<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - Motivating the Foldable Type Class</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="../">Home</a> <br>
              <a href="../about.html">About</a> <br>
              <a href="../archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <h2 class="post"> Motivating the Foldable Type Class </h2>
<div class="info">
    Posted on September 16, 2016
    
</div>

<p>Something I have never seen articulated is why the <code>Foldable</code> type class exists. It is lawless apart from the free theorems which leads to ad-hoc definitions of its methods. What use is the abstraction if not to enable us to reason more easily about our programs? This post aims to articulate some justification stemming from the universality of folds.</p>
<p>In brief, here is the argument.</p>
<ol style="list-style-type: decimal">
<li>For inductive data types, the fold is unique defined as a consequence of initiality.</li>
<li>The <code>Foldable</code> type class is a way to exploit this universality without having to define all of our data types as the fixed points of base functors.</li>
<li>The uneasiness comes from this impedence mismatch between points 1 and 2.</li>
</ol>
<!--more-->
<p>To recall, the type class is meant to capture the intuitive notion of a fold. Folds are a way of consuming a data type by summarising values in a uniform manner before combining them together.</p>
<p>We now recall the basics of initial algebra semantics for polynomial data types.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> We can represent all data types as the fixed point of a polynomial functor. In Haskell we can represent the fixed point by the data type <code>Mu</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> {<span class="ot"> out ::</span> (f (<span class="dt">Mu</span> f)) }

<span class="co">-- Inital algebra</span>
<span class="kw">in</span><span class="ot"> ::</span> f (<span class="dt">Mu</span> f) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f
<span class="kw">in</span> <span class="fu">=</span> <span class="dt">Mu</span></code></pre></div>
<p>We then specify data types by first defining a control functor <span class="math inline">\(F\)</span> and then considering the initial <span class="math inline">\(F\)</span>-algebra for the functor. The initial <span class="math inline">\(F\)</span>-algebra is given by <span class="math inline">\((\mu F, in)\)</span>. The injection function <span class="math inline">\(in\)</span> wraps up one level of the recursion. The projection function <code>out</code> strips off one layer of the recursion.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>We can define the type of lists by first specifying a control functor <span class="math inline">\(ListF = 1 + (A \times \_)\)</span> and then defining lists in terms of this base functor and <code>Mu</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r

<span class="kw">type</span> <span class="dt">ListM</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">ListF</span> a)</code></pre></div>
<p>We call types which are definable in this manner <em>inductive</em> types.</p>
<p>We do not usually define data types in this style as programming directly with them is quite cumbersome as one must wrap and unwrap to access the recursive structure.</p>
<p>However, defining data in this manner has some useful properties. The one that we care about is that it is possible to define a generic fold operator for inductive types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cata ::</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a
cata f <span class="fu">=</span> f <span class="fu">.</span> fmap (cata f) <span class="fu">.</span> out</code></pre></div>
<p>What’s more, due to initiality, <code>cata f</code> is the unique function of this type. We have no choice about how we define a fold operator after we have described how to interpret the control functor.</p>
<p>Fleshed out in some more detail, Given a functor <span class="math inline">\(F\)</span>, for any other algebra <span class="math inline">\((B, g : F B \to B)\)</span> there exists a unique map <span class="math inline">\(h\)</span> to this algebra from <span class="math inline">\((\mu F, in)\)</span>. Our definition of <code>cata</code> is precisely the way to construct this unique map.</p>
<h1 id="real-world-haskell">Real-World Haskell</h1>
<p>Languages such as Haskell allow users to define data types in a more ad-hoc fashion by specifying the recursive structure themselves rather than in terms of a base functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<p>It can be easily seen that <code>Mu (ListF a) ~= List a</code> and thus we can exploit the university of the fold function and define a canonical fold function specialised to our newly defined data type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p><code>foldr</code> is a specialisation of <code>cata</code> to lists. It is perhaps clearer to see the correspondence if we rewrite the function to explicitly take a list algebra as it’s first argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListAlg</span> a b <span class="fu">=</span> <span class="dt">ListAlg</span> (<span class="ot"> z ::</span> () <span class="ot">-&gt;</span> b ,<span class="ot"> cons ::</span> (a, b) <span class="ot">-&gt;</span> b }

foldr<span class="ot"> ::</span> <span class="dt">ListAlg</span> a b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Specifying a function <code>ListF a b -&gt; b</code> is precisely the same as specifying <code>ListAlg a b</code> as it amounts to specifying functions <span class="math inline">\(1 \to b\)</span> and <span class="math inline">\(a \times b \to b\)</span>.</p>
<p>So, for each data type we define we can specialise the <code>cata</code> operator in order to define a canonical fold operator. However, the issue now is that each one of our fold operators has a different type. It would be useful to still be able to provide a consistent interface so that we can still fold any inductive type. The answer to this problem is <code>Foldable</code>.</p>
<p>This highlights the essential tension with the <code>Foldable</code> type class. It exists in order to be able to continue to define a generic fold operation but without the cost of defining our data types in terms of fixed points and base functors.</p>
<h1 id="foldable"><code>Foldable</code></h1>
<p>The method <code>foldr</code> is the only method needed to define an instance of <code>Foldable</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span>
<span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</code></pre></div>
<p>It turns out that <code>(a -&gt; b -&gt; b)</code> and a single constant <code>b</code> are sufficient for specifying algebras for inductive types. Inductive types are built from polynomial base functors so we can describe an algebra by first matching on the summand and then iteratively applying the combining function to combine each recursive position. If there are no recursive positions, we instead use the zero value <code>z</code>.</p>
<p>Defining the instance for lists is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> [] <span class="kw">where</span>
  foldr _ z [] <span class="fu">=</span> z
  foldr f _ (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f xs)</code></pre></div>
<p>As another example, we consider writing an instance for binary trees which only contain values at leaves. It is less obvious then how to implement this interface as the usual fold has a different type signature. We can do so by cleverly instantiating the result type <code>b</code> when performing the recursive calls.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldTree ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span>
<span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b
  foldr f z t <span class="fu">=</span>
    <span class="kw">case</span> t <span class="kw">of</span>
      <span class="dt">Leaf</span> a <span class="ot">-&gt;</span> f a z
      <span class="dt">Branch</span> l r <span class="ot">-&gt;</span> foldr (\a c <span class="ot">-&gt;</span> f a <span class="fu">.</span> c) id l
                   		(foldr f z r)</code></pre></div>
<p>The first recursive call of <code>foldr</code> returns a function of type <code>b -&gt; b</code> which tells us how to combine the next recursive occurence. In this case there are only two recursive positions but this process can be iterated to combine all the recursive holes.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>The definition for <code>foldMap</code> usually provides a more intuitive interface for defining instances but it is harder to motivate which is why we prefer <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldMapTree ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> m
foldMapTree f (<span class="dt">Leaf</span> a) <span class="fu">=</span> f a
foldMapTree f (<span class="dt">Branch</span> l r) <span class="fu">=</span> foldMapTree f l <span class="fu">&lt;&gt;</span> foldMapTree f r</code></pre></div>
<p>For inductive types the intuitive way to define instances coincides with the canonical definition given by initiality. Class instances defined in this way are clearly well-motivated.</p>
<h1 id="conclusion">Conclusion</h1>
<p>The definition of <code>Foldable</code> is motivated by the well-understood theory of inductive data types. The pragmatics of Haskell lead us to the seemingly quite ad-hoc class definition which has generated much discussion in recent years. The goal of this post was to argue that the class is better founded than people think and to explain some of the reasons that it leads to some uncomfort.</p>
<p>My argument is not about deciding whether an ad-hoc definition is lawful, it is explaining the motivation for the class in a way which also explains the lawlessness. The class definition is a compromise because of the practicalities of Haskell. The only way in which we can know a definition is sensible or not is by inspecting whether the ad-hoc definition agrees with the canonical definition given by <code>cata</code>.</p>
<h1 id="appendix-free-theorems-of-foldr">Appendix: Free Theorems of <code>foldr</code></h1>
<p>There are some free theorems for <code>foldr</code> which is natural in <code>a</code> and <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Naturality in <code>b</code> amounts to, for all functions <code>g : b -&gt; c</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">g (foldr f z t) <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f x (g y)) (g z)</code></pre></div>
<p>and naturality in <code>a</code> amounts to, for all functions <code>f : c -&gt; a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f z <span class="fu">.</span> fmap h <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f (h x) y) z</code></pre></div>
<p>These are included for completeness.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>From now on when we say data type, we mean polynomial data type.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Lambek’s lemma tells us that the two functions are each other’s inverse.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Notice that we are only able to fold type constructors of kind <code>* -&gt; *</code>, this is an arbritary choice, motivated by the fact that most containers which we wish to fold are polymorphic in one way. (For example, lists and trees).<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Note that I didn’t think of this definiton myself but arrived at it purely calculationally from the definition of <code>foldMap</code> and <code>foldr</code>.<a href="#fnref4">↩</a></p></li>
</ol>
</div>

        <div id="footer">
          <a href="../atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
