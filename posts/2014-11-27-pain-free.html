<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - Pain Free Unfix with Pattern Synonyms</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="../">Home</a> <br>
              <a href="../about.html">About</a> <br>
              <a href="../archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <h2 class="post"> Pain Free Unfix with Pattern Synonyms </h2>
<div class="info">
    Posted on November 27, 2014
    
</div>

<p>Pattern synonyms are a great feature.</p>
<p>It is common to define closed data types. Later if one wants to annotate their syntax tree or pass along any other additional information this can cause significant problems. A clean solution is to redefine the data type using open recursion and then taking the fixed point.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> This approach allows great flexibility and access to uniform <a href="http://hackage.haskell.org/package/recursion-schemes">recursion schemes</a> but used to come at a cost. If the library writer had exposed the constructors, all existing user code would break with these changes. Since GHC 7.10, patterns allow us to completely swap out the underlying data type whilst maintaining the original interface.</p>
<!--more-->
<p>Here’s how. Consider Hutton’s Razor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hutton</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Hutton</span> <span class="dt">Hutton</span></code></pre>
<p>Typically there will be many different operations defined as traversals of the syntax tree. One might typically be an evaluator.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Hutton</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">Int</span> n) <span class="fu">=</span> n
eval (<span class="dt">Add</span> n m) <span class="fu">=</span> eval n <span class="fu">+</span> eval m</code></pre>
<p>Later, we might want to define the unfixed version of <code>Hutton</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HuttonF</span> a <span class="fu">=</span> <span class="dt">IntF</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">AddF</span> a a <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))

<span class="kw">type</span> <span class="dt">Hutton</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">HuttonF</span></code></pre>
<p>Unfortunately, we can no longer use any of our existing functions. Fortunately, using pattern synonyms we can regain this functionality.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">pattern (<span class="dt">Int</span> n) <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">IntF</span> n)
pattern (<span class="dt">Add</span> x y) <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">AddF</span> x y)</code></pre>
<p>This is as far as GHC 7.8 will take us. To move further we need to take advantage of <a href="https://ghc.haskell.org/trac/ghc/ticket/8581">explicitly-bidirectional pattern synonyms</a> which are set to be introduced in GHC 7.10. These allow us to explicitly specify the constructor as well as the pattern. Useless in this case but what if we also wanted to annotate out AST?</p>
<p>To do so it is usual to define a product type, <code>Annotate</code>,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Annotate</span> f <span class="fu">=</span> <span class="dt">Annotate</span> <span class="dt">Label</span> (f (<span class="dt">Annotate</span> f))</code></pre>
<p>which we can then take the fixed point to get an annotated AST.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Annotated</span> <span class="fu">=</span> <span class="dt">Annotate</span> <span class="dt">Hutton</span></code></pre>
<p>Now we want to be able to keep using our existing functions for both annotated and unannotated values. The catch is that we can only have one pattern which corresponds to each constructor. To get around this we can use view patterns and a type class in order to use the same pattern for both our annotated and unannotated AST.</p>
<p><code>View</code> provides an injection and projection function. Then defining suitable instances for <code>Annotated</code> and <code>Hutton</code>, we can reuse all of our previous definitions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">View</span> a <span class="kw">where</span>
<span class="ot">  proj ::</span> a <span class="ot">-&gt;</span> <span class="dt">HuttonF</span> a
<span class="ot">  inj ::</span> <span class="dt">HuttonF</span> a <span class="ot">-&gt;</span> a

pattern <span class="dt">I</span> n <span class="ot">&lt;-</span> (proj <span class="ot">-&gt;</span> <span class="dt">IF</span> n) <span class="kw">where</span>
  <span class="dt">I</span> n <span class="fu">=</span> inj (<span class="dt">IF</span> n)

pattern <span class="dt">Add</span> a b <span class="ot">&lt;-</span> (proj <span class="ot">-&gt;</span> <span class="dt">AddF</span> a b) <span class="kw">where</span>
  <span class="dt">Add</span> a b <span class="fu">=</span> inj (<span class="dt">AddF</span> a b)


<span class="kw">instance</span> <span class="dt">View</span> <span class="dt">Hutton</span> <span class="kw">where</span>
  proj <span class="fu">=</span> unFix
  inj <span class="fu">=</span> <span class="dt">Fix</span>

<span class="kw">instance</span> <span class="dt">View</span> <span class="dt">Annotated</span> <span class="kw">where</span>
  proj (<span class="dt">Annotated</span> _ e) <span class="fu">=</span> e
  inj v <span class="fu">=</span> <span class="dt">Annotated</span> (mkLabel v) v

<span class="ot">mkLabel ::</span> <span class="dt">HuttonF</span> <span class="dt">Annotated</span> <span class="ot">-&gt;</span> <span class="dt">Label</span></code></pre>
<p>So far so good. Let’s test out our sample program.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">View</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">I</span> n) <span class="fu">=</span> n
eval (<span class="dt">Add</span> a b) <span class="fu">=</span> eval a <span class="fu">+</span> eval b

p1 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">I</span> <span class="dv">5</span>) (<span class="dt">I</span> <span class="dv">6</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> p2 <span class="fu">=</span><span class="ot"> p1 ::</span> <span class="dt">Hutton</span>
  <span class="kw">let</span> p3 <span class="fu">=</span><span class="ot"> p1 ::</span> <span class="dt">Annotated</span>
  print (eval p2)
  print (eval p3)

<span class="fu">&gt;</span> <span class="fu">./</span>patterns
<span class="dv">11</span>
<span class="dv">11</span></code></pre>
<p>To take stock for a moment - using technology available in GHC 7.8 we were able to swap out our standard data type and replace it with an unfixed variant. Then with machinery available to us in GHC 7.10, we were able to vary this underlying type as long as we could provide suitable mapping functions.</p>
<p>Looking back at our definition of <code>inj</code> for <code>Annotated</code>, depending on what we want the label to be, it could make little sense to fill in the annotation whilst we are building the AST. It seems sensible to separate our <code>View</code> typeclass into two separate classes, one for projection and one for injection as they might not both make sense for all data types. Indeed if we introduce one more example, it is clear that they don’t.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Holey</span> f <span class="fu">=</span> <span class="dt">Hole</span> <span class="fu">|</span> <span class="dt">Expr</span> (f (<span class="dt">Holey</span> f))

<span class="kw">type</span> <span class="dt">HuttonHole</span> <span class="fu">=</span> <span class="dt">Holey</span> <span class="dt">HuttonF</span></code></pre>
<p>This union type represents syntax trees which might have holes in. Clearly there is no total definition of <code>proj</code> so we redefine our type classes as follows.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Project</span> a <span class="kw">where</span>
<span class="ot">  proj ::</span> a <span class="ot">-&gt;</span> <span class="dt">HuttonF</span> a

<span class="kw">class</span> <span class="dt">Inject</span> a <span class="kw">where</span>
<span class="ot">  inj ::</span> <span class="dt">HuttonF</span> a <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Inject</span> <span class="dt">HuttonHole</span> <span class="kw">where</span>
  inj <span class="fu">=</span> <span class="dt">Expr</span></code></pre>
<p>Now we <em>should</em> be able to use this data type very naturally to construct trees which might contain holes and later fill in the holes with whatever we please.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hole ::</span> <span class="dt">HuttonHole</span>
hole <span class="fu">=</span> <span class="dt">Hole</span>

<span class="ot">p4 ::</span> <span class="dt">HuttonHole</span>
p4 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">I</span> <span class="dv">5</span>) hole

<span class="ot">fillHole ::</span> (<span class="dt">Hole</span> <span class="ot">-&gt;</span> <span class="dt">Hutton</span>) <span class="ot">-&gt;</span> <span class="dt">HuttonHole</span> <span class="ot">-&gt;</span> <span class="dt">Hutton</span>
fillHole f <span class="dt">Hole</span> <span class="fu">=</span> f <span class="dt">Hole</span>
fillHole _ (<span class="dt">Expr</span> v) <span class="fu">=</span> v</code></pre>
<p>Unfortunately we have pushed pattern synonyms a little bit too far. Instead of sweet sweet compilation, we are greeted with the following error message for each of the patterns.</p>
<pre><code>Could not deduce (Inject a) arising from a use of ‘inj’
    from the context (Project a)
      bound by the type signature for Main.I :: Project a =&gt; Int -&gt; a
      at patterns.hs:1:1
    Possible fix:
      add (Inject a) to the context of
        the type signature for Main.I :: Project a =&gt; Int -&gt; a
    In the expression: inj' (IF n)
    In an equation for ‘I’: I n = inj (IF n)</code></pre>
<p>GHC baulks at the fact that we have different class constraints for the pattern and constructor. I don’t think there is any reason that they <em>need</em> to have the same constraints but it might be desirable so that constructors, even synonyms, continue to match up with patterns.</p>
<p>There are many powerful abstractions in Haskell which allow a library maintainer to provide a consistent interface across interactions. Unfortunately, if they ever chose to expose their internal syntax tree to the end-user, it was previously very difficult to maintain backwards compatibility. Pattern synonyms provide the perfect tool to do just this but they don’t appear to stretch quite far enough to tackle all interesting use cases.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’ve been meaning to put this post up for a while but <a href="http://stackoverflow.com/questions/27157717/boilerplate-free-annotation-of-asts-in-haskell">this</a> stack overflow answer prompted me to finish up the post. As a result, the examples I use here are heavily inspired by it.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

        <div id="footer">
          <a href="../atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
