<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - Pattern Synonyms in GHC 8.0</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="../">Home</a> <br>
              <a href="../about.html">About</a> <br>
              <a href="../archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <h2 class="post"> Pattern Synonyms in GHC 8.0 </h2>
<div class="info">
    Posted on December 12, 2015
    
</div>

<p>There have been four small but significant improvements to pattern synonyms which are going to appear in GHC 8.0.</p>
<p>This work closes up some holes which were left in the implementation of pattern synonyms and should provide library authors with a new and flexible method of abstraction.</p>
<p>More information about pattern synonyms can be found in the <a href="http://mpickering.github.io/users_guide/glasgow_exts.html#pattern-synonyms">GHC 8.0 user guide</a>.</p>
<!--more-->
<h3 id="record-pattern-synonyms">Record Pattern Synonyms</h3>
<p>The biggest update extends pattern synonyms to allow the construction of pattern synonyms which behave like record data constructors.</p>
<p>Since GHC 7.8 you have been able to define prefix and infix pattern synonyms which behave like normal data constructors. With the addition of record pattern synonyms most data constructors can be replicated by pattern synonyms.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>To make this clear, consider the data constructor <code>Just</code>. We can use this constructor in two contexts, in a pattern match or in an expression context to construct a value.</p>
<p>If we defined the pattern synonym <code>MyJust</code>, we can use it in precisely the same contexts as <code>Just</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyJust</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
pattern <span class="dt">MyJust</span> a <span class="fu">=</span> <span class="dt">Just</span> a</code></pre></div>
<p>Similarly, record data constructors can be used in seven contexts.</p>
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Usage</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>As a constructor</p></td>
<td><p><code>zero = Point 0 0</code></p></td>
</tr>
<tr class="even">
<td><p>As a constructor with record syntax</p></td>
<td><p><code>zero = Point { x = 0, y = 0}</code></p></td>
</tr>
<tr class="odd">
<td><p>In a pattern context</p></td>
<td><p><code>isZero (Point 0 0) = True</code></p></td>
</tr>
<tr class="even">
<td><p>In a pattern context with record syntax</p></td>
<td><p><code>isZero (Point { x = 0, y = 0 }</code></p></td>
</tr>
<tr class="odd">
<td><p>In a pattern context with field puns</p></td>
<td><p><code>getX (Point {x}) = x</code></p></td>
</tr>
<tr class="even">
<td><p>In a record update</p></td>
<td><p><code>(0, 0) { x = 1 } == (1,0)</code></p></td>
</tr>
<tr class="odd">
<td><p>Using record selectors</p></td>
<td><p><code>x (0,0) == 0</code></p></td>
</tr>
</tbody>
</table>
<p>Record pattern synonyms are defined as follows and can also be used in these seven contexts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyPoint</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
pattern <span class="dt">MyPoint</span>{x, y} <span class="fu">=</span> (x,y)</code></pre></div>
<p>Projection functions, <code>x</code> and <code>y</code> are defined like record selectors for ordinary constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">y ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Because we defined this pattern synonym, tuples can now be updated with record update syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> (<span class="dv">0</span>,<span class="dv">0</span>) { x <span class="fu">=</span> <span class="dv">5</span> }
(<span class="dv">5</span>, <span class="dv">0</span>)</code></pre></div>
<h3 id="bundling-pattern-synonyms">Bundling Pattern Synonyms</h3>
<p>Since pattern synonyms are a lot like data constructors, they should be able to be imported just like data constructors. To put it another way a user should be unaware whether they are using a pattern synonym or a data constructor.</p>
<p>However, before GHC 8.0, there has been quite an awkward distinction between the two. Data constructors couldn’t be imported or exported separated from the type which they construct. On the other hand, pattern synonyms could only be imported and exported individually by using the <code>pattern</code> keyword. This meant that consumers had to be aware that whether they were importing a pattern synonym or not! No good!</p>
<p>Now there are two ways which we can export the pattern synonym <code>P :: A</code>.</p>
<ol style="list-style-type: decimal">
<li><p>Separately, as before, by using the <code>pattern</code> keyword.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> (pattern <span class="dt">P</span>) <span class="kw">where</span></code></pre></div></li>
<li><p>Bundled with the relevant type constructor</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> ( <span class="dt">A</span>(<span class="dt">P</span>) ) <span class="kw">where</span></code></pre></div>
<p>or to export all of <code>A</code>’s constructors along with the pattern synonym <code>P</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> ( <span class="dt">A</span>(<span class="fu">..</span>, <span class="dt">P</span>) ) <span class="kw">where</span></code></pre></div></li>
</ol>
<p>In this second case, if another module imports <code>Foo</code> then <code>P</code> can be imported alongwith <code>A</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Will import P</span>
<span class="kw">import </span><span class="dt">Foo</span> (<span class="dt">A</span> (..))</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Will import P</span>
<span class="kw">import </span><span class="dt">Foo</span> (<span class="dt">A</span> (<span class="dt">P</span>))</code></pre></div>
<h4 id="an-example-errorcall">An Example: <code>ErrorCall</code></h4>
<p>This problem reared its head in one of the first serious uses of pattern synonyms. In GHC 8 a pattern synonym <code>ErrorCall</code> is introduced into the base library to smooth over changes in the internal representation caused by Eric Seidel’s work on call stacks.</p>
<p>The datatype <code>ErrorCall</code> previously just had one synonymous constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCall</span> <span class="dt">String</span></code></pre></div>
<p>After the <a href="https://phabricator.haskell.org/D861">refactoring</a>, the single constructor was renamed to <code>ErrorCallWithLocation</code> but Eric wanted to smooth over the transition by providing a pattern synonym which would behave much like before.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span>

pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span>
pattern <span class="dt">ErrorCall</span> s <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> s _ <span class="kw">where</span>
  <span class="dt">ErrorCall</span> s <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> s <span class="st">&quot;&quot;</span></code></pre></div>
<p>However clients importing <code>ErrorCall(..)</code> found that despite the careful efforts of the library author this change broke their code. The problem being that by default, it is necessary to explicitly import pattern synonyms.</p>
<p>With this feature, we can now bundle the new <code>ErrorCall</code> pattern synonym in the export list of the module so that users importing <code>ErrorCall(..)</code> will also import the pattern synonym.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GHC.Exception</span> ( <span class="dt">ErrorCall</span>(<span class="fu">..</span>, <span class="dt">ErrorCall</span>) ) <span class="kw">where</span></code></pre></div>
<h3 id="pattern-synonym-signatures">Pattern Synonym Signatures</h3>
<p>Pattern synonyms can also have type signatures. The syntax is very similar to normal type signatures but there are two sets of constraints rather than the usual one which correspond to “required” and “provided” constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> provided <span class="ot">=&gt;</span> <span class="kw">type</span></code></pre></div>
<p>In the common case that there are no provided constraints, it is possible to omit the first set of constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> <span class="kw">type</span></code></pre></div>
<p>and in the even more common case when there are no constraints, both can be omitted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> <span class="kw">type</span></code></pre></div>
<p><em>Required</em> constraints are constraints which are required in order to make a match. For example, we could provide the quite silly pattern synonym which uses <code>show</code> to check whether a pattern should match. As <code>show</code> is from the <code>Show</code> typeclass, we have to add it to the required constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">IsTrue</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a
pattern <span class="dt">IsTrue</span> <span class="ot">&lt;-</span> ((<span class="fu">==</span> <span class="st">&quot;True&quot;</span>) <span class="fu">.</span> show <span class="ot">-&gt;</span> <span class="dt">True</span>)</code></pre></div>
<p><em>Provided</em> constraints are constraints which are made available on a successful match. This usually occurs when matching on a GADT with an existential type.</p>
<p>In fact, it only makes sense for provided constraints to mention existentially quantified type variables which explains why they are less often used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="kw">where</span>
  <span class="dt">MkT</span><span class="ot"> ::</span> (<span class="dt">Show</span> b) <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span>

pattern <span class="dt">ExNumPat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> b <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span>
pattern <span class="dt">ExNumPat</span> x <span class="fu">=</span> <span class="dt">MkT</span> x</code></pre></div>
<p>Pattern synonym signatures aren’t new for GHC 8.0 but the order of required and provided constraints has been switched.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h3 id="warnings-for-missing-pattern-synonym-signatures">Warnings for missing pattern synonym signatures</h3>
<p>The final small change is that GHC can also warn about any pattern synonym which doesn’t have a type signature. The warning is turned on by the flag <code>-fwarn-missing-pat-syn-sigs</code> and is also enabled by <code>-Wall</code>.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is one exception which is a datatype which has record constructors which share field names. <code>data A = B { a :: Int } | C { a :: Int, b :: Int }</code><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In previous versions, provided constraints appeared before required constraints and if only one set was given then it was assumed to be the provided rather than required constraints.<a href="#fnref2">↩</a></p></li>
</ol>
</div>

        <div id="footer">
          <a href="../atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
