<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - Why do pattern synonyms not cause type refinement?</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="../">Home</a> <br>
              <a href="../about.html">About</a> <br>
              <a href="../archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <h2 class="post"> Why do pattern synonyms not cause type refinement? </h2>
<div class="info">
    Posted on June 18, 2016
    
</div>

<p>Pattern synonyms can’t (safely) cause any additional type refinement than their definition dictates. This means that they can’t be used to provide a GADT-like interface when the underlying representation is not a GADT. The purpose of this note is to explain this restriction.</p>
<!--more-->
<p>The defining feature of GADTs is that the constructors can bind dictionaries for constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CaptureShow</span> a <span class="kw">where</span>
  <span class="dt">CaptureShow</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a</code></pre></div>
<p>When the constructor is matched upon, the constraints are <em>provided</em> to the local environment.</p>
<p>When the constraints are equality constraints, this causes type refinement. We learn more about the result type from performing the match.</p>
<p>We can use pattern synonyms to abstract GADTs. The second set of constraints is the set of provided constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyCaptureShow</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a
pattern <span class="dt">MyCaptureShow</span> <span class="fu">=</span> <span class="dt">CaptureShow</span></code></pre></div>
<p>But, the set of provided constraints must be exactly those constraints which the underlying constructor provides. This is different to <em>required</em> constraints which can be more specific than needed.</p>
<p>Why is this the case? One might expect that if additional constraints were specified then the pattern synonym could bind the needed dictionaries when building and release them when matching. However, <strong>not all values which can be destructed with a pattern synonym must be constructed with a pattern synonym</strong>.</p>
<p>For example, we would be able to specify an unsatisfiable constraint in the provided context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">Unsat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (<span class="ch">'True ~ '</span><span class="dt">False</span>) <span class="ot">=&gt;</span> <span class="dt">Int</span>
pattern <span class="dt">Unsat</span> <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>If we did the same in a GADT it would be impossible to construct such a value, similary here we can’t use <code>Unsat</code> to construct an <code>Int</code> as we will never be able to satisfy the equality constraint. However, if it were possible to define such a pattern synonym we would be able to use it to match on <code>0</code>. Doing so would provide the bogus constraint.</p>
<p>There is a more immediate reason why this will never work. For type class constraints, the dictionaries must be bound when the constructor is used to construct values. If the pattern synonym is not used to construct the value then we can’t conjure it up out of thin air when we need it.</p>
<p>This wasn’t obvious to me, which is why it is now written down. Pattern synonym signatures are surprisingly tricky.</p>
<h1 id="addendum">Addendum</h1>
<p>David Feuer and Edward Yang conspired to show that using <code>unsafeCoerce</code> it was possible to provide additional type equalities. The key to the approach is to use a dummy GADT which is used to actually do the refining. Our more efficient representation is upcasted to this GADT, then by matching on the constructor, we cause refinement. Here is Edward’s code:</p>
<pre><code>{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE GADTs #-}
{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
module GhostBuster where

import GHC.TypeLits
import Unsafe.Coerce

newtype Vec a (n :: Nat) = Vec { unVec :: [a] }

-- &quot;Almost&quot; Vec GADT, but the inside is a Vec
-- (so only the top-level is unfolded.)
data Vec' a (n :: Nat) where
    VNil'  :: Vec' a 0
    VCons' :: a -&gt; Vec a n -&gt; Vec' a (n + 1)

upVec :: Vec a n -&gt; Vec' a n
upVec (Vec [])     = unsafeCoerce VNil'
upVec (Vec (x:xs)) = unsafeCoerce (VCons' x (Vec xs))

pattern VNil :: () =&gt; (n ~ 0) =&gt; Vec a n
pattern VNil &lt;- (upVec -&gt; VNil') where
    VNil = Vec []

pattern VCons :: () =&gt; ((n + 1) ~ n') =&gt; a -&gt; Vec a n -&gt; Vec a n'
pattern VCons x xs &lt;- (upVec -&gt; VCons' x xs) where
    VCons x (Vec xs) = Vec (x : xs)

headVec :: Vec a (n + 1) -&gt; a
headVec (VCons x _) = x

mapVec :: (a -&gt; b) -&gt; Vec a n -&gt; Vec b n
mapVec f VNil = VNil
mapVec f (VCons x xs) = VCons (f x) (mapVec f xs)</code></pre>
<p>If we were to change the definition of the nil case of <code>mapVec</code> to use <code>VCons</code> instead then it wouldn’t type check.</p>
<div id="refs" class="references">

</div>

        <div id="footer">
          <a href="../atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
