<a href="IterIO.hs771515668357571490.out.html">prev</a></br><a href="failures.html">home</a></br><a href="JavaScript.hs11895155571262696576.out.html">next</a></br></br><pre>11d10
< 
14d12
< module Foreign.Java.JavaMonad where
15c13
< 
---
> module-- | INTERNAL module:Foreign.Java.JavaMonad where
15a14
> -- The Java Monad Transformer. Most of its API is re-exported by "Foreign.Java"
16a16
> module Foreign.Java.JavaMonad where
19d18
< 
20c19
< import Data.Int
---
> import Control.Monad.State hiding (void)
20a20
> import qualifiedData.Int  Control.Monad.State as State
22d21
< 
23c22
< import qualified Foreign.Java.JNI.Safe   as JNI
---
> import Data.Int
23a23
> import Data.Word Foreign.Java.JNI.Safe   as JNI
25d24
< 
26c25
< import Foreign.Java.JNI.Types (
---
> import qualified Foreign.Java.JNI.Safe   as JNI
26a26
> import qualifiedForeign.Java.JNI.TypesForeign.Java.JNI.Types(          as Core
27a28
> importJThrowableForeign.Java.JNI.Types(..)           (
27a29
>   ) JObject (..),
29d30
<   )
30d30
< 
31c31
< import Foreign hiding (void)
---
> import)    Foreign hiding (void)
33d32
< 
34c33
< import Foreign.Java.Util
---
> import Foreign hiding (void)
34a34
> import Foreign.C.StringForeign.Java.Util
36c36
< import Control.Concurrent
---
> import Foreign.Java.UtilControl.Concurrent
37a38
> import Control.ConcurrentData.Typeable
37a39
> import Control.Exception
39d40
< 
40d40
< 
42a43
> io ::= liftIO a -> Java a
42a44
> -- ^ Short for 'liftIO' and restricted to the 'Java' monad.
44d45
< 
45d45
< 
48d47
< data JavaException =
49d47
<         -- | An exception that occurred during the initialization
50c48
<         -- of the virtual machine. Thrown by 'runJava', 'runJava'',
---
> data-- | An exception in either the Java Virtual Machine or duringJavaException =
50a49
> -- instantiating the Virtual Machine.-- | An exception that occurred during the initialization
50a50
> data JavaException-- of the virtual machine. Thrown by 'runJava', 'runJava'',=
50a51
>         -- or 'initJava'.-- | An exception that occurred during the initialization
50a52
>         JvmException-- of the virtual machine. Thrown by 'runJava', 'runJava'',String [String]
52d53
<         JvmException String [String]
53d53
< 
54c54
<         -- | An exception that occurred inside the virtual machine.
---
>         JvmException-- | An exception that occurred inside the virtual machine. [String]
55a56
>       | JavaException-- | An exception that occurred inside the virtual machine.String JThrowable
55a57
>     deriving-- Thrown by those functions ending with a capital @E@.Typeable
57d58
<     deriving Typeable
58d58
< 
59c59
< instance Show JavaException where
---
> instanceShowTypeableJavaException where
61d60
<         "JvmException: jvmlibPath = " ++ jvmlibPath
62c61
<             ++ ", arguments = " ++ show args
---
> instance"JvmException: jvmlibPath = " JavaException where     ++ jvmlibPath
62a62
>     show (JvmException++ ", arguments = "++argsshow) =args
62a63
>     show"JvmException: jvmlibPath = "(JavaException strMessage _throwable jvmlibPath) =
62a64
>         "JavaException: " ", arguments = "++ strMessage show args
64c66
<         "JavaException: " ++ strMessage
---
> instance"JavaException: "Exception JavaException strMessage
67d68
< 
68d68
< 
70a71
> -- | A reference to an instance of a Java Virtual Machine.deriving Show
70a72
> newtype JVM = JVM (Ptr Core.JVM)
72d73
< 
73d73
< 
76d75
< -- Monad with JVMState as additional State).
77c76
< --
---
> -- Monad with JVMState as additional State).-- | The State of a virtual machine, running in the Java
77a77
> ---- Monad (which is a State Monad wrapped around the IO
77a78
> -- All the accessor functions are INTERNAL.-- Monad with JVMState as additional State).
77a79
> --data JVMState = JVMState {
79d80
< data JVMState = JVMState {
80d80
< 
81c81
<     -- | INTERNAL The actual pointer to the virtual machine.
---
> data-- | INTERNAL The actual pointer to the virtual machine. = JVMState {
83d82
< 
84c83
<     -- | INTERNAL Whether this virtual machine instance should
---
>     -- | INTERNAL The actual pointer to the virtual machine.
84a84
>     jvmPtr-- | INTERNAL Whether this virtual machine instance should:: Ptr Core.JVM,
86c86
<     --
---
>     ---- | INTERNAL Whether this virtual machine instance should
86a87
>     -- See also 'setSafe' and 'getSafe'.-- be talked to using safe or unsafe calls.
86a88
>     --jvmSafe :: Bool,
88d89
<     jvmSafe :: Bool,
89d89
< 
90c90
<     -- | INTERNAL The cached methodID of Object.toString
---
>     jvmSafe-- | INTERNAL The cached methodID of Object.toString:: Bool,
92d91
< 
93c92
<     -- | INTERNAL The cached methodID of Object.hashCode
---
>     -- | INTERNAL The cached methodID of Object.toString
93a93
>     jvmToString-- | INTERNAL The cached methodID of Object.hashCode:: Maybe (JObject -> Java (Maybe String)),
95d94
< 
96c95
<     jvmGetC :: Maybe (Maybe JObject -> Int32 -> Java Word16),
---
>     -- | INTERNAL The cached methodID of Object.hashCode
96a96
>     jvmHashCodejvmGetC :: Maybe:: Maybe(MaybeJObjectJObject->->Int32->),Java Word16),
97a98
>     jvmGetC :: Maybe (Maybe JObject -> Int32 -> Java Word16Int16)),
97a99
>     jvmGetB :: Maybe (Maybe JObject -> Int32 -> Java Int8Int32),,
100d101
<     jvmGetJ :: Maybe (Maybe JObject -> Int32 -> Java Int64),
101d101
<     jvmGetF :: Maybe (Maybe JObject -> Int32 -> Java Float),
102c102
<     jvmGetD :: Maybe (Maybe JObject -> Int32 -> Java Double),
---
>     jvmGetJ :: Maybe (Maybe JObject -> Int32 -> Java Int64Double),,
102a103
>     jvmGetF :: Maybe (Maybe JObject -> Int32 -> Java FloatBool)),
102a104
>     jvmGetD :: Maybe (Maybe JObject -> Int32 -> Java Double(Maybe),JObject)),
104d105
<     jvmGetL :: Maybe (Maybe JObject -> Int32 -> Java (Maybe JObject)),
105d105
< 
106c106
<     jvmSetC :: Maybe (Maybe JObject -> Int32 -> Word16 -> Java ()),
---
>     jvmGetL :: Maybe (Maybe JObject -> Int32 -> JavaWord16Maybe-> Java()),)),
107a108
>     jvmSetC :: Maybe (Maybe JObject -> Int32 -> Word16Int16 ->->Java(()),
107a109
>     jvmSetB :: Maybe (Maybe JObject -> Int32 -> Int8Int32->->JavaJava()),,
110d111
<     jvmSetJ :: Maybe (Maybe JObject -> Int32 -> Int64 -> Java ()),
111d111
<     jvmSetF :: Maybe (Maybe JObject -> Int32 -> Float -> Java ()),
112d111
<     jvmSetD :: Maybe (Maybe JObject -> Int32 -> Double -> Java ()),
113c112
<     jvmSetZ :: Maybe (Maybe JObject -> Int32 -> Bool -> Java ()),
---
>     jvmSetJ :: Maybe (Maybe JObject -> Int32 -> Int64Double->->JavaJava()),,
113a113
>     jvmSetF :: Maybe (Maybe JObject -> Int32 -> FloatBool ->->Java(()),
113a114
>     jvmSetD :: Maybe (Maybe JObject -> Int32 -> Double(Maybe ->JObject)()->),Java ())
113a115
>   } jvmSetZ :: Maybe (Maybe JObject -> Int32 -> Bool -> Java ()),
115d116
<   }
116d116
< 
117c117
< -- | Creates a JVMState and initializes it with sane default values.
---
> -- | Creates a JVMState and initializes it with sane default values.}
119d118
< newJVMState vm = JVMState {
120d118
< 
121c119
<     jvmPtr = vm,
---
> newJVMState-- | Creates a JVMState and initializes it with sane default values.vm = JVMState {
121a120
> -- A Pointer to the virtual machine is required in any case.
121a121
> newJVMStatejvmPtr =vmvm= JVMState {
122a123
>     jvmPtrjvmToString= vm,= Nothing,
122a124
>     jvmSafejvmHashCode= True= ,Nothing,
124d125
<     jvmHashCode = Nothing,
125c126
< 
---
>     jvmHashCodejvmGetC = Nothing= Nothing, jvmSetC,     = Nothing,
125a127
>     jvmGetB = Nothing, jvmSetB = Nothing,
133c135
<     jvmGetZ = Nothing, jvmSetZ = Nothing,
---
>   } jvmGetZ = Nothing, jvmSetZ = Nothing,
136d137
< 
137d137
< 
140d139
< -- IO operations can be performed in both the IO monad as well as in
141d139
< -- the Java monad, but Java operations can be performed in the Java
142d139
< -- monad only and not in the IO monad.
143d139
< --
144d139
< -- Use one of 'runJava' or 'runJava'' to perform operations in the
145c140
< -- Java monad.
---
> -- IO operations can be performed in both the IO monad as well as in-- | Every computation in the Java Virtual Machine happens inside the
145a141
> -- Java monad. The Java monad is mightier than the IO monad, i.e.-- the Java monad, but Java operations can be performed in the Java
145a142
> -- monad only and not in the IO monad.-- IO operations can be performed in both the IO monad as well as in
145a143
> ---- the Java monad, but Java operations can be performed in the Java
145a144
> -- monad only and not in the IO monad.-- Use one of 'runJava' or 'runJava'' to perform operations in the
145a145
> ---- Java monad.
145a146
> newtype-- Use one of 'runJava' or 'runJava'' to perform operations in theJava a = Java { _runJava :: StateT JVMState IO a }
145a147
> -- Java monad.deriving (Monad, MonadState JVMState, Functor, MonadIO)
147d148
<     deriving (Monad, MonadState JVMState, Functor, MonadIO)
148d148
< 
149c149
< -- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads
---
> -- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads (Monad, MonadState JVMState, Functor, MonadIO)
150a151
> getVM-- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads:: Java (Ptr Core.JVM)
150a152
> getVM-- State.= State.get $> jvmPtr
152d153
< getVM   = State.get $> jvmPtr
153d153
< 
154c154
< -- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.
---
> getVM-- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.= State.get $> jvmPtr
156d155
< getSafe = State.get $> jvmSafe
157d155
< 
158c156
< -- | By default java methods are invoked via the FFI using
---
> getSafe-- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.= State.get $> jvmSafe
158a157
> getSafe :: Java Bool
158a158
> getSafe-- | By default java methods are invoked via the FFI using= State.get $> jvmSafe
160d159
< -- function controls whether safe or unsafe calls are being
161d159
< -- used to communicate with the JVM.
162d159
< --
163d159
< -- If your application does not invoke the JVM concurrently
164d159
< -- it is mostly safe to use unsafe calls.
165d159
< --
166c160
< -- > runJava (setUnsafe True >> doSomething)
---
> -- | By default java methods are invoked via the FFI using-- function controls whether safe or unsafe calls are being
166a161
> -- used to communicate with the JVM.-- safe calls. Safe calls are slower than unsafe calls. This
166a162
> ---- function controls whether safe or unsafe calls are being
166a163
> -- used to communicate with the JVM.-- If your application does not invoke the JVM concurrently
166a164
> ---- it is mostly safe to use unsafe calls.
166a165
> ---- If your application does not invoke the JVM concurrently
166a166
> -- it is mostly safe to use unsafe calls.-- > runJava (setUnsafe True >> doSomething)
168d167
< -- will perform 'doSomething' using unsafe calls.
169c168
< setUnsafe mode = do
---
> -- > runJava (setUnsafe True >> doSomething)-- will perform 'doSomething' using unsafe calls.
169a169
> --setUnsafe mode = do
169a170
> -- will perform 'doSomething' using unsafe calls.state <- State.get
169a171
> setUnsafeState.put(=state  { jvmSafe = not mode })
173d174
< 
174d174
< 
177c177
< forkJava :: Java a -> Java (JavaThreadId a)
---
> newtypeforkJavaJavaThreadId:: Java a ->aJava= JavaThreadId(JavaThreadIdMVara) (Either SomeException a))
179d178
< -- Java Monad. It will return a 'JavaThreadId' which you can wait on
180d178
< -- using 'waitJava'.
181d178
< forkJava t = io $ do
182d178
<     lock <- newEmptyMVar
183d178
<     _ <- forkOS $ do
184c179
<         result <- try $ runJava t
---
> forkJava-- Java Monad. It will return a 'JavaThreadId' which you can wait on:: Java a -> Java (JavaThreadId a)
184a180
> -- using 'waitJava'.-- ^ A utility function for forking an OS thread which runs in the
184a181
> forkJava-- Java Monad. It will return a 'JavaThreadId' which you can wait ont = io $ do
184a182
> -- using 'waitJava'.lock <- newEmptyMVar
184a183
> forkJava_ <- tforkOS= io $ do
184a184
>     lockresult<- newEmptyMVar<- try $ runJava t
184a185
>     _ <-putMVar $lock result
184a186
>     return$ JavaThreadId<- try $ runJavalock  t
187d188
< 
188d188
< 
191d190
< -- (that is, if an exception occurred), this function will return
192c191
< -- @Left SomeException@. Otherwise it will return the result of the
---
> waitJava-- (that is, if an exception occurred), this function will return:: JavaThreadId a -> Java (Either SomeException a)
192a192
> -- ^ Wait for a Java Thread to exit. If the thread exits abnormally
192a193
> -- computation as @Right a@.-- (that is, if an exception occurred), this function will return
192a194
> waitJava-- @Left SomeException@. Otherwise it will return the result of the(JavaThreadId mvar) = io $ takeMVar mvar
195d196
< 
196d196
< 
198a199
> runJava ::= runJava' a ->[]IO a
198a200
> -- ^ Run a computation with support by a Java Virtual Machine.
200d201
< 
201d201
< 
204d203
< -- initialized with the given parameters.
205c204
< --
---
> runJava'-- initialized with the given parameters.:: [String] -> Java a -> IO a
205a205
> ---- ^ Run a computation with support by a Java Virtual Machine,
205a206
> -- initialized with the given parameters.-- This function may be used only once. If you intend to call
205a207
> ---- it multiple times, you need to initialize the Java subsystem
207d208
< -- it multiple times, you need to initialize the Java subsystem
208d208
< -- once before. If you fail to do so, this function will tear
209d208
< -- down the virtual machine once it is done.
210d208
< --
211d208
< -- By using 'initJava' the virtual machine will be alive during
212d208
< -- the whole lifetime of your process and 'runJava'' will never
213d208
< -- tear down the machine.
214d208
< --
215d208
< -- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
216d208
< --
217d208
< -- This function can be used to set for example the classpath
218d208
< -- of the virtual machine:
219d208
< --
220d208
< -- > runJava' ["-Djava.class.path=java-library-dir"] $ do
221c209
< -- >     doSomething
---
> -- down the virtual machine once it is done.-- it multiple times, you need to initialize the Java subsystem
221a210
> ---- once before. If you fail to do so, this function will tear
221a211
> -- down the virtual machine once it is done.-- By using 'initJava' the virtual machine will be alive during
221a212
> ---- the whole lifetime of your process and 'runJava'' will never
221a213
> -- tear down the machine.-- By using 'initJava' the virtual machine will be alive during
221a214
> ---- the whole lifetime of your process and 'runJava'' will never
221a215
> -- tear down the machine.-- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
222a217
> -- This function can be used to set for example the classpath-- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
222a218
> ---- of the virtual machine:
222a219
> ---- This function can be used to set for example the classpath
222a220
> -- of the virtual machine:-- > runJava' ["-Djava.class.path=java-library-dir"] $ do
222a221
> ---- >     doSomething
222a222
> ---- > runJava' ["-Djava.class.path=java-library-dir"] $ do
222a223
> -- >     doSomething-- /NOTE: java.class.path does support relative paths./
222a224
> --runJava' opts f = do
224d225
< runJava' opts f = do
225d225
< 
226c226
<     str <- mapM newCString (augmentOpts opts)
---
> runJava'str <-mapM =newCString       (augmentOpts opts)
228d227
<     vm  <- JNI.createVM' (fromIntegral $ length str) ptr
229d227
< 
230c228
<     mapM_ free str >> free ptr
---
>     strvm  <- mapMJNI.createVM'(fromIntegralaugmentOpts$optslength)   str) ptr
230a229
>     ptr <- newArray str
230a230
>     vmmapM_<-freestr >> freefromIntegralptr         $ length str) ptr
232c232
<     if vm == nullPtr then do
---
>     mapM_if vm free== nullPtr >>thendo
233a234
>     if vm == nullPtr then dothrow $ JvmException libjvmPath opts
233a235
>                      else return()    <- JNI.getLibjvmPath >>= peekCString
235d236
<                      else return ()
236d236
< 
237c237
<     (result, _) <- finally (runStateT (_runJava f) (newJVMState vm))
---
>     (result, _) <- finallyelse return(runStateT)   (_runJava f) (newJVMState vm))
239d238
< 
240c239
<     return result
---
>     (result, _) <- finally (runStateT (_runJava f) (newJVMState vm))
240a240
>     return result          (JNI.destroyVM vm)
242c242
< #ifdef FFIJNI_DEBUG
---
> #ifdef FFIJNI_DEBUG result
247c247
< 
---
> augmentOpts = id
250d249
< runJavaGui = runJavaGui' []
251d249
< 
252c250
< runJavaGui' :: [String] -> Java a -> IO ()
---
> runJavaGui ::= runJavaGui' a -> IO[]()
252a251
> -- ^ Short hand for @runJavaGui' []@.
252a252
> runJavaGuirunJavaGui'=::[String] ->]Java a -> IO ()
254d253
< -- graphical applications, namely a Cocoa Runloop needs to be present
255d253
< -- on the main thread. Since the main thread is the application
256d253
< -- that the JVM was invoked from this has two consequences:
257d253
< -- (1) A runloop needs to be created on the main thread
258d253
< -- manually and (2) the main thread is not usable for your application.
259d253
< --
260d253
< -- On Mac OS X this function will fork an os thread using 'forkJava'
261d253
< -- and start the Cocoa main event loop. This means that this function
262d253
< -- must be called on the main thread and that it will never terminate
263d253
< -- (since the cocoa event queue will be running there forever).
264d253
< --
265d253
< -- Note that this implies that you link your application with
266d253
< -- the threaded runtime (`-threaded` in GHC).
267d253
< --
268d253
< -- Typically your application should look like this:
269d253
< --
270d253
< -- > main = runJavaGui $ do
271c254
< -- >     stuffYourApplicationDoes
---
> runJavaGui'-- graphical applications, namely a Cocoa Runloop needs to be present:: [String] -> Java a -> IO ()
271a255
> -- ^ Mac OS X needs some special treatment for initializing-- on the main thread. Since the main thread is the application
271a256
> -- that the JVM was invoked from this has two consequences:-- graphical applications, namely a Cocoa Runloop needs to be present
271a257
> -- (1) A runloop needs to be created on the main thread-- on the main thread. Since the main thread is the application
271a258
> -- that the JVM was invoked from this has two consequences:-- manually and (2) the main thread is not usable for your application.
271a259
> ---- (1) A runloop needs to be created on the main thread
271a260
> -- On Mac OS X this function will fork an os thread using 'forkJava'-- manually and (2) the main thread is not usable for your application.
271a261
> ---- and start the Cocoa main event loop. This means that this function
271a262
> -- On Mac OS X this function will fork an os thread using 'forkJava'-- must be called on the main thread and that it will never terminate
271a263
> -- (since the cocoa event queue will be running there forever).-- and start the Cocoa main event loop. This means that this function
271a264
> ---- must be called on the main thread and that it will never terminate
271a265
> -- Note that this implies that you link your application with-- (since the cocoa event queue will be running there forever).
271a266
> ---- the threaded runtime (`-threaded` in GHC).
271a267
> ---- Note that this implies that you link your application with
271a268
> -- the threaded runtime (`-threaded` in GHC).-- Typically your application should look like this:
273d269
< -- On all other platforms this is exactly the same as 'runJava''
274d269
< -- (minus the fact that it returns @()@).
275d269
< #if defined(FFIJNI_MACOSX) && defined(FFIJNI_OSX_GUI)
276c270
< runJavaGui' opts java = runJava' opts $ do
---
> -- > main = runJavaGui $ do-- Typically your application should look like this:
276a271
> ---- >     stuffYourApplicationDoes
276a272
> ---- > main = runJavaGui $ do
276a273
> -- >     stuffYourApplicationDoes-- On all other platforms this is exactly the same as 'runJava''
276a274
> ---- (minus the fact that it returns @()@).
276a275
> #if defined(FFIJNI_MACOSX) && defined(FFIJNI_OSX_GUI)-- On all other platforms this is exactly the same as 'runJava''
276a276
> runJavaGui'-- (minus the fact that it returns @()@).opts java = runJava' opts $ do
282c282
< 
---
> runJavaGui' opts javaGui = runJava' opts javaGui >> return ()
285d284
< -- be used by subsequent invocations of 'runJava'. Note that
286c285
< -- once you start the virtual machine it will be runing throughout
---
> initJava-- be used by subsequent invocations of 'runJava'. Note that:: [String] -> IO ()
286a286
> -- ^ Initializes the Java Virtual Machine so that it can-- once you start the virtual machine it will be runing throughout
286a287
> -- be used by subsequent invocations of 'runJava'. Note that-- the whole lifetime of the main thread of your application.
286a288
> initJava-- once you start the virtual machine it will be runing throughoutopts = runJava' opts persistVM
288d289
< initJava opts = runJava' opts persistVM
289d289
< 
290c290
< persistVM :: Java ()
---
> initJavapersistVMopts:: Java= runJava'()     opts persistVM
292c292
<     vm <- getVM
---
> persistVMvm <- ::getVM ()
292a293
> persistVMliftIO=$doJNI.persistVM vm
292a294
>     vmreturn<- getVM()
296d297
< 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Haskell2010
    , GeneralizedNewtypeDeriving
    , DeriveDataTypeable
    , CPP
 #-}
{-# OPTIONS
    -Wall
    -fno-warn-missing-signatures
    -fno-warn-name-shadowing
 #-}

-- | INTERNAL module:
-- The Java Monad Transformer. Most of its API is re-exported by "Foreign.Java"
module Foreign.Java.JavaMonad where


import Control.Monad.State hiding (void)
import qualified Control.Monad.State as State

import Data.Int
import Data.Word

import qualified Foreign.Java.JNI.Safe   as JNI
import qualified Foreign.Java.JNI.Types  as Core

import Foreign.Java.JNI.Types (
    JObject (..),
    JThrowable (..)
  )

import Foreign hiding (void)
import Foreign.C.String

import Foreign.Java.Util

import Control.Concurrent
import Control.Exception
import Data.Typeable


io :: IO a -> Java a
-- ^ Short for 'liftIO' and restricted to the 'Java' monad.
io = liftIO


-- | An exception in either the Java Virtual Machine or during
-- instantiating the Virtual Machine.
data JavaException =
        -- | An exception that occurred during the initialization
        -- of the virtual machine. Thrown by 'runJava', 'runJava'',
        -- or 'initJava'.
        JvmException String [String]

        -- | An exception that occurred inside the virtual machine.
        -- Thrown by those functions ending with a capital @E@.
      | JavaException String JThrowable
    deriving Typeable

instance Show JavaException where
    show (JvmException jvmlibPath args) =
        "JvmException: jvmlibPath = " ++ jvmlibPath
            ++ ", arguments = " ++ show args
    show (JavaException strMessage _throwable) =
        "JavaException: " ++ strMessage

instance Exception JavaException


-- | A reference to an instance of a Java Virtual Machine.
newtype JVM = JVM (Ptr Core.JVM)
    deriving Show


-- | The State of a virtual machine, running in the Java
-- Monad (which is a State Monad wrapped around the IO
-- Monad with JVMState as additional State).
--
-- All the accessor functions are INTERNAL.
data JVMState = JVMState {

    -- | INTERNAL The actual pointer to the virtual machine.
    jvmPtr :: Ptr Core.JVM,

    -- | INTERNAL Whether this virtual machine instance should
    -- be talked to using safe or unsafe calls.
    --
    -- See also 'setSafe' and 'getSafe'.
    jvmSafe :: Bool,

    -- | INTERNAL The cached methodID of Object.toString
    jvmToString :: Maybe (JObject -> Java (Maybe String)),

    -- | INTERNAL The cached methodID of Object.hashCode
    jvmHashCode :: Maybe (JObject -> Java Int32),

    jvmGetC :: Maybe (Maybe JObject -> Int32 -> Java Word16),
    jvmGetB :: Maybe (Maybe JObject -> Int32 -> Java Int8),
    jvmGetS :: Maybe (Maybe JObject -> Int32 -> Java Int16),
    jvmGetI :: Maybe (Maybe JObject -> Int32 -> Java Int32),
    jvmGetJ :: Maybe (Maybe JObject -> Int32 -> Java Int64),
    jvmGetF :: Maybe (Maybe JObject -> Int32 -> Java Float),
    jvmGetD :: Maybe (Maybe JObject -> Int32 -> Java Double),
    jvmGetZ :: Maybe (Maybe JObject -> Int32 -> Java Bool),
    jvmGetL :: Maybe (Maybe JObject -> Int32 -> Java (Maybe JObject)),

    jvmSetC :: Maybe (Maybe JObject -> Int32 -> Word16 -> Java ()),
    jvmSetB :: Maybe (Maybe JObject -> Int32 -> Int8 -> Java ()),
    jvmSetS :: Maybe (Maybe JObject -> Int32 -> Int16 -> Java ()),
    jvmSetI :: Maybe (Maybe JObject -> Int32 -> Int32 -> Java ()),
    jvmSetJ :: Maybe (Maybe JObject -> Int32 -> Int64 -> Java ()),
    jvmSetF :: Maybe (Maybe JObject -> Int32 -> Float -> Java ()),
    jvmSetD :: Maybe (Maybe JObject -> Int32 -> Double -> Java ()),
    jvmSetZ :: Maybe (Maybe JObject -> Int32 -> Bool -> Java ()),
    jvmSetL :: Maybe (Maybe JObject -> Int32 -> (Maybe JObject) -> Java ())
  }

-- | Creates a JVMState and initializes it with sane default values.
-- A Pointer to the virtual machine is required in any case.
newJVMState vm = JVMState {

    jvmPtr = vm,
    jvmSafe = True,
    jvmToString = Nothing,
    jvmHashCode = Nothing,

    jvmGetC = Nothing, jvmSetC = Nothing,
    jvmGetB = Nothing, jvmSetB = Nothing,
    jvmGetS = Nothing, jvmSetS = Nothing,
    jvmGetI = Nothing, jvmSetI = Nothing,
    jvmGetJ = Nothing, jvmSetJ = Nothing,
    jvmGetF = Nothing, jvmSetF = Nothing,
    jvmGetD = Nothing, jvmSetD = Nothing,
    jvmGetZ = Nothing, jvmSetZ = Nothing,
    jvmGetL = Nothing, jvmSetL = Nothing
  }


-- | Every computation in the Java Virtual Machine happens inside the
-- Java monad. The Java monad is mightier than the IO monad, i.e.
-- IO operations can be performed in both the IO monad as well as in
-- the Java monad, but Java operations can be performed in the Java
-- monad only and not in the IO monad.
--
-- Use one of 'runJava' or 'runJava'' to perform operations in the
-- Java monad.
newtype Java a = Java { _runJava :: StateT JVMState IO a }
    deriving (Monad, MonadState JVMState, Functor, MonadIO)

-- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads
-- State.
getVM :: Java (Ptr Core.JVM)
getVM   = State.get $> jvmPtr

-- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.
getSafe :: Java Bool
getSafe = State.get $> jvmSafe

-- | By default java methods are invoked via the FFI using
-- safe calls. Safe calls are slower than unsafe calls. This
-- function controls whether safe or unsafe calls are being
-- used to communicate with the JVM.
--
-- If your application does not invoke the JVM concurrently
-- it is mostly safe to use unsafe calls.
--
-- > runJava (setUnsafe True >> doSomething)
--
-- will perform 'doSomething' using unsafe calls.
setUnsafe mode = do
    state <- State.get
    State.put (state { jvmSafe = not mode })



newtype JavaThreadId a = JavaThreadId (MVar (Either SomeException a))

forkJava :: Java a -> Java (JavaThreadId a)
-- ^ A utility function for forking an OS thread which runs in the
-- Java Monad. It will return a 'JavaThreadId' which you can wait on
-- using 'waitJava'.
forkJava t = io $ do
    lock <- newEmptyMVar
    _ <- forkOS $ do
        result <- try $ runJava t
        putMVar lock result
    return $ JavaThreadId lock


waitJava :: JavaThreadId a -> Java (Either SomeException a)
-- ^ Wait for a Java Thread to exit. If the thread exits abnormally
-- (that is, if an exception occurred), this function will return
-- @Left SomeException@. Otherwise it will return the result of the
-- computation as @Right a@.
waitJava (JavaThreadId mvar) = io $ takeMVar mvar


runJava :: Java a -> IO a
-- ^ Run a computation with support by a Java Virtual Machine.
runJava = runJava' []


runJava' :: [String] -> Java a -> IO a
-- ^ Run a computation with support by a Java Virtual Machine,
-- initialized with the given parameters.
--
-- This function may be used only once. If you intend to call
-- it multiple times, you need to initialize the Java subsystem
-- once before. If you fail to do so, this function will tear
-- down the virtual machine once it is done.
--
-- By using 'initJava' the virtual machine will be alive during
-- the whole lifetime of your process and 'runJava'' will never
-- tear down the machine.
--
-- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
--
-- This function can be used to set for example the classpath
-- of the virtual machine:
--
-- > runJava' ["-Djava.class.path=java-library-dir"] $ do
-- >     doSomething
--
-- /NOTE: java.class.path does support relative paths./
runJava' opts f = do

    str <- mapM newCString (augmentOpts opts)
    ptr <- newArray str
    vm  <- JNI.createVM' (fromIntegral $ length str) ptr

    mapM_ free str >> free ptr

    if vm == nullPtr then do
                            libjvmPath <- JNI.getLibjvmPath >>= peekCString
                            throw $ JvmException libjvmPath opts
                     else return ()

    (result, _) <- finally (runStateT (_runJava f) (newJVMState vm))
                           (JNI.destroyVM vm)

    return result

#ifdef FFIJNI_DEBUG
augmentOpts = ("-Xcheck:jni" :)
#else
augmentOpts = id
#endif

runJavaGui :: Java a -> IO ()
-- ^ Short hand for @runJavaGui' []@.
runJavaGui = runJavaGui' []

runJavaGui' :: [String] -> Java a -> IO ()
-- ^ Mac OS X needs some special treatment for initializing
-- graphical applications, namely a Cocoa Runloop needs to be present
-- on the main thread. Since the main thread is the application
-- that the JVM was invoked from this has two consequences:
-- (1) A runloop needs to be created on the main thread
-- manually and (2) the main thread is not usable for your application.
--
-- On Mac OS X this function will fork an os thread using 'forkJava'
-- and start the Cocoa main event loop. This means that this function
-- must be called on the main thread and that it will never terminate
-- (since the cocoa event queue will be running there forever).
--
-- Note that this implies that you link your application with
-- the threaded runtime (`-threaded` in GHC).
--
-- Typically your application should look like this:
--
-- > main = runJavaGui $ do
-- >     stuffYourApplicationDoes
--
-- On all other platforms this is exactly the same as 'runJava''
-- (minus the fact that it returns @()@).
#if defined(FFIJNI_MACOSX) && defined(FFIJNI_OSX_GUI)
runJavaGui' opts java = runJava' opts $ do
        _ <- forkJava java
        io JNI.runCocoaMain
#else
runJavaGui' opts javaGui = runJava' opts javaGui >> return ()
#endif

initJava :: [String] -> IO ()
-- ^ Initializes the Java Virtual Machine so that it can
-- be used by subsequent invocations of 'runJava'. Note that
-- once you start the virtual machine it will be runing throughout
-- the whole lifetime of the main thread of your application.
initJava opts = runJava' opts persistVM

persistVM :: Java ()
persistVM = do
    vm <- getVM
    liftIO $ JNI.persistVM vm
    return ()


</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Haskell2010
    , GeneralizedNewtypeDeriving
    , DeriveDataTypeable
    , CPP
 #-}
{-# OPTIONS
    -Wall
    -fno-warn-missing-signatures
    -fno-warn-name-shadowing
 #-}
-- | INTERNAL module:
-- The Java Monad Transformer. Most of its API is re-exported by "Foreign.Java"
module-- | INTERNAL module:Foreign.Java.JavaMonad where
-- The Java Monad Transformer. Most of its API is re-exported by "Foreign.Java"

module Foreign.Java.JavaMonad where
import Control.Monad.State hiding (void)
import qualified Control.Monad.State as State
import Control.Monad.State hiding (void)
import qualifiedData.Int  Control.Monad.State as State
import Data.Word
import Data.Int
import Data.Word Foreign.Java.JNI.Safe   as JNI
import qualified Foreign.Java.JNI.Types  as Core
import qualified Foreign.Java.JNI.Safe   as JNI
import qualifiedForeign.Java.JNI.TypesForeign.Java.JNI.Types(          as Core
    JObject (..),
importJThrowableForeign.Java.JNI.Types(..)           (
  ) JObject (..),
    JThrowable (..)
import)    Foreign hiding (void)
import Foreign.C.String
import Foreign hiding (void)
import Foreign.C.StringForeign.Java.Util

import Foreign.Java.UtilControl.Concurrent
import Control.Exception
import Control.ConcurrentData.Typeable
import Control.Exception
import Data.Typeable
io :: IO a -> Java a
-- ^ Short for 'liftIO' and restricted to the 'Java' monad.
io ::= liftIO a -> Java a
-- ^ Short for 'liftIO' and restricted to the 'Java' monad.
io = liftIO
-- | An exception in either the Java Virtual Machine or during
-- instantiating the Virtual Machine.
data-- | An exception in either the Java Virtual Machine or duringJavaException =
-- instantiating the Virtual Machine.-- | An exception that occurred during the initialization
data JavaException-- of the virtual machine. Thrown by 'runJava', 'runJava'',=
        -- or 'initJava'.-- | An exception that occurred during the initialization
        JvmException-- of the virtual machine. Thrown by 'runJava', 'runJava'',String [String]
        -- or 'initJava'.
        JvmException-- | An exception that occurred inside the virtual machine. [String]
        -- Thrown by those functions ending with a capital @E@.
      | JavaException-- | An exception that occurred inside the virtual machine.String JThrowable
    deriving-- Thrown by those functions ending with a capital @E@.Typeable
      | JavaException String JThrowable
instanceShowTypeableJavaException where
    show (JvmException jvmlibPath args) =
instance"JvmException: jvmlibPath = " JavaException where     ++ jvmlibPath
    show (JvmException++ ", arguments = "++argsshow) =args
    show"JvmException: jvmlibPath = "(JavaException strMessage _throwable jvmlibPath) =
        "JavaException: " ", arguments = "++ strMessage show args
    show (JavaException strMessage _throwable) =
instance"JavaException: "Exception JavaException strMessage

instance Exception JavaException
-- | A reference to an instance of a Java Virtual Machine.
newtype JVM = JVM (Ptr Core.JVM)
-- | A reference to an instance of a Java Virtual Machine.deriving Show
newtype JVM = JVM (Ptr Core.JVM)
    deriving Show
-- | The State of a virtual machine, running in the Java
-- Monad (which is a State Monad wrapped around the IO
-- Monad with JVMState as additional State).-- | The State of a virtual machine, running in the Java
---- Monad (which is a State Monad wrapped around the IO
-- All the accessor functions are INTERNAL.-- Monad with JVMState as additional State).
--data JVMState = JVMState {
-- All the accessor functions are INTERNAL.
data-- | INTERNAL The actual pointer to the virtual machine. = JVMState {
    jvmPtr :: Ptr Core.JVM,
    -- | INTERNAL The actual pointer to the virtual machine.
    jvmPtr-- | INTERNAL Whether this virtual machine instance should:: Ptr Core.JVM,
    -- be talked to using safe or unsafe calls.
    ---- | INTERNAL Whether this virtual machine instance should
    -- See also 'setSafe' and 'getSafe'.-- be talked to using safe or unsafe calls.
    --jvmSafe :: Bool,
    -- See also 'setSafe' and 'getSafe'.
    jvmSafe-- | INTERNAL The cached methodID of Object.toString:: Bool,
    jvmToString :: Maybe (JObject -> Java (Maybe String)),
    -- | INTERNAL The cached methodID of Object.toString
    jvmToString-- | INTERNAL The cached methodID of Object.hashCode:: Maybe (JObject -> Java (Maybe String)),
    jvmHashCode :: Maybe (JObject -> Java Int32),
    -- | INTERNAL The cached methodID of Object.hashCode
    jvmHashCodejvmGetC :: Maybe:: Maybe(MaybeJObjectJObject->->Int32->),Java Word16),
    jvmGetB :: Maybe (Maybe JObject -> Int32 -> Java Int8),
    jvmGetC :: Maybe (Maybe JObject -> Int32 -> Java Word16Int16)),
    jvmGetB :: Maybe (Maybe JObject -> Int32 -> Java Int8Int32),,
    jvmGetS :: Maybe (Maybe JObject -> Int32 -> Java Int16),
    jvmGetI :: Maybe (Maybe JObject -> Int32 -> Java Int32),
    jvmGetJ :: Maybe (Maybe JObject -> Int32 -> Java Int64Double),,
    jvmGetF :: Maybe (Maybe JObject -> Int32 -> Java FloatBool)),
    jvmGetD :: Maybe (Maybe JObject -> Int32 -> Java Double(Maybe),JObject)),
    jvmGetZ :: Maybe (Maybe JObject -> Int32 -> Java Bool),
    jvmGetL :: Maybe (Maybe JObject -> Int32 -> JavaWord16Maybe-> Java()),)),
    jvmSetB :: Maybe (Maybe JObject -> Int32 -> Int8 -> Java ()),
    jvmSetC :: Maybe (Maybe JObject -> Int32 -> Word16Int16 ->->Java(()),
    jvmSetB :: Maybe (Maybe JObject -> Int32 -> Int8Int32->->JavaJava()),,
    jvmSetS :: Maybe (Maybe JObject -> Int32 -> Int16 -> Java ()),
    jvmSetI :: Maybe (Maybe JObject -> Int32 -> Int32 -> Java ()),
    jvmSetJ :: Maybe (Maybe JObject -> Int32 -> Int64Double->->JavaJava()),,
    jvmSetF :: Maybe (Maybe JObject -> Int32 -> FloatBool ->->Java(()),
    jvmSetD :: Maybe (Maybe JObject -> Int32 -> Double(Maybe ->JObject)()->),Java ())
  } jvmSetZ :: Maybe (Maybe JObject -> Int32 -> Bool -> Java ()),
    jvmSetL :: Maybe (Maybe JObject -> Int32 -> (Maybe JObject) -> Java ())
-- | Creates a JVMState and initializes it with sane default values.}
-- A Pointer to the virtual machine is required in any case.
newJVMState-- | Creates a JVMState and initializes it with sane default values.vm = JVMState {
-- A Pointer to the virtual machine is required in any case.
newJVMStatejvmPtr =vmvm= JVMState {
    jvmSafe = True,
    jvmPtrjvmToString= vm,= Nothing,
    jvmSafejvmHashCode= True= ,Nothing,
    jvmToString = Nothing,
    jvmHashCodejvmGetC = Nothing= Nothing, jvmSetC,     = Nothing,
    jvmGetB = Nothing, jvmSetB = Nothing,
    jvmGetC = Nothing, jvmSetC = Nothing,
    jvmGetB = Nothing, jvmSetB = Nothing,
    jvmGetS = Nothing, jvmSetS = Nothing,
    jvmGetI = Nothing, jvmSetI = Nothing,
    jvmGetJ = Nothing, jvmSetJ = Nothing,
    jvmGetF = Nothing, jvmSetF = Nothing,
    jvmGetD = Nothing, jvmSetD = Nothing,
  } jvmGetZ = Nothing, jvmSetZ = Nothing,
    jvmGetL = Nothing, jvmSetL = Nothing
  }
-- | Every computation in the Java Virtual Machine happens inside the
-- Java monad. The Java monad is mightier than the IO monad, i.e.
-- IO operations can be performed in both the IO monad as well as in-- | Every computation in the Java Virtual Machine happens inside the
-- Java monad. The Java monad is mightier than the IO monad, i.e.-- the Java monad, but Java operations can be performed in the Java
-- monad only and not in the IO monad.-- IO operations can be performed in both the IO monad as well as in
---- the Java monad, but Java operations can be performed in the Java
-- monad only and not in the IO monad.-- Use one of 'runJava' or 'runJava'' to perform operations in the
---- Java monad.
newtype-- Use one of 'runJava' or 'runJava'' to perform operations in theJava a = Java { _runJava :: StateT JVMState IO a }
-- Java monad.deriving (Monad, MonadState JVMState, Functor, MonadIO)
newtype Java a = Java { _runJava :: StateT JVMState IO a }
-- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads (Monad, MonadState JVMState, Functor, MonadIO)
-- State.
getVM-- | INTERNAL Retrieve the 'jvmPtr' from this Java Monads:: Java (Ptr Core.JVM)
getVM-- State.= State.get $> jvmPtr
getVM :: Java (Ptr Core.JVM)
getVM-- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.= State.get $> jvmPtr
getSafe :: Java Bool
getSafe-- | INTERNAL Retrieve 'jvmSafe' from this Java Monads Sate.= State.get $> jvmSafe
getSafe :: Java Bool
getSafe-- | By default java methods are invoked via the FFI using= State.get $> jvmSafe
-- safe calls. Safe calls are slower than unsafe calls. This
-- | By default java methods are invoked via the FFI using-- function controls whether safe or unsafe calls are being
-- used to communicate with the JVM.-- safe calls. Safe calls are slower than unsafe calls. This
---- function controls whether safe or unsafe calls are being
-- used to communicate with the JVM.-- If your application does not invoke the JVM concurrently
---- it is mostly safe to use unsafe calls.
---- If your application does not invoke the JVM concurrently
-- it is mostly safe to use unsafe calls.-- > runJava (setUnsafe True >> doSomething)
--
-- > runJava (setUnsafe True >> doSomething)-- will perform 'doSomething' using unsafe calls.
--setUnsafe mode = do
-- will perform 'doSomething' using unsafe calls.state <- State.get
setUnsafeState.put(=state  { jvmSafe = not mode })
    state <- State.get
    State.put (state { jvmSafe = not mode })

newtype JavaThreadId a = JavaThreadId (MVar (Either SomeException a))

newtypeforkJavaJavaThreadId:: Java a ->aJava= JavaThreadId(JavaThreadIdMVara) (Either SomeException a))
-- ^ A utility function for forking an OS thread which runs in the
forkJava-- Java Monad. It will return a 'JavaThreadId' which you can wait on:: Java a -> Java (JavaThreadId a)
-- using 'waitJava'.-- ^ A utility function for forking an OS thread which runs in the
forkJava-- Java Monad. It will return a 'JavaThreadId' which you can wait ont = io $ do
-- using 'waitJava'.lock <- newEmptyMVar
forkJava_ <- tforkOS= io $ do
    lockresult<- newEmptyMVar<- try $ runJava t
    _ <-putMVar $lock result
    return$ JavaThreadId<- try $ runJavalock  t
        putMVar lock result
    return $ JavaThreadId lock
waitJava :: JavaThreadId a -> Java (Either SomeException a)
-- ^ Wait for a Java Thread to exit. If the thread exits abnormally
waitJava-- (that is, if an exception occurred), this function will return:: JavaThreadId a -> Java (Either SomeException a)
-- ^ Wait for a Java Thread to exit. If the thread exits abnormally
-- computation as @Right a@.-- (that is, if an exception occurred), this function will return
waitJava-- @Left SomeException@. Otherwise it will return the result of the(JavaThreadId mvar) = io $ takeMVar mvar
-- computation as @Right a@.
waitJava (JavaThreadId mvar) = io $ takeMVar mvar
runJava :: Java a -> IO a
-- ^ Run a computation with support by a Java Virtual Machine.
runJava ::= runJava' a ->[]IO a
-- ^ Run a computation with support by a Java Virtual Machine.
runJava = runJava' []
runJava' :: [String] -> Java a -> IO a
-- ^ Run a computation with support by a Java Virtual Machine,
runJava'-- initialized with the given parameters.:: [String] -> Java a -> IO a
---- ^ Run a computation with support by a Java Virtual Machine,
-- initialized with the given parameters.-- This function may be used only once. If you intend to call
---- it multiple times, you need to initialize the Java subsystem
-- This function may be used only once. If you intend to call
-- down the virtual machine once it is done.-- it multiple times, you need to initialize the Java subsystem
---- once before. If you fail to do so, this function will tear
-- down the virtual machine once it is done.-- By using 'initJava' the virtual machine will be alive during
---- the whole lifetime of your process and 'runJava'' will never
-- tear down the machine.-- By using 'initJava' the virtual machine will be alive during
---- the whole lifetime of your process and 'runJava'' will never
-- tear down the machine.-- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
--
-- This function can be used to set for example the classpath-- /NOTE: According to the Java Native Interface specification it may be possible to create multiple virtual machines within a single process. However, no implementation of the JNI seems to be capable of doing so./
---- of the virtual machine:
---- This function can be used to set for example the classpath
-- of the virtual machine:-- > runJava' ["-Djava.class.path=java-library-dir"] $ do
---- >     doSomething
---- > runJava' ["-Djava.class.path=java-library-dir"] $ do
-- >     doSomething-- /NOTE: java.class.path does support relative paths./
--runJava' opts f = do
-- /NOTE: java.class.path does support relative paths./
runJava'str <-mapM =newCString       (augmentOpts opts)
    ptr <- newArray str
    strvm  <- mapMJNI.createVM'(fromIntegralaugmentOpts$optslength)   str) ptr
    ptr <- newArray str
    vmmapM_<-freestr >> freefromIntegralptr         $ length str) ptr

    mapM_if vm free== nullPtr >>thendo
                            libjvmPath <- JNI.getLibjvmPath >>= peekCString
    if vm == nullPtr then dothrow $ JvmException libjvmPath opts
                     else return()    <- JNI.getLibjvmPath >>= peekCString
                            throw $ JvmException libjvmPath opts
    (result, _) <- finallyelse return(runStateT)   (_runJava f) (newJVMState vm))
                           (JNI.destroyVM vm)
    (result, _) <- finally (runStateT (_runJava f) (newJVMState vm))
    return result          (JNI.destroyVM vm)

#ifdef FFIJNI_DEBUG result
augmentOpts = ("-Xcheck:jni" :)
#else
augmentOpts = id
#endif
augmentOpts = id
runJavaGui :: Java a -> IO ()
-- ^ Short hand for @runJavaGui' []@.
runJavaGui ::= runJavaGui' a -> IO[]()
-- ^ Short hand for @runJavaGui' []@.
runJavaGuirunJavaGui'=::[String] ->]Java a -> IO ()
-- ^ Mac OS X needs some special treatment for initializing
runJavaGui'-- graphical applications, namely a Cocoa Runloop needs to be present:: [String] -> Java a -> IO ()
-- ^ Mac OS X needs some special treatment for initializing-- on the main thread. Since the main thread is the application
-- that the JVM was invoked from this has two consequences:-- graphical applications, namely a Cocoa Runloop needs to be present
-- (1) A runloop needs to be created on the main thread-- on the main thread. Since the main thread is the application
-- that the JVM was invoked from this has two consequences:-- manually and (2) the main thread is not usable for your application.
---- (1) A runloop needs to be created on the main thread
-- On Mac OS X this function will fork an os thread using 'forkJava'-- manually and (2) the main thread is not usable for your application.
---- and start the Cocoa main event loop. This means that this function
-- On Mac OS X this function will fork an os thread using 'forkJava'-- must be called on the main thread and that it will never terminate
-- (since the cocoa event queue will be running there forever).-- and start the Cocoa main event loop. This means that this function
---- must be called on the main thread and that it will never terminate
-- Note that this implies that you link your application with-- (since the cocoa event queue will be running there forever).
---- the threaded runtime (`-threaded` in GHC).
---- Note that this implies that you link your application with
-- the threaded runtime (`-threaded` in GHC).-- Typically your application should look like this:
--
-- > main = runJavaGui $ do-- Typically your application should look like this:
---- >     stuffYourApplicationDoes
---- > main = runJavaGui $ do
-- >     stuffYourApplicationDoes-- On all other platforms this is exactly the same as 'runJava''
---- (minus the fact that it returns @()@).
#if defined(FFIJNI_MACOSX) && defined(FFIJNI_OSX_GUI)-- On all other platforms this is exactly the same as 'runJava''
runJavaGui'-- (minus the fact that it returns @()@).opts java = runJava' opts $ do
        _ <- forkJava java
        io JNI.runCocoaMain
#else
runJavaGui' opts javaGui = runJava' opts javaGui >> return ()
#endif
runJavaGui' opts javaGui = runJava' opts javaGui >> return ()
initJava :: [String] -> IO ()
-- ^ Initializes the Java Virtual Machine so that it can
initJava-- be used by subsequent invocations of 'runJava'. Note that:: [String] -> IO ()
-- ^ Initializes the Java Virtual Machine so that it can-- once you start the virtual machine it will be runing throughout
-- be used by subsequent invocations of 'runJava'. Note that-- the whole lifetime of the main thread of your application.
initJava-- once you start the virtual machine it will be runing throughoutopts = runJava' opts persistVM
-- the whole lifetime of the main thread of your application.
initJavapersistVMopts:: Java= runJava'()     opts persistVM
persistVM = do
persistVMvm <- ::getVM ()
persistVMliftIO=$doJNI.persistVM vm
    vmreturn<- getVM()
    liftIO $ JNI.persistVM vm
    return ()

</pre>