<a href="Evt.hs18645465171351934195.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Example.hs144128232716531729.out.html">next</a></br></br><pre>5c5
< foo :: Set '["x" :-> Int, "z" :-> Int, "w" :-> Int]
---
> foo :: Set   "x" :-> Int, "z" :-> Int, "w" :-> Int]
11c11
< bar :: Set '["y" :-> Int, "w" :-> Int]
---
> bar :: Set   "y" :-> Int, "w" :-> Int]
18a19
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds, TypeOperators #-}

import Data.Type.Set

foo :: Set '["x" :-> Int, "z" :-> Int, "w" :-> Int]
foo = Ext ((Var :: (Var "x")) :-> 2) $
       Ext ((Var :: (Var "z")) :-> 4) $
        Ext ((Var :: (Var "w")) :-> 5) $
         Empty

bar :: Set '["y" :-> Int, "w" :-> Int]
bar = Ext ((Var :: (Var "y")) :-> 3) $
       Ext ((Var :: (Var "w")) :-> 1) $
         Empty

-- GHC can easily infer this type, so an explicit signature not necessary
-- foobar :: Set '["w" :-> Int, "x" :-> Int, "y" :-> Integer, "z" :-> Int]
foobar = foo `union` bar
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds, TypeOperators #-}

import Data.Type.Set

foo :: Set   "x" :-> Int, "z" :-> Int, "w" :-> Int]
foo = Ext ((Var :: (Var "x")) :-> 2) $
       Ext ((Var :: (Var "z")) :-> 4) $
        Ext ((Var :: (Var "w")) :-> 5) $
         Empty

bar :: Set   "y" :-> Int, "w" :-> Int]
bar = Ext ((Var :: (Var "y")) :-> 3) $
       Ext ((Var :: (Var "w")) :-> 1) $
         Empty

-- GHC can easily infer this type, so an explicit signature not necessary
-- foobar :: Set '["w" :-> Int, "x" :-> Int, "y" :-> Integer, "z" :-> Int]
foobar = foo `union` bar

</pre>