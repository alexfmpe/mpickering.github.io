<a href="Github.hs19548990971636807826.out.html">prev</a></br><a href="failures.html">home</a></br><a href="GitsonSpec.hs19548990971636807826.out.html">next</a></br></br><pre>43c43
< type Finder = [(IdAndName, FileName)] → Maybe (IdAndName, FileName)
---
> type Finder = [(IdAndName, FileName)] -> Maybe (IdAndName, FileName)
45c45
< splitFindDocument ∷ (MonadIO i, Functor i) ⇒ FilePath → Finder → i (Maybe (IdAndName, FileName))
---
> splitFindDocument :: (MonadIO i, Functor i) => FilePath -> Finder -> i (Maybe (IdAndName, FileName))
47c47
<   finder . mapMaybe (\x → intoFunctor (maybeReadIntString x) x) <$> listDocumentKeys collection
---
>   finder . mapMaybe (\x -> intoFunctor (maybeReadIntString x) x) <$> listDocumentKeys collection
49c49
< documentFullKey ∷ (MonadIO i, Functor i) ⇒ FilePath → Finder → i (Maybe FileName)
---
> documentFullKey :: (MonadIO i, Functor i) => FilePath -> Finder -> i (Maybe FileName)
52c52
< findById ∷ Int → Finder
---
> findById :: Int -> Finder
55c55
< findByName ∷ String → Finder
---
> findByName :: String -> Finder
59c59
< createRepo ∷ FilePath → IO ()
---
> createRepo :: FilePath -> IO ()
65c65
< transaction ∷ (MonadIO i, Functor i, MonadBaseControl IO i) ⇒ FilePath → TransactionWriter i () → i ()
---
> transaction :: (MonadIO i, Functor i, MonadBaseControl IO i) => FilePath -> TransactionWriter i () -> i ()
70c70
<       writeActions ← execWriterT action
---
>       writeActions <- execWriterT action
77c77
< combineKey ∷ IdAndName → FileName
---
> combineKey :: IdAndName -> FileName
80c80
< writeDocument ∷ ToJSON a ⇒ FilePath → FileName → a → IO ()
---
> writeDocument :: ToJSON a => FilePath -> FileName -> a -> IO ()
84c84
< saveDocument ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → FileName → a → TransactionWriter i ()
---
> saveDocument :: (MonadIO i, Functor i, ToJSON a) => FilePath -> FileName -> a -> TransactionWriter i ()
91c91
< saveNextDocument ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → FileName → a → TransactionWriter i ()
---
> saveNextDocument :: (MonadIO i, Functor i, ToJSON a) => FilePath -> FileName -> a -> TransactionWriter i ()
96c96
<         \nextId → writeDocument collection (combineKey (nextId, key)) content]
---
>         \nextId -> writeDocument collection (combineKey (nextId, key)) content]
100c100
< saveDocumentById ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → Int → a → TransactionWriter i ()
---
> saveDocumentById :: (MonadIO i, Functor i, ToJSON a) => FilePath -> Int -> a -> TransactionWriter i ()
103d102
<         \k → case k of
104d102
<           Just key → writeDocument collection key content
105c103
<           Nothing → return ()]
---
>         \k -> case k of
105a104
>           Just key -> writeDocument collection key content
105a105
>           Nothing -> return ()]
109c109
< saveDocumentByName ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → String → a → TransactionWriter i ()
---
> saveDocumentByName :: (MonadIO i, Functor i, ToJSON a) => FilePath -> String -> a -> TransactionWriter i ()
112d111
<         \k → case k of
113d111
<           Just key → writeDocument collection key content
114c112
<           Nothing → return ()]
---
>         \k -> case k of
114a113
>           Just key -> writeDocument collection key content
114a114
>           Nothing -> return ()]
117c117
< listCollections ∷ (MonadIO i, Functor i) ⇒ i [FilePath]
---
> listCollections :: (MonadIO i, Functor i) => i [FilePath]
119c119
<   contents ← try (getDirectoryContents =<< getCurrentDirectory) ∷ IO (Either IOException [FilePath])
---
>   contents <- try (getDirectoryContents =<< getCurrentDirectory) :: IO (Either IOException [FilePath])
123c123
< listDocumentKeys ∷ (MonadIO i, Functor i) ⇒ FilePath → i [FileName]
---
> listDocumentKeys :: (MonadIO i, Functor i) => FilePath -> i [FileName]
125c125
<   contents ← try (getDirectoryContents collection) ∷ IO (Either IOException [String])
---
>   contents <- try (getDirectoryContents collection) :: IO (Either IOException [String])
129c129
< listEntries ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → i [a]
---
> listEntries :: (MonadIO i, Functor i, FromJSON a) => FilePath -> i [a]
131c131
<   maybes ← mapM (readDocument collection) =<< listDocumentKeys collection
---
>   maybes <- mapM (readDocument collection) =<< listDocumentKeys collection
135c135
< readDocument ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → FileName → i (Maybe a)
---
> readDocument :: (MonadIO i, Functor i, FromJSON a) => FilePath -> FileName -> i (Maybe a)
137c137
<   jsonString ← try (BL.readFile $ documentPath collection key) ∷ IO (Either IOException BL.ByteString)
---
>   jsonString <- try (BL.readFile $ documentPath collection key) :: IO (Either IOException BL.ByteString)
140c140
< readDocument' ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → Maybe FileName → i (Maybe a)
---
> readDocument' :: (MonadIO i, Functor i, FromJSON a) => FilePath -> Maybe FileName -> i (Maybe a)
142d141
<   Just key → readDocument collection key
143c142
<   Nothing → return Nothing
---
>   Just key -> readDocument collection key
143a143
>   Nothing -> return Nothing
146c146
< readDocumentById ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → Int → i (Maybe a)
---
> readDocumentById :: (MonadIO i, Functor i, FromJSON a) => FilePath -> Int -> i (Maybe a)
151c151
< readDocumentByName ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → String → i (Maybe a)
---
> readDocumentByName :: (MonadIO i, Functor i, FromJSON a) => FilePath -> String -> i (Maybe a)
157c157
< documentIdFromName ∷ (MonadIO i, Functor i) ⇒ FilePath → String → i (Maybe Int)
---
> documentIdFromName :: (MonadIO i, Functor i) => FilePath -> String -> i (Maybe Int)
163c163
< documentNameFromId ∷ (MonadIO i, Functor i) ⇒ FilePath → Int → i (Maybe String)
---
> documentNameFromId :: (MonadIO i, Functor i) => FilePath -> Int -> i (Maybe String)
165a166
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Safe, FlexibleContexts, UnicodeSyntax #-}

-- | Gitson is a simple document store library for Git + JSON.
module Gitson (
  TransactionWriter
, createRepo
, transaction
, saveDocument
, saveNextDocument
, saveDocumentById
, saveDocumentByName
, listCollections
, listDocumentKeys
, listEntries
, readDocument
, readDocumentById
, readDocumentByName
, documentIdFromName
, documentNameFromId
) where

import           System.Directory
import           System.Lock.FLock
import           Control.Applicative
import           Control.Exception (try, IOException)
import           Control.Error.Util (hush)
import           Control.Monad.Trans.Writer
import           Control.Monad.Trans.Control
import           Control.Monad.IO.Class
import           Control.Monad (liftM)
import           Data.Maybe (fromMaybe, mapMaybe)
import           Data.List (find, isSuffixOf)
import           Text.Printf (printf)
import qualified Data.ByteString.Lazy as BL
import           Gitson.Util
import           Gitson.Json

-- | A transaction monad.
type TransactionWriter = WriterT [IO ()]

type IdAndName = (Int, String)
type FileName = String
type Finder = [(IdAndName, FileName)] → Maybe (IdAndName, FileName)

splitFindDocument ∷ (MonadIO i, Functor i) ⇒ FilePath → Finder → i (Maybe (IdAndName, FileName))
splitFindDocument collection finder =
  finder . mapMaybe (\x → intoFunctor (maybeReadIntString x) x) <$> listDocumentKeys collection

documentFullKey ∷ (MonadIO i, Functor i) ⇒ FilePath → Finder → i (Maybe FileName)
documentFullKey collection finder = (snd <$>) <$> splitFindDocument collection finder

findById ∷ Int → Finder
findById i = find $ (== i) . fst . fst

findByName ∷ String → Finder
findByName n = find $ isSuffixOf n . snd . fst

-- | Creates a git repository under a given path.
createRepo ∷ FilePath → IO ()
createRepo path = do
  createDirectoryIfMissing True path
  insideDirectory path $ shell "git" ["init"]

-- | Executes a blocking transaction on a repository, committing the results to git.
transaction ∷ (MonadIO i, Functor i, MonadBaseControl IO i) ⇒ FilePath → TransactionWriter i () → i ()
transaction repoPath action =
  insideDirectory repoPath $ do
    liftIO $ writeFile lockPath ""
    withLock lockPath Exclusive Block $ do
      writeActions ← execWriterT action
      shell "git" ["stash"] -- it's totally ok to do this without changes
      liftIO $ sequence_ writeActions
      shell "git" ["add", "--all"]
      shell "git" ["commit", "-m", "Gitson transaction"]
      shell "git" ["stash", "pop"]

combineKey ∷ IdAndName → FileName
combineKey (n, s) = printf "%06d-%s" n s

writeDocument ∷ ToJSON a ⇒ FilePath → FileName → a → IO ()
writeDocument collection key content = BL.writeFile (documentPath collection key) (encode content)

-- | Adds a write action to a transaction.
saveDocument ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → FileName → a → TransactionWriter i ()
saveDocument collection key content =
  tell [createDirectoryIfMissing True collection,
        writeDocument collection key content]

-- | Adds a write action to a transaction.
-- The key will start with a numeric id, incremented from the last id in the collection.
saveNextDocument ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → FileName → a → TransactionWriter i ()
saveNextDocument collection key content =
  tell [createDirectoryIfMissing True collection,
        listDocumentKeys collection >>=
        return . nextKeyId >>=
        \nextId → writeDocument collection (combineKey (nextId, key)) content]

-- | Adds a write action to a transaction.
-- Will update the document with the given numeric id.
saveDocumentById ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → Int → a → TransactionWriter i ()
saveDocumentById collection i content =
  tell [documentFullKey collection (findById i) >>=
        \k → case k of
          Just key → writeDocument collection key content
          Nothing → return ()]

-- | Adds a write action to a transaction.
-- Will update the document with the given numeric id.
saveDocumentByName ∷ (MonadIO i, Functor i, ToJSON a) ⇒ FilePath → String → a → TransactionWriter i ()
saveDocumentByName collection n content =
  tell [documentFullKey collection (findByName n) >>=
        \k → case k of
          Just key → writeDocument collection key content
          Nothing → return ()]

-- | Lists collections in the current repository.
listCollections ∷ (MonadIO i, Functor i) ⇒ i [FilePath]
listCollections = liftIO $ do
  contents ← try (getDirectoryContents =<< getCurrentDirectory) ∷ IO (Either IOException [FilePath])
  filterDirs $ fromMaybe [] $ hush contents

-- | Lists document keys in a collection.
listDocumentKeys ∷ (MonadIO i, Functor i) ⇒ FilePath → i [FileName]
listDocumentKeys collection = liftIO $ do
  contents ← try (getDirectoryContents collection) ∷ IO (Either IOException [String])
  return . filterFilenamesAsKeys . fromMaybe [] $ hush contents

-- | Lists entries in a collection.
listEntries ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → i [a]
listEntries collection = liftIO $ do
  maybes ← mapM (readDocument collection) =<< listDocumentKeys collection
  return . fromMaybe [] $ sequence maybes

-- | Reads a document from a collection by key.
readDocument ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → FileName → i (Maybe a)
readDocument collection key = liftIO $ do
  jsonString ← try (BL.readFile $ documentPath collection key) ∷ IO (Either IOException BL.ByteString)
  return $ decode =<< hush jsonString

readDocument' ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → Maybe FileName → i (Maybe a)
readDocument' collection key = liftIO $ case key of
  Just key → readDocument collection key
  Nothing → return Nothing

-- | Reads a document from a collection by numeric id (for example, key "00001-hello" has id 1).
readDocumentById ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → Int → i (Maybe a)
readDocumentById collection i =
  readDocument' collection =<< documentFullKey collection (findById i)

-- | Reads a document from a collection by name (for example, key "00001-hello" has name "hello").
readDocumentByName ∷ (MonadIO i, Functor i, FromJSON a) ⇒ FilePath → String → i (Maybe a)
readDocumentByName collection n =
  readDocument' collection =<< documentFullKey collection (findByName n)

-- | Returns a document's id by name (for example, "hello" will return 23 when key "00023-hello" exists).
-- Does not read the document!
documentIdFromName ∷ (MonadIO i, Functor i) ⇒ FilePath → String → i (Maybe Int)
documentIdFromName collection n =
  (fst <$> fst <$>) <$> splitFindDocument collection (findByName n)

-- | Returns a document's name by id (for example, 23 will return "hello" when key "00023-hello" exists).
-- Does not read the document!
documentNameFromId ∷ (MonadIO i, Functor i) ⇒ FilePath → Int → i (Maybe String)
documentNameFromId collection i =
  (drop 1 . snd <$> fst <$>) <$> splitFindDocument collection (findById i)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Safe, FlexibleContexts, UnicodeSyntax #-}

-- | Gitson is a simple document store library for Git + JSON.
module Gitson (
  TransactionWriter
, createRepo
, transaction
, saveDocument
, saveNextDocument
, saveDocumentById
, saveDocumentByName
, listCollections
, listDocumentKeys
, listEntries
, readDocument
, readDocumentById
, readDocumentByName
, documentIdFromName
, documentNameFromId
) where

import           System.Directory
import           System.Lock.FLock
import           Control.Applicative
import           Control.Exception (try, IOException)
import           Control.Error.Util (hush)
import           Control.Monad.Trans.Writer
import           Control.Monad.Trans.Control
import           Control.Monad.IO.Class
import           Control.Monad (liftM)
import           Data.Maybe (fromMaybe, mapMaybe)
import           Data.List (find, isSuffixOf)
import           Text.Printf (printf)
import qualified Data.ByteString.Lazy as BL
import           Gitson.Util
import           Gitson.Json

-- | A transaction monad.
type TransactionWriter = WriterT [IO ()]

type IdAndName = (Int, String)
type FileName = String
type Finder = [(IdAndName, FileName)] -> Maybe (IdAndName, FileName)

splitFindDocument :: (MonadIO i, Functor i) => FilePath -> Finder -> i (Maybe (IdAndName, FileName))
splitFindDocument collection finder =
  finder . mapMaybe (\x -> intoFunctor (maybeReadIntString x) x) <$> listDocumentKeys collection

documentFullKey :: (MonadIO i, Functor i) => FilePath -> Finder -> i (Maybe FileName)
documentFullKey collection finder = (snd <$>) <$> splitFindDocument collection finder

findById :: Int -> Finder
findById i = find $ (== i) . fst . fst

findByName :: String -> Finder
findByName n = find $ isSuffixOf n . snd . fst

-- | Creates a git repository under a given path.
createRepo :: FilePath -> IO ()
createRepo path = do
  createDirectoryIfMissing True path
  insideDirectory path $ shell "git" ["init"]

-- | Executes a blocking transaction on a repository, committing the results to git.
transaction :: (MonadIO i, Functor i, MonadBaseControl IO i) => FilePath -> TransactionWriter i () -> i ()
transaction repoPath action =
  insideDirectory repoPath $ do
    liftIO $ writeFile lockPath ""
    withLock lockPath Exclusive Block $ do
      writeActions <- execWriterT action
      shell "git" ["stash"] -- it's totally ok to do this without changes
      liftIO $ sequence_ writeActions
      shell "git" ["add", "--all"]
      shell "git" ["commit", "-m", "Gitson transaction"]
      shell "git" ["stash", "pop"]

combineKey :: IdAndName -> FileName
combineKey (n, s) = printf "%06d-%s" n s

writeDocument :: ToJSON a => FilePath -> FileName -> a -> IO ()
writeDocument collection key content = BL.writeFile (documentPath collection key) (encode content)

-- | Adds a write action to a transaction.
saveDocument :: (MonadIO i, Functor i, ToJSON a) => FilePath -> FileName -> a -> TransactionWriter i ()
saveDocument collection key content =
  tell [createDirectoryIfMissing True collection,
        writeDocument collection key content]

-- | Adds a write action to a transaction.
-- The key will start with a numeric id, incremented from the last id in the collection.
saveNextDocument :: (MonadIO i, Functor i, ToJSON a) => FilePath -> FileName -> a -> TransactionWriter i ()
saveNextDocument collection key content =
  tell [createDirectoryIfMissing True collection,
        listDocumentKeys collection >>=
        return . nextKeyId >>=
        \nextId -> writeDocument collection (combineKey (nextId, key)) content]

-- | Adds a write action to a transaction.
-- Will update the document with the given numeric id.
saveDocumentById :: (MonadIO i, Functor i, ToJSON a) => FilePath -> Int -> a -> TransactionWriter i ()
saveDocumentById collection i content =
  tell [documentFullKey collection (findById i) >>=
        \k -> case k of
          Just key -> writeDocument collection key content
          Nothing -> return ()]

-- | Adds a write action to a transaction.
-- Will update the document with the given numeric id.
saveDocumentByName :: (MonadIO i, Functor i, ToJSON a) => FilePath -> String -> a -> TransactionWriter i ()
saveDocumentByName collection n content =
  tell [documentFullKey collection (findByName n) >>=
        \k -> case k of
          Just key -> writeDocument collection key content
          Nothing -> return ()]

-- | Lists collections in the current repository.
listCollections :: (MonadIO i, Functor i) => i [FilePath]
listCollections = liftIO $ do
  contents <- try (getDirectoryContents =<< getCurrentDirectory) :: IO (Either IOException [FilePath])
  filterDirs $ fromMaybe [] $ hush contents

-- | Lists document keys in a collection.
listDocumentKeys :: (MonadIO i, Functor i) => FilePath -> i [FileName]
listDocumentKeys collection = liftIO $ do
  contents <- try (getDirectoryContents collection) :: IO (Either IOException [String])
  return . filterFilenamesAsKeys . fromMaybe [] $ hush contents

-- | Lists entries in a collection.
listEntries :: (MonadIO i, Functor i, FromJSON a) => FilePath -> i [a]
listEntries collection = liftIO $ do
  maybes <- mapM (readDocument collection) =<< listDocumentKeys collection
  return . fromMaybe [] $ sequence maybes

-- | Reads a document from a collection by key.
readDocument :: (MonadIO i, Functor i, FromJSON a) => FilePath -> FileName -> i (Maybe a)
readDocument collection key = liftIO $ do
  jsonString <- try (BL.readFile $ documentPath collection key) :: IO (Either IOException BL.ByteString)
  return $ decode =<< hush jsonString

readDocument' :: (MonadIO i, Functor i, FromJSON a) => FilePath -> Maybe FileName -> i (Maybe a)
readDocument' collection key = liftIO $ case key of
  Just key -> readDocument collection key
  Nothing -> return Nothing

-- | Reads a document from a collection by numeric id (for example, key "00001-hello" has id 1).
readDocumentById :: (MonadIO i, Functor i, FromJSON a) => FilePath -> Int -> i (Maybe a)
readDocumentById collection i =
  readDocument' collection =<< documentFullKey collection (findById i)

-- | Reads a document from a collection by name (for example, key "00001-hello" has name "hello").
readDocumentByName :: (MonadIO i, Functor i, FromJSON a) => FilePath -> String -> i (Maybe a)
readDocumentByName collection n =
  readDocument' collection =<< documentFullKey collection (findByName n)

-- | Returns a document's id by name (for example, "hello" will return 23 when key "00023-hello" exists).
-- Does not read the document!
documentIdFromName :: (MonadIO i, Functor i) => FilePath -> String -> i (Maybe Int)
documentIdFromName collection n =
  (fst <$> fst <$>) <$> splitFindDocument collection (findByName n)

-- | Returns a document's name by id (for example, 23 will return "hello" when key "00023-hello" exists).
-- Does not read the document!
documentNameFromId :: (MonadIO i, Functor i) => FilePath -> Int -> i (Maybe String)
documentNameFromId collection i =
  (drop 1 . snd <$> fst <$>) <$> splitFindDocument collection (findById i)

</pre>