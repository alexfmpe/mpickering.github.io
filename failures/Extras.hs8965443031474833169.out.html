<a href="Execute.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Factorial.hs15223954191779636775.out.html">next</a></br></br><pre>121d120
<    succ a               = Lift $ succ_     REFLECT (lower a)
122d120
<    pred a               = Lift $ pred_     REFLECT (lower a)
123d120
<    toEnum a             = Lift $ toEnum_   REFLECT a
124d120
<    fromEnum a           =        fromEnum_ REFLECT $ lower a
125d120
<    enumFrom       a     = map Lift $ enumFrom_       REFLECT (lower a)
126d120
<    enumFromThen   a b   = map Lift $ enumFromThen_   REFLECT (lower a) (lower b)
127d120
<    enumFromTo     a b   = map Lift $ enumFromTo_     REFLECT (lower a) (lower b)
128c121
<    enumFromThenTo a b c = map Lift $ enumFromThenTo_ REFLECT (lower a) (lower b) (lower c)
---
>    succ a               = Lift $ succ_     (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
128a122
>    pred a               = Lift $ pred_     (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
128a123
>    toEnum a             = Lift $ toEnum_   (REFLECTreflecta(Proxy :: Proxy s)) a
128a124
>    fromEnum a           =        fromEnum_ (REFLECTreflect$(Proxy ::a  Proxy s)) $ lower a
128a125
>    enumFrom       a     = map Lift $ enumFrom_       (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
128a126
>    enumFromThen   a b   = map Lift $ enumFromThen_   (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
128a127
>    enumFromTo     a b   = map Lift $ enumFromTo_     (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
128a128
>    enumFromThenTo a b c = map Lift $ enumFromThenTo_ (REFLECTreflect((lowerProxya::) (Proxy s))((lowerlowerca) (lower b) (lower c)
144d143
<   minBound = Lift $ minBound_ REFLECT
145c144
<   maxBound = Lift $ maxBound_ REFLECT
---
>   minBound = Lift $ minBound_ (REFLECTreflect (Proxy :: Proxy s))
145a145
>   maxBound = Lift $ maxBound_ (REFLECTreflect (Proxy :: Proxy s))
155d154
<   (+)         = liftA2 ((+.) REFLECT)
156d154
<   (*)         = liftA2 ((*.) REFLECT)
157d154
<   (-)         = liftA2 ((-.) REFLECT)
158d154
<   negate      = fmap (negate_ REFLECT)
159d154
<   abs         = fmap (abs_ REFLECT)
160d154
<   signum      = fmap (signum_ REFLECT)
161c155
<   fromInteger = Lift . fromInteger_  REFLECT
---
>   (+)         = liftA2 ((+.) (REFLECTreflect) (Proxy :: Proxy s)))
161a156
>   (*)         = liftA2 ((*.) (REFLECTreflect) (Proxy :: Proxy s)))
161a157
>   (-)         = liftA2 ((-.) (REFLECTreflect) (Proxy :: Proxy s)))
161a158
>   negate      = fmap (negate_ (REFLECTreflect) (Proxy :: Proxy s)))
161a159
>   abs         = fmap (abs_ (REFLECTreflect) (Proxy :: Proxy s)))
161a160
>   signum      = fmap (signum_ (REFLECTreflect) (Proxy :: Proxy s)))
161a161
>   fromInteger = Lift . fromInteger_  (REFLECTreflect (Proxy :: Proxy s))
179c179
<    compare a b = (compare_ . ordDef) REFLECT (lower a) (lower b)
---
>    compare a b = (compare_ . ordDef) (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
182d181
<    (+)         = liftA2 ((+.) $ numDef REFLECT)
183d181
<    (*)         = liftA2 ((*.) $ numDef REFLECT)
184d181
<    (-)         = liftA2 ((-.) $ numDef REFLECT)
185d181
<    negate      = fmap (negate_ $ numDef REFLECT)
186d181
<    abs         = fmap (abs_ $ numDef REFLECT)
187d181
<    signum      = fmap (signum_ $ numDef REFLECT)
188c182
<    fromInteger = Lift . (fromInteger_ . numDef) REFLECT
---
>    (+)         = liftA2 ((+.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a183
>    (*)         = liftA2 ((*.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a184
>    (-)         = liftA2 ((-.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a185
>    negate      = fmap (negate_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a186
>    abs         = fmap (abs_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a187
>    signum      = fmap (signum_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
188a188
>    fromInteger = Lift . (fromInteger_ . numDef) (REFLECTreflect (Proxy :: Proxy s))
191c191
<   toRational a = toRational_ REFLECT (lower a)
---
>   toRational a = toRational_ (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
203c203
<    toRational a = (toRational_ $ realDef REFLECT) (lower a)
---
>    toRational a = (toRational_ $ realDef (reflect (Proxy :: Proxy s))) (lower a)
206d205
<    quot    a b = Lift $ quot_    REFLECT (lower a) (lower b)
207d205
<    rem     a b = Lift $ rem_     REFLECT (lower a) (lower b)
208d205
<    div     a b = Lift $ div_     REFLECT (lower a) (lower b)
209d205
<    mod     a b = Lift $ mod_     REFLECT (lower a) (lower b)
210d205
<    quotRem a b = over both Lift $ quotRem_ REFLECT (lower a) (lower b)
211d205
<    divMod  a b = over both Lift $ divMod_  REFLECT (lower a) (lower b)
212c206
<    toInteger a = toInteger_ REFLECT (lower a)
---
>    quot    a b = Lift $ quot_    (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a207
>    rem     a b = Lift $ rem_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a208
>    div     a b = Lift $ div_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a209
>    mod     a b = Lift $ mod_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a210
>    quotRem a b = over both Lift $ quotRem_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a211
>    divMod  a b = over both Lift $ divMod_  (reflect (Proxy :: Proxy s)) (lower a) (lower b)
212a212
>    toInteger a = toInteger_ (reflect (Proxy :: Proxy s)) (lower a)
228d227
<   (/)          a b = Lift $ (/.) REFLECT (lower a) (lower b)
229d227
<   recip        a b = Lift $ recip REFLECT (lower a) (lower b)
230c228
<   fromRational a b = Lift $ fromRational_ REFLECT (lower a) (lower b)
---
>   (/)          a b = Lift $ (/.) (reflect (Proxy :: Proxy s)) (lower a) (lower b)
230a229
>   recip        a b = Lift $ recip (reflect (Proxy :: Proxy s)) (lower a) (lower b)
230a230
>   fromRational a b = Lift $ fromRational_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)
242d241
<    exp     a   = Lift $ exp_     REFLECT (lower a)
243d241
<    sqrt    a   = Lift $ sqrt_    REFLECT (lower a)
244d241
<    log     a   = Lift $ log_     REFLECT (lower a)
245d241
<    (**)    a b = Lift $ (**.)    REFLECT (lower a) (lower b)
246d241
<    logBase a b = Lift $ logBase_ REFLECT (lower a) (lower b)
247d241
<    sin     a   = Lift $ sin_     REFLECT (lower a)
248d241
<    tan     a   = Lift $ tan_     REFLECT (lower a)
249d241
<    cos     a   = Lift $ cos_     REFLECT (lower a)
250d241
<    asin    a   = Lift $ asin_    REFLECT (lower a)
251d241
<    atan    a   = Lift $ atan_    REFLECT (lower a)
252d241
<    acos    a   = Lift $ acos_    REFLECT (lower a)
253d241
<    sinh    a   = Lift $ sinh_    REFLECT (lower a)
254d241
<    tanh    a   = Lift $ tanh_    REFLECT (lower a)
255d241
<    cosh    a   = Lift $ cosh_    REFLECT (lower a)
256d241
<    asinh   a   = Lift $ asinh_   REFLECT (lower a)
257d241
<    atanh   a   = Lift $ atanh_   REFLECT (lower a)
258c242
<    acosh   a   = Lift $ acosh_   REFLECT (lower a)
---
>    exp     a   = Lift $ exp_     (reflect (Proxy :: Proxy s)) (lower a)
258a243
>    sqrt    a   = Lift $ sqrt_    (reflect (Proxy :: Proxy s)) (lower a)
258a244
>    log     a   = Lift $ log_     (reflect (Proxy :: Proxy s)) (lower a)
258a245
>    (**)    a b = Lift $ (**.)    (reflect (Proxy :: Proxy s)) (lower a) (lower b)
258a246
>    logBase a b = Lift $ logBase_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)
258a247
>    sin     a   = Lift $ sin_     (reflect (Proxy :: Proxy s)) (lower a)
258a248
>    tan     a   = Lift $ tan_     (reflect (Proxy :: Proxy s)) (lower a)
258a249
>    cos     a   = Lift $ cos_     (reflect (Proxy :: Proxy s)) (lower a)
258a250
>    asin    a   = Lift $ asin_    (reflect (Proxy :: Proxy s)) (lower a)
258a251
>    atan    a   = Lift $ atan_    (reflect (Proxy :: Proxy s)) (lower a)
258a252
>    acos    a   = Lift $ acos_    (reflect (Proxy :: Proxy s)) (lower a)
258a253
>    sinh    a   = Lift $ sinh_    (reflect (Proxy :: Proxy s)) (lower a)
258a254
>    tanh    a   = Lift $ tanh_    (reflect (Proxy :: Proxy s)) (lower a)
258a255
>    cosh    a   = Lift $ cosh_    (reflect (Proxy :: Proxy s)) (lower a)
258a256
>    asinh   a   = Lift $ asinh_   (reflect (Proxy :: Proxy s)) (lower a)
258a257
>    atanh   a   = Lift $ atanh_   (reflect (Proxy :: Proxy s)) (lower a)
258a258
>    acosh   a   = Lift $ acosh_   (reflect (Proxy :: Proxy s)) (lower a)
284d283
<    properFraction a = fmap Lift $ properFraction_ REFLECT (lower a)
285d283
<    truncate       a =      Lift $ truncate_       REFLECT (lower a)
286d283
<    round          a =      Lift $ round_          REFLECT (lower a)
287d283
<    ceiling        a =      Lift $ ceiling_        REFLECT (lower a)
288c284
<    floor          a =      Lift $ floor_          REFLECT (lower a)
---
>    properFraction a = fmap Lift $ properFraction_ (reflect (Proxy :: Proxy s)) (lower a)
288a285
>    truncate       a =      Lift $ truncate_       (reflect (Proxy :: Proxy s)) (lower a)
288a286
>    round          a =      Lift $ round_          (reflect (Proxy :: Proxy s)) (lower a)
288a287
>    ceiling        a =      Lift $ ceiling_        (reflect (Proxy :: Proxy s)) (lower a)
288a288
>    floor          a =      Lift $ floor_          (reflect (Proxy :: Proxy s)) (lower a)
302d301
<    floatRadix     a   = floatRadix_     REFLECT (lower a)
303d301
<    floatDigits    a   = floatDigits_    REFLECT (lower a)
304d301
<    floatRange     a   = floatRange_     REFLECT (lower a)
305c302
<    decodeFloat    a   = decodeFloat_    REFLECT (lower a)
---
>    floatRadix     a   = floatRadix_     (reflect (Proxy :: Proxy s)) (lower a)
305a303
>    floatDigits    a   = floatDigits_    (reflect (Proxy :: Proxy s)) (lower a)
305a304
>    floatRange     a   = floatRange_     (reflect (Proxy :: Proxy s)) (lower a)
305a305
>    decodeFloat    a   = decodeFloat_    (reflect (Proxy :: Proxy s)) (lower a)
307c307
<    exponent       a   = exponent_       REFLECT (lower a)
---
>    exponent       a   = exponent_       (reflect (Proxy :: Proxy s)) (lower a)
310d309
<    isInfinite     a   = isInfinite_     REFLECT (lower a)
311d309
<    isDenormalized a   = isDenormalized_ REFLECT (lower a)
312d309
<    isNegativeZero a   = isNegativeZero_ REFLECT (lower a)
313d309
<    isIEEE         a   = isIEEE_         REFLECT (lower a)
314c310
<    atan2          a   = atan2_          REFLECT (lower a)
---
>    isInfinite     a   = isInfinite_     (reflect (Proxy :: Proxy s)) (lower a)
314a311
>    isDenormalized a   = isDenormalized_ (reflect (Proxy :: Proxy s)) (lower a)
314a312
>    isNegativeZero a   = isNegativeZero_ (reflect (Proxy :: Proxy s)) (lower a)
314a313
>    isIEEE         a   = isIEEE_         (reflect (Proxy :: Proxy s)) (lower a)
314a314
>    atan2          a   = atan2_          (reflect (Proxy :: Proxy s)) (lower a)
354c354
<   show = show_ REFLECT . lower
---
>   show = show_ (REFLECTreflect.(Proxy :: Proxy s)) . lower
365c365
<   readsPrec x s = over _1 Lift <$> readsPrec_ REFLECT x s
---
>   readsPrec x s = over _1 Lift <$> readsPrec_ (REFLECTreflectx(Proxys     :: Proxy s)) x s
367c367
<                <$> readList_  REFLECT s
---
>                <$> readList_  (REFLECTreflects(Proxy :: Proxy s)) s
374c374
<    x == y = eq_ REFLECT (lower x) (lower y)
---
>    x == y = eq_ (REFLECTreflect((lowerProxyx::) (Proxy s)) (lower x) (lower y)
384c384
<   compare a b = compare_ REFLECT (lower a) (lower b)
---
>   compare a b = compare_ (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
391d390
<   mappend = liftA2 (mappend_ REFLECT)
392c391
<   mempty  = pure $ mempty_ REFLECT
---
>   mappend = liftA2 (mappend_ (REFLECTreflect) (Proxy :: Proxy s)))
392a392
>   mempty  = pure $ mempty_ (REFLECTreflect (Proxy :: Proxy s))
400c400
<    parseJSON = fmap pure . parseJSON_ REFLECT
---
>    parseJSON = fmap pure . parseJSON_ (REFLECTreflect (Proxy :: Proxy s))
407c407
<    toJSON a = toJSON_ REFLECT (lower a)
---
>    toJSON a = toJSON_ (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
407a408
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE KindSignatures#-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE CPP #-}
module Data.Reflection.Extras
   ( using
   , usingT
   , reifyInstance
   , with
   , Lift
   , ReifiableConstraint (..)
   , Reifies (..)
   , Def (..)
   , FromJSON (..)
   , ToJSON (..)
   ) where
import Data.Constraint
import Data.Constraint.Unsafe
import Data.Monoid
import Data.Proxy
import Data.Reflection
import Control.Lens
import Data.Aeson
import Data.Aeson.Types
import Control.Applicative

#define REFLECT (reflect (Proxy :: Proxy s))

--------------------------------------------------------------------------------
-- Intro
-- I made this a functor to make the instances easier
newtype Lift (p :: * -> Constraint) (s :: *) (a :: *) = Lift { lower :: a }
   deriving (Functor)

instance Applicative (Lift p s) where
   pure              = Lift
   Lift f <*> Lift x = Lift $ f x

makeIso ''Lift

newtype ProxyLift (p :: * -> Constraint) (a :: *) (s :: *) = PLift { plower :: a }

makeIso ''ProxyLift

flipS :: Iso' (Lift p s a) (ProxyLift p a s)
flipS = from lift . pLift

class ReifiableConstraint p where
  data Def (p :: * -> Constraint) (a :: * ) :: *
  reifiedIns :: forall s a. Reifies s (Def p a) :- p (Lift p s a)
--  default reifiedIns :: forall s a. p (Lift p s a)
--                     => Reifies s (Def p a) :- p (Lift p s a)
--  reifiedIns = Sub (Dict :: Reifies s (Def p a)
--                         => Dict (p (Lift p s a)))

--------------------------------------------------------------------------------
-- Machinery


with :: forall p a. Def p a -> (forall s. Reifies s (Def p a) => Lift p s a) -> a
with d v = reify d (plower . asProxyOf (view flipS v))

reifyInstance :: Def p a -> (forall (s :: *). Reifies s (Def p a) => Proxy s -> r) -> r
reifyInstance = reify

asProxyOf :: f s -> Proxy s -> f s
asProxyOf a _ = a

-- | Choose a dictionary for a local type class instance.
--
--   >>> using (Monoid (+) 0) $ mempty <> 10 <> 12
--   > 12
--
using :: forall p a. ReifiableConstraint p => Def p a -> (p a => a) -> a
using d m = reify d $ \(_ :: Proxy s) ->
  let replaceProof :: Reifies s (Def p a) :- p a
      replaceProof = trans proof reifiedIns
        where proof = unsafeCoerceConstraint :: p (Lift p s a) :- p a
  in m \\ replaceProof

usingT :: forall p f a. ReifiableConstraint p => Def p a -> (p a => f a) -> f a
usingT d m = reify d $ \(_ :: Proxy s) ->
  let replaceProof :: Reifies s (Def p a) :- p a
      replaceProof = trans proof reifiedIns
        where proof = unsafeCoerceConstraint :: p (Lift p s a) :- p a
  in m \\ replaceProof

{-
-- ClassProxy
data ClassProxy (p :: * -> Constraint) = ClassProxy

given :: ClassProxy c -> p s -> a -> Lift c s a
given _ _ = Lift

eq :: ClassProxy Eq
eq = ClassProxy

ord :: ClassProxy Ord
ord = ClassProxy

monoid :: ClassProxy Monoid
monoid = ClassProxy
-}
--------------------------------------------------------------------------------
-- Instances


instance Reifies s (Def Enum a) => Enum (Lift Enum s a) where
   succ a               = Lift $ succ_     REFLECT (lower a)
   pred a               = Lift $ pred_     REFLECT (lower a)
   toEnum a             = Lift $ toEnum_   REFLECT a
   fromEnum a           =        fromEnum_ REFLECT $ lower a
   enumFrom       a     = map Lift $ enumFrom_       REFLECT (lower a)
   enumFromThen   a b   = map Lift $ enumFromThen_   REFLECT (lower a) (lower b)
   enumFromTo     a b   = map Lift $ enumFromTo_     REFLECT (lower a) (lower b)
   enumFromThenTo a b c = map Lift $ enumFromThenTo_ REFLECT (lower a) (lower b) (lower c)

instance ReifiableConstraint Enum where
  data Def Enum a = Enum
      { succ_           :: a -> a
      , pred_           :: a -> a
      , toEnum_         :: Int -> a
      , fromEnum_       :: a -> Int
      , enumFrom_       :: a -> [a]
      , enumFromThen_   :: a -> a -> [a]
      , enumFromTo_     :: a -> a -> [a]
      , enumFromThenTo_ :: a -> a -> a -> [a]
      }
  reifiedIns = Sub Dict

instance Reifies s (Def Bounded a) => Bounded (Lift Bounded s a) where
  minBound = Lift $ minBound_ REFLECT
  maxBound = Lift $ maxBound_ REFLECT

instance ReifiableConstraint Bounded where
  data Def Bounded a = Bounded
     { minBound_ :: a
     , maxBound_ :: a
     }
  reifiedIns = Sub Dict

instance Reifies s (Def Num a) => Num (Lift Num s a) where
  (+)         = liftA2 ((+.) REFLECT)
  (*)         = liftA2 ((*.) REFLECT)
  (-)         = liftA2 ((-.) REFLECT)
  negate      = fmap (negate_ REFLECT)
  abs         = fmap (abs_ REFLECT)
  signum      = fmap (signum_ REFLECT)
  fromInteger = Lift . fromInteger_  REFLECT

instance ReifiableConstraint Num where
  data Def Num a = Num
     { (+.)         :: a -> a -> a
     , (*.)         :: a -> a -> a
     , (-.)         :: a -> a -> a
     , negate_      :: a -> a
     , abs_         :: a -> a
     , signum_      :: a -> a
     , fromInteger_ :: Integer -> a
     }
  reifiedIns = Sub Dict

instance (Reifies s (Def Real a)) => Eq (Lift Real s a) where
   a == b = compare a b == EQ

instance (Reifies s (Def Real a)) => Ord (Lift Real s a) where
   compare a b = (compare_ . ordDef) REFLECT (lower a) (lower b)

instance (Reifies s (Def Real a)) => Num (Lift Real s a) where
   (+)         = liftA2 ((+.) $ numDef REFLECT)
   (*)         = liftA2 ((*.) $ numDef REFLECT)
   (-)         = liftA2 ((-.) $ numDef REFLECT)
   negate      = fmap (negate_ $ numDef REFLECT)
   abs         = fmap (abs_ $ numDef REFLECT)
   signum      = fmap (signum_ $ numDef REFLECT)
   fromInteger = Lift . (fromInteger_ . numDef) REFLECT

instance Reifies s (Def Real a) => Real (Lift Real s a) where
  toRational a = toRational_ REFLECT (lower a)

instance ReifiableConstraint Real where
 data Def Real a = Real
   { toRational_ :: a -> Rational
   , ordDef      :: Def Ord a
   , numDef      :: Def Num a
   }
 reifiedIns = Sub Dict

{-
instance Reifies s (Def Integral a) => Real (Lift Integral s a) where
   toRational a = (toRational_ $ realDef REFLECT) (lower a)

instance Reifies s (Def Integral a) => Integral (Lift Integral s a) where
   quot    a b = Lift $ quot_    REFLECT (lower a) (lower b)
   rem     a b = Lift $ rem_     REFLECT (lower a) (lower b)
   div     a b = Lift $ div_     REFLECT (lower a) (lower b)
   mod     a b = Lift $ mod_     REFLECT (lower a) (lower b)
   quotRem a b = over both Lift $ quotRem_ REFLECT (lower a) (lower b)
   divMod  a b = over both Lift $ divMod_  REFLECT (lower a) (lower b)
   toInteger a = toInteger_ REFLECT (lower a)

instance ReifiableConstraint Integral where
  data Def Integral a = Integral
     { quot_      :: a -> a -> a
     , rem_       :: a -> a -> a
     , div_       :: a -> a -> a
     , mod_       :: a -> a -> a
     , quotRem_   :: a -> a -> (a, a)
     , divMod_    :: a -> a -> (a, a)
     , toInteger_ :: a -> Integer
     , realDef    :: Def Real a
     }
  reifiedIns = Sub Dict

instance Reifies s (Def Fractional a) => Fractional (Lift Fractional s a) where
  (/)          a b = Lift $ (/.) REFLECT (lower a) (lower b)
  recip        a b = Lift $ recip REFLECT (lower a) (lower b)
  fromRational a b = Lift $ fromRational_ REFLECT (lower a) (lower b)

instance ReifiableConstraint Fractional where
  data Def Fractional a = Fractional
      { (/.)          :: a -> a -> a
      , recip_        :: a -> a
      , fromRational_ :: Rational -> a
      }
  reifiedIns = Sub Dict

instance Reifies s (Def Floating a) => Floating (Lift Floating s a) where
   pi          = Lift $ pi_      reflect (Proxy :: Proxy s)
   exp     a   = Lift $ exp_     REFLECT (lower a)
   sqrt    a   = Lift $ sqrt_    REFLECT (lower a)
   log     a   = Lift $ log_     REFLECT (lower a)
   (**)    a b = Lift $ (**.)    REFLECT (lower a) (lower b)
   logBase a b = Lift $ logBase_ REFLECT (lower a) (lower b)
   sin     a   = Lift $ sin_     REFLECT (lower a)
   tan     a   = Lift $ tan_     REFLECT (lower a)
   cos     a   = Lift $ cos_     REFLECT (lower a)
   asin    a   = Lift $ asin_    REFLECT (lower a)
   atan    a   = Lift $ atan_    REFLECT (lower a)
   acos    a   = Lift $ acos_    REFLECT (lower a)
   sinh    a   = Lift $ sinh_    REFLECT (lower a)
   tanh    a   = Lift $ tanh_    REFLECT (lower a)
   cosh    a   = Lift $ cosh_    REFLECT (lower a)
   asinh   a   = Lift $ asinh_   REFLECT (lower a)
   atanh   a   = Lift $ atanh_   REFLECT (lower a)
   acosh   a   = Lift $ acosh_   REFLECT (lower a)

instance ReifiableConstraint Floating where
  data Def Floating a = Floating
      { pi_      :: a
      , exp_     :: a -> a
      , sqrt_    :: a -> a
      , log_     :: a -> a
      , (**.)    :: a -> a -> a
      , logBase_ :: a -> a -> a
      , sin_     :: a -> a
      , tan_     :: a -> a
      , cos_     :: a -> a
      , asin_    :: a -> a
      , atan_    :: a -> a
      , acos_    :: a -> a
      , sinh_    :: a -> a
      , tanh_    :: a -> a
      , cosh_    :: a -> a
      , asinh_   :: a -> a
      , atanh_   :: a -> a
      , acosh_   :: a -> a
      }
  reifiedIns = Sub Dict

instance Reifies s (Def RealFrac a) => RealFrac (Lift RealFrac s a) where
   properFraction a = fmap Lift $ properFraction_ REFLECT (lower a)
   truncate       a =      Lift $ truncate_       REFLECT (lower a)
   round          a =      Lift $ round_          REFLECT (lower a)
   ceiling        a =      Lift $ ceiling_        REFLECT (lower a)
   floor          a =      Lift $ floor_          REFLECT (lower a)


instance ReifiableConstraint RealFrac where
  data Def RealFrac a = RealFrac
      { properFraction_ :: Integral b => a -> (b, a)
      , truncate_       :: Integral b => a -> b
      , round_          :: Integral b => a -> b
      , ceiling_        :: Integral b => a -> b
      , floor_          :: Integral b => a -> b
      }
  reifiedIns = Sub Dict

instance Reifies s (Def RealFloat a) => RealFloat (Lift RealFloat s a) where
   floatRadix     a   = floatRadix_     REFLECT (lower a)
   floatDigits    a   = floatDigits_    REFLECT (lower a)
   floatRange     a   = floatRange_     REFLECT (lower a)
   decodeFloat    a   = decodeFloat_    REFLECT (lower a)
   encodeFloat    a b = encodeFloat_    (reflect b) (lower a) (lower b)
   exponent       a   = exponent_       REFLECT (lower a)
   significand    a b = significand_    (reflect b) (lower a) (lower b)
   scaleFloat     a b = scaleFloat_     (reflect b) (lower a) (lower b)
   isInfinite     a   = isInfinite_     REFLECT (lower a)
   isDenormalized a   = isDenormalized_ REFLECT (lower a)
   isNegativeZero a   = isNegativeZero_ REFLECT (lower a)
   isIEEE         a   = isIEEE_         REFLECT (lower a)
   atan2          a   = atan2_          REFLECT (lower a)

instance ReifiableConstraint RealFloat where
  data Def RealFloat a = RealFloat
      { floatRadix_  :: a -> Integer
      , floatDigits_ :: a -> Int
      , floatRange_  :: a -> (Int, Int)
      , decodeFloat_ :: a -> (Integer, Int)
      , encodeFloat_ :: Integer -> Int -> a
      , exponent_    :: a -> Int
      , significand_  :: Int -> a -> a
      , scaleFloat_   :: Int -> a -> a
      , isInfinite_   :: a -> Bool
      , isDenormalized_ :: a -> Bool
      , isNegativeZero_ :: a -> Bool
      , isIEEE_         :: a -> Bool
      , atan2_          :: a -> Bool
      }
  reifiedIns = Sub Dict
-}

{-
I think this will need a reifyable constraint1
instance Reifies s (Def Monad a) => Monad (Lift Monad s a) where
   (>>=)  =
   (>>)   =
   return =
   fail   =

instance ReifiableConstraint Monad where
  data Def Monad a = Monad
      { (>>=.) :: forall a b. m a -> (a -> m b) -> m b
      , (>>.)  :: forall a b. m a -> m b -> m b
      , return :: a -> m a
      , fail   :: String -> m a
      }
  reifiedIns = Sub Dict
-}

instance Reifies s (Def Show a) => Show (Lift Show s a) where
  show = show_ REFLECT . lower

instance ReifiableConstraint Show where
  data Def Show a = Show { show_ :: a -> String }
  reifiedIns = Sub Dict

instance ReifiableConstraint Read where
  data Def Read a = Read { readsPrec_ :: Int -> ReadS a, readList_ :: ReadS [a] }
  reifiedIns = Sub Dict

instance Reifies s (Def Read a) => Read (Lift Read s a) where
  readsPrec x s = over _1 Lift <$> readsPrec_ REFLECT x s
  readList  s   = over _1 (fmap Lift)
               <$> readList_  REFLECT s

instance ReifiableConstraint Eq where
  data Def Eq a = Eq { eq_ :: a -> a -> Bool }
  reifiedIns = Sub Dict

instance Reifies s (Def Eq a) => Eq (Lift Eq s a) where
   x == y = eq_ REFLECT (lower x) (lower y)

instance ReifiableConstraint Ord where
  data Def Ord a = Ord { compare_ :: a -> a -> Ordering }
  reifiedIns = Sub Dict

instance Reifies s (Def Ord a) => Eq (Lift Ord s a) where
  a == b = compare a b == EQ

instance Reifies s (Def Ord a) => Ord (Lift Ord s a) where
  compare a b = compare_ REFLECT (lower a) (lower b)

instance ReifiableConstraint Monoid where
  data Def Monoid a = Monoid { mappend_ :: a -> a -> a, mempty_ :: a }
  reifiedIns = Sub Dict

instance Reifies s (Def Monoid a) => Monoid (Lift Monoid s a) where
  mappend = liftA2 (mappend_ REFLECT)
  mempty  = pure $ mempty_ REFLECT

-- Aeson Instances
instance ReifiableConstraint FromJSON where
   data Def FromJSON a = FromJSON { parseJSON_ :: Value -> Parser a }
   reifiedIns = Sub Dict

instance Reifies s (Def FromJSON a) => FromJSON (Lift FromJSON s a) where
   parseJSON = fmap pure . parseJSON_ REFLECT

instance ReifiableConstraint ToJSON where
   data Def ToJSON a = ToJSON { toJSON_ :: a -> Value}
   reifiedIns = Sub Dict

instance Reifies s (Def ToJSON a) => ToJSON (Lift ToJSON s a) where
   toJSON a = toJSON_ REFLECT (lower a)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE KindSignatures#-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE CPP #-}
module Data.Reflection.Extras
   ( using
   , usingT
   , reifyInstance
   , with
   , Lift
   , ReifiableConstraint (..)
   , Reifies (..)
   , Def (..)
   , FromJSON (..)
   , ToJSON (..)
   ) where
import Data.Constraint
import Data.Constraint.Unsafe
import Data.Monoid
import Data.Proxy
import Data.Reflection
import Control.Lens
import Data.Aeson
import Data.Aeson.Types
import Control.Applicative

#define REFLECT (reflect (Proxy :: Proxy s))

--------------------------------------------------------------------------------
-- Intro
-- I made this a functor to make the instances easier
newtype Lift (p :: * -> Constraint) (s :: *) (a :: *) = Lift { lower :: a }
   deriving (Functor)

instance Applicative (Lift p s) where
   pure              = Lift
   Lift f <*> Lift x = Lift $ f x

makeIso ''Lift

newtype ProxyLift (p :: * -> Constraint) (a :: *) (s :: *) = PLift { plower :: a }

makeIso ''ProxyLift

flipS :: Iso' (Lift p s a) (ProxyLift p a s)
flipS = from lift . pLift

class ReifiableConstraint p where
  data Def (p :: * -> Constraint) (a :: * ) :: *
  reifiedIns :: forall s a. Reifies s (Def p a) :- p (Lift p s a)
--  default reifiedIns :: forall s a. p (Lift p s a)
--                     => Reifies s (Def p a) :- p (Lift p s a)
--  reifiedIns = Sub (Dict :: Reifies s (Def p a)
--                         => Dict (p (Lift p s a)))

--------------------------------------------------------------------------------
-- Machinery


with :: forall p a. Def p a -> (forall s. Reifies s (Def p a) => Lift p s a) -> a
with d v = reify d (plower . asProxyOf (view flipS v))

reifyInstance :: Def p a -> (forall (s :: *). Reifies s (Def p a) => Proxy s -> r) -> r
reifyInstance = reify

asProxyOf :: f s -> Proxy s -> f s
asProxyOf a _ = a

-- | Choose a dictionary for a local type class instance.
--
--   >>> using (Monoid (+) 0) $ mempty <> 10 <> 12
--   > 12
--
using :: forall p a. ReifiableConstraint p => Def p a -> (p a => a) -> a
using d m = reify d $ \(_ :: Proxy s) ->
  let replaceProof :: Reifies s (Def p a) :- p a
      replaceProof = trans proof reifiedIns
        where proof = unsafeCoerceConstraint :: p (Lift p s a) :- p a
  in m \\ replaceProof

usingT :: forall p f a. ReifiableConstraint p => Def p a -> (p a => f a) -> f a
usingT d m = reify d $ \(_ :: Proxy s) ->
  let replaceProof :: Reifies s (Def p a) :- p a
      replaceProof = trans proof reifiedIns
        where proof = unsafeCoerceConstraint :: p (Lift p s a) :- p a
  in m \\ replaceProof

{-
-- ClassProxy
data ClassProxy (p :: * -> Constraint) = ClassProxy

given :: ClassProxy c -> p s -> a -> Lift c s a
given _ _ = Lift

eq :: ClassProxy Eq
eq = ClassProxy

ord :: ClassProxy Ord
ord = ClassProxy

monoid :: ClassProxy Monoid
monoid = ClassProxy
-}
--------------------------------------------------------------------------------
-- Instances


instance Reifies s (Def Enum a) => Enum (Lift Enum s a) where
   succ a               = Lift $ succ_     (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
   pred a               = Lift $ pred_     (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
   toEnum a             = Lift $ toEnum_   (REFLECTreflecta(Proxy :: Proxy s)) a
   fromEnum a           =        fromEnum_ (REFLECTreflect$(Proxy ::a  Proxy s)) $ lower a
   enumFrom       a     = map Lift $ enumFrom_       (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)
   enumFromThen   a b   = map Lift $ enumFromThen_   (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
   enumFromTo     a b   = map Lift $ enumFromTo_     (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)
   enumFromThenTo a b c = map Lift $ enumFromThenTo_ (REFLECTreflect((lowerProxya::) (Proxy s))((lowerlowerca) (lower b) (lower c)

instance ReifiableConstraint Enum where
  data Def Enum a = Enum
      { succ_           :: a -> a
      , pred_           :: a -> a
      , toEnum_         :: Int -> a
      , fromEnum_       :: a -> Int
      , enumFrom_       :: a -> [a]
      , enumFromThen_   :: a -> a -> [a]
      , enumFromTo_     :: a -> a -> [a]
      , enumFromThenTo_ :: a -> a -> a -> [a]
      }
  reifiedIns = Sub Dict

instance Reifies s (Def Bounded a) => Bounded (Lift Bounded s a) where
  minBound = Lift $ minBound_ (REFLECTreflect (Proxy :: Proxy s))
  maxBound = Lift $ maxBound_ (REFLECTreflect (Proxy :: Proxy s))

instance ReifiableConstraint Bounded where
  data Def Bounded a = Bounded
     { minBound_ :: a
     , maxBound_ :: a
     }
  reifiedIns = Sub Dict

instance Reifies s (Def Num a) => Num (Lift Num s a) where
  (+)         = liftA2 ((+.) (REFLECTreflect) (Proxy :: Proxy s)))
  (*)         = liftA2 ((*.) (REFLECTreflect) (Proxy :: Proxy s)))
  (-)         = liftA2 ((-.) (REFLECTreflect) (Proxy :: Proxy s)))
  negate      = fmap (negate_ (REFLECTreflect) (Proxy :: Proxy s)))
  abs         = fmap (abs_ (REFLECTreflect) (Proxy :: Proxy s)))
  signum      = fmap (signum_ (REFLECTreflect) (Proxy :: Proxy s)))
  fromInteger = Lift . fromInteger_  (REFLECTreflect (Proxy :: Proxy s))

instance ReifiableConstraint Num where
  data Def Num a = Num
     { (+.)         :: a -> a -> a
     , (*.)         :: a -> a -> a
     , (-.)         :: a -> a -> a
     , negate_      :: a -> a
     , abs_         :: a -> a
     , signum_      :: a -> a
     , fromInteger_ :: Integer -> a
     }
  reifiedIns = Sub Dict

instance (Reifies s (Def Real a)) => Eq (Lift Real s a) where
   a == b = compare a b == EQ

instance (Reifies s (Def Real a)) => Ord (Lift Real s a) where
   compare a b = (compare_ . ordDef) (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)

instance (Reifies s (Def Real a)) => Num (Lift Real s a) where
   (+)         = liftA2 ((+.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   (*)         = liftA2 ((*.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   (-)         = liftA2 ((-.) $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   negate      = fmap (negate_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   abs         = fmap (abs_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   signum      = fmap (signum_ $ numDef (REFLECTreflect) (Proxy :: Proxy s)))
   fromInteger = Lift . (fromInteger_ . numDef) (REFLECTreflect (Proxy :: Proxy s))

instance Reifies s (Def Real a) => Real (Lift Real s a) where
  toRational a = toRational_ (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)

instance ReifiableConstraint Real where
 data Def Real a = Real
   { toRational_ :: a -> Rational
   , ordDef      :: Def Ord a
   , numDef      :: Def Num a
   }
 reifiedIns = Sub Dict

{-
instance Reifies s (Def Integral a) => Real (Lift Integral s a) where
   toRational a = (toRational_ $ realDef (reflect (Proxy :: Proxy s))) (lower a)

instance Reifies s (Def Integral a) => Integral (Lift Integral s a) where
   quot    a b = Lift $ quot_    (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   rem     a b = Lift $ rem_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   div     a b = Lift $ div_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   mod     a b = Lift $ mod_     (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   quotRem a b = over both Lift $ quotRem_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   divMod  a b = over both Lift $ divMod_  (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   toInteger a = toInteger_ (reflect (Proxy :: Proxy s)) (lower a)

instance ReifiableConstraint Integral where
  data Def Integral a = Integral
     { quot_      :: a -> a -> a
     , rem_       :: a -> a -> a
     , div_       :: a -> a -> a
     , mod_       :: a -> a -> a
     , quotRem_   :: a -> a -> (a, a)
     , divMod_    :: a -> a -> (a, a)
     , toInteger_ :: a -> Integer
     , realDef    :: Def Real a
     }
  reifiedIns = Sub Dict

instance Reifies s (Def Fractional a) => Fractional (Lift Fractional s a) where
  (/)          a b = Lift $ (/.) (reflect (Proxy :: Proxy s)) (lower a) (lower b)
  recip        a b = Lift $ recip (reflect (Proxy :: Proxy s)) (lower a) (lower b)
  fromRational a b = Lift $ fromRational_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)

instance ReifiableConstraint Fractional where
  data Def Fractional a = Fractional
      { (/.)          :: a -> a -> a
      , recip_        :: a -> a
      , fromRational_ :: Rational -> a
      }
  reifiedIns = Sub Dict

instance Reifies s (Def Floating a) => Floating (Lift Floating s a) where
   pi          = Lift $ pi_      reflect (Proxy :: Proxy s)
   exp     a   = Lift $ exp_     (reflect (Proxy :: Proxy s)) (lower a)
   sqrt    a   = Lift $ sqrt_    (reflect (Proxy :: Proxy s)) (lower a)
   log     a   = Lift $ log_     (reflect (Proxy :: Proxy s)) (lower a)
   (**)    a b = Lift $ (**.)    (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   logBase a b = Lift $ logBase_ (reflect (Proxy :: Proxy s)) (lower a) (lower b)
   sin     a   = Lift $ sin_     (reflect (Proxy :: Proxy s)) (lower a)
   tan     a   = Lift $ tan_     (reflect (Proxy :: Proxy s)) (lower a)
   cos     a   = Lift $ cos_     (reflect (Proxy :: Proxy s)) (lower a)
   asin    a   = Lift $ asin_    (reflect (Proxy :: Proxy s)) (lower a)
   atan    a   = Lift $ atan_    (reflect (Proxy :: Proxy s)) (lower a)
   acos    a   = Lift $ acos_    (reflect (Proxy :: Proxy s)) (lower a)
   sinh    a   = Lift $ sinh_    (reflect (Proxy :: Proxy s)) (lower a)
   tanh    a   = Lift $ tanh_    (reflect (Proxy :: Proxy s)) (lower a)
   cosh    a   = Lift $ cosh_    (reflect (Proxy :: Proxy s)) (lower a)
   asinh   a   = Lift $ asinh_   (reflect (Proxy :: Proxy s)) (lower a)
   atanh   a   = Lift $ atanh_   (reflect (Proxy :: Proxy s)) (lower a)
   acosh   a   = Lift $ acosh_   (reflect (Proxy :: Proxy s)) (lower a)

instance ReifiableConstraint Floating where
  data Def Floating a = Floating
      { pi_      :: a
      , exp_     :: a -> a
      , sqrt_    :: a -> a
      , log_     :: a -> a
      , (**.)    :: a -> a -> a
      , logBase_ :: a -> a -> a
      , sin_     :: a -> a
      , tan_     :: a -> a
      , cos_     :: a -> a
      , asin_    :: a -> a
      , atan_    :: a -> a
      , acos_    :: a -> a
      , sinh_    :: a -> a
      , tanh_    :: a -> a
      , cosh_    :: a -> a
      , asinh_   :: a -> a
      , atanh_   :: a -> a
      , acosh_   :: a -> a
      }
  reifiedIns = Sub Dict

instance Reifies s (Def RealFrac a) => RealFrac (Lift RealFrac s a) where
   properFraction a = fmap Lift $ properFraction_ (reflect (Proxy :: Proxy s)) (lower a)
   truncate       a =      Lift $ truncate_       (reflect (Proxy :: Proxy s)) (lower a)
   round          a =      Lift $ round_          (reflect (Proxy :: Proxy s)) (lower a)
   ceiling        a =      Lift $ ceiling_        (reflect (Proxy :: Proxy s)) (lower a)
   floor          a =      Lift $ floor_          (reflect (Proxy :: Proxy s)) (lower a)


instance ReifiableConstraint RealFrac where
  data Def RealFrac a = RealFrac
      { properFraction_ :: Integral b => a -> (b, a)
      , truncate_       :: Integral b => a -> b
      , round_          :: Integral b => a -> b
      , ceiling_        :: Integral b => a -> b
      , floor_          :: Integral b => a -> b
      }
  reifiedIns = Sub Dict

instance Reifies s (Def RealFloat a) => RealFloat (Lift RealFloat s a) where
   floatRadix     a   = floatRadix_     (reflect (Proxy :: Proxy s)) (lower a)
   floatDigits    a   = floatDigits_    (reflect (Proxy :: Proxy s)) (lower a)
   floatRange     a   = floatRange_     (reflect (Proxy :: Proxy s)) (lower a)
   decodeFloat    a   = decodeFloat_    (reflect (Proxy :: Proxy s)) (lower a)
   encodeFloat    a b = encodeFloat_    (reflect b) (lower a) (lower b)
   exponent       a   = exponent_       (reflect (Proxy :: Proxy s)) (lower a)
   significand    a b = significand_    (reflect b) (lower a) (lower b)
   scaleFloat     a b = scaleFloat_     (reflect b) (lower a) (lower b)
   isInfinite     a   = isInfinite_     (reflect (Proxy :: Proxy s)) (lower a)
   isDenormalized a   = isDenormalized_ (reflect (Proxy :: Proxy s)) (lower a)
   isNegativeZero a   = isNegativeZero_ (reflect (Proxy :: Proxy s)) (lower a)
   isIEEE         a   = isIEEE_         (reflect (Proxy :: Proxy s)) (lower a)
   atan2          a   = atan2_          (reflect (Proxy :: Proxy s)) (lower a)

instance ReifiableConstraint RealFloat where
  data Def RealFloat a = RealFloat
      { floatRadix_  :: a -> Integer
      , floatDigits_ :: a -> Int
      , floatRange_  :: a -> (Int, Int)
      , decodeFloat_ :: a -> (Integer, Int)
      , encodeFloat_ :: Integer -> Int -> a
      , exponent_    :: a -> Int
      , significand_  :: Int -> a -> a
      , scaleFloat_   :: Int -> a -> a
      , isInfinite_   :: a -> Bool
      , isDenormalized_ :: a -> Bool
      , isNegativeZero_ :: a -> Bool
      , isIEEE_         :: a -> Bool
      , atan2_          :: a -> Bool
      }
  reifiedIns = Sub Dict
-}

{-
I think this will need a reifyable constraint1
instance Reifies s (Def Monad a) => Monad (Lift Monad s a) where
   (>>=)  =
   (>>)   =
   return =
   fail   =

instance ReifiableConstraint Monad where
  data Def Monad a = Monad
      { (>>=.) :: forall a b. m a -> (a -> m b) -> m b
      , (>>.)  :: forall a b. m a -> m b -> m b
      , return :: a -> m a
      , fail   :: String -> m a
      }
  reifiedIns = Sub Dict
-}

instance Reifies s (Def Show a) => Show (Lift Show s a) where
  show = show_ (REFLECTreflect.(Proxy :: Proxy s)) . lower

instance ReifiableConstraint Show where
  data Def Show a = Show { show_ :: a -> String }
  reifiedIns = Sub Dict

instance ReifiableConstraint Read where
  data Def Read a = Read { readsPrec_ :: Int -> ReadS a, readList_ :: ReadS [a] }
  reifiedIns = Sub Dict

instance Reifies s (Def Read a) => Read (Lift Read s a) where
  readsPrec x s = over _1 Lift <$> readsPrec_ (REFLECTreflectx(Proxys     :: Proxy s)) x s
  readList  s   = over _1 (fmap Lift)
               <$> readList_  (REFLECTreflects(Proxy :: Proxy s)) s

instance ReifiableConstraint Eq where
  data Def Eq a = Eq { eq_ :: a -> a -> Bool }
  reifiedIns = Sub Dict

instance Reifies s (Def Eq a) => Eq (Lift Eq s a) where
   x == y = eq_ (REFLECTreflect((lowerProxyx::) (Proxy s)) (lower x) (lower y)

instance ReifiableConstraint Ord where
  data Def Ord a = Ord { compare_ :: a -> a -> Ordering }
  reifiedIns = Sub Dict

instance Reifies s (Def Ord a) => Eq (Lift Ord s a) where
  a == b = compare a b == EQ

instance Reifies s (Def Ord a) => Ord (Lift Ord s a) where
  compare a b = compare_ (REFLECTreflect((lowerProxya::) (Proxy s)) (lower a) (lower b)

instance ReifiableConstraint Monoid where
  data Def Monoid a = Monoid { mappend_ :: a -> a -> a, mempty_ :: a }
  reifiedIns = Sub Dict

instance Reifies s (Def Monoid a) => Monoid (Lift Monoid s a) where
  mappend = liftA2 (mappend_ (REFLECTreflect) (Proxy :: Proxy s)))
  mempty  = pure $ mempty_ (REFLECTreflect (Proxy :: Proxy s))

-- Aeson Instances
instance ReifiableConstraint FromJSON where
   data Def FromJSON a = FromJSON { parseJSON_ :: Value -> Parser a }
   reifiedIns = Sub Dict

instance Reifies s (Def FromJSON a) => FromJSON (Lift FromJSON s a) where
   parseJSON = fmap pure . parseJSON_ (REFLECTreflect (Proxy :: Proxy s))

instance ReifiableConstraint ToJSON where
   data Def ToJSON a = ToJSON { toJSON_ :: a -> Value}
   reifiedIns = Sub Dict

instance Reifies s (Def ToJSON a) => ToJSON (Lift ToJSON s a) where
   toJSON a = toJSON_ (REFLECTreflect((lowerProxya::)  Proxy s)) (lower a)

</pre>