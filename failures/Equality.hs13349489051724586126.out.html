<a href="Eq.hs771515668357571490.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Equational.hs2145586676329863108.out.html">next</a></br></br><pre>8d7
< #endif
9d7
< -------------------------------------------------------------------------------
10d7
< -- |
11d7
< -- Module      : Data.Type.Equality
12d7
< -- Copyright   : (c) 2009, Erik Hesselink
13d7
< -- License     : BSD3
14d7
< --
15d7
< -- Maintainer  : Erik Hesselink <hesselink@gmail.com>
16d7
< -- Stability   : Experimental
17d7
< --
18d7
< -- Type equality, coercion/cast and other operations.
19c8
< --
---
> #endif{-# LANGUAGE PolyKinds #-}
21d9
< module Data.Type.Equality
22d9
<   ( (:=:)(Refl)
23c10
<   , sym
---
> -- |-------------------------------------------------------------------------------
23a11
> -- |-- Module      : Data.Type.Equality
23a12
> -- Module      : Data.Type.Equality-- Copyright   : (c) 2009, Erik Hesselink
23a13
> -- License     : BSD3-- Copyright   : (c) 2009, Erik Hesselink
23a14
> ---- License     : BSD3
23a15
> ---- Maintainer  : Erik Hesselink <hesselink@gmail.com>
23a16
> -- Stability   : Experimental-- Maintainer  : Erik Hesselink <hesselink@gmail.com>
23a17
> ---- Stability   : Experimental
23a18
> ---- Type equality, coercion/cast and other operations.
23a19
> ---- Type equality, coercion/cast and other operations.
23a20
> ---------------------------------------------------------------------------------
23a21
> module-------------------------------------------------------------------------------Data.Type.Equality
23a22
> module( (:=:Data.Type.Equality)(Refl)
23a23
>   ( (sym:=:)(Refl)
23a24
>   , symtrans
25c26
<   , subst
---
>   , substsubst2
27d27
< 
28a29
>   , congcong2
31d31
< 
33c33
< 
---
>   , coerce
34a35
>   , EqTEqT2(eqT(eqT2) )
36c37
<   , EqT3(eqT3)
---
>   , EqT3where(eqT3)
38d38
< 
40c40
< #if __GLASGOW_HASKELL__ >= 609
---
> import#if __GLASGOW_HASKELL__ >= 609Prelude
42d41
< import Control.Category
43c42
< #endif
---
> import Control.Category (id, (.))
43a43
> import#endif  Control.Category
46d45
< -- @b@ are equal. By pattern matching on @Refl@ this fact is
47d45
< -- introduced to the type checker.
48c46
< data a :=: b where
---
> -- @b@ are equal. By pattern matching on @Refl@ this fact is-- | Type equality. A value of @a :=: b@ is a proof that types @a@ and
48a47
> -- introduced to the type checker.-- @b@ are equal. By pattern matching on @Refl@ this fact is
48a48
> data-- introduced to the type checker.a :=: b where
48a49
> dataRefl :=::: ab:=:wherea
50d50
< 
52c52
< 
---
> infix 4 :=:
54d53
< -- a GADT, so it is defined here manually.
55c54
< instance Show (a :=: b) where
---
> -- a GADT, so it is defined here manually.-- | Any value is just shown as "Refl", but this cannot be derived for
55a55
> instance-- a GADT, so it is defined here manually.Show (a :=: b) where
55a56
> instanceshowsPrec_ (Refla :=:= bshowString) where   "Refl"
57d57
< 
59d58
< -- since that is not true, in general. We just parse the string
60d58
< -- "Refl", optionally surrounded with parentheses, and return 'Refl'.
61c59
< instance Read (a :=: a) where
---
> -- since that is not true, in general. We just parse the string-- | We can only read values if the result is @a :=: a@, not @a :=: b@
61a60
> -- since that is not true, in general. We just parse the string-- "Refl", optionally surrounded with parentheses, and return 'Refl'.
61a61
> instance-- "Refl", optionally surrounded with parentheses, and return 'Refl'.Read (a :=: a) where
61a62
> instancereadsPrec_ (areadParen a) whereFalse (\s -> [(Refl, r) | ("Refl", r) <- lex s])
63d63
< 
66d65
<   id = Refl
67d65
<   Refl . Refl = Refl
68c66
< #endif
---
> instanceid = Refl (:=:) where
68a67
>   idRefl= Refl. Refl = Refl
68a68
> #endif . Refl = Refl
71c71
< sym :: a :=: b -> b :=: a
---
> sym-- | Equality is symmetric.:: a :=: b -> b :=: a
71a72
> sym ::Refl :=:= Refl -> b :=: a
73d73
< 
75d74
< -- instance, but also works in GHC 6.8.
76c75
< trans :: a :=: b -> b :=: c -> a :=: c
---
> -- instance, but also works in GHC 6.8.-- | Equality is transitive. This is the same as (>>>) from the 'Category'
76a76
> trans-- instance, but also works in GHC 6.8.:: a :=: b -> b :=: c -> a :=: c
76a77
> trans ::Refl :=:Reflb=->Refl :=: c -> a :=: c
78d78
< 
80d79
< -- be defined as 'coerce' '.' 'cong'.
81c80
< subst :: a :=: b -> f a -> f b
---
> -- be defined as 'coerce' '.' 'cong'.-- | Equality is substitutive. This is defined directly, but can also
81a81
> subst-- be defined as 'coerce' '.' 'cong'.:: a :=: b -> f a -> f b
81a82
> subst ::Refl :=:= idb -> f a -> f b
83d83
< 
85d84
< -- to 'coerce' '.' 'cong' '.' 'cong'.
86c85
< subst2 :: a :=: b -> f (g a) -> f (g b)
---
> -- to 'coerce' '.' 'cong' '.' 'cong'.-- | Substitution inside nested type constructors. This is equivalent
86a86
> subst2-- to 'coerce' '.' 'cong' '.' 'cong'.:: a :=: b -> f (g a) -> f (g b)
86a87
> subst2 ::Refl :=:= idb -> f (g a) -> f (g b)
88d88
< 
90c90
< cong :: a :=: b -> f a :=: f b
---
> cong-- | Equality is congruential.:: a :=: b -> f a :=: f b
90a91
> cong ::Refl :=:= Refl -> f a :=: f b
92d92
< 
94c94
< cong2 :: a :=: b -> c :=: d -> f a c :=: f b d
---
> cong2-- | Congruence for type constructors with two parameters.:: a :=: b -> c :=: d -> f a c :=: f b d
94a95
> cong2 ::Refl :=:Reflb=->Refl :=: d -> f a c :=: f b d
96d96
< 
98c98
< cong3 :: a :=: a'-> b :=: b' -> c :=: c' -> f a b c :=: f a' b' c'
---
> cong3-- | Congruence for type constructors with three parameters.:: a :=: a'-> b :=: b' -> c :=: c' -> f a b c :=: f a' b' c'
98a99
> cong3 ::Refl :=:Refla'Refl-> b=:=:Refl -> c :=: c' -> f a b c :=: f a' b' c'
100d100
< 
102c102
< coerce :: a :=: b -> a -> b
---
> coerce-- | Coerce a type to another using an equality proof.:: a :=: b -> a -> b
102a103
> coerce ::Refl :=:= idb -> a -> b
104d104
< 
106d105
< -- as we can get to decidable equality on types. Note that @f@ must be
107d105
< -- a GADT to be able to define 'eqT'.
108c106
< class EqT f where
---
> -- | A type class for constructing equality proofs. This is as close-- as we can get to decidable equality on types. Note that @f@ must be
108a107
> -- a GADT to be able to define 'eqT'.-- as we can get to decidable equality on types. Note that @f@ must be
108a108
> class-- a GADT to be able to define 'eqT'.EqT f where
108a109
> classeqT EqT:: ffawhere-> f b -> Maybe (a :=: b)
110d110
< 
112d111
< -- constructor with two parameters. Can be useful when representing
113d111
< -- relations between types.
114c112
< class EqT2 f where
---
> -- | A type class for constructing equality proofs for type-- constructor with two parameters. Can be useful when representing
114a113
> -- relations between types.-- constructor with two parameters. Can be useful when representing
114a114
> class-- relations between types.EqT2 f where
114a115
> classeqT2EqT2:: ffawhereb -> f c d -> (Maybe (a :=: c), Maybe (b :=: d))
116d116
< 
118d117
< -- constructor with three parameters. If you find a use for this, let
119d117
< -- me know.
120c118
< class EqT3 f where
---
> -- | A type class for constructing equality proofs for type-- constructor with three parameters. If you find a use for this, let
120a119
> -- me know.-- constructor with three parameters. If you find a use for this, let
120a120
> class-- me know.EqT3 f where
120a121
> classeqT3EqT3:: ffawhereb c -> f a' b' c' -> (Maybe (a :=: a'), Maybe (b :=: b'), Maybe (c :=: c'))
122d122
< 
124c124
<   eqT Refl Refl = Just Refl
---
> instanceeqT ReflRefl(:=:= )Just) whereRefl
124a125
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeOperators
           , GADTs
           , FlexibleInstances
           , CPP
           #-}
#if __GLASGOW_HASKELL__ >= 706
{-# LANGUAGE PolyKinds #-}
#endif
-------------------------------------------------------------------------------
-- |
-- Module      : Data.Type.Equality
-- Copyright   : (c) 2009, Erik Hesselink
-- License     : BSD3
--
-- Maintainer  : Erik Hesselink <hesselink@gmail.com>
-- Stability   : Experimental
--
-- Type equality, coercion/cast and other operations.
--
-------------------------------------------------------------------------------
module Data.Type.Equality
  ( (:=:)(Refl)
  , sym
  , trans
  , subst
  , subst2

  , cong
  , cong2
  , cong3

  , coerce

  , EqT(eqT)
  , EqT2(eqT2)
  , EqT3(eqT3)
  ) where

import Prelude
#if __GLASGOW_HASKELL__ >= 609
               hiding (id, (.))
import Control.Category
#endif

-- | Type equality. A value of @a :=: b@ is a proof that types @a@ and
-- @b@ are equal. By pattern matching on @Refl@ this fact is
-- introduced to the type checker.
data a :=: b where
  Refl :: a :=: a

infix 4 :=:

-- | Any value is just shown as "Refl", but this cannot be derived for
-- a GADT, so it is defined here manually.
instance Show (a :=: b) where
  showsPrec _ Refl = showString "Refl"

-- | We can only read values if the result is @a :=: a@, not @a :=: b@
-- since that is not true, in general. We just parse the string
-- "Refl", optionally surrounded with parentheses, and return 'Refl'.
instance Read (a :=: a) where
  readsPrec _ = readParen False (\s -> [(Refl, r) | ("Refl", r) <- lex s])

#if __GLASGOW_HASKELL__ >= 609
instance Category (:=:) where
  id = Refl
  Refl . Refl = Refl
#endif

-- | Equality is symmetric.
sym :: a :=: b -> b :=: a
sym Refl = Refl

-- | Equality is transitive. This is the same as (>>>) from the 'Category'
-- instance, but also works in GHC 6.8.
trans :: a :=: b -> b :=: c -> a :=: c
trans Refl Refl = Refl

-- | Equality is substitutive. This is defined directly, but can also
-- be defined as 'coerce' '.' 'cong'.
subst :: a :=: b -> f a -> f b
subst Refl = id

-- | Substitution inside nested type constructors. This is equivalent
-- to 'coerce' '.' 'cong' '.' 'cong'.
subst2 :: a :=: b -> f (g a) -> f (g b)
subst2 Refl = id

-- | Equality is congruential.
cong :: a :=: b -> f a :=: f b
cong Refl = Refl

-- | Congruence for type constructors with two parameters.
cong2 :: a :=: b -> c :=: d -> f a c :=: f b d
cong2 Refl Refl = Refl

-- | Congruence for type constructors with three parameters.
cong3 :: a :=: a'-> b :=: b' -> c :=: c' -> f a b c :=: f a' b' c'
cong3 Refl Refl Refl = Refl

-- | Coerce a type to another using an equality proof.
coerce :: a :=: b -> a -> b
coerce Refl = id

-- | A type class for constructing equality proofs. This is as close
-- as we can get to decidable equality on types. Note that @f@ must be
-- a GADT to be able to define 'eqT'.
class EqT f where
  eqT :: f a -> f b -> Maybe (a :=: b)

-- | A type class for constructing equality proofs for type
-- constructor with two parameters. Can be useful when representing
-- relations between types.
class EqT2 f where
  eqT2 :: f a b -> f c d -> (Maybe (a :=: c), Maybe (b :=: d))

-- | A type class for constructing equality proofs for type
-- constructor with three parameters. If you find a use for this, let
-- me know.
class EqT3 f where
  eqT3 :: f a b c -> f a' b' c' -> (Maybe (a :=: a'), Maybe (b :=: b'), Maybe (c :=: c'))

instance EqT ((:=:) a) where
  eqT Refl Refl = Just Refl
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeOperators
           , GADTs
           , FlexibleInstances
           , CPP
           #-}
#if __GLASGOW_HASKELL__ >= 706
{-# LANGUAGE PolyKinds #-}
#endif{-# LANGUAGE PolyKinds #-}
-------------------------------------------------------------------------------
-- |-------------------------------------------------------------------------------
-- |-- Module      : Data.Type.Equality
-- Module      : Data.Type.Equality-- Copyright   : (c) 2009, Erik Hesselink
-- License     : BSD3-- Copyright   : (c) 2009, Erik Hesselink
---- License     : BSD3
---- Maintainer  : Erik Hesselink <hesselink@gmail.com>
-- Stability   : Experimental-- Maintainer  : Erik Hesselink <hesselink@gmail.com>
---- Stability   : Experimental
---- Type equality, coercion/cast and other operations.
---- Type equality, coercion/cast and other operations.
---------------------------------------------------------------------------------
module-------------------------------------------------------------------------------Data.Type.Equality
module( (:=:Data.Type.Equality)(Refl)
  ( (sym:=:)(Refl)
  , symtrans
  , trans
  , substsubst2
  , subst2
  , cong
  , congcong2
  , cong2
  , cong3
  , coerce
  , coerce
  , EqT(eqT)
  , EqTEqT2(eqT(eqT2) )
  , EqT2(eqT2)
  , EqT3where(eqT3)
  ) where
import Prelude
import#if __GLASGOW_HASKELL__ >= 609Prelude
               hiding (id, (.))
import Control.Category (id, (.))
import#endif  Control.Category

-- | Type equality. A value of @a :=: b@ is a proof that types @a@ and
-- @b@ are equal. By pattern matching on @Refl@ this fact is-- | Type equality. A value of @a :=: b@ is a proof that types @a@ and
-- introduced to the type checker.-- @b@ are equal. By pattern matching on @Refl@ this fact is
data-- introduced to the type checker.a :=: b where
dataRefl :=::: ab:=:wherea
  Refl :: a :=: a
infix 4 :=:
infix 4 :=:
-- | Any value is just shown as "Refl", but this cannot be derived for
-- a GADT, so it is defined here manually.-- | Any value is just shown as "Refl", but this cannot be derived for
instance-- a GADT, so it is defined here manually.Show (a :=: b) where
instanceshowsPrec_ (Refla :=:= bshowString) where   "Refl"
  showsPrec _ Refl = showString "Refl"
-- | We can only read values if the result is @a :=: a@, not @a :=: b@
-- since that is not true, in general. We just parse the string-- | We can only read values if the result is @a :=: a@, not @a :=: b@
-- since that is not true, in general. We just parse the string-- "Refl", optionally surrounded with parentheses, and return 'Refl'.
instance-- "Refl", optionally surrounded with parentheses, and return 'Refl'.Read (a :=: a) where
instancereadsPrec_ (areadParen a) whereFalse (\s -> [(Refl, r) | ("Refl", r) <- lex s])
  readsPrec _ = readParen False (\s -> [(Refl, r) | ("Refl", r) <- lex s])
#if __GLASGOW_HASKELL__ >= 609
instance Category (:=:) where
instanceid = Refl (:=:) where
  idRefl= Refl. Refl = Refl
#endif . Refl = Refl

-- | Equality is symmetric.
sym-- | Equality is symmetric.:: a :=: b -> b :=: a
sym ::Refl :=:= Refl -> b :=: a
sym Refl = Refl
-- | Equality is transitive. This is the same as (>>>) from the 'Category'
-- instance, but also works in GHC 6.8.-- | Equality is transitive. This is the same as (>>>) from the 'Category'
trans-- instance, but also works in GHC 6.8.:: a :=: b -> b :=: c -> a :=: c
trans ::Refl :=:Reflb=->Refl :=: c -> a :=: c
trans Refl Refl = Refl
-- | Equality is substitutive. This is defined directly, but can also
-- be defined as 'coerce' '.' 'cong'.-- | Equality is substitutive. This is defined directly, but can also
subst-- be defined as 'coerce' '.' 'cong'.:: a :=: b -> f a -> f b
subst ::Refl :=:= idb -> f a -> f b
subst Refl = id
-- | Substitution inside nested type constructors. This is equivalent
-- to 'coerce' '.' 'cong' '.' 'cong'.-- | Substitution inside nested type constructors. This is equivalent
subst2-- to 'coerce' '.' 'cong' '.' 'cong'.:: a :=: b -> f (g a) -> f (g b)
subst2 ::Refl :=:= idb -> f (g a) -> f (g b)
subst2 Refl = id
-- | Equality is congruential.
cong-- | Equality is congruential.:: a :=: b -> f a :=: f b
cong ::Refl :=:= Refl -> f a :=: f b
cong Refl = Refl
-- | Congruence for type constructors with two parameters.
cong2-- | Congruence for type constructors with two parameters.:: a :=: b -> c :=: d -> f a c :=: f b d
cong2 ::Refl :=:Reflb=->Refl :=: d -> f a c :=: f b d
cong2 Refl Refl = Refl
-- | Congruence for type constructors with three parameters.
cong3-- | Congruence for type constructors with three parameters.:: a :=: a'-> b :=: b' -> c :=: c' -> f a b c :=: f a' b' c'
cong3 ::Refl :=:Refla'Refl-> b=:=:Refl -> c :=: c' -> f a b c :=: f a' b' c'
cong3 Refl Refl Refl = Refl
-- | Coerce a type to another using an equality proof.
coerce-- | Coerce a type to another using an equality proof.:: a :=: b -> a -> b
coerce ::Refl :=:= idb -> a -> b
coerce Refl = id
-- | A type class for constructing equality proofs. This is as close
-- | A type class for constructing equality proofs. This is as close-- as we can get to decidable equality on types. Note that @f@ must be
-- a GADT to be able to define 'eqT'.-- as we can get to decidable equality on types. Note that @f@ must be
class-- a GADT to be able to define 'eqT'.EqT f where
classeqT EqT:: ffawhere-> f b -> Maybe (a :=: b)
  eqT :: f a -> f b -> Maybe (a :=: b)
-- | A type class for constructing equality proofs for type
-- | A type class for constructing equality proofs for type-- constructor with two parameters. Can be useful when representing
-- relations between types.-- constructor with two parameters. Can be useful when representing
class-- relations between types.EqT2 f where
classeqT2EqT2:: ffawhereb -> f c d -> (Maybe (a :=: c), Maybe (b :=: d))
  eqT2 :: f a b -> f c d -> (Maybe (a :=: c), Maybe (b :=: d))
-- | A type class for constructing equality proofs for type
-- | A type class for constructing equality proofs for type-- constructor with three parameters. If you find a use for this, let
-- me know.-- constructor with three parameters. If you find a use for this, let
class-- me know.EqT3 f where
classeqT3EqT3:: ffawhereb c -> f a' b' c' -> (Maybe (a :=: a'), Maybe (b :=: b'), Maybe (c :=: c'))
  eqT3 :: f a b c -> f a' b' c' -> (Maybe (a :=: a'), Maybe (b :=: b'), Maybe (c :=: c'))
instance EqT ((:=:) a) where
instanceeqT ReflRefl(:=:= )Just) whereRefl

</pre>