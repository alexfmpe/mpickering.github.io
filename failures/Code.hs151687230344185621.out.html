<a href="Code.hs144128232716531729.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Code128.hs14587779232007237709.out.html">next</a></br></br><pre>4d3
< module Code where
5d3
< {-# LINE 2 "src-ag/Code.ag" #-}
6d3
< 
7c4
< import Patterns
---
> module Code where Patterns
12d8
< {-# LINE 13 "dist/build/Code.hs" #-}
13d8
< {-# LINE 146 "src-ag/Code.ag" #-}
15d9
< -- Unboxed tuples
16d9
< --   unbox  Whether unboxed tuples are wanted or not
17d9
< --   inh    The inherited attributes.
18d9
< --          If there are none, no unboxing can take place,
19d9
< --          because in that case the semantic function (a top-level identifier) would have an unboxed type.
20d9
< -- Of course we can't have an unboxed 1-tuple
21d9
< mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
22d9
< mkTupleExpr unbox' noInh exprs | not unbox' || noInh || length exprs == 1 = TupleExpr exprs
23d9
<                                | otherwise                                = UnboxedTupleExpr exprs
24d9
< mkTupleType :: Bool -> Bool -> Types -> Type
25d9
< mkTupleType unbox' noInh tps | not unbox' || noInh || length tps == 1 = TupleType tps
26d9
<                              | otherwise                              = UnboxedTupleType tps
27d9
< mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
28d9
< mkTupleLhs  unbox' noInh comps | not unbox' || noInh || length comps == 1 = TupleLhs comps
29d9
<                                | otherwise                                = UnboxedTupleLhs comps
30c10
< {-# LINE 31 "dist/build/Code.hs" #-}
---
> 
30a11
> 
30a12
> 
30a13
> 
30a14
> 
30a15
> 
30a16
> 
30a17
> 
30a18
> 
30a19
> 
30a20
> 
30a21
> 
30a22
> 
30a23
> 
30a24
> 
30a25
> 
30a26
> 
30a27
> 
30a28
> 
30a29
> 
30a30
> 
30a31
> 
38c39
< data CaseAlt = CaseAlt (Lhs) (Expr)
---
> 
47c48
< type CaseAlts = [CaseAlt]
---
> 
62c63
< data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
---
> 
71c72
< type Chunks = [Chunk]
---
> 
82d82
< data DataAlt = DataAlt (String) (Types)
83c83
<              | Record (String) (NamedTypes)
---
> 
83a84
> 
92c93
< type DataAlts = [DataAlt]
---
> 
139d139
< data Decl = Decl (Lhs) (Expr) ((Set String)) ((Set String))
140d139
<           | Bind (Lhs) (Expr)
141d139
<           | BindLet (Lhs) (Expr)
142d139
<           | Data (String) (([String])) (DataAlts) (Bool) (([String]))
143d139
<           | NewType (String) (([String])) (String) (Type)
144d139
<           | Type (String) (([String])) (Type)
145d139
<           | TSig (String) (Type)
146d139
<           | Comment (String)
147d139
<           | PragmaDecl (String)
148d139
<           | Resume (Bool) (String) (Lhs) (Expr)
149c140
<           | EvalDecl (String) (Lhs) (Expr)
---
> 
149a141
> 
149a142
> 
149a143
> 
149a144
> 
149a145
> 
149a146
> 
149a147
> 
149a148
> 
149a149
> 
149a150
> 
158d158
< type Decls = [Decl]
159d158
< -- Expr --------------------------------------------------------
160c159
< {-
---
> --   unbox  Whether unboxed tuples are wanted or not
160a160
> --   inh    The inherited attributes.
160a161
> --          If there are none, no unboxing can take place,
160a162
> --          because in that case the semantic function (a top-level identifier) would have an unboxed type.
160a163
> -- Of course we can't have an unboxed 1-tuple
160a164
> mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
160a165
> mkTupleExpr unbox' noInh exprs | not unbox' || noInh || length exprs == 1 = TupleExpr exprs
160a166
>                                | otherwise                                = UnboxedTupleExpr exprs
160a167
> mkTupleType :: Bool -> Bool -> Types -> Type
160a168
> mkTupleType unbox' noInh tps | not unbox' || noInh || length tps == 1 = TupleType tps
160a169
>                              | otherwise                              = UnboxedTupleType tps
160a170
> mkTupleLhs-- Expr --------------------------------------------------------:: Bool -> Bool -> [String] -> Lhs
160a171
> mkTupleLhs{-
214c225
< -}
---
> -}           noInh comps | not unbox' || noInh || length comps == 1 = TupleLhs comps
214a226
>                                | otherwise                                = UnboxedTupleLhs comps CaseAlt = CaseAlt (Lhs) (Expr)
214a227
> 
214a228
> 
214a229
> 
214a230
> 
214a231
> 
214a232
> 
214a233
> 
214a234
> 
214a235
> type CaseAlts = [CaseAlt]
214a236
> 
214a237
> 
214a238
> 
214a239
> 
214a240
> 
214a241
> 
214a242
> 
214a243
> 
214a244
> 
214a245
> 
214a246
> 
214a247
> 
214a248
> 
214a249
> 
214a250
> data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
214a251
> 
214a252
> 
214a253
> 
214a254
> 
214a255
> 
214a256
> 
214a257
> 
214a258
> 
214a259
> type Chunks = [Chunk]
214a260
> 
214a261
> 
214a262
> 
214a263
> 
214a264
> 
214a265
> 
214a266
> 
214a267
> 
214a268
> 
214a269
> 
214a270
> data DataAlt = DataAlt (String) (Types)
214a271
>              | Record (String) (NamedTypes)
214a272
> 
214a273
> 
214a274
> 
214a275
> 
214a276
> 
214a277
> 
214a278
> 
214a279
> 
214a280
> type DataAlts = [DataAlt]
214a281
> 
214a282
> 
214a283
> 
214a284
> 
214a285
> 
214a286
> 
214a287
> 
214a288
> 
214a289
> 
214a290
> 
214a291
> 
214a292
> 
214a293
> 
214a294
> 
214a295
> 
214a296
> 
214a297
> 
214a298
> 
214a299
> 
214a300
> 
214a301
> 
214a302
> 
214a303
> 
214a304
> 
214a305
> 
214a306
> 
214a307
> 
214a308
> 
214a309
> 
214a310
> 
214a311
> 
214a312
> 
214a313
> 
214a314
> 
214a315
> 
214a316
> 
214a317
> 
214a318
> 
214a319
> 
214a320
> 
214a321
> 
214a322
> 
214a323
> 
214a324
> 
214a325
> 
214a326
> 
214a327
> data Decl = Decl (Lhs) (Expr) ((Set String)) ((Set String))
214a328
>           | Bind (Lhs) (Expr)
214a329
>           | BindLet (Lhs) (Expr)
214a330
>           | Data (String) (([String])) (DataAlts) (Bool) (([String]))
214a331
>           | NewType (String) (([String])) (String) (Type)
214a332
>           | Type (String) (([String])) (Type)
214a333
>           | TSig (String) (Type)
214a334
>           | Comment (String)
214a335
>           | PragmaDecl (String)
214a336
>           | Resume (Bool) (String) (Lhs) (Expr)
214a337
>           | EvalDecl (String) (Lhs) (Expr)
214a338
> 
214a339
> 
214a340
> 
214a341
> 
214a342
> 
214a343
> 
214a344
> 
214a345
> 
214a346
> type Decls = [Decl]
214a347
> 
214a348
> 
214a349
> 
214a350
> 
214a351
> 
214a352
> 
214a353
> 
214a354
> 
214a355
> 
214a356
> 
214a357
> 
214a358
> 
214a359
> 
214a360
> 
214a361
> 
214a362
> 
214a363
> 
214a364
> 
214a365
> 
214a366
> 
214a367
> 
214a368
> 
214a369
> 
214a370
> 
214a371
> 
214a372
> 
214a373
> 
214a374
> 
214a375
> 
214a376
> 
214a377
> 
214a378
> 
214a379
> 
214a380
> 
214a381
> 
214a382
> 
214a383
> 
214a384
> 
214a385
> 
214a386
> 
214a387
> 
214a388
> 
214a389
> 
214a390
> 
214a391
> 
214a392
> 
214a393
> 
214a394
> 
214a395
> 
214a396
> 
214a397
> 
214a398
> 
214a399
> 
214a400
> 
214a401
> 
214a402
> 
356a545
> 
</pre></br><h2>original</h2></br><pre>

-- UUAGC 0.9.51.1 (src-ag/Code.ag)
module Code where
{-# LINE 2 "src-ag/Code.ag" #-}

import Patterns
import Data.Set(Set)
import qualified Data.Set as Set
import Data.Map(Map)
import qualified Data.Map as Map
{-# LINE 13 "dist/build/Code.hs" #-}
{-# LINE 146 "src-ag/Code.ag" #-}

-- Unboxed tuples
--   unbox  Whether unboxed tuples are wanted or not
--   inh    The inherited attributes.
--          If there are none, no unboxing can take place,
--          because in that case the semantic function (a top-level identifier) would have an unboxed type.
-- Of course we can't have an unboxed 1-tuple
mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
mkTupleExpr unbox' noInh exprs | not unbox' || noInh || length exprs == 1 = TupleExpr exprs
                               | otherwise                                = UnboxedTupleExpr exprs
mkTupleType :: Bool -> Bool -> Types -> Type
mkTupleType unbox' noInh tps | not unbox' || noInh || length tps == 1 = TupleType tps
                             | otherwise                              = UnboxedTupleType tps
mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
mkTupleLhs  unbox' noInh comps | not unbox' || noInh || length comps == 1 = TupleLhs comps
                               | otherwise                                = UnboxedTupleLhs comps
{-# LINE 31 "dist/build/Code.hs" #-}
-- CaseAlt -----------------------------------------------------
{-
   alternatives:
      alternative CaseAlt:
         child left           : Lhs
         child expr           : Expr
-}
data CaseAlt = CaseAlt (Lhs) (Expr)
-- CaseAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : CaseAlt
         child tl             : CaseAlts
      alternative Nil:
-}
type CaseAlts = [CaseAlt]
-- Chunk -------------------------------------------------------
{-
   alternatives:
      alternative Chunk:
         child name           : {String}
         child comment        : Decl
         child info           : Decls
         child dataDef        : Decls
         child cataFun        : Decls
         child semDom         : Decls
         child semWrapper     : Decls
         child semFunctions   : Decls
         child semNames       : {[String]}
-}
data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
-- Chunks ------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Chunk
         child tl             : Chunks
      alternative Nil:
-}
type Chunks = [Chunk]
-- DataAlt -----------------------------------------------------
{-
   alternatives:
      alternative DataAlt:
         child name           : {String}
         child args           : Types
      alternative Record:
         child name           : {String}
         child args           : NamedTypes
-}
data DataAlt = DataAlt (String) (Types)
             | Record (String) (NamedTypes)
-- DataAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : DataAlt
         child tl             : DataAlts
      alternative Nil:
-}
type DataAlts = [DataAlt]
-- Decl --------------------------------------------------------
{-
   alternatives:
      alternative Decl:
         child left           : Lhs
         child rhs            : Expr
         child binds          : {Set String}
         child uses           : {Set String}
      alternative Bind:
         child left           : Lhs
         child rhs            : Expr
      alternative BindLet:
         child left           : Lhs
         child rhs            : Expr
      alternative Data:
         child name           : {String}
         child params         : {[String]}
         child alts           : DataAlts
         child strict         : {Bool}
         child derivings      : {[String]}
      alternative NewType:
         child name           : {String}
         child params         : {[String]}
         child con            : {String}
         child tp             : Type
      alternative Type:
         child name           : {String}
         child params         : {[String]}
         child tp             : Type
      alternative TSig:
         child name           : {String}
         child tp             : Type
      alternative Comment:
         child txt            : {String}
      alternative PragmaDecl:
         child txt            : {String}
      alternative Resume:
         child monadic        : {Bool}
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative EvalDecl:
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
-}
data Decl = Decl (Lhs) (Expr) ((Set String)) ((Set String))
          | Bind (Lhs) (Expr)
          | BindLet (Lhs) (Expr)
          | Data (String) (([String])) (DataAlts) (Bool) (([String]))
          | NewType (String) (([String])) (String) (Type)
          | Type (String) (([String])) (Type)
          | TSig (String) (Type)
          | Comment (String)
          | PragmaDecl (String)
          | Resume (Bool) (String) (Lhs) (Expr)
          | EvalDecl (String) (Lhs) (Expr)
-- Decls -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Decl
         child tl             : Decls
      alternative Nil:
-}
type Decls = [Decl]
-- Expr --------------------------------------------------------
{-
   alternatives:
      alternative Let:
         child decls          : Decls
         child body           : Expr
      alternative Case:
         child expr           : Expr
         child alts           : CaseAlts
      alternative Do:
         child stmts          : Decls
         child body           : Expr
      alternative Lambda:
         child args           : Exprs
         child body           : Expr
      alternative TupleExpr:
         child exprs          : Exprs
      alternative UnboxedTupleExpr:
         child exprs          : Exprs
      alternative App:
         child name           : {String}
         child args           : Exprs
      alternative SimpleExpr:
         child txt            : {String}
      alternative TextExpr:
         child lns            : {[String]}
      alternative Trace:
         child txt            : {String}
         child expr           : Expr
      alternative PragmaExpr:
         child onLeftSide     : {Bool}
         child onNewLine      : {Bool}
         child txt            : {String}
         child expr           : Expr
      alternative LineExpr:
         child expr           : Expr
      alternative TypedExpr:
         child expr           : Expr
         child tp             : Type
      alternative ResultExpr:
         child nt             : {String}
         child expr           : Expr
      alternative InvokeExpr:
         child nt             : {String}
         child expr           : Expr
         child args           : Exprs
      alternative ResumeExpr:
         child nt             : {String}
         child expr           : Expr
         child left           : Lhs
         child rhs            : Expr
      alternative SemFun:
         child nt             : {String}
         child args           : Exprs
         child body           : Expr
-}
data Expr = Let (Decls) (Expr)
          | Case (Expr) (CaseAlts)
          | Do (Decls) (Expr)
          | Lambda (Exprs) (Expr)
          | TupleExpr (Exprs)
          | UnboxedTupleExpr (Exprs)
          | App (String) (Exprs)
          | SimpleExpr (String)
          | TextExpr (([String]))
          | Trace (String) (Expr)
          | PragmaExpr (Bool) (Bool) (String) (Expr)
          | LineExpr (Expr)
          | TypedExpr (Expr) (Type)
          | ResultExpr (String) (Expr)
          | InvokeExpr (String) (Expr) (Exprs)
          | ResumeExpr (String) (Expr) (Lhs) (Expr)
          | SemFun (String) (Exprs) (Expr)
-- Exprs -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Expr
         child tl             : Exprs
      alternative Nil:
-}
type Exprs = [Expr]
-- Lhs ---------------------------------------------------------
{-
   alternatives:
      alternative Pattern3:
         child pat3           : {Pattern}
      alternative Pattern3SM:
         child pat3           : {Pattern}
      alternative TupleLhs:
         child comps          : {[String]}
      alternative UnboxedTupleLhs:
         child comps          : {[String]}
      alternative Fun:
         child name           : {String}
         child args           : Exprs
      alternative Unwrap:
         child name           : {String}
         child sub            : Lhs
-}
data Lhs = Pattern3 (Pattern)
         | Pattern3SM (Pattern)
         | TupleLhs (([String]))
         | UnboxedTupleLhs (([String]))
         | Fun (String) (Exprs)
         | Unwrap (String) (Lhs)
-- NamedType ---------------------------------------------------
{-
   alternatives:
      alternative Named:
         child strict         : {Bool}
         child name           : {String}
         child tp             : Type
-}
data NamedType = Named (Bool) (String) (Type)
-- NamedTypes --------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : NamedType
         child tl             : NamedTypes
      alternative Nil:
-}
type NamedTypes = [NamedType]
-- Program -----------------------------------------------------
{-
   alternatives:
      alternative Program:
         child chunks         : Chunks
         child ordered        : {Bool}
-}
data Program = Program (Chunks) (Bool)
-- Type --------------------------------------------------------
{-
   alternatives:
      alternative Arr:
         child left           : Type
         child right          : Type
      alternative CtxApp:
         child left           : {[(String, [String])]}
         child right          : Type
      alternative QuantApp:
         child left           : {String}
         child right          : Type
      alternative TypeApp:
         child func           : Type
         child args           : Types
      alternative TupleType:
         child tps            : Types
      alternative UnboxedTupleType:
         child tps            : Types
      alternative List:
         child tp             : Type
      alternative SimpleType:
         child txt            : {String}
      alternative NontermType:
         child name           : {String}
         child params         : {[String]}
         child deforested     : {Bool}
      alternative TMaybe:
         child tp             : Type
      alternative TEither:
         child left           : Type
         child right          : Type
      alternative TMap:
         child key            : Type
         child value          : Type
      alternative TIntMap:
         child value          : Type
      alternative TSet:
         child tp             : Type
      alternative TIntSet:
-}
data Type = Arr (Type) (Type)
          | CtxApp (([(String, [String])])) (Type)
          | QuantApp (String) (Type)
          | TypeApp (Type) (Types)
          | TupleType (Types)
          | UnboxedTupleType (Types)
          | List (Type)
          | SimpleType (String)
          | NontermType (String) (([String])) (Bool)
          | TMaybe (Type)
          | TEither (Type) (Type)
          | TMap (Type) (Type)
          | TIntMap (Type)
          | TSet (Type)
          | TIntSet
          deriving ( Show)
-- Types -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Type
         child tl             : Types
      alternative Nil:
-}
type Types = [Type]
</pre></br><h2>printed</h2></br><pre>

-- UUAGC 0.9.51.1 (src-ag/Code.ag)
module Code where Patterns
import Data.Set(Set)
import qualified Data.Set as Set
import Data.Map(Map)
import qualified Data.Map as Map























-- CaseAlt -----------------------------------------------------
{-
   alternatives:
      alternative CaseAlt:
         child left           : Lhs
         child expr           : Expr
-}

-- CaseAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : CaseAlt
         child tl             : CaseAlts
      alternative Nil:
-}

-- Chunk -------------------------------------------------------
{-
   alternatives:
      alternative Chunk:
         child name           : {String}
         child comment        : Decl
         child info           : Decls
         child dataDef        : Decls
         child cataFun        : Decls
         child semDom         : Decls
         child semWrapper     : Decls
         child semFunctions   : Decls
         child semNames       : {[String]}
-}

-- Chunks ------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Chunk
         child tl             : Chunks
      alternative Nil:
-}

-- DataAlt -----------------------------------------------------
{-
   alternatives:
      alternative DataAlt:
         child name           : {String}
         child args           : Types
      alternative Record:
         child name           : {String}
         child args           : NamedTypes
-}


-- DataAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : DataAlt
         child tl             : DataAlts
      alternative Nil:
-}

-- Decl --------------------------------------------------------
{-
   alternatives:
      alternative Decl:
         child left           : Lhs
         child rhs            : Expr
         child binds          : {Set String}
         child uses           : {Set String}
      alternative Bind:
         child left           : Lhs
         child rhs            : Expr
      alternative BindLet:
         child left           : Lhs
         child rhs            : Expr
      alternative Data:
         child name           : {String}
         child params         : {[String]}
         child alts           : DataAlts
         child strict         : {Bool}
         child derivings      : {[String]}
      alternative NewType:
         child name           : {String}
         child params         : {[String]}
         child con            : {String}
         child tp             : Type
      alternative Type:
         child name           : {String}
         child params         : {[String]}
         child tp             : Type
      alternative TSig:
         child name           : {String}
         child tp             : Type
      alternative Comment:
         child txt            : {String}
      alternative PragmaDecl:
         child txt            : {String}
      alternative Resume:
         child monadic        : {Bool}
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative EvalDecl:
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
-}











-- Decls -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Decl
         child tl             : Decls
      alternative Nil:
-}
--   unbox  Whether unboxed tuples are wanted or not
--   inh    The inherited attributes.
--          If there are none, no unboxing can take place,
--          because in that case the semantic function (a top-level identifier) would have an unboxed type.
-- Of course we can't have an unboxed 1-tuple
mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
mkTupleExpr unbox' noInh exprs | not unbox' || noInh || length exprs == 1 = TupleExpr exprs
                               | otherwise                                = UnboxedTupleExpr exprs
mkTupleType :: Bool -> Bool -> Types -> Type
mkTupleType unbox' noInh tps | not unbox' || noInh || length tps == 1 = TupleType tps
                             | otherwise                              = UnboxedTupleType tps
mkTupleLhs-- Expr --------------------------------------------------------:: Bool -> Bool -> [String] -> Lhs
mkTupleLhs{-
   alternatives:
      alternative Let:
         child decls          : Decls
         child body           : Expr
      alternative Case:
         child expr           : Expr
         child alts           : CaseAlts
      alternative Do:
         child stmts          : Decls
         child body           : Expr
      alternative Lambda:
         child args           : Exprs
         child body           : Expr
      alternative TupleExpr:
         child exprs          : Exprs
      alternative UnboxedTupleExpr:
         child exprs          : Exprs
      alternative App:
         child name           : {String}
         child args           : Exprs
      alternative SimpleExpr:
         child txt            : {String}
      alternative TextExpr:
         child lns            : {[String]}
      alternative Trace:
         child txt            : {String}
         child expr           : Expr
      alternative PragmaExpr:
         child onLeftSide     : {Bool}
         child onNewLine      : {Bool}
         child txt            : {String}
         child expr           : Expr
      alternative LineExpr:
         child expr           : Expr
      alternative TypedExpr:
         child expr           : Expr
         child tp             : Type
      alternative ResultExpr:
         child nt             : {String}
         child expr           : Expr
      alternative InvokeExpr:
         child nt             : {String}
         child expr           : Expr
         child args           : Exprs
      alternative ResumeExpr:
         child nt             : {String}
         child expr           : Expr
         child left           : Lhs
         child rhs            : Expr
      alternative SemFun:
         child nt             : {String}
         child args           : Exprs
         child body           : Expr
-}           noInh comps | not unbox' || noInh || length comps == 1 = TupleLhs comps
                               | otherwise                                = UnboxedTupleLhs comps CaseAlt = CaseAlt (Lhs) (Expr)








type CaseAlts = [CaseAlt]














data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))








type Chunks = [Chunk]










data DataAlt = DataAlt (String) (Types)
             | Record (String) (NamedTypes)








type DataAlts = [DataAlt]














































data Decl = Decl (Lhs) (Expr) ((Set String)) ((Set String))
          | Bind (Lhs) (Expr)
          | BindLet (Lhs) (Expr)
          | Data (String) (([String])) (DataAlts) (Bool) (([String]))
          | NewType (String) (([String])) (String) (Type)
          | Type (String) (([String])) (Type)
          | TSig (String) (Type)
          | Comment (String)
          | PragmaDecl (String)
          | Resume (Bool) (String) (Lhs) (Expr)
          | EvalDecl (String) (Lhs) (Expr)








type Decls = [Decl]
























































data Expr = Let (Decls) (Expr)
          | Case (Expr) (CaseAlts)
          | Do (Decls) (Expr)
          | Lambda (Exprs) (Expr)
          | TupleExpr (Exprs)
          | UnboxedTupleExpr (Exprs)
          | App (String) (Exprs)
          | SimpleExpr (String)
          | TextExpr (([String]))
          | Trace (String) (Expr)
          | PragmaExpr (Bool) (Bool) (String) (Expr)
          | LineExpr (Expr)
          | TypedExpr (Expr) (Type)
          | ResultExpr (String) (Expr)
          | InvokeExpr (String) (Expr) (Exprs)
          | ResumeExpr (String) (Expr) (Lhs) (Expr)
          | SemFun (String) (Exprs) (Expr)
-- Exprs -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Expr
         child tl             : Exprs
      alternative Nil:
-}
type Exprs = [Expr]
-- Lhs ---------------------------------------------------------
{-
   alternatives:
      alternative Pattern3:
         child pat3           : {Pattern}
      alternative Pattern3SM:
         child pat3           : {Pattern}
      alternative TupleLhs:
         child comps          : {[String]}
      alternative UnboxedTupleLhs:
         child comps          : {[String]}
      alternative Fun:
         child name           : {String}
         child args           : Exprs
      alternative Unwrap:
         child name           : {String}
         child sub            : Lhs
-}
data Lhs = Pattern3 (Pattern)
         | Pattern3SM (Pattern)
         | TupleLhs (([String]))
         | UnboxedTupleLhs (([String]))
         | Fun (String) (Exprs)
         | Unwrap (String) (Lhs)
-- NamedType ---------------------------------------------------
{-
   alternatives:
      alternative Named:
         child strict         : {Bool}
         child name           : {String}
         child tp             : Type
-}
data NamedType = Named (Bool) (String) (Type)
-- NamedTypes --------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : NamedType
         child tl             : NamedTypes
      alternative Nil:
-}
type NamedTypes = [NamedType]
-- Program -----------------------------------------------------
{-
   alternatives:
      alternative Program:
         child chunks         : Chunks
         child ordered        : {Bool}
-}
data Program = Program (Chunks) (Bool)
-- Type --------------------------------------------------------
{-
   alternatives:
      alternative Arr:
         child left           : Type
         child right          : Type
      alternative CtxApp:
         child left           : {[(String, [String])]}
         child right          : Type
      alternative QuantApp:
         child left           : {String}
         child right          : Type
      alternative TypeApp:
         child func           : Type
         child args           : Types
      alternative TupleType:
         child tps            : Types
      alternative UnboxedTupleType:
         child tps            : Types
      alternative List:
         child tp             : Type
      alternative SimpleType:
         child txt            : {String}
      alternative NontermType:
         child name           : {String}
         child params         : {[String]}
         child deforested     : {Bool}
      alternative TMaybe:
         child tp             : Type
      alternative TEither:
         child left           : Type
         child right          : Type
      alternative TMap:
         child key            : Type
         child value          : Type
      alternative TIntMap:
         child value          : Type
      alternative TSet:
         child tp             : Type
      alternative TIntSet:
-}
data Type = Arr (Type) (Type)
          | CtxApp (([(String, [String])])) (Type)
          | QuantApp (String) (Type)
          | TypeApp (Type) (Types)
          | TupleType (Types)
          | UnboxedTupleType (Types)
          | List (Type)
          | SimpleType (String)
          | NontermType (String) (([String])) (Bool)
          | TMaybe (Type)
          | TEither (Type) (Type)
          | TMap (Type) (Type)
          | TIntMap (Type)
          | TSet (Type)
          | TIntSet
          deriving ( Show)
-- Types -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Type
         child tl             : Types
      alternative Nil:
-}
type Types = [Type]

</pre>