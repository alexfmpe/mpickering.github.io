<a href="LhsToIpynb.hs250334414450031625.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Lib.hs578354438892053144.out.html">next</a></br></br><pre>18c18
< class FunToList t tl | t → tl
---
> class FunToList t tl | t -> tl
22c22
<          ⇒ FunToList t tl
---
>          => FunToList t tl
24c24
< class FunToList' a t tl | a t → tl
---
> class FunToList' a t tl | a t -> tl
31c31
<        ⇒ FunToList' HTrue (x → y) tl
---
>        => FunToList' HTrue (x -> y) tl
37c37
< class ListToFun tl t | tl → t
---
> class ListToFun tl t | tl -> t
42d41
<           ListToFun ((a → r) :*: tls) t)
43c42
<          ⇒ ListToFun (r :*: (tl :*: tls)) t
---
>           ListToFun ((a -> r) :*: tls) t)
43a43
>          => ListToFun (r :*: (tl :*: tls)) t
50d49
< class IsFunction a b | a → b
51d49
< instance TypeCast f HTrue ⇒ IsFunction (x → y) f
52c50
< instance TypeCast f HFalse ⇒ IsFunction a f
---
> class IsFunction a b | a -> b
52a51
> instance TypeCast f HTrue => IsFunction (x -> y) f
52a52
> instance TypeCast f HFalse => IsFunction a f
54d53
< class TypeEq' () x y b ⇒ TypeEq x y b | x y → b
55d53
< class TypeEq' q x y b | q x y → b
56d53
< class TypeEq'' q x y b | q x y → b
57d53
< instance TypeEq' () x y b ⇒ TypeEq x y b
58d53
< instance TypeCast b HTrue ⇒ TypeEq' () x x b
59c54
< instance TypeEq'' q x y b ⇒ TypeEq' q x y b
---
> class TypeEq' () x y b => TypeEq x y b | x y -> b
59a55
> class TypeEq' q x y b | q x y -> b
59a56
> class TypeEq'' q x y b | q x y -> b
59a57
> instance TypeEq' () x y b => TypeEq x y b
59a58
> instance TypeCast b HTrue => TypeEq' () x x b
59a59
> instance TypeEq'' q x y b => TypeEq' q x y b
62a63
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
  UndecidableInstances, IncoherentInstances,
  UnicodeSyntax, TypeOperators, ScopedTypeVariables, MultiParamTypeClasses,
  FunctionalDependencies, TypeSynonymInstances, FlexibleInstances,
  FlexibleContexts #-}

module Guess.Combinator.Lib (module Prelude, module Data.HList, module Guess.Combinator.Lib) where

import Prelude (($), (++), show, Either(..), Maybe(..), Num(..), Show(..), Bool(..))
import Data.HList (HTrue, HFalse, HNil(HNil), HCons(HCons), (:*:), HAppend, HReverse)
import Data.HList.TypeCastGeneric2 (TypeCast)

-- | FunToList +type -typelist
-- Flatten the functions in a given type, in reverse order
--
-- For example, FunToList (a -> (b -> c) -> d) [d, [c, [b]], [a]]

class FunToList t tl | t → tl

instance (IsFunction t flag,
          FunToList' flag t tl)
         ⇒ FunToList t tl

class FunToList' a t tl | a t → tl

instance FunToList' HFalse t (t :*: HNil)

instance (FunToList x tlx,
          FunToList y tly,
          HAppend tly (tlx :*: HNil) tl)
       ⇒ FunToList' HTrue (x → y) tl

-- | ListToFun +typelist -type
--
-- Reverse of FunToList

class ListToFun tl t | tl → t

instance ListToFun (t :*: HNil) t

instance (ListToFun tl a,
          ListToFun ((a → r) :*: tls) t)
         ⇒ ListToFun (r :*: (tl :*: tls)) t

-- Misc type-level programming classes and helpers

infixr 2 .*.
a .*. b = HCons a b

class IsFunction a b | a → b
instance TypeCast f HTrue ⇒ IsFunction (x → y) f
instance TypeCast f HFalse ⇒ IsFunction a f

class TypeEq' () x y b ⇒ TypeEq x y b | x y → b
class TypeEq' q x y b | q x y → b
class TypeEq'' q x y b | q x y → b
instance TypeEq' () x y b ⇒ TypeEq x y b
instance TypeCast b HTrue ⇒ TypeEq' () x x b
instance TypeEq'' q x y b ⇒ TypeEq' q x y b
instance TypeEq'' () x y HFalse

data Proxy t = Proxy
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
  UndecidableInstances, IncoherentInstances,
  UnicodeSyntax, TypeOperators, ScopedTypeVariables, MultiParamTypeClasses,
  FunctionalDependencies, TypeSynonymInstances, FlexibleInstances,
  FlexibleContexts #-}

module Guess.Combinator.Lib (module Prelude, module Data.HList, module Guess.Combinator.Lib) where

import Prelude (($), (++), show, Either(..), Maybe(..), Num(..), Show(..), Bool(..))
import Data.HList (HTrue, HFalse, HNil(HNil), HCons(HCons), (:*:), HAppend, HReverse)
import Data.HList.TypeCastGeneric2 (TypeCast)

-- | FunToList +type -typelist
-- Flatten the functions in a given type, in reverse order
--
-- For example, FunToList (a -> (b -> c) -> d) [d, [c, [b]], [a]]

class FunToList t tl | t -> tl

instance (IsFunction t flag,
          FunToList' flag t tl)
         => FunToList t tl

class FunToList' a t tl | a t -> tl

instance FunToList' HFalse t (t :*: HNil)

instance (FunToList x tlx,
          FunToList y tly,
          HAppend tly (tlx :*: HNil) tl)
       => FunToList' HTrue (x -> y) tl

-- | ListToFun +typelist -type
--
-- Reverse of FunToList

class ListToFun tl t | tl -> t

instance ListToFun (t :*: HNil) t

instance (ListToFun tl a,
          ListToFun ((a -> r) :*: tls) t)
         => ListToFun (r :*: (tl :*: tls)) t

-- Misc type-level programming classes and helpers

infixr 2 .*.
a .*. b = HCons a b

class IsFunction a b | a -> b
instance TypeCast f HTrue => IsFunction (x -> y) f
instance TypeCast f HFalse => IsFunction a f

class TypeEq' () x y b => TypeEq x y b | x y -> b
class TypeEq' q x y b | q x y -> b
class TypeEq'' q x y b | q x y -> b
instance TypeEq' () x y b => TypeEq x y b
instance TypeCast b HTrue => TypeEq' () x x b
instance TypeEq'' q x y b => TypeEq' q x y b
instance TypeEq'' () x y HFalse

data Proxy t = Proxy

</pre>