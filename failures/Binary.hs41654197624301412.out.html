<a href="Binary.hs307187357347221711.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BinDU.hs2121578553552265483.out.html">next</a></br></br><pre>173d172
< -- representation size.
174d172
< fixedSize :: (HasResolution r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
175d172
< {-# INLINE fixedSize #-}
176c173
< fixedSize x = withResolution $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
---
> -- representation size.-- | Fast conversion between fixed-point numbers with the same
176a174
> fixedSize-- representation size.:: (HasResolution r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
176a175
> fixedSize{-# INLINE::fixedSizeHasResolution#-}    r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
176a176
> {-# INLINEfixedSize xfixedSize= withResolution#-}     $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
176a177
> fixedSize-- TODO Rewrite rules? = withResolution $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
178d178
< 
180d179
< (*.) :: (Num (Super a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
181c180
< {-# INLINE (*.) #-}
---
> (-- | Multiplication without throwing away fractional information.*.) :: (Num (Super a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
181a181
> ({-# INLINE*.) :: (Num(*.Super) #-} a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
181a182
> {-# INLINE(*.) = inFixed2*.) #-}((fmap subCast . (*)) `on` superCast)
183d183
< 
185d184
< -- fractional part.
186d184
< (/.) :: Integral a => Fixed r a -> Fixed s a -> Fixed (r :- s) a
187c185
< {-# INLINE (/.) #-}
---
> -- fractional part.-- | Division while removing unnecessary bits in the result's
187a186
> (-- fractional part./.) :: Integral a => Fixed r a -> Fixed s a -> Fixed (r :- s) a
187a187
> ({-# INLINE/.) :: Integral(/.) #-} => Fixed r a -> Fixed s a -> Fixed (r :- s) a
187a188
> {-# INLINE(/.) = inFixed2/.) #-}eucQuot
189d189
< 
191d190
< -- intermediate steps. This may be faster (especially when you are
192d190
< -- already working with native-sized integer data), but it's only safe
193d190
< -- to use if you are sure that the multiplication won't
194d190
< -- overflow. Normal multiplication is equivalent to @\x y -> subCast
195d190
< -- (superCast x *!  superCast y)@.
196d190
< (*!) :: (HasResolution r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
197c191
< {-# INLINE (*!) #-}
---
> -- intermediate steps. This may be faster (especially when you are-- | Perform a multiplication without adding any extra bits for the
197a192
> -- intermediate steps. This may be faster (especially when you are-- already working with native-sized integer data), but it's only safe
197a193
> -- to use if you are sure that the multiplication won't-- already working with native-sized integer data), but it's only safe
197a194
> -- to use if you are sure that the multiplication won't-- overflow. Normal multiplication is equivalent to @\x y -> subCast
197a195
> -- (superCast x *!  superCast y)@.-- overflow. Normal multiplication is equivalent to @\x y -> subCast
197a196
> (-- (superCast x *!  superCast y)@.*!) :: (HasResolution r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
197a197
> ({-# INLINE*!) :: (HasResolution(*!) #-}    r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
197a198
> {-# INLINEFixed x *! (Fixed*!) #-}y = withResolution $ Fixed . shiftR (x * y)
199d199
< 
201d200
< -- intermediate steps. This may be faster if supercasting brings it up
202d200
< -- to a non-native size, but you need to be sure that the shifting
203d200
< -- before the division won't cause an overflow.
204d200
< (/!) :: (HasResolution r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
205c201
< {-# INLINE (/!) #-}
---
> -- | Perform a division without adding any extra bits for the-- intermediate steps. This may be faster if supercasting brings it up
205a202
> -- to a non-native size, but you need to be sure that the shifting-- intermediate steps. This may be faster if supercasting brings it up
205a203
> -- before the division won't cause an overflow.-- to a non-native size, but you need to be sure that the shifting
205a204
> (-- before the division won't cause an overflow./!) :: (HasResolution r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
205a205
> ({-# INLINE/!) :: (HasResolution(/!) #-}    r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
205a206
> {-# INLINEa /! b = Fixed/!)$#-}(unFixed a `shiftL` resolution a) `eucQuot` unFixed b
207d207
< 
209d208
< -- expose this function.
210d208
< toRealFloat :: (HasResolution r, Integral a, RealFloat b) => Fixed r a -> b
211d208
< {-# INLINE toRealFloat #-}
212d208
< toRealFloat = liftA2 encodeFloat (fromIntegral . unFixed) (negate . resolution)
213c209
< {-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> Float #-}
---
> -- expose this function.-- TODO Don't assume it's a binary float so that we can actually
213a210
> toRealFloat-- expose this function.:: (HasResolution r, Integral a, RealFloat b) => Fixed r a -> b
213a211
> toRealFloat{-# INLINE toRealFloat:: (HasResolution#-}    r, Integral a, RealFloat b) => Fixed r a -> b
213a212
> {-# INLINEtoRealFloattoRealFloat= liftA2 encodeFloat#-}       (fromIntegral . unFixed) (negate . resolution)
213a213
> toRealFloat{-# SPECIALIZE= liftA2toRealFloat:: (HasResolutionfromIntegralr,.Integral)a(negate=> Fixed resolutionr a -> Float)   #-}
213a214
> {-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> FloatDouble#-}#-}
215d215
< 
217d216
< "realToFrac/Float"  forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Float
218c217
< "realToFrac/Double" forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Double
---
> {-# RULES"realToFrac/Float"  forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Float
218a218
> "realToFrac/Float""realToFrac/Double" forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: FloatDouble
218a219
> "realToFrac/Double"#-}               forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Double
220d220
< 
223d222
< {-# INLINE fromRealFloat #-}
224d222
< fromRealFloat x = let (s,e) = decodeFloat x
225d222
<                   in withResolution $ \t -> Fixed . fromIntegral $ shiftBaseExp s (floatRadix x) (t + e)
226c223
< {-# SPECIALIZE fromRealFloat :: (HasResolution r, Num b) => Float -> Fixed r b #-}
---
> {-# INLINE-- | Fast conversion from floating-point to fixed-point.fromRealFloat #-}
226a224
> fromRealFloat ::x =(RealFloatlet (s,e) a,decodeFloatx  r, Num b) => a -> Fixed r b
226a225
> {-# INLINE fromRealFloatin withResolution#-}        $ \t -> Fixed . fromIntegral $ shiftBaseExp s (floatRadix x) (t + e)
226a226
> fromRealFloat{-# SPECIALIZExfromRealFloat= let (s,e) =::(HasResolution    r, Num b) => Float -> Fixed r b #-}
226a227
>             {-# SPECIALIZE fromRealFloatin withResolution:: (HasResolution \t -> Fixedr, .Numb) => Double shiftBaseExp-> Fixed r b s#-}floatRadix x) (t + e)
226a228
> {-# SPECIALIZE-- TODO Rewrite rules? :: (HasResolution r, Num b) => Float -> Fixed r b #-}
228d229
< -- TODO Rewrite rules?
229d229
< 
230c230
< shiftBaseExp :: Integer -> Integer -> Int -> Integer
---
> shiftBaseExp-- TODO Rewrite rules?:: Integer -> Integer -> Int -> Integer
232d231
<                    | otherwise = x * (b ^ e)
233d231
< 
234c232
< data E0
---
> shiftBaseExp :: Integer| otherwise-> Integer= x ->* (Intb ^ ->e) Integer
234a233
> shiftBaseExp x b e | e < 0     = x `eucQuot` (b ^ negate e)
234a234
> data E0            | otherwise = x * (b ^ e)
236c236
< -- | Increment a resolution
---
> data-- | Increment a resolution
238d237
< 
239c238
< -- | Add resolutions
---
> -- | Increment a resolution
239a239
> data-- | Add resolutions n
240a241
> type-- | Add resolutionsinstance E0 :+ b = b
240a242
> type familyinstance :+S ab:+ b = S (a :+ b)
242d243
< type instance S a :+ b = S (a :+ b)
243d243
< 
244c244
< -- | Subtract resolutions
---
> type-- | Subtract resolutionsinstance S a :+ b = S (a :+ b)
245a246
> type-- | Subtract resolutionsinstance a :- E0 = a
245a247
> type familyinstance :-S ab:- S b = a :- b
247d248
< type instance S a :- S b = a :- b
248d248
< 
249c249
< -- | Decrement a resolution
---
> type-- | Decrement a resolutioninstance S a :- S b = a :- b
251d250
< type instance P (S a) = a
252d250
< 
253c251
< type E1  = S E0
---
> type-- | Decrement a resolutioninstance P (S a) = a
253a252
> type family P a
253a253
> type instanceE1  = S E0 (S a) = a
255d254
< type E4  = E2 :+ E2
256d254
< type E8  = E4 :+ E4
257d254
< type E10 = S (S E8)
258c255
< type E16 = E8 :+ E8
---
> type E1  = SE2E0:+ E2
258a256
> type E2  = E1 :+ E1
258a257
> type E4E10 = E2S (:+S E8)
258a258
> type E8E16 = E4 :+ E4
258a259
> type E10 = SE10S:+)E10
258a260
> type E16 = E8E20:+:+E8E10
262d263
< type E64 = E32 :+ E32
263d263
< 
264c264
< instance HasResolution n => HasResolution (S n) where
---
> typeinstance =HasResolution :+ E32  n => HasResolution (S n) where
266d265
<   resolution = succ . resolution' undefined
267d265
<     where resolution' :: (HasResolution n, Num a) =>
268c266
<                          Fixed n a -> Fixed (S n) a -> Int
---
> instanceresolution= succ . resolution' => HasResolutionundefinedS n) where
268a267
>   {-# INLINEwhere resolution'::#-}(HasResolution n, Num a) =>
268a268
>   resolution = succ . resolution'Fixed n aundefined-> Fixed (S n) a -> Int
268a269
>     where resolution'{-# INLINE resolution':: (HasResolution#-}    n, Num a) =>
268a270
>           resolution' dummy= const a ->$ FixedresolutionS n)dummy -> Int
270d271
<           resolution' dummy = const $ resolution dummy
271d271
< 
272c272
< instance HasResolution E0 where
---
> instance HasResolution dummyE0 where= const $ resolution dummy
274d273
<   resolution = const 0
275d273
< 
276c274
< -- | Instances of 'SuperTypeable' can be cast up to and down from a
---
> instanceresolution= const 0 E0 where
276a275
>   {-# INLINE resolution #-}
276a276
> -- | Instances of 'SuperTypeable' can be cast up to and down from a = const 0
278c278
< -- hold at least twice as much information to be a valid instance.
---
> -- hold at least twice as much information to be a valid instance.-- | Instances of 'SuperTypeable' can be cast up to and down from a
278a279
> class-- supertype. If the type is bounded, the supertype must be able toSuperTypeable a where
278a280
> -- hold at least twice as much information to be a valid instance.type Super a
280d281
<   type Super a
281d281
< 
282c282
<   -- | Losslessly cast to a supertype.
---
>   type-- | Losslessly cast to a supertype. a
284d283
< 
285c284
<   -- | Cast to a subtype. Information may be lost.
---
>   -- | Losslessly cast to a supertype.
285a285
>   superCast-- | Cast to a subtype. Information may be lost.:: a -> Super a
287d286
< 
288c287
< {-# RULES
---
>   -- | Cast to a subtype. Information may be lost.
288a288
> {-# RULES :: Super a -> a
290d289
<   #-}
291d289
< 
292c290
< instance (SuperTypeable a, Num a, Num (Super a), Integral a, Integral (Super a)) =>
---
> {-# RULES#-}
292a291
> "subCast . superCast" subCast . superCast = id
292a292
> instance#-}    (SuperTypeable a, Num a, Num (Super a), Integral a, Integral (Super a)) =>
295c295
<   {-# INLINE superCast #-}
---
> instance{-# INLINESuperTypeablesuperCast #-}, Num a, Num (Super a), Integral a, Integral (Super a)) =>
295a296
>   superCast= fixedRadixFixed r a) where
295a297
>   type{-# INLINE (subCastFixed r#-}) = Fixed r (Super a)
295a298
>   {-# INLINEsubCast = fixedRadix #-}
297d299
<   {-# INLINE subCast #-}
298d299
<   subCast = fixedRadix
299d299
< 
300d299
< instance SuperTypeable Word8 where
301c300
<   type Super Word8 = Word16
---
> instance SuperTypeable #-}Word8 where
301a301
>   subCasttype Super= fixedRadixWord8 = Word16
302a303
> instancesuperCast= fromIntegral where
302a304
>   type{-# INLINE Word8subCast= Word16#-}
302a305
>   {-# INLINEsubCast = fromIntegral #-}
304d306
<   {-# INLINE subCast #-}
305d306
<   subCast = fromIntegral
306d306
< 
307d306
< instance SuperTypeable Word16 where
308c307
<   type Super Word16 = Word32
---
> instance SuperTypeable #-}Word16 where
308a308
>   subCasttype Super= fromIntegralWord16 = Word32
309a310
> instancesuperCast= fromIntegral where
309a311
>   type{-# INLINE Word16subCast=#-}
309a312
>   {-# INLINEsubCast = fromIntegral #-}
311d313
<   {-# INLINE subCast #-}
312d313
<   subCast = fromIntegral
313d313
< 
314d313
< instance SuperTypeable Word32 where
315c314
<   type Super Word32 = Word64
---
> instance SuperTypeable #-}Word32 where
315a315
>   subCasttype Super= fromIntegralWord32 = Word64
316a317
> instancesuperCast= fromIntegral where
316a318
>   type{-# INLINE Word32subCast=#-}
316a319
>   {-# INLINEsubCast = fromIntegral #-}
318d320
<   {-# INLINE subCast #-}
319d320
<   subCast = fromIntegral
320d320
< 
321d320
< instance SuperTypeable Word64 where
322c321
<   type Super Word64 = Integer
---
> instance SuperTypeable #-}Word64 where
322a322
>   subCasttype Super= fromIntegralWord64 = Integer
323a324
> instancesuperCast= fromIntegral where
323a325
>   type{-# INLINE Word64subCast=#-}
323a326
>   {-# INLINEsubCast = fromIntegral #-}
325d327
<   {-# INLINE subCast #-}
326d327
<   subCast = fromIntegral
327d327
< 
328d327
< instance SuperTypeable Word where
329c328
< #ifdef i386_HOST_ARCH
---
> instance SuperTypeable #-}Word where
329a329
> #ifdef i386_HOST_ARCH = fromIntegral
331c331
< #else
---
> instance#else     SuperTypeable Word where
335c335
<   superCast = fromIntegral
---
>   typesuperCast=WordfromIntegral= Integer
337d336
<   subCast = fromIntegral
338d336
< 
339d336
< instance SuperTypeable Int8 where
340c337
<   type Super Int8 = Int16
---
>   {-# INLINEsubCast = fromIntegral #-}
340a338
>   superCast = fromIntegral
340a339
> instance SuperTypeable #-}Int8 where
340a340
>   subCasttype Super= fromIntegralInt8 = Int16
341a342
> instancesuperCast= fromIntegral where
341a343
>   type{-# INLINE Int8subCast= Int16#-}
341a344
>   {-# INLINEsubCast = fromIntegral #-}
343d345
<   {-# INLINE subCast #-}
344d345
<   subCast = fromIntegral
345d345
< 
346d345
< instance SuperTypeable Int16 where
347c346
<   type Super Int16 = Int32
---
> instance SuperTypeable #-}Int16 where
347a347
>   subCasttype Super= fromIntegralInt16 = Int32
348a349
> instancesuperCast= fromIntegral where
348a350
>   type{-# INLINE Int16subCast= Int32#-}
348a351
>   {-# INLINEsubCast = fromIntegral #-}
350d352
<   {-# INLINE subCast #-}
351d352
<   subCast = fromIntegral
352d352
< 
353d352
< instance SuperTypeable Int32 where
354c353
<   type Super Int32 = Int64
---
> instance SuperTypeable #-}Int32 where
354a354
>   subCasttype Super= fromIntegralInt32 = Int64
355a356
> instancesuperCast= fromIntegral where
355a357
>   type{-# INLINE Int32subCast= Int64#-}
355a358
>   {-# INLINEsubCast = fromIntegral #-}
357d359
<   {-# INLINE subCast #-}
358d359
<   subCast = fromIntegral
359d359
< 
360d359
< instance SuperTypeable Int64 where
361c360
<   type Super Int64 = Integer
---
> instance SuperTypeable #-}Int64 where
361a361
>   subCasttype Super= fromIntegralInt64 = Integer
362a363
> instancesuperCast= fromIntegral where
362a364
>   type{-# INLINE Int64subCast= Integer#-}
362a365
>   {-# INLINEsubCast = fromIntegral #-}
364d366
<   {-# INLINE subCast #-}
365d366
<   subCast = fromIntegral
366d366
< 
367d366
< instance SuperTypeable Int where
368c367
< #ifdef i386_HOST_ARCH
---
> instance SuperTypeable #-}Int where
368a368
> #ifdef i386_HOST_ARCH = fromIntegral
370c370
< #else
---
> instance#else     SuperTypeable Int where
374c374
<   superCast = fromIntegral
---
>   typesuperCast=IntfromIntegral= Integer
376d375
<   subCast = fromIntegral
377d375
< 
378d375
< instance SuperTypeable Integer where
379c376
<   type Super Integer = Integer
---
>   {-# INLINEsubCast = fromIntegral #-}
379a377
>   superCast = fromIntegral
379a378
> instance SuperTypeable #-}Integer where
379a379
>   subCasttype Super= fromIntegralInteger = Integer
380a381
> instancesuperCast= id       Integer where
380a382
>   type{-# INLINE Integer =#-}
380a383
>   {-# INLINEsubCast = id #-}
382d384
<   {-# INLINE subCast #-}
383d384
<   subCast = id
384d384
< 
385d384
< eucQuot :: Integral a => a -> a -> a
386c385
< {-# INLINE eucQuot #-}
---
> eucQuot :: Integrala#-}=> a -> a -> a
386a386
> {-# INLINE =eucQuot     #-}
388d387
<   | a >= 0    = a `quot` b
389d387
<   | b >  0    = ((a + 1) `quot` b) - 1
390c388
<   | otherwise = ((a + 1) `quot` b) + 1
---
> eucQuot| a >=::0 Integral= a `quot =>` a -> a -> a
390a389
> {-# INLINE| b >  0 eucQuot= ((a#-}+ 1) `quot` b) - 1
390a390
> a `eucQuototherwise` b = ((a + 1) `quot` b) + 1
390a391
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE ViewPatterns #-}

{-|
This module defines a type for binary fixed-point arithmetic. The main
advantage this provides over decimal fixed-point arithmetic is that
the point is maintained using fast bit shifts instead of slow 'div'
operations. This type is also polymorphic on the underlying
representation, so you can use whatever size and signedness you
want.
-}
module Data.Fixed.Binary
       ( div'
       , mod'
       , divMod'
       , Fixed ()
       , SuperTypeable (..)
       , HasResolution (..)
       , E0, E1, E2, E4, E8, E10, E16, E20, E30, E32, E64
       , S, P
       , fixedRadix, fixedSize, fromRealFloat
       , (:+), (*.), (*!)
       , (:-), (/.), (/!)
       ) where

import Control.Applicative
import Control.Arrow
import Data.Bits
import Data.Fixed (div', mod', divMod')
import Data.Function
import Data.Int
import Data.List
import Data.Maybe
import Data.Ratio
import Data.Typeable
import Data.Word
import Text.Read
import qualified Text.Read.Lex as L

-- | The first type parameter represents the number of bits to devote
-- to the fractional part of the number. The second type parameter is
-- the underlying representation. For example, @Fixed E8 Int16@ uses
-- eight bits for the integer component (of which one bit is used for
-- the sign) and eight bits for the fractional component.
newtype Fixed r a = Fixed { unFixed :: a }
                  deriving (Bounded, Enum, Eq, Ord, Typeable)

inFixed :: (a -> b) -> (Fixed r a -> Fixed s b)
{-# INLINE inFixed #-}
inFixed = (Fixed .) . (. unFixed)

inFixed2 :: (a -> b -> c) -> (Fixed r a -> Fixed s b -> Fixed t c)
{-# INLINE inFixed2 #-}
inFixed2 = (inFixed .) . (. unFixed)

-- | Instances of this class are useful as the first parameter of
-- 'Fixed'.
class HasResolution r where
  -- | Given a fixed-point number, give the number of bits used to
  -- represent its fractional part.
  resolution :: Num a => Fixed r a -> Int

withResolution :: (HasResolution r, Num a) => (Int -> Fixed r a) -> Fixed r a
{-# INLINE withResolution #-}
withResolution f = withType (f . resolution)
  where withType :: (Fixed r a -> Fixed r a) -> Fixed r a
        withType g = g undefined

-- Read a signed number. Stolen from GHC.Read.
readNumber :: Num a => (L.Lexeme -> ReadPrec a) -> ReadPrec a
readNumber convert =
  parens
  ( do x <- lexP
       case x of
         L.Symbol "-" -> do y <- lexP
                            n <- convert y
                            return (negate n)

         _   -> convert x
  )

-- Stolen from GHC.Read.
convertFrac :: Fractional a => L.Lexeme -> ReadPrec a
convertFrac (L.Int i) = return (fromInteger i)
convertFrac (L.Rat r) = return (fromRational r)
convertFrac _         = pfail

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Read (Fixed r a) where
  readPrec = readNumber convertFrac

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Show (Fixed r a) where
  show (properFraction -> (i, f)) =
    show (i :: Integer) ++ "." ++ (uncurry pad . second (show . numerator) .
                                   fromJust . find ((==1) . denominator . snd) .
                                   iterate (succ *** (*10)) . (,) 0 $
                                   toRational f)
    where pad n str = replicate (n - length str) '0' ++ str

instance ( HasResolution r, Bits a, Bits (Super a), Integral a, Num (Super a)
         , Integral (Super a), SuperTypeable a) => Num (Fixed r a) where
  {-# INLINE (+) #-}
  (+) = inFixed2 (+)
  {-# INLINE (-) #-}
  (-) = inFixed2 (-)
  {-# INLINE (*) #-}
  (*) = fmap subCast . (*!) `on` superCast
  {-# INLINE negate #-}
  negate = inFixed negate
  {-# INLINE abs #-}
  abs = inFixed abs
  {-# INLINE signum #-}
  signum (Fixed x) = withResolution $ \s -> Fixed $ signum x `shiftL` s
  {-# INLINE fromInteger #-}
  fromInteger i = withResolution $ Fixed . shiftL (fromInteger i)

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Real (Fixed r a) where
  {-# INLINE toRational #-}
  toRational x = toRational (unFixed x) / toRational (2 ^ resolution x :: Integer)

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Fractional (Fixed r a) where
  {-# INLINE (/) #-}
  (/) = fmap subCast . (/!) `on` superCast
  {-# INLINE recip #-}
  recip x = Fixed . subCast $ (1 `shiftL` (2 * resolution x)) `eucQuot` superCast (unFixed x)
  {-# INLINE fromRational #-}
  fromRational r = withResolution $ \s ->
    Fixed . floor $ (numerator r `shiftL` s) % denominator r

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => RealFrac (Fixed r a) where
  {-# INLINE properFraction #-}
  properFraction a = let i = truncate a in (i, a - fromIntegral i)
  {-# INLINE truncate #-}
  truncate = truncate . toRational
  {-# INLINE round #-}
  round = round . toRational
  {-# INLINE ceiling #-}
  ceiling = ceiling . toRational
  {-# INLINE floor #-}
  floor = floor . toRational

-- | Fast conversion between fixed-point numbers with the same
-- fractional size.
fixedRadix :: (Integral a, Num b) => Fixed r a -> Fixed r b
{-# INLINE fixedRadix #-}
fixedRadix = inFixed fromIntegral

-- TODO Can't I write this as one awesome, polymorphic rule?
{-# RULES
"realToFrac/fixedRadixInt"     forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int
"realToFrac/fixedRadixInt8"    forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int8
"realToFrac/fixedRadixInt16"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int16
"realToFrac/fixedRadixInt32"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int32
"realToFrac/fixedRadixInt64"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int64
"realToFrac/fixedRadixWord"    forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word
"realToFrac/fixedRadixWord8"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word8
"realToFrac/fixedRadixWord16"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word16
"realToFrac/fixedRadixWord32"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word32
"realToFrac/fixedRadixWord64"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word64
"realToFrac/fixedRadixInteger" forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Integer
  #-}

-- | Fast conversion between fixed-point numbers with the same
-- representation size.
fixedSize :: (HasResolution r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
{-# INLINE fixedSize #-}
fixedSize x = withResolution $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
-- TODO Rewrite rules?

-- | Multiplication without throwing away fractional information.
(*.) :: (Num (Super a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
{-# INLINE (*.) #-}
(*.) = inFixed2 ((fmap subCast . (*)) `on` superCast)

-- | Division while removing unnecessary bits in the result's
-- fractional part.
(/.) :: Integral a => Fixed r a -> Fixed s a -> Fixed (r :- s) a
{-# INLINE (/.) #-}
(/.) = inFixed2 eucQuot

-- | Perform a multiplication without adding any extra bits for the
-- intermediate steps. This may be faster (especially when you are
-- already working with native-sized integer data), but it's only safe
-- to use if you are sure that the multiplication won't
-- overflow. Normal multiplication is equivalent to @\x y -> subCast
-- (superCast x *!  superCast y)@.
(*!) :: (HasResolution r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
{-# INLINE (*!) #-}
Fixed x *! Fixed y = withResolution $ Fixed . shiftR (x * y)

-- | Perform a division without adding any extra bits for the
-- intermediate steps. This may be faster if supercasting brings it up
-- to a non-native size, but you need to be sure that the shifting
-- before the division won't cause an overflow.
(/!) :: (HasResolution r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
{-# INLINE (/!) #-}
a /! b = Fixed $ (unFixed a `shiftL` resolution a) `eucQuot` unFixed b

-- TODO Don't assume it's a binary float so that we can actually
-- expose this function.
toRealFloat :: (HasResolution r, Integral a, RealFloat b) => Fixed r a -> b
{-# INLINE toRealFloat #-}
toRealFloat = liftA2 encodeFloat (fromIntegral . unFixed) (negate . resolution)
{-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> Float #-}
{-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> Double #-}

{-# RULES
"realToFrac/Float"  forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Float
"realToFrac/Double" forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Double
  #-}

-- | Fast conversion from floating-point to fixed-point.
fromRealFloat :: (RealFloat a, HasResolution r, Num b) => a -> Fixed r b
{-# INLINE fromRealFloat #-}
fromRealFloat x = let (s,e) = decodeFloat x
                  in withResolution $ \t -> Fixed . fromIntegral $ shiftBaseExp s (floatRadix x) (t + e)
{-# SPECIALIZE fromRealFloat :: (HasResolution r, Num b) => Float -> Fixed r b #-}
{-# SPECIALIZE fromRealFloat :: (HasResolution r, Num b) => Double -> Fixed r b #-}
-- TODO Rewrite rules?

shiftBaseExp :: Integer -> Integer -> Int -> Integer
shiftBaseExp x b e | e < 0     = x `eucQuot` (b ^ negate e)
                   | otherwise = x * (b ^ e)

data E0

-- | Increment a resolution
data S n

-- | Add resolutions
type family a :+ b
type instance E0 :+ b = b
type instance S a :+ b = S (a :+ b)

-- | Subtract resolutions
type family a :- b
type instance a :- E0 = a
type instance S a :- S b = a :- b

-- | Decrement a resolution
type family P a
type instance P (S a) = a

type E1  = S E0
type E2  = E1 :+ E1
type E4  = E2 :+ E2
type E8  = E4 :+ E4
type E10 = S (S E8)
type E16 = E8 :+ E8
type E20 = E10 :+ E10
type E30 = E20 :+ E10
type E32 = E16 :+ E16
type E64 = E32 :+ E32

instance HasResolution n => HasResolution (S n) where
  {-# INLINE resolution #-}
  resolution = succ . resolution' undefined
    where resolution' :: (HasResolution n, Num a) =>
                         Fixed n a -> Fixed (S n) a -> Int
          {-# INLINE resolution' #-}
          resolution' dummy = const $ resolution dummy

instance HasResolution E0 where
  {-# INLINE resolution #-}
  resolution = const 0

-- | Instances of 'SuperTypeable' can be cast up to and down from a
-- supertype. If the type is bounded, the supertype must be able to
-- hold at least twice as much information to be a valid instance.
class SuperTypeable a where
  type Super a

  -- | Losslessly cast to a supertype.
  superCast :: a -> Super a

  -- | Cast to a subtype. Information may be lost.
  subCast :: Super a -> a

{-# RULES
"subCast . superCast" subCast . superCast = id
  #-}

instance (SuperTypeable a, Num a, Num (Super a), Integral a, Integral (Super a)) =>
         SuperTypeable (Fixed r a) where
  type Super (Fixed r a) = Fixed r (Super a)
  {-# INLINE superCast #-}
  superCast = fixedRadix
  {-# INLINE subCast #-}
  subCast = fixedRadix

instance SuperTypeable Word8 where
  type Super Word8 = Word16
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Word16 where
  type Super Word16 = Word32
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Word32 where
  type Super Word32 = Word64
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Word64 where
  type Super Word64 = Integer
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Word where
#ifdef i386_HOST_ARCH
  type Super Word = Word64
#else
  type Super Word = Integer
#endif
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Int8 where
  type Super Int8 = Int16
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Int16 where
  type Super Int16 = Int32
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Int32 where
  type Super Int32 = Int64
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Int64 where
  type Super Int64 = Integer
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Int where
#ifdef i386_HOST_ARCH
  type Super Int = Int64
#else
  type Super Int = Integer
#endif
  {-# INLINE superCast #-}
  superCast = fromIntegral
  {-# INLINE subCast #-}
  subCast = fromIntegral

instance SuperTypeable Integer where
  type Super Integer = Integer
  {-# INLINE superCast #-}
  superCast = id
  {-# INLINE subCast #-}
  subCast = id

eucQuot :: Integral a => a -> a -> a
{-# INLINE eucQuot #-}
a `eucQuot` b
  | a >= 0    = a `quot` b
  | b >  0    = ((a + 1) `quot` b) - 1
  | otherwise = ((a + 1) `quot` b) + 1
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE ViewPatterns #-}

{-|
This module defines a type for binary fixed-point arithmetic. The main
advantage this provides over decimal fixed-point arithmetic is that
the point is maintained using fast bit shifts instead of slow 'div'
operations. This type is also polymorphic on the underlying
representation, so you can use whatever size and signedness you
want.
-}
module Data.Fixed.Binary
       ( div'
       , mod'
       , divMod'
       , Fixed ()
       , SuperTypeable (..)
       , HasResolution (..)
       , E0, E1, E2, E4, E8, E10, E16, E20, E30, E32, E64
       , S, P
       , fixedRadix, fixedSize, fromRealFloat
       , (:+), (*.), (*!)
       , (:-), (/.), (/!)
       ) where

import Control.Applicative
import Control.Arrow
import Data.Bits
import Data.Fixed (div', mod', divMod')
import Data.Function
import Data.Int
import Data.List
import Data.Maybe
import Data.Ratio
import Data.Typeable
import Data.Word
import Text.Read
import qualified Text.Read.Lex as L

-- | The first type parameter represents the number of bits to devote
-- to the fractional part of the number. The second type parameter is
-- the underlying representation. For example, @Fixed E8 Int16@ uses
-- eight bits for the integer component (of which one bit is used for
-- the sign) and eight bits for the fractional component.
newtype Fixed r a = Fixed { unFixed :: a }
                  deriving (Bounded, Enum, Eq, Ord, Typeable)

inFixed :: (a -> b) -> (Fixed r a -> Fixed s b)
{-# INLINE inFixed #-}
inFixed = (Fixed .) . (. unFixed)

inFixed2 :: (a -> b -> c) -> (Fixed r a -> Fixed s b -> Fixed t c)
{-# INLINE inFixed2 #-}
inFixed2 = (inFixed .) . (. unFixed)

-- | Instances of this class are useful as the first parameter of
-- 'Fixed'.
class HasResolution r where
  -- | Given a fixed-point number, give the number of bits used to
  -- represent its fractional part.
  resolution :: Num a => Fixed r a -> Int

withResolution :: (HasResolution r, Num a) => (Int -> Fixed r a) -> Fixed r a
{-# INLINE withResolution #-}
withResolution f = withType (f . resolution)
  where withType :: (Fixed r a -> Fixed r a) -> Fixed r a
        withType g = g undefined

-- Read a signed number. Stolen from GHC.Read.
readNumber :: Num a => (L.Lexeme -> ReadPrec a) -> ReadPrec a
readNumber convert =
  parens
  ( do x <- lexP
       case x of
         L.Symbol "-" -> do y <- lexP
                            n <- convert y
                            return (negate n)

         _   -> convert x
  )

-- Stolen from GHC.Read.
convertFrac :: Fractional a => L.Lexeme -> ReadPrec a
convertFrac (L.Int i) = return (fromInteger i)
convertFrac (L.Rat r) = return (fromRational r)
convertFrac _         = pfail

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Read (Fixed r a) where
  readPrec = readNumber convertFrac

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Show (Fixed r a) where
  show (properFraction -> (i, f)) =
    show (i :: Integer) ++ "." ++ (uncurry pad . second (show . numerator) .
                                   fromJust . find ((==1) . denominator . snd) .
                                   iterate (succ *** (*10)) . (,) 0 $
                                   toRational f)
    where pad n str = replicate (n - length str) '0' ++ str

instance ( HasResolution r, Bits a, Bits (Super a), Integral a, Num (Super a)
         , Integral (Super a), SuperTypeable a) => Num (Fixed r a) where
  {-# INLINE (+) #-}
  (+) = inFixed2 (+)
  {-# INLINE (-) #-}
  (-) = inFixed2 (-)
  {-# INLINE (*) #-}
  (*) = fmap subCast . (*!) `on` superCast
  {-# INLINE negate #-}
  negate = inFixed negate
  {-# INLINE abs #-}
  abs = inFixed abs
  {-# INLINE signum #-}
  signum (Fixed x) = withResolution $ \s -> Fixed $ signum x `shiftL` s
  {-# INLINE fromInteger #-}
  fromInteger i = withResolution $ Fixed . shiftL (fromInteger i)

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Real (Fixed r a) where
  {-# INLINE toRational #-}
  toRational x = toRational (unFixed x) / toRational (2 ^ resolution x :: Integer)

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => Fractional (Fixed r a) where
  {-# INLINE (/) #-}
  (/) = fmap subCast . (/!) `on` superCast
  {-# INLINE recip #-}
  recip x = Fixed . subCast $ (1 `shiftL` (2 * resolution x)) `eucQuot` superCast (unFixed x)
  {-# INLINE fromRational #-}
  fromRational r = withResolution $ \s ->
    Fixed . floor $ (numerator r `shiftL` s) % denominator r

instance ( HasResolution r, Bits a, Bits (Super a), Integral a
         , Integral (Super a), SuperTypeable a) => RealFrac (Fixed r a) where
  {-# INLINE properFraction #-}
  properFraction a = let i = truncate a in (i, a - fromIntegral i)
  {-# INLINE truncate #-}
  truncate = truncate . toRational
  {-# INLINE round #-}
  round = round . toRational
  {-# INLINE ceiling #-}
  ceiling = ceiling . toRational
  {-# INLINE floor #-}
  floor = floor . toRational

-- | Fast conversion between fixed-point numbers with the same
-- fractional size.
fixedRadix :: (Integral a, Num b) => Fixed r a -> Fixed r b
{-# INLINE fixedRadix #-}
fixedRadix = inFixed fromIntegral

-- TODO Can't I write this as one awesome, polymorphic rule?
{-# RULES
"realToFrac/fixedRadixInt"     forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int
"realToFrac/fixedRadixInt8"    forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int8
"realToFrac/fixedRadixInt16"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int16
"realToFrac/fixedRadixInt32"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int32
"realToFrac/fixedRadixInt64"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Int64
"realToFrac/fixedRadixWord"    forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word
"realToFrac/fixedRadixWord8"   forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word8
"realToFrac/fixedRadixWord16"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word16
"realToFrac/fixedRadixWord32"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word32
"realToFrac/fixedRadixWord64"  forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Word64
"realToFrac/fixedRadixInteger" forall (x :: Integral a => Fixed r a). realToFrac x = fixedRadix x :: Fixed r Integer
  #-}

-- | Fast conversion between fixed-point numbers with the same
-- representation size.-- | Fast conversion between fixed-point numbers with the same
fixedSize-- representation size.:: (HasResolution r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
fixedSize{-# INLINE::fixedSizeHasResolution#-}    r, HasResolution s, Bits a) => Fixed r a -> Fixed s a
{-# INLINEfixedSize xfixedSize= withResolution#-}     $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
fixedSize-- TODO Rewrite rules? = withResolution $ \s -> Fixed $ unFixed x `shift` (s - resolution x)
-- TODO Rewrite rules?
-- | Multiplication without throwing away fractional information.
(-- | Multiplication without throwing away fractional information.*.) :: (Num (Super a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
({-# INLINE*.) :: (Num(*.Super) #-} a), SuperTypeable a) => Fixed r a -> Fixed s a -> Fixed (r :+ s) a
{-# INLINE(*.) = inFixed2*.) #-}((fmap subCast . (*)) `on` superCast)
(*.) = inFixed2 ((fmap subCast . (*)) `on` superCast)
-- | Division while removing unnecessary bits in the result's
-- fractional part.-- | Division while removing unnecessary bits in the result's
(-- fractional part./.) :: Integral a => Fixed r a -> Fixed s a -> Fixed (r :- s) a
({-# INLINE/.) :: Integral(/.) #-} => Fixed r a -> Fixed s a -> Fixed (r :- s) a
{-# INLINE(/.) = inFixed2/.) #-}eucQuot
(/.) = inFixed2 eucQuot
-- | Perform a multiplication without adding any extra bits for the
-- intermediate steps. This may be faster (especially when you are-- | Perform a multiplication without adding any extra bits for the
-- intermediate steps. This may be faster (especially when you are-- already working with native-sized integer data), but it's only safe
-- to use if you are sure that the multiplication won't-- already working with native-sized integer data), but it's only safe
-- to use if you are sure that the multiplication won't-- overflow. Normal multiplication is equivalent to @\x y -> subCast
-- (superCast x *!  superCast y)@.-- overflow. Normal multiplication is equivalent to @\x y -> subCast
(-- (superCast x *!  superCast y)@.*!) :: (HasResolution r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
({-# INLINE*!) :: (HasResolution(*!) #-}    r, Bits a, Num a) => Fixed r a -> Fixed r a -> Fixed r a
{-# INLINEFixed x *! (Fixed*!) #-}y = withResolution $ Fixed . shiftR (x * y)
Fixed x *! Fixed y = withResolution $ Fixed . shiftR (x * y)
-- | Perform a division without adding any extra bits for the
-- | Perform a division without adding any extra bits for the-- intermediate steps. This may be faster if supercasting brings it up
-- to a non-native size, but you need to be sure that the shifting-- intermediate steps. This may be faster if supercasting brings it up
-- before the division won't cause an overflow.-- to a non-native size, but you need to be sure that the shifting
(-- before the division won't cause an overflow./!) :: (HasResolution r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
({-# INLINE/!) :: (HasResolution(/!) #-}    r, Bits a, Integral a) => Fixed r a -> Fixed r a -> Fixed r a
{-# INLINEa /! b = Fixed/!)$#-}(unFixed a `shiftL` resolution a) `eucQuot` unFixed b
a /! b = Fixed $ (unFixed a `shiftL` resolution a) `eucQuot` unFixed b
-- TODO Don't assume it's a binary float so that we can actually
-- expose this function.-- TODO Don't assume it's a binary float so that we can actually
toRealFloat-- expose this function.:: (HasResolution r, Integral a, RealFloat b) => Fixed r a -> b
toRealFloat{-# INLINE toRealFloat:: (HasResolution#-}    r, Integral a, RealFloat b) => Fixed r a -> b
{-# INLINEtoRealFloattoRealFloat= liftA2 encodeFloat#-}       (fromIntegral . unFixed) (negate . resolution)
toRealFloat{-# SPECIALIZE= liftA2toRealFloat:: (HasResolutionfromIntegralr,.Integral)a(negate=> Fixed resolutionr a -> Float)   #-}
{-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> FloatDouble#-}#-}
{-# SPECIALIZE toRealFloat :: (HasResolution r, Integral a) => Fixed r a -> Double #-}
{-# RULES
{-# RULES"realToFrac/Float"  forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Float
"realToFrac/Float""realToFrac/Double" forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: FloatDouble
"realToFrac/Double"#-}               forall (x :: (HasResolution r, Integral a) => Fixed r a). realToFrac x = toRealFloat x :: Double
  #-}
-- | Fast conversion from floating-point to fixed-point.
fromRealFloat :: (RealFloat a, HasResolution r, Num b) => a -> Fixed r b
{-# INLINE-- | Fast conversion from floating-point to fixed-point.fromRealFloat #-}
fromRealFloat ::x =(RealFloatlet (s,e) a,decodeFloatx  r, Num b) => a -> Fixed r b
{-# INLINE fromRealFloatin withResolution#-}        $ \t -> Fixed . fromIntegral $ shiftBaseExp s (floatRadix x) (t + e)
fromRealFloat{-# SPECIALIZExfromRealFloat= let (s,e) =::(HasResolution    r, Num b) => Float -> Fixed r b #-}
            {-# SPECIALIZE fromRealFloatin withResolution:: (HasResolution \t -> Fixedr, .Numb) => Double shiftBaseExp-> Fixed r b s#-}floatRadix x) (t + e)
{-# SPECIALIZE-- TODO Rewrite rules? :: (HasResolution r, Num b) => Float -> Fixed r b #-}
{-# SPECIALIZE fromRealFloat :: (HasResolution r, Num b) => Double -> Fixed r b #-}
shiftBaseExp-- TODO Rewrite rules?:: Integer -> Integer -> Int -> Integer
shiftBaseExp x b e | e < 0     = x `eucQuot` (b ^ negate e)
shiftBaseExp :: Integer| otherwise-> Integer= x ->* (Intb ^ ->e) Integer
shiftBaseExp x b e | e < 0     = x `eucQuot` (b ^ negate e)
data E0            | otherwise = x * (b ^ e)

data-- | Increment a resolution
data S n
-- | Increment a resolution
data-- | Add resolutions n
type family a :+ b
type-- | Add resolutionsinstance E0 :+ b = b
type familyinstance :+S ab:+ b = S (a :+ b)
type instance E0 :+ b = b
type-- | Subtract resolutionsinstance S a :+ b = S (a :+ b)
type family a :- b
type-- | Subtract resolutionsinstance a :- E0 = a
type familyinstance :-S ab:- S b = a :- b
type instance a :- E0 = a
type-- | Decrement a resolutioninstance S a :- S b = a :- b
type family P a
type-- | Decrement a resolutioninstance P (S a) = a
type family P a
type instanceE1  = S E0 (S a) = a
type E2  = E1 :+ E1
type E1  = SE2E0:+ E2
type E2  = E1 :+ E1
type E4E10 = E2S (:+S E8)
type E8E16 = E4 :+ E4
type E10 = SE10S:+)E10
type E16 = E8E20:+:+E8E10
type E20 = E10 :+ E10
type E30 = E20 :+ E10
type E32 = E16 :+ E16
typeinstance =HasResolution :+ E32  n => HasResolution (S n) where
  {-# INLINE resolution #-}
instanceresolution= succ . resolution' => HasResolutionundefinedS n) where
  {-# INLINEwhere resolution'::#-}(HasResolution n, Num a) =>
  resolution = succ . resolution'Fixed n aundefined-> Fixed (S n) a -> Int
    where resolution'{-# INLINE resolution':: (HasResolution#-}    n, Num a) =>
          resolution' dummy= const a ->$ FixedresolutionS n)dummy -> Int
          {-# INLINE resolution' #-}
instance HasResolution dummyE0 where= const $ resolution dummy
  {-# INLINE resolution #-}
instanceresolution= const 0 E0 where
  {-# INLINE resolution #-}
-- | Instances of 'SuperTypeable' can be cast up to and down from a = const 0
-- supertype. If the type is bounded, the supertype must be able to
-- hold at least twice as much information to be a valid instance.-- | Instances of 'SuperTypeable' can be cast up to and down from a
class-- supertype. If the type is bounded, the supertype must be able toSuperTypeable a where
-- hold at least twice as much information to be a valid instance.type Super a
class SuperTypeable a where
  type-- | Losslessly cast to a supertype. a
  superCast :: a -> Super a
  -- | Losslessly cast to a supertype.
  superCast-- | Cast to a subtype. Information may be lost.:: a -> Super a
  subCast :: Super a -> a
  -- | Cast to a subtype. Information may be lost.
{-# RULES :: Super a -> a
"subCast . superCast" subCast . superCast = id
{-# RULES#-}
"subCast . superCast" subCast . superCast = id
instance#-}    (SuperTypeable a, Num a, Num (Super a), Integral a, Integral (Super a)) =>
         SuperTypeable (Fixed r a) where
  type Super (Fixed r a) = Fixed r (Super a)
instance{-# INLINESuperTypeablesuperCast #-}, Num a, Num (Super a), Integral a, Integral (Super a)) =>
  superCast= fixedRadixFixed r a) where
  type{-# INLINE (subCastFixed r#-}) = Fixed r (Super a)
  {-# INLINEsubCast = fixedRadix #-}
  superCast = fixedRadix
instance SuperTypeable #-}Word8 where
  subCasttype Super= fixedRadixWord8 = Word16
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Word8subCast= Word16#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Word16 where
  subCasttype Super= fromIntegralWord16 = Word32
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Word16subCast=#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Word32 where
  subCasttype Super= fromIntegralWord32 = Word64
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Word32subCast=#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Word64 where
  subCasttype Super= fromIntegralWord64 = Integer
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Word64subCast=#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Word where
#ifdef i386_HOST_ARCH = fromIntegral
  type Super Word = Word64
instance#else     SuperTypeable Word where
  type Super Word = Integer
#endif
  {-# INLINE superCast #-}
  typesuperCast=WordfromIntegral= Integer
  {-# INLINE subCast #-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Int8 where
  subCasttype Super= fromIntegralInt8 = Int16
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Int8subCast= Int16#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Int16 where
  subCasttype Super= fromIntegralInt16 = Int32
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Int16subCast= Int32#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Int32 where
  subCasttype Super= fromIntegralInt32 = Int64
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Int32subCast= Int64#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Int64 where
  subCasttype Super= fromIntegralInt64 = Integer
  {-# INLINE superCast #-}
instancesuperCast= fromIntegral where
  type{-# INLINE Int64subCast= Integer#-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Int where
#ifdef i386_HOST_ARCH = fromIntegral
  type Super Int = Int64
instance#else     SuperTypeable Int where
  type Super Int = Integer
#endif
  {-# INLINE superCast #-}
  typesuperCast=IntfromIntegral= Integer
  {-# INLINE subCast #-}
  {-# INLINEsubCast = fromIntegral #-}
  superCast = fromIntegral
instance SuperTypeable #-}Integer where
  subCasttype Super= fromIntegralInteger = Integer
  {-# INLINE superCast #-}
instancesuperCast= id       Integer where
  type{-# INLINE Integer =#-}
  {-# INLINEsubCast = id #-}
  superCast = id
eucQuot :: Integrala#-}=> a -> a -> a
{-# INLINE =eucQuot     #-}
a `eucQuot` b
eucQuot| a >=::0 Integral= a `quot =>` a -> a -> a
{-# INLINE| b >  0 eucQuot= ((a#-}+ 1) `quot` b) - 1
a `eucQuototherwise` b = ((a + 1) `quot` b) + 1

</pre>