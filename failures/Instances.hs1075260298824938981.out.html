<a href="Inject.hs1148079871137522503.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Instances.hs1290659378379847699.out.html">next</a></br></br><pre>8d7
< --  basic class instances for creating, reading, and writing standard
9d7
< --  reference types, and re-exports the types for which it defines instances.
10d7
< --
11d7
< --  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
12d7
< --  a minimum.
13d7
< module Data.StateRef.Instances
14d7
<     ( IORef
15c8
<     , MVar
---
> --  basic class instances for creating, reading, and writing standard-- |This module exports no new symbols of its own.  It defines several
15a9
> --  basic class instances for creating, reading, and writing standard--  reference types, and re-exports the types for which it defines instances.
15a10
> ----  reference types, and re-exports the types for which it defines instances.
15a11
> ----  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
15a12
> --  a minimum.--  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
15a13
> module--  a minimum.Data.StateRef.Instances
15a14
> module( IORefData.StateRef.Instances
15a15
>     ( IORefMVar
15a16
>     , MVarMonadIO(..)
17d17
< 
19c19
<     , ST
---
>     , STRefST
19a20
>     , STRealWorld
21d21
< 
23c23
< 
---
>     , ForeignPtr
29c29
< 
---
>     , module Data.StateRef.Instances.Undecidable
31c31
< 
---
>     ) where
36a37
> import Data.StateRef.TypesData.StateRef.Instances.Undecidable
38d38
< 
39a40
> import Data.IORefControl.Concurrent.MVar
41d41
< 
43c43
< import Control.Monad.ST
---
> import Control.Monad.TransControl.Monad.ST
43a44
> import Control.Monad.STData.STRef
45d45
< 
46a47
> import qualified Control.Monad.ST.LazyData.STRef.Lazy
48d48
< 
49a50
> import Foreign.StorableForeign.ForeignPtr
51d51
< 
53d52
< instance HasRef m => NewRef (Ref m a) m a where
54d52
<     newReference = newRef
55d52
< instance ReadRef (Ref m a) m a where
56d52
<     readReference (Ref sr) = readReference sr
57d52
< instance WriteRef (Ref m a) m a where
58d52
<     writeReference (Ref sr) = writeReference sr
59d52
< instance ModifyRef (Ref m a) m a where
60c53
<     atomicModifyReference (Ref sr) = atomicModifyReference sr
---
> instance-- @Ref m@ in @m@:HasRef m => NewRef (Ref m a) m a where
60a54
> instancenewReference m==>newRef (Ref m a) m a where
60a55
> instanceReadRef =Refm a) m a where
60a56
> instancereadReference (Ref(Refmsr) m areadReferencewhere       sr
60a57
> instanceWriteRef (Ref srm ))=mreadReferencea where      sr
60a58
> instancewriteReference (Ref(Refmsr) m awriteReferencewhere        sr
60a59
> instanceModifyRef (Ref srm ))=mwriteReferencea where       sr
60a60
> instanceatomicModifyReference (Ref m a)Ref asrwhere) = atomicModifyReference sr
60a61
>     atomicModifyReferencemodifyReference (Ref srRef) = srmodifyReference) = atomicModifyReferencesr          sr
62d62
< 
64d63
< -- (cannot have instance Monad m => ReadRef (m a) m a, because this activates
65d63
< -- functional dependencies that would overconstrain totally unrelated instances
66d63
< -- because of the possibility of the future addition of, e.g., instance Monad TMVar)
67d63
< instance Monad m => NewRef (IO a) m a where
68d63
<     newReference ro = return (return ro)
69c64
< instance MonadIO m => ReadRef (IO a) m a where
---
> -- m a in semi-arbitrary monad m-- (cannot have instance Monad m => ReadRef (m a) m a, because this activates
69a65
> -- (cannot have instance Monad m => ReadRef (m a) m a, because this activates-- functional dependencies that would overconstrain totally unrelated instances
69a66
> -- functional dependencies that would overconstrain totally unrelated instances-- because of the possibility of the future addition of, e.g., instance Monad TMVar)
69a67
> instance-- because of the possibility of the future addition of, e.g., instance Monad TMVar)Monad m => NewRef (IO a) m a where
69a68
> instancenewReference m => NewRef= returnIO(return) m arowhere)
69a69
> instanceMonadIO rom =>= returnReadRef(return(IO a) rom ) where
69a70
> instancereadReference m==>liftIO (IO a) m a where
71d71
< 
73d72
<     newReference ro = return (return ro)
74d72
< instance ReadRef (ST s a) (ST s) a where
75d72
<     readReference = id
76c73
< instance MonadIO m => ReadRef (ST RealWorld a) m a where
---
> instancenewReference m => NewRef= returnST(return a) mro)where
76a74
> instanceReadRef ro(ST=sreturna) (ST(returns) a where)
76a75
> instancereadReference (ST= id a) (ST s) a where
76a76
> instanceMonadIO m==>ReadRef (ST RealWorld a) m a where
76a77
> instancereadReference m==>liftIO. stToIOST RealWorld a) m a where
78d78
< 
80d79
< instance HasRef IO where
81d79
<     newRef x = do
82d79
<         sr <- newIORef x
83d79
<         return (Ref sr)
84d79
< instance MonadIO m => NewRef (IORef a) m a where
85d79
<     newReference = liftIO . newIORef
86d79
< instance MonadIO m => ReadRef (IORef a) m a where
87d79
<     readReference = liftIO . readIORef
88d79
< instance MonadIO m => WriteRef (IORef a) m a where
89d79
<     writeReference r = liftIO . writeIORef r
90d79
< instance MonadIO m => ModifyRef (IORef a) m a where
91c80
<     atomicModifyReference r = liftIO . atomicModifyIORef r
---
> instance-- IORef in IO-compatible monadsHasRef IO where
91a81
> instancenewRefx = do where
91a82
>     newRefsr x<-=newIORef      x
91a83
>         srreturn<- newIORef(Ref sr)x
91a84
> instancereturnMonadIORefm =>)NewRef (IORef a) m a where
91a85
> instancenewReference m =>liftIO. newIORefIORef a) m a where
91a86
> instanceMonadIO = liftIO=> ReadRef newIORef(IORef a) m a where
91a87
> instancereadReference m==>liftIO. readIORefIORef a) m a where
91a88
> instanceMonadIO m==>WriteRef readIORef(IORef a) m a where
91a89
> instancewriteReference m =>r =WriteRefliftIO .(IORefwriteIORef) m a where
91a90
> instanceMonadIO m r=>=ModifyRef . writeIORef(IORef a) mra where
91a91
> instanceatomicModifyReference m => ModifyRefr = liftIOIORef. aatomicModifyIORef) m a where      r
91a92
>     atomicModifyReferencemodifyReference r = liftIO = liftIO. modifyIORef atomicModifyIORefr           r
93d93
< 
95d94
< --   (maybe...)
96d94
< -- instance MonadIO m => NewRef (Ref IO a) m a where
97d94
< --         newReference (Ref sr) = liftIO (newIORef sr)
98d94
< -- instance MonadIO m => ReadRef (Ref IO a) m a where
99d94
< --         readReference (Ref sr) = liftIO (readIORef sr)
100d94
< -- instance MonadIO m => WriteRef (Ref IO a) m a where
101d94
< --         writeReference (Ref sr) = liftIO . writeIORef sr
102d94
< -- instance MonadIO m => ModifyRef (Ref IO a) m a where
103c95
< --         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
---
> --   (maybe...)-- @Ref IO@ in IO-compatible monads
103a96
> --   (maybe...)-- instance MonadIO m => NewRef (Ref IO a) m a where
103a97
> -- instance MonadIO m => NewRef (Ref IO a) m a where--         newReference (Ref sr) = liftIO (newIORef sr)
103a98
> -- instance MonadIO m => ReadRef (Ref IO a) m a where--         newReference (Ref sr) = liftIO (newIORef sr)
103a99
> -- instance MonadIO m => ReadRef (Ref IO a) m a where--         readReference (Ref sr) = liftIO (readIORef sr)
103a100
> -- instance MonadIO m => WriteRef (Ref IO a) m a where--         readReference (Ref sr) = liftIO (readIORef sr)
103a101
> -- instance MonadIO m => WriteRef (Ref IO a) m a where--         writeReference (Ref sr) = liftIO . writeIORef sr
103a102
> -- instance MonadIO m => ModifyRef (Ref IO a) m a where--         writeReference (Ref sr) = liftIO . writeIORef sr
103a103
> -- instance MonadIO m => ModifyRef (Ref IO a) m a where--         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
103a104
> --         modifyReference (Ref sr) = liftIO . modifyIORef sr--         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
105d105
< 
107d106
< instance HasRef (ST s) where
108d106
<     newRef x = do
109d106
<         sr <- newSTRef x
110d106
<         return (Ref sr)
111d106
< instance NewRef (STRef s a) (ST s) a where
112d106
<     newReference = newSTRef
113d106
< instance ReadRef (STRef s a) (ST s) a where
114d106
<     readReference = readSTRef
115d106
< instance WriteRef (STRef s a) (ST s) a where
116d106
<     writeReference = writeSTRef
117d106
< instance ModifyRef (STRef s a) (ST s) a where
118c107
<     atomicModifyReference   = defaultAtomicModifyReference
---
> instance-- (STRef s) in (ST s) monadHasRef (ST s) where
118a108
> instancenewRefx = doST s) where
118a109
>     newRefsr x<-=newSTRef      x
118a110
>         srreturn<- newSTRef(Ref sr)x
118a111
> instancereturnNewRef(Ref(STRef)s a) (ST s) a where
118a112
> instancenewReference (STRef= newSTRef a) (ST s) a where
118a113
> instanceReadRef =STRefs a) (ST s) a where
118a114
> instancereadReference (STRef= readSTRef a) (ST s) a where
118a115
> instanceWriteRef =STRefs a) (ST s) a where
118a116
> instancewriteReference (STRef= writeSTRef a) (ST s) a where
118a117
> instanceModifyRef =STRefs a) (ST s) a where
118a118
> instanceatomicModifyReference (STRef s a)defaultAtomicModifyReferenceST s) a where
118a119
>     atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
120d120
< 
122d121
< --  would overlap with (ST s) even though there's no instance MonadIO (ST a))
123d121
< instance NewRef (STRef RealWorld a) IO a where
124d121
<     newReference = stToIO . newReference
125d121
< instance ReadRef (STRef RealWorld a) IO a where
126d121
<     readReference = stToIO . readReference
127d121
< instance WriteRef (STRef RealWorld a) IO a where
128d121
<     writeReference r = stToIO . writeReference r
129d121
< instance ModifyRef (STRef RealWorld a) IO a where
130c122
<     modifyReference r       = stToIO . modifyReference r
---
> -- (STRef RealWorld) in IO monad (not MonadIO instances, because the m--  would overlap with (ST s) even though there's no instance MonadIO (ST a))
130a123
> instance--  would overlap with (ST s) even though there's no instance MonadIO (ST a))NewRef (STRef RealWorld a) IO a where
130a124
> instancenewReference (STRef= stToIO. newReference) IO a where
130a125
> instanceReadRef =STRefRealWorld newReferencea) IO a where
130a126
> instancereadReference (STRef= stToIO. readReference) IO a where
130a127
> instanceWriteRef =STRefRealWorld readReferencea) IO a where
130a128
> instancewriteReference (STRefr = stToIO. writeReference) IO a wherer
130a129
> instanceModifyRef rSTRef= stToIORealWorld writeReferencea) IO a where
130a130
> instancemodifyReference (STRefr     RealWorld= stToIOa) IOmodifyReference where      r
130a131
>     modifyReferenceatomicModifyReference     r = stToIO . modifyReferenceatomicModifyReference     r
132d132
< 
134d133
< instance HasRef (Control.Monad.ST.Lazy.ST s) where
135d133
<     newRef x = do
136d133
<         sr <- Data.STRef.Lazy.newSTRef x
137d133
<         return (Ref sr)
138d133
< instance NewRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
139d133
<     newReference = Data.STRef.Lazy.newSTRef
140d133
< instance ReadRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
141d133
<     readReference = Data.STRef.Lazy.readSTRef
142d133
< instance WriteRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
143d133
<     writeReference = Data.STRef.Lazy.writeSTRef
144d133
< instance ModifyRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
145c134
<     atomicModifyReference   = defaultAtomicModifyReference
---
> instance-- (STRef s) in lazy (ST s) monadHasRef (Control.Monad.ST.Lazy.ST s) where
145a135
> instancenewRefx = doControl.Monad.ST.Lazy.ST s) where
145a136
>     newRefsr x<-=Data.STRef.Lazy.newSTRef                      x
145a137
>         srreturn<- Data.STRef.Lazy.newSTRef(Ref sr)                x
145a138
> instancereturnNewRef(Ref(STRef)s a) (Control.Monad.ST.Lazy.ST s) a where
145a139
> instancenewReference (STRef= Data.STRef.Lazy.newSTRef a) (Control.Monad.ST.Lazy.ST s) a where
145a140
> instanceReadRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
145a141
> instancereadReference (STRef= Data.STRef.Lazy.readSTRef a) (Control.Monad.ST.Lazy.ST s) a where
145a142
> instanceWriteRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
145a143
> instancewriteReference (STRef= Data.STRef.Lazy.writeSTRef a) (Control.Monad.ST.Lazy.ST s) a where
145a144
> instanceModifyRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
145a145
> instanceatomicModifyReference (STRef s a)defaultAtomicModifyReferenceControl.Monad.ST.Lazy.ST s) a where
145a146
>     atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
147d147
< 
149d148
< instance MonadIO m => NewRef (MVar a) m (Maybe a) where
150c149
<     newReference Nothing = liftIO newEmptyMVar
---
> instance-- MVar in IO-compatible monads (constructable but not usable as a "normal" state ref)MonadIO m => NewRef (MVar a) m (Maybe a) where
150a150
> instancenewReference mNothing=> NewRef= liftIOMVarnewEmptyMVar) m (Maybe a) where
150a151
>     newReference Nothing(Just x)==liftIOliftIOnewEmptyMVar(newMVar x)
152d152
< 
154d153
< instance (Storable a, MonadIO m) => NewRef (ForeignPtr a) m a where
155d153
<     newReference val = liftIO $ do
156d153
<         ptr <- mallocForeignPtr
157d153
<         withForeignPtr ptr (\ptr -> poke ptr val)
158d153
<         return ptr
159d153
< instance (Storable a, MonadIO m) => ReadRef (ForeignPtr a) m a where
160d153
<     readReference ptr = liftIO (withForeignPtr ptr peek)
161d153
< instance (Storable a, MonadIO m) => WriteRef (ForeignPtr a) m a where
162d153
<     writeReference ptr val = liftIO (withForeignPtr ptr (\ptr -> poke ptr val))
163d153
< instance (Storable a, MonadIO m) => ModifyRef (ForeignPtr a) m a where
164c154
<     atomicModifyReference   = defaultAtomicModifyReference
---
> instance-- ForeignPtrs, Ptrs, etc., in IO-compatible monads(Storable a, MonadIO m) => NewRef (ForeignPtr a) m a where
164a155
> instancenewReferenceStorableval,=MonadIOliftIO m)do=> NewRef (ForeignPtr a) m a where
164a156
>     newReferenceptr <- mallocForeignPtr = liftIO $ do
164a157
>         ptrwithForeignPtr<- mallocForeignPtrptr (\ptr -> poke ptr val)
164a158
>         withForeignPtrreturn ptr     ptr (\ptr -> poke ptr val)
164a159
> instancereturn(Storable a, MonadIO m) => ReadRef (ForeignPtr a) m a where
164a160
> instancereadReferenceStorableptr, MonadIO= liftIOm)withForeignPtr=> ReadRef (ForeignPtrptr peek)a) m a where
164a161
> instance(Storableptra, =MonadIOm(withForeignPtr=> WriteRef (ForeignPtr peek) a) m a where
164a162
> instancewriteReferenceStorable aptr, MonadIOval = liftIO) => WriteRef(withForeignPtrForeignPtrptr (a)ptr a->wherepoke ptr val))
164a163
> instance(Storable ptra, MonadIO = liftIOm) => (ModifyRefwithForeignPtr(ForeignPtr (\ptra) m->a pokewhereptr val))
164a164
> instanceatomicModifyReferenceStorable a, MonadIO= mdefaultAtomicModifyReference) => ModifyRef (ForeignPtr a) m a where
164a165
>     atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
166d166
< 
167a168
> -- this is an instance I would like to make, but it opens-- a big can of worms... it requires incoherent instances, for one.
169d169
< -- perhaps I ought to give up the abstractness of 'sr' in the class
170d169
< -- definition; i don't know if that gets me anywhere though...
171d169
< --
172d169
< -- note that as long as only these instances exist, there is no
173d169
< -- actual overlap.  maybe it's not such a bad idea.  on the other
174d169
< -- hand, a corresponding instance for Reader would be nice too, and
175d169
< -- that would be a duplicate instance (because only the context would
176d169
< -- differ).
177c170
< --
---
> -- definition; i don't know if that gets me anywhere though...-- perhaps I ought to give up the abstractness of 'sr' in the class
177a171
> ---- definition; i don't know if that gets me anywhere though...
177a172
> ---- note that as long as only these instances exist, there is no
177a173
> -- note that as long as only these instances exist, there is no-- actual overlap.  maybe it's not such a bad idea.  on the other
177a174
> -- actual overlap.  maybe it's not such a bad idea.  on the other-- hand, a corresponding instance for Reader would be nice too, and
177a175
> -- hand, a corresponding instance for Reader would be nice too, and-- that would be a duplicate instance (because only the context would
177a176
> -- differ).-- that would be a duplicate instance (because only the context would
177a177
> ---- differ).
177a178
> ---- instance (MonadState s1 m,
179d179
< --           StateRef s2 m a)
180d179
< --                 => StateRef (s1 -> s2) m a
181d179
< --         where
182d179
< --                 readReference f       = do
183d179
< --                         s1 <- get
184d179
< --                         readReference (f s1)
185d179
< --                 writeReference f val  = do
186d179
< --                         s1 <- get
187d179
< --                         writeReference (f s1) val
188d179
< --                 modifyReference f g = do
189d179
< --                         s1 <- get
190c180
< --                         modifyReference (f s1) g
---
> --           StateRef s2 m a)--                 => StateRef (s1 -> s2) m a
190a181
> --         where--                 => StateRef (s1 -> s2) m a
190a182
> --         where--                 readReference f       = do
190a183
> --                         s1 <- get--                 readReference f       = do
190a184
> --                         s1 <- get--                         readReference (f s1)
190a185
> --                 writeReference f val  = do--                         readReference (f s1)
190a186
> --                         s1 <- get--                 writeReference f val  = do
190a187
> --                         s1 <- get--                         writeReference (f s1) val
190a188
> --                 modifyReference f g = do--                         writeReference (f s1) val
190a189
> --                         s1 <- get--                 modifyReference f g = do
190a190
> --                         s1 <- get--                         modifyReference (f s1) g
190a191
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
        CPP,
        MultiParamTypeClasses,
        FlexibleInstances
  #-}

-- |This module exports no new symbols of its own.  It defines several
--  basic class instances for creating, reading, and writing standard
--  reference types, and re-exports the types for which it defines instances.
--
--  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
--  a minimum.
module Data.StateRef.Instances
    ( IORef
    , MVar
    , MonadIO(..)

    , STRef
    , ST
    , RealWorld

    , ForeignPtr

#ifdef useSTM
    , module Data.StateRef.Instances.STM
#endif

    , module Data.StateRef.Instances.Undecidable

    ) where

#ifdef useSTM
import Data.StateRef.Instances.STM
#endif

import Data.StateRef.Types
import Data.StateRef.Instances.Undecidable

import Data.IORef
import Control.Concurrent.MVar

import Control.Monad.Trans
import Control.Monad.ST
import Data.STRef

import qualified Control.Monad.ST.Lazy
import qualified Data.STRef.Lazy

import Foreign.Storable
import Foreign.ForeignPtr

-- @Ref m@ in @m@:
instance HasRef m => NewRef (Ref m a) m a where
    newReference = newRef
instance ReadRef (Ref m a) m a where
    readReference (Ref sr) = readReference sr
instance WriteRef (Ref m a) m a where
    writeReference (Ref sr) = writeReference sr
instance ModifyRef (Ref m a) m a where
    atomicModifyReference (Ref sr) = atomicModifyReference sr
    modifyReference (Ref sr) = modifyReference sr

-- m a in semi-arbitrary monad m
-- (cannot have instance Monad m => ReadRef (m a) m a, because this activates
-- functional dependencies that would overconstrain totally unrelated instances
-- because of the possibility of the future addition of, e.g., instance Monad TMVar)
instance Monad m => NewRef (IO a) m a where
    newReference ro = return (return ro)
instance MonadIO m => ReadRef (IO a) m a where
    readReference = liftIO

instance Monad m => NewRef (ST s a) m a where
    newReference ro = return (return ro)
instance ReadRef (ST s a) (ST s) a where
    readReference = id
instance MonadIO m => ReadRef (ST RealWorld a) m a where
    readReference = liftIO . stToIO

-- IORef in IO-compatible monads
instance HasRef IO where
    newRef x = do
        sr <- newIORef x
        return (Ref sr)
instance MonadIO m => NewRef (IORef a) m a where
    newReference = liftIO . newIORef
instance MonadIO m => ReadRef (IORef a) m a where
    readReference = liftIO . readIORef
instance MonadIO m => WriteRef (IORef a) m a where
    writeReference r = liftIO . writeIORef r
instance MonadIO m => ModifyRef (IORef a) m a where
    atomicModifyReference r = liftIO . atomicModifyIORef r
    modifyReference r = liftIO . modifyIORef r

-- @Ref IO@ in IO-compatible monads
--   (maybe...)
-- instance MonadIO m => NewRef (Ref IO a) m a where
--         newReference (Ref sr) = liftIO (newIORef sr)
-- instance MonadIO m => ReadRef (Ref IO a) m a where
--         readReference (Ref sr) = liftIO (readIORef sr)
-- instance MonadIO m => WriteRef (Ref IO a) m a where
--         writeReference (Ref sr) = liftIO . writeIORef sr
-- instance MonadIO m => ModifyRef (Ref IO a) m a where
--         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
--         modifyReference (Ref sr) = liftIO . modifyIORef sr

-- (STRef s) in (ST s) monad
instance HasRef (ST s) where
    newRef x = do
        sr <- newSTRef x
        return (Ref sr)
instance NewRef (STRef s a) (ST s) a where
    newReference = newSTRef
instance ReadRef (STRef s a) (ST s) a where
    readReference = readSTRef
instance WriteRef (STRef s a) (ST s) a where
    writeReference = writeSTRef
instance ModifyRef (STRef s a) (ST s) a where
    atomicModifyReference   = defaultAtomicModifyReference
    modifyReference         = defaultModifyReference

-- (STRef RealWorld) in IO monad (not MonadIO instances, because the m
--  would overlap with (ST s) even though there's no instance MonadIO (ST a))
instance NewRef (STRef RealWorld a) IO a where
    newReference = stToIO . newReference
instance ReadRef (STRef RealWorld a) IO a where
    readReference = stToIO . readReference
instance WriteRef (STRef RealWorld a) IO a where
    writeReference r = stToIO . writeReference r
instance ModifyRef (STRef RealWorld a) IO a where
    modifyReference r       = stToIO . modifyReference r
    atomicModifyReference r = stToIO . atomicModifyReference r

-- (STRef s) in lazy (ST s) monad
instance HasRef (Control.Monad.ST.Lazy.ST s) where
    newRef x = do
        sr <- Data.STRef.Lazy.newSTRef x
        return (Ref sr)
instance NewRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
    newReference = Data.STRef.Lazy.newSTRef
instance ReadRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
    readReference = Data.STRef.Lazy.readSTRef
instance WriteRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
    writeReference = Data.STRef.Lazy.writeSTRef
instance ModifyRef (STRef s a) (Control.Monad.ST.Lazy.ST s) a where
    atomicModifyReference   = defaultAtomicModifyReference
    modifyReference         = defaultModifyReference

-- MVar in IO-compatible monads (constructable but not usable as a "normal" state ref)
instance MonadIO m => NewRef (MVar a) m (Maybe a) where
    newReference Nothing = liftIO newEmptyMVar
    newReference (Just x) = liftIO (newMVar x)

-- ForeignPtrs, Ptrs, etc., in IO-compatible monads
instance (Storable a, MonadIO m) => NewRef (ForeignPtr a) m a where
    newReference val = liftIO $ do
        ptr <- mallocForeignPtr
        withForeignPtr ptr (\ptr -> poke ptr val)
        return ptr
instance (Storable a, MonadIO m) => ReadRef (ForeignPtr a) m a where
    readReference ptr = liftIO (withForeignPtr ptr peek)
instance (Storable a, MonadIO m) => WriteRef (ForeignPtr a) m a where
    writeReference ptr val = liftIO (withForeignPtr ptr (\ptr -> poke ptr val))
instance (Storable a, MonadIO m) => ModifyRef (ForeignPtr a) m a where
    atomicModifyReference   = defaultAtomicModifyReference
    modifyReference         = defaultModifyReference

-- this is an instance I would like to make, but it opens
-- a big can of worms... it requires incoherent instances, for one.
-- perhaps I ought to give up the abstractness of 'sr' in the class
-- definition; i don't know if that gets me anywhere though...
--
-- note that as long as only these instances exist, there is no
-- actual overlap.  maybe it's not such a bad idea.  on the other
-- hand, a corresponding instance for Reader would be nice too, and
-- that would be a duplicate instance (because only the context would
-- differ).
--
-- instance (MonadState s1 m,
--           StateRef s2 m a)
--                 => StateRef (s1 -> s2) m a
--         where
--                 readReference f       = do
--                         s1 <- get
--                         readReference (f s1)
--                 writeReference f val  = do
--                         s1 <- get
--                         writeReference (f s1) val
--                 modifyReference f g = do
--                         s1 <- get
--                         modifyReference (f s1) g
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
        CPP,
        MultiParamTypeClasses,
        FlexibleInstances
  #-}

-- |This module exports no new symbols of its own.  It defines several
--  basic class instances for creating, reading, and writing standard-- |This module exports no new symbols of its own.  It defines several
--  basic class instances for creating, reading, and writing standard--  reference types, and re-exports the types for which it defines instances.
----  reference types, and re-exports the types for which it defines instances.
----  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
--  a minimum.--  TODO: add millions of SPECIALIZE INSTANCE pragmas, for IO monad at
module--  a minimum.Data.StateRef.Instances
module( IORefData.StateRef.Instances
    ( IORefMVar
    , MVarMonadIO(..)
    , MonadIO(..)
    , STRef
    , STRefST
    , STRealWorld
    , RealWorld
    , ForeignPtr
    , ForeignPtr
#ifdef useSTM
    , module Data.StateRef.Instances.STM
#endif

    , module Data.StateRef.Instances.Undecidable
    , module Data.StateRef.Instances.Undecidable
    ) where
    ) where
#ifdef useSTM
import Data.StateRef.Instances.STM
#endif

import Data.StateRef.Types
import Data.StateRef.TypesData.StateRef.Instances.Undecidable
import Data.StateRef.Instances.Undecidable
import Data.IORef
import Data.IORefControl.Concurrent.MVar
import Control.Concurrent.MVar
import Control.Monad.Trans
import Control.Monad.TransControl.Monad.ST
import Control.Monad.STData.STRef
import Data.STRef
import qualified Control.Monad.ST.Lazy
import qualified Control.Monad.ST.LazyData.STRef.Lazy
import qualified Data.STRef.Lazy
import Foreign.Storable
import Foreign.StorableForeign.ForeignPtr
import Foreign.ForeignPtr
-- @Ref m@ in @m@:
instance-- @Ref m@ in @m@:HasRef m => NewRef (Ref m a) m a where
instancenewReference m==>newRef (Ref m a) m a where
instanceReadRef =Refm a) m a where
instancereadReference (Ref(Refmsr) m areadReferencewhere       sr
instanceWriteRef (Ref srm ))=mreadReferencea where      sr
instancewriteReference (Ref(Refmsr) m awriteReferencewhere        sr
instanceModifyRef (Ref srm ))=mwriteReferencea where       sr
instanceatomicModifyReference (Ref m a)Ref asrwhere) = atomicModifyReference sr
    atomicModifyReferencemodifyReference (Ref srRef) = srmodifyReference) = atomicModifyReferencesr          sr
    modifyReference (Ref sr) = modifyReference sr
-- m a in semi-arbitrary monad m
-- m a in semi-arbitrary monad m-- (cannot have instance Monad m => ReadRef (m a) m a, because this activates
-- (cannot have instance Monad m => ReadRef (m a) m a, because this activates-- functional dependencies that would overconstrain totally unrelated instances
-- functional dependencies that would overconstrain totally unrelated instances-- because of the possibility of the future addition of, e.g., instance Monad TMVar)
instance-- because of the possibility of the future addition of, e.g., instance Monad TMVar)Monad m => NewRef (IO a) m a where
instancenewReference m => NewRef= returnIO(return) m arowhere)
instanceMonadIO rom =>= returnReadRef(return(IO a) rom ) where
instancereadReference m==>liftIO (IO a) m a where
    readReference = liftIO
instance Monad m => NewRef (ST s a) m a where
instancenewReference m => NewRef= returnST(return a) mro)where
instanceReadRef ro(ST=sreturna) (ST(returns) a where)
instancereadReference (ST= id a) (ST s) a where
instanceMonadIO m==>ReadRef (ST RealWorld a) m a where
instancereadReference m==>liftIO. stToIOST RealWorld a) m a where
    readReference = liftIO . stToIO
-- IORef in IO-compatible monads
instance-- IORef in IO-compatible monadsHasRef IO where
instancenewRefx = do where
    newRefsr x<-=newIORef      x
        srreturn<- newIORef(Ref sr)x
instancereturnMonadIORefm =>)NewRef (IORef a) m a where
instancenewReference m =>liftIO. newIORefIORef a) m a where
instanceMonadIO = liftIO=> ReadRef newIORef(IORef a) m a where
instancereadReference m==>liftIO. readIORefIORef a) m a where
instanceMonadIO m==>WriteRef readIORef(IORef a) m a where
instancewriteReference m =>r =WriteRefliftIO .(IORefwriteIORef) m a where
instanceMonadIO m r=>=ModifyRef . writeIORef(IORef a) mra where
instanceatomicModifyReference m => ModifyRefr = liftIOIORef. aatomicModifyIORef) m a where      r
    atomicModifyReferencemodifyReference r = liftIO = liftIO. modifyIORef atomicModifyIORefr           r
    modifyReference r = liftIO . modifyIORef r
-- @Ref IO@ in IO-compatible monads
--   (maybe...)-- @Ref IO@ in IO-compatible monads
--   (maybe...)-- instance MonadIO m => NewRef (Ref IO a) m a where
-- instance MonadIO m => NewRef (Ref IO a) m a where--         newReference (Ref sr) = liftIO (newIORef sr)
-- instance MonadIO m => ReadRef (Ref IO a) m a where--         newReference (Ref sr) = liftIO (newIORef sr)
-- instance MonadIO m => ReadRef (Ref IO a) m a where--         readReference (Ref sr) = liftIO (readIORef sr)
-- instance MonadIO m => WriteRef (Ref IO a) m a where--         readReference (Ref sr) = liftIO (readIORef sr)
-- instance MonadIO m => WriteRef (Ref IO a) m a where--         writeReference (Ref sr) = liftIO . writeIORef sr
-- instance MonadIO m => ModifyRef (Ref IO a) m a where--         writeReference (Ref sr) = liftIO . writeIORef sr
-- instance MonadIO m => ModifyRef (Ref IO a) m a where--         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
--         modifyReference (Ref sr) = liftIO . modifyIORef sr--         atomicModifyReference (Ref sr) = liftIO . atomicModifyIORef sr
--         modifyReference (Ref sr) = liftIO . modifyIORef sr
-- (STRef s) in (ST s) monad
instance-- (STRef s) in (ST s) monadHasRef (ST s) where
instancenewRefx = doST s) where
    newRefsr x<-=newSTRef      x
        srreturn<- newSTRef(Ref sr)x
instancereturnNewRef(Ref(STRef)s a) (ST s) a where
instancenewReference (STRef= newSTRef a) (ST s) a where
instanceReadRef =STRefs a) (ST s) a where
instancereadReference (STRef= readSTRef a) (ST s) a where
instanceWriteRef =STRefs a) (ST s) a where
instancewriteReference (STRef= writeSTRef a) (ST s) a where
instanceModifyRef =STRefs a) (ST s) a where
instanceatomicModifyReference (STRef s a)defaultAtomicModifyReferenceST s) a where
    atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
    modifyReference         = defaultModifyReference
-- (STRef RealWorld) in IO monad (not MonadIO instances, because the m
-- (STRef RealWorld) in IO monad (not MonadIO instances, because the m--  would overlap with (ST s) even though there's no instance MonadIO (ST a))
instance--  would overlap with (ST s) even though there's no instance MonadIO (ST a))NewRef (STRef RealWorld a) IO a where
instancenewReference (STRef= stToIO. newReference) IO a where
instanceReadRef =STRefRealWorld newReferencea) IO a where
instancereadReference (STRef= stToIO. readReference) IO a where
instanceWriteRef =STRefRealWorld readReferencea) IO a where
instancewriteReference (STRefr = stToIO. writeReference) IO a wherer
instanceModifyRef rSTRef= stToIORealWorld writeReferencea) IO a where
instancemodifyReference (STRefr     RealWorld= stToIOa) IOmodifyReference where      r
    modifyReferenceatomicModifyReference     r = stToIO . modifyReferenceatomicModifyReference     r
    atomicModifyReference r = stToIO . atomicModifyReference r
-- (STRef s) in lazy (ST s) monad
instance-- (STRef s) in lazy (ST s) monadHasRef (Control.Monad.ST.Lazy.ST s) where
instancenewRefx = doControl.Monad.ST.Lazy.ST s) where
    newRefsr x<-=Data.STRef.Lazy.newSTRef                      x
        srreturn<- Data.STRef.Lazy.newSTRef(Ref sr)                x
instancereturnNewRef(Ref(STRef)s a) (Control.Monad.ST.Lazy.ST s) a where
instancenewReference (STRef= Data.STRef.Lazy.newSTRef a) (Control.Monad.ST.Lazy.ST s) a where
instanceReadRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
instancereadReference (STRef= Data.STRef.Lazy.readSTRef a) (Control.Monad.ST.Lazy.ST s) a where
instanceWriteRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
instancewriteReference (STRef= Data.STRef.Lazy.writeSTRef a) (Control.Monad.ST.Lazy.ST s) a where
instanceModifyRef =STRefs a) (Control.Monad.ST.Lazy.ST s) a where
instanceatomicModifyReference (STRef s a)defaultAtomicModifyReferenceControl.Monad.ST.Lazy.ST s) a where
    atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
    modifyReference         = defaultModifyReference
-- MVar in IO-compatible monads (constructable but not usable as a "normal" state ref)
instance-- MVar in IO-compatible monads (constructable but not usable as a "normal" state ref)MonadIO m => NewRef (MVar a) m (Maybe a) where
instancenewReference mNothing=> NewRef= liftIOMVarnewEmptyMVar) m (Maybe a) where
    newReference Nothing(Just x)==liftIOliftIOnewEmptyMVar(newMVar x)
    newReference (Just x) = liftIO (newMVar x)
-- ForeignPtrs, Ptrs, etc., in IO-compatible monads
instance-- ForeignPtrs, Ptrs, etc., in IO-compatible monads(Storable a, MonadIO m) => NewRef (ForeignPtr a) m a where
instancenewReferenceStorableval,=MonadIOliftIO m)do=> NewRef (ForeignPtr a) m a where
    newReferenceptr <- mallocForeignPtr = liftIO $ do
        ptrwithForeignPtr<- mallocForeignPtrptr (\ptr -> poke ptr val)
        withForeignPtrreturn ptr     ptr (\ptr -> poke ptr val)
instancereturn(Storable a, MonadIO m) => ReadRef (ForeignPtr a) m a where
instancereadReferenceStorableptr, MonadIO= liftIOm)withForeignPtr=> ReadRef (ForeignPtrptr peek)a) m a where
instance(Storableptra, =MonadIOm(withForeignPtr=> WriteRef (ForeignPtr peek) a) m a where
instancewriteReferenceStorable aptr, MonadIOval = liftIO) => WriteRef(withForeignPtrForeignPtrptr (a)ptr a->wherepoke ptr val))
instance(Storable ptra, MonadIO = liftIOm) => (ModifyRefwithForeignPtr(ForeignPtr (\ptra) m->a pokewhereptr val))
instanceatomicModifyReferenceStorable a, MonadIO= mdefaultAtomicModifyReference) => ModifyRef (ForeignPtr a) m a where
    atomicModifyReferencemodifyReference         = defaultAtomicModifyReferencedefaultModifyReference
    modifyReference         = defaultModifyReference
-- this is an instance I would like to make, but it opens
-- this is an instance I would like to make, but it opens-- a big can of worms... it requires incoherent instances, for one.
-- a big can of worms... it requires incoherent instances, for one.
-- definition; i don't know if that gets me anywhere though...-- perhaps I ought to give up the abstractness of 'sr' in the class
---- definition; i don't know if that gets me anywhere though...
---- note that as long as only these instances exist, there is no
-- note that as long as only these instances exist, there is no-- actual overlap.  maybe it's not such a bad idea.  on the other
-- actual overlap.  maybe it's not such a bad idea.  on the other-- hand, a corresponding instance for Reader would be nice too, and
-- hand, a corresponding instance for Reader would be nice too, and-- that would be a duplicate instance (because only the context would
-- differ).-- that would be a duplicate instance (because only the context would
---- differ).
---- instance (MonadState s1 m,
-- instance (MonadState s1 m,
--           StateRef s2 m a)--                 => StateRef (s1 -> s2) m a
--         where--                 => StateRef (s1 -> s2) m a
--         where--                 readReference f       = do
--                         s1 <- get--                 readReference f       = do
--                         s1 <- get--                         readReference (f s1)
--                 writeReference f val  = do--                         readReference (f s1)
--                         s1 <- get--                 writeReference f val  = do
--                         s1 <- get--                         writeReference (f s1) val
--                 modifyReference f g = do--                         writeReference (f s1) val
--                         s1 <- get--                 modifyReference f g = do
--                         s1 <- get--                         modifyReference (f s1) g

</pre>