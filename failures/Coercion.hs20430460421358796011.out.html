<a href="CodeSyntax.hs1623161625992663534.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Combinators.hs9434546791771024152.out.html">next</a></br></br><pre>19c19
< {-# LINE 41 "src/ehc/Core/Coercion.chs" #-}
---
> 
19a20
> 
19a21
> 
19a22
> 
19a23
> 
19a24
> 
19a25
> 
19a26
> 
19a27
> 
19a28
> 
19a29
> 
19a30
> 
19a31
> 
19a32
> 
19a33
> 
19a34
> 
19a35
> 
19a36
> 
19a37
> 
19a38
> 
19a39
> 
19a40
> 
22c43
< {-# LINE 53 "src/ehc/Core/Coercion.chs" #-}
---
> 
22a44
> 
22a45
> 
22a46
> 
22a47
> 
22a48
> 
22a49
> 
22a50
> 
22a51
> 
22a52
> 
32c62
< {-# LINE 64 "src/ehc/Core/Coercion.chs" #-}
---
> 
32a63
> 
43c74
< {-# LINE 76 "src/ehc/Core/Coercion.chs" #-}
---
> 
43a75
> 
47c79
< {-# LINE 81 "src/ehc/Core/Coercion.chs" #-}
---
> 
47a80
> 
54c87
< {-# LINE 89 "src/ehc/Core/Coercion.chs" #-}
---
> 
54a88
> 
58c92
< {-# LINE 94 "src/ehc/Core/Coercion.chs" #-}
---
> 
58a93
> 
71c106
< {-# LINE 108 "src/ehc/Core/Coercion.chs" #-}
---
> 
71a107
> 
74a111
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Core.Coercion
( Coe, Coe' (..)
, LRCoeKind (..), lrcoeKindOfCoe
, LRCoe (..), emptyLRCoe
, lrcoeIsId
, mkLRCoe
, mkIdLRCoeWith
, lrcoeLSingleton, lrcoeRSingleton, lrcoeLFromList, lrcoeRFromList
, lrcoeUnion )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.AbstractCore
import qualified Data.Map as Map
import qualified Data.Set as Set

{-# LINE 41 "src/ehc/Core/Coercion.chs" #-}
type Coe = Coe' CExpr CMetaVal CBind CBound CTy

{-# LINE 53 "src/ehc/Core/Coercion.chs" #-}
data LRCoeKind = LRCoeId | LRCoeOther deriving Eq

lrcoeKindAnd :: LRCoeKind -> LRCoeKind -> LRCoeKind
lrcoeKindAnd LRCoeId LRCoeId = LRCoeId
lrcoeKindAnd _       _       = LRCoeOther

lrcoeKindOfCoe :: Coe -> LRCoeKind
lrcoeKindOfCoe c = if acoreCoeIsId c then LRCoeId else LRCoeOther

{-# LINE 64 "src/ehc/Core/Coercion.chs" #-}
data LRCoe
  = LRCoe
      { lrcoeKind       :: LRCoeKind
      , lrcoeLeftL      :: [Coe]
      , lrcoeRightL     :: [Coe]
      }

emptyLRCoe :: LRCoe
emptyLRCoe = LRCoe LRCoeId [] []

{-# LINE 76 "src/ehc/Core/Coercion.chs" #-}
lrcoeIsId :: LRCoe -> Bool
lrcoeIsId c = lrcoeKind c == LRCoeId

{-# LINE 81 "src/ehc/Core/Coercion.chs" #-}
mkLRCoe :: Coe -> Coe -> LRCoe
mkLRCoe l r = LRCoe LRCoeOther [l] [r]

mkIdLRCoe' :: Coe -> Coe -> LRCoe
mkIdLRCoe' l r = LRCoe LRCoeId [l] [r]

{-# LINE 89 "src/ehc/Core/Coercion.chs" #-}
mkIdLRCoeWith :: HsName -> CMetaVal -> LRCoe
mkIdLRCoeWith n m = mkIdLRCoe' (acoreCoeAppN [(acoreVar n)]) (acoreCoeLam1 n)

{-# LINE 94 "src/ehc/Core/Coercion.chs" #-}
lrcoeLFromList :: [Coe] -> LRCoe
lrcoeLFromList c = LRCoe LRCoeOther c []

lrcoeRFromList :: [Coe] -> LRCoe
lrcoeRFromList c = LRCoe LRCoeOther [] c

lrcoeLSingleton :: Coe -> LRCoe
lrcoeLSingleton c = LRCoe (lrcoeKindOfCoe c) [c] []

lrcoeRSingleton :: Coe -> LRCoe
lrcoeRSingleton c = LRCoe (lrcoeKindOfCoe c) [] [c]

{-# LINE 108 "src/ehc/Core/Coercion.chs" #-}
lrcoeUnion :: LRCoe -> LRCoe -> LRCoe
lrcoeUnion (LRCoe k1 l1 r1) (LRCoe k2 l2 r2) = LRCoe (lrcoeKindAnd k1 k2) (l1 ++ l2) (r1 ++ r2)

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Core.Coercion
( Coe, Coe' (..)
, LRCoeKind (..), lrcoeKindOfCoe
, LRCoe (..), emptyLRCoe
, lrcoeIsId
, mkLRCoe
, mkIdLRCoeWith
, lrcoeLSingleton, lrcoeRSingleton, lrcoeLFromList, lrcoeRFromList
, lrcoeUnion )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.AbstractCore
import qualified Data.Map as Map
import qualified Data.Set as Set























type Coe = Coe' CExpr CMetaVal CBind CBound CTy











data LRCoeKind = LRCoeId | LRCoeOther deriving Eq

lrcoeKindAnd :: LRCoeKind -> LRCoeKind -> LRCoeKind
lrcoeKindAnd LRCoeId LRCoeId = LRCoeId
lrcoeKindAnd _       _       = LRCoeOther

lrcoeKindOfCoe :: Coe -> LRCoeKind
lrcoeKindOfCoe c = if acoreCoeIsId c then LRCoeId else LRCoeOther



data LRCoe
  = LRCoe
      { lrcoeKind       :: LRCoeKind
      , lrcoeLeftL      :: [Coe]
      , lrcoeRightL     :: [Coe]
      }

emptyLRCoe :: LRCoe
emptyLRCoe = LRCoe LRCoeId [] []



lrcoeIsId :: LRCoe -> Bool
lrcoeIsId c = lrcoeKind c == LRCoeId



mkLRCoe :: Coe -> Coe -> LRCoe
mkLRCoe l r = LRCoe LRCoeOther [l] [r]

mkIdLRCoe' :: Coe -> Coe -> LRCoe
mkIdLRCoe' l r = LRCoe LRCoeId [l] [r]



mkIdLRCoeWith :: HsName -> CMetaVal -> LRCoe
mkIdLRCoeWith n m = mkIdLRCoe' (acoreCoeAppN [(acoreVar n)]) (acoreCoeLam1 n)



lrcoeLFromList :: [Coe] -> LRCoe
lrcoeLFromList c = LRCoe LRCoeOther c []

lrcoeRFromList :: [Coe] -> LRCoe
lrcoeRFromList c = LRCoe LRCoeOther [] c

lrcoeLSingleton :: Coe -> LRCoe
lrcoeLSingleton c = LRCoe (lrcoeKindOfCoe c) [c] []

lrcoeRSingleton :: Coe -> LRCoe
lrcoeRSingleton c = LRCoe (lrcoeKindOfCoe c) [] [c]



lrcoeUnion :: LRCoe -> LRCoe -> LRCoe
lrcoeUnion (LRCoe k1 l1 r1) (LRCoe k2 l2 r2) = LRCoe (lrcoeKindAnd k1 k2) (l1 ++ l2) (r1 ++ r2)


</pre>