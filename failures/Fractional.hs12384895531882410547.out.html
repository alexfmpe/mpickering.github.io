<a href="Fraction.hs8235644401115438165.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Fractional.hs174076737834991545.out.html">next</a></br></br><pre>47c47
< optSlash ∷ (Monad μ, CharParsing μ) ⇒ μ Optional
---
> optSlash :: (Monad μ, CharParsing μ) => μ Optional
52d51
< fraction' ∷ (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
53d51
<           ⇒ μ Sign -- ^ Sign parser
54d51
<           → s
55d51
<           → μ Optional -- ^ Numerator/denominator separator parser
56c52
<           → μ α
---
> fraction' :: (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
56a53
>           => μ Sign -- ^ Sign parser
56a54
>           -> s
56a55
>           -> μ Optional -- ^ Numerator/denominator separator parser
56a56
>           -> μ α
58d57
<   n ← number' neg s <?> "numerator"
59d57
<   den >>= \case
60c58
<     Optional →
---
>   n <- number' neg s <?> "numerator"
60a59
>   den >>= 
60a60
>     Optional ->
62d61
<     Required → do
63d61
<       d ← (<?> "denominator") $ do
64c62
<         d ← nonNegative s
---
>     Required -> do
64a63
>       d <- (<?> "denominator") $ do
64a64
>         d <- nonNegative s
70c70
< fraction ∷ (Fractional α, Monad μ, CharParsing μ) ⇒ μ α
---
> fraction :: (Fractional α, Monad μ, CharParsing μ) => μ α
75d74
< decExpSign ∷ (Monad μ, CharParsing μ) ⇒ μ (Maybe Sign)
76d74
< decExpSign = optional (PC.oneOf "eE") >>= \case
77d74
<                Nothing → return Nothing
78c75
<                Just _  → Just <$> optSign
---
> decExpSign :: (Monad μ, CharParsing μ) => μ (Maybe Sign)
78a76
> decExpSign = optional (PC.oneOf "eE") >>= 
78a77
>                Nothing -> return Nothing
78a78
>                Just _  -> Just <$> optSign
82d81
< hexExpSign ∷ (Monad μ, CharParsing μ) ⇒ μ (Maybe Sign)
83d81
< hexExpSign = optional (PC.oneOf "pP") >>= \case
84d81
<                Nothing → return Nothing
85c82
<                Just _  → Just <$> optSign
---
> hexExpSign :: (Monad μ, CharParsing μ) => μ (Maybe Sign)
85a83
> hexExpSign = optional (PC.oneOf "pP") >>= 
85a84
>                Nothing -> return Nothing
85a85
>                Just _  -> Just <$> optSign
88d87
< fractional' ∷ (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
89d87
<             ⇒ μ Sign -- ^ Sign parser.
90d87
<             → s
91d87
<             → Optional -- ^ Whether the integer part is optional.
92d87
<             → μ () -- ^ Dot parser.
93d87
<             → μ (Maybe Sign) -- ^ Exponent start parser.
94c88
<             → μ α
---
> fractional' :: (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
94a89
>             => μ Sign -- ^ Sign parser.
94a90
>             -> s
94a91
>             -> Optional -- ^ Whether the integer part is optional.
94a92
>             -> μ () -- ^ Dot parser.
94a93
>             -> μ (Maybe Sign) -- ^ Exponent start parser.
94a94
>             -> μ α
96d95
<     sign ← neg <?> "sign"
97c96
<     (i, f, fDigits) ← do
---
>     sign <- neg <?> "sign"
97a97
>     (i, f, fDigits) <- do
99c99
<             i ← nonNegative s <?> "integer part"
---
>             i <- nonNegative s <?> "integer part"
101d100
<       (i, hasF) ← case ip of
102d100
<         Optional → optional dot >>= \case
103d100
<           Nothing → integral
104d100
<           Just _ → return (0, True)
105d100
<         Required → integral
106c101
<       (f, fDigits) ←
---
>       (i, hasF) <- case ip of
106a102
>         Optional -> optional dot >>= 
106a103
>           Nothing -> integral
106a104
>           Just _ -> return (0, True)
106a105
>         Required -> integral
106a106
>       (f, fDigits) <-
109d108
<           let go !ds !f = optional digit >>= \case
110d108
<                             Just d  → go (ds + 1) (f * radix + d)
111d108
<                             Nothing → return (f, ds)
112c109
<           digit >>= go (1 ∷ Int) <?> "fractional part"
---
>           let go !ds !f = optional digit >>= 
112a110
>                             Just d  -> go (ds + 1) (f * radix + d)
112a111
>                             Nothing -> return (f, ds)
112a112
>           digit >>= go (1 :: Int) <?> "fractional part"
116d115
<     (<?> "exponent") $ eneg >>= \case
117d115
<       Nothing | f == 0    → return $ fromInteger $ applySign sign i
118c116
<               | otherwise → return $ fromRational
---
>     (<?> "exponent") $ eneg >>= 
118a117
>       Nothing | f == 0    -> return $ fromInteger $ applySign sign i
118a118
>               | otherwise -> return $ fromRational
121d120
<       Just esign → do
122c121
<         e ← nnBounded Decimal
---
>       Just esign -> do
122a122
>         e <- nnBounded Decimal
124d123
<           NonNegative → case e - fDigits of
125d123
<             e₁ | e₁ >= 0   → fromInteger $ i * radix ^ e + f * radix ^ e₁
126c124
<                | otherwise → fromRational
---
>           NonNegative -> case e - fDigits of
126a125
>             e₁ | e₁ >= 0   -> fromInteger $ i * radix ^ e + f * radix ^ e₁
126a126
>                | otherwise -> fromRational
129c129
<           NonPositive → fromRational
---
>           NonPositive -> fromRational
136c136
< fractional ∷ (Monad μ, Fractional α, CharParsing μ) ⇒ μ α
---
> fractional :: (Monad μ, Fractional α, CharParsing μ) => μ α
138a139
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE LambdaCase #-}

-- | Parsers for fractions.
module Data.Textual.Fractional
  (
  -- * Positional numeral systems
    PositionalSystem(..)
  , Binary(..)
  , Octal(..)
  , Decimal(..)
  , Hexadecimal(..)
  , UpHex(..)
  , LowHex(..)
  -- * Sign
  , Sign(..)
  , applySign
  , optMinus
  , optSign
  -- * Optionality characteristic
  , Optional(..)
  , isOptional
  , isRequired
  -- * Fraction parsers
  , optSlash
  , fraction'
  , fraction
  -- * s-fraction parsers
  , decExpSign
  , hexExpSign
  , fractional'
  , fractional
  ) where

import Data.Maybe (isJust)
import Data.Ratio ((%))
import Control.Applicative
import Text.Printer.Fractional (Optional(..), isOptional, isRequired)
import Text.Parser.Combinators ((<?>), unexpected)
import Text.Parser.Char (CharParsing)
import qualified Text.Parser.Char as PC
import Data.Textual.Integral

-- | Accept a slash and return 'Required'. Otherwise return 'Optional'.
optSlash ∷ (Monad μ, CharParsing μ) ⇒ μ Optional
optSlash = maybe Optional (const Required) <$> optional (PC.char '/')

-- | Parse a fraction. The numerator and the denominator are expected to be
--   written in the specified positional numeral system.
fraction' ∷ (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
          ⇒ μ Sign -- ^ Sign parser
          → s
          → μ Optional -- ^ Numerator/denominator separator parser
          → μ α
fraction' neg s den = (<?> "fraction") $ do
  n ← number' neg s <?> "numerator"
  den >>= \case
    Optional →
      return $ fromInteger n
    Required → do
      d ← (<?> "denominator") $ do
        d ← nonNegative s
        if d == 0 then unexpected "zero denominator"
                  else return d
      return $ fromRational $ n % d

-- | A shorthand for 'fraction'' 'optMinus' 'Decimal' 'optSlash'.
fraction ∷ (Fractional α, Monad μ, CharParsing μ) ⇒ μ α
fraction = fraction' optMinus Decimal optSlash

-- | Start of a decimal exponent. Accepts /'e'/ or /'E'/ followed by
--   an optional sign. Otherwise 'Nothing' is returned.
decExpSign ∷ (Monad μ, CharParsing μ) ⇒ μ (Maybe Sign)
decExpSign = optional (PC.oneOf "eE") >>= \case
               Nothing → return Nothing
               Just _  → Just <$> optSign

-- | Start of a hexadecimal exponent. Accepts /'p'/ or /'P'/ followed by
--   an optional sign. Otherwise 'Nothing' is returned.
hexExpSign ∷ (Monad μ, CharParsing μ) ⇒ μ (Maybe Sign)
hexExpSign = optional (PC.oneOf "pP") >>= \case
               Nothing → return Nothing
               Just _  → Just <$> optSign

-- | /s/-fraction parser.
fractional' ∷ (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
            ⇒ μ Sign -- ^ Sign parser.
            → s
            → Optional -- ^ Whether the integer part is optional.
            → μ () -- ^ Dot parser.
            → μ (Maybe Sign) -- ^ Exponent start parser.
            → μ α
fractional' neg s ip dot eneg = (<?> (systemName s ++ "-fraction")) $ do
    sign ← neg <?> "sign"
    (i, f, fDigits) ← do
      let integral = do
            i ← nonNegative s <?> "integer part"
            ((i, ) . isJust) <$> optional dot
      (i, hasF) ← case ip of
        Optional → optional dot >>= \case
          Nothing → integral
          Just _ → return (0, True)
        Required → integral
      (f, fDigits) ←
        if hasF
        then do
          let go !ds !f = optional digit >>= \case
                            Just d  → go (ds + 1) (f * radix + d)
                            Nothing → return (f, ds)
          digit >>= go (1 ∷ Int) <?> "fractional part"
        else
          return (0, 0)
      return (i, f, fDigits)
    (<?> "exponent") $ eneg >>= \case
      Nothing | f == 0    → return $ fromInteger $ applySign sign i
              | otherwise → return $ fromRational
                                   $ applySign sign
                                   $ fromInteger i + f % radix ^ fDigits
      Just esign → do
        e ← nnBounded Decimal
        return $ applySign sign $ case esign of
          NonNegative → case e - fDigits of
            e₁ | e₁ >= 0   → fromInteger $ i * radix ^ e + f * radix ^ e₁
               | otherwise → fromRational
                           $ fromInteger (i * radix ^ e)
                           + i % radix ^ negate e₁
          NonPositive → fromRational
                      $ i % (radix ^ e) + f % radix ^ (fDigits + e)
  where
    radix = radixIn s
    digit = digitIn s

-- | Decimal fraction parser.
fractional ∷ (Monad μ, Fractional α, CharParsing μ) ⇒ μ α
fractional = fractional' optMinus Decimal Required
                         (PC.char '.' *> pure ()) decExpSign
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE LambdaCase #-}

-- | Parsers for fractions.
module Data.Textual.Fractional
  (
  -- * Positional numeral systems
    PositionalSystem(..)
  , Binary(..)
  , Octal(..)
  , Decimal(..)
  , Hexadecimal(..)
  , UpHex(..)
  , LowHex(..)
  -- * Sign
  , Sign(..)
  , applySign
  , optMinus
  , optSign
  -- * Optionality characteristic
  , Optional(..)
  , isOptional
  , isRequired
  -- * Fraction parsers
  , optSlash
  , fraction'
  , fraction
  -- * s-fraction parsers
  , decExpSign
  , hexExpSign
  , fractional'
  , fractional
  ) where

import Data.Maybe (isJust)
import Data.Ratio ((%))
import Control.Applicative
import Text.Printer.Fractional (Optional(..), isOptional, isRequired)
import Text.Parser.Combinators ((<?>), unexpected)
import Text.Parser.Char (CharParsing)
import qualified Text.Parser.Char as PC
import Data.Textual.Integral

-- | Accept a slash and return 'Required'. Otherwise return 'Optional'.
optSlash :: (Monad μ, CharParsing μ) => μ Optional
optSlash = maybe Optional (const Required) <$> optional (PC.char '/')

-- | Parse a fraction. The numerator and the denominator are expected to be
--   written in the specified positional numeral system.
fraction' :: (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
          => μ Sign -- ^ Sign parser
          -> s
          -> μ Optional -- ^ Numerator/denominator separator parser
          -> μ α
fraction' neg s den = (<?> "fraction") $ do
  n <- number' neg s <?> "numerator"
  den >>= 
    Optional ->
      return $ fromInteger n
    Required -> do
      d <- (<?> "denominator") $ do
        d <- nonNegative s
        if d == 0 then unexpected "zero denominator"
                  else return d
      return $ fromRational $ n % d

-- | A shorthand for 'fraction'' 'optMinus' 'Decimal' 'optSlash'.
fraction :: (Fractional α, Monad μ, CharParsing μ) => μ α
fraction = fraction' optMinus Decimal optSlash

-- | Start of a decimal exponent. Accepts /'e'/ or /'E'/ followed by
--   an optional sign. Otherwise 'Nothing' is returned.
decExpSign :: (Monad μ, CharParsing μ) => μ (Maybe Sign)
decExpSign = optional (PC.oneOf "eE") >>= 
               Nothing -> return Nothing
               Just _  -> Just <$> optSign

-- | Start of a hexadecimal exponent. Accepts /'p'/ or /'P'/ followed by
--   an optional sign. Otherwise 'Nothing' is returned.
hexExpSign :: (Monad μ, CharParsing μ) => μ (Maybe Sign)
hexExpSign = optional (PC.oneOf "pP") >>= 
               Nothing -> return Nothing
               Just _  -> Just <$> optSign

-- | /s/-fraction parser.
fractional' :: (PositionalSystem s, Fractional α, Monad μ, CharParsing μ)
            => μ Sign -- ^ Sign parser.
            -> s
            -> Optional -- ^ Whether the integer part is optional.
            -> μ () -- ^ Dot parser.
            -> μ (Maybe Sign) -- ^ Exponent start parser.
            -> μ α
fractional' neg s ip dot eneg = (<?> (systemName s ++ "-fraction")) $ do
    sign <- neg <?> "sign"
    (i, f, fDigits) <- do
      let integral = do
            i <- nonNegative s <?> "integer part"
            ((i, ) . isJust) <$> optional dot
      (i, hasF) <- case ip of
        Optional -> optional dot >>= 
          Nothing -> integral
          Just _ -> return (0, True)
        Required -> integral
      (f, fDigits) <-
        if hasF
        then do
          let go !ds !f = optional digit >>= 
                            Just d  -> go (ds + 1) (f * radix + d)
                            Nothing -> return (f, ds)
          digit >>= go (1 :: Int) <?> "fractional part"
        else
          return (0, 0)
      return (i, f, fDigits)
    (<?> "exponent") $ eneg >>= 
      Nothing | f == 0    -> return $ fromInteger $ applySign sign i
              | otherwise -> return $ fromRational
                                   $ applySign sign
                                   $ fromInteger i + f % radix ^ fDigits
      Just esign -> do
        e <- nnBounded Decimal
        return $ applySign sign $ case esign of
          NonNegative -> case e - fDigits of
            e₁ | e₁ >= 0   -> fromInteger $ i * radix ^ e + f * radix ^ e₁
               | otherwise -> fromRational
                           $ fromInteger (i * radix ^ e)
                           + i % radix ^ negate e₁
          NonPositive -> fromRational
                      $ i % (radix ^ e) + f % radix ^ (fDigits + e)
  where
    radix = radixIn s
    digit = digitIn s

-- | Decimal fraction parser.
fractional :: (Monad μ, Fractional α, CharParsing μ) => μ α
fractional = fractional' optMinus Decimal Required
                         (PC.char '.' *> pure ()) decExpSign

</pre>