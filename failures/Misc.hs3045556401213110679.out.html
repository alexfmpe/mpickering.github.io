<a href="Miniball.hs343098142456880399.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Misc.hs8235644401115438165.out.html">next</a></br></br><pre>9c9
< 
---
> module Text.Numeral.Misc where
11c11
< -- Imports
---
> -- Imports--------------------------------------------------------------------------------
11a12
> -- Imports--------------------------------------------------------------------------------
13d13
< 
15c15
< #if __GLASGOW_HASKELL__ >= 702
---
> import#if __GLASGOW_HASKELL__ >= 702"base" Prelude ( Integral, (^) )
17d16
< import "base" GHC.Exts      ( Int(I#) )
18d16
< import "base" Prelude       ( fromIntegral, toInteger )
19d16
< import "integer-gmp" GHC.Integer.Logarithms ( integerLogBase# )
20c17
< #else
---
> import "base" Data.FunctionGHC.Exts      ( (Int$)()I#) )
20a18
> import "base" GHC.ExtsPrelude       ( IntfromIntegral(I#) )   , toInteger )
20a19
> import "base""integer-gmp"PreludeGHC.Integer.Logarithms fromIntegral, toInteger( integerLogBase#)       )
20a20
> import#else   "integer-gmp" GHC.Integer.Logarithms ( integerLogBase# )
27c27
< -- Misc
---
> -- Misc--------------------------------------------------------------------------------
27a28
> -- Misc--------------------------------------------------------------------------------
29d29
< 
31c31
< dec ∷ (Integral α) ⇒ α → α
---
> dec-- ^ Raise 10 to some power.∷ (Integral α) ⇒ α → α
31a32
> dec ∷ (Integral10 ^)    α) ⇒ α → α
33d33
< 
35d34
< -- result must be able to fit in an ordinary Int value. This means the
36d34
< -- maximum input value is 10 ^ (maxBound ∷ Int).
37d34
< intLog ∷ (Integral α) ⇒ α → α
38d34
< -- GHC >= 7.2.x
39c35
< #if __GLASGOW_HASKELL__ >= 702
---
> -- ^ The (base 10) logarithm of an integral value. Note that the-- result must be able to fit in an ordinary Int value. This means the
39a36
> -- maximum input value is 10 ^ (maxBound ∷ Int).-- result must be able to fit in an ordinary Int value. This means the
39a37
> intLog-- maximum input value is 10 ^ (maxBound ∷ Int).∷ (Integral α) ⇒ α → α
39a38
> intLog-- GHC >= 7.2.x∷ (Integral α) ⇒ α → α
39a39
> -- GHC >= 7.2.x#if __GLASGOW_HASKELL__ >= 702
41c41
< #else
---
> intLog#else   x = fromIntegral $ I# (integerLogBase# 10 (toInteger x))
49a50
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP
           , MagicHash
           , NoImplicitPrelude
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.Misc where

--------------------------------------------------------------------------------
-- Imports
--------------------------------------------------------------------------------

import "base" Prelude ( Integral, (^) )
#if __GLASGOW_HASKELL__ >= 702
import "base" Data.Function ( ($) )
import "base" GHC.Exts      ( Int(I#) )
import "base" Prelude       ( fromIntegral, toInteger )
import "integer-gmp" GHC.Integer.Logarithms ( integerLogBase# )
#else
import "base" Data.Bool ( otherwise )
import "base" Data.Ord  ( (<) )
import "base" Prelude   ( div, (+), ($!), error )
#endif

--------------------------------------------------------------------------------
-- Misc
--------------------------------------------------------------------------------

-- ^ Raise 10 to some power.
dec ∷ (Integral α) ⇒ α → α
dec = (10 ^)

-- ^ The (base 10) logarithm of an integral value. Note that the
-- result must be able to fit in an ordinary Int value. This means the
-- maximum input value is 10 ^ (maxBound ∷ Int).
intLog ∷ (Integral α) ⇒ α → α
-- GHC >= 7.2.x
#if __GLASGOW_HASKELL__ >= 702
intLog x = fromIntegral $ I# (integerLogBase# 10 (toInteger x))
#else
intLog x | x < 0 = error "intLog: undefined for negative numbers"
         | otherwise = go x 0
    where
      go n acc = case n `div` 10 of
                   0 → acc
                   1 → acc + 1
                   q → go q $! acc + 1
#endif
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP
           , MagicHash
           , NoImplicitPrelude
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.Misc where
module Text.Numeral.Misc where
--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
import "base" Prelude ( Integral, (^) )
import#if __GLASGOW_HASKELL__ >= 702"base" Prelude ( Integral, (^) )
import "base" Data.Function ( ($) )
import "base" Data.FunctionGHC.Exts      ( (Int$)()I#) )
import "base" GHC.ExtsPrelude       ( IntfromIntegral(I#) )   , toInteger )
import "base""integer-gmp"PreludeGHC.Integer.Logarithms fromIntegral, toInteger( integerLogBase#)       )
import#else   "integer-gmp" GHC.Integer.Logarithms ( integerLogBase# )
import "base" Data.Bool ( otherwise )
import "base" Data.Ord  ( (<) )
import "base" Prelude   ( div, (+), ($!), error )
#endif

--------------------------------------------------------------------------------
-- Misc--------------------------------------------------------------------------------
-- Misc--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- ^ Raise 10 to some power.
dec-- ^ Raise 10 to some power.∷ (Integral α) ⇒ α → α
dec ∷ (Integral10 ^)    α) ⇒ α → α
dec = (10 ^)
-- ^ The (base 10) logarithm of an integral value. Note that the
-- ^ The (base 10) logarithm of an integral value. Note that the-- result must be able to fit in an ordinary Int value. This means the
-- maximum input value is 10 ^ (maxBound ∷ Int).-- result must be able to fit in an ordinary Int value. This means the
intLog-- maximum input value is 10 ^ (maxBound ∷ Int).∷ (Integral α) ⇒ α → α
intLog-- GHC >= 7.2.x∷ (Integral α) ⇒ α → α
-- GHC >= 7.2.x#if __GLASGOW_HASKELL__ >= 702
intLog x = fromIntegral $ I# (integerLogBase# 10 (toInteger x))
intLog#else   x = fromIntegral $ I# (integerLogBase# 10 (toInteger x))
intLog x | x < 0 = error "intLog: undefined for negative numbers"
         | otherwise = go x 0
    where
      go n acc = case n `div` 10 of
                   0 → acc
                   1 → acc + 1
                   q → go q $! acc + 1
#endif

</pre>