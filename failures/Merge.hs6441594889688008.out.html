<a href="Merge.hs13539632491323602331.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Mersenne.hs563613512101929267.out.html">next</a></br></br><pre>24c24
< {-# LINE 45 "src/ehc/Core/Merge.chs" #-}
---
> 
24a25
> 
24a26
> 
24a27
> 
24a28
> 
24a29
> 
24a30
> 
24a31
> 
24a32
> 
24a33
> 
24a34
> 
24a35
> 
24a36
> 
24a37
> 
24a38
> 
24a39
> 
24a40
> 
24a41
> 
24a42
> 
24a43
> 
24a44
> 
64c84
< {-# LINE 90 "src/ehc/Core/Merge.chs" #-}
---
> 
64a85
> 
64a86
> 
64a87
> 
64a88
> 
64a89
> 
70a96
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Core.Merge
( cModMerge )
where
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core hiding (cModMerge)
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Module.Merge
import Data.List
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Util.Utils
import Control.Monad.Identity
import Control.Monad.State
import Data.Array
import qualified UHC.Util.FastSeq as Seq
import UHC.Light.Compiler.Core.FvS
import UHC.Light.Compiler.Core.ModAsMap
import UHC.Light.Compiler.Core.ExtractFFE


{-# LINE 45 "src/ehc/Core/Merge.chs" #-}
instance ModPuller
           CModule
           (CModuleDatabase, Map.Map HsName CModuleDatabase)
           (HsName,CExportL,CImportL,CDeclMetaL)
           CModule CExpr CBindCateg CBind
  where
    mpullSplit mmain@(CModule_Mod modNm _ _ _ _) mimpL =
        ( cmoddbMainExpr modDbMain
        ,
          Just (CBindCateg_FFE, [ (effeBind e, effeFvS e) | m <- mmain : mimpL, e <- cmodExtractFFE m ])
        , ( modDbMain
          , modDbMp
          )
        , ( modNm
          -- TBD: combine this in some way with the FFE implicit exports...
          , [] -- Set.toList $ Set.fromList $ concatMap cmoddbExports $ modDbMain : modDbImp
          , [] -- Set.toList $ Set.fromList $ concatMap cmoddbImports $ modDbMain : modDbImp
          , concatMap cmoddbMeta $ modDbMain : modDbImp
        ) )
      where modDbMain =     cexprModAsDatabase mmain
            modDbImp  = map cexprModAsDatabase mimpL
            modDbMp   = Map.unions [ Map.singleton (cmoddbModNm db) db | db <- modDbMain : modDbImp ]

    mpullUsedBindings n (modDbMain,modDbMp) = return $ do
        db <- maybe (Just modDbMain) (\m -> Map.lookup m modDbMp) $ hsnQualifier n
        (bi,_) <- cmoddbLookup n db
        let (cat,bsarr) = cmoddbBindArr db ! bi
            bs = elems bsarr
        return
          ( cat, bs
          , Set.fromList $ map cbindNm bs
          )

    mpullRelevantExprs = cbindExprs

    mpullFreeVars = cexprFvS

    mpullBindingsAddToMod (modNm,allExports,allImports,allMeta) rootExpr bs _ = CModule_Mod modNm allExports allImports allMeta (acoreLetN bs $ rootExpr)

{-# LINE 90 "src/ehc/Core/Merge.chs" #-}
-- | merge by pulling
cModMerge :: (CModule,[CModule]) -> CModule
cModMerge mods@(mmain,mimpL)
  = mkM mmain
  where (mkM,_) = modMergeByPullingIn mods

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Core.Merge
( cModMerge )
where
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core hiding (cModMerge)
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Module.Merge
import Data.List
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Util.Utils
import Control.Monad.Identity
import Control.Monad.State
import Data.Array
import qualified UHC.Util.FastSeq as Seq
import UHC.Light.Compiler.Core.FvS
import UHC.Light.Compiler.Core.ModAsMap
import UHC.Light.Compiler.Core.ExtractFFE























instance ModPuller
           CModule
           (CModuleDatabase, Map.Map HsName CModuleDatabase)
           (HsName,CExportL,CImportL,CDeclMetaL)
           CModule CExpr CBindCateg CBind
  where
    mpullSplit mmain@(CModule_Mod modNm _ _ _ _) mimpL =
        ( cmoddbMainExpr modDbMain
        ,
          Just (CBindCateg_FFE, [ (effeBind e, effeFvS e) | m <- mmain : mimpL, e <- cmodExtractFFE m ])
        , ( modDbMain
          , modDbMp
          )
        , ( modNm
          -- TBD: combine this in some way with the FFE implicit exports...
          , [] -- Set.toList $ Set.fromList $ concatMap cmoddbExports $ modDbMain : modDbImp
          , [] -- Set.toList $ Set.fromList $ concatMap cmoddbImports $ modDbMain : modDbImp
          , concatMap cmoddbMeta $ modDbMain : modDbImp
        ) )
      where modDbMain =     cexprModAsDatabase mmain
            modDbImp  = map cexprModAsDatabase mimpL
            modDbMp   = Map.unions [ Map.singleton (cmoddbModNm db) db | db <- modDbMain : modDbImp ]

    mpullUsedBindings n (modDbMain,modDbMp) = return $ do
        db <- maybe (Just modDbMain) (\m -> Map.lookup m modDbMp) $ hsnQualifier n
        (bi,_) <- cmoddbLookup n db
        let (cat,bsarr) = cmoddbBindArr db ! bi
            bs = elems bsarr
        return
          ( cat, bs
          , Set.fromList $ map cbindNm bs
          )

    mpullRelevantExprs = cbindExprs

    mpullFreeVars = cexprFvS

    mpullBindingsAddToMod (modNm,allExports,allImports,allMeta) rootExpr bs _ = CModule_Mod modNm allExports allImports allMeta (acoreLetN bs $ rootExpr)







-- | merge by pulling
cModMerge :: (CModule,[CModule]) -> CModule
cModMerge mods@(mmain,mimpL)
  = mkM mmain
  where (mkM,_) = modMergeByPullingIn mods


</pre>