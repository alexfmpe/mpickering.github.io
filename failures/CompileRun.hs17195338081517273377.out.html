<a href="CompileRanges.hs18667296621536830211.out.html">prev</a></br><a href="failures.html">home</a></br><a href="CompileUnit.hs159282276141000625.out.html">next</a></br></br><pre>65c65
< {-# LINE 71 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
65a66
> 
65a67
> 
65a68
> 
65a69
> 
65a70
> 
84c89
< {-# LINE 91 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
84a90
> 
97c103
< {-# LINE 125 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
97a104
> 
97a105
> 
97a106
> 
97a107
> 
97a108
> 
97a109
> 
97a110
> 
97a111
> 
97a112
> 
97a113
> 
97a114
> 
97a115
> 
97a116
> 
97a117
> 
97a118
> 
97a119
> 
97a120
> 
97a121
> 
97a122
> 
97a123
> 
97a124
> 
117c144
< {-# LINE 156 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
117a145
> 
117a146
> 
117a147
> 
117a148
> 
117a149
> 
117a150
> 
117a151
> 
117a152
> 
117a153
> 
117a154
> 
117a155
> 
138c176
< {-# LINE 188 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
138a177
> 
138a178
> 
138a179
> 
138a180
> 
138a181
> 
138a182
> 
138a183
> 
138a184
> 
138a185
> 
138a186
> 
138a187
> 
146c195
< {-# LINE 197 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
146a196
> 
153c203
< {-# LINE 205 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
153a204
> 
157c208
< {-# LINE 210 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
157a209
> 
178c230
< {-# LINE 232 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
178a231
> 
184c237
< {-# LINE 244 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
184a238
> 
184a239
> 
184a240
> 
184a241
> 
184a242
> 
184a243
> 
210c269
< {-# LINE 279 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
210a270
> 
210a271
> 
210a272
> 
210a273
> 
210a274
> 
210a275
> 
210a276
> 
210a277
> 
210a278
> 
215c283
< {-# LINE 302 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
215a284
> 
215a285
> 
215a286
> 
215a287
> 
215a288
> 
215a289
> 
215a290
> 
215a291
> 
215a292
> 
215a293
> 
215a294
> 
215a295
> 
215a296
> 
215a297
> 
215a298
> 
215a299
> 
215a300
> 
215a301
> 
220c306
< {-# LINE 312 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
220a307
> 
220a308
> 
220a309
> 
220a310
> 
220a311
> 
225c316
< {-# LINE 318 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
225a317
> 
235c327
<                         (\(e :: SomeException) -> hPutStrLn stderr (show f ++ ": " ++ show e))
---
>                         (\(                  ) -> hPutStrLn stderr (show f ++ ": " ++ show e))
237c329
< {-# LINE 335 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
237a330
> 
237a331
> 
237a332
> 
237a333
> 
237a334
> 
265c362
< {-# LINE 376 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
265a363
> 
265a364
> 
265a365
> 
265a366
> 
265a367
> 
265a368
> 
265a369
> 
265a370
> 
265a371
> 
265a372
> 
265a373
> 
265a374
> 
265a375
> 
276c386
< {-# LINE 392 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
276a387
> 
276a388
> 
276a389
> 
276a390
> 
276a391
> 
288c403
< {-# LINE 422 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
288a404
> 
288a405
> 
288a406
> 
288a407
> 
288a408
> 
288a409
> 
288a410
> 
288a411
> 
288a412
> 
288a413
> 
288a414
> 
288a415
> 
288a416
> 
288a417
> 
288a418
> 
288a419
> 
288a420
> 
288a421
> 
297c430
< {-# LINE 436 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
297a431
> 
297a432
> 
297a433
> 
297a434
> 
297a435
> 
306c444
< {-# LINE 450 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
306a445
> 
306a446
> 
306a447
> 
306a448
> 
306a449
> 
318c461
< {-# LINE 467 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
318a462
> 
318a463
> 
318a464
> 
318a465
> 
318a466
> 
323c471
< {-# LINE 477 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
323a472
> 
323a473
> 
323a474
> 
323a475
> 
323a476
> 
335c488
< {-# LINE 498 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
335a489
> 
335a490
> 
335a491
> 
335a492
> 
335a493
> 
335a494
> 
335a495
> 
335a496
> 
335a497
> 
341c503
< {-# LINE 509 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
341a504
> 
341a505
> 
341a506
> 
341a507
> 
341a508
> 
356c523
< {-# LINE 529 "src/ehc/EHC/CompileRun.chs" #-}
---
> 
356a524
> 
356a525
> 
356a526
> 
356a527
> 
356a528
> 
368a541
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompileRun
( EHCompileRunStateInfo (..)
, emptyEHCompileRunStateInfo
, EHCCompileRunner
, EHCompileRun, EHCompilePhaseT, EHCompilePhase
, crBaseInfo, crMbBaseInfo, crBaseInfo'
, cpUpdOpts
, cpMsg, cpMsg'
, cpStepUID, cpSetUID
, cpSystem', cpSystem
, cpSystemRaw
, cpStopAt
, crsiExpNmOffMpDbg, crsiExpNmOffMp
, crPartitionMainAndImported
, crModNeedsCompile
, crModCanCompile
, crSetAndCheckMain
, EHCTime, EHCTimeDiff, getEHCTime, ehcTimeDiff, ehcTimeDiffFmt
, EHCIOInfo (..), newEHCIOInfo
, cpRegisterFilesToRm
, cpRmFilesToRm
, crPartitionIntoPkgAndOthers )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import System.IO
import System.Exit
import System.Environment
import System.Process
import Control.Monad.State
import Control.Monad.Error
import Control.Exception as CE
import UHC.Light.Compiler.CodeGen.ValAccess as VA
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import qualified UHC.Light.Compiler.Core as Core
import qualified UHC.Light.Compiler.CoreRun as CoreRun
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import qualified UHC.Light.Compiler.HS.MainAG as HSSem
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.EHC.CompileGroup
import qualified UHC.Light.Compiler.HS.ModImpExp as HSSemMod
import UHC.Light.Compiler.Module.ImportExport
import UHC.Util.Time
import System.CPUTime
import System.Locale
import Data.IORef
import System.IO.Unsafe
import System.Directory
import UHC.Util.FPath
import UHC.Light.Compiler.Base.PackageDatabase













{-# LINE 71 "src/ehc/EHC/CompileRun.chs" #-}
type EHCTime = Integer
type EHCTimeDiff = Integer

getEHCTime :: IO EHCTime
getEHCTime = getCPUTime

ehcTimeDiff :: EHCTime -> EHCTime -> EHCTimeDiff
ehcTimeDiff = (-)

ehcTimeDiffFmt :: EHCTimeDiff -> String
ehcTimeDiffFmt t
  = fm 2 hrs ++ ":" ++ fm 2 mins ++ ":" ++ fm 2 secs ++ ":" ++ fm 6 (psecs `div` 1000000)
  where (r0  , psecs) = t  `quotRem` 1000000000000
        (r1  , secs ) = r0 `quotRem` 60
        (r2  , mins ) = r1 `quotRem` 60
        (days, hrs  ) = r2 `quotRem` 24
        fm n x = strPadLeft '0' n (show x)

{-# LINE 91 "src/ehc/EHC/CompileRun.chs" #-}
data EHCIOInfo
  = EHCIOInfo
      { ehcioinfoStartTime          :: EHCTime
      , ehcioinfoLastTime           :: EHCTime
      }

newEHCIOInfo :: IO (IORef EHCIOInfo)
newEHCIOInfo
  = do t <- getEHCTime
       newIORef (EHCIOInfo t t)


{-# LINE 125 "src/ehc/EHC/CompileRun.chs" #-}
data EHCompileRunStateInfo
  = EHCompileRunStateInfo
      { crsiOpts        :: !EHCOpts                             -- options
      , crsiNextUID     :: !UID                                 -- unique id, the next one
      , crsiHereUID     :: !UID                                 -- unique id, the current one
      , crsiHSInh       :: !HSSem.Inh_AGItf                     -- current inh attrs for HS sem
      , crsiEHInh       :: !EHSem.Inh_AGItf                     -- current inh attrs for EH sem
      , crsiCoreInh     :: !Core2GrSem.Inh_CodeAGItf            -- current inh attrs for Core2Grin sem
      , crsiCore2RunInh :: !CoreRun.Nm2RefMp                    -- current inh attrs for Core2CoreRun sem
      , crsiMbMainNm    :: !(Maybe HsName)                      -- name of main module, if any
      , crsiHSModInh    :: !HSSemMod.Inh_AGItf                  -- current inh attrs for HS module analysis sem
      , crsiModMp       :: !ModMp                               -- import/export info for modules
      , crsiGrpMp       :: (Map.Map HsName EHCompileGroup)      -- not yet used, for mut rec modules
      , crsiOptim       :: !Optim                               -- inter module optimisation info
      , crsiModOffMp    :: !VA.HsName2FldMpMp                   -- mapping of all modules + exp entries to offsets in module + exp tables
      , crsiEHCIOInfo   :: !(IORef EHCIOInfo)                   -- unsafe info
      , crsiFilesToRm   :: ![FPath]                             -- files to clean up (remove)
      }

{-# LINE 156 "src/ehc/EHC/CompileRun.chs" #-}
emptyEHCompileRunStateInfo :: EHCompileRunStateInfo
emptyEHCompileRunStateInfo
  = EHCompileRunStateInfo
      { crsiOpts        =   defaultEHCOpts
      , crsiNextUID     =   uidStart
      , crsiHereUID     =   uidStart
      , crsiHSInh       =   panic "emptyEHCompileRunStateInfo.crsiHSInh"
      , crsiEHInh       =   panic "emptyEHCompileRunStateInfo.crsiEHInh"
      , crsiCoreInh     =   panic "emptyEHCompileRunStateInfo.crsiCoreInh"
      , crsiCore2RunInh =   panic "emptyEHCompileRunStateInfo.crsiCoreRunInh"
      , crsiMbMainNm    =   Nothing
      , crsiHSModInh    =   panic "emptyEHCompileRunStateInfo.crsiHSModInh"
      , crsiModMp       =   Map.empty
      , crsiGrpMp       =   Map.empty
      , crsiOptim       =   defaultOptim
      , crsiModOffMp    =   Map.empty
      , crsiEHCIOInfo   =   panic "emptyEHCompileRunStateInfo.crsiEHCIOInfo"
      , crsiFilesToRm   =   []
      }

{-# LINE 188 "src/ehc/EHC/CompileRun.chs" #-}
crsiExpNmOffMpDbg :: String -> HsName -> EHCompileRunStateInfo -> VA.HsName2FldMp
crsiExpNmOffMpDbg ctxt modNm crsi = mmiNmOffMp $ panicJust ("crsiExpNmOffMp." ++ ctxt ++ show ks ++ ": " ++ show modNm) $ Map.lookup modNm $ crsiModMp crsi
  where ks = Map.keys $ crsiModMp crsi

crsiExpNmOffMp :: HsName -> EHCompileRunStateInfo -> VA.HsName2FldMp
crsiExpNmOffMp modNm crsi = mmiNmOffMp $ panicJust ("crsiExpNmOffMp: " ++ show modNm) $ Map.lookup modNm $ crsiModMp crsi

{-# LINE 197 "src/ehc/EHC/CompileRun.chs" #-}
instance Show EHCompileRunStateInfo where
  show _ = "EHCompileRunStateInfo"

instance PP EHCompileRunStateInfo where
  pp i = "CRSI:" >#< ppModMp (crsiModMp i)

{-# LINE 205 "src/ehc/EHC/CompileRun.chs" #-}
instance CompileRunStateInfo EHCompileRunStateInfo HsName () where
  crsiImportPosOfCUKey n i = ()

{-# LINE 210 "src/ehc/EHC/CompileRun.chs" #-}
class (MonadIO m, CompileRunner EHCompileUnitState HsName () FileLoc EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)) => EHCCompileRunner m where

instance ( CompileRunStateInfo EHCompileRunStateInfo HsName ()
         , CompileUnit EHCompileUnit HsName FileLoc EHCompileUnitState
         , CompileRunError Err ()
         -- , MonadError (CompileRunState Err) m
         -- , MonadState EHCompileRun (EHCompilePhaseAddonT m)
         , MonadIO m -- (EHCompilePhaseAddonT m)
         , Monad m
         ) => CompileRunner EHCompileUnitState HsName () FileLoc EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)

instance ( CompileRunStateInfo EHCompileRunStateInfo HsName ()
         , CompileUnit EHCompileUnit HsName FileLoc EHCompileUnitState
         , CompileRunError Err ()
         -- , MonadError (CompileRunState Err) m
         -- , MonadState EHCompileRun (EHCompilePhaseAddonT m)
         , MonadIO m -- (EHCompilePhaseAddonT m)
         , Monad m
         ) => EHCCompileRunner m

{-# LINE 232 "src/ehc/EHC/CompileRun.chs" #-}
type EHCompileRun           = CompileRun HsName EHCompileUnit EHCompileRunStateInfo Err
type EHCompilePhaseAddonT m = StateT EHCompileRun m
type EHCompilePhaseT      m = CompilePhaseT HsName EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)
type EHCompilePhase         = EHCompilePhaseT IO

{-# LINE 244 "src/ehc/EHC/CompileRun.chs" #-}
crBaseInfo' :: EHCompileRun -> (EHCompileRunStateInfo,EHCOpts)
crBaseInfo' cr
  = (crsi,opts)
  where crsi   = crStateInfo cr
        opts   = crsiOpts  crsi

crMbBaseInfo :: HsName -> EHCompileRun -> (Maybe EHCompileUnit, EHCompileRunStateInfo, EHCOpts, Maybe FPath)
crMbBaseInfo modNm cr
  = ( mbEcu ,crsi
    -- if any per module opts are available, use those
    , maybe opts id $ mbEcu >>= ecuMbOpts
    , fmap ecuFilePath mbEcu
    )
  where mbEcu       = crMbCU modNm cr
        (crsi,opts) = crBaseInfo' cr

crBaseInfo :: HsName -> EHCompileRun -> (EHCompileUnit,EHCompileRunStateInfo,EHCOpts,FPath)
crBaseInfo modNm cr
  = ( maybe (panic "crBaseInfo.mbEcu") id mbEcu
    , crsi
    , opts
    , maybe (panic "crBaseInfo.mbFp") id mbFp
    )
  where (mbEcu, crsi, opts, mbFp) = crMbBaseInfo modNm cr

{-# LINE 279 "src/ehc/EHC/CompileRun.chs" #-}
cpMemUsage :: EHCCompileRunner m => EHCompilePhaseT m ()
cpMemUsage
  = return ()

{-# LINE 302 "src/ehc/EHC/CompileRun.chs" #-}
cpUpdOpts :: EHCCompileRunner m => (EHCOpts -> EHCOpts) -> EHCompilePhaseT m ()
cpUpdOpts upd
  = cpUpdSI (\crsi -> crsi {crsiOpts = upd $ crsiOpts crsi})

{-# LINE 312 "src/ehc/EHC/CompileRun.chs" #-}
cpRegisterFilesToRm :: EHCCompileRunner m => [FPath] -> EHCompilePhaseT m ()
cpRegisterFilesToRm fpL
  = cpUpdSI (\crsi -> crsi {crsiFilesToRm = fpL ++ crsiFilesToRm crsi})

{-# LINE 318 "src/ehc/EHC/CompileRun.chs" #-}
cpRmFilesToRm :: EHCCompileRunner m => EHCompilePhaseT m ()
cpRmFilesToRm
  = do { cr <- get
       ; let (crsi,opts) = crBaseInfo' cr
             files = Set.toList $ Set.fromList $ map fpathToStr $ crsiFilesToRm crsi
       ; liftIO $ mapM rm files
       ; cpUpdSI (\crsi -> crsi {crsiFilesToRm = []})
       }
  where rm f = CE.catch (removeFile f)
                        (\(e :: SomeException) -> hPutStrLn stderr (show f ++ ": " ++ show e))

{-# LINE 335 "src/ehc/EHC/CompileRun.chs" #-}
cpMsg :: EHCCompileRunner m => HsName -> Verbosity -> String -> EHCompilePhaseT m ()
cpMsg modNm v m
  = do { cr <- get
       ; let (_,_,_,mbFp) = crMbBaseInfo modNm cr
       ; cpMsg' modNm v m Nothing (maybe emptyFPath id mbFp)
       }

cpMsg' :: EHCCompileRunner m => HsName -> Verbosity -> String -> Maybe String -> FPath -> EHCompilePhaseT m ()
cpMsg' modNm v m mbInfo fp
  = do { cr <- get
       ; let (mbEcu,crsi,opts,_) = crMbBaseInfo modNm cr
       ; ehcioinfo <- liftIO $ readIORef (crsiEHCIOInfo crsi)
       ; clockTime <- liftIO getEHCTime
       ; let clockStartTimePrev = ehcioinfoStartTime ehcioinfo
             clockTimePrev      = ehcioinfoLastTime ehcioinfo
             clockStartTimeDiff = ehcTimeDiff clockTime clockStartTimePrev
             clockTimeDiff      = ehcTimeDiff clockTime clockTimePrev
       ; let
             t              = if v >= VerboseALot then "<" ++ strBlankPad 35 (ehcTimeDiffFmt clockStartTimeDiff ++ "/" ++ ehcTimeDiffFmt clockTimeDiff) ++ ">" else ""
             m'             = maybe "" (\ecu -> show (ecuSeqNr ecu) ++ t ++ " ") mbEcu ++ m
       ; liftIO $ putCompileMsg v (ehcOptVerbosity opts) m' mbInfo modNm fp
       ; clockTime <- liftIO getEHCTime
       ; liftIO $ writeIORef (crsiEHCIOInfo crsi) (ehcioinfo {ehcioinfoLastTime = clockTime})
       -- ; cpUpdSI (\crsi -> crsi { crsiTime = clockTime })
       ; cpMemUsage
       }

{-# LINE 376 "src/ehc/EHC/CompileRun.chs" #-}
cpStepUID :: EHCCompileRunner m => EHCompilePhaseT m ()
cpStepUID
  = cpUpdSI (\crsi -> let (n,h) = mkNewLevUID (crsiNextUID crsi)
                      in  crsi {crsiNextUID = n, crsiHereUID = h}
            )

cpSetUID :: EHCCompileRunner m => UID -> EHCompilePhaseT m ()
cpSetUID u
  = cpUpdSI (\crsi -> crsi {crsiNextUID = u})

{-# LINE 392 "src/ehc/EHC/CompileRun.chs" #-}
cpSystem' :: EHCCompileRunner m => Maybe FilePath -> (FilePath,[String]) -> EHCompilePhaseT m ()
cpSystem' mbStdOut (cmd,args)
  = do { exitCode <- liftIO $ system $ showShellCmd $ (cmd,args ++ (maybe [] (\o -> [">", o]) mbStdOut))
       ; case exitCode of
           ExitSuccess -> return ()
           _           -> cpSetFail
       }

cpSystem :: EHCCompileRunner m => (FilePath,[String]) -> EHCompilePhaseT m ()
cpSystem = cpSystem' Nothing

{-# LINE 422 "src/ehc/EHC/CompileRun.chs" #-}
cpSystemRaw :: EHCCompileRunner m => String -> [String] -> EHCompilePhaseT m ()
cpSystemRaw cmd args
  = do { exitCode <- liftIO $ rawSystem cmd args
       ; case exitCode of
           ExitSuccess -> return ()
           _           -> cpSetErrs [rngLift emptyRange Err_PP $ pp $ show exitCode] -- cpSetFail
       }

{-# LINE 436 "src/ehc/EHC/CompileRun.chs" #-}
cpStopAt :: EHCCompileRunner m => CompilePoint -> EHCompilePhaseT m ()
cpStopAt atPhase
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; unless (atPhase < ehcStopAtPoint opts)
                cpSetStopAllSeq
       }

{-# LINE 450 "src/ehc/EHC/CompileRun.chs" #-}
crPartitionNewerOlderImports :: HsName -> EHCompileRun -> ([EHCompileUnit],[EHCompileUnit])
crPartitionNewerOlderImports modNm cr
  = partition isNewer $ map (flip crCU cr) $ ecuImpNmL ecu
  where ecu = crCU modNm cr
        t   = panicJust "crPartitionNewerOlderImports1" $ ecuMbHIInfoTime ecu
        isNewer ecu'
            | isJust mbt = t' `diffClockTimes` t > noTimeDiff
            | otherwise  = False
            where t' = panicJust "crPartitionNewerOlderImports2" $ ecuMbHIInfoTime ecu'
                  mbt = ecuMbHIInfoTime ecu'

{-# LINE 467 "src/ehc/EHC/CompileRun.chs" #-}
-- | Partition modules into main and non main (i.e. imported) module names
crPartitionMainAndImported :: EHCompileRun -> [HsName] -> ([HsName], [HsName])
crPartitionMainAndImported cr modNmL = partition (\n -> ecuHasMain $ crCU n cr) modNmL

{-# LINE 477 "src/ehc/EHC/CompileRun.chs" #-}
crModNeedsCompile :: HsName -> EHCompileRun -> Bool
crModNeedsCompile modNm cr
  = ecuIsMainMod ecu -- ecuIsTopMod ecu
    || not (  ehcOptCheckRecompile opts
           && ecuCanUseHIInsteadOfHS ecu
           && null newer
           )
  where ecu = crCU modNm cr
        (newer,_) = crPartitionNewerOlderImports modNm cr
        opts = crsiOpts $ crStateInfo cr

{-# LINE 498 "src/ehc/EHC/CompileRun.chs" #-}
crModCanCompile :: HsName -> EHCompileRun -> Bool
crModCanCompile modNm cr
  = isJust (ecuMbSrcTime ecu) && ecuDirIsWritable ecu
  where ecu = crCU modNm cr

{-# LINE 509 "src/ehc/EHC/CompileRun.chs" #-}
-- | split module names in those part of a package, and others
crPartitionIntoPkgAndOthers :: EHCompileRun -> [HsName] -> ([PkgModulePartition],[HsName])
crPartitionIntoPkgAndOthers cr modNmL
  = ( [ (p,d,m)
      | ((p,d),m) <- Map.toList $ Map.unionsWith (++) $ map Map.fromList ps
      ]
    , concat ms
    )
  where (ps,ms) = unzip $ map loc modNmL
        loc m = case filelocKind $ ecuFileLocation ecu of
                  FileLocKind_Dir     -> ([           ], [m])
                  FileLocKind_Pkg p d -> ([((p,d),[m])], [ ])
              where (ecu,_,_,_) = crBaseInfo m cr

{-# LINE 529 "src/ehc/EHC/CompileRun.chs" #-}
crSetAndCheckMain :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
crSetAndCheckMain modNm
  = do { cr <- get
       ; let (crsi,opts) = crBaseInfo' cr
             mkerr lim ns = cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MayOnlyHaveNrMain lim ns modNm]
       ; case crsiMbMainNm crsi of
           Just n | n /= modNm          -> mkerr 1 [n]
           _ | ehcOptDoExecLinking opts -> cpUpdSI (\crsi -> crsi {crsiMbMainNm = Just modNm})
             | otherwise                -> return ()
                                           -- mkerr 0 []
       }

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompileRun
( EHCompileRunStateInfo (..)
, emptyEHCompileRunStateInfo
, EHCCompileRunner
, EHCompileRun, EHCompilePhaseT, EHCompilePhase
, crBaseInfo, crMbBaseInfo, crBaseInfo'
, cpUpdOpts
, cpMsg, cpMsg'
, cpStepUID, cpSetUID
, cpSystem', cpSystem
, cpSystemRaw
, cpStopAt
, crsiExpNmOffMpDbg, crsiExpNmOffMp
, crPartitionMainAndImported
, crModNeedsCompile
, crModCanCompile
, crSetAndCheckMain
, EHCTime, EHCTimeDiff, getEHCTime, ehcTimeDiff, ehcTimeDiffFmt
, EHCIOInfo (..), newEHCIOInfo
, cpRegisterFilesToRm
, cpRmFilesToRm
, crPartitionIntoPkgAndOthers )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import System.IO
import System.Exit
import System.Environment
import System.Process
import Control.Monad.State
import Control.Monad.Error
import Control.Exception as CE
import UHC.Light.Compiler.CodeGen.ValAccess as VA
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import qualified UHC.Light.Compiler.Core as Core
import qualified UHC.Light.Compiler.CoreRun as CoreRun
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import qualified UHC.Light.Compiler.HS.MainAG as HSSem
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.EHC.CompileGroup
import qualified UHC.Light.Compiler.HS.ModImpExp as HSSemMod
import UHC.Light.Compiler.Module.ImportExport
import UHC.Util.Time
import System.CPUTime
import System.Locale
import Data.IORef
import System.IO.Unsafe
import System.Directory
import UHC.Util.FPath
import UHC.Light.Compiler.Base.PackageDatabase



















type EHCTime = Integer
type EHCTimeDiff = Integer

getEHCTime :: IO EHCTime
getEHCTime = getCPUTime

ehcTimeDiff :: EHCTime -> EHCTime -> EHCTimeDiff
ehcTimeDiff = (-)

ehcTimeDiffFmt :: EHCTimeDiff -> String
ehcTimeDiffFmt t
  = fm 2 hrs ++ ":" ++ fm 2 mins ++ ":" ++ fm 2 secs ++ ":" ++ fm 6 (psecs `div` 1000000)
  where (r0  , psecs) = t  `quotRem` 1000000000000
        (r1  , secs ) = r0 `quotRem` 60
        (r2  , mins ) = r1 `quotRem` 60
        (days, hrs  ) = r2 `quotRem` 24
        fm n x = strPadLeft '0' n (show x)



data EHCIOInfo
  = EHCIOInfo
      { ehcioinfoStartTime          :: EHCTime
      , ehcioinfoLastTime           :: EHCTime
      }

newEHCIOInfo :: IO (IORef EHCIOInfo)
newEHCIOInfo
  = do t <- getEHCTime
       newIORef (EHCIOInfo t t)
























data EHCompileRunStateInfo
  = EHCompileRunStateInfo
      { crsiOpts        :: !EHCOpts                             -- options
      , crsiNextUID     :: !UID                                 -- unique id, the next one
      , crsiHereUID     :: !UID                                 -- unique id, the current one
      , crsiHSInh       :: !HSSem.Inh_AGItf                     -- current inh attrs for HS sem
      , crsiEHInh       :: !EHSem.Inh_AGItf                     -- current inh attrs for EH sem
      , crsiCoreInh     :: !Core2GrSem.Inh_CodeAGItf            -- current inh attrs for Core2Grin sem
      , crsiCore2RunInh :: !CoreRun.Nm2RefMp                    -- current inh attrs for Core2CoreRun sem
      , crsiMbMainNm    :: !(Maybe HsName)                      -- name of main module, if any
      , crsiHSModInh    :: !HSSemMod.Inh_AGItf                  -- current inh attrs for HS module analysis sem
      , crsiModMp       :: !ModMp                               -- import/export info for modules
      , crsiGrpMp       :: (Map.Map HsName EHCompileGroup)      -- not yet used, for mut rec modules
      , crsiOptim       :: !Optim                               -- inter module optimisation info
      , crsiModOffMp    :: !VA.HsName2FldMpMp                   -- mapping of all modules + exp entries to offsets in module + exp tables
      , crsiEHCIOInfo   :: !(IORef EHCIOInfo)                   -- unsafe info
      , crsiFilesToRm   :: ![FPath]                             -- files to clean up (remove)
      }













emptyEHCompileRunStateInfo :: EHCompileRunStateInfo
emptyEHCompileRunStateInfo
  = EHCompileRunStateInfo
      { crsiOpts        =   defaultEHCOpts
      , crsiNextUID     =   uidStart
      , crsiHereUID     =   uidStart
      , crsiHSInh       =   panic "emptyEHCompileRunStateInfo.crsiHSInh"
      , crsiEHInh       =   panic "emptyEHCompileRunStateInfo.crsiEHInh"
      , crsiCoreInh     =   panic "emptyEHCompileRunStateInfo.crsiCoreInh"
      , crsiCore2RunInh =   panic "emptyEHCompileRunStateInfo.crsiCoreRunInh"
      , crsiMbMainNm    =   Nothing
      , crsiHSModInh    =   panic "emptyEHCompileRunStateInfo.crsiHSModInh"
      , crsiModMp       =   Map.empty
      , crsiGrpMp       =   Map.empty
      , crsiOptim       =   defaultOptim
      , crsiModOffMp    =   Map.empty
      , crsiEHCIOInfo   =   panic "emptyEHCompileRunStateInfo.crsiEHCIOInfo"
      , crsiFilesToRm   =   []
      }













crsiExpNmOffMpDbg :: String -> HsName -> EHCompileRunStateInfo -> VA.HsName2FldMp
crsiExpNmOffMpDbg ctxt modNm crsi = mmiNmOffMp $ panicJust ("crsiExpNmOffMp." ++ ctxt ++ show ks ++ ": " ++ show modNm) $ Map.lookup modNm $ crsiModMp crsi
  where ks = Map.keys $ crsiModMp crsi

crsiExpNmOffMp :: HsName -> EHCompileRunStateInfo -> VA.HsName2FldMp
crsiExpNmOffMp modNm crsi = mmiNmOffMp $ panicJust ("crsiExpNmOffMp: " ++ show modNm) $ Map.lookup modNm $ crsiModMp crsi



instance Show EHCompileRunStateInfo where
  show _ = "EHCompileRunStateInfo"

instance PP EHCompileRunStateInfo where
  pp i = "CRSI:" >#< ppModMp (crsiModMp i)



instance CompileRunStateInfo EHCompileRunStateInfo HsName () where
  crsiImportPosOfCUKey n i = ()



class (MonadIO m, CompileRunner EHCompileUnitState HsName () FileLoc EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)) => EHCCompileRunner m where

instance ( CompileRunStateInfo EHCompileRunStateInfo HsName ()
         , CompileUnit EHCompileUnit HsName FileLoc EHCompileUnitState
         , CompileRunError Err ()
         -- , MonadError (CompileRunState Err) m
         -- , MonadState EHCompileRun (EHCompilePhaseAddonT m)
         , MonadIO m -- (EHCompilePhaseAddonT m)
         , Monad m
         ) => CompileRunner EHCompileUnitState HsName () FileLoc EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)

instance ( CompileRunStateInfo EHCompileRunStateInfo HsName ()
         , CompileUnit EHCompileUnit HsName FileLoc EHCompileUnitState
         , CompileRunError Err ()
         -- , MonadError (CompileRunState Err) m
         -- , MonadState EHCompileRun (EHCompilePhaseAddonT m)
         , MonadIO m -- (EHCompilePhaseAddonT m)
         , Monad m
         ) => EHCCompileRunner m



type EHCompileRun           = CompileRun HsName EHCompileUnit EHCompileRunStateInfo Err
type EHCompilePhaseAddonT m = StateT EHCompileRun m
type EHCompilePhaseT      m = CompilePhaseT HsName EHCompileUnit EHCompileRunStateInfo Err (EHCompilePhaseAddonT m)
type EHCompilePhase         = EHCompilePhaseT IO








crBaseInfo' :: EHCompileRun -> (EHCompileRunStateInfo,EHCOpts)
crBaseInfo' cr
  = (crsi,opts)
  where crsi   = crStateInfo cr
        opts   = crsiOpts  crsi

crMbBaseInfo :: HsName -> EHCompileRun -> (Maybe EHCompileUnit, EHCompileRunStateInfo, EHCOpts, Maybe FPath)
crMbBaseInfo modNm cr
  = ( mbEcu ,crsi
    -- if any per module opts are available, use those
    , maybe opts id $ mbEcu >>= ecuMbOpts
    , fmap ecuFilePath mbEcu
    )
  where mbEcu       = crMbCU modNm cr
        (crsi,opts) = crBaseInfo' cr

crBaseInfo :: HsName -> EHCompileRun -> (EHCompileUnit,EHCompileRunStateInfo,EHCOpts,FPath)
crBaseInfo modNm cr
  = ( maybe (panic "crBaseInfo.mbEcu") id mbEcu
    , crsi
    , opts
    , maybe (panic "crBaseInfo.mbFp") id mbFp
    )
  where (mbEcu, crsi, opts, mbFp) = crMbBaseInfo modNm cr











cpMemUsage :: EHCCompileRunner m => EHCompilePhaseT m ()
cpMemUsage
  = return ()




















cpUpdOpts :: EHCCompileRunner m => (EHCOpts -> EHCOpts) -> EHCompilePhaseT m ()
cpUpdOpts upd
  = cpUpdSI (\crsi -> crsi {crsiOpts = upd $ crsiOpts crsi})







cpRegisterFilesToRm :: EHCCompileRunner m => [FPath] -> EHCompilePhaseT m ()
cpRegisterFilesToRm fpL
  = cpUpdSI (\crsi -> crsi {crsiFilesToRm = fpL ++ crsiFilesToRm crsi})



cpRmFilesToRm :: EHCCompileRunner m => EHCompilePhaseT m ()
cpRmFilesToRm
  = do { cr <- get
       ; let (crsi,opts) = crBaseInfo' cr
             files = Set.toList $ Set.fromList $ map fpathToStr $ crsiFilesToRm crsi
       ; liftIO $ mapM rm files
       ; cpUpdSI (\crsi -> crsi {crsiFilesToRm = []})
       }
  where rm f = CE.catch (removeFile f)
                        (\(                  ) -> hPutStrLn stderr (show f ++ ": " ++ show e))







cpMsg :: EHCCompileRunner m => HsName -> Verbosity -> String -> EHCompilePhaseT m ()
cpMsg modNm v m
  = do { cr <- get
       ; let (_,_,_,mbFp) = crMbBaseInfo modNm cr
       ; cpMsg' modNm v m Nothing (maybe emptyFPath id mbFp)
       }

cpMsg' :: EHCCompileRunner m => HsName -> Verbosity -> String -> Maybe String -> FPath -> EHCompilePhaseT m ()
cpMsg' modNm v m mbInfo fp
  = do { cr <- get
       ; let (mbEcu,crsi,opts,_) = crMbBaseInfo modNm cr
       ; ehcioinfo <- liftIO $ readIORef (crsiEHCIOInfo crsi)
       ; clockTime <- liftIO getEHCTime
       ; let clockStartTimePrev = ehcioinfoStartTime ehcioinfo
             clockTimePrev      = ehcioinfoLastTime ehcioinfo
             clockStartTimeDiff = ehcTimeDiff clockTime clockStartTimePrev
             clockTimeDiff      = ehcTimeDiff clockTime clockTimePrev
       ; let
             t              = if v >= VerboseALot then "<" ++ strBlankPad 35 (ehcTimeDiffFmt clockStartTimeDiff ++ "/" ++ ehcTimeDiffFmt clockTimeDiff) ++ ">" else ""
             m'             = maybe "" (\ecu -> show (ecuSeqNr ecu) ++ t ++ " ") mbEcu ++ m
       ; liftIO $ putCompileMsg v (ehcOptVerbosity opts) m' mbInfo modNm fp
       ; clockTime <- liftIO getEHCTime
       ; liftIO $ writeIORef (crsiEHCIOInfo crsi) (ehcioinfo {ehcioinfoLastTime = clockTime})
       -- ; cpUpdSI (\crsi -> crsi { crsiTime = clockTime })
       ; cpMemUsage
       }















cpStepUID :: EHCCompileRunner m => EHCompilePhaseT m ()
cpStepUID
  = cpUpdSI (\crsi -> let (n,h) = mkNewLevUID (crsiNextUID crsi)
                      in  crsi {crsiNextUID = n, crsiHereUID = h}
            )

cpSetUID :: EHCCompileRunner m => UID -> EHCompilePhaseT m ()
cpSetUID u
  = cpUpdSI (\crsi -> crsi {crsiNextUID = u})







cpSystem' :: EHCCompileRunner m => Maybe FilePath -> (FilePath,[String]) -> EHCompilePhaseT m ()
cpSystem' mbStdOut (cmd,args)
  = do { exitCode <- liftIO $ system $ showShellCmd $ (cmd,args ++ (maybe [] (\o -> [">", o]) mbStdOut))
       ; case exitCode of
           ExitSuccess -> return ()
           _           -> cpSetFail
       }

cpSystem :: EHCCompileRunner m => (FilePath,[String]) -> EHCompilePhaseT m ()
cpSystem = cpSystem' Nothing




















cpSystemRaw :: EHCCompileRunner m => String -> [String] -> EHCompilePhaseT m ()
cpSystemRaw cmd args
  = do { exitCode <- liftIO $ rawSystem cmd args
       ; case exitCode of
           ExitSuccess -> return ()
           _           -> cpSetErrs [rngLift emptyRange Err_PP $ pp $ show exitCode] -- cpSetFail
       }







cpStopAt :: EHCCompileRunner m => CompilePoint -> EHCompilePhaseT m ()
cpStopAt atPhase
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; unless (atPhase < ehcStopAtPoint opts)
                cpSetStopAllSeq
       }







crPartitionNewerOlderImports :: HsName -> EHCompileRun -> ([EHCompileUnit],[EHCompileUnit])
crPartitionNewerOlderImports modNm cr
  = partition isNewer $ map (flip crCU cr) $ ecuImpNmL ecu
  where ecu = crCU modNm cr
        t   = panicJust "crPartitionNewerOlderImports1" $ ecuMbHIInfoTime ecu
        isNewer ecu'
            | isJust mbt = t' `diffClockTimes` t > noTimeDiff
            | otherwise  = False
            where t' = panicJust "crPartitionNewerOlderImports2" $ ecuMbHIInfoTime ecu'
                  mbt = ecuMbHIInfoTime ecu'







-- | Partition modules into main and non main (i.e. imported) module names
crPartitionMainAndImported :: EHCompileRun -> [HsName] -> ([HsName], [HsName])
crPartitionMainAndImported cr modNmL = partition (\n -> ecuHasMain $ crCU n cr) modNmL







crModNeedsCompile :: HsName -> EHCompileRun -> Bool
crModNeedsCompile modNm cr
  = ecuIsMainMod ecu -- ecuIsTopMod ecu
    || not (  ehcOptCheckRecompile opts
           && ecuCanUseHIInsteadOfHS ecu
           && null newer
           )
  where ecu = crCU modNm cr
        (newer,_) = crPartitionNewerOlderImports modNm cr
        opts = crsiOpts $ crStateInfo cr











crModCanCompile :: HsName -> EHCompileRun -> Bool
crModCanCompile modNm cr
  = isJust (ecuMbSrcTime ecu) && ecuDirIsWritable ecu
  where ecu = crCU modNm cr







-- | split module names in those part of a package, and others
crPartitionIntoPkgAndOthers :: EHCompileRun -> [HsName] -> ([PkgModulePartition],[HsName])
crPartitionIntoPkgAndOthers cr modNmL
  = ( [ (p,d,m)
      | ((p,d),m) <- Map.toList $ Map.unionsWith (++) $ map Map.fromList ps
      ]
    , concat ms
    )
  where (ps,ms) = unzip $ map loc modNmL
        loc m = case filelocKind $ ecuFileLocation ecu of
                  FileLocKind_Dir     -> ([           ], [m])
                  FileLocKind_Pkg p d -> ([((p,d),[m])], [ ])
              where (ecu,_,_,_) = crBaseInfo m cr







crSetAndCheckMain :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
crSetAndCheckMain modNm
  = do { cr <- get
       ; let (crsi,opts) = crBaseInfo' cr
             mkerr lim ns = cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MayOnlyHaveNrMain lim ns modNm]
       ; case crsiMbMainNm crsi of
           Just n | n /= modNm          -> mkerr 1 [n]
           _ | ehcOptDoExecLinking opts -> cpUpdSI (\crsi -> crsi {crsiMbMainNm = Just modNm})
             | otherwise                -> return ()
                                           -- mkerr 0 []
       }


</pre>