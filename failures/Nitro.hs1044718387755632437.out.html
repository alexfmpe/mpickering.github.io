<a href="Newtype.hs15438212651106577801.out.html">prev</a></br><a href="failures.html">home</a></br><a href="NKL2FKL.hs1843563948885215120.out.html">next</a></br></br><pre>1d0
< -- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
2d0
< -- Edit the ORIGNAL .chs file instead!
3d0
< 
4d0
< 
5d0
< {-# LINE 1 "./System/Nitro.chs" #-}
15c10
< module System.Nitro (
---
> -- Edit the ORIGNAL .chs file instead!module System.Nitro (
219d213
< {-# LINE 217 "./System/Nitro.chs" #-}
220a215
> 
220a216
> 
220a217
> 
223d219
< {-# LINE 220 "./System/Nitro.chs" #-}
226d221
< {-# LINE 222 "./System/Nitro.chs" #-}
233d227
<   return ()
234d227
< {-# LINE 227 "./System/Nitro.chs" #-}
235d227
< 
236c228
< --  nitro_frame_t *nitro_frame_new_copy(void *d, uint32_t size)
---
> --  nitro_frame_t *nitro_frame_new_copy(void *d, uint32_t size) ()
240d231
<   let {a2' = id a2} in
241d231
<   nitroFrameNewCopy'_ a1' a2' >>= \res ->
242d231
<   let {res' = id res} in
243d231
<   return (res')
244d231
< {-# LINE 231 "./System/Nitro.chs" #-}
245d231
< 
246d231
< --  void *nitro_frame_data(nitro_frame_t *f)
247c232
< nitroFrameData :: NitroFrameInternal -> IO (Ptr ())
---
> --  void *nitro_frame_data(nitro_frame_t *f) {a2' = id a2} in
247a233
>                                             nitroFrameNewCopy'_ a1' a2' >>= \res ->
247a234
>                                             let {res' = id res} in
247a235
>                                             return (res') :: NitroFrameInternal -> IO (Ptr ())
250d237
<   nitroFrameData'_ a1' >>= \res ->
251d237
<   let {res' = id res} in
252d237
<   return (res')
253d237
< {-# LINE 235 "./System/Nitro.chs" #-}
254d237
< 
255d237
< --  uint32_t nitro_frame_size(nitro_frame_t *f)
256c238
< nitroFrameSize :: NitroFrameInternal -> IO (CUInt)
---
> --  uint32_t nitro_frame_size(nitro_frame_t *f) a1' >>= \res ->
256a239
>                                let {res' = id res} in
256a240
>                                return (res') :: NitroFrameInternal -> IO (CUInt)
259d242
<   nitroFrameSize'_ a1' >>= \res ->
260d242
<   let {res' = id res} in
261d242
<   return (res')
262d242
< {-# LINE 239 "./System/Nitro.chs" #-}
263d242
< 
264d242
< --  nitro_socket_t * nitro_socket_bind(char *location, nitro_sockopt_t *opt)
265c243
< nitroSocketBind :: String -> NitroSockOpt -> IO (NitroSocket)
---
> --  nitro_socket_t * nitro_socket_bind(char *location, nitro_sockopt_t *opt) a1' >>= \res ->
265a244
>                                                             let {res' = id res} in
265a245
>                                                             return (res') :: String -> NitroSockOpt -> IO (NitroSocket)
268d247
<   let {a2' = id a2} in
269d247
<   nitroSocketBind'_ a1' a2' >>= \res ->
270d247
<   let {res' = id res} in
271d247
<   return (res')
272d247
< {-# LINE 243 "./System/Nitro.chs" #-}
273d247
< 
274d247
< --  nitro_socket_t * nitro_socket_connect(char *location, nitro_sockopt_t *opt)
275c248
< nitroSocketConnect :: String -> NitroSockOpt -> IO (NitroSocket)
---
> --  nitro_socket_t * nitro_socket_connect(char *location, nitro_sockopt_t *opt) {a2' = id a2} in
275a249
>                                                                                nitroSocketBind'_ a1' a2' >>= \res ->
275a250
>                                                                                let {res' = id res} in
275a251
>                                                                                return (res') :: String -> NitroSockOpt -> IO (NitroSocket)
278d253
<   let {a2' = id a2} in
279d253
<   nitroSocketConnect'_ a1' a2' >>= \res ->
280d253
<   let {res' = id res} in
281d253
<   return (res')
282d253
< {-# LINE 247 "./System/Nitro.chs" #-}
283d253
< 
284d253
< --  nitro_sockopt_t *nitro_sockopt_new()
285c254
< nitroSockoptNew :: IO (NitroSockOpt)
---
> --  nitro_sockopt_t *nitro_sockopt_new() {a2' = id a2} in
285a255
>                                         nitroSocketConnect'_ a1' a2' >>= \res ->
285a256
>                                         let {res' = id res} in
285a257
>                                         return (res') :: IO (NitroSockOpt)
288d259
<   let {res' = id res} in
289d259
<   return (res')
290d259
< {-# LINE 251 "./System/Nitro.chs" #-}
291d259
< 
292d259
< --  void nitro_sockopt_set_hwm(nitro_sockopt_t *opt, int hwm)
293c260
< nitroSockoptSetHwm :: NitroSockOpt -> Int -> IO ()
---
> --  void nitro_sockopt_set_hwm(nitro_sockopt_t *opt, int hwm) {res' = id res} in
293a261
>                                                              return (res') :: NitroSockOpt -> Int -> IO ()
296d263
<   let {a2' = fromIntegral a2} in
297d263
<   nitroSockoptSetHwm'_ a1' a2' >>= \res ->
298d263
<   return ()
299d263
< {-# LINE 255 "./System/Nitro.chs" #-}
300d263
< 
301d263
< --  void nitro_sockopt_set_want_eventfd(nitro_sockopt_t *opt, int want_eventfd)
302c264
< nitroSockoptSetWantEventfd :: NitroSockOpt -> Int -> IO ()
---
> --  void nitro_sockopt_set_want_eventfd(nitro_sockopt_t *opt, int want_eventfd) {a2' = fromIntegral a2} in
302a265
>                                                                                nitroSockoptSetHwm'_ a1' a2' >>= \res ->
302a266
>                                                                                return () :: NitroSockOpt -> Int -> IO ()
307d270
<   return ()
308d270
< {-# LINE 259 "./System/Nitro.chs" #-}
309d270
< 
310c271
< nitroSocketClose :: NitroSocket -> IO ()
---
>   return () :: NitroSocket -> IO ()
314d274
<   return ()
315d274
< {-# LINE 262 "./System/Nitro.chs" #-}
316d274
< 
317c275
< nitroSend :: NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
---
>   return () :: NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
325d282
< {-# LINE 325 "./System/Nitro.chs" #-}
326a284
> 
326a285
> 
326a286
> 
326a287
> 
326a288
> 
326a289
> 
326a290
> 
326a291
> 
326a292
> 
326a293
> 
326a294
> 
326a295
> 
326a296
> 
326a297
> 
326a298
> 
326a299
> 
326a300
> 
326a301
> 
326a302
> 
326a303
> 
326a304
> 
326a305
> 
326a306
> 
326a307
> 
326a308
> 
326a309
> 
326a310
> 
326a311
> 
326a312
> 
326a313
> 
326a314
> 
326a315
> 
326a316
> 
326a317
> 
326a318
> 
326a319
> 
326a320
> 
326a321
> 
326a322
> 
326a323
> 
326a324
> 
326a325
> 
326a326
> 
326a327
> 
326a328
> 
326a329
> 
326a330
> 
326a331
> 
326a332
> 
326a333
> 
326a334
> 
326a335
> 
326a336
> 
326a337
> 
333d343
<   return (res')
334d343
< {-# LINE 328 "./System/Nitro.chs" #-}
335d343
< 
336c344
< nitroReply :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
---
>   return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
344d351
<   return (res')
345d351
< {-# LINE 331 "./System/Nitro.chs" #-}
346d351
< 
347c352
< nitroRelayFw :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
---
>   return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
349c354
<   let {a1' = id a1} in
---
>   let { = id a1} in
355d359
<   return (res')
356d359
< {-# LINE 334 "./System/Nitro.chs" #-}
357d359
< 
358c360
< nitroRelayBk :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
---
>   return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
360c362
<   let {a1' = id a1} in
---
>   let { = id a1} in
366d367
<   return (res')
367d367
< {-# LINE 337 "./System/Nitro.chs" #-}
368d367
< 
369c368
< nitroSub :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
---
>   return (res') :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
371c370
<   let {a1' = id a1} in
---
>   let { = id a1} in
376d374
<   return (res')
377d374
< {-# LINE 340 "./System/Nitro.chs" #-}
378d374
< 
379c375
< nitroUnsub :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
---
>   return (res') :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
386d381
<   return (res')
387d381
< {-# LINE 343 "./System/Nitro.chs" #-}
388d381
< 
389c382
< nitroPub :: NitroFrameInternal -> Ptr CUChar -> CULong -> NitroSocket -> Int -> IO (Int)
---
>   return (res') :: NitroFrameInternal -> Ptr CUChar -> CULong -> NitroSocket -> Int -> IO (Int)
398d390
<   return (res')
399d390
< {-# LINE 346 "./System/Nitro.chs" #-}
400d390
< 
401c391
< nitroEventfd :: NitroSocket -> IO (Int)
---
>   return (res') :: NitroSocket -> IO (Int)
403c393
<   let {a1' = id a1} in
---
>   let {} in
406d395
<   return (res')
407d395
< {-# LINE 349 "./System/Nitro.chs" #-}
408d395
< 
409c396
< nitroFrameDestroy :: NitroFrameInternal -> IO ()
---
>   return (res') :: NitroFrameInternal -> IO ()
413d399
<   return ()
414d399
< {-# LINE 352 "./System/Nitro.chs" #-}
415d399
< 
416d399
< 
417c400
< --flags api
---
> --flags api ()
431d413
<   return (res')
432d413
< {-# LINE 366 "./System/Nitro.chs" #-}
433d413
< 
434c414
< nitroErrmsg :: Int -> IO (String)
---
>   return (res') :: Int -> IO (String)
439d418
<   return (res')
440d418
< {-# LINE 369 "./System/Nitro.chs" #-}
441d418
< 
442c419
< throwNitroError fname e = do
---
>   return (res') fname e = do
667a645
> 
</pre></br><h2>original</h2></br><pre>-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "./System/Nitro.chs" #-}
-- |
-- Module:  System.Nitro
-- License: BSD3
-- Maintainer:  Erin Dahlgren <edahlgren@bu.mp>
-- Stability:   experimental
-- Portability: non-portable
--
-- Nitro is a fast, secure transport layer for sending messages across TCP and Inproc sockets.  It is ideal for building scalable network applications.
-- Nitro depends on the c libraries nitro and nitronacl (<https://github.com/bumptech/nitro>).
module System.Nitro (
     -- * How to use Nitro sockets
     -- $use

       nitroRuntimeStart
     , NitroSocket
     , SocketOptions(..)
     , defaultOpts
     , bind
     , connect
     , withSocket
     , close

     -- * Distributing messages
     -- $distributed
     , NitroFrame
     , bstrToFrame
     , frameToBstr
     , recv
     , send

     -- * Routing messages
     -- $routing
     , reply

     -- * Proxying messages
     -- $proxying
     , relayFw
     , relayBk

     -- * Pub/Sub messages
     -- $pubsub
     , sub
     , unsub
     , pub

     -- * Advanced
     -- $advanced
     , fileno

     -- * Types
     , Flag(NoWait)
     ) where

import Foreign.C.Types
import Foreign.Ptr
import Foreign.ForeignPtr
import Foreign.Storable
import Foreign.C.String
import qualified Foreign.Concurrent as FC
import Foreign.Marshal.Alloc

import Data.IORef
import Data.Bits
import qualified Data.ByteString as BS
import Data.ByteString.Internal
import Control.Monad (when)
import Control.Exception (bracket)

import System.IO (hPutStrLn, stderr)

-- $use
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     server <- bind "tcp://127.0.0.1:7777" defaultOpts
-- >     client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >     fr <- bstrToFrame "Hi I'm a client"
-- >     send client fr []
-- >     recv server [] >>= frameToBstr >>= print

-- $distributed
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (forkIO, threadDelay)
-- > import Control.Monad (forever)
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     server <- bind "tcp://*:7777" defaultOpts
-- >
-- >     let serverWorker = (\i -> forkIO $ forever $ do
-- >                             fr <- recv server []
-- >                             threadDelay 1000000
-- >                             print ("Thread #" ++ (show i))
-- >                             print . frameToBstr $ msg
-- >                         )
-- >
-- >     mapM_ serverWorker [1..2]
-- >
-- >     client <- connect "tcp://127.0.0.1:7777" client
-- >     fr1 <- bstrToFrame "Here's a request"
-- >     send client fr1 []
-- >     fr2 <- bstrToFrame "Here's another request"
-- >     send client fr2 []
-- >
-- >     threadDelay 2000000
--
-- Nitro wraps messages in a transport layer called a NitroFrame.  NitroFrames encode routing information about the sender of a message.  When you receive a NitroFrame you can use it to reply to the original sender.
-- Compile all multithreaded Nitro code with ghc-option: -threaded

-- $routing
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (forkIO, threadDelay)
-- > import Control.Monad (forever)
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     client1 <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >     client2 <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >     fr1 <- bstrToFrame "Hi I want a response"
-- >     send client1 fr1 []
-- >     fr2 <- bstrToFrame "Hi I also want a response"
-- >     send client2 fr2 []
-- >
-- >     forkIO $ withSocket (bind "tcp://127.0.0.1:7777" defaultOpts)
-- >                         (\echoServer -> forever $ do
-- >                             frame <- recv echoServer []
-- >                             reply echoServer frame frame []
-- >                         )
-- >
-- >     recv client1 [] >>= frameToBstr >>= print
-- >     recv client2 [] >>= frameToBstr >>= print
--
-- Nitro sockets are threadsafe.  Many worker threads can receive messages on a shared socket without overlap.

-- $proxying
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Data.ByteString as BS
-- > import Control.Concurrent (threadDelay, forkIO)
-- > import Control.Monad (forever, when)
-- >
-- > proxy = withSocket (bind "tcp://127.0.0.1:7777" defaultOpts)
-- >                    (\proxyRecv -> do
-- >                        withSocket (connect "tcp://127.0.0.1:7778" defaultOpts)
-- >                        (\proxySend -> forever $ do
-- >                            frame <- recv proxyRecv []
-- >                            msg <- frameToBstr
-- >                            when (BS.length msg < 50) $
-- >                            relayFw proxySend frame frame []
-- >                        )
-- >                    )
-- >
-- > server = withSocket (bind "tcp://127.0.0.1:7778" defaultOpts)
-- >                     (\server -> forever $ do
-- >                         fr <- recv server []
-- >                         print . frameToBstr $ fr
-- >                     )
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     forkIO $ server
-- >     forkIO $ proxy
-- >
-- >     client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >     fr1 <- bstrToFrame "Here's a short message"
-- >     send client fr1  []
-- >     fr2 <- "This message is too long for our server, it will be blocked"
-- >     send client fr2  []
-- >     threadDelay 1000000

-- $pubsub
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (threadDelay)
-- >
-- > main = do
-- >    nitroRuntimeStart
-- >
-- >    server <- bind "tcp://127.0.0.1:7777" defaultOpts
-- >    client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >    sub client "con"
-- >    threadDelay 1000000
-- >
-- >    fr <- bstrToFrame "You don't understand"
-- >    pub server fr "contender" []
-- >
-- >    recv client [] >>= frameToBstr >>= print

-- $advanced
--
-- Nitro sockets support a NoWait flag, which makes calls to recv nonblocking.  To make this useful, Nitro exposes an Int that represents the file descriptor of a Nitro socket.  Registering an intent to read from this file descriptor using the GHC event manager is one way to know when it is safe to do a nonblocking recv.


-- | A Nitro frame, which contains a message and routing information about the message's sender.
type NitroFrame = ForeignPtr ()

type NitroFrameInternal = Ptr (())
{-# LINE 217 "./System/Nitro.chs" #-}

-- | A Nitro socket
type NitroSocket = Ptr (())
{-# LINE 220 "./System/Nitro.chs" #-}

type NitroSockOpt = Ptr (())
{-# LINE 222 "./System/Nitro.chs" #-}

--  void nitro_runtime_start()
-- | Start the Nitro runtime manager.  This function must be called and must return before calling any other Nitro functions.
nitroRuntimeStart :: IO ()
nitroRuntimeStart =
  nitroRuntimeStart'_ >>= \res ->
  return ()
{-# LINE 227 "./System/Nitro.chs" #-}

--  nitro_frame_t *nitro_frame_new_copy(void *d, uint32_t size)
nitroFrameNewCopy :: Ptr () -> CUInt -> IO (NitroFrameInternal)
nitroFrameNewCopy a1 a2 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  nitroFrameNewCopy'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 231 "./System/Nitro.chs" #-}

--  void *nitro_frame_data(nitro_frame_t *f)
nitroFrameData :: NitroFrameInternal -> IO (Ptr ())
nitroFrameData a1 =
  let {a1' = id a1} in
  nitroFrameData'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 235 "./System/Nitro.chs" #-}

--  uint32_t nitro_frame_size(nitro_frame_t *f)
nitroFrameSize :: NitroFrameInternal -> IO (CUInt)
nitroFrameSize a1 =
  let {a1' = id a1} in
  nitroFrameSize'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 239 "./System/Nitro.chs" #-}

--  nitro_socket_t * nitro_socket_bind(char *location, nitro_sockopt_t *opt)
nitroSocketBind :: String -> NitroSockOpt -> IO (NitroSocket)
nitroSocketBind a1 a2 =
  withCString a1 $ \a1' ->
  let {a2' = id a2} in
  nitroSocketBind'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 243 "./System/Nitro.chs" #-}

--  nitro_socket_t * nitro_socket_connect(char *location, nitro_sockopt_t *opt)
nitroSocketConnect :: String -> NitroSockOpt -> IO (NitroSocket)
nitroSocketConnect a1 a2 =
  withCString a1 $ \a1' ->
  let {a2' = id a2} in
  nitroSocketConnect'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 247 "./System/Nitro.chs" #-}

--  nitro_sockopt_t *nitro_sockopt_new()
nitroSockoptNew :: IO (NitroSockOpt)
nitroSockoptNew =
  nitroSockoptNew'_ >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 251 "./System/Nitro.chs" #-}

--  void nitro_sockopt_set_hwm(nitro_sockopt_t *opt, int hwm)
nitroSockoptSetHwm :: NitroSockOpt -> Int -> IO ()
nitroSockoptSetHwm a1 a2 =
  let {a1' = id a1} in
  let {a2' = fromIntegral a2} in
  nitroSockoptSetHwm'_ a1' a2' >>= \res ->
  return ()
{-# LINE 255 "./System/Nitro.chs" #-}

--  void nitro_sockopt_set_want_eventfd(nitro_sockopt_t *opt, int want_eventfd)
nitroSockoptSetWantEventfd :: NitroSockOpt -> Int -> IO ()
nitroSockoptSetWantEventfd a1 a2 =
  let {a1' = id a1} in
  let {a2' = fromIntegral a2} in
  nitroSockoptSetWantEventfd'_ a1' a2' >>= \res ->
  return ()
{-# LINE 259 "./System/Nitro.chs" #-}

nitroSocketClose :: NitroSocket -> IO ()
nitroSocketClose a1 =
  let {a1' = id a1} in
  nitroSocketClose'_ a1' >>= \res ->
  return ()
{-# LINE 262 "./System/Nitro.chs" #-}

nitroSend :: NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroSend a1 a2 a3 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = fromIntegral a3} in
  nitroSend'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 325 "./System/Nitro.chs" #-}

nitroRecv :: NitroSocket -> Int -> IO (NitroFrameInternal)
nitroRecv a1 a2 =
  let {a1' = id a1} in
  let {a2' = fromIntegral a2} in
  nitroRecv'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 328 "./System/Nitro.chs" #-}

nitroReply :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroReply a1 a2 a3 a4 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroReply'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 331 "./System/Nitro.chs" #-}

nitroRelayFw :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroRelayFw a1 a2 a3 a4 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroRelayFw'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 334 "./System/Nitro.chs" #-}

nitroRelayBk :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroRelayBk a1 a2 a3 a4 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroRelayBk'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 337 "./System/Nitro.chs" #-}

nitroSub :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
nitroSub a1 a2 a3 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  nitroSub'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 340 "./System/Nitro.chs" #-}

nitroUnsub :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
nitroUnsub a1 a2 a3 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  nitroUnsub'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 343 "./System/Nitro.chs" #-}

nitroPub :: NitroFrameInternal -> Ptr CUChar -> CULong -> NitroSocket -> Int -> IO (Int)
nitroPub a1 a2 a3 a4 a5 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = id a4} in
  let {a5' = fromIntegral a5} in
  nitroPub'_ a1' a2' a3' a4' a5' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 346 "./System/Nitro.chs" #-}

nitroEventfd :: NitroSocket -> IO (Int)
nitroEventfd a1 =
  let {a1' = id a1} in
  nitroEventfd'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 349 "./System/Nitro.chs" #-}

nitroFrameDestroy :: NitroFrameInternal -> IO ()
nitroFrameDestroy a1 =
  let {a1' = id a1} in
  nitroFrameDestroy'_ a1' >>= \res ->
  return ()
{-# LINE 352 "./System/Nitro.chs" #-}


--flags api
data Flag = NoFlag
          | Reuse
          | NoWait
      deriving (Show,Eq,Enum)

toflag :: Flag -> [Flag] -> Int
toflag baseFlag = fromIntegral . foldr ((.|.) . fromEnum) (fromEnum baseFlag)


nitroError :: IO (Int)
nitroError =
  nitroError'_ >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 366 "./System/Nitro.chs" #-}

nitroErrmsg :: Int -> IO (String)
nitroErrmsg a1 =
  let {a1' = fromIntegral a1} in
  nitroErrmsg'_ a1' >>= \res ->
  peekCString res >>= \res' ->
  return (res')
{-# LINE 369 "./System/Nitro.chs" #-}

throwNitroError fname e = do
  msg <- nitroErrmsg e
  error $ fname ++ ": " ++ msg

-- API

data SocketOptions = SocketOptions {
      wantFd :: Bool
  }

-- | Default socket options
--
-- > defaultOpts = SocketOptions {
-- >       wantFd = False
-- > }
defaultOpts = SocketOptions {
      wantFd = False
  }

-- | Set the WantFd flag on a Nitro socket to True or False.  Once the socket is connected or bound, calling fileno on the socket will give an Int representing a valid file descriptor for the socket.
setWantFd :: NitroSockOpt -> Bool -> IO ()
setWantFd opt v =
  nitroSockoptSetWantEventfd opt (if v then (1 :: Int) else (0 :: Int))

-- | Set the high water mark on a Nitro socket.
setHighWaterMark :: NitroSockOpt -> Int -> IO ()
setHighWaterMark opt hwm =
  nitroSockoptSetHwm opt hwm

setSockOpts :: NitroSockOpt -> SocketOptions -> IO ()
setSockOpts opt setopts =
  setWantFd opt (wantFd setopts)

newNitroSockOpt :: SocketOptions -> IO NitroSockOpt
newNitroSockOpt opts = do
  newOpt <- nitroSockoptNew
  when (newOpt == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  setSockOpts newOpt opts
  return newOpt

-- | Create a Nitro socket bound to a TCP address.
bind :: String -> SocketOptions -> IO NitroSocket
bind location opts = do
  bound <- nitroSocketBind location =<< newNitroSockOpt opts
  when (bound == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  return bound

-- | Create a Nitro socket connected to a TCP address.
connect :: String -> SocketOptions -> IO NitroSocket
connect location opts = do
  connected <- nitroSocketConnect location =<< newNitroSockOpt opts
  when (connected == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  return connected

-- | Run an action with a Nitro socket.  The socket is garaunteed to close when the action finishes or when an error occurs.
withSocket :: (IO NitroSocket) -> (NitroSocket -> IO a) -> IO a
withSocket create action = bracket create close action

-- | Close a Nitro socket that is either connected or bound.
close :: NitroSocket -> IO ()
close = nitroSocketClose

-- | Get the Int representation of a Nitro socket's file descriptor.  If wantFd has not been set to True at the creation the Nitro socket, this Int will be meaningless.
--
-- > defaultOpt { wantFd = True }
--
fileno :: NitroSocket -> IO Int
fileno = nitroEventfd

-- | Receive a NitroFrame on a Nitro socket.  The NitroFrame includes routing information about the sender of the bytestring.  The NitroFrame can be given to reply or to the relaying functions in order to route responses back to the sender.
recv :: NitroSocket -> [Flag] -> IO NitroFrame
recv s flags = do
  fr <- nitroRecv s (toflag NoFlag flags)
  fp <- FC.newForeignPtr fr (nitroFrameDestroy fr)
  when (fr == nullPtr) $ do
    e <- nitroError
    throwNitroError "recv" e
  return fp

-- | Convert a NitroFrame to a strict bytestring.
frameToBstr :: NitroFrame -> IO ByteString
frameToBstr fp =
  withForeignPtr fp $ \fr -> do
    data' <- nitroFrameData fr
    size <- nitroFrameSize fr
    fptr <- newForeignPtr_ (castPtr data')
    return $ BS.copy (PS fptr 0 (fromIntegral size))

-- | Send a strict bytestring on a Nitro socket.  Nitro sockets do not set a high water mark by default.
send :: NitroSocket -> NitroFrame -> [Flag] -> IO ()
send s fp flags = do
  withForeignPtr fp $ \fr -> do
    e <- nitroSend fr s (toflag Reuse flags)
    when (e < 0) $ do
      e <- nitroError
      throwNitroError "send" e

-- | Convert a strict bytestring to a NitroFrame.
bstrToFrame :: ByteString -> IO NitroFrame
bstrToFrame (PS ps off size) = do
  fr <- withForeignPtr ps $ \p -> nitroFrameNewCopy (castPtr p `plusPtr` off) (fromIntegral size)
  FC.newForeignPtr fr (nitroFrameDestroy fr)

-- | Reply to the sender of a NitroFrame.  The first NitroFrame is the the sent NitroFrame, and the second NitroFrame is the response.
reply :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
reply s snd fr flags =
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroReply ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "reply" e

-- | Forward a NitroFrame to a new destination, passing along the routing information of the original sender.  The first NitroFrame is from the original sender, and the second NitroFrame contains the message to be forwarded.  Useful for building proxies.
relayFw :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
relayFw s snd fr flags = do
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroRelayFw ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "relayFw" e

-- | Relay back a NitroFrame by passing along the routing information from a reply.  The first NitroFrame is from the replier, and the second NitroFrame contains the message to be relayed back.  Useful for building proxies.
relayBk :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
relayBk s snd fr flags = do
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroRelayBk ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "relayBk" e

-- | Subscribe a Nitro socket to a channel prefix.  The channel prefix is a strict bytestring.  This socket can then receive messages on any channel containing that prefix.
sub :: NitroSocket -> ByteString -> IO ()
sub s (PS key off size) = do
  e <- withForeignPtr key $ \k -> nitroSub s (castPtr k `plusPtr` off) (fromIntegral size)
  when (e < 0)  $ do
    e <- nitroError
    throwNitroError "sub" e

-- | Unsubscribe a Nitro socket from a channel prefix.  The channel prefix is a strict bytestring.
unsub :: NitroSocket -> ByteString -> IO ()
unsub s (PS key off size) = do
  e <- withForeignPtr key $ \k -> nitroSub s (castPtr k `plusPtr` off) (fromIntegral size)
  when (e < 0) $ do
    e <- nitroError
    throwNitroError "unsub" e

-- | Publish a NitroFrame to a channel on a Nitro socket.  Any sockets connected to the same location can subscribe to updates from this publisher.
pub :: NitroSocket -> NitroFrame -> ByteString -> [Flag] -> IO Int
pub s fp (PS key offk sizek) flags = do
  withForeignPtr fp $ \fr ->
    withForeignPtr key $ \k -> nitroPub fr (castPtr k `plusPtr` offk) (fromIntegral sizek) s (toflag Reuse flags)

foreign import ccall safe "System/Nitro.chs.h nitro_runtime_start"
  nitroRuntimeStart'_ :: (IO CInt)

foreign import ccall safe "System/Nitro.chs.h nitro_frame_new_copy"
  nitroFrameNewCopy'_ :: ((Ptr ()) -> (CUInt -> (IO (NitroFrameInternal))))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_data"
  nitroFrameData'_ :: ((NitroFrameInternal) -> (IO (Ptr ())))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_size"
  nitroFrameSize'_ :: ((NitroFrameInternal) -> (IO CUInt))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_bind"
  nitroSocketBind'_ :: ((Ptr CChar) -> ((NitroSockOpt) -> (IO (NitroSocket))))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_connect"
  nitroSocketConnect'_ :: ((Ptr CChar) -> ((NitroSockOpt) -> (IO (NitroSocket))))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_new"
  nitroSockoptNew'_ :: (IO (NitroSockOpt))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_set_hwm"
  nitroSockoptSetHwm'_ :: ((NitroSockOpt) -> (CInt -> (IO ())))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_set_want_eventfd"
  nitroSockoptSetWantEventfd'_ :: ((NitroSockOpt) -> (CInt -> (IO ())))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_close"
  nitroSocketClose'_ :: ((NitroSocket) -> (IO ()))

foreign import ccall safe "System/Nitro.chs.h nitro_send_"
  nitroSend'_ :: ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_recv_"
  nitroRecv'_ :: ((NitroSocket) -> (CInt -> (IO (NitroFrameInternal))))

foreign import ccall safe "System/Nitro.chs.h nitro_reply_"
  nitroReply'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_relay_fw_"
  nitroRelayFw'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_relay_bk_"
  nitroRelayBk'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_sub_"
  nitroSub'_ :: ((NitroSocket) -> ((Ptr CUChar) -> (CULong -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_unsub_"
  nitroUnsub'_ :: ((NitroSocket) -> ((Ptr CUChar) -> (CULong -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_pub_"
  nitroPub'_ :: ((NitroFrameInternal) -> ((Ptr CUChar) -> (CULong -> ((NitroSocket) -> (CInt -> (IO CInt))))))

foreign import ccall safe "System/Nitro.chs.h nitro_eventfd_"
  nitroEventfd'_ :: ((NitroSocket) -> (IO CInt))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_destroy_"
  nitroFrameDestroy'_ :: ((NitroFrameInternal) -> (IO ()))

foreign import ccall safe "System/Nitro.chs.h nitro_error"
  nitroError'_ :: (IO CInt)

foreign import ccall safe "System/Nitro.chs.h nitro_errmsg"
  nitroErrmsg'_ :: (CInt -> (IO (Ptr CChar)))
</pre></br><h2>printed</h2></br><pre>-- |
-- Module:  System.Nitro
-- License: BSD3
-- Maintainer:  Erin Dahlgren <edahlgren@bu.mp>
-- Stability:   experimental
-- Portability: non-portable
--
-- Nitro is a fast, secure transport layer for sending messages across TCP and Inproc sockets.  It is ideal for building scalable network applications.
-- Nitro depends on the c libraries nitro and nitronacl (<https://github.com/bumptech/nitro>).
-- Edit the ORIGNAL .chs file instead!module System.Nitro (
     -- * How to use Nitro sockets
     -- $use

       nitroRuntimeStart
     , NitroSocket
     , SocketOptions(..)
     , defaultOpts
     , bind
     , connect
     , withSocket
     , close

     -- * Distributing messages
     -- $distributed
     , NitroFrame
     , bstrToFrame
     , frameToBstr
     , recv
     , send

     -- * Routing messages
     -- $routing
     , reply

     -- * Proxying messages
     -- $proxying
     , relayFw
     , relayBk

     -- * Pub/Sub messages
     -- $pubsub
     , sub
     , unsub
     , pub

     -- * Advanced
     -- $advanced
     , fileno

     -- * Types
     , Flag(NoWait)
     ) where

import Foreign.C.Types
import Foreign.Ptr
import Foreign.ForeignPtr
import Foreign.Storable
import Foreign.C.String
import qualified Foreign.Concurrent as FC
import Foreign.Marshal.Alloc

import Data.IORef
import Data.Bits
import qualified Data.ByteString as BS
import Data.ByteString.Internal
import Control.Monad (when)
import Control.Exception (bracket)

import System.IO (hPutStrLn, stderr)

-- $use
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     server <- bind "tcp://127.0.0.1:7777" defaultOpts
-- >     client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >     fr <- bstrToFrame "Hi I'm a client"
-- >     send client fr []
-- >     recv server [] >>= frameToBstr >>= print

-- $distributed
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (forkIO, threadDelay)
-- > import Control.Monad (forever)
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     server <- bind "tcp://*:7777" defaultOpts
-- >
-- >     let serverWorker = (\i -> forkIO $ forever $ do
-- >                             fr <- recv server []
-- >                             threadDelay 1000000
-- >                             print ("Thread #" ++ (show i))
-- >                             print . frameToBstr $ msg
-- >                         )
-- >
-- >     mapM_ serverWorker [1..2]
-- >
-- >     client <- connect "tcp://127.0.0.1:7777" client
-- >     fr1 <- bstrToFrame "Here's a request"
-- >     send client fr1 []
-- >     fr2 <- bstrToFrame "Here's another request"
-- >     send client fr2 []
-- >
-- >     threadDelay 2000000
--
-- Nitro wraps messages in a transport layer called a NitroFrame.  NitroFrames encode routing information about the sender of a message.  When you receive a NitroFrame you can use it to reply to the original sender.
-- Compile all multithreaded Nitro code with ghc-option: -threaded

-- $routing
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (forkIO, threadDelay)
-- > import Control.Monad (forever)
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     client1 <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >     client2 <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >     fr1 <- bstrToFrame "Hi I want a response"
-- >     send client1 fr1 []
-- >     fr2 <- bstrToFrame "Hi I also want a response"
-- >     send client2 fr2 []
-- >
-- >     forkIO $ withSocket (bind "tcp://127.0.0.1:7777" defaultOpts)
-- >                         (\echoServer -> forever $ do
-- >                             frame <- recv echoServer []
-- >                             reply echoServer frame frame []
-- >                         )
-- >
-- >     recv client1 [] >>= frameToBstr >>= print
-- >     recv client2 [] >>= frameToBstr >>= print
--
-- Nitro sockets are threadsafe.  Many worker threads can receive messages on a shared socket without overlap.

-- $proxying
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Data.ByteString as BS
-- > import Control.Concurrent (threadDelay, forkIO)
-- > import Control.Monad (forever, when)
-- >
-- > proxy = withSocket (bind "tcp://127.0.0.1:7777" defaultOpts)
-- >                    (\proxyRecv -> do
-- >                        withSocket (connect "tcp://127.0.0.1:7778" defaultOpts)
-- >                        (\proxySend -> forever $ do
-- >                            frame <- recv proxyRecv []
-- >                            msg <- frameToBstr
-- >                            when (BS.length msg < 50) $
-- >                            relayFw proxySend frame frame []
-- >                        )
-- >                    )
-- >
-- > server = withSocket (bind "tcp://127.0.0.1:7778" defaultOpts)
-- >                     (\server -> forever $ do
-- >                         fr <- recv server []
-- >                         print . frameToBstr $ fr
-- >                     )
-- >
-- > main = do
-- >     nitroRuntimeStart
-- >
-- >     forkIO $ server
-- >     forkIO $ proxy
-- >
-- >     client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >     fr1 <- bstrToFrame "Here's a short message"
-- >     send client fr1  []
-- >     fr2 <- "This message is too long for our server, it will be blocked"
-- >     send client fr2  []
-- >     threadDelay 1000000

-- $pubsub
--
-- > {-# LANGUAGE OverloadedStrings, ForeignFunctionInterface #-}
-- > import System.Nitro
-- > import Control.Concurrent (threadDelay)
-- >
-- > main = do
-- >    nitroRuntimeStart
-- >
-- >    server <- bind "tcp://127.0.0.1:7777" defaultOpts
-- >    client <- connect "tcp://127.0.0.1:7777" defaultOpts
-- >
-- >    sub client "con"
-- >    threadDelay 1000000
-- >
-- >    fr <- bstrToFrame "You don't understand"
-- >    pub server fr "contender" []
-- >
-- >    recv client [] >>= frameToBstr >>= print

-- $advanced
--
-- Nitro sockets support a NoWait flag, which makes calls to recv nonblocking.  To make this useful, Nitro exposes an Int that represents the file descriptor of a Nitro socket.  Registering an intent to read from this file descriptor using the GHC event manager is one way to know when it is safe to do a nonblocking recv.


-- | A Nitro frame, which contains a message and routing information about the message's sender.
type NitroFrame = ForeignPtr ()

type NitroFrameInternal = Ptr (())




-- | A Nitro socket
type NitroSocket = Ptr (())

type NitroSockOpt = Ptr (())

--  void nitro_runtime_start()
-- | Start the Nitro runtime manager.  This function must be called and must return before calling any other Nitro functions.
nitroRuntimeStart :: IO ()
nitroRuntimeStart =
  nitroRuntimeStart'_ >>= \res ->
--  nitro_frame_t *nitro_frame_new_copy(void *d, uint32_t size) ()
nitroFrameNewCopy :: Ptr () -> CUInt -> IO (NitroFrameInternal)
nitroFrameNewCopy a1 a2 =
  let {a1' = id a1} in
--  void *nitro_frame_data(nitro_frame_t *f) {a2' = id a2} in
                                            nitroFrameNewCopy'_ a1' a2' >>= \res ->
                                            let {res' = id res} in
                                            return (res') :: NitroFrameInternal -> IO (Ptr ())
nitroFrameData a1 =
  let {a1' = id a1} in
--  uint32_t nitro_frame_size(nitro_frame_t *f) a1' >>= \res ->
                               let {res' = id res} in
                               return (res') :: NitroFrameInternal -> IO (CUInt)
nitroFrameSize a1 =
  let {a1' = id a1} in
--  nitro_socket_t * nitro_socket_bind(char *location, nitro_sockopt_t *opt) a1' >>= \res ->
                                                            let {res' = id res} in
                                                            return (res') :: String -> NitroSockOpt -> IO (NitroSocket)
nitroSocketBind a1 a2 =
  withCString a1 $ \a1' ->
--  nitro_socket_t * nitro_socket_connect(char *location, nitro_sockopt_t *opt) {a2' = id a2} in
                                                                               nitroSocketBind'_ a1' a2' >>= \res ->
                                                                               let {res' = id res} in
                                                                               return (res') :: String -> NitroSockOpt -> IO (NitroSocket)
nitroSocketConnect a1 a2 =
  withCString a1 $ \a1' ->
--  nitro_sockopt_t *nitro_sockopt_new() {a2' = id a2} in
                                        nitroSocketConnect'_ a1' a2' >>= \res ->
                                        let {res' = id res} in
                                        return (res') :: IO (NitroSockOpt)
nitroSockoptNew =
  nitroSockoptNew'_ >>= \res ->
--  void nitro_sockopt_set_hwm(nitro_sockopt_t *opt, int hwm) {res' = id res} in
                                                             return (res') :: NitroSockOpt -> Int -> IO ()
nitroSockoptSetHwm a1 a2 =
  let {a1' = id a1} in
--  void nitro_sockopt_set_want_eventfd(nitro_sockopt_t *opt, int want_eventfd) {a2' = fromIntegral a2} in
                                                                               nitroSockoptSetHwm'_ a1' a2' >>= \res ->
                                                                               return () :: NitroSockOpt -> Int -> IO ()
nitroSockoptSetWantEventfd a1 a2 =
  let {a1' = id a1} in
  let {a2' = fromIntegral a2} in
  nitroSockoptSetWantEventfd'_ a1' a2' >>= \res ->
  return () :: NitroSocket -> IO ()
nitroSocketClose a1 =
  let {a1' = id a1} in
  nitroSocketClose'_ a1' >>= \res ->
  return () :: NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroSend a1 a2 a3 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = fromIntegral a3} in
  nitroSend'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')























































nitroRecv :: NitroSocket -> Int -> IO (NitroFrameInternal)
nitroRecv a1 a2 =
  let {a1' = id a1} in
  let {a2' = fromIntegral a2} in
  nitroRecv'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroReply a1 a2 a3 a4 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroReply'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroRelayFw a1 a2 a3 a4 =
  let { = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroRelayFw'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroFrameInternal -> NitroFrameInternal -> NitroSocket -> Int -> IO (Int)
nitroRelayBk a1 a2 a3 a4 =
  let { = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = fromIntegral a4} in
  nitroRelayBk'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
nitroSub a1 a2 a3 =
  let { = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  nitroSub'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroSocket -> Ptr CUChar -> CULong -> IO (Int)
nitroUnsub a1 a2 a3 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  nitroUnsub'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroFrameInternal -> Ptr CUChar -> CULong -> NitroSocket -> Int -> IO (Int)
nitroPub a1 a2 a3 a4 a5 =
  let {a1' = id a1} in
  let {a2' = id a2} in
  let {a3' = id a3} in
  let {a4' = id a4} in
  let {a5' = fromIntegral a5} in
  nitroPub'_ a1' a2' a3' a4' a5' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroSocket -> IO (Int)
nitroEventfd a1 =
  let {} in
  nitroEventfd'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: NitroFrameInternal -> IO ()
nitroFrameDestroy a1 =
  let {a1' = id a1} in
  nitroFrameDestroy'_ a1' >>= \res ->
--flags api ()
data Flag = NoFlag
          | Reuse
          | NoWait
      deriving (Show,Eq,Enum)

toflag :: Flag -> [Flag] -> Int
toflag baseFlag = fromIntegral . foldr ((.|.) . fromEnum) (fromEnum baseFlag)


nitroError :: IO (Int)
nitroError =
  nitroError'_ >>= \res ->
  let {res' = fromIntegral res} in
  return (res') :: Int -> IO (String)
nitroErrmsg a1 =
  let {a1' = fromIntegral a1} in
  nitroErrmsg'_ a1' >>= \res ->
  peekCString res >>= \res' ->
  return (res') fname e = do
  msg <- nitroErrmsg e
  error $ fname ++ ": " ++ msg

-- API

data SocketOptions = SocketOptions {
      wantFd :: Bool
  }

-- | Default socket options
--
-- > defaultOpts = SocketOptions {
-- >       wantFd = False
-- > }
defaultOpts = SocketOptions {
      wantFd = False
  }

-- | Set the WantFd flag on a Nitro socket to True or False.  Once the socket is connected or bound, calling fileno on the socket will give an Int representing a valid file descriptor for the socket.
setWantFd :: NitroSockOpt -> Bool -> IO ()
setWantFd opt v =
  nitroSockoptSetWantEventfd opt (if v then (1 :: Int) else (0 :: Int))

-- | Set the high water mark on a Nitro socket.
setHighWaterMark :: NitroSockOpt -> Int -> IO ()
setHighWaterMark opt hwm =
  nitroSockoptSetHwm opt hwm

setSockOpts :: NitroSockOpt -> SocketOptions -> IO ()
setSockOpts opt setopts =
  setWantFd opt (wantFd setopts)

newNitroSockOpt :: SocketOptions -> IO NitroSockOpt
newNitroSockOpt opts = do
  newOpt <- nitroSockoptNew
  when (newOpt == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  setSockOpts newOpt opts
  return newOpt

-- | Create a Nitro socket bound to a TCP address.
bind :: String -> SocketOptions -> IO NitroSocket
bind location opts = do
  bound <- nitroSocketBind location =<< newNitroSockOpt opts
  when (bound == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  return bound

-- | Create a Nitro socket connected to a TCP address.
connect :: String -> SocketOptions -> IO NitroSocket
connect location opts = do
  connected <- nitroSocketConnect location =<< newNitroSockOpt opts
  when (connected == nullPtr) $ do
    e <- nitroError
    throwNitroError "connect" e
  return connected

-- | Run an action with a Nitro socket.  The socket is garaunteed to close when the action finishes or when an error occurs.
withSocket :: (IO NitroSocket) -> (NitroSocket -> IO a) -> IO a
withSocket create action = bracket create close action

-- | Close a Nitro socket that is either connected or bound.
close :: NitroSocket -> IO ()
close = nitroSocketClose

-- | Get the Int representation of a Nitro socket's file descriptor.  If wantFd has not been set to True at the creation the Nitro socket, this Int will be meaningless.
--
-- > defaultOpt { wantFd = True }
--
fileno :: NitroSocket -> IO Int
fileno = nitroEventfd

-- | Receive a NitroFrame on a Nitro socket.  The NitroFrame includes routing information about the sender of the bytestring.  The NitroFrame can be given to reply or to the relaying functions in order to route responses back to the sender.
recv :: NitroSocket -> [Flag] -> IO NitroFrame
recv s flags = do
  fr <- nitroRecv s (toflag NoFlag flags)
  fp <- FC.newForeignPtr fr (nitroFrameDestroy fr)
  when (fr == nullPtr) $ do
    e <- nitroError
    throwNitroError "recv" e
  return fp

-- | Convert a NitroFrame to a strict bytestring.
frameToBstr :: NitroFrame -> IO ByteString
frameToBstr fp =
  withForeignPtr fp $ \fr -> do
    data' <- nitroFrameData fr
    size <- nitroFrameSize fr
    fptr <- newForeignPtr_ (castPtr data')
    return $ BS.copy (PS fptr 0 (fromIntegral size))

-- | Send a strict bytestring on a Nitro socket.  Nitro sockets do not set a high water mark by default.
send :: NitroSocket -> NitroFrame -> [Flag] -> IO ()
send s fp flags = do
  withForeignPtr fp $ \fr -> do
    e <- nitroSend fr s (toflag Reuse flags)
    when (e < 0) $ do
      e <- nitroError
      throwNitroError "send" e

-- | Convert a strict bytestring to a NitroFrame.
bstrToFrame :: ByteString -> IO NitroFrame
bstrToFrame (PS ps off size) = do
  fr <- withForeignPtr ps $ \p -> nitroFrameNewCopy (castPtr p `plusPtr` off) (fromIntegral size)
  FC.newForeignPtr fr (nitroFrameDestroy fr)

-- | Reply to the sender of a NitroFrame.  The first NitroFrame is the the sent NitroFrame, and the second NitroFrame is the response.
reply :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
reply s snd fr flags =
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroReply ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "reply" e

-- | Forward a NitroFrame to a new destination, passing along the routing information of the original sender.  The first NitroFrame is from the original sender, and the second NitroFrame contains the message to be forwarded.  Useful for building proxies.
relayFw :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
relayFw s snd fr flags = do
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroRelayFw ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "relayFw" e

-- | Relay back a NitroFrame by passing along the routing information from a reply.  The first NitroFrame is from the replier, and the second NitroFrame contains the message to be relayed back.  Useful for building proxies.
relayBk :: NitroSocket -> NitroFrame -> NitroFrame -> [Flag] -> IO ()
relayBk s snd fr flags = do
  withForeignPtr snd $ \ptr1 ->
    withForeignPtr fr $ \ptr2 -> do
      e <- nitroRelayBk ptr1 ptr2 s (toflag Reuse flags)
      when (e < 0) $ do
        e <- nitroError
        throwNitroError "relayBk" e

-- | Subscribe a Nitro socket to a channel prefix.  The channel prefix is a strict bytestring.  This socket can then receive messages on any channel containing that prefix.
sub :: NitroSocket -> ByteString -> IO ()
sub s (PS key off size) = do
  e <- withForeignPtr key $ \k -> nitroSub s (castPtr k `plusPtr` off) (fromIntegral size)
  when (e < 0)  $ do
    e <- nitroError
    throwNitroError "sub" e

-- | Unsubscribe a Nitro socket from a channel prefix.  The channel prefix is a strict bytestring.
unsub :: NitroSocket -> ByteString -> IO ()
unsub s (PS key off size) = do
  e <- withForeignPtr key $ \k -> nitroSub s (castPtr k `plusPtr` off) (fromIntegral size)
  when (e < 0) $ do
    e <- nitroError
    throwNitroError "unsub" e

-- | Publish a NitroFrame to a channel on a Nitro socket.  Any sockets connected to the same location can subscribe to updates from this publisher.
pub :: NitroSocket -> NitroFrame -> ByteString -> [Flag] -> IO Int
pub s fp (PS key offk sizek) flags = do
  withForeignPtr fp $ \fr ->
    withForeignPtr key $ \k -> nitroPub fr (castPtr k `plusPtr` offk) (fromIntegral sizek) s (toflag Reuse flags)

foreign import ccall safe "System/Nitro.chs.h nitro_runtime_start"
  nitroRuntimeStart'_ :: (IO CInt)

foreign import ccall safe "System/Nitro.chs.h nitro_frame_new_copy"
  nitroFrameNewCopy'_ :: ((Ptr ()) -> (CUInt -> (IO (NitroFrameInternal))))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_data"
  nitroFrameData'_ :: ((NitroFrameInternal) -> (IO (Ptr ())))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_size"
  nitroFrameSize'_ :: ((NitroFrameInternal) -> (IO CUInt))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_bind"
  nitroSocketBind'_ :: ((Ptr CChar) -> ((NitroSockOpt) -> (IO (NitroSocket))))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_connect"
  nitroSocketConnect'_ :: ((Ptr CChar) -> ((NitroSockOpt) -> (IO (NitroSocket))))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_new"
  nitroSockoptNew'_ :: (IO (NitroSockOpt))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_set_hwm"
  nitroSockoptSetHwm'_ :: ((NitroSockOpt) -> (CInt -> (IO ())))

foreign import ccall safe "System/Nitro.chs.h nitro_sockopt_set_want_eventfd"
  nitroSockoptSetWantEventfd'_ :: ((NitroSockOpt) -> (CInt -> (IO ())))

foreign import ccall safe "System/Nitro.chs.h nitro_socket_close"
  nitroSocketClose'_ :: ((NitroSocket) -> (IO ()))

foreign import ccall safe "System/Nitro.chs.h nitro_send_"
  nitroSend'_ :: ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_recv_"
  nitroRecv'_ :: ((NitroSocket) -> (CInt -> (IO (NitroFrameInternal))))

foreign import ccall safe "System/Nitro.chs.h nitro_reply_"
  nitroReply'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_relay_fw_"
  nitroRelayFw'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_relay_bk_"
  nitroRelayBk'_ :: ((NitroFrameInternal) -> ((NitroFrameInternal) -> ((NitroSocket) -> (CInt -> (IO CInt)))))

foreign import ccall safe "System/Nitro.chs.h nitro_sub_"
  nitroSub'_ :: ((NitroSocket) -> ((Ptr CUChar) -> (CULong -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_unsub_"
  nitroUnsub'_ :: ((NitroSocket) -> ((Ptr CUChar) -> (CULong -> (IO CInt))))

foreign import ccall safe "System/Nitro.chs.h nitro_pub_"
  nitroPub'_ :: ((NitroFrameInternal) -> ((Ptr CUChar) -> (CULong -> ((NitroSocket) -> (CInt -> (IO CInt))))))

foreign import ccall safe "System/Nitro.chs.h nitro_eventfd_"
  nitroEventfd'_ :: ((NitroSocket) -> (IO CInt))

foreign import ccall safe "System/Nitro.chs.h nitro_frame_destroy_"
  nitroFrameDestroy'_ :: ((NitroFrameInternal) -> (IO ()))

foreign import ccall safe "System/Nitro.chs.h nitro_error"
  nitroError'_ :: (IO CInt)

foreign import ccall safe "System/Nitro.chs.h nitro_errmsg"
  nitroErrmsg'_ :: (CInt -> (IO (Ptr CChar)))

</pre>