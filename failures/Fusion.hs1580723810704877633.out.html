<a href="Fusion.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Fusion.hs5298553951812423303.out.html">next</a></br></br><pre>23c23
< genericLength ∷ Num n ⇒ Stream α → n
---
> genericLength :: Num n => Stream α -> n
27c27
< genericTake ∷ Integral n ⇒ n → Stream α → Stream α
---
> genericTake :: Integral n => n -> Stream α -> Stream α
31c31
< genericDrop ∷ Integral n ⇒ n → Stream α → Stream α
---
> genericDrop :: Integral n => n -> Stream α -> Stream α
35c35
< genericIndex ∷ (Integral n, Show n) ⇒ Stream α → n → α
---
> genericIndex :: (Integral n, Show n) => Stream α -> n -> α
39c39
< genericReplicate ∷ Integral n ⇒ n → α → Stream α
---
> genericReplicate :: Integral n => n -> α -> Stream α
43c43
< genericUnfoldrN ∷ Integral n ⇒ n → (β → Maybe (α, β)) → β → Stream α
---
> genericUnfoldrN :: Integral n => n -> (β -> Maybe (α, β)) -> β -> Stream α
47c47
< genericFindIndex ∷ Integral n ⇒ (α → Bool) → Stream α → Maybe n
---
> genericFindIndex :: Integral n => (α -> Bool) -> Stream α -> Maybe n
51c51
< genericIndexed ∷ Integral n ⇒ Stream α → Stream (n, α)
---
> genericIndexed :: Integral n => Stream α -> Stream (n, α)
53a54
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    UnicodeSyntax
  #-}
-- | Some functions currently missing from
-- "Data.Vector.Fusion.Stream".
module Data.Bitstream.Fusion
    ( genericLength
    , genericTake
    , genericDrop
    , genericIndex
    , genericReplicate
    , genericUnfoldrN
    , genericFindIndex
    , genericIndexed
    )
    where
import qualified Data.Bitstream.Fusion.Monadic as M
import Data.Vector.Fusion.Stream
import Data.Vector.Fusion.Util
import Prelude hiding (replicate)
import Prelude.Unicode

genericLength ∷ Num n ⇒ Stream α → n
{-# INLINE genericLength #-}
genericLength = unId ∘ M.genericLength

genericTake ∷ Integral n ⇒ n → Stream α → Stream α
{-# INLINE genericTake #-}
genericTake = M.genericTake

genericDrop ∷ Integral n ⇒ n → Stream α → Stream α
{-# INLINE genericDrop #-}
genericDrop = M.genericDrop

genericIndex ∷ (Integral n, Show n) ⇒ Stream α → n → α
{-# INLINE genericIndex #-}
genericIndex s = unId ∘ M.genericIndex s

genericReplicate ∷ Integral n ⇒ n → α → Stream α
{-# INLINE genericReplicate #-}
genericReplicate = M.genericReplicate

genericUnfoldrN ∷ Integral n ⇒ n → (β → Maybe (α, β)) → β → Stream α
{-# INLINE genericUnfoldrN #-}
genericUnfoldrN = M.genericUnfoldrN

genericFindIndex ∷ Integral n ⇒ (α → Bool) → Stream α → Maybe n
{-# INLINE genericFindIndex #-}
genericFindIndex f = unId ∘ M.genericFindIndex f

genericIndexed ∷ Integral n ⇒ Stream α → Stream (n, α)
{-# INLINE genericIndexed #-}
genericIndexed = M.genericIndexed
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    UnicodeSyntax
  #-}
-- | Some functions currently missing from
-- "Data.Vector.Fusion.Stream".
module Data.Bitstream.Fusion
    ( genericLength
    , genericTake
    , genericDrop
    , genericIndex
    , genericReplicate
    , genericUnfoldrN
    , genericFindIndex
    , genericIndexed
    )
    where
import qualified Data.Bitstream.Fusion.Monadic as M
import Data.Vector.Fusion.Stream
import Data.Vector.Fusion.Util
import Prelude hiding (replicate)
import Prelude.Unicode

genericLength :: Num n => Stream α -> n
{-# INLINE genericLength #-}
genericLength = unId ∘ M.genericLength

genericTake :: Integral n => n -> Stream α -> Stream α
{-# INLINE genericTake #-}
genericTake = M.genericTake

genericDrop :: Integral n => n -> Stream α -> Stream α
{-# INLINE genericDrop #-}
genericDrop = M.genericDrop

genericIndex :: (Integral n, Show n) => Stream α -> n -> α
{-# INLINE genericIndex #-}
genericIndex s = unId ∘ M.genericIndex s

genericReplicate :: Integral n => n -> α -> Stream α
{-# INLINE genericReplicate #-}
genericReplicate = M.genericReplicate

genericUnfoldrN :: Integral n => n -> (β -> Maybe (α, β)) -> β -> Stream α
{-# INLINE genericUnfoldrN #-}
genericUnfoldrN = M.genericUnfoldrN

genericFindIndex :: Integral n => (α -> Bool) -> Stream α -> Maybe n
{-# INLINE genericFindIndex #-}
genericFindIndex f = unId ∘ M.genericFindIndex f

genericIndexed :: Integral n => Stream α -> Stream (n, α)
{-# INLINE genericIndexed #-}
genericIndexed = M.genericIndexed

</pre>