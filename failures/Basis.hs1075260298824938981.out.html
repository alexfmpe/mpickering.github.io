<a href="Base58Address.hs340756291478446501.out.html">prev</a></br><a href="failures.html">home</a></br><a href="bench.hs1108728549685118024.out.html">next</a></br></br><pre>5d4
< ----------------------------------------------------------------------
6d4
< -- |
7d4
< -- Module      :  Data.Basis
8d4
< -- Copyright   :  (c) Conal Elliott 2008
9d4
< -- License     :  BSD3
10d4
< --
11d4
< -- Maintainer  :  conal@conal.net
12d4
< -- Stability   :  experimental
13d4
< --
14d4
< -- Basis of a vector space, as an associated type
15c5
< -- This module requires ghc-6.10 or later
---
> {-# OPTIONS_GHC -Wall -fno-warn-orphans #-}----------------------------------------------------------------------
15a6
> -- |----------------------------------------------------------------------
15a7
> -- |-- Module      :  Data.Basis
15a8
> -- Module      :  Data.Basis-- Copyright   :  (c) Conal Elliott 2008
15a9
> -- License     :  BSD3-- Copyright   :  (c) Conal Elliott 2008
15a10
> ---- License     :  BSD3
15a11
> ---- Maintainer  :  conal@conal.net
15a12
> -- Stability   :  experimental-- Maintainer  :  conal@conal.net
15a13
> ---- Stability   :  experimental
15a14
> ---- Basis of a vector space, as an associated type
15a15
> -- This module requires ghc-6.10 or later-- Basis of a vector space, as an associated type
15a16
> -- This module requires ghc-6.10 or later----------------------------------------------------------------------
17d17
< 
19c19
< 
---
> module Data.Basis (HasBasis(..), linearCombo, recompose) where
21d20
< import Control.Arrow (first)
22d20
< import Data.Ratio
23c21
< import Foreign.C.Types (CFloat, CDouble)
---
> import-- import Control.Applicative ((<$>))Control.Arrow (first)
23a22
> import Control.ArrowData.Ratio    (first)
23a23
> import Data.RatioForeign.C.Types (CFloat, CDouble)
23a24
> import-- import Data.EitherForeign.C.Types (CFloat, CDouble)
25d25
< 
27c27
< 
---
> import Data.VectorSpace
28a29
> -- around ghc bug <http://hackage.haskell.org/trac/ghc/ticket/3038>-- using associated data type instead of associated type synonym to work
30d30
< 
32d31
<   -- | Representation of the canonical basis for @v@
33d31
<   type Basis v :: *
34d31
<   -- | Interpret basis rep as a vector
35d31
<   basisValue   :: Basis v -> v
36d31
<   -- | Extract coordinates
37d31
<   decompose    :: v -> [(Basis v, Scalar v)]
38d31
<   -- | Experimental version.  More elegant definitions, and friendly to
39c32
<   -- infinite-dimensional vector spaces.
---
> class-- | Representation of the canonical basis for @v@ v => HasBasis v where
39a33
>   type-- | Representation of the canonical basis for @v@Basis v :: *
39a34
>   type-- | Interpret basis rep as a vector v :: *
39a35
>   basisValue-- | Interpret basis rep as a vector:: Basis v -> v
39a36
>   basisValue-- | Extract coordinates:: Basis v -> v
39a37
>   decompose-- | Extract coordinates:: v -> [(Basis v, Scalar v)]
39a38
>   decompose-- | Experimental version.  More elegant definitions, and friendly to:: v -> [(Basis v, Scalar v)]
39a39
>   -- infinite-dimensional vector spaces.-- | Experimental version.  More elegant definitions, and friendly to
39a40
>   decompose'-- infinite-dimensional vector spaces.:: v -> (Basis v -> Scalar v)
41d41
< 
43c43
< 
---
> -- Defining property: recompose . decompose == id
45c45
< recompose :: HasBasis v => [(Basis v, Scalar v)] -> v
---
> recompose-- Turn a basis decomposition back into a vector.:: HasBasis v => [(Basis v, Scalar v)] -> v
45a46
> recompose ::= linearCombo v =>. fmap(Basis(first, ScalarbasisValue)])-> v
47d47
< 
49c49
< 
---
> -- recompose ps = linearCombo (first basisValue <$> ps)
51d50
< --
52d50
< --   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
53d50
< --
54c51
< -- However, I don't seem to use recompose anywhere.
---
> ---- I don't know how to define
54a52
> ----   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
54a53
> ----   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
54a54
> ---- However, I don't seem to use recompose anywhere.
54a55
> -- I don't even use basisValue or decompose.-- However, I don't seem to use recompose anywhere.
56d56
< 
67d66
< ScalarType(CFloat)
68d66
< ScalarType(Double)
69d66
< ScalarType(CDouble)
70d66
< ScalarTypeCon(Integral a, Ratio a)
71c67
< 
---
> instanceScalarType)CFloat=> HasBasis)      (Float) where { type Basis (Float) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
71a68
> instanceScalarType)Double=> HasBasis)      (CFloat) where { type Basis (CFloat) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
71a69
> instanceScalarType)CDouble=> HasBasis)     (Double) where { type Basis (Double) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
71a70
> instanceScalarTypeCon) =>(Integrala(CDoubleRatio ))where { type Basis (CDouble) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
71a71
> instance Integral a => HasBasis ( Ratio a) where { type Basis ( Ratio a) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
73d72
<          , HasBasis v, s ~ Scalar v )
74d72
<       => HasBasis (u,v) where
75d72
<   type Basis (u,v)     = Basis u `Either` Basis v
76d72
<   basisValue (Left  a) = (basisValue a, zeroV)
77d72
<   basisValue (Right b) = (zeroV, basisValue b)
78c73
<   decompose  (u,v)     = decomp2 Left u ++ decomp2 Right v
---
> instance ( HasBasis u, s ~ Scalar u )
78a74
>       => ,HasBasis(uv,)swhere~ Scalar v )
78a75
>   type=>Basis(u,v)(u,v)=whereBasis u `Either` Basis v
78a76
>   typebasisValue (uLeft,v)  a) = Basis(basisValue `Eithera, `zeroV)  v
78a77
>   basisValue (LeftRight a) = (basisValuezeroV, basisValue, zeroVb)
78a78
>   basisValuedecompose  (Rightu,v)  b) = (decomp2zeroV, basisValueLeft u ++ decomp2)     Right v
78a79
>   decomposedecompose' (u,v)     = decomp2decompose'u ueither decomp2` decompose' vv
81d81
< 
82a83
> decomp2 ::inject= fmap =>(firstBasisinject ->) b)decompose-> w -> [(b, Scalar w)]
84d84
< 
86d85
<          , HasBasis v, s ~ Scalar v
87d85
<          , HasBasis w, s ~ Scalar w )
88d85
<       => HasBasis (u,v,w) where
89d85
<   type Basis (u,v,w) = Basis (u,(v,w))
90d85
<   basisValue         = unnest3 . basisValue
91c86
<   decompose          = decompose  . nest3
---
> instance ( HasBasis u, s ~ Scalar u
91a87
>          , HasBasis v, s ~ Scalar v )
91a88
>       => ,HasBasis(uw,,s)~where w )
91a89
>   type=>Basis(u,v,(u,v,wBasis) where(u,(v,w))
91a90
>   typebasisValue (u,v,w) = Basisunnest3u,(vbasisValue,w))
91a91
>   basisValuedecompose          = unnest3decompose basisValue. nest3
91a92
>   decomposedecompose'         = decomposedecompose' . nest3
93d93
< 
94a95
> unnest3 ::(a,(a,(b,c))(->a,b(a,b,c)
96d96
< 
97a98
> nest3 ::(a,(a,b,c)(->a,((a,(b,c))
100d100
< 
102d101
< --   type Basis (a -> u) = (a, Basis u)
103d101
< --   basisValue (a,b) = f
104d101
< --     where f a' | a == a'   = bv
105d101
< --                | otherwise = zeroV
106d101
< --           bv = basisValue b
107c102
< --   decompose = error "decompose: not defined on functions"
---
> --   type Basis (a -> u) = (a, Basis u)-- instance (Eq a, HasBasis u) => HasBasis (a -> u) where
107a103
> --   basisValue (a,b) = f--   type Basis (a -> u) = (a, Basis u)
107a104
> --   basisValue (a,b) = f--     where f a' | a == a'   = bv
107a105
> --     where f a' | a == a'   = bv--                | otherwise = zeroV
107a106
> --           bv = basisValue b--                | otherwise = zeroV
107a107
> --           bv = basisValue b--   decompose = error "decompose: not defined on functions"
107a108
> --   decompose' g (a,b) = decompose' (g a) b--   decompose = error "decompose: not defined on functions"
110d110
< 
112d111
< --
113c112
< --   basisValue (a,b) a' | a == a'   = basisValue b
---
> ---- Simpler but less efficient:
113a113
> ----   basisValue (a,b) a' | a == a'   = basisValue b
113a114
> --                       | otherwise = zeroV--   basisValue (a,b) a' | a == a'   = basisValue b
115d115
< 
117d116
< --
118d116
< --   decompose' g = uncurry (\ a b -> decompose' (g a) b)
119d116
< --   decompose' g = uncurry (\ a -> decompose' (g a))
120d116
< --   decompose' g = uncurry (decompose' . g)
121c117
< --   decompose' = uncurry . fmap decompose'
---
> ---- Just for pointless perversion points:
121a118
> ----   decompose' g = uncurry (\ a b -> decompose' (g a) b)
121a119
> --   decompose' g = uncurry (\ a -> decompose' (g a))--   decompose' g = uncurry (\ a b -> decompose' (g a) b)
121a120
> --   decompose' g = uncurry (decompose' . g)--   decompose' g = uncurry (\ a -> decompose' (g a))
121a121
> --   decompose' = uncurry . fmap decompose'--   decompose' g = uncurry (decompose' . g)
121a122
> --   decompose' = uncurry . fmap decompose'--   decompose' = (fmap uncurry) (fmap decompose')
124d124
< 
134a135
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeOperators, TypeFamilies, UndecidableInstances
  , FlexibleInstances, MultiParamTypeClasses, CPP
  #-}
{-# OPTIONS_GHC -Wall -fno-warn-orphans #-}
----------------------------------------------------------------------
-- |
-- Module      :  Data.Basis
-- Copyright   :  (c) Conal Elliott 2008
-- License     :  BSD3
--
-- Maintainer  :  conal@conal.net
-- Stability   :  experimental
--
-- Basis of a vector space, as an associated type
-- This module requires ghc-6.10 or later
----------------------------------------------------------------------

module Data.Basis (HasBasis(..), linearCombo, recompose) where

-- import Control.Applicative ((<$>))
import Control.Arrow (first)
import Data.Ratio
import Foreign.C.Types (CFloat, CDouble)
-- import Data.Either

import Data.VectorSpace

-- using associated data type instead of associated type synonym to work
-- around ghc bug <http://hackage.haskell.org/trac/ghc/ticket/3038>

class VectorSpace v => HasBasis v where
  -- | Representation of the canonical basis for @v@
  type Basis v :: *
  -- | Interpret basis rep as a vector
  basisValue   :: Basis v -> v
  -- | Extract coordinates
  decompose    :: v -> [(Basis v, Scalar v)]
  -- | Experimental version.  More elegant definitions, and friendly to
  -- infinite-dimensional vector spaces.
  decompose'   :: v -> (Basis v -> Scalar v)

-- Defining property: recompose . decompose == id

-- Turn a basis decomposition back into a vector.
recompose :: HasBasis v => [(Basis v, Scalar v)] -> v
recompose = linearCombo . fmap (first basisValue)

-- recompose ps = linearCombo (first basisValue <$> ps)

-- I don't know how to define
--
--   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
--
-- However, I don't seem to use recompose anywhere.
-- I don't even use basisValue or decompose.

#define ScalarTypeCon(con,t) \
  instance con => HasBasis (t) where \
    { type Basis (t) = () \
    ; basisValue ()  = 1 \
    ; decompose s    = [((),s)] \
    ; decompose' s   = const s }

#define ScalarType(t) ScalarTypeCon((),t)

ScalarType(Float)
ScalarType(CFloat)
ScalarType(Double)
ScalarType(CDouble)
ScalarTypeCon(Integral a, Ratio a)

instance ( HasBasis u, s ~ Scalar u
         , HasBasis v, s ~ Scalar v )
      => HasBasis (u,v) where
  type Basis (u,v)     = Basis u `Either` Basis v
  basisValue (Left  a) = (basisValue a, zeroV)
  basisValue (Right b) = (zeroV, basisValue b)
  decompose  (u,v)     = decomp2 Left u ++ decomp2 Right v
  decompose' (u,v)     = decompose' u `either` decompose' v


decomp2 :: HasBasis w => (Basis w -> b) -> w -> [(b, Scalar w)]
decomp2 inject = fmap (first inject) . decompose

instance ( HasBasis u, s ~ Scalar u
         , HasBasis v, s ~ Scalar v
         , HasBasis w, s ~ Scalar w )
      => HasBasis (u,v,w) where
  type Basis (u,v,w) = Basis (u,(v,w))
  basisValue         = unnest3 . basisValue
  decompose          = decompose  . nest3
  decompose'         = decompose' . nest3

unnest3 :: (a,(b,c)) -> (a,b,c)
unnest3 (a,(b,c)) = (a,b,c)

nest3 :: (a,b,c) -> (a,(b,c))
nest3 (a,b,c) = (a,(b,c))


-- instance (Eq a, HasBasis u) => HasBasis (a -> u) where
--   type Basis (a -> u) = (a, Basis u)
--   basisValue (a,b) = f
--     where f a' | a == a'   = bv
--                | otherwise = zeroV
--           bv = basisValue b
--   decompose = error "decompose: not defined on functions"
--   decompose' g (a,b) = decompose' (g a) b


-- Simpler but less efficient:
--
--   basisValue (a,b) a' | a == a'   = basisValue b
--                       | otherwise = zeroV

-- Just for pointless perversion points:
--
--   decompose' g = uncurry (\ a b -> decompose' (g a) b)
--   decompose' g = uncurry (\ a -> decompose' (g a))
--   decompose' g = uncurry (decompose' . g)
--   decompose' = uncurry . fmap decompose'
--   decompose' = (fmap uncurry) (fmap decompose')


{-

---- Testing

t1 = basisValue () :: Float
t2 = basisValue () :: Double
t3 = basisValue (Right ()) :: (Float,Double)
t4 = basisValue (Right (Left ())) :: (Float,Double,Float)

-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeOperators, TypeFamilies, UndecidableInstances
  , FlexibleInstances, MultiParamTypeClasses, CPP
  #-}
{-# OPTIONS_GHC -Wall -fno-warn-orphans #-}
{-# OPTIONS_GHC -Wall -fno-warn-orphans #-}----------------------------------------------------------------------
-- |----------------------------------------------------------------------
-- |-- Module      :  Data.Basis
-- Module      :  Data.Basis-- Copyright   :  (c) Conal Elliott 2008
-- License     :  BSD3-- Copyright   :  (c) Conal Elliott 2008
---- License     :  BSD3
---- Maintainer  :  conal@conal.net
-- Stability   :  experimental-- Maintainer  :  conal@conal.net
---- Stability   :  experimental
---- Basis of a vector space, as an associated type
-- This module requires ghc-6.10 or later-- Basis of a vector space, as an associated type
-- This module requires ghc-6.10 or later----------------------------------------------------------------------
----------------------------------------------------------------------
module Data.Basis (HasBasis(..), linearCombo, recompose) where
module Data.Basis (HasBasis(..), linearCombo, recompose) where
-- import Control.Applicative ((<$>))
import-- import Control.Applicative ((<$>))Control.Arrow (first)
import Control.ArrowData.Ratio    (first)
import Data.RatioForeign.C.Types (CFloat, CDouble)
import-- import Data.EitherForeign.C.Types (CFloat, CDouble)
-- import Data.Either
import Data.VectorSpace
import Data.VectorSpace
-- using associated data type instead of associated type synonym to work
-- around ghc bug <http://hackage.haskell.org/trac/ghc/ticket/3038>-- using associated data type instead of associated type synonym to work
-- around ghc bug <http://hackage.haskell.org/trac/ghc/ticket/3038>
class VectorSpace v => HasBasis v where
class-- | Representation of the canonical basis for @v@ v => HasBasis v where
  type-- | Representation of the canonical basis for @v@Basis v :: *
  type-- | Interpret basis rep as a vector v :: *
  basisValue-- | Interpret basis rep as a vector:: Basis v -> v
  basisValue-- | Extract coordinates:: Basis v -> v
  decompose-- | Extract coordinates:: v -> [(Basis v, Scalar v)]
  decompose-- | Experimental version.  More elegant definitions, and friendly to:: v -> [(Basis v, Scalar v)]
  -- infinite-dimensional vector spaces.-- | Experimental version.  More elegant definitions, and friendly to
  decompose'-- infinite-dimensional vector spaces.:: v -> (Basis v -> Scalar v)
  decompose'   :: v -> (Basis v -> Scalar v)
-- Defining property: recompose . decompose == id
-- Defining property: recompose . decompose == id
-- Turn a basis decomposition back into a vector.
recompose-- Turn a basis decomposition back into a vector.:: HasBasis v => [(Basis v, Scalar v)] -> v
recompose ::= linearCombo v =>. fmap(Basis(first, ScalarbasisValue)])-> v
recompose = linearCombo . fmap (first basisValue)
-- recompose ps = linearCombo (first basisValue <$> ps)
-- recompose ps = linearCombo (first basisValue <$> ps)
-- I don't know how to define
---- I don't know how to define
----   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
----   recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
---- However, I don't seem to use recompose anywhere.
-- I don't even use basisValue or decompose.-- However, I don't seem to use recompose anywhere.
-- I don't even use basisValue or decompose.
#define ScalarTypeCon(con,t) \
  instance con => HasBasis (t) where \
    { type Basis (t) = () \
    ; basisValue ()  = 1 \
    ; decompose s    = [((),s)] \
    ; decompose' s   = const s }

#define ScalarType(t) ScalarTypeCon((),t)

ScalarType(Float)
instanceScalarType)CFloat=> HasBasis)      (Float) where { type Basis (Float) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
instanceScalarType)Double=> HasBasis)      (CFloat) where { type Basis (CFloat) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
instanceScalarType)CDouble=> HasBasis)     (Double) where { type Basis (Double) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
instanceScalarTypeCon) =>(Integrala(CDoubleRatio ))where { type Basis (CDouble) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
instance Integral a => HasBasis ( Ratio a) where { type Basis ( Ratio a) = () ; basisValue () = 1 ; decompose s = [((),s)] ; decompose' s   = const s }
instance ( HasBasis u, s ~ Scalar u
instance ( HasBasis u, s ~ Scalar u )
      => ,HasBasis(uv,)swhere~ Scalar v )
  type=>Basis(u,v)(u,v)=whereBasis u `Either` Basis v
  typebasisValue (uLeft,v)  a) = Basis(basisValue `Eithera, `zeroV)  v
  basisValue (LeftRight a) = (basisValuezeroV, basisValue, zeroVb)
  basisValuedecompose  (Rightu,v)  b) = (decomp2zeroV, basisValueLeft u ++ decomp2)     Right v
  decomposedecompose' (u,v)     = decomp2decompose'u ueither decomp2` decompose' vv
  decompose' (u,v)     = decompose' u `either` decompose' v

decomp2 :: HasBasis w => (Basis w -> b) -> w -> [(b, Scalar w)]
decomp2 ::inject= fmap =>(firstBasisinject ->) b)decompose-> w -> [(b, Scalar w)]
decomp2 inject = fmap (first inject) . decompose
instance ( HasBasis u, s ~ Scalar u
instance ( HasBasis u, s ~ Scalar u
         , HasBasis v, s ~ Scalar v )
      => ,HasBasis(uw,,s)~where w )
  type=>Basis(u,v,(u,v,wBasis) where(u,(v,w))
  typebasisValue (u,v,w) = Basisunnest3u,(vbasisValue,w))
  basisValuedecompose          = unnest3decompose basisValue. nest3
  decomposedecompose'         = decomposedecompose' . nest3
  decompose'         = decompose' . nest3
unnest3 :: (a,(b,c)) -> (a,b,c)
unnest3 ::(a,(a,(b,c))(->a,b(a,b,c)
unnest3 (a,(b,c)) = (a,b,c)
nest3 :: (a,b,c) -> (a,(b,c))
nest3 ::(a,(a,b,c)(->a,((a,(b,c))
nest3 (a,b,c) = (a,(b,c))

-- instance (Eq a, HasBasis u) => HasBasis (a -> u) where
--   type Basis (a -> u) = (a, Basis u)-- instance (Eq a, HasBasis u) => HasBasis (a -> u) where
--   basisValue (a,b) = f--   type Basis (a -> u) = (a, Basis u)
--   basisValue (a,b) = f--     where f a' | a == a'   = bv
--     where f a' | a == a'   = bv--                | otherwise = zeroV
--           bv = basisValue b--                | otherwise = zeroV
--           bv = basisValue b--   decompose = error "decompose: not defined on functions"
--   decompose' g (a,b) = decompose' (g a) b--   decompose = error "decompose: not defined on functions"
--   decompose' g (a,b) = decompose' (g a) b

-- Simpler but less efficient:
---- Simpler but less efficient:
----   basisValue (a,b) a' | a == a'   = basisValue b
--                       | otherwise = zeroV--   basisValue (a,b) a' | a == a'   = basisValue b
--                       | otherwise = zeroV
-- Just for pointless perversion points:
---- Just for pointless perversion points:
----   decompose' g = uncurry (\ a b -> decompose' (g a) b)
--   decompose' g = uncurry (\ a -> decompose' (g a))--   decompose' g = uncurry (\ a b -> decompose' (g a) b)
--   decompose' g = uncurry (decompose' . g)--   decompose' g = uncurry (\ a -> decompose' (g a))
--   decompose' = uncurry . fmap decompose'--   decompose' g = uncurry (decompose' . g)
--   decompose' = uncurry . fmap decompose'--   decompose' = (fmap uncurry) (fmap decompose')
--   decompose' = (fmap uncurry) (fmap decompose')

{-

---- Testing

t1 = basisValue () :: Float
t2 = basisValue () :: Double
t3 = basisValue (Right ()) :: (Float,Double)
t4 = basisValue (Right (Left ())) :: (Float,Double,Float)

-}

</pre>