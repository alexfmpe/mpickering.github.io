<a href="ParserState.hs1148079871137522503.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Parsing.hs1148079871137522503.out.html">next</a></br></br><pre>17c17
< {-# LINE 34 "src/ehc/Base/ParseUtils.chs" #-}
---
> 
17a18
> 
17a19
> 
17a20
> 
17a21
> 
17a22
> 
17a23
> 
17a24
> 
17a25
> 
17a26
> 
17a27
> 
17a28
> 
17a29
> 
17a30
> 
17a31
> 
17a32
> 
17a33
> 
20c36
< {-# LINE 42 "src/ehc/Base/ParseUtils.chs" #-}
---
> 
20a37
> 
20a38
> 
20a39
> 
20a40
> 
20a41
> 
25a47
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.ParseUtils
( P
, parseString )
where
import UHC.Light.Compiler.Base.Common
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Base.HsName
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import Data.Version
import Data.List

{-# LINE 34 "src/ehc/Base/ParseUtils.chs" #-}
type P p = PlainParser Token p

{-# LINE 42 "src/ehc/Base/ParseUtils.chs" #-}
parseString :: ScanOpts -> P res -> String -> Maybe res
parseString scanOpts p s
  = if null errs then Just res else Nothing
  where tokens     = scan scanOpts (initPos s) s
        (res,errs) = parseToResMsgs p tokens
</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.ParseUtils
( P
, parseString )
where
import UHC.Light.Compiler.Base.Common
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Base.HsName
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import Data.Version
import Data.List


















type P p = PlainParser Token p







parseString :: ScanOpts -> P res -> String -> Maybe res
parseString scanOpts p s
  = if null errs then Just res else Nothing
  where tokens     = scan scanOpts (initPos s) s
        (res,errs) = parseToResMsgs p tokens

</pre>