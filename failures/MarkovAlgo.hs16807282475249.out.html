<a href="MapReduce.hs2035308228158374933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Markups.hs340756291478446501.out.html">next</a></br></br><pre>30c30
< antecedent ∷ Rule c → [c]
---
> antecedent :: Rule c -> [c]
35c35
< consequent ∷ Rule c → [c]
---
> consequent :: Rule c -> [c]
40c40
< constructor ∷ Rule c → ([d] → [d] → Rule d)
---
> constructor :: Rule c -> ([d] -> [d] -> Rule d)
52c52
< isChar ∷ Var α → Bool
---
> isChar :: Var α -> Bool
56c56
< isVar ∷ Var α → Bool
---
> isVar :: Var α -> Bool
60d59
< expand ∷ Eq α
61d59
<        ⇒ [α]               -- ^ Alphabet
62d59
<        → Algo (Var α)      -- ^ Algorithm with variables
63c60
<        → Algo α
---
> expand :: Eq α
63a61
>        => [α]               -- ^ Alphabet
63a62
>        -> Algo (Var α)      -- ^ Algorithm with variables
63a63
>        -> Algo α
66c66
< expandRule ∷ Eq α ⇒ [α] → Rule (Var α) → [Rule α]
---
> expandRule :: Eq α => [α] -> Rule (Var α) -> [Rule α]
69c69
< toChar ∷ Rule (Var α) → Rule α
---
> toChar :: Rule (Var α) -> Rule α
72c72
<     toChar' ∷ [Var α] → [α]
---
>     toChar' :: [Var α] -> [α]
78d77
< expandRule' ∷ [α] → Rule (Var α) → [Rule (Var α)]
79c78
< expandRule' 𝔞 rule = [(constructor rule) a c | (a,c) ← expandString 𝔞 (antecedent rule) (consequent rule)]
---
> expandRule' :: [α] -> Rule (Var α) -> [Rule (Var α)]
79a79
> expandRule' 𝔞 rule = [(constructor rule) a c | (a,c) <- expandString 𝔞 (antecedent rule) (consequent rule)]
81c81
< expandString ∷ [α] → [Var α] → [Var α] → [([Var α], [Var α])]
---
> expandString :: [α] -> [Var α] -> [Var α] -> [([Var α], [Var α])]
87c87
< subst ∷ [Var α] → [Var α] → [α] → ([Var α], [Var α])
---
> subst :: [Var α] -> [Var α] -> [α] -> ([Var α], [Var α])
95c95
< parseString ∷ Eq α ⇒ [α] → [α] → [Var α]
---
> parseString :: Eq α => [α] -> [α] -> [Var α]
99d98
<                 Nothing → L c
100c99
<                 Just n  → V n
---
>                 Nothing -> L c
100a100
>                 Just n  -> V n
103d102
< parseRule ∷ Eq α
104d102
<           ⇒ [α]    -- ^ Names of variables
105d102
<           → Rule α -- ^ Concrete rule
106c103
<           → Rule (Var α)
---
> parseRule :: Eq α
106a104
>           => [α]    -- ^ Names of variables
106a105
>           -> Rule α -- ^ Concrete rule
106a106
>           -> Rule (Var α)
109c109
< replace ∷ Eq α ⇒ [α] → [α] → [α] → [α]
---
> replace :: Eq α => [α] -> [α] -> [α] -> [α]
115c115
< applyRule ∷ Eq α ⇒ Rule α → [α] → (Maybe [α], Bool)
---
> applyRule :: Eq α => Rule α -> [α] -> (Maybe [α], Bool)
122c122
< shouldStop ∷ Rule c → Bool
---
> shouldStop :: Rule c -> Bool
127d126
< runMarkov ∷ Eq α
128d126
<           ⇒ Algo α       -- ^ Algorithm itself
129d126
<           → [α]          -- ^ Start string
130c127
<           → [α]
---
> runMarkov :: Eq α
130a128
>           => Algo α       -- ^ Algorithm itself
130a129
>           -> [α]          -- ^ Start string
130a130
>           -> [α]
133c133
<     runMarkov' :: Eq α ⇒ Algo α → Algo α → [α] → [α]
---
>     runMarkov' :: Eq α => Algo α -> Algo α -> [α] -> [α]
137d136
<         (Just res, False) → runMarkov' algo algo res
138d136
<         (Just res, True)  → res
139c137
<         (Nothing,  _)     → runMarkov' algo rs s
---
>         (Just res, False) -> runMarkov' algo algo res
139a138
>         (Just res, True)  -> res
139a139
>         (Nothing,  _)     -> runMarkov' algo rs s
142d141
< buildAlgo ∷ Eq α
143d141
<           ⇒ [α]     -- ^ Alphabet
144d141
<           → [α]     -- ^ Names of variables
145d141
<           → Algo α  -- ^ Description of algorithm
146c142
<           → Algo α
---
> buildAlgo :: Eq α
146a143
>           => [α]     -- ^ Alphabet
146a144
>           -> [α]     -- ^ Names of variables
146a145
>           -> Algo α  -- ^ Description of algorithm
146a146
>           -> Algo α
148a149
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Data.MarkovAlgo
  (Algo, Rule (..), Var (..),
   antecedent, consequent, constructor,
   expand,
   parseRule,
   buildAlgo,
   runMarkov)
  where

import Data.List

-- | Markov's algorithm itself
type Algo c = [Rule c]

-- | One rule in algorithm
data Rule c = [c] :-> [c]   -- ^ Non-terminating rule
            | [c] :->. [c]  -- ^ Terminating rule
  deriving (Eq)

instance Show (Rule Char) where
  show (a :-> s) = a ++ " → " ++ s
  show (a :->. s) = a ++ " →. " ++ s

instance Show (Rule (Var Char)) where
  show (a :-> s) = show a ++ " → " ++ show s
  show (a :->. s) = show a ++ " →. " ++ show s

-- | Get antecedent of rule
antecedent ∷ Rule c → [c]
antecedent (xs :-> _) = xs
antecedent (xs :->. _) = xs

-- | Get consequent of rule
consequent ∷ Rule c → [c]
consequent (_ :-> ys) = ys
consequent (_ :->. ys) = ys

-- | Get data constructor of Rule
constructor ∷ Rule c → ([d] → [d] → Rule d)
constructor (_ :-> _) = (:->)
constructor (_ :->. _) = (:->.)

-- | Variable for rules
data Var α = L α    -- ^ Literal char
           | V Int  -- ^ Variable with given number

instance Show (Var Char) where
  show (L c) = [c]
  show (V c) = show c

isChar ∷ Var α → Bool
isChar (L _) = True
isChar _     = False

isVar ∷ Var α → Bool
isVar = not . isChar

-- | Expand algorithm with variables into algorithm without variables
expand ∷ Eq α
       ⇒ [α]               -- ^ Alphabet
       → Algo (Var α)      -- ^ Algorithm with variables
       → Algo α
expand 𝔞 = concatMap (expandRule 𝔞)

expandRule ∷ Eq α ⇒ [α] → Rule (Var α) → [Rule α]
expandRule 𝔞 rule = nub $ map toChar (expandRule' 𝔞 rule)

toChar ∷ Rule (Var α) → Rule α
toChar rule = (constructor rule) (toChar' $ antecedent rule) (toChar' $ consequent rule)
  where
    toChar' ∷ [Var α] → [α]
    toChar' = map toChar''

    toChar'' (L c) = c
    toChar'' (V _) = error "Internal error"

expandRule' ∷ [α] → Rule (Var α) → [Rule (Var α)]
expandRule' 𝔞 rule = [(constructor rule) a c | (a,c) ← expandString 𝔞 (antecedent rule) (consequent rule)]

expandString ∷ [α] → [Var α] → [Var α] → [([Var α], [Var α])]
expandString 𝔞 as cs
  = map (subst as cs) $ mapM (const 𝔞) [1..n]
      where
        n = length (filter isVar (as ++ cs))

subst ∷ [Var α] → [Var α] → [α] → ([Var α], [Var α])
subst as cs xs = (subst' as xs, subst' cs xs)
  where
    subst' []        _      = []
    subst' (L c: vs) cs = L c: subst' vs cs
    subst' (V n: vs) cs = L (cs !! n): subst' vs cs
    subst' (V _: _)  [] = error "Internal error: too few arguments in `subst'!"

parseString ∷ Eq α ⇒ [α] → [α] → [Var α]
parseString xs s = map toVar s
  where
    toVar c = case elemIndex c xs of
                Nothing → L c
                Just n  → V n

-- | Create generic Rule from concrete Rule
parseRule ∷ Eq α
          ⇒ [α]    -- ^ Names of variables
          → Rule α -- ^ Concrete rule
          → Rule (Var α)
parseRule xs rule = (constructor rule) (parseString xs $ antecedent rule) (parseString xs $ consequent rule)

replace ∷ Eq α ⇒ [α] → [α] → [α] → [α]
replace _ _ [] = []
replace old new s@(c:cs)
  | old `isPrefixOf` s = new ++ (drop (length old) s)
  | otherwise          = c: replace old new cs

applyRule ∷ Eq α ⇒ Rule α → [α] → (Maybe [α], Bool)
applyRule rule s | a `isInfixOf` s = (Just $ replace a c s, shouldStop rule)
                 | otherwise       = (Nothing, shouldStop rule)
                     where
                      a = antecedent rule
                      c = consequent rule

shouldStop ∷ Rule c → Bool
shouldStop (_ :-> _) = False
shouldStop (_ :->. _) = True

-- | Run concrete (without variables) Markov's algorithm
runMarkov ∷ Eq α
          ⇒ Algo α       -- ^ Algorithm itself
          → [α]          -- ^ Start string
          → [α]
runMarkov algo s = runMarkov' algo algo s
  where
    runMarkov' :: Eq α ⇒ Algo α → Algo α → [α] → [α]
    runMarkov' _ [] s = s
    runMarkov' algo (r:rs) s =
      case applyRule r s of
        (Just res, False) → runMarkov' algo algo res
        (Just res, True)  → res
        (Nothing,  _)     → runMarkov' algo rs s

-- | Build concrete algo from simple text description with variables
buildAlgo ∷ Eq α
          ⇒ [α]     -- ^ Alphabet
          → [α]     -- ^ Names of variables
          → Algo α  -- ^ Description of algorithm
          → Algo α
buildAlgo 𝔞 vs algo = expand 𝔞 $ map (parseRule vs) algo

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Data.MarkovAlgo
  (Algo, Rule (..), Var (..),
   antecedent, consequent, constructor,
   expand,
   parseRule,
   buildAlgo,
   runMarkov)
  where

import Data.List

-- | Markov's algorithm itself
type Algo c = [Rule c]

-- | One rule in algorithm
data Rule c = [c] :-> [c]   -- ^ Non-terminating rule
            | [c] :->. [c]  -- ^ Terminating rule
  deriving (Eq)

instance Show (Rule Char) where
  show (a :-> s) = a ++ " → " ++ s
  show (a :->. s) = a ++ " →. " ++ s

instance Show (Rule (Var Char)) where
  show (a :-> s) = show a ++ " → " ++ show s
  show (a :->. s) = show a ++ " →. " ++ show s

-- | Get antecedent of rule
antecedent :: Rule c -> [c]
antecedent (xs :-> _) = xs
antecedent (xs :->. _) = xs

-- | Get consequent of rule
consequent :: Rule c -> [c]
consequent (_ :-> ys) = ys
consequent (_ :->. ys) = ys

-- | Get data constructor of Rule
constructor :: Rule c -> ([d] -> [d] -> Rule d)
constructor (_ :-> _) = (:->)
constructor (_ :->. _) = (:->.)

-- | Variable for rules
data Var α = L α    -- ^ Literal char
           | V Int  -- ^ Variable with given number

instance Show (Var Char) where
  show (L c) = [c]
  show (V c) = show c

isChar :: Var α -> Bool
isChar (L _) = True
isChar _     = False

isVar :: Var α -> Bool
isVar = not . isChar

-- | Expand algorithm with variables into algorithm without variables
expand :: Eq α
       => [α]               -- ^ Alphabet
       -> Algo (Var α)      -- ^ Algorithm with variables
       -> Algo α
expand 𝔞 = concatMap (expandRule 𝔞)

expandRule :: Eq α => [α] -> Rule (Var α) -> [Rule α]
expandRule 𝔞 rule = nub $ map toChar (expandRule' 𝔞 rule)

toChar :: Rule (Var α) -> Rule α
toChar rule = (constructor rule) (toChar' $ antecedent rule) (toChar' $ consequent rule)
  where
    toChar' :: [Var α] -> [α]
    toChar' = map toChar''

    toChar'' (L c) = c
    toChar'' (V _) = error "Internal error"

expandRule' :: [α] -> Rule (Var α) -> [Rule (Var α)]
expandRule' 𝔞 rule = [(constructor rule) a c | (a,c) <- expandString 𝔞 (antecedent rule) (consequent rule)]

expandString :: [α] -> [Var α] -> [Var α] -> [([Var α], [Var α])]
expandString 𝔞 as cs
  = map (subst as cs) $ mapM (const 𝔞) [1..n]
      where
        n = length (filter isVar (as ++ cs))

subst :: [Var α] -> [Var α] -> [α] -> ([Var α], [Var α])
subst as cs xs = (subst' as xs, subst' cs xs)
  where
    subst' []        _      = []
    subst' (L c: vs) cs = L c: subst' vs cs
    subst' (V n: vs) cs = L (cs !! n): subst' vs cs
    subst' (V _: _)  [] = error "Internal error: too few arguments in `subst'!"

parseString :: Eq α => [α] -> [α] -> [Var α]
parseString xs s = map toVar s
  where
    toVar c = case elemIndex c xs of
                Nothing -> L c
                Just n  -> V n

-- | Create generic Rule from concrete Rule
parseRule :: Eq α
          => [α]    -- ^ Names of variables
          -> Rule α -- ^ Concrete rule
          -> Rule (Var α)
parseRule xs rule = (constructor rule) (parseString xs $ antecedent rule) (parseString xs $ consequent rule)

replace :: Eq α => [α] -> [α] -> [α] -> [α]
replace _ _ [] = []
replace old new s@(c:cs)
  | old `isPrefixOf` s = new ++ (drop (length old) s)
  | otherwise          = c: replace old new cs

applyRule :: Eq α => Rule α -> [α] -> (Maybe [α], Bool)
applyRule rule s | a `isInfixOf` s = (Just $ replace a c s, shouldStop rule)
                 | otherwise       = (Nothing, shouldStop rule)
                     where
                      a = antecedent rule
                      c = consequent rule

shouldStop :: Rule c -> Bool
shouldStop (_ :-> _) = False
shouldStop (_ :->. _) = True

-- | Run concrete (without variables) Markov's algorithm
runMarkov :: Eq α
          => Algo α       -- ^ Algorithm itself
          -> [α]          -- ^ Start string
          -> [α]
runMarkov algo s = runMarkov' algo algo s
  where
    runMarkov' :: Eq α => Algo α -> Algo α -> [α] -> [α]
    runMarkov' _ [] s = s
    runMarkov' algo (r:rs) s =
      case applyRule r s of
        (Just res, False) -> runMarkov' algo algo res
        (Just res, True)  -> res
        (Nothing,  _)     -> runMarkov' algo rs s

-- | Build concrete algo from simple text description with variables
buildAlgo :: Eq α
          => [α]     -- ^ Alphabet
          -> [α]     -- ^ Names of variables
          -> Algo α  -- ^ Description of algorithm
          -> Algo α
buildAlgo 𝔞 vs algo = expand 𝔞 $ map (parseRule vs) algo


</pre>