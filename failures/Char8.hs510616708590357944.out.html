<a href="Char8.hs195400260589673557.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Ciphers.hs828530767832633821.out.html">next</a></br></br><pre>12c12
< #endif
---
> #endif{-# LANGUAGE Trustworthy #-}
15c15
< 
---
> {-# OPTIONS_GHC -fno-warn-orphans #-}
17d16
< -- Module      : Data.Vector.Storable.ByteString.Char8
18d16
< -- Copyright   : (c) Don Stewart 2006-2008
19d16
< --               (c) Bas van Dijk 2011
20d16
< -- License     : BSD-style
21d16
< --
22d16
< -- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
23d16
< -- Stability   : experimental
24d16
< --
25d16
< -- Manipulate 'ByteString's using 'Char' operations. All Chars will be
26d16
< -- truncated to 8 bits. It can be expected that these functions will run
27d16
< -- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
28c17
< --
---
> -- |-- Module      : Data.Vector.Storable.ByteString.Char8
28a18
> -- Copyright   : (c) Don Stewart 2006-2008-- Module      : Data.Vector.Storable.ByteString.Char8
28a19
> --               (c) Bas van Dijk 2011-- Copyright   : (c) Don Stewart 2006-2008
28a20
> -- License     : BSD-style--               (c) Bas van Dijk 2011
28a21
> ---- License     : BSD-style
28a22
> ---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
28a23
> -- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
28a24
> ---- Stability   : experimental
28a25
> ---- Manipulate 'ByteString's using 'Char' operations. All Chars will be
28a26
> -- Manipulate 'ByteString's using 'Char' operations. All Chars will be-- truncated to 8 bits. It can be expected that these functions will run
28a27
> -- truncated to 8 bits. It can be expected that these functions will run-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
28a28
> ---- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
28a29
> ---- More specifically these byte strings are taken to be in the
31d31
< -- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
32d31
< --
33d31
< -- See:
34d31
< --
35d31
< --  * <http://www.unicode.org/charts/>
36d31
< --
37d31
< --  * <http://www.unicode.org/charts/PDF/U0000.pdf>
38d31
< --
39d31
< --  * <http://www.unicode.org/charts/PDF/U0080.pdf>
40d31
< --
41d31
< -- This module is intended to be imported @qualified@, to avoid name
42d31
< -- clashes with "Prelude" functions.  eg.
43d31
< --
44d31
< -- > import qualified Data.Vector.Storable.ByteString.Char8 as B
45d31
< --
46d31
< -- The Char8 interface to bytestrings provides an instance of IsString
47d31
< -- for the ByteString type, enabling you to use string literals, and
48d31
< -- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
49c32
< -- to enable this.
---
> ---- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
49a33
> ---- See:
49a34
> ---- See:
49a35
> ----  * <http://www.unicode.org/charts/>
49a36
> ----  * <http://www.unicode.org/charts/>
49a37
> ----  * <http://www.unicode.org/charts/PDF/U0000.pdf>
49a38
> ----  * <http://www.unicode.org/charts/PDF/U0000.pdf>
49a39
> ----  * <http://www.unicode.org/charts/PDF/U0080.pdf>
49a40
> ----  * <http://www.unicode.org/charts/PDF/U0080.pdf>
49a41
> ---- This module is intended to be imported @qualified@, to avoid name
49a42
> -- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
49a43
> ---- clashes with "Prelude" functions.  eg.
49a44
> ---- > import qualified Data.Vector.Storable.ByteString.Char8 as B
49a45
> ---- > import qualified Data.Vector.Storable.ByteString.Char8 as B
49a46
> ---- The Char8 interface to bytestrings provides an instance of IsString
49a47
> -- for the ByteString type, enabling you to use string literals, and-- The Char8 interface to bytestrings provides an instance of IsString
49a48
> -- for the ByteString type, enabling you to use string literals, and-- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
49a49
> -- to enable this.-- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
49a50
> ---- to enable this.
51d51
< 
53c53
< 
---
> module Data.Vector.Storable.ByteString.Char8 (
54a55
>         ByteString-- * The ByteString type,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
56d56
< 
58d57
<         B.empty,           -- :: ByteString
59d57
<         singleton,         -- :: Char   -> ByteString
60c58
<         pack,              -- :: String -> ByteString
---
>         B.empty-- * Introducing and eliminating ByteStrings,           -- :: ByteString
60a59
>         B.emptysingleton, ,         -- :: ByteString-- :: Char   -> ByteString
60a60
>         singletonpack,    ,         -- :: Char   -> ByteString
60a61
>         packunpack, ,            -- :: String -> ByteString
62d62
< 
63a64
>         cons-- * Basic interface,              -- :: Char -> ByteString -> ByteString
65d65
<         snoc,              -- :: ByteString -> Char -> ByteString
66d65
<         B.append,          -- :: ByteString -> ByteString -> ByteString
67d65
<         head,              -- :: ByteString -> Char
68d65
<         uncons,            -- :: ByteString -> Maybe (Char, ByteString)
69c66
<         last,              -- :: ByteString -> Char
---
>         snocB.append,   ,          -- :: ByteString -> Char -> ByteString-- :: ByteString -> ByteString -> ByteString
69a67
>         B.appendhead,   ,          -- :: ByteString -> Char-- :: ByteString -> ByteString -> ByteString
69a68
>         headuncons, ,            -- :: ByteString -> Char-- :: ByteString -> Maybe (Char, ByteString)
69a69
>         unconslast, ,            -- :: ByteString -> Char-- :: ByteString -> Maybe (Char, ByteString)
69a70
>         lastB.tail, ,            -- :: ByteString -> Char-- :: ByteString -> ByteString
71d71
<         B.init,            -- :: ByteString -> ByteString
72c72
<         B.null,            -- :: ByteString -> Bool
---
>         B.init,            -- :: ByteString -> Bool-- :: ByteString -> ByteString
72a73
>         B.nullB.length, ,          -- :: ByteString -> Int-- :: ByteString -> Bool
74d74
< 
76d75
<         map,               -- :: (Char -> Char) -> ByteString -> ByteString
77d75
<         B.reverse,         -- :: ByteString -> ByteString
78d75
<         intersperse,       -- :: Char -> ByteString -> ByteString
79c76
<         B.intercalate,     -- :: ByteString -> [ByteString] -> ByteString
---
>         map-- * Transformating ByteStrings,               -- :: (Char -> Char) -> ByteString -> ByteString
79a77
>         mapB.reverse,     ,         -- :: ByteString -> ByteString-- :: (Char -> Char) -> ByteString -> ByteString
79a78
>         B.reverseintersperse, ,       -- :: ByteString -> ByteString-- :: Char -> ByteString -> ByteString
79a79
>         intersperseB.intercalate, ,     -- :: Char -> ByteString -> ByteString-- :: ByteString -> [ByteString] -> ByteString
79a80
>         B.intercalateB.transpose, ,     -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
81d81
< 
83d82
<         foldl,             -- :: (a -> Char -> a) -> a -> ByteString -> a
84d82
<         foldl',            -- :: (a -> Char -> a) -> a -> ByteString -> a
85c83
<         foldl1,            -- :: (Char -> Char -> Char) -> ByteString -> Char
---
>         foldl-- * Reducing ByteStrings (folds),             -- :: (a -> Char -> a) -> a -> ByteString -> a
85a84
>         foldlfoldl',,            -- :: (a -> Char -> a) -> a -> ByteString -> a
85a85
>         foldl',            -- :: (a -> Char -> a) -> a -> ByteString -> a-- :: (Char -> Char -> Char) -> ByteString -> Char
85a86
>         foldl1foldl1',,           -- :: (Char -> Char -> Char) -> ByteString -> Char
87d87
< 
89d88
<         foldr',            -- :: (Char -> a -> a) -> a -> ByteString -> a
90c89
<         foldr1,            -- :: (Char -> Char -> Char) -> ByteString -> Char
---
>         foldrfoldr',,            -- :: (Char -> a -> a) -> a -> ByteString -> a
90a90
>         foldr',            -- :: (Char -> a -> a) -> a -> ByteString -> a-- :: (Char -> Char -> Char) -> ByteString -> Char
90a91
>         foldr1foldr1',,           -- :: (Char -> Char -> Char) -> ByteString -> Char
92d92
< 
94d93
<         B.concat,          -- :: [ByteString] -> ByteString
95c94
<         concatMap,         -- :: (Char -> ByteString) -> ByteString -> ByteString
---
>         B.concat-- ** Special folds,          -- :: [ByteString] -> ByteString
95a95
>         B.concatconcatMap,,         -- :: [ByteString] -> ByteString-- :: (Char -> ByteString) -> ByteString -> ByteString
95a96
>         concatMapany,     ,         -- :: (Char -> Bool) -> ByteString -> Bool-- :: (Char -> ByteString) -> ByteString -> ByteString
97c98
<         all,               -- :: (Char -> Bool) -> ByteString -> Bool
---
>         allmaximum,   ,           -- :: ByteString -> Char-- :: (Char -> Bool) -> ByteString -> Bool
100d100
< 
102d101
<         -- ** Scans
103d101
<         scanl,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
104d101
<         scanl1,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString
105c102
<         scanr,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
---
>         -- ** Scans-- * Building ByteStrings
105a103
>         scanl-- ** Scans,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
105a104
>         scanlscanl1,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
105a105
>         scanl1scanr,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
105a106
>         scanrscanr1,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
107d107
< 
108a109
>         mapAccumL-- ** Accumulating maps,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
111d111
< 
113d112
<         replicate,         -- :: Int -> Char -> ByteString
114c113
<         unfoldr,           -- :: (a -> Maybe (Char, a)) -> a -> ByteString
---
>         replicate-- ** Generating and unfolding ByteStrings,         -- :: Int -> Char -> ByteString
114a114
>         replicateunfoldr, ,         -- :: Int -> Char -> ByteString-- :: (a -> Maybe (Char, a)) -> a -> ByteString
114a115
>         unfoldrunfoldrN,,          -- :: (a -> Maybe (Char, a)) -> a -> ByteString-- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
116d116
< 
118c118
< 
---
>         -- * Substrings
119a120
>         B.take-- ** Breaking strings,            -- :: Int -> ByteString -> ByteString
121d121
<         B.drop,            -- :: Int -> ByteString -> ByteString
122c122
<         B.splitAt,         -- :: Int -> ByteString -> (ByteString, ByteString)
---
>         B.dropB.splitAt,  ,         -- :: Int -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
122a123
>         B.splitAt,         -- :: (Char -> Bool) -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
124d124
<         dropWhile,         -- :: (Char -> Bool) -> ByteString -> ByteString
125d124
<         span,              -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
126d124
<         spanEnd,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
127d124
<         break,             -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
128d124
<         breakEnd,          -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
129d124
<         B.group,           -- :: ByteString -> [ByteString]
130c125
<         groupBy,           -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
---
>         dropWhilespan,    ,         -- :: (Char -> Bool) -> ByteString -> ByteString-- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
130a126
>         spanspanEnd,  ,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
130a127
>         spanEndbreak, ,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
130a128
>         breakbreakEnd,  ,          -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
130a129
>         breakEndB.group,,          -- :: ByteString -> [ByteString]-- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
130a130
>         B.group,           -- :: ByteString -> [ByteString]-- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
130a131
>         groupBy,           -- :: ByteString -> [ByteString]-- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
133d133
< 
135c135
<         split,             -- :: Char -> ByteString -> [ByteString]
---
>         split-- ** Breaking into many substrings,             -- :: Char -> ByteString -> [ByteString]
135a136
>         splitsplitWith,   ,         -- :: Char -> ByteString -> [ByteString]-- :: (Char -> Bool) -> ByteString -> [ByteString]
137d137
< 
138a139
>         lines-- ** Breaking into lines and words,             -- :: ByteString -> [ByteString]
140c141
<         words,             -- :: ByteString -> [ByteString]
---
>         wordsunlines, ,           -- :: ByteString -> [ByteString]
143d143
< 
144a145
>         B.isPrefixOf-- * Predicates,      -- :: ByteString -> ByteString -> Bool
146c147
<         B.isSuffixOf,      -- :: ByteString -> ByteString -> Bool
---
>         B.isSuffixOfB.isInfixOf,,      -- :: ByteString -> ByteString -> Bool
148d148
< 
150d149
<         B.breakSubstring,  -- :: ByteString -> ByteString -> (ByteString,ByteString)
151c150
<         B.findSubstring,   -- :: ByteString -> ByteString -> Maybe Int
---
>         B.breakSubstring-- ** Search for arbitrary substrings,  -- :: ByteString -> ByteString -> (ByteString,ByteString)
151a151
>         B.breakSubstringB.findSubstring,,  -- :: ByteString -> ByteString -> Maybe Int-- :: ByteString -> ByteString -> (ByteString,ByteString)
151a152
>         B.findSubstringB.findSubstrings,,  -- :: ByteString -> ByteString -> [Int]-- :: ByteString -> ByteString -> Maybe Int
153d153
< 
155c155
< 
---
>         -- * Searching ByteStrings
157c157
<         elem,              -- :: Char -> ByteString -> Bool
---
>         elem-- ** Searching by equality,              -- :: Char -> ByteString -> Bool
157a158
>         elemnotElem,  ,           -- :: Char -> ByteString -> Bool
159d159
< 
161c161
<         find,              -- :: (Char -> Bool) -> ByteString -> Maybe Char
---
>         find-- ** Searching with a predicate,              -- :: (Char -> Bool) -> ByteString -> Maybe Char
161a162
>         findfilter, ,            -- :: (Char -> Bool) -> ByteString -> Maybe Char
163d163
< 
165d164
<         index,             -- :: ByteString -> Int -> Char
166d164
<         elemIndex,         -- :: Char -> ByteString -> Maybe Int
167d164
<         elemIndices,       -- :: Char -> ByteString -> [Int]
168d164
<         elemIndexEnd,      -- :: Char -> ByteString -> Maybe Int
169d164
<         findIndex,         -- :: (Char -> Bool) -> ByteString -> Maybe Int
170c165
<         findIndices,       -- :: (Char -> Bool) -> ByteString -> [Int]
---
>         index-- * Indexing ByteStrings,             -- :: ByteString -> Int -> Char
170a166
>         indexelemIndex,   ,         -- :: ByteString -> Int -> Char-- :: Char -> ByteString -> Maybe Int
170a167
>         elemIndexelemIndices, ,       -- :: Char -> ByteString -> [Int]-- :: Char -> ByteString -> Maybe Int
170a168
>         elemIndiceselemIndexEnd,,      -- :: Char -> ByteString -> [Int]-- :: Char -> ByteString -> Maybe Int
170a169
>         elemIndexEndfindIndex,  ,      -- :: Char -> ByteString -> Maybe Int-- :: (Char -> Bool) -> ByteString -> Maybe Int
170a170
>         findIndexfindIndices, ,       -- :: (Char -> Bool) -> ByteString -> [Int]-- :: (Char -> Bool) -> ByteString -> Maybe Int
170a171
>         findIndicescount,     ,       -- :: Char -> ByteString -> Int-- :: (Char -> Bool) -> ByteString -> [Int]
172d172
< 
174d173
<         zip,               -- :: ByteString -> ByteString -> [(Char,Char)]
175c174
<         zipWith,           -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
---
>         zip-- * Zipping and unzipping ByteStrings,               -- :: ByteString -> ByteString -> [(Char,Char)]
175a175
>         zipzipWith,   ,           -- :: ByteString -> ByteString -> [(Char,Char)]-- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
175a176
>         zipWithunzip, ,           -- :: [(Char,Char)] -> (ByteString,ByteString)-- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
177d177
< 
178a179
>         B.sort-- * Ordered ByteStrings,            -- :: ByteString -> ByteString
180d180
< 
182c182
<         readInt,           -- :: ByteString -> Maybe (Int, ByteString)
---
>         readInt-- * Reading from ByteStrings,           -- :: ByteString -> Maybe (Int, ByteString)
182a183
>         readIntreadInteger,   ,       -- :: ByteString -> Maybe (Int, ByteString)-- :: ByteString -> Maybe (Integer, ByteString)
184d184
< 
186c186
< 
---
>         -- * Low level CString conversions
187a188
>         B.copy-- ** Copying ByteStrings,            -- :: ByteString -> ByteString
189d189
< 
191c191
<         B.packCString,     -- :: CString -> IO ByteString
---
>         B.packCString-- ** Packing CStrings and pointers,     -- :: CString -> IO ByteString
191a192
>         B.packCStringB.packCStringLen,  ,  -- :: CString -> IO ByteString-- :: CStringLen -> IO ByteString
193d193
< 
195c195
<         B.useAsCString,    -- :: ByteString -> (CString    -> IO a) -> IO a
---
>         B.useAsCString-- ** Using ByteStrings as CStrings,    -- :: ByteString -> (CString    -> IO a) -> IO a
195a196
>         B.useAsCStringB.useAsCStringLen,  , -- :: ByteString -> (CString    -> IO a) -> IO a
197d197
< 
199c199
< 
---
>         -- * I\/O with ByteStrings
201d200
<         B.getLine,         -- :: IO ByteString
202c201
<         B.getContents,     -- :: IO ByteString
---
>         B.getLine-- ** Standard input and output,         -- :: IO ByteString
202a202
>         B.getLineB.getContents,   ,     -- :: IO ByteString
202a203
>         B.getContentsB.putStr,    ,     -- :: IO ByteString-- :: ByteString -> IO ()
204c205
<         putStrLn,          -- :: ByteString -> IO ()
---
>         putStrLnB.interact, ,        -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
206d206
< 
208d207
<         readFile,          -- :: FilePath -> IO ByteString
209c208
<         writeFile,         -- :: FilePath -> ByteString -> IO ()
---
>         readFile-- ** Files,          -- :: FilePath -> IO ByteString
209a209
>         readFilewriteFile,,         -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
209a210
>         writeFileappendFile,,        -- :: FilePath -> ByteString -> IO ()
211d211
< 
213d212
<         B.hGetLine,        -- :: Handle -> IO ByteString
214d212
<         B.hGetContents,    -- :: Handle -> IO ByteString
215d212
<         B.hGet,            -- :: Handle -> Int -> IO ByteString
216d212
<         B.hGetNonBlocking, -- :: Handle -> Int -> IO ByteString
217d212
<         B.hPut,            -- :: Handle -> ByteString -> IO ()
218c213
<         B.hPutNonBlocking, -- :: Handle -> ByteString -> IO ByteString
---
>         B.hGetLine-- ** I\/O with Handles,        -- :: Handle -> IO ByteString
218a214
>         B.hGetLineB.hGetContents,   ,    -- :: Handle -> IO ByteString
218a215
>         B.hGetContentsB.hGet,       ,    -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
218a216
>         B.hGetB.hGetNonBlocking,          , -- :: Handle -> Int -> IO ByteString
218a217
>         B.hGetNonBlockingB.hPut,          , -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
218a218
>         B.hPutB.hPutNonBlocking,          , -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
218a219
>         B.hPutNonBlockingB.hPutStr,       , -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
221d221
< 
223c223
< 
---
>   ) where
225c225
< -- Imports
---
> -- Imports--------------------------------------------------------------------------------
225a226
> -- Imports--------------------------------------------------------------------------------
227d227
< 
229d228
< import Control.Monad      ( (>>=), (>>), return )
230d228
< import Data.Bool          ( Bool(False, True), (&&), (||), not, otherwise )
231d228
< import Data.Char          ( Char, isSpace )
232d228
< import Data.Eq            ( (==) )
233d228
< import Data.Function      ( (.), ($) )
234d228
< import Data.Functor       ( fmap )
235d228
< import Data.Int           ( Int )
236d228
< import Data.Maybe         ( Maybe(Nothing, Just) )
237d228
< import Data.Ord           ( (<), (<=), (>=) )
238d228
< import Data.String        ( IsString, fromString )
239d228
< import Data.Tuple         ( fst, snd )
240d228
< import Foreign.ForeignPtr ( withForeignPtr )
241d228
< import Foreign.Storable   ( peekElemOff, peekByteOff )
242c229
< import Prelude            ( String, Integer, fromIntegral, toInteger, negate
---
> import-- from base:Control.Monad      ( (>>=), (>>), return )
242a230
> import Control.MonadData.Bool          ( (Bool>>=),False>>),True), ()&&), (||), not, otherwise )
242a231
> import Data.Bool          ( Bool(FalseisSpace, True) ), (&&), (||), not, otherwise )
242a232
> import Data.CharData.Eq            ( Char(==),)isSpace )
242a233
> import Data.EqData.Function      ( (==.)) )$) )
242a234
> import Data.FunctionData.Functor       ( (fmap.), ($) )
242a235
> import Data.FunctorData.Int           ( fmapInt ))
242a236
> import Data.IntData.Maybe         ( IntMaybe)(Nothing, Just) )
242a237
> import Data.MaybeData.Ord           ( Maybe(<), (Nothing<=), (>=,)Just)  ) )
242a238
> import Data.OrdData.String        ( (IsString<), (<=),fromString>=) )    )
242a239
> import Data.StringData.Tuple         ( IsStringfst, snd,)fromString )
242a240
> import Data.TupleForeign.ForeignPtr ( fstwithForeignPtr, snd )     )
242a241
> import Foreign.ForeignPtrForeign.Storable   ( withForeignPtrpeekElemOff, peekByteOff)         )
242a242
> import Foreign.StorablePrelude            ( peekElemOffString, Integer, peekByteOff, fromIntegral)   , toInteger, negate
242a243
> import Prelude            ( String(*), (,)Integer, (-), ,^fromIntegral), ($!), seq, toInteger, negate
244d244
<                           )
245d244
< import System.IO          ( IO, FilePath, Handle
246c245
<                           , IOMode(ReadMode, WriteMode, AppendMode)
---
> import System.IO          ) IO, FilePath, Handle
246a246
> import System.IO          ( IOIOMode, FilePath(ReadMode, Handle, WriteMode, AppendMode)
246a247
>                           , IOModewithFile(ReadMode, stdout,,WriteModehFileSize, AppendMode)
249d249
< 
251d250
< import GHC.IO             ( stToIO )
252d250
< import GHC.Prim           ( Addr#, plusAddr#, writeWord8OffAddr# )
253c251
< import GHC.Ptr            ( Ptr(..) )
---
> import GHC.BaseGHC.IO             ( CharstToIO(..), unpackCString#, ord#, int2Word# )
253a252
> import GHC.IOGHC.Prim           ( stToIOAddr#, )plusAddr#, writeWord8OffAddr# )
253a253
> import GHC.PrimGHC.Ptr            ( Addr#Ptr(..,)plusAddr#)       , writeWord8OffAddr# )
253a254
> import GHC.PtrGHC.ST             ( PtrST((....))))
255d255
< 
257c257
< 
---
> import qualified Data.List as L ( length, map, intersperse, filter )
258a259
> import-- from vector:qualified Data.Vector.Storable as VS
260d260
< 
261a262
> import-- from primitive:Control.Monad.Primitive ( unsafeInlineIO )
263d263
< 
264a265
> import-- from vector-bytestring (this package):Data.Vector.Storable.ByteString.Internal ( c2w, w2c, isSpaceWord8 )
266d266
< 
268c268
< import Data.Vector.Storable.ByteString.Internal ( unsafeCreate )
---
> import qualifiedData.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString(asunsafeCreateB          )
268a269
> import Data.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString.Unsafe   ( unsafeCreateunsafePackAddress)    )
270d270
< 
272c272
< 
---
> import Data.Vector.Storable.ByteString ( ByteString )
275c275
< -- * Introducing and eliminating ByteStrings
---
> -- * Introducing and eliminating ByteStrings------------------------------------------------------------------------
275a276
> -- * Introducing and eliminating ByteStrings------------------------------------------------------------------------
277d277
< 
279d278
< singleton :: Char -> ByteString
280c279
< singleton = VS.singleton . c2w
---
> singleton-- | /O(1)/ Convert a 'Char' into a 'ByteString':: Char -> ByteString
280a280
> singleton ::= VS.singleton -> ByteString. c2w
280a281
> singleton{-# INLINE=singleton#-} . c2w
282d282
< 
284c284
<     fromString = pack
---
> instancefromString= pack where
284a285
>     fromString =fromString     #-}
286d286
< 
288d287
< --
289d287
< -- For applications with large numbers of string literals, pack can be a
290d287
< -- bottleneck.
291d287
< pack :: String -> ByteString
292d287
< pack str = unsafeCreate (L.length str) $ \(Ptr p) -> stToIO (go p str)
293d287
<     where
294d287
<       go :: Addr# -> [Char] -> ST a ()
295d287
<       go _ []          = return ()
296d287
<       go p (C# c : cs) = writeByte >> go (p `plusAddr#` 1#) cs
297d287
<           where
298d287
<             writeByte = ST $ \s# ->
299d287
<               case writeWord8OffAddr# p 0# (int2Word# (ord# c)) s# of
300d287
<                 s2# -> (# s2#, () #)
301c288
<             {-# INLINE writeByte #-}
---
> ---- | /O(n)/ Convert a 'String' into a 'ByteString'
301a289
> ---- For applications with large numbers of string literals, pack can be a
301a290
> -- bottleneck.-- For applications with large numbers of string literals, pack can be a
301a291
> pack-- bottleneck.:: String -> ByteString
301a292
> pack ::strString= unsafeCreate-> ByteString(L.length str) $ \(Ptr p) -> stToIO (go p str)
301a293
> packwhere = unsafeCreate (L.length str) $ \(Ptr p) -> stToIO (go p str)
301a294
>     wherego :: Addr# -> [Char] -> ST a ()
301a295
>       go ::_ [Addr#]     -> [Char= return] -> ST()a ()
301a296
>       go _ []C# c : cs) = returnwriteByte) >> go (p `plusAddr#` 1#) cs
301a297
>       go pwhereC# c : cs) = writeByte >> go (p `plusAddr#` 1#) cs
301a298
>           wherewriteByte = ST $ \s# ->
301a299
>             writeBytecase writeWord8OffAddr#= ST $ \s# ->   p 0# (int2Word# (ord# c)) s# of
301a300
>                              cases2#writeWord8OffAddr#-> (# s2#, () #)  p 0# (int2Word# (ord# c)) s# of
301a301
>                            {-# INLINE -> (#writeByte, ()#-}#)
301a302
> {-# INLINE [{-# INLINE1] pack #-}writeByte #-}
303d303
< 
305d304
< "ByteString pack/packAddress" forall s .
306c305
<    pack (unpackCString# s) = unsafeInlineIO (unsafePackAddress s)
---
> {-# RULES"ByteString pack/packAddress" forall s .
306a306
> "ByteString pack/packAddress"pack (unpackCString# s) = unsafeInlineIOforall s .    (unsafePackAddress s)
306a307
>  #-} (unpackCString# s) = unsafeInlineIO (unsafePackAddress s)
308d308
< 
353d352
< 
354d352
< -- | /O(n)/ Converts a 'ByteString' to a 'String'.
357d354
< {-# INLINE unpack #-}
358d354
< 
359d354
< 
360c355
< ------------------------------------------------------------------------
---
> {-# INLINE-- | /O(n)/ Converts a 'ByteString' to a 'String'.unpack #-}
360a356
> unpack :: ByteString -> [Char]
360a357
> unpack = L.map w2c . B.unpack
360a358
> {-# INLINE------------------------------------------------------------------------ #-}
363d360
< 
364d360
< -- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
365c361
< -- complexity, as it requires a memcpy.
---
> ------------------------------------------------------------------------
365a362
> -- * Basic interface-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
365a363
> -- complexity, as it requires a memcpy.------------------------------------------------------------------------
367d364
< cons = VS.cons . c2w
368d364
< {-# INLINE cons #-}
369d364
< 
370d364
< -- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
371c365
< -- 'cons', this function performs a memcpy.
---
> cons-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different= VS.cons . c2w
371a366
> {-# INLINE-- complexity, as it requires a memcpy.cons #-}
371a367
> cons :: Char -> ByteString -> ByteString
371a368
> cons-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to= VS.cons . c2w
371a369
> {-# INLINE-- 'cons', this function performs a memcpy. #-}
373d370
< snoc p = VS.snoc p . c2w
374d370
< {-# INLINE snoc #-}
375d370
< 
376d370
< -- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
377c371
< head :: ByteString -> Char
---
> snoc-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar top = VS.snoc p . c2w
377a372
> {-# INLINE-- 'cons', this function performs a memcpy.snoc #-}
377a373
> snoc :: ByteString -> Char -> ByteString
377a374
> snoc-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty. = VS.snoc p . c2w
377a375
> {-# INLINEhead :: ByteString #-}-> Char
379d376
< {-# INLINE head #-}
380d376
< 
381d376
< -- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
382c377
< -- if it is empty.
---
> {-# INLINE-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.head #-}
382a378
> head :: ByteString -> Char
382a379
> head-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing= w2c . VS.head
382a380
> {-# INLINE-- if it is empty. #-}
384d381
< uncons = fmap (\(w,v) -> (w2c w, v)) . B.uncons
385d381
< {-# INLINE uncons #-}
386d381
< 
387c382
< -- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
---
> uncons-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing= fmap (\(w,v) -> (w2c w, v)) . B.uncons
387a383
> {-# INLINE-- if it is empty.uncons #-}
387a384
> uncons :: ByteString -> Maybe (Char, ByteString)
387a385
> uncons-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.= fmap (\(w,v) -> (w2c w, v)) . B.uncons
387a386
> {-# INLINElast :: ByteString #-}-> Char
387a387
> last = w2c . VS.last
387a388
> {-# INLINE-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.last #-}
390d390
< {-# INLINE last #-}
391d390
< 
392d390
< 
393c391
< ------------------------------------------------------------------------
---
> {-# INLINE------------------------------------------------------------------------ #-}
396d393
< 
397d393
< -- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
398c394
< map :: (Char -> Char) -> ByteString -> ByteString
---
> ------------------------------------------------------------------------
398a395
> -- * Transformating ByteStrings-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
398a396
> map------------------------------------------------------------------------:: (Char -> Char) -> ByteString -> ByteString
400d397
< {-# INLINE map #-}
401d397
< 
402d397
< -- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
403c398
< -- and \`intersperses\' that Char between the elements of the
---
> {-# INLINE-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@map #-}
403a399
> map :: (Char -> Char) -> ByteString -> ByteString
403a400
> map-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString' = VS.map (c2w . f . w2c)
403a401
> {-# INLINE-- and \`intersperses\' that Char between the elements of the #-}
404a403
> intersperse-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString':: Char -> ByteString -> ByteString
404a404
> intersperse-- and \`intersperses\' that Char between the elements of the= B.intersperse . c2w
404a405
> {-# INLINE-- 'ByteString'.  It is analogous to the intersperse function on Lists.intersperse #-}
407d407
< {-# INLINE intersperse #-}
408d407
< 
409d407
< 
410c408
< ------------------------------------------------------------------------
---
> {-# INLINE------------------------------------------------------------------------ #-}
413d410
< 
414d410
< -- | 'foldl', applied to a binary operator, a starting value (typically
415c411
< -- the left-identity of the operator), and a ByteString, reduces the
---
> ------------------------------------------------------------------------
415a412
> -- * Reducing ByteStrings (folds)-- | 'foldl', applied to a binary operator, a starting value (typically
415a413
> -- the left-identity of the operator), and a ByteString, reduces the------------------------------------------------------------------------
416a415
> foldl-- | 'foldl', applied to a binary operator, a starting value (typically:: (a -> Char -> a) -> a -> ByteString -> a
416a416
> foldl-- the left-identity of the operator), and a ByteString, reduces thef = VS.foldl (\a c -> f a (w2c c))
416a417
> {-# INLINE-- ByteString using the binary operator, from left to right.foldl #-}
418d418
< foldl f = VS.foldl (\a c -> f a (w2c c))
419d418
< {-# INLINE foldl #-}
420d418
< 
421d418
< -- | 'foldl\'' is like foldl, but strict in the accumulator.
422c419
< foldl' :: (a -> Char -> a) -> a -> ByteString -> a
---
> foldl-- | 'foldl\'' is like foldl, but strict in the accumulator. = VS.foldl (\a c -> f a (w2c c))
422a420
> {-# INLINEfoldl' :: (foldla -> Char#-} -> a) -> a -> ByteString -> a
424d421
< {-# INLINE foldl' #-}
425d421
< 
426d421
< -- | 'foldr', applied to a binary operator, a starting value
427c422
< -- (typically the right-identity of the operator), and a packed string,
---
> {-# INLINE-- | 'foldl\'' is like foldl, but strict in the accumulator.foldl' #-}
427a423
> foldl' :: (a -> Char -> a) -> a -> ByteString -> a
427a424
> foldl'-- | 'foldr', applied to a binary operator, a starting value = VS.foldl' (\a c -> f a (w2c c))
427a425
> {-# INLINE-- (typically the right-identity of the operator), and a packed string, #-}
428a427
> foldr-- | 'foldr', applied to a binary operator, a starting value:: (Char -> a -> a) -> a -> ByteString -> a
428a428
> foldr-- (typically the right-identity of the operator), and a packed string,f = VS.foldr (\c a -> f (w2c c) a)
428a429
> {-# INLINE-- reduces the packed string using the binary operator, from right to left.foldr #-}
430d430
< foldr f = VS.foldr (\c a -> f (w2c c) a)
431d430
< {-# INLINE foldr #-}
432d430
< 
433d430
< -- | 'foldr\'' is a strict variant of foldr
434c431
< foldr' :: (Char -> a -> a) -> a -> ByteString -> a
---
> foldr-- | 'foldr\'' is a strict variant of foldr = VS.foldr (\c a -> f (w2c c) a)
434a432
> {-# INLINEfoldr' :: (foldrChar ->#-}a -> a) -> a -> ByteString -> a
436d433
< {-# INLINE foldr' #-}
437d433
< 
438d433
< -- | 'foldl1' is a variant of 'foldl' that has no starting value
439c434
< -- argument, and thus must be applied to non-empty 'ByteStrings'.
---
> {-# INLINE-- | 'foldr\'' is a strict variant of foldrfoldr' #-}
439a435
> foldr' :: (Char -> a -> a) -> a -> ByteString -> a
439a436
> foldr'-- | 'foldl1' is a variant of 'foldl' that has no starting value = VS.foldr' (\c a -> f (w2c c) a)
439a437
> {-# INLINE-- argument, and thus must be applied to non-empty 'ByteStrings'. #-}
441d438
< foldl1 f v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
442d438
< {-# INLINE foldl1 #-}
443d438
< 
444d438
< -- | A strict version of 'foldl1'
445c439
< foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
---
> foldl1-- | 'foldl1' is a variant of 'foldl' that has no starting valuef v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
445a440
> {-# INLINE-- argument, and thus must be applied to non-empty 'ByteStrings'.foldl1 #-}
445a441
> foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
445a442
> foldl1-- | A strict version of 'foldl1' v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
445a443
> {-# INLINEfoldl1' :: foldl1(Char ->#-}Char -> Char) -> ByteString -> Char
447d444
< {-# INLINE foldl1' #-}
448d444
< 
449d444
< -- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
450c445
< -- and thus must be applied to non-empty 'ByteString's
---
> {-# INLINE-- | A strict version of 'foldl1'foldl1' #-}
450a446
> foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
450a447
> foldl1'-- | 'foldr1' is a variant of 'foldr' that has no starting value argument, v = w2c (VS.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) v)
450a448
> {-# INLINE-- and thus must be applied to non-empty 'ByteString's #-}
452d449
< foldr1 f v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
453d449
< {-# INLINE foldr1 #-}
454d449
< 
455d449
< -- | A strict variant of foldr1
456c450
< foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
---
> foldr1-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,f v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
456a451
> {-# INLINE-- and thus must be applied to non-empty 'ByteString'sfoldr1 #-}
456a452
> foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
456a453
> foldr1-- | A strict variant of foldr1 v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
456a454
> {-# INLINEfoldr1' :: foldr1(Char ->#-}Char -> Char) -> ByteString -> Char
458d455
< {-# INLINE foldr1' #-}
459d455
< 
460d455
< ------------------------------------------------------------------------
461c456
< -- ** Special folds
---
> {-# INLINE-- | A strict variant of foldr1foldr1' #-}
461a457
> foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
461a458
> foldr1'------------------------------------------------------------------------ v = w2c (VS.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) v)
461a459
> {-# INLINE-- ** Special folds #-}
463d460
< -- | Map a function over a 'ByteString' and concatenate the results
464c461
< concatMap :: (Char -> ByteString) -> ByteString -> ByteString
---
> -- | Map a function over a 'ByteString' and concatenate the results------------------------------------------------------------------------
464a462
> concatMap-- ** Special folds:: (Char -> ByteString) -> ByteString -> ByteString
466d463
< {-# INLINE concatMap #-}
467d463
< 
468d463
< -- | Applied to a predicate and a ByteString, 'any' determines if
469c464
< -- any element of the 'ByteString' satisfies the predicate.
---
> {-# INLINE-- | Map a function over a 'ByteString' and concatenate the resultsconcatMap #-}
469a465
> concatMap :: (Char -> ByteString) -> ByteString -> ByteString
469a466
> concatMap-- | Applied to a predicate and a ByteString, 'any' determines if = VS.concatMap (f . w2c)
469a467
> {-# INLINE-- any element of the 'ByteString' satisfies the predicate. #-}
471d468
< any f = VS.any (f . w2c)
472d468
< {-# INLINE any #-}
473d468
< 
474d468
< -- | Applied to a predicate and a 'ByteString', 'all' determines if
475c469
< -- all elements of the 'ByteString' satisfy the predicate.
---
> any-- | Applied to a predicate and a ByteString, 'any' determines iff = VS.any (f . w2c)
475a470
> {-# INLINE-- any element of the 'ByteString' satisfies the predicate.any #-}
475a471
> any :: (Char -> Bool) -> ByteString -> Bool
475a472
> any-- | Applied to a predicate and a 'ByteString', 'all' determines if = VS.any (f . w2c)
475a473
> {-# INLINE-- all elements of the 'ByteString' satisfy the predicate. #-}
477d474
< all f = VS.all (f . w2c)
478d474
< {-# INLINE all #-}
479d474
< 
480d474
< -- | 'maximum' returns the maximum value from a 'ByteString'
481c475
< maximum :: ByteString -> Char
---
> all-- | Applied to a predicate and a 'ByteString', 'all' determines iff = VS.all (f . w2c)
481a476
> {-# INLINE-- all elements of the 'ByteString' satisfy the predicate.all #-}
481a477
> all :: (Char -> Bool) -> ByteString -> Bool
481a478
> all-- | 'maximum' returns the maximum value from a 'ByteString' = VS.all (f . w2c)
481a479
> {-# INLINEmaximum :: allByteString#-}    -> Char
483d480
< {-# INLINE maximum #-}
484d480
< 
485c481
< -- | 'minimum' returns the minimum value from a 'ByteString'
---
> {-# INLINE-- | 'maximum' returns the maximum value from a 'ByteString'maximum #-}
485a482
> maximum :: ByteString -> Char
485a483
> maximum-- | 'minimum' returns the minimum value from a 'ByteString'= w2c . VS.maximum
485a484
> {-# INLINEminimum :: maximumByteString#-}-> Char
485a485
> minimum = w2c . VS.minimum
485a486
> {-# INLINE-- | 'minimum' returns the minimum value from a 'ByteString'minimum #-}
488d488
< {-# INLINE minimum #-}
489d488
< 
490d488
< 
491c489
< ------------------------------------------------------------------------
---
> {-# INLINE------------------------------------------------------------------------ #-}
494d491
< 
496c493
< -- ** Scans
---
> -- * Building ByteStrings------------------------------------------------------------------------
496a494
> -- ** Scans------------------------------------------------------------------------
498d495
< -- | 'scanl' is similar to 'foldl', but returns a list of successive
499d495
< -- reduced values from the left:
500d495
< --
501d495
< -- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
502d495
< --
503c496
< -- Note that
---
> -- | 'scanl' is similar to 'foldl', but returns a list of successive------------------------------------------------------------------------
503a497
> -- ** Scans-- reduced values from the left:
505c499
< -- > last (scanl f z xs) == foldl f z xs.
---
> -- | 'scanl' is similar to 'foldl', but returns a list of successive-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
505a500
> ---- reduced values from the left:
505a501
> ---- Note that
505a502
> ---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
505a503
> ---- > last (scanl f z xs) == foldl f z xs.
505a504
> scanl-- Note that:: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
505a505
> --scanl f z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
505a506
> {-# INLINE-- > last (scanl f z xs) == foldl f z xs.scanl #-}
507d507
< scanl f z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
508d507
< {-# INLINE scanl #-}
509d507
< 
510d507
< -- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
511c508
< --
---
> scanl-- | 'scanl1' is a variant of 'scanl' that has no starting value argument: z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
511a509
> {-# INLINE--         scanl #-}
512a511
> scanl1-- | 'scanl1' is a variant of 'scanl' that has no starting value argument::: (Char -> Char -> Char) -> ByteString -> ByteString
512a512
> --scanl1 f = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
512a513
> {-# INLINE-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]scanl1 #-}
514d514
< scanl1 f = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
515d514
< {-# INLINE scanl1 #-}
516d514
< 
517d514
< -- | scanr is the right-to-left dual of scanl.
518c515
< scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
---
> scanl1-- | scanr is the right-to-left dual of scanl. = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
518a516
> {-# INLINEscanr :: (Char-> #-}Char -> Char) -> Char -> ByteString -> ByteString
520d517
< {-# INLINE scanr #-}
521d517
< 
522d517
< -- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
523c518
< scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
---
> {-# INLINE-- | scanr is the right-to-left dual of scanl.scanr #-}
523a519
> scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
523a520
> scanr-- | 'scanr1' is a variant of 'scanr' that has no starting value argument. z = VS.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
523a521
> {-# INLINEscanr1 :: (scanrChar ->#-}Char -> Char) -> ByteString -> ByteString
525d522
< {-# INLINE scanr1 #-}
526d522
< 
527d522
< ------------------------------------------------------------------------
528c523
< -- ** Accumulating maps
---
> {-# INLINE-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.scanr1 #-}
528a524
> scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
528a525
> scanr1------------------------------------------------------------------------ = VS.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))
528a526
> {-# INLINE-- ** Accumulating maps #-}
530d527
< -- | The 'mapAccumL' function behaves like a combination of 'map' and
531c528
< -- 'foldl'; it applies a function to each element of a ByteString,
---
> -- | The 'mapAccumL' function behaves like a combination of 'map' and------------------------------------------------------------------------
531a529
> -- ** Accumulating maps-- 'foldl'; it applies a function to each element of a ByteString,
533d530
< -- final value of this accumulator together with the new list.
534d530
< mapAccumL :: (acc -> Char -> (acc, Char))
535d530
<           -> acc -> ByteString -> (acc, ByteString)
536d530
< mapAccumL f = B.mapAccumL $ \acc w ->
537d530
<                 case f acc (w2c w) of
538d530
<                   (acc', c) -> (acc', c2w c)
539d530
< {-# INLINE mapAccumL #-}
540d530
< 
541d530
< -- | The 'mapAccumR' function behaves like a combination of 'map' and
542c531
< -- 'foldr'; it applies a function to each element of a ByteString,
---
> -- final value of this accumulator together with the new list.-- | The 'mapAccumL' function behaves like a combination of 'map' and
542a532
> mapAccumL-- 'foldl'; it applies a function to each element of a ByteString,:: (acc -> Char -> (acc, Char))
542a533
> -- passing an accumulating parameter from left to right, and returning a-> acc -> ByteString -> (acc, ByteString)
542a534
> mapAccumL-- final value of this accumulator together with the new list.f = B.mapAccumL $ \acc w ->
542a535
> mapAccumL :: (acccase-> Charf acc->(w2caccw, Charof  ))
542a536
>           -> acc ->(acc', c) -> ->(acc'acc, ,c2wc)      )
542a537
> mapAccumL{-# INLINEfmapAccumL= B.mapAccumL#-}  $ \acc w ->
542a538
>                         case f acc (w2c w) of
542a539
>         -- | The 'mapAccumR' function behaves like a combination of 'map' andacc', c) -> (acc', c2w c)
542a540
> {-# INLINE-- 'foldr'; it applies a function to each element of a ByteString, #-}
544d541
< -- final value of this accumulator together with the new ByteString.
545d541
< mapAccumR :: (acc -> Char -> (acc, Char))
546d541
<           -> acc -> ByteString -> (acc, ByteString)
547d541
< mapAccumR f = B.mapAccumR $ \acc w ->
548d541
<                 case f acc (w2c w) of
549d541
<                   (acc', c) -> (acc', c2w c)
550d541
< {-# INLINE mapAccumR #-}
551d541
< 
552d541
< ------------------------------------------------------------------------
553c542
< -- ** Generating and unfolding ByteStrings
---
> -- final value of this accumulator together with the new ByteString.-- | The 'mapAccumR' function behaves like a combination of 'map' and
553a543
> mapAccumR-- 'foldr'; it applies a function to each element of a ByteString,:: (acc -> Char -> (acc, Char))
553a544
> -- passing an accumulating parameter from right to left, and returning a-> acc -> ByteString -> (acc, ByteString)
553a545
> mapAccumR-- final value of this accumulator together with the new ByteString.f = B.mapAccumR $ \acc w ->
553a546
> mapAccumR :: (acccase-> Charf acc->(w2caccw, Charof  ))
553a547
>           -> acc ->(acc', c) -> ->(acc'acc, ,c2wc)      )
553a548
> mapAccumR{-# INLINEfmapAccumR= B.mapAccumR#-}  $ \acc w ->
553a549
>                         case f acc (w2c w) of
553a550
>         ------------------------------------------------------------------------acc', c) -> (acc', c2w c)
553a551
> {-# INLINE-- ** Generating and unfolding ByteStrings #-}
555d552
< -- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
556d552
< -- the value of every element. The following holds:
557d552
< --
558c553
< -- > replicate w c = unfoldr w (\u -> Just (u,u)) c
---
> -- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@------------------------------------------------------------------------
558a554
> -- ** Generating and unfolding ByteStrings-- the value of every element. The following holds:
560c556
< -- This implemenation uses @memset(3)@
---
> -- > replicate w c = unfoldr w (\u -> Just (u,u)) c-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
560a557
> ---- the value of every element. The following holds:
560a558
> ---- This implemenation uses @memset(3)@
560a559
> replicate-- > replicate w c = unfoldr w (\u -> Just (u,u)) c:: Int -> Char -> ByteString
560a560
> --replicate w = B.replicate w . c2w
560a561
> {-# INLINE-- This implemenation uses @memset(3)@replicate #-}
562d562
< replicate w = B.replicate w . c2w
563d562
< {-# INLINE replicate #-}
564d562
< 
565d562
< -- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
566c563
< -- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
---
> replicate-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' = B.replicate w . c2w
566a564
> {-# INLINE-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a #-}
568d565
< -- returns 'Nothing' if it is done producing the ByteString or returns
569d565
< -- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
570d565
< -- and @b@ is the seed value for further production.
571d565
< --
572d565
< -- Examples:
573d565
< --
574d565
< -- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
575c566
< unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
---
> -- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'-- returns 'Nothing' if it is done producing the ByteString or returns
575a567
> -- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
575a568
> -- and @b@ is the seed value for further production.-- ByteString from a seed value.  The function takes the element and
575a569
> ---- returns 'Nothing' if it is done producing the ByteString or returns
575a570
> -- Examples:-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
575a571
> ---- and @b@ is the seed value for further production.
575a572
> ---- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
575a573
> unfoldr-- Examples::: (a -> Maybe (Char, a)) -> a -> ByteString
575a574
> --unfoldr f x0 = VS.unfoldr (fmap k . f) x0
575a575
> -- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"where k (i, j) = (c2w i, j)
575a576
> unfoldr{-# INLINE:: (unfoldra -> Maybe#-} (Char, a)) -> a -> ByteString
577d577
<     where k (i, j) = (c2w i, j)
578d577
< {-# INLINE unfoldr #-}
579d577
< 
580d577
< -- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
581c578
< -- value.  However, the length of the result is limited by the first
---
> -- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seedwhere k (i, j) = (c2w i, j)
581a579
> {-# INLINE-- value.  However, the length of the result is limited by the first #-}
583d580
< -- when the maximum length of the result is known.
584d580
< --
585d580
< -- The following equation relates 'unfoldrN' and 'unfoldr':
586d580
< --
587d580
< -- > unfoldrN n f s == take n (unfoldr f s)
588c581
< unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
---
> -- when the maximum length of the result is known.-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
588a582
> ---- value.  However, the length of the result is limited by the first
588a583
> -- The following equation relates 'unfoldrN' and 'unfoldr':-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
588a584
> ---- when the maximum length of the result is known.
588a585
> ---- > unfoldrN n f s == take n (unfoldr f s)
588a586
> unfoldrN-- The following equation relates 'unfoldrN' and 'unfoldr'::: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
588a587
> --unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
588a588
> -- > unfoldrN n f s == take n (unfoldr f s)where k (i,j) = (c2w i, j)
588a589
> unfoldrN{-# INLINE::unfoldrN -> (a#-}-> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
591d591
< {-# INLINE unfoldrN #-}
592d591
< 
593d591
< 
594c592
< ------------------------------------------------------------------------
---
> {-# INLINE------------------------------------------------------------------------ #-}
597d594
< 
599c596
< -- ** Breaking strings
---
> -- * Substrings------------------------------------------------------------------------
599a597
> -- ** Breaking strings------------------------------------------------------------------------
601d598
< -- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
602c599
< -- returns the longest prefix (possibly empty) of @xs@ of elements that
---
> -- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,------------------------------------------------------------------------
602a600
> -- ** Breaking strings-- returns the longest prefix (possibly empty) of @xs@ of elements that
603a602
> takeWhile-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,:: (Char -> Bool) -> ByteString -> ByteString
603a603
> takeWhile-- returns the longest prefix (possibly empty) of @xs@ of elements thatf = VS.takeWhile (f . w2c)
603a604
> {-# INLINE-- satisfy @p@.takeWhile #-}
605d605
< takeWhile f = VS.takeWhile (f . w2c)
606d605
< {-# INLINE takeWhile #-}
607d605
< 
608c606
< -- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
---
> takeWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@. = VS.takeWhile (f . w2c)
608a607
> {-# INLINEdropWhile ::(Char ->#-}Bool) -> ByteString -> ByteString
608a608
> dropWhile f = VS.dropWhile (f . w2c)
608a609
> {-# INLINE-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.[1] dropWhile #-}
611d611
< {-# INLINE [1] dropWhile #-}
612d611
< 
613d611
< {-# RULES
614c612
< "ByteString specialise dropWhile isSpace -> dropSpace"
---
> {-# INLINE"ByteString specialise dropWhile isSpace -> dropSpace"[1] dropWhile #-}
616d613
<   #-}
617d613
< 
618d613
< -- | 'dropSpace' efficiently returns the 'ByteString' argument with
619c614
< -- white space Chars removed from the front. It is more efficient than
---
> {-# RULES#-}
619a615
> "ByteString specialise dropWhile isSpace -> dropSpace"
619a616
> -- | 'dropSpace' efficiently returns the 'ByteString' argument with isSpace = dropSpace
619a617
> -- white space Chars removed from the front. It is more efficient than#-}
622d619
< -- > dropWhile isSpace == dropSpace
623d619
< --
624d619
< dropSpace :: ByteString -> ByteString
625d619
< dropSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
626d619
<     let go !i
627d619
<             | i >= l    = return VS.empty
628d619
<             | otherwise = do
629d619
<                 w <- peekElemOff p i
630d619
<                 if isSpaceWord8 w
631d619
<                   then go (i+1)
632d619
<                   else return $ VS.unsafeFromForeignPtr fp i (l-i)
633d619
<     in go 0
634d619
<         where
635d619
<           (fp, l) = VS.unsafeToForeignPtr0 v
636d619
< {-# INLINE dropSpace #-}
637d619
< 
638d619
< -- | 'span' @p xs@ breaks the ByteString into two segments. It is
639d619
< -- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
640c620
< span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
---
> -- > dropWhile isSpace == dropSpace-- | 'dropSpace' efficiently returns the 'ByteString' argument with
640a621
> ---- white space Chars removed from the front. It is more efficient than
640a622
> dropSpace-- calling dropWhile for removing whitespace. I.e.:: ByteString -> ByteString
640a623
> --dropSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
640a624
> -- > dropWhile isSpace == dropSpacelet go !i
640a625
> --          | i >= l    = return VS.empty
640a626
> dropSpace ::|ByteStringotherwise ->= do
640a627
> dropSpace v = unsafeInlineIOw <- peekElemOff withForeignPtrp i          fp $ \p ->
640a628
>       let go !i   if isSpaceWord8 w
640a629
>               | i >=then   go= return(i+1)  VS.empty
640a630
>               | otherwiseelse return= do  $ VS.unsafeFromForeignPtr fp i (l-i)
640a631
>       in go 0     w <- peekElemOff p i
640a632
>           where   if isSpaceWord8 w
640a633
>             (fp, l) then= VS.unsafeToForeignPtr0 (i+1)            v
640a634
>   {-# INLINE dropSpaceelse#-} $ VS.unsafeFromForeignPtr fp i (l-i)
640a635
>       in go 0
640a636
> -- | 'span' @p xs@ breaks the ByteString into two segments. It iswhere
640a637
> -- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@fp, l) = VS.unsafeToForeignPtr0 v
640a638
> {-# INLINEspan :: (Char-> Bool#-}) -> ByteString -> (ByteString, ByteString)
642d639
< {-# INLINE span #-}
643d639
< 
644d639
< -- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
645d639
< -- We have
646c640
< --
---
> {-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It isspan #-}
646a641
> -- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
646a642
> span-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
646a643
> span-- We have = VS.span (f . w2c)
646a644
> {-# INLINE--         span #-}
647a646
> ---- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
647a647
> -- and-- We have
649c649
< -- and
---
> -- > spanEnd (not . isSpace) v-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
649a650
> ---- >    ==
649a651
> -- and-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
651d652
< -- > spanEnd (not . isSpace) v
652d652
< -- >    ==
653c653
< -- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
---
> spanEnd-- > spanEnd (not . isSpace) v:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
653a654
> spanEnd-- >    ==f = B.spanEnd (f . w2c)
653a655
> {-# INLINE-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)spanEnd #-}
655d656
< spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
656d656
< spanEnd f = B.spanEnd (f . w2c)
657d656
< {-# INLINE spanEnd #-}
658d656
< 
659d656
< -- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
660d656
< break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
661c657
< break f = VS.break (f . w2c)
---
> spanEnd-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
661a658
> spanEndbreak ::f(=Char-> Bool(f-> w2cByteString)       -> (ByteString, ByteString)
661a659
> {-# INLINEbreak f = VS.break #-}(f . w2c)
663d660
< 
664d660
< {-# RULES
665d660
< "ByteString specialise break (x==)" forall x.
666c661
<     break ((==) x) = breakChar x
---
> -- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
666a662
> break{-# RULES:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
666a663
> break"ByteString specialise break (x==)" = VS.break (f . w2c)        forall x.
666a664
> {-# INLINEbreak ([1==])breakx) = #-}breakChar x
668d665
<     break (==x) = breakChar x
669d665
<   #-}
670d665
< 
671d665
< -- | 'breakChar' breaks its ByteString argument at the first occurence
672d665
< -- of the specified char. It is more efficient than 'break' as it is
673c666
< -- implemented with @memchr(3)@. I.e.
---
> {-# RULESbreak (==x) = breakChar x
673a667
> "ByteString specialise break (x==)"#-}                               forall x.
673a668
>     break ((==) x) = breakChar x
673a669
> "ByteString specialise break (==x)"-- | 'breakChar' breaks its ByteString argument at the first occurenceforall x.
673a670
> -- of the specified char. It is more efficient than 'break' as it is (==x) = breakChar x
673a671
> -- implemented with @memchr(3)@. I.e.#-}
676c674
< --
---
> ---- | 'breakChar' breaks its ByteString argument at the first occurence
676a675
> breakChar-- of the specified char. It is more efficient than 'break' as it is:: Char -> ByteString -> (ByteString, ByteString)
676a676
> breakChar-- implemented with @memchr(3)@. I.e.c v = case elemIndex c v of
676a677
> --  Nothing -> (v, VS.empty)
676a678
> -- > break (=='c') "abcd" == breakChar 'c' "abcd"Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
676a679
> --{-# INLINE breakChar #-}
679d681
<     Nothing -> (v, VS.empty)
680d681
<     Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
681d681
< {-# INLINE breakChar #-}
682d681
< 
683d681
< {-# RULES
684d681
< "ByteString specialise break -> breakSpace"
685d681
<     break isSpace = breakSpace
686c682
<   #-}
---
> "ByteString specialise break -> breakSpace" -> (v, VS.empty)
686a683
>     JustbreaknisSpace (VS.unsafeTake= breakSpacen v, VS.unsafeDrop n v)
686a684
> {-# INLINE#-}      breakChar #-}
688d685
< -- | 'breakSpace' returns the pair of ByteStrings when the argument is
689d685
< -- broken at the first whitespace byte. I.e.
690d685
< --
691c686
< -- > break isSpace == breakSpace
---
> {-# RULES-- | 'breakSpace' returns the pair of ByteStrings when the argument is
691a687
> "ByteString specialise break -> breakSpace"-- broken at the first whitespace byte. I.e.
691a688
> --  break isSpace = breakSpace
691a689
> -- > break isSpace == breakSpace#-}
694d691
< breakSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
695d691
<     let go !i
696d691
<             | i >= l    = return (vec l, VS.empty)
697d691
<             | otherwise = do
698d691
<                 w <- peekByteOff p i
699d691
<                 if (not . isSpaceWord8) w
700d691
<                   then go (i+1)
701d691
<                   else return $!
702d691
<                        if i == 0
703c692
<                        then (VS.empty, vec l)
---
> breakSpace-- | 'breakSpace' returns the pair of ByteStrings when the argument isv = unsafeInlineIO $ withForeignPtr fp $ \p ->
703a693
> -- broken at the first whitespace byte. I.e.let go !i
703a694
> --          | i >= l    = return (vec l, VS.empty)
703a695
> -- > break isSpace == breakSpace| otherwise = do
703a696
> --              w <- peekByteOff p i
703a697
> breakSpace :: ByteStringif (not .->isSpaceWord8ByteString),ByteStringw         )
703a698
> breakSpace v = unsafeInlineIOthen go (i+1$ withForeignPtr fp $ \p ->
703a699
>     let go !i     else return $!
703a700
>             | i >= l   if= returni == 0 (vec l, VS.empty)
703a701
>             | otherwisethen= do(VS.empty, vec l)
703a702
>                 w <- peekByteOffelse (vec p,iVS.unsafeFromForeignPtr fp i (l-i))
703a703
>     in go 0     if (not . isSpaceWord8) w
703a704
>         where     then go (i+1)
703a705
>           (fp, l) else= VS.unsafeToForeignPtr0 $!           v
703a706
>           vec = VS.unsafeFromForeignPtr0 i == 0         fp
703a707
> {-# INLINE breakSpace #-}then (VS.empty, vec l)
705d708
<     in go 0
706d708
<         where
707d708
<           (fp, l) = VS.unsafeToForeignPtr0 v
708d708
<           vec = VS.unsafeFromForeignPtr0 fp
709d708
< {-# INLINE breakSpace #-}
710c709
< 
---
> -- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'in go 0
710a710
> --      where
710a711
> -- breakEnd p == spanEnd (not.p)fp, l) = VS.unsafeToForeignPtr0 v
710a712
> breakEnd ::(Char= VS.unsafeFromForeignPtr0-> Bool) -> ByteString fp (ByteString, ByteString)
710a713
> {-# INLINEbreakEnd f breakSpace= B.breakEnd#-}(f . w2c)
710a714
> {-# INLINE breakEnd #-}
712d715
< --
713d715
< -- breakEnd p == spanEnd (not.p)
714d715
< breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
715c716
< breakEnd f = B.breakEnd (f . w2c)
---
> ---- | The 'groupBy' function is the non-overloaded version of 'group'.
715a717
> groupBy-- breakEnd p == spanEnd (not.p):: (Char -> Char -> Bool) -> ByteString -> [ByteString]
715a718
> breakEndgroupBy k::= (B.groupByChar -> Bool(\a)b->->ByteStringk (w2c a) ->(w2cByteStringb))      , ByteString)
715a719
> breakEnd{-# INLINE =groupBy#-}  (f . w2c)
717d720
< 
718d720
< -- | The 'groupBy' function is the non-overloaded version of 'group'.
719d720
< groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
720d720
< groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))
721d720
< {-# INLINE groupBy #-}
722d720
< 
724d721
< -- argument, consuming the delimiter. I.e.
725d721
< --
726d721
< -- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
727c722
< -- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
---
> -- argument, consuming the delimiter. I.e.-- | The 'groupBy' function is the non-overloaded version of 'group'.
727a723
> groupBy--      :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
727a724
> groupBy-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"] = B.groupBy (\a b -> k (w2c a) (w2c b))
727a725
> {-# INLINE-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""] #-}
729d726
< --
730d726
< -- and
731d726
< --
732d726
< -- > intercalate [c] . split c == id
733c727
< -- > split == splitWith . (==)
---
> ---- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
733a728
> -- and-- argument, consuming the delimiter. I.e.
735c730
< -- As for all splitting functions in this library, this function does
---
> -- > intercalate [c] . split c == id-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
735a731
> -- > split == splitWith . (==)-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
735a732
> ---- > split 'x'  "x"          == ["",""]
735a733
> ---- As for all splitting functions in this library, this function does
735a734
> -- and-- not copy the substrings, it just constructs new 'ByteStrings' that
735a735
> ---- are slices of the original.
735a736
> ---- > intercalate [c] . split c == id
735a737
> split-- > split == splitWith . (==):: Char -> ByteString -> [ByteString]
735a738
> --split = B.split . c2w
735a739
> {-# INLINE-- As for all splitting functions in this library, this function doessplit #-}
737d740
< -- are slices of the original.
738d740
< --
739d740
< split :: Char -> ByteString -> [ByteString]
740d740
< split = B.split . c2w
741d740
< {-# INLINE split #-}
742d740
< 
743d740
< -- | /O(n)/ Splits a 'ByteString' into components delimited by
744d740
< -- separators, where the predicate returns True for a separator element.
745d740
< -- The resulting components do not contain the separators.  Two adjacent
746d740
< -- separators result in an empty component in the output.  eg.
747c741
< --
---
> -- are slices of the original.-- | /O(n)/ Splits a 'ByteString' into components delimited by
747a742
> ---- separators, where the predicate returns True for a separator element.
747a743
> split-- The resulting components do not contain the separators.  Two adjacent:: Char -> ByteString -> [ByteString]
747a744
> split-- separators result in an empty component in the output.  eg.= B.split . c2w
747a745
> {-# INLINE--         split #-}
748a747
> ---- | /O(n)/ Splits a 'ByteString' into components delimited by
748a748
> splitWith-- separators, where the predicate returns True for a separator element.:: (Char -> Bool) -> ByteString -> [ByteString]
748a749
> splitWith-- The resulting components do not contain the separators.  Two adjacentf = B.splitWith (f . w2c)
748a750
> {-# INLINE-- separators result in an empty component in the output.  eg.splitWith #-} -- the inline makes a big difference here.
749a752
> -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]------------------------------------------------------------------------
749a753
> ---- ** Breaking into lines and words
751d754
< splitWith f = B.splitWith (f . w2c)
752d754
< {-# INLINE splitWith #-} -- the inline makes a big difference here.
753d754
< 
754d754
< ------------------------------------------------------------------------
755d754
< -- ** Breaking into lines and words
756d754
< 
757d754
< -- | 'lines' breaks a ByteString up into a list of ByteStrings at
758c755
< -- newline Chars. The resulting strings do not contain newlines.
---
> splitWith-- | 'lines' breaks a ByteString up into a list of ByteStrings at = B.splitWith (f . w2c)
758a756
> {-# INLINE-- newline Chars. The resulting strings do not contain newlines. #-} -- the inline makes a big difference here.
760d757
< lines v
761c758
<     | VS.null v = []
---
> lines------------------------------------------------------------------------v
761a759
> -- ** Breaking into lines and words| VS.null v = []
763d760
<         Nothing -> [v]
764c761
<         Just n  -> VS.unsafeTake n v : lines (VS.unsafeDrop (n+1) v)
---
> -- | 'lines' breaks a ByteString up into a list of ByteStrings atNothing -> [v]
764a762
> -- newline Chars. The resulting strings do not contain newlines.Just n  -> VS.unsafeTake n v : lines (VS.unsafeDrop (n+1) v)
764a763
> lines{-# INLINE:: ByteStringlines #-}-> [ByteString]
764a764
> lines v
764a765
> -- | 'words' breaks a ByteString up into a list of words, which VS.null v = []
764a766
> -- were delimited by Chars representing white space. otherwise = case elemIndex '\n' v of
764a767
> words ::NothingByteString [v->] [ByteString]
764a768
> words = JustL.filter  ->(not. VS.null) n vB.splitWith lines (VS.unsafeDropisSpaceWord8 (n+1) v)
767d770
< -- | 'words' breaks a ByteString up into a list of words, which
768d770
< -- were delimited by Chars representing white space.
769d770
< words :: ByteString -> [ByteString]
770d770
< words = L.filter (not . VS.null) . B.splitWith isSpaceWord8
771d770
< {-# INLINE words #-}
772d770
< 
773d770
< -- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
774d770
< -- after appending a terminating newline to each.
775d770
< unlines :: [ByteString] -> ByteString
776d770
< unlines [] = VS.empty
777c771
< unlines vs = VS.concat (L.intersperse (VS.singleton nl) vs) `VS.snoc` nl
---
> -- | 'words' breaks a ByteString up into a list of words, which-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
777a772
> -- after appending a terminating newline to each.-- were delimited by Chars representing white space.
777a773
> wordsunlines::::[ByteString->][ByteString-> ByteString]
777a774
> wordsunlines= L.filter[] = VS.emptynot . VS.null) . B.splitWith isSpaceWord8
777a775
> {-# INLINEunlines vs words= VS.concat#-}   (L.intersperse (VS.singleton nl) vs) `VS.snoc` nl
779c777
<       nl = c2w '\n'
---
> -- | 'unlines' is an inverse operation to 'lines'.  It joins lines,nl = c2w '\n'
779a778
> {-# INLINE-- after appending a terminating newline to each.unlines #-}
779a779
> unlines :: [ByteString] -> ByteString
779a780
> unlines-- | The 'unwords' function is analogous to the 'unlines' function, on words.] = VS.empty
779a781
> unlines vs =ByteString](L.intersperse-> ByteString (VS.singleton nl) vs) `VS.snoc` nl
779a782
> unwordswhere= B.intercalate (singleton ' ')
779a783
> {-# INLINE = c2wunwords#-}
782d785
< -- | The 'unwords' function is analogous to the 'unlines' function, on words.
783d785
< unwords :: [ByteString] -> ByteString
784c786
< unwords = B.intercalate (singleton ' ')
---
> -------------------------------------------------------------------------- | The 'unwords' function is analogous to the 'unlines' function, on words.
784a787
> unwords-- * Searching ByteStrings:: [ByteString] -> ByteString
784a788
> unwords------------------------------------------------------------------------= B.intercalate (singleton ' ')
786d789
< 
787d789
< 
789d790
< -- * Searching ByteStrings
790d790
< ------------------------------------------------------------------------
791d790
< 
792d790
< ------------------------------------------------------------------------
794d791
< 
795d791
< -- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
796c792
< -- implementation uses @memchr(3)@.
---
> ------------------------------------------------------------------------
796a793
> -- * Searching ByteStrings-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
796a794
> -- implementation uses @memchr(3)@.------------------------------------------------------------------------
798d795
< elem c = VS.elem (c2w c)
799d795
< {-# INLINE elem #-}
800d795
< 
801d795
< -- | /O(n)/ 'notElem' is the inverse of 'elem'
802d795
< notElem :: Char -> ByteString -> Bool
803d795
< notElem c = VS.notElem (c2w c)
804c796
< {-# INLINE notElem #-}
---
> elem------------------------------------------------------------------------c = VS.elem (c2w c)
804a797
> {-# INLINE-- ** Searching by equalityelem #-}
805a799
> -- | /O(n)/ 'notElem' is the inverse of 'elem'-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
805a800
> notElem-- implementation uses @memchr(3)@.:: Char -> ByteString -> Bool
805a801
> elemnotElem:: Charc = VS.notElem-> ByteString(c2w->c)Bool
805a802
> elem{-# INLINE = VS.elemnotElemc2w#-}c)
805a803
> {-# INLINE elem #-}
807d804
< -- ** Searching with a predicate
808d804
< 
809d804
< -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
810c805
< -- and returns the first element in matching the predicate, or 'Nothing'
---
> -- ** Searching with a predicate-- | /O(n)/ 'notElem' is the inverse of 'elem'
810a806
> notElem :: Char -> ByteString -> Bool
810a807
> notElem-- | /O(n)/ The 'find' function takes a predicate and a ByteString, = VS.notElem (c2w c)
810a808
> {-# INLINE-- and returns the first element in matching the predicate, or 'Nothing' #-}
812d809
< find :: (Char -> Bool) -> ByteString -> Maybe Char
813c810
< find f v = w2c `fmap` VS.find (f . w2c) v
---
> find------------------------------------------------------------------------:: (Char -> Bool) -> ByteString -> Maybe Char
813a811
> find-- ** Searching with a predicatef v = w2c `fmap` VS.find (f . w2c) v
815c813
< 
---
> -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
815a814
> -- | /O(n)/ 'filter', applied to a predicate and a ByteString,-- and returns the first element in matching the predicate, or 'Nothing'
815a815
> -- if there is no such element.-- returns a ByteString containing those characters that satisfy the
815a816
> find-- predicate.:: (Char -> Bool) -> ByteString -> Maybe Char
815a817
> findfilter v::=(w2cChar`fmap-> Bool` VS.find) -> ByteStringf . w2c)-> ByteString
815a818
> {-# INLINEfilter f = findVS.filter#-}  (f . w2c)
815a819
> {-# INLINE filter #-}
818d821
< -- predicate.
819d821
< filter :: (Char -> Bool) -> ByteString -> ByteString
820c822
< filter f = VS.filter (f . w2c)
---
> -- predicate.------------------------------------------------------------------------
820a823
> filter-- * Indexing ByteStrings:: (Char -> Bool) -> ByteString -> ByteString
820a824
> filter------------------------------------------------------------------------ = VS.filter (f . w2c)
822d825
< 
823d825
< 
824d825
< ------------------------------------------------------------------------
825d825
< -- * Indexing ByteStrings
826d825
< ------------------------------------------------------------------------
827d825
< 
830d827
< index = (w2c .) . (VS.!)
831d827
< {-# INLINE index #-}
832c828
< 
---
> index------------------------------------------------------------------------= (w2c .) . (VS.!)
832a829
> {-# INLINE-- * Indexing ByteStringsindex #-}
832a830
> ------------------------------------------------------------------------
834d831
< -- element in the given 'ByteString' which is equal (by memchr) to the
835d831
< -- query element, or 'Nothing' if there is no such element.
836d831
< elemIndex :: Char -> ByteString -> Maybe Int
837c832
< elemIndex = VS.elemIndex . c2w
---
> -- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.-- element in the given 'ByteString' which is equal (by memchr) to the
837a833
> index-- query element, or 'Nothing' if there is no such element.:: ByteString -> Int -> Char
837a834
> indexelemIndex= (w2c:: .Char) . (->VS.!ByteString)        -> Maybe Int
837a835
> {-# INLINEelemIndex =indexVS.elemIndex#-}     . c2w
839d836
< 
840d836
< -- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
841d836
< -- the indices of all elements equal to the query element, in ascending order.
842d836
< elemIndices :: Char -> ByteString -> [Int]
843d836
< elemIndices = B.elemIndices . c2w
844c837
< {-# INLINE elemIndices #-}
---
> -- | /O(n)/ The 'elemIndex' function returns the index of the first
844a838
> -- element in the given 'ByteString' which is equal (by memchr) to the-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
844a839
> -- query element, or 'Nothing' if there is no such element.-- the indices of all elements equal to the query element, in ascending order.
844a840
> elemIndexelemIndices::::Char->->ByteString->->[IntInt]
844a841
> elemIndexelemIndices= VS.elemIndex= B.elemIndices c2w. c2w
844a842
> {-# INLINE elemIndexelemIndices#-}#-}
846d843
< -- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
847d843
< -- element in the given 'ByteString' which is equal to the query
848d843
< -- element, or 'Nothing' if there is no such element. The following
849d843
< -- holds:
850c844
< --
---
> -- | /O(n)/ The 'elemIndexEnd' function returns the last index of the-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
850a845
> -- element in the given 'ByteString' which is equal to the query-- the indices of all elements equal to the query element, in ascending order.
850a846
> elemIndices-- element, or 'Nothing' if there is no such element. The following:: Char -> ByteString -> [Int]
850a847
> elemIndices-- holds:   = B.elemIndices . c2w
850a848
> {-# INLINE--         elemIndices #-}
852d849
< -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
853d849
< --
854d849
< elemIndexEnd :: Char -> ByteString -> Maybe Int
855d849
< elemIndexEnd = B.elemIndexEnd . c2w
856d849
< {-# INLINE elemIndexEnd #-}
857d849
< 
858d849
< -- | The 'findIndex' function takes a predicate and a 'ByteString' and
859d849
< -- returns the index of the first element in the ByteString satisfying the predicate.
860d849
< findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
861d849
< findIndex f = VS.findIndex (f . w2c)
862c850
< {-# INLINE findIndex #-}
---
> -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
862a851
> ---- element in the given 'ByteString' which is equal to the query
862a852
> elemIndexEnd-- element, or 'Nothing' if there is no such element. The following:: Char -> ByteString -> Maybe Int
862a853
> -- holds:elemIndexEnd = B.elemIndexEnd . c2w
862a854
> --{-# INLINE elemIndexEnd #-}
862a855
> -- > elemIndexEnd c xs ==
862a856
> -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- | The 'findIndex' function takes a predicate and a 'ByteString' and
862a857
> ---- returns the index of the first element in the ByteString satisfying the predicate.
862a858
> elemIndexEndfindIndex :: ::(Char->->Bool) -> ByteString-> Maybe->IntMaybe Int
862a859
> elemIndexEndfindIndex f ==VS.findIndex(f . c2w)
862a860
> {-# INLINE elemIndexEndfindIndex #-}#-}
864d861
< -- | The 'findIndices' function extends 'findIndex', by returning the
865d861
< -- indices of all elements satisfying the predicate, in ascending order.
866d861
< findIndices :: (Char -> Bool) -> ByteString -> [Int]
867d861
< findIndices f = B.findIndices (f . w2c)
868c862
< {-# INLINE findIndices #-}
---
> -- | The 'findIndices' function extends 'findIndex', by returning the-- | The 'findIndex' function takes a predicate and a 'ByteString' and
868a863
> -- indices of all elements satisfying the predicate, in ascending order.-- returns the index of the first element in the ByteString satisfying the predicate.
868a864
> findIndexfindIndices::::Char(Char->->Bool) ->) ->ByteString->->[IntInt]
868a865
> findIndexfindIndices = VS.findIndex= B.findIndicesf .fw2c. )w2c)
868a866
> {-# INLINE findIndexfindIndices#-}#-}
870d867
< -- | count returns the number of times its argument appears in the ByteString
871d867
< --
872c868
< -- > count = length . elemIndices
---
> -- | The 'findIndices' function extends 'findIndex', by returning the-- | count returns the number of times its argument appears in the ByteString
872a869
> ---- indices of all elements satisfying the predicate, in ascending order.
872a870
> findIndices-- > count = length . elemIndices:: (Char -> Bool) -> ByteString -> [Int]
872a871
> findIndices--          f = B.findIndices (f . w2c)
872a872
> {-# INLINE-- Also    findIndices #-}
874c874
< -- Also
---
> -- > count '\n' == length . lines-- | count returns the number of times its argument appears in the ByteString
875a876
> -- > count = length . elemIndices-- But more efficiently than using length on the intermediate list.
875a877
> --count :: Char -> ByteString -> Int
875a878
> count-- Alsoc = B.count (c2w c)
875a879
> --{-# INLINE count #-}
878d881
< -- But more efficiently than using length on the intermediate list.
879d881
< count :: Char -> ByteString -> Int
880c882
< count c = B.count (c2w c)
---
> -- But more efficiently than using length on the intermediate list.------------------------------------------------------------------------
880a883
> count-- * Zipping and unzipping ByteStrings:: Char -> ByteString -> Int
880a884
> count------------------------------------------------------------------------ = B.count (c2w c)
882d885
< 
883d885
< 
884d885
< ------------------------------------------------------------------------
885d885
< -- * Zipping and unzipping ByteStrings
886d885
< ------------------------------------------------------------------------
887d885
< 
890d887
< -- excess elements of the longer ByteString are discarded. This is
891d887
< -- equivalent to a pair of 'unpack' operations, and so space
892c888
< -- usage may be large for multi-megabyte ByteStrings
---
> -- excess elements of the longer ByteString are discarded. This is------------------------------------------------------------------------
892a889
> -- * Zipping and unzipping ByteStrings-- equivalent to a pair of 'unpack' operations, and so space
892a890
> -- usage may be large for multi-megabyte ByteStrings------------------------------------------------------------------------
894d891
< zip v1 v2
895d891
<     | VS.null v1 || VS.null v2 = []
896d891
<     | otherwise = (unsafeHead v1, unsafeHead v2)
897d891
<                 : zip (VS.unsafeTail v1) (VS.unsafeTail v2)
898d891
< {-# INLINE zip #-}
899d891
< 
900d891
< -- | 'zipWith' generalises 'zip' by zipping with the function given as
901d891
< -- the first argument, instead of a tupling function.  For example,
902d891
< -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
903d891
< -- of corresponding sums.
904c892
< zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
---
> zip-- | /O(n)/ 'zip' takes two ByteStrings and returns a list ofv1 v2
904a893
> -- corresponding pairs of Chars. If one input ByteString is short,| VS.null v1 || VS.null v2 = []
904a894
> -- excess elements of the longer ByteString are discarded. This is| otherwise = (unsafeHead v1, unsafeHead v2)
904a895
> -- equivalent to a pair of 'unpack' operations, and so space: zip (VS.unsafeTail v1) (VS.unsafeTail v2)
904a896
> {-# INLINE-- usage may be large for multi-megabyte ByteStringszip #-}
904a897
> zip :: ByteString -> ByteString -> [(Char, Char)]
904a898
> zip-- | 'zipWith' generalises 'zip' by zipping with the function given as v2
904a899
> -- the first argument, instead of a tupling function.  For example, VS.null v1 || VS.null v2 = []
904a900
> -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list otherwise = (unsafeHead v1, unsafeHead v2)
904a901
> -- of corresponding sums. zip (VS.unsafeTail v1) (VS.unsafeTail v2)
904a902
> {-# INLINEzipWith :: zip(Char#-}-> Char -> a) -> ByteString -> ByteString -> [a]
906c904
< {-# INLINE zipWith #-}
---
> {-# INLINE-- | 'zipWith' generalises 'zip' by zipping with the function given aszipWith #-}
906a905
> -- the first argument, instead of a tupling function.  For example,
906a906
> -- | 'unzip' transforms a list of pairs of Chars into a pair of-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
906a907
> -- of corresponding sums.-- ByteStrings. Note that this performs two 'pack' operations.
906a908
> zipWithunzip ::::[((CharChar, ->Char)] ->->(aByteString) -> ByteString, ByteString-> ByteString)        -> [a]
906a909
> zipWithunzip lsf==(B.zipWithpack (L.map(.fstls)). fpack w2c(L.map)    snd ls))
906a910
> {-# INLINE zipWithunzip #-}#-}
909d912
< -- ByteStrings. Note that this performs two 'pack' operations.
910d912
< unzip :: [(Char, Char)] -> (ByteString, ByteString)
911c913
< unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
---
> -- ByteStrings. Note that this performs two 'pack' operations.------------------------------------------------------------------------
911a914
> unzip-- * Reading from ByteStrings:: [(Char, Char)] -> (ByteString, ByteString)
911a915
> unzip------------------------------------------------------------------------ = (pack (L.map fst ls), pack (L.map snd ls))
913d916
< 
914d916
< 
915d916
< ------------------------------------------------------------------------
916d916
< -- * Reading from ByteStrings
917d916
< ------------------------------------------------------------------------
918d916
< 
921d918
< -- it just returns the int read, and the rest of the string.
922d918
< readInt :: ByteString -> Maybe (Int, ByteString)
923c919
< readInt v
---
> -- it just returns the int read, and the rest of the string.------------------------------------------------------------------------
923a920
> readInt-- * Reading from ByteStrings:: ByteString -> Maybe (Int, ByteString)
923a921
> readInt------------------------------------------------------------------------v
925d922
<     | otherwise =
926d922
<         case unsafeHead v of
927d922
<             '-' -> loop True  0 0 (VS.unsafeTail v)
928d922
<             '+' -> loop False 0 0 (VS.unsafeTail v)
929d922
<             _   -> loop False 0 0 v
930d922
< 
931d922
<     where loop :: Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
932d922
<           loop !neg !i !n !ps
933d922
<               | VS.null ps = end neg i n ps
934d922
<               | otherwise =
935c923
<                   case VS.unsafeHead ps of
---
> -- | readInt reads an Int from the beginning of the ByteString.  If there is no| otherwise =
935a924
> -- integer at the beginning of the string, it returns Nothing, otherwisecase unsafeHead v of
935a925
> -- it just returns the int read, and the rest of the string.'-' -> loop True  0 0 (VS.unsafeTail v)
935a926
> readInt :: ByteString'+' -> loop->False0(Int0 (,VS.unsafeTail) v)
935a927
> readInt v   _   -> loop False 0 0 v
935a928
>     | VS.null v = Nothing
935a929
>     |whereloop ::= Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
935a930
>         caseloop!neg !i !v of!ps
935a931
>             '-'| ->VS.null Trueps = end 0negVS.unsafeTaili n ps      v)
935a932
>             '+'| ->otherwise False=   0 0 (VS.unsafeTail v)
935a933
>             _   ->caseVS.unsafeHead 0 0 v  ps of
937d934
<                      && w <= 0x39 -> loop neg (i+1)
938c935
<                                           (n * 10 + (fromIntegral w - 0x30))
---
>     where loop :: Bool&&->w Int<= 0x39-> Int-> ->loopneg (i+1)-> Maybe (Int, ByteString)
938a936
>           loop !neg !i !n !ps             (n * 10 + (fromIntegral w - 0x30))
938a937
>               | VS.null ps = end neg i n ps(VS.unsafeTail ps)
938a938
>               | otherwise| otherwise=       -> end neg i n ps
938a939
>                   case VS.unsafeHead ps of
938a940
>           end _    0w_|_w >== Nothing
938a941
>           end True _ &&n ps <== Just(->negatenneg, ps(i+1)
938a942
>           end _    _ n ps = Just (n, ps)  (n * 10 + (fromIntegral w - 0x30))
940d943
<                       | otherwise -> end neg i n ps
941d943
< 
942d943
<           end _    0 _ _  = Nothing
943d943
<           end True _ n ps = Just (negate n, ps)
944d943
<           end _    _ n ps = Just (n, ps)
945d943
< 
946c944
< -- | readInteger reads an Integer from the beginning of the ByteString.  If
---
> -- | readInteger reads an Integer from the beginning of the ByteString.  If otherwise -> end neg i n ps
948d945
< -- otherwise it just returns the int read, and the rest of the string.
949d945
< readInteger :: ByteString -> Maybe (Integer, ByteString)
950c946
< readInteger v
---
> -- otherwise it just returns the int read, and the rest of the string. _    0 _ _  = Nothing
950a947
> readInteger::TrueByteString n ps =->JustMaybenegate(Integer,,psByteString)        )
950a948
> readIntegerv _    _ n ps = Just (n, ps)
952d949
<     | otherwise =
953d949
<         case unsafeHead v of
954d949
<             '-' -> first (VS.unsafeTail v) >>= \(n, bs) -> return (-n, bs)
955d949
<             '+' -> first (VS.unsafeTail v)
956d949
<             _   -> first v
957d949
< 
958d949
<     where first ps | VS.null ps = Nothing
959d949
<                    | otherwise =
960d949
<                        case VS.unsafeHead ps of
961d949
<                         w | w >= 0x30 && w <= 0x39 -> Just $
962c950
<                             loop 1 (fromIntegral w - 0x30) [] (VS.unsafeTail ps)
---
> -- | readInteger reads an Integer from the beginning of the ByteString.  If| otherwise =
962a951
> -- there is no integer at the beginning of the string, it returns Nothing,case unsafeHead v of
962a952
> -- otherwise it just returns the int read, and the rest of the string.'-' -> first (VS.unsafeTail v) >>= \(n, bs) -> return (-n, bs)
962a953
> readInteger ::'+'ByteString-> first (->VS.unsafeTail (Integerv) , ByteString)
962a954
> readInteger v    -> first v
962a955
>     | VS.null v = Nothing
962a956
>     |wherefirst =ps | VS.null ps = Nothing
962a957
>         case unsafeHead| otherwise of   =
962a958
>             '-' -> firstcaseVS.unsafeTailVS.unsafeHead)psof\(n, bs) -> return (-n, bs)
962a959
>             '+' -> firstw(VS.unsafeTail| w >= 0x30 &&v) <= 0x39 -> Just $
962a960
>             _   -> first v  loop 1 (fromIntegral w - 0x30) [] (VS.unsafeTail ps)
964d961
< 
965d961
<           loop :: Int -> Int -> [Integer]
966d961
<                -> ByteString -> (Integer, ByteString)
967d961
<           loop !d !acc !ns !ps
968d961
<               | VS.null ps = combine d acc ns VS.empty
969c962
<               | otherwise =
---
>     where first ps | VS.null ps = Nothing
969a963
>           loop :: Int otherwise-> Int ->=[Integer]
969a964
>                -> ByteString VS.unsafeHead-> (Integer, psByteStringof     )
969a965
>           loop !d !acc !wns|!wps>= 0x30 && w <= 0x39 -> Just $
969a966
>               | VS.null ps =loopcombine (fromIntegrald acc ns VS.empty - 0x30) [] (VS.unsafeTail ps)
969a967
>               | otherwise | otherwise              -> Nothing
971d968
<                    w | w >= 0x30 && w <= 0x39 ->
972c969
<                        if d == 9 then loop 1 (fromIntegral w - 0x30)
---
>           loop :: Intw |->w Int>= 0x30-> [Integer&& w <=]0x39 ->
972a970
>                -> ByteStringif d ==->9(Integerthen loop, ByteString1 (fromIntegral)      w - 0x30)
972a971
>           loop !d !acc !ns !ps             (toInteger acc : ns)
972a972
>               | VS.null ps = combine d acc ns(VS.unsafeTail    ps)
972a973
>               | otherwise =      else loop (d+1)
972a974
>                   case VS.unsafeHead ps of (10*acc + (fromIntegral w - 0x30))
972a975
>                    w | w >= 0x30 && w <= 0x39ns ->(VS.unsafeTail ps)
972a976
>                      | ifotherwise == 9 then-> combine 1d(fromIntegralacc ns ps    w - 0x30)
974d977
<                                            (VS.unsafeTail ps)
975d977
<                                  else loop (d+1)
976c978
<                                            (10*acc + (fromIntegral w - 0x30))
---
>           combine _ acc [] ps = (toInteger (accVS.unsafeTail, ps)       ps)
976a979
>           combine d acc ns ps =  else loop (d+1)
976a980
>               ((10^d * combine1 1000000000 (ns10*acctoInteger (fromIntegralacc), ps)w - 0x30))
978d981
<                      | otherwise -> combine d acc ns ps
979c982
< 
---
>           combine1 _ |notherwise] = n     -> combine d acc ns ps
979a983
>           combine1 b ns  = combine1 (b*b) $ combine2 b ns
981d984
<           combine d acc ns ps =
982c985
<               ((10^d * combine1 1000000000 ns + toInteger acc), ps)
---
>           combinecombine2dbacc(n:nsm:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
982a986
>           combine2(10^d *nscombine1= 1000000000ns         ns + toInteger acc), ps)
985d988
<           combine1 b ns  = combine1 (b*b) $ combine2 b ns
986d988
< 
987d988
<           combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
988d988
<           combine2 _ ns       = ns
989d988
< 
990d988
< 
991c989
< ------------------------------------------------------------------------
---
> ------------------------------------------------------------------------ b ns  = combine1 (b*b) $ combine2 b ns
993d990
< ------------------------------------------------------------------------
994c991
< 
---
> ------------------------------------------------------------------------ b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
994a992
>           combine2 _ ns       = ns
997d994
< 
998d994
< -- | Write a ByteString to stdout, appending a newline byte
999c995
< putStrLn :: ByteString -> IO ()
---
> ------------------------------------------------------------------------
999a996
> -- * * I\/O with ByteStrings-- | Write a ByteString to stdout, appending a newline byte
999a997
> putStrLn------------------------------------------------------------------------:: ByteString -> IO ()
1001d998
< 
1002a1000
> -- ** Standard input and output------------------------------------------------------------------------
1004d1001
< 
1005d1001
< -- | Read an entire file strictly into a 'ByteString'.  This is far more
1006c1002
< -- efficient than reading the characters into a 'String' and then using
---
> -- | Write a ByteString to stdout, appending a newline byte
1006a1003
> putStrLn-- | Read an entire file strictly into a 'ByteString'.  This is far more:: ByteString -> IO ()
1006a1004
> putStrLn-- efficient than reading the characters into a 'String' and then using= hPutStrLn stdout
1008d1005
< -- reading it using hGet.
1009c1006
< readFile :: FilePath -> IO ByteString
---
> -- reading it using hGet.------------------------------------------------------------------------
1009a1007
> readFile-- ** Files:: FilePath -> IO ByteString
1011d1008
<                hFileSize h >>= B.hGet h . fromIntegral
1012d1008
< 
1013d1008
< -- | Write a 'ByteString' to a file.
1014d1008
< writeFile :: FilePath -> ByteString -> IO ()
1015d1008
< writeFile f txt = withFile f WriteMode $ \h -> B.hPut h txt
1016d1008
< 
1017c1009
< -- | Append a 'ByteString' to a file.
---
> -- | Read an entire file strictly into a 'ByteString'.  This is far morehFileSize h >>= B.hGet h . fromIntegral
1017a1010
> -- efficient than reading the characters into a 'String' and then using
1017a1011
> -- | Write a 'ByteString' to a file.-- 'pack'.  It also may be more efficient than opening the file and
1017a1012
> writeFile-- reading it using hGet.:: FilePath -> ByteString -> IO ()
1017a1013
> readFilewriteFile::f FilePathtxt = withFile-> IO ByteStringf WriteMode $ \h -> B.hPut h txt
1017a1014
> readFile f = withFile f ReadMode $ \h ->
1017a1015
> -- | Append a 'ByteString' to a file. h >>= B.hGet h . fromIntegral
1019d1016
< appendFile f txt = withFile f AppendMode $ \h -> B.hPut h txt
1020d1016
< 
1021c1017
< ------------------------------------------------------------------------
---
> appendFile-- | Write a 'ByteString' to a file.f txt = withFile f AppendMode $ \h -> B.hPut h txt
1021a1018
> writeFile :: FilePath -> ByteString -> IO ()
1021a1019
> writeFile------------------------------------------------------------------------ txt = withFile f WriteMode $ \h -> B.hPut h txt
1023d1020
< 
1024d1020
< -- | Write a ByteString to a handle, appending a newline byte
1025c1021
< hPutStrLn :: Handle -> ByteString -> IO ()
---
> -- | Append a 'ByteString' to a file.
1025a1022
> appendFile-- | Write a ByteString to a handle, appending a newline byte:: FilePath -> ByteString -> IO ()
1025a1023
> appendFilehPutStrLn :: txtHandle= withFile-> ByteString AppendMode-> IO ($ \h -> B.hPut h txt
1027d1024
<     | VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
1028c1025
<     | otherwise = do B.hPut h v
---
> ------------------------------------------------------------------------| VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
1028a1026
> -- ** I\/O with Handles| otherwise = do B.hPut h v
1030c1028
<     where
---
> -- | Write a ByteString to a handle, appending a newline bytewhere
1030a1029
> hPutStrLnnl =::c2w'\n' -> ByteString -> IO ()
1030a1030
> hPutStrLn h v
1030a1031
>     | VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
1030a1032
> ------------------------------------------------------------------------ otherwise = do B.hPut h v
1030a1033
>                                                                    -- * Utils           B.hPut h $ VS.singleton nl -- don't copy
1030a1034
> ------------------------------------------------------------------------where
1032d1035
< 
1033d1035
< 
1034d1035
< ------------------------------------------------------------------------
1035d1035
< -- * Utils
1036d1035
< ------------------------------------------------------------------------
1037d1035
< 
1040d1037
< -- there is an obligation on the programmer to provide a proof that the
1041d1037
< -- ByteString is non-empty.
1042c1038
< unsafeHead :: ByteString -> Char
---
> -- there is an obligation on the programmer to provide a proof that the------------------------------------------------------------------------
1042a1039
> -- * Utils-- ByteString is non-empty.
1042a1040
> unsafeHead------------------------------------------------------------------------:: ByteString -> Char
1044c1042
< {-# INLINE unsafeHead #-}
---
> {-# INLINE-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omitsunsafeHead #-}
1044a1043
> -- the check for the empty case, which is good for performance, but
1044a1044
> -- there is an obligation on the programmer to provide a proof that the
1044a1045
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP
           , NoImplicitPrelude
           , BangPatterns
           , TypeSynonymInstances
           , FlexibleInstances
           , MagicHash
           , UnboxedTuples
  #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-orphans #-}

-- |
-- Module      : Data.Vector.Storable.ByteString.Char8
-- Copyright   : (c) Don Stewart 2006-2008
--               (c) Bas van Dijk 2011
-- License     : BSD-style
--
-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental
--
-- Manipulate 'ByteString's using 'Char' operations. All Chars will be
-- truncated to 8 bits. It can be expected that these functions will run
-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
--
-- More specifically these byte strings are taken to be in the
-- subset of Unicode covered by code points 0-255. This covers
-- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
--
-- See:
--
--  * <http://www.unicode.org/charts/>
--
--  * <http://www.unicode.org/charts/PDF/U0000.pdf>
--
--  * <http://www.unicode.org/charts/PDF/U0080.pdf>
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.Vector.Storable.ByteString.Char8 as B
--
-- The Char8 interface to bytestrings provides an instance of IsString
-- for the ByteString type, enabling you to use string literals, and
-- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
-- to enable this.
--

module Data.Vector.Storable.ByteString.Char8 (

        -- * The ByteString type
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating ByteStrings
        B.empty,           -- :: ByteString
        singleton,         -- :: Char   -> ByteString
        pack,              -- :: String -> ByteString
        unpack,            -- :: ByteString -> String

        -- * Basic interface
        cons,              -- :: Char -> ByteString -> ByteString
        snoc,              -- :: ByteString -> Char -> ByteString
        B.append,          -- :: ByteString -> ByteString -> ByteString
        head,              -- :: ByteString -> Char
        uncons,            -- :: ByteString -> Maybe (Char, ByteString)
        last,              -- :: ByteString -> Char
        B.tail,            -- :: ByteString -> ByteString
        B.init,            -- :: ByteString -> ByteString
        B.null,            -- :: ByteString -> Bool
        B.length,          -- :: ByteString -> Int

        -- * Transformating ByteStrings
        map,               -- :: (Char -> Char) -> ByteString -> ByteString
        B.reverse,         -- :: ByteString -> ByteString
        intersperse,       -- :: Char -> ByteString -> ByteString
        B.intercalate,     -- :: ByteString -> [ByteString] -> ByteString
        B.transpose,       -- :: [ByteString] -> [ByteString]

        -- * Reducing ByteStrings (folds)
        foldl,             -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',            -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,            -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',           -- :: (Char -> Char -> Char) -> ByteString -> Char

        foldr,             -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr',            -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,            -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1',           -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        B.concat,          -- :: [ByteString] -> ByteString
        concatMap,         -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,               -- :: (Char -> Bool) -> ByteString -> Bool
        all,               -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,           -- :: ByteString -> Char
        minimum,           -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanl1,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString
        scanr,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanr1,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Generating and unfolding ByteStrings
        replicate,         -- :: Int -> Char -> ByteString
        unfoldr,           -- :: (a -> Maybe (Char, a)) -> a -> ByteString
        unfoldrN,          -- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        B.take,            -- :: Int -> ByteString -> ByteString
        B.drop,            -- :: Int -> ByteString -> ByteString
        B.splitAt,         -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,         -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,         -- :: (Char -> Bool) -> ByteString -> ByteString
        span,              -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,             -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,          -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        B.group,           -- :: ByteString -> [ByteString]
        groupBy,           -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        B.inits,           -- :: ByteString -> [ByteString]
        B.tails,           -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,             -- :: Char -> ByteString -> [ByteString]
        splitWith,         -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,             -- :: ByteString -> [ByteString]
        words,             -- :: ByteString -> [ByteString]
        unlines,           -- :: [ByteString] -> ByteString
        unwords,           -- :: ByteString -> [ByteString]

        -- * Predicates
        B.isPrefixOf,      -- :: ByteString -> ByteString -> Bool
        B.isSuffixOf,      -- :: ByteString -> ByteString -> Bool
        B.isInfixOf,       -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
        B.breakSubstring,  -- :: ByteString -> ByteString -> (ByteString,ByteString)
        B.findSubstring,   -- :: ByteString -> ByteString -> Maybe Int
        B.findSubstrings,  -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,              -- :: Char -> ByteString -> Bool
        notElem,           -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,              -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,            -- :: (Char -> Bool) -> ByteString -> ByteString

        -- * Indexing ByteStrings
        index,             -- :: ByteString -> Int -> Char
        elemIndex,         -- :: Char -> ByteString -> Maybe Int
        elemIndices,       -- :: Char -> ByteString -> [Int]
        elemIndexEnd,      -- :: Char -> ByteString -> Maybe Int
        findIndex,         -- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndices,       -- :: (Char -> Bool) -> ByteString -> [Int]
        count,             -- :: Char -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,               -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,           -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        unzip,             -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        B.sort,            -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,           -- :: ByteString -> Maybe (Int, ByteString)
        readInteger,       -- :: ByteString -> Maybe (Integer, ByteString)

        -- * Low level CString conversions

        -- ** Copying ByteStrings
        B.copy,            -- :: ByteString -> ByteString

        -- ** Packing CStrings and pointers
        B.packCString,     -- :: CString -> IO ByteString
        B.packCStringLen,  -- :: CStringLen -> IO ByteString

        -- ** Using ByteStrings as CStrings
        B.useAsCString,    -- :: ByteString -> (CString    -> IO a) -> IO a
        B.useAsCStringLen, -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- * I\/O with ByteStrings

        -- ** Standard input and output
        B.getLine,         -- :: IO ByteString
        B.getContents,     -- :: IO ByteString
        B.putStr,          -- :: ByteString -> IO ()
        putStrLn,          -- :: ByteString -> IO ()
        B.interact,        -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,          -- :: FilePath -> IO ByteString
        writeFile,         -- :: FilePath -> ByteString -> IO ()
        appendFile,        -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        B.hGetLine,        -- :: Handle -> IO ByteString
        B.hGetContents,    -- :: Handle -> IO ByteString
        B.hGet,            -- :: Handle -> Int -> IO ByteString
        B.hGetNonBlocking, -- :: Handle -> Int -> IO ByteString
        B.hPut,            -- :: Handle -> ByteString -> IO ()
        B.hPutNonBlocking, -- :: Handle -> ByteString -> IO ByteString
        B.hPutStr,         -- :: Handle -> ByteString -> IO ()
        hPutStrLn,         -- :: Handle -> ByteString -> IO ()

  ) where

--------------------------------------------------------------------------------
-- Imports
--------------------------------------------------------------------------------

-- from base:
import Control.Monad      ( (>>=), (>>), return )
import Data.Bool          ( Bool(False, True), (&&), (||), not, otherwise )
import Data.Char          ( Char, isSpace )
import Data.Eq            ( (==) )
import Data.Function      ( (.), ($) )
import Data.Functor       ( fmap )
import Data.Int           ( Int )
import Data.Maybe         ( Maybe(Nothing, Just) )
import Data.Ord           ( (<), (<=), (>=) )
import Data.String        ( IsString, fromString )
import Data.Tuple         ( fst, snd )
import Foreign.ForeignPtr ( withForeignPtr )
import Foreign.Storable   ( peekElemOff, peekByteOff )
import Prelude            ( String, Integer, fromIntegral, toInteger, negate
                          , (*), (+), (-), (^), ($!), seq,
                          )
import System.IO          ( IO, FilePath, Handle
                          , IOMode(ReadMode, WriteMode, AppendMode)
                          , withFile, stdout, hFileSize
                          )

import GHC.Base           ( Char(..), unpackCString#, ord#, int2Word# )
import GHC.IO             ( stToIO )
import GHC.Prim           ( Addr#, plusAddr#, writeWord8OffAddr# )
import GHC.Ptr            ( Ptr(..) )
import GHC.ST             ( ST(..) )

import qualified Data.List as L ( length, map, intersperse, filter )

-- from vector:
import qualified Data.Vector.Storable as VS

-- from primitive:
import Control.Monad.Primitive ( unsafeInlineIO )

-- from vector-bytestring (this package):
import Data.Vector.Storable.ByteString.Internal ( c2w, w2c, isSpaceWord8 )

import qualified Data.Vector.Storable.ByteString as B
import Data.Vector.Storable.ByteString.Internal ( unsafeCreate )
import Data.Vector.Storable.ByteString.Unsafe   ( unsafePackAddress )

import Data.Vector.Storable.ByteString ( ByteString )


------------------------------------------------------------------------
-- * Introducing and eliminating ByteStrings
------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = VS.singleton . c2w
{-# INLINE singleton #-}

instance IsString ByteString where
    fromString = pack
    {-# INLINE fromString #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck.
pack :: String -> ByteString
pack str = unsafeCreate (L.length str) $ \(Ptr p) -> stToIO (go p str)
    where
      go :: Addr# -> [Char] -> ST a ()
      go _ []          = return ()
      go p (C# c : cs) = writeByte >> go (p `plusAddr#` 1#) cs
          where
            writeByte = ST $ \s# ->
              case writeWord8OffAddr# p 0# (int2Word# (ord# c)) s# of
                s2# -> (# s2#, () #)
            {-# INLINE writeByte #-}
{-# INLINE [1] pack #-}

{-# RULES
"ByteString pack/packAddress" forall s .
   pack (unpackCString# s) = unsafeInlineIO (unsafePackAddress s)
 #-}

{-
TODO: Unfortunately the following definition of pack is slower:

pack = VS.fromList . L.map c2w

Probably because of the intermediate list that is constructed and immediately
consumed. However, this definition is amenable to stream-fusion because of the
VS.fromList.

So lets try to fuse the construction of the list with the construction of the
Stream. To do that we need to add the following to:
Data.Vector.Fusion.Stream.Monadic

    #if __GLASGOW_HASKELL__
    import GHC.Base ( build )
    #endif

    #if __GLASGOW_HASKELL__
     {-# RULES
    "unsafeFromList/build"
      forall sz (g :: forall b. (a -> b -> b) -> b -> b).
      unsafeFromList sz (build g) = unsafeFromListF sz g
      #-}
    unsafeFromListF :: forall m a. Monad m
                    => Size
                    -> (forall b. (a -> b -> b) -> b -> b)
                    -> Stream m a
    {-# INLINE unsafeFromListF #-}
    unsafeFromListF sz g = Stream step st sz
        where
          St step st = g c z

          c :: a -> St m a -> St m a
          c x st = St (\(St s st') -> s st')
                      (St (\s -> return (Yield x s)) st)

          z :: St m a
          z = St (\_ -> return Done) undefined

    data St m a = St ((St m a) -> m (Step (St m a) a)) (St m a)
    #endif

Unfortunately, initial experiments failed to make it faster.
-}

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = L.map w2c . B.unpack
{-# INLINE unpack #-}


------------------------------------------------------------------------
-- * Basic interface
------------------------------------------------------------------------

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Char -> ByteString -> ByteString
cons = VS.cons . c2w
{-# INLINE cons #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = VS.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . VS.head
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Char, ByteString)
uncons = fmap (\(w,v) -> (w2c w, v)) . B.uncons
{-# INLINE uncons #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . VS.last
{-# INLINE last #-}


------------------------------------------------------------------------
-- * Transformating ByteStrings
------------------------------------------------------------------------

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = VS.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = B.intersperse . c2w
{-# INLINE intersperse #-}


------------------------------------------------------------------------
-- * Reducing ByteStrings (folds)
------------------------------------------------------------------------

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = VS.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = VS.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = VS.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldr\'' is a strict variant of foldr
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr' f = VS.foldr' (\c a -> f (w2c c) a)
{-# INLINE foldr' #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE foldl1 #-}

-- | A strict version of 'foldl1'
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f v = w2c (VS.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE foldl1' #-}

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE foldr1 #-}

-- | A strict variant of foldr1
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr1' f v = w2c (VS.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE foldr1' #-}

------------------------------------------------------------------------
-- ** Special folds

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = VS.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = VS.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = VS.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . VS.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . VS.minimum
{-# INLINE minimum #-}


------------------------------------------------------------------------
-- * Building ByteStrings
------------------------------------------------------------------------

------------------------------------------------------------------------
-- ** Scans

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left:
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINE scanl #-}

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanl1 f = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINE scanl1 #-}

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr f z = VS.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINE scanr #-}

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr1 f = VS.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINE scanr1 #-}

------------------------------------------------------------------------
-- ** Accumulating maps

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Char -> (acc, Char))
          -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = B.mapAccumL $ \acc w ->
                case f acc (w2c w) of
                  (acc', c) -> (acc', c2w c)
{-# INLINE mapAccumL #-}

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char))
          -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = B.mapAccumR $ \acc w ->
                case f acc (w2c w) of
                  (acc', c) -> (acc', c2w c)
{-# INLINE mapAccumR #-}

------------------------------------------------------------------------
-- ** Generating and unfolding ByteStrings

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
--
-- This implemenation uses @memset(3)@
replicate :: Int -> Char -> ByteString
replicate w = B.replicate w . c2w
{-# INLINE replicate #-}

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
-- ByteString from a seed value.  The function takes the element and
-- returns 'Nothing' if it is done producing the ByteString or returns
-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f x0 = VS.unfoldr (fmap k . f) x0
    where k (i, j) = (c2w i, j)
{-# INLINE unfoldr #-}

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > unfoldrN n f s == take n (unfoldr f s)
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
    where k (i,j) = (c2w i, j)
{-# INLINE unfoldrN #-}


------------------------------------------------------------------------
-- * Substrings
------------------------------------------------------------------------

------------------------------------------------------------------------
-- ** Breaking strings

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = VS.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = VS.dropWhile (f . w2c)
{-# INLINE [1] dropWhile #-}

{-# RULES
"ByteString specialise dropWhile isSpace -> dropSpace"
    dropWhile isSpace = dropSpace
  #-}

-- | 'dropSpace' efficiently returns the 'ByteString' argument with
-- white space Chars removed from the front. It is more efficient than
-- calling dropWhile for removing whitespace. I.e.
--
-- > dropWhile isSpace == dropSpace
--
dropSpace :: ByteString -> ByteString
dropSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
    let go !i
            | i >= l    = return VS.empty
            | otherwise = do
                w <- peekElemOff p i
                if isSpaceWord8 w
                  then go (i+1)
                  else return $ VS.unsafeFromForeignPtr fp i (l-i)
    in go 0
        where
          (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE dropSpace #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = VS.span (f . w2c)
{-# INLINE span #-}

-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and
--
-- > spanEnd (not . isSpace) v
-- >    ==
-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
--
spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd f = B.spanEnd (f . w2c)
{-# INLINE spanEnd #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = VS.break (f . w2c)
{-# INLINE [1] break #-}

{-# RULES
"ByteString specialise break (x==)" forall x.
    break ((==) x) = breakChar x
"ByteString specialise break (==x)" forall x.
    break (==x) = breakChar x
  #-}

-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar c v = case elemIndex c v of
    Nothing -> (v, VS.empty)
    Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
{-# INLINE breakChar #-}

{-# RULES
"ByteString specialise break -> breakSpace"
    break isSpace = breakSpace
  #-}

-- | 'breakSpace' returns the pair of ByteStrings when the argument is
-- broken at the first whitespace byte. I.e.
--
-- > break isSpace == breakSpace
--
breakSpace :: ByteString -> (ByteString,ByteString)
breakSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
    let go !i
            | i >= l    = return (vec l, VS.empty)
            | otherwise = do
                w <- peekByteOff p i
                if (not . isSpaceWord8) w
                  then go (i+1)
                  else return $!
                       if i == 0
                       then (VS.empty, vec l)
                       else (vec i, VS.unsafeFromForeignPtr fp i (l-i))
    in go 0
        where
          (fp, l) = VS.unsafeToForeignPtr0 v
          vec = VS.unsafeFromForeignPtr0 fp
{-# INLINE breakSpace #-}

-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
--
-- breakEnd p == spanEnd (not.p)
breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd f = B.breakEnd (f . w2c)
{-# INLINE breakEnd #-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))
{-# INLINE groupBy #-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = B.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = B.splitWith (f . w2c)
{-# INLINE splitWith #-} -- the inline makes a big difference here.

------------------------------------------------------------------------
-- ** Breaking into lines and words

-- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- newline Chars. The resulting strings do not contain newlines.
lines :: ByteString -> [ByteString]
lines v
    | VS.null v = []
    | otherwise = case elemIndex '\n' v of
        Nothing -> [v]
        Just n  -> VS.unsafeTake n v : lines (VS.unsafeDrop (n+1) v)
{-# INLINE lines #-}

-- | 'words' breaks a ByteString up into a list of words, which
-- were delimited by Chars representing white space.
words :: ByteString -> [ByteString]
words = L.filter (not . VS.null) . B.splitWith isSpaceWord8
{-# INLINE words #-}

-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = VS.empty
unlines vs = VS.concat (L.intersperse (VS.singleton nl) vs) `VS.snoc` nl
    where
      nl = c2w '\n'
{-# INLINE unlines #-}

-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords :: [ByteString] -> ByteString
unwords = B.intercalate (singleton ' ')
{-# INLINE unwords #-}


------------------------------------------------------------------------
-- * Searching ByteStrings
------------------------------------------------------------------------

------------------------------------------------------------------------
-- ** Searching by equality

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem c = VS.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = VS.notElem (c2w c)
{-# INLINE notElem #-}

------------------------------------------------------------------------
-- ** Searching with a predicate

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find :: (Char -> Bool) -> ByteString -> Maybe Char
find f v = w2c `fmap` VS.find (f . w2c) v
{-# INLINE find #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = VS.filter (f . w2c)
{-# INLINE filter #-}


------------------------------------------------------------------------
-- * Indexing ByteStrings
------------------------------------------------------------------------

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Char
index = (w2c .) . (VS.!)
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int
elemIndex = VS.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int]
elemIndices = B.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Char -> ByteString -> Maybe Int
elemIndexEnd = B.elemIndexEnd . c2w
{-# INLINE elemIndexEnd #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
findIndex f = VS.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int]
findIndices f = B.findIndices (f . w2c)
{-# INLINE findIndices #-}

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- Also
--
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int
count c = B.count (c2w c)
{-# INLINE count #-}


------------------------------------------------------------------------
-- * Zipping and unzipping ByteStrings
------------------------------------------------------------------------

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings
zip :: ByteString -> ByteString -> [(Char, Char)]
zip v1 v2
    | VS.null v1 || VS.null v2 = []
    | otherwise = (unsafeHead v1, unsafeHead v2)
                : zip (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINE zip #-}

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = B.zipWith ((. w2c) . f . w2c)
{-# INLINE zipWith #-}

-- | 'unzip' transforms a list of pairs of Chars into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Char, Char)] -> (ByteString, ByteString)
unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
{-# INLINE unzip #-}


------------------------------------------------------------------------
-- * Reading from ByteStrings
------------------------------------------------------------------------

-- | readInt reads an Int from the beginning of the ByteString.  If there is no
-- integer at the beginning of the string, it returns Nothing, otherwise
-- it just returns the int read, and the rest of the string.
readInt :: ByteString -> Maybe (Int, ByteString)
readInt v
    | VS.null v = Nothing
    | otherwise =
        case unsafeHead v of
            '-' -> loop True  0 0 (VS.unsafeTail v)
            '+' -> loop False 0 0 (VS.unsafeTail v)
            _   -> loop False 0 0 v

    where loop :: Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
          loop !neg !i !n !ps
              | VS.null ps = end neg i n ps
              | otherwise =
                  case VS.unsafeHead ps of
                    w | w >= 0x30
                     && w <= 0x39 -> loop neg (i+1)
                                          (n * 10 + (fromIntegral w - 0x30))
                                          (VS.unsafeTail ps)
                      | otherwise -> end neg i n ps

          end _    0 _ _  = Nothing
          end True _ n ps = Just (negate n, ps)
          end _    _ n ps = Just (n, ps)

-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.
readInteger :: ByteString -> Maybe (Integer, ByteString)
readInteger v
    | VS.null v = Nothing
    | otherwise =
        case unsafeHead v of
            '-' -> first (VS.unsafeTail v) >>= \(n, bs) -> return (-n, bs)
            '+' -> first (VS.unsafeTail v)
            _   -> first v

    where first ps | VS.null ps = Nothing
                   | otherwise =
                       case VS.unsafeHead ps of
                        w | w >= 0x30 && w <= 0x39 -> Just $
                            loop 1 (fromIntegral w - 0x30) [] (VS.unsafeTail ps)
                          | otherwise              -> Nothing

          loop :: Int -> Int -> [Integer]
               -> ByteString -> (Integer, ByteString)
          loop !d !acc !ns !ps
              | VS.null ps = combine d acc ns VS.empty
              | otherwise =
                  case VS.unsafeHead ps of
                   w | w >= 0x30 && w <= 0x39 ->
                       if d == 9 then loop 1 (fromIntegral w - 0x30)
                                           (toInteger acc : ns)
                                           (VS.unsafeTail ps)
                                 else loop (d+1)
                                           (10*acc + (fromIntegral w - 0x30))
                                           ns (VS.unsafeTail ps)
                     | otherwise -> combine d acc ns ps

          combine _ acc [] ps = (toInteger acc, ps)
          combine d acc ns ps =
              ((10^d * combine1 1000000000 ns + toInteger acc), ps)

          combine1 _ [n] = n
          combine1 b ns  = combine1 (b*b) $ combine2 b ns

          combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns


------------------------------------------------------------------------
-- * * I\/O with ByteStrings
------------------------------------------------------------------------

------------------------------------------------------------------------
-- ** Standard input and output

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn = hPutStrLn stdout

------------------------------------------------------------------------
-- ** Files

-- | Read an entire file strictly into a 'ByteString'.  This is far more
-- efficient than reading the characters into a 'String' and then using
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet.
readFile :: FilePath -> IO ByteString
readFile f = withFile f ReadMode $ \h ->
               hFileSize h >>= B.hGet h . fromIntegral

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = withFile f WriteMode $ \h -> B.hPut h txt

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = withFile f AppendMode $ \h -> B.hPut h txt

------------------------------------------------------------------------
-- ** I\/O with Handles

-- | Write a ByteString to a handle, appending a newline byte
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn h v
    | VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
    | otherwise = do B.hPut h v
                     B.hPut h $ VS.singleton nl -- don't copy
    where
      nl = c2w '\n'


------------------------------------------------------------------------
-- * Utils
------------------------------------------------------------------------

-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
-- the check for the empty case, which is good for performance, but
-- there is an obligation on the programmer to provide a proof that the
-- ByteString is non-empty.
unsafeHead :: ByteString -> Char
unsafeHead  = w2c . VS.unsafeHead
{-# INLINE unsafeHead #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP
           , NoImplicitPrelude
           , BangPatterns
           , TypeSynonymInstances
           , FlexibleInstances
           , MagicHash
           , UnboxedTuples
  #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif{-# LANGUAGE Trustworthy #-}

{-# OPTIONS_GHC -fno-warn-orphans #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
-- |
-- |-- Module      : Data.Vector.Storable.ByteString.Char8
-- Copyright   : (c) Don Stewart 2006-2008-- Module      : Data.Vector.Storable.ByteString.Char8
--               (c) Bas van Dijk 2011-- Copyright   : (c) Don Stewart 2006-2008
-- License     : BSD-style--               (c) Bas van Dijk 2011
---- License     : BSD-style
---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
---- Stability   : experimental
---- Manipulate 'ByteString's using 'Char' operations. All Chars will be
-- Manipulate 'ByteString's using 'Char' operations. All Chars will be-- truncated to 8 bits. It can be expected that these functions will run
-- truncated to 8 bits. It can be expected that these functions will run-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
---- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
---- More specifically these byte strings are taken to be in the
-- More specifically these byte strings are taken to be in the
-- subset of Unicode covered by code points 0-255. This covers
---- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
---- See:
---- See:
----  * <http://www.unicode.org/charts/>
----  * <http://www.unicode.org/charts/>
----  * <http://www.unicode.org/charts/PDF/U0000.pdf>
----  * <http://www.unicode.org/charts/PDF/U0000.pdf>
----  * <http://www.unicode.org/charts/PDF/U0080.pdf>
----  * <http://www.unicode.org/charts/PDF/U0080.pdf>
---- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
---- clashes with "Prelude" functions.  eg.
---- > import qualified Data.Vector.Storable.ByteString.Char8 as B
---- > import qualified Data.Vector.Storable.ByteString.Char8 as B
---- The Char8 interface to bytestrings provides an instance of IsString
-- for the ByteString type, enabling you to use string literals, and-- The Char8 interface to bytestrings provides an instance of IsString
-- for the ByteString type, enabling you to use string literals, and-- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
-- to enable this.-- have them implicitly packed to ByteStrings. Use -XOverloadedStrings
---- to enable this.
--
module Data.Vector.Storable.ByteString.Char8 (
module Data.Vector.Storable.ByteString.Char8 (
        -- * The ByteString type
        ByteString-- * The ByteString type,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
        -- * Introducing and eliminating ByteStrings
        B.empty-- * Introducing and eliminating ByteStrings,           -- :: ByteString
        B.emptysingleton, ,         -- :: ByteString-- :: Char   -> ByteString
        singletonpack,    ,         -- :: Char   -> ByteString
        packunpack, ,            -- :: String -> ByteString
        unpack,            -- :: ByteString -> String
        -- * Basic interface
        cons-- * Basic interface,              -- :: Char -> ByteString -> ByteString
        cons,              -- :: Char -> ByteString -> ByteString
        snocB.append,   ,          -- :: ByteString -> Char -> ByteString-- :: ByteString -> ByteString -> ByteString
        B.appendhead,   ,          -- :: ByteString -> Char-- :: ByteString -> ByteString -> ByteString
        headuncons, ,            -- :: ByteString -> Char-- :: ByteString -> Maybe (Char, ByteString)
        unconslast, ,            -- :: ByteString -> Char-- :: ByteString -> Maybe (Char, ByteString)
        lastB.tail, ,            -- :: ByteString -> Char-- :: ByteString -> ByteString
        B.tail,            -- :: ByteString -> ByteString
        B.init,            -- :: ByteString -> Bool-- :: ByteString -> ByteString
        B.nullB.length, ,          -- :: ByteString -> Int-- :: ByteString -> Bool
        B.length,          -- :: ByteString -> Int
        -- * Transformating ByteStrings
        map-- * Transformating ByteStrings,               -- :: (Char -> Char) -> ByteString -> ByteString
        mapB.reverse,     ,         -- :: ByteString -> ByteString-- :: (Char -> Char) -> ByteString -> ByteString
        B.reverseintersperse, ,       -- :: ByteString -> ByteString-- :: Char -> ByteString -> ByteString
        intersperseB.intercalate, ,     -- :: Char -> ByteString -> ByteString-- :: ByteString -> [ByteString] -> ByteString
        B.intercalateB.transpose, ,     -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
        B.transpose,       -- :: [ByteString] -> [ByteString]
        -- * Reducing ByteStrings (folds)
        foldl-- * Reducing ByteStrings (folds),             -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldlfoldl',,            -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',            -- :: (a -> Char -> a) -> a -> ByteString -> a-- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1foldl1',,           -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',           -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr,             -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldrfoldr',,            -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr',            -- :: (Char -> a -> a) -> a -> ByteString -> a-- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1foldr1',,           -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1',           -- :: (Char -> Char -> Char) -> ByteString -> Char
        -- ** Special folds
        B.concat-- ** Special folds,          -- :: [ByteString] -> ByteString
        B.concatconcatMap,,         -- :: [ByteString] -> ByteString-- :: (Char -> ByteString) -> ByteString -> ByteString
        concatMapany,     ,         -- :: (Char -> Bool) -> ByteString -> Bool-- :: (Char -> ByteString) -> ByteString -> ByteString
        any,               -- :: (Char -> Bool) -> ByteString -> Bool
        allmaximum,   ,           -- :: ByteString -> Char-- :: (Char -> Bool) -> ByteString -> Bool
        maximum,           -- :: ByteString -> Char
        minimum,           -- :: ByteString -> Char
        -- * Building ByteStrings
        -- ** Scans-- * Building ByteStrings
        scanl-- ** Scans,             -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanlscanl1,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanl1scanr,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanrscanr1,,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString-- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanr1,            -- :: (Char -> Char -> Char) -> ByteString -> ByteString
        -- ** Accumulating maps
        mapAccumL-- ** Accumulating maps,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumL,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,         -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        -- ** Generating and unfolding ByteStrings
        replicate-- ** Generating and unfolding ByteStrings,         -- :: Int -> Char -> ByteString
        replicateunfoldr, ,         -- :: Int -> Char -> ByteString-- :: (a -> Maybe (Char, a)) -> a -> ByteString
        unfoldrunfoldrN,,          -- :: (a -> Maybe (Char, a)) -> a -> ByteString-- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
        unfoldrN,          -- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
        -- * Substrings
        -- * Substrings
        -- ** Breaking strings
        B.take-- ** Breaking strings,            -- :: Int -> ByteString -> ByteString
        B.take,            -- :: Int -> ByteString -> ByteString
        B.dropB.splitAt,  ,         -- :: Int -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
        B.splitAt,         -- :: (Char -> Bool) -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,         -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhilespan,    ,         -- :: (Char -> Bool) -> ByteString -> ByteString-- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanspanEnd,  ,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEndbreak, ,           -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakbreakEnd,  ,          -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEndB.group,,          -- :: ByteString -> [ByteString]-- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        B.group,           -- :: ByteString -> [ByteString]-- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        groupBy,           -- :: ByteString -> [ByteString]-- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        B.inits,           -- :: ByteString -> [ByteString]
        B.tails,           -- :: ByteString -> [ByteString]
        -- ** Breaking into many substrings
        split-- ** Breaking into many substrings,             -- :: Char -> ByteString -> [ByteString]
        splitsplitWith,   ,         -- :: Char -> ByteString -> [ByteString]-- :: (Char -> Bool) -> ByteString -> [ByteString]
        splitWith,         -- :: (Char -> Bool) -> ByteString -> [ByteString]
        -- ** Breaking into lines and words
        lines-- ** Breaking into lines and words,             -- :: ByteString -> [ByteString]
        lines,             -- :: ByteString -> [ByteString]
        wordsunlines, ,           -- :: ByteString -> [ByteString]
        unlines,           -- :: [ByteString] -> ByteString
        unwords,           -- :: ByteString -> [ByteString]
        -- * Predicates
        B.isPrefixOf-- * Predicates,      -- :: ByteString -> ByteString -> Bool
        B.isPrefixOf,      -- :: ByteString -> ByteString -> Bool
        B.isSuffixOfB.isInfixOf,,      -- :: ByteString -> ByteString -> Bool
        B.isInfixOf,       -- :: ByteString -> ByteString -> Bool
        -- ** Search for arbitrary substrings
        B.breakSubstring-- ** Search for arbitrary substrings,  -- :: ByteString -> ByteString -> (ByteString,ByteString)
        B.breakSubstringB.findSubstring,,  -- :: ByteString -> ByteString -> Maybe Int-- :: ByteString -> ByteString -> (ByteString,ByteString)
        B.findSubstringB.findSubstrings,,  -- :: ByteString -> ByteString -> [Int]-- :: ByteString -> ByteString -> Maybe Int
        B.findSubstrings,  -- :: ByteString -> ByteString -> [Int]
        -- * Searching ByteStrings
        -- * Searching ByteStrings
        -- ** Searching by equality
        elem-- ** Searching by equality,              -- :: Char -> ByteString -> Bool
        elemnotElem,  ,           -- :: Char -> ByteString -> Bool
        notElem,           -- :: Char -> ByteString -> Bool
        -- ** Searching with a predicate
        find-- ** Searching with a predicate,              -- :: (Char -> Bool) -> ByteString -> Maybe Char
        findfilter, ,            -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,            -- :: (Char -> Bool) -> ByteString -> ByteString
        -- * Indexing ByteStrings
        index-- * Indexing ByteStrings,             -- :: ByteString -> Int -> Char
        indexelemIndex,   ,         -- :: ByteString -> Int -> Char-- :: Char -> ByteString -> Maybe Int
        elemIndexelemIndices, ,       -- :: Char -> ByteString -> [Int]-- :: Char -> ByteString -> Maybe Int
        elemIndiceselemIndexEnd,,      -- :: Char -> ByteString -> [Int]-- :: Char -> ByteString -> Maybe Int
        elemIndexEndfindIndex,  ,      -- :: Char -> ByteString -> Maybe Int-- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndexfindIndices, ,       -- :: (Char -> Bool) -> ByteString -> [Int]-- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndicescount,     ,       -- :: Char -> ByteString -> Int-- :: (Char -> Bool) -> ByteString -> [Int]
        count,             -- :: Char -> ByteString -> Int
        -- * Zipping and unzipping ByteStrings
        zip-- * Zipping and unzipping ByteStrings,               -- :: ByteString -> ByteString -> [(Char,Char)]
        zipzipWith,   ,           -- :: ByteString -> ByteString -> [(Char,Char)]-- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        zipWithunzip, ,           -- :: [(Char,Char)] -> (ByteString,ByteString)-- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        unzip,             -- :: [(Char,Char)] -> (ByteString,ByteString)
        -- * Ordered ByteStrings
        B.sort-- * Ordered ByteStrings,            -- :: ByteString -> ByteString
        B.sort,            -- :: ByteString -> ByteString
        -- * Reading from ByteStrings
        readInt-- * Reading from ByteStrings,           -- :: ByteString -> Maybe (Int, ByteString)
        readIntreadInteger,   ,       -- :: ByteString -> Maybe (Int, ByteString)-- :: ByteString -> Maybe (Integer, ByteString)
        readInteger,       -- :: ByteString -> Maybe (Integer, ByteString)
        -- * Low level CString conversions
        -- * Low level CString conversions
        -- ** Copying ByteStrings
        B.copy-- ** Copying ByteStrings,            -- :: ByteString -> ByteString
        B.copy,            -- :: ByteString -> ByteString
        -- ** Packing CStrings and pointers
        B.packCString-- ** Packing CStrings and pointers,     -- :: CString -> IO ByteString
        B.packCStringB.packCStringLen,  ,  -- :: CString -> IO ByteString-- :: CStringLen -> IO ByteString
        B.packCStringLen,  -- :: CStringLen -> IO ByteString
        -- ** Using ByteStrings as CStrings
        B.useAsCString-- ** Using ByteStrings as CStrings,    -- :: ByteString -> (CString    -> IO a) -> IO a
        B.useAsCStringB.useAsCStringLen,  , -- :: ByteString -> (CString    -> IO a) -> IO a
        B.useAsCStringLen, -- :: ByteString -> (CStringLen -> IO a) -> IO a
        -- * I\/O with ByteStrings
        -- * I\/O with ByteStrings
        -- ** Standard input and output
        B.getLine-- ** Standard input and output,         -- :: IO ByteString
        B.getLineB.getContents,   ,     -- :: IO ByteString
        B.getContentsB.putStr,    ,     -- :: IO ByteString-- :: ByteString -> IO ()
        B.putStr,          -- :: ByteString -> IO ()
        putStrLnB.interact, ,        -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
        B.interact,        -- :: (ByteString -> ByteString) -> IO ()
        -- ** Files
        readFile-- ** Files,          -- :: FilePath -> IO ByteString
        readFilewriteFile,,         -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
        writeFileappendFile,,        -- :: FilePath -> ByteString -> IO ()
        appendFile,        -- :: FilePath -> ByteString -> IO ()
        -- ** I\/O with Handles
        B.hGetLine-- ** I\/O with Handles,        -- :: Handle -> IO ByteString
        B.hGetLineB.hGetContents,   ,    -- :: Handle -> IO ByteString
        B.hGetContentsB.hGet,       ,    -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
        B.hGetB.hGetNonBlocking,          , -- :: Handle -> Int -> IO ByteString
        B.hGetNonBlockingB.hPut,          , -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
        B.hPutB.hPutNonBlocking,          , -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        B.hPutNonBlockingB.hPutStr,       , -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        B.hPutStr,         -- :: Handle -> ByteString -> IO ()
        hPutStrLn,         -- :: Handle -> ByteString -> IO ()
  ) where
  ) where
--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- from base:
import-- from base:Control.Monad      ( (>>=), (>>), return )
import Control.MonadData.Bool          ( (Bool>>=),False>>),True), ()&&), (||), not, otherwise )
import Data.Bool          ( Bool(FalseisSpace, True) ), (&&), (||), not, otherwise )
import Data.CharData.Eq            ( Char(==),)isSpace )
import Data.EqData.Function      ( (==.)) )$) )
import Data.FunctionData.Functor       ( (fmap.), ($) )
import Data.FunctorData.Int           ( fmapInt ))
import Data.IntData.Maybe         ( IntMaybe)(Nothing, Just) )
import Data.MaybeData.Ord           ( Maybe(<), (Nothing<=), (>=,)Just)  ) )
import Data.OrdData.String        ( (IsString<), (<=),fromString>=) )    )
import Data.StringData.Tuple         ( IsStringfst, snd,)fromString )
import Data.TupleForeign.ForeignPtr ( fstwithForeignPtr, snd )     )
import Foreign.ForeignPtrForeign.Storable   ( withForeignPtrpeekElemOff, peekByteOff)         )
import Foreign.StorablePrelude            ( peekElemOffString, Integer, peekByteOff, fromIntegral)   , toInteger, negate
import Prelude            ( String(*), (,)Integer, (-), ,^fromIntegral), ($!), seq, toInteger, negate
                          , (*), (+), (-), (^), ($!), seq,
import System.IO          ) IO, FilePath, Handle
import System.IO          ( IOIOMode, FilePath(ReadMode, Handle, WriteMode, AppendMode)
                          , IOModewithFile(ReadMode, stdout,,WriteModehFileSize, AppendMode)
                          , withFile, stdout, hFileSize
                          )
import GHC.Base           ( Char(..), unpackCString#, ord#, int2Word# )
import GHC.BaseGHC.IO             ( CharstToIO(..), unpackCString#, ord#, int2Word# )
import GHC.IOGHC.Prim           ( stToIOAddr#, )plusAddr#, writeWord8OffAddr# )
import GHC.PrimGHC.Ptr            ( Addr#Ptr(..,)plusAddr#)       , writeWord8OffAddr# )
import GHC.PtrGHC.ST             ( PtrST((....))))
import GHC.ST             ( ST(..) )
import qualified Data.List as L ( length, map, intersperse, filter )
import qualified Data.List as L ( length, map, intersperse, filter )
-- from vector:
import-- from vector:qualified Data.Vector.Storable as VS
import qualified Data.Vector.Storable as VS
-- from primitive:
import-- from primitive:Control.Monad.Primitive ( unsafeInlineIO )
import Control.Monad.Primitive ( unsafeInlineIO )
-- from vector-bytestring (this package):
import-- from vector-bytestring (this package):Data.Vector.Storable.ByteString.Internal ( c2w, w2c, isSpaceWord8 )
import Data.Vector.Storable.ByteString.Internal ( c2w, w2c, isSpaceWord8 )
import qualified Data.Vector.Storable.ByteString as B
import qualifiedData.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString(asunsafeCreateB          )
import Data.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString.Unsafe   ( unsafeCreateunsafePackAddress)    )
import Data.Vector.Storable.ByteString.Unsafe   ( unsafePackAddress )
import Data.Vector.Storable.ByteString ( ByteString )
import Data.Vector.Storable.ByteString ( ByteString )

------------------------------------------------------------------------
-- * Introducing and eliminating ByteStrings------------------------------------------------------------------------
-- * Introducing and eliminating ByteStrings------------------------------------------------------------------------
------------------------------------------------------------------------
-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton-- | /O(1)/ Convert a 'Char' into a 'ByteString':: Char -> ByteString
singleton ::= VS.singleton -> ByteString. c2w
singleton{-# INLINE=singleton#-} . c2w
{-# INLINE singleton #-}
instance IsString ByteString where
instancefromString= pack where
    fromString =fromString     #-}
    {-# INLINE fromString #-}
-- | /O(n)/ Convert a 'String' into a 'ByteString'
---- | /O(n)/ Convert a 'String' into a 'ByteString'
---- For applications with large numbers of string literals, pack can be a
-- bottleneck.-- For applications with large numbers of string literals, pack can be a
pack-- bottleneck.:: String -> ByteString
pack ::strString= unsafeCreate-> ByteString(L.length str) $ \(Ptr p) -> stToIO (go p str)
packwhere = unsafeCreate (L.length str) $ \(Ptr p) -> stToIO (go p str)
    wherego :: Addr# -> [Char] -> ST a ()
      go ::_ [Addr#]     -> [Char= return] -> ST()a ()
      go _ []C# c : cs) = returnwriteByte) >> go (p `plusAddr#` 1#) cs
      go pwhereC# c : cs) = writeByte >> go (p `plusAddr#` 1#) cs
          wherewriteByte = ST $ \s# ->
            writeBytecase writeWord8OffAddr#= ST $ \s# ->   p 0# (int2Word# (ord# c)) s# of
                             cases2#writeWord8OffAddr#-> (# s2#, () #)  p 0# (int2Word# (ord# c)) s# of
                           {-# INLINE -> (#writeByte, ()#-}#)
{-# INLINE [{-# INLINE1] pack #-}writeByte #-}
{-# INLINE [1] pack #-}
{-# RULES
{-# RULES"ByteString pack/packAddress" forall s .
"ByteString pack/packAddress"pack (unpackCString# s) = unsafeInlineIOforall s .    (unsafePackAddress s)
 #-} (unpackCString# s) = unsafeInlineIO (unsafePackAddress s)
 #-}
{-
TODO: Unfortunately the following definition of pack is slower:

pack = VS.fromList . L.map c2w

Probably because of the intermediate list that is constructed and immediately
consumed. However, this definition is amenable to stream-fusion because of the
VS.fromList.

So lets try to fuse the construction of the list with the construction of the
Stream. To do that we need to add the following to:
Data.Vector.Fusion.Stream.Monadic

    #if __GLASGOW_HASKELL__
    import GHC.Base ( build )
    #endif

    #if __GLASGOW_HASKELL__
     {-# RULES
    "unsafeFromList/build"
      forall sz (g :: forall b. (a -> b -> b) -> b -> b).
      unsafeFromList sz (build g) = unsafeFromListF sz g
      #-}
    unsafeFromListF :: forall m a. Monad m
                    => Size
                    -> (forall b. (a -> b -> b) -> b -> b)
                    -> Stream m a
    {-# INLINE unsafeFromListF #-}
    unsafeFromListF sz g = Stream step st sz
        where
          St step st = g c z

          c :: a -> St m a -> St m a
          c x st = St (\(St s st') -> s st')
                      (St (\s -> return (Yield x s)) st)

          z :: St m a
          z = St (\_ -> return Done) undefined

    data St m a = St ((St m a) -> m (Step (St m a) a)) (St m a)
    #endif

Unfortunately, initial experiments failed to make it faster.
-}
unpack :: ByteString -> [Char]
unpack = L.map w2c . B.unpack
{-# INLINE-- | /O(n)/ Converts a 'ByteString' to a 'String'.unpack #-}
unpack :: ByteString -> [Char]
unpack = L.map w2c . B.unpack
{-# INLINE------------------------------------------------------------------------ #-}
-- * Basic interface
------------------------------------------------------------------------
------------------------------------------------------------------------
-- * Basic interface-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.------------------------------------------------------------------------
cons :: Char -> ByteString -> ByteString
cons-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different= VS.cons . c2w
{-# INLINE-- complexity, as it requires a memcpy.cons #-}
cons :: Char -> ByteString -> ByteString
cons-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to= VS.cons . c2w
{-# INLINE-- 'cons', this function performs a memcpy. #-}
snoc :: ByteString -> Char -> ByteString
snoc-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar top = VS.snoc p . c2w
{-# INLINE-- 'cons', this function performs a memcpy.snoc #-}
snoc :: ByteString -> Char -> ByteString
snoc-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty. = VS.snoc p . c2w
{-# INLINEhead :: ByteString #-}-> Char
head = w2c . VS.head
{-# INLINE-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.head #-}
head :: ByteString -> Char
head-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing= w2c . VS.head
{-# INLINE-- if it is empty. #-}
uncons :: ByteString -> Maybe (Char, ByteString)
uncons-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing= fmap (\(w,v) -> (w2c w, v)) . B.uncons
{-# INLINE-- if it is empty.uncons #-}
uncons :: ByteString -> Maybe (Char, ByteString)
uncons-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.= fmap (\(w,v) -> (w2c w, v)) . B.uncons
{-# INLINElast :: ByteString #-}-> Char
last = w2c . VS.last
{-# INLINE-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.last #-}
last :: ByteString -> Char
last = w2c . VS.last
{-# INLINE------------------------------------------------------------------------ #-}
-- * Transformating ByteStrings
------------------------------------------------------------------------
------------------------------------------------------------------------
-- * Transformating ByteStrings-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map------------------------------------------------------------------------:: (Char -> Char) -> ByteString -> ByteString
map f = VS.map (c2w . f . w2c)
{-# INLINE-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@map #-}
map :: (Char -> Char) -> ByteString -> ByteString
map-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString' = VS.map (c2w . f . w2c)
{-# INLINE-- and \`intersperses\' that Char between the elements of the #-}
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString':: Char -> ByteString -> ByteString
intersperse-- and \`intersperses\' that Char between the elements of the= B.intersperse . c2w
{-# INLINE-- 'ByteString'.  It is analogous to the intersperse function on Lists.intersperse #-}
intersperse :: Char -> ByteString -> ByteString
intersperse = B.intersperse . c2w
{-# INLINE------------------------------------------------------------------------ #-}
-- * Reducing ByteStrings (folds)
------------------------------------------------------------------------
------------------------------------------------------------------------
-- * Reducing ByteStrings (folds)-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the------------------------------------------------------------------------
-- ByteString using the binary operator, from left to right.
foldl-- | 'foldl', applied to a binary operator, a starting value (typically:: (a -> Char -> a) -> a -> ByteString -> a
foldl-- the left-identity of the operator), and a ByteString, reduces thef = VS.foldl (\a c -> f a (w2c c))
{-# INLINE-- ByteString using the binary operator, from left to right.foldl #-}
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl-- | 'foldl\'' is like foldl, but strict in the accumulator. = VS.foldl (\a c -> f a (w2c c))
{-# INLINEfoldl' :: (foldla -> Char#-} -> a) -> a -> ByteString -> a
foldl' f = VS.foldl' (\a c -> f a (w2c c))
{-# INLINE-- | 'foldl\'' is like foldl, but strict in the accumulator.foldl' #-}
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl'-- | 'foldr', applied to a binary operator, a starting value = VS.foldl' (\a c -> f a (w2c c))
{-# INLINE-- (typically the right-identity of the operator), and a packed string, #-}
-- reduces the packed string using the binary operator, from right to left.
foldr-- | 'foldr', applied to a binary operator, a starting value:: (Char -> a -> a) -> a -> ByteString -> a
foldr-- (typically the right-identity of the operator), and a packed string,f = VS.foldr (\c a -> f (w2c c) a)
{-# INLINE-- reduces the packed string using the binary operator, from right to left.foldr #-}
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr-- | 'foldr\'' is a strict variant of foldr = VS.foldr (\c a -> f (w2c c) a)
{-# INLINEfoldr' :: (foldrChar ->#-}a -> a) -> a -> ByteString -> a
foldr' f = VS.foldr' (\c a -> f (w2c c) a)
{-# INLINE-- | 'foldr\'' is a strict variant of foldrfoldr' #-}
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr'-- | 'foldl1' is a variant of 'foldl' that has no starting value = VS.foldr' (\c a -> f (w2c c) a)
{-# INLINE-- argument, and thus must be applied to non-empty 'ByteStrings'. #-}
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1-- | 'foldl1' is a variant of 'foldl' that has no starting valuef v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- argument, and thus must be applied to non-empty 'ByteStrings'.foldl1 #-}
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1-- | A strict version of 'foldl1' v = w2c (VS.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINEfoldl1' :: foldl1(Char ->#-}Char -> Char) -> ByteString -> Char
foldl1' f v = w2c (VS.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- | A strict version of 'foldl1'foldl1' #-}
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1'-- | 'foldr1' is a variant of 'foldr' that has no starting value argument, v = w2c (VS.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- and thus must be applied to non-empty 'ByteString's #-}
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,f v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- and thus must be applied to non-empty 'ByteString'sfoldr1 #-}
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1-- | A strict variant of foldr1 v = w2c (VS.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINEfoldr1' :: foldr1(Char ->#-}Char -> Char) -> ByteString -> Char
foldr1' f v = w2c (VS.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- | A strict variant of foldr1foldr1' #-}
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr1'------------------------------------------------------------------------ v = w2c (VS.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) v)
{-# INLINE-- ** Special folds #-}

-- | Map a function over a 'ByteString' and concatenate the results------------------------------------------------------------------------
concatMap-- ** Special folds:: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = VS.concatMap (f . w2c)
{-# INLINE-- | Map a function over a 'ByteString' and concatenate the resultsconcatMap #-}
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap-- | Applied to a predicate and a ByteString, 'any' determines if = VS.concatMap (f . w2c)
{-# INLINE-- any element of the 'ByteString' satisfies the predicate. #-}
any :: (Char -> Bool) -> ByteString -> Bool
any-- | Applied to a predicate and a ByteString, 'any' determines iff = VS.any (f . w2c)
{-# INLINE-- any element of the 'ByteString' satisfies the predicate.any #-}
any :: (Char -> Bool) -> ByteString -> Bool
any-- | Applied to a predicate and a 'ByteString', 'all' determines if = VS.any (f . w2c)
{-# INLINE-- all elements of the 'ByteString' satisfy the predicate. #-}
all :: (Char -> Bool) -> ByteString -> Bool
all-- | Applied to a predicate and a 'ByteString', 'all' determines iff = VS.all (f . w2c)
{-# INLINE-- all elements of the 'ByteString' satisfy the predicate.all #-}
all :: (Char -> Bool) -> ByteString -> Bool
all-- | 'maximum' returns the maximum value from a 'ByteString' = VS.all (f . w2c)
{-# INLINEmaximum :: allByteString#-}    -> Char
maximum = w2c . VS.maximum
{-# INLINE-- | 'maximum' returns the maximum value from a 'ByteString'maximum #-}
maximum :: ByteString -> Char
maximum-- | 'minimum' returns the minimum value from a 'ByteString'= w2c . VS.maximum
{-# INLINEminimum :: maximumByteString#-}-> Char
minimum = w2c . VS.minimum
{-# INLINE-- | 'minimum' returns the minimum value from a 'ByteString'minimum #-}
minimum :: ByteString -> Char
minimum = w2c . VS.minimum
{-# INLINE------------------------------------------------------------------------ #-}
-- * Building ByteStrings
------------------------------------------------------------------------
------------------------------------------------------------------------
-- * Building ByteStrings------------------------------------------------------------------------
-- ** Scans------------------------------------------------------------------------

-- | 'scanl' is similar to 'foldl', but returns a list of successive------------------------------------------------------------------------
-- ** Scans-- reduced values from the left:
--
-- | 'scanl' is similar to 'foldl', but returns a list of successive-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---- reduced values from the left:
---- Note that
---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---- > last (scanl f z xs) == foldl f z xs.
scanl-- Note that:: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--scanl f z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINE-- > last (scanl f z xs) == foldl f z xs.scanl #-}
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl-- | 'scanl1' is a variant of 'scanl' that has no starting value argument: z = VS.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINE--         scanl #-}
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1-- | 'scanl1' is a variant of 'scanl' that has no starting value argument::: (Char -> Char -> Char) -> ByteString -> ByteString
--scanl1 f = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINE-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]scanl1 #-}
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanl1-- | scanr is the right-to-left dual of scanl. = VS.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINEscanr :: (Char-> #-}Char -> Char) -> Char -> ByteString -> ByteString
scanr f z = VS.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINE-- | scanr is the right-to-left dual of scanl.scanr #-}
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr-- | 'scanr1' is a variant of 'scanr' that has no starting value argument. z = VS.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)
{-# INLINEscanr1 :: (scanrChar ->#-}Char -> Char) -> ByteString -> ByteString
scanr1 f = VS.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINE-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.scanr1 #-}
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr1------------------------------------------------------------------------ = VS.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))
{-# INLINE-- ** Accumulating maps #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and------------------------------------------------------------------------
-- ** Accumulating maps-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.-- | The 'mapAccumL' function behaves like a combination of 'map' and
mapAccumL-- 'foldl'; it applies a function to each element of a ByteString,:: (acc -> Char -> (acc, Char))
-- passing an accumulating parameter from left to right, and returning a-> acc -> ByteString -> (acc, ByteString)
mapAccumL-- final value of this accumulator together with the new list.f = B.mapAccumL $ \acc w ->
mapAccumL :: (acccase-> Charf acc->(w2caccw, Charof  ))
          -> acc ->(acc', c) -> ->(acc'acc, ,c2wc)      )
mapAccumL{-# INLINEfmapAccumL= B.mapAccumL#-}  $ \acc w ->
                        case f acc (w2c w) of
        -- | The 'mapAccumR' function behaves like a combination of 'map' andacc', c) -> (acc', c2w c)
{-# INLINE-- 'foldr'; it applies a function to each element of a ByteString, #-}
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.-- | The 'mapAccumR' function behaves like a combination of 'map' and
mapAccumR-- 'foldr'; it applies a function to each element of a ByteString,:: (acc -> Char -> (acc, Char))
-- passing an accumulating parameter from right to left, and returning a-> acc -> ByteString -> (acc, ByteString)
mapAccumR-- final value of this accumulator together with the new ByteString.f = B.mapAccumR $ \acc w ->
mapAccumR :: (acccase-> Charf acc->(w2caccw, Charof  ))
          -> acc ->(acc', c) -> ->(acc'acc, ,c2wc)      )
mapAccumR{-# INLINEfmapAccumR= B.mapAccumR#-}  $ \acc w ->
                        case f acc (w2c w) of
        ------------------------------------------------------------------------acc', c) -> (acc', c2w c)
{-# INLINE-- ** Generating and unfolding ByteStrings #-}

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@------------------------------------------------------------------------
-- ** Generating and unfolding ByteStrings-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
---- the value of every element. The following holds:
---- This implemenation uses @memset(3)@
replicate-- > replicate w c = unfoldr w (\u -> Just (u,u)) c:: Int -> Char -> ByteString
--replicate w = B.replicate w . c2w
{-# INLINE-- This implemenation uses @memset(3)@replicate #-}
replicate :: Int -> Char -> ByteString
replicate-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' = B.replicate w . c2w
{-# INLINE-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a #-}
-- ByteString from a seed value.  The function takes the element and
-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'-- returns 'Nothing' if it is done producing the ByteString or returns
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
-- and @b@ is the seed value for further production.-- ByteString from a seed value.  The function takes the element and
---- returns 'Nothing' if it is done producing the ByteString or returns
-- Examples:-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
---- and @b@ is the seed value for further production.
---- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
unfoldr-- Examples::: (a -> Maybe (Char, a)) -> a -> ByteString
--unfoldr f x0 = VS.unfoldr (fmap k . f) x0
-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"where k (i, j) = (c2w i, j)
unfoldr{-# INLINE:: (unfoldra -> Maybe#-} (Char, a)) -> a -> ByteString
unfoldr f x0 = VS.unfoldr (fmap k . f) x0
-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seedwhere k (i, j) = (c2w i, j)
{-# INLINE-- value.  However, the length of the result is limited by the first #-}
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
---- value.  However, the length of the result is limited by the first
-- The following equation relates 'unfoldrN' and 'unfoldr':-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
---- when the maximum length of the result is known.
---- > unfoldrN n f s == take n (unfoldr f s)
unfoldrN-- The following equation relates 'unfoldrN' and 'unfoldr'::: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
--unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
-- > unfoldrN n f s == take n (unfoldr f s)where k (i,j) = (c2w i, j)
unfoldrN{-# INLINE::unfoldrN -> (a#-}-> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
    where k (i,j) = (c2w i, j)
{-# INLINE------------------------------------------------------------------------ #-}
-- * Substrings
------------------------------------------------------------------------
------------------------------------------------------------------------
-- * Substrings------------------------------------------------------------------------
-- ** Breaking strings------------------------------------------------------------------------

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,------------------------------------------------------------------------
-- ** Breaking strings-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,:: (Char -> Bool) -> ByteString -> ByteString
takeWhile-- returns the longest prefix (possibly empty) of @xs@ of elements thatf = VS.takeWhile (f . w2c)
{-# INLINE-- satisfy @p@.takeWhile #-}
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@. = VS.takeWhile (f . w2c)
{-# INLINEdropWhile ::(Char ->#-}Bool) -> ByteString -> ByteString
dropWhile f = VS.dropWhile (f . w2c)
{-# INLINE-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.[1] dropWhile #-}
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = VS.dropWhile (f . w2c)
{-# INLINE"ByteString specialise dropWhile isSpace -> dropSpace"[1] dropWhile #-}
    dropWhile isSpace = dropSpace
{-# RULES#-}
"ByteString specialise dropWhile isSpace -> dropSpace"
-- | 'dropSpace' efficiently returns the 'ByteString' argument with isSpace = dropSpace
-- white space Chars removed from the front. It is more efficient than#-}
-- calling dropWhile for removing whitespace. I.e.
--
-- > dropWhile isSpace == dropSpace-- | 'dropSpace' efficiently returns the 'ByteString' argument with
---- white space Chars removed from the front. It is more efficient than
dropSpace-- calling dropWhile for removing whitespace. I.e.:: ByteString -> ByteString
--dropSpace v = unsafeInlineIO $ withForeignPtr fp $ \p ->
-- > dropWhile isSpace == dropSpacelet go !i
--          | i >= l    = return VS.empty
dropSpace ::|ByteStringotherwise ->= do
dropSpace v = unsafeInlineIOw <- peekElemOff withForeignPtrp i          fp $ \p ->
      let go !i   if isSpaceWord8 w
              | i >=then   go= return(i+1)  VS.empty
              | otherwiseelse return= do  $ VS.unsafeFromForeignPtr fp i (l-i)
      in go 0     w <- peekElemOff p i
          where   if isSpaceWord8 w
            (fp, l) then= VS.unsafeToForeignPtr0 (i+1)            v
  {-# INLINE dropSpaceelse#-} $ VS.unsafeFromForeignPtr fp i (l-i)
      in go 0
-- | 'span' @p xs@ breaks the ByteString into two segments. It iswhere
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINEspan :: (Char-> Bool#-}) -> ByteString -> (ByteString, ByteString)
span f = VS.span (f . w2c)
{-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It isspan #-}
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span-- We have = VS.span (f . w2c)
{-# INLINE--         span #-}
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
---- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- and-- We have
--
-- > spanEnd (not . isSpace) v-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
---- >    ==
-- and-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
--
spanEnd-- > spanEnd (not . isSpace) v:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd-- >    ==f = B.spanEnd (f . w2c)
{-# INLINE-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)spanEnd #-}
--
spanEnd-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEndbreak ::f(=Char-> Bool(f-> w2cByteString)       -> (ByteString, ByteString)
{-# INLINEbreak f = VS.break #-}(f . w2c)
{-# INLINE [1] break #-}
-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break{-# RULES:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break"ByteString specialise break (x==)" = VS.break (f . w2c)        forall x.
{-# INLINEbreak ([1==])breakx) = #-}breakChar x
"ByteString specialise break (==x)" forall x.
{-# RULESbreak (==x) = breakChar x
"ByteString specialise break (x==)"#-}                               forall x.
    break ((==) x) = breakChar x
"ByteString specialise break (==x)"-- | 'breakChar' breaks its ByteString argument at the first occurenceforall x.
-- of the specified char. It is more efficient than 'break' as it is (==x) = breakChar x
-- implemented with @memchr(3)@. I.e.#-}
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
---- | 'breakChar' breaks its ByteString argument at the first occurence
breakChar-- of the specified char. It is more efficient than 'break' as it is:: Char -> ByteString -> (ByteString, ByteString)
breakChar-- implemented with @memchr(3)@. I.e.c v = case elemIndex c v of
--  Nothing -> (v, VS.empty)
-- > break (=='c') "abcd" == breakChar 'c' "abcd"Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
--{-# INLINE breakChar #-}
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar c v = case elemIndex c v of
"ByteString specialise break -> breakSpace" -> (v, VS.empty)
    JustbreaknisSpace (VS.unsafeTake= breakSpacen v, VS.unsafeDrop n v)
{-# INLINE#-}      breakChar #-}

{-# RULES-- | 'breakSpace' returns the pair of ByteStrings when the argument is
"ByteString specialise break -> breakSpace"-- broken at the first whitespace byte. I.e.
--  break isSpace = breakSpace
-- > break isSpace == breakSpace#-}
--
breakSpace :: ByteString -> (ByteString,ByteString)
breakSpace-- | 'breakSpace' returns the pair of ByteStrings when the argument isv = unsafeInlineIO $ withForeignPtr fp $ \p ->
-- broken at the first whitespace byte. I.e.let go !i
--          | i >= l    = return (vec l, VS.empty)
-- > break isSpace == breakSpace| otherwise = do
--              w <- peekByteOff p i
breakSpace :: ByteStringif (not .->isSpaceWord8ByteString),ByteStringw         )
breakSpace v = unsafeInlineIOthen go (i+1$ withForeignPtr fp $ \p ->
    let go !i     else return $!
            | i >= l   if= returni == 0 (vec l, VS.empty)
            | otherwisethen= do(VS.empty, vec l)
                w <- peekByteOffelse (vec p,iVS.unsafeFromForeignPtr fp i (l-i))
    in go 0     if (not . isSpaceWord8) w
        where     then go (i+1)
          (fp, l) else= VS.unsafeToForeignPtr0 $!           v
          vec = VS.unsafeFromForeignPtr0 i == 0         fp
{-# INLINE breakSpace #-}then (VS.empty, vec l)
                       else (vec i, VS.unsafeFromForeignPtr fp i (l-i))
-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'in go 0
--      where
-- breakEnd p == spanEnd (not.p)fp, l) = VS.unsafeToForeignPtr0 v
breakEnd ::(Char= VS.unsafeFromForeignPtr0-> Bool) -> ByteString fp (ByteString, ByteString)
{-# INLINEbreakEnd f breakSpace= B.breakEnd#-}(f . w2c)
{-# INLINE breakEnd #-}
-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
---- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy-- breakEnd p == spanEnd (not.p):: (Char -> Char -> Bool) -> ByteString -> [ByteString]
breakEndgroupBy k::= (B.groupByChar -> Bool(\a)b->->ByteStringk (w2c a) ->(w2cByteStringb))      , ByteString)
breakEnd{-# INLINE =groupBy#-}  (f . w2c)
{-# INLINE breakEnd #-}
-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy--      :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"] = B.groupBy (\a b -> k (w2c a) (w2c b))
{-# INLINE-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""] #-}
-- > split 'x'  "x"          == ["",""]
---- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- and-- argument, consuming the delimiter. I.e.
--
-- > intercalate [c] . split c == id-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split == splitWith . (==)-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
---- > split 'x'  "x"          == ["",""]
---- As for all splitting functions in this library, this function does
-- and-- not copy the substrings, it just constructs new 'ByteStrings' that
---- are slices of the original.
---- > intercalate [c] . split c == id
split-- > split == splitWith . (==):: Char -> ByteString -> [ByteString]
--split = B.split . c2w
{-# INLINE-- As for all splitting functions in this library, this function doessplit #-}
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.-- | /O(n)/ Splits a 'ByteString' into components delimited by
---- separators, where the predicate returns True for a separator element.
split-- The resulting components do not contain the separators.  Two adjacent:: Char -> ByteString -> [ByteString]
split-- separators result in an empty component in the output.  eg.= B.split . c2w
{-# INLINE--         split #-}
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
---- | /O(n)/ Splits a 'ByteString' into components delimited by
splitWith-- separators, where the predicate returns True for a separator element.:: (Char -> Bool) -> ByteString -> [ByteString]
splitWith-- The resulting components do not contain the separators.  Two adjacentf = B.splitWith (f . w2c)
{-# INLINE-- separators result in an empty component in the output.  eg.splitWith #-} -- the inline makes a big difference here.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]------------------------------------------------------------------------
---- ** Breaking into lines and words
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith-- | 'lines' breaks a ByteString up into a list of ByteStrings at = B.splitWith (f . w2c)
{-# INLINE-- newline Chars. The resulting strings do not contain newlines. #-} -- the inline makes a big difference here.
lines :: ByteString -> [ByteString]
lines------------------------------------------------------------------------v
-- ** Breaking into lines and words| VS.null v = []
    | otherwise = case elemIndex '\n' v of
-- | 'lines' breaks a ByteString up into a list of ByteStrings atNothing -> [v]
-- newline Chars. The resulting strings do not contain newlines.Just n  -> VS.unsafeTake n v : lines (VS.unsafeDrop (n+1) v)
lines{-# INLINE:: ByteStringlines #-}-> [ByteString]
lines v
-- | 'words' breaks a ByteString up into a list of words, which VS.null v = []
-- were delimited by Chars representing white space. otherwise = case elemIndex '\n' v of
words ::NothingByteString [v->] [ByteString]
words = JustL.filter  ->(not. VS.null) n vB.splitWith lines (VS.unsafeDropisSpaceWord8 (n+1) v)
{-# INLINE lines #-}

-- | 'words' breaks a ByteString up into a list of words, which-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.-- were delimited by Chars representing white space.
wordsunlines::::[ByteString->][ByteString-> ByteString]
wordsunlines= L.filter[] = VS.emptynot . VS.null) . B.splitWith isSpaceWord8
{-# INLINEunlines vs words= VS.concat#-}   (L.intersperse (VS.singleton nl) vs) `VS.snoc` nl
    where
-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,nl = c2w '\n'
{-# INLINE-- after appending a terminating newline to each.unlines #-}
unlines :: [ByteString] -> ByteString
unlines-- | The 'unwords' function is analogous to the 'unlines' function, on words.] = VS.empty
unlines vs =ByteString](L.intersperse-> ByteString (VS.singleton nl) vs) `VS.snoc` nl
unwordswhere= B.intercalate (singleton ' ')
{-# INLINE = c2wunwords#-}
{-# INLINE unlines #-}

-------------------------------------------------------------------------- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords-- * Searching ByteStrings:: [ByteString] -> ByteString
unwords------------------------------------------------------------------------= B.intercalate (singleton ' ')
{-# INLINE unwords #-}
------------------------------------------------------------------------
-- ** Searching by equality
------------------------------------------------------------------------
-- * Searching ByteStrings-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.------------------------------------------------------------------------
elem :: Char -> ByteString -> Bool
elem------------------------------------------------------------------------c = VS.elem (c2w c)
{-# INLINE-- ** Searching by equalityelem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
notElem-- implementation uses @memchr(3)@.:: Char -> ByteString -> Bool
elemnotElem:: Charc = VS.notElem-> ByteString(c2w->c)Bool
elem{-# INLINE = VS.elemnotElemc2w#-}c)
{-# INLINE elem #-}
------------------------------------------------------------------------
-- ** Searching with a predicate-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem-- | /O(n)/ The 'find' function takes a predicate and a ByteString, = VS.notElem (c2w c)
{-# INLINE-- and returns the first element in matching the predicate, or 'Nothing' #-}
-- if there is no such element.
find------------------------------------------------------------------------:: (Char -> Bool) -> ByteString -> Maybe Char
find-- ** Searching with a predicatef v = w2c `fmap` VS.find (f . w2c) v
{-# INLINE find #-}
-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- | /O(n)/ 'filter', applied to a predicate and a ByteString,-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.-- returns a ByteString containing those characters that satisfy the
find-- predicate.:: (Char -> Bool) -> ByteString -> Maybe Char
findfilter v::=(w2cChar`fmap-> Bool` VS.find) -> ByteStringf . w2c)-> ByteString
{-# INLINEfilter f = findVS.filter#-}  (f . w2c)
{-# INLINE filter #-}
-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.------------------------------------------------------------------------
filter-- * Indexing ByteStrings:: (Char -> Bool) -> ByteString -> ByteString
filter------------------------------------------------------------------------ = VS.filter (f . w2c)
{-# INLINE filter #-}
-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Char
index------------------------------------------------------------------------= (w2c .) . (VS.!)
{-# INLINE-- * Indexing ByteStringsindex #-}
------------------------------------------------------------------------
-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.-- element in the given 'ByteString' which is equal (by memchr) to the
index-- query element, or 'Nothing' if there is no such element.:: ByteString -> Int -> Char
indexelemIndex= (w2c:: .Char) . (->VS.!ByteString)        -> Maybe Int
{-# INLINEelemIndex =indexVS.elemIndex#-}     . c2w
{-# INLINE elemIndex #-}
-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- query element, or 'Nothing' if there is no such element.-- the indices of all elements equal to the query element, in ascending order.
elemIndexelemIndices::::Char->->ByteString->->[IntInt]
elemIndexelemIndices= VS.elemIndex= B.elemIndices c2w. c2w
{-# INLINE elemIndexelemIndices#-}#-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- element in the given 'ByteString' which is equal to the query-- the indices of all elements equal to the query element, in ascending order.
elemIndices-- element, or 'Nothing' if there is no such element. The following:: Char -> ByteString -> [Int]
elemIndices-- holds:   = B.elemIndices . c2w
{-# INLINE--         elemIndices #-}
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
---- element in the given 'ByteString' which is equal to the query
elemIndexEnd-- element, or 'Nothing' if there is no such element. The following:: Char -> ByteString -> Maybe Int
-- holds:elemIndexEnd = B.elemIndexEnd . c2w
--{-# INLINE elemIndexEnd #-}
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- | The 'findIndex' function takes a predicate and a 'ByteString' and
---- returns the index of the first element in the ByteString satisfying the predicate.
elemIndexEndfindIndex :: ::(Char->->Bool) -> ByteString-> Maybe->IntMaybe Int
elemIndexEndfindIndex f ==VS.findIndex(f . c2w)
{-# INLINE elemIndexEndfindIndex #-}#-}

-- | The 'findIndices' function extends 'findIndex', by returning the-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- indices of all elements satisfying the predicate, in ascending order.-- returns the index of the first element in the ByteString satisfying the predicate.
findIndexfindIndices::::Char(Char->->Bool) ->) ->ByteString->->[IntInt]
findIndexfindIndices = VS.findIndex= B.findIndicesf .fw2c. )w2c)
{-# INLINE findIndexfindIndices#-}#-}

-- | The 'findIndices' function extends 'findIndex', by returning the-- | count returns the number of times its argument appears in the ByteString
---- indices of all elements satisfying the predicate, in ascending order.
findIndices-- > count = length . elemIndices:: (Char -> Bool) -> ByteString -> [Int]
findIndices--          f = B.findIndices (f . w2c)
{-# INLINE-- Also    findIndices #-}
--
-- > count '\n' == length . lines-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices-- But more efficiently than using length on the intermediate list.
--count :: Char -> ByteString -> Int
count-- Alsoc = B.count (c2w c)
--{-# INLINE count #-}
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.------------------------------------------------------------------------
count-- * Zipping and unzipping ByteStrings:: Char -> ByteString -> Int
count------------------------------------------------------------------------ = B.count (c2w c)
{-# INLINE count #-}
-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is------------------------------------------------------------------------
-- * Zipping and unzipping ByteStrings-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings------------------------------------------------------------------------
zip :: ByteString -> ByteString -> [(Char, Char)]
zip-- | /O(n)/ 'zip' takes two ByteStrings and returns a list ofv1 v2
-- corresponding pairs of Chars. If one input ByteString is short,| VS.null v1 || VS.null v2 = []
-- excess elements of the longer ByteString are discarded. This is| otherwise = (unsafeHead v1, unsafeHead v2)
-- equivalent to a pair of 'unpack' operations, and so space: zip (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINE-- usage may be large for multi-megabyte ByteStringszip #-}
zip :: ByteString -> ByteString -> [(Char, Char)]
zip-- | 'zipWith' generalises 'zip' by zipping with the function given as v2
-- the first argument, instead of a tupling function.  For example, VS.null v1 || VS.null v2 = []
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list otherwise = (unsafeHead v1, unsafeHead v2)
-- of corresponding sums. zip (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINEzipWith :: zip(Char#-}-> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = B.zipWith ((. w2c) . f . w2c)
{-# INLINE-- | 'zipWith' generalises 'zip' by zipping with the function given aszipWith #-}
-- the first argument, instead of a tupling function.  For example,
-- | 'unzip' transforms a list of pairs of Chars into a pair of-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.-- ByteStrings. Note that this performs two 'pack' operations.
zipWithunzip ::::[((CharChar, ->Char)] ->->(aByteString) -> ByteString, ByteString-> ByteString)        -> [a]
zipWithunzip lsf==(B.zipWithpack (L.map(.fstls)). fpack w2c(L.map)    snd ls))
{-# INLINE zipWithunzip #-}#-}

-- | 'unzip' transforms a list of pairs of Chars into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.------------------------------------------------------------------------
unzip-- * Reading from ByteStrings:: [(Char, Char)] -> (ByteString, ByteString)
unzip------------------------------------------------------------------------ = (pack (L.map fst ls), pack (L.map snd ls))
{-# INLINE unzip #-}
-- | readInt reads an Int from the beginning of the ByteString.  If there is no
-- integer at the beginning of the string, it returns Nothing, otherwise
-- it just returns the int read, and the rest of the string.------------------------------------------------------------------------
readInt-- * Reading from ByteStrings:: ByteString -> Maybe (Int, ByteString)
readInt------------------------------------------------------------------------v
    | VS.null v = Nothing
-- | readInt reads an Int from the beginning of the ByteString.  If there is no| otherwise =
-- integer at the beginning of the string, it returns Nothing, otherwisecase unsafeHead v of
-- it just returns the int read, and the rest of the string.'-' -> loop True  0 0 (VS.unsafeTail v)
readInt :: ByteString'+' -> loop->False0(Int0 (,VS.unsafeTail) v)
readInt v   _   -> loop False 0 0 v
    | VS.null v = Nothing
    |whereloop ::= Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
        caseloop!neg !i !v of!ps
            '-'| ->VS.null Trueps = end 0negVS.unsafeTaili n ps      v)
            '+'| ->otherwise False=   0 0 (VS.unsafeTail v)
            _   ->caseVS.unsafeHead 0 0 v  ps of
                    w | w >= 0x30
    where loop :: Bool&&->w Int<= 0x39-> Int-> ->loopneg (i+1)-> Maybe (Int, ByteString)
          loop !neg !i !n !ps             (n * 10 + (fromIntegral w - 0x30))
              | VS.null ps = end neg i n ps(VS.unsafeTail ps)
              | otherwise| otherwise=       -> end neg i n ps
                  case VS.unsafeHead ps of
          end _    0w_|_w >== Nothing
          end True _ &&n ps <== Just(->negatenneg, ps(i+1)
          end _    _ n ps = Just (n, ps)  (n * 10 + (fromIntegral w - 0x30))
                                          (VS.unsafeTail ps)
-- | readInteger reads an Integer from the beginning of the ByteString.  If otherwise -> end neg i n ps
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string. _    0 _ _  = Nothing
readInteger::TrueByteString n ps =->JustMaybenegate(Integer,,psByteString)        )
readIntegerv _    _ n ps = Just (n, ps)
    | VS.null v = Nothing
-- | readInteger reads an Integer from the beginning of the ByteString.  If| otherwise =
-- there is no integer at the beginning of the string, it returns Nothing,case unsafeHead v of
-- otherwise it just returns the int read, and the rest of the string.'-' -> first (VS.unsafeTail v) >>= \(n, bs) -> return (-n, bs)
readInteger ::'+'ByteString-> first (->VS.unsafeTail (Integerv) , ByteString)
readInteger v    -> first v
    | VS.null v = Nothing
    |wherefirst =ps | VS.null ps = Nothing
        case unsafeHead| otherwise of   =
            '-' -> firstcaseVS.unsafeTailVS.unsafeHead)psof\(n, bs) -> return (-n, bs)
            '+' -> firstw(VS.unsafeTail| w >= 0x30 &&v) <= 0x39 -> Just $
            _   -> first v  loop 1 (fromIntegral w - 0x30) [] (VS.unsafeTail ps)
                          | otherwise              -> Nothing
    where first ps | VS.null ps = Nothing
          loop :: Int otherwise-> Int ->=[Integer]
               -> ByteString VS.unsafeHead-> (Integer, psByteStringof     )
          loop !d !acc !wns|!wps>= 0x30 && w <= 0x39 -> Just $
              | VS.null ps =loopcombine (fromIntegrald acc ns VS.empty - 0x30) [] (VS.unsafeTail ps)
              | otherwise | otherwise              -> Nothing
                  case VS.unsafeHead ps of
          loop :: Intw |->w Int>= 0x30-> [Integer&& w <=]0x39 ->
               -> ByteStringif d ==->9(Integerthen loop, ByteString1 (fromIntegral)      w - 0x30)
          loop !d !acc !ns !ps             (toInteger acc : ns)
              | VS.null ps = combine d acc ns(VS.unsafeTail    ps)
              | otherwise =      else loop (d+1)
                  case VS.unsafeHead ps of (10*acc + (fromIntegral w - 0x30))
                   w | w >= 0x30 && w <= 0x39ns ->(VS.unsafeTail ps)
                     | ifotherwise == 9 then-> combine 1d(fromIntegralacc ns ps    w - 0x30)
                                           (toInteger acc : ns)
          combine _ acc [] ps = (toInteger (accVS.unsafeTail, ps)       ps)
          combine d acc ns ps =  else loop (d+1)
              ((10^d * combine1 1000000000 (ns10*acctoInteger (fromIntegralacc), ps)w - 0x30))
                                           ns (VS.unsafeTail ps)
          combine1 _ |notherwise] = n     -> combine d acc ns ps
          combine1 b ns  = combine1 (b*b) $ combine2 b ns
          combine _ acc [] ps = (toInteger acc, ps)
          combinecombine2dbacc(n:nsm:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
          combine2(10^d *nscombine1= 1000000000ns         ns + toInteger acc), ps)

          combine1 _ [n] = n
------------------------------------------------------------------------ b ns  = combine1 (b*b) $ combine2 b ns
-- * * I\/O with ByteStrings
------------------------------------------------------------------------ b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns
------------------------------------------------------------------------
-- ** Standard input and output
------------------------------------------------------------------------
-- * * I\/O with ByteStrings-- | Write a ByteString to stdout, appending a newline byte
putStrLn------------------------------------------------------------------------:: ByteString -> IO ()
putStrLn = hPutStrLn stdout
------------------------------------------------------------------------
-- ** Standard input and output------------------------------------------------------------------------
-- ** Files
-- | Write a ByteString to stdout, appending a newline byte
putStrLn-- | Read an entire file strictly into a 'ByteString'.  This is far more:: ByteString -> IO ()
putStrLn-- efficient than reading the characters into a 'String' and then using= hPutStrLn stdout
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet.------------------------------------------------------------------------
readFile-- ** Files:: FilePath -> IO ByteString
readFile f = withFile f ReadMode $ \h ->
-- | Read an entire file strictly into a 'ByteString'.  This is far morehFileSize h >>= B.hGet h . fromIntegral
-- efficient than reading the characters into a 'String' and then using
-- | Write a 'ByteString' to a file.-- 'pack'.  It also may be more efficient than opening the file and
writeFile-- reading it using hGet.:: FilePath -> ByteString -> IO ()
readFilewriteFile::f FilePathtxt = withFile-> IO ByteStringf WriteMode $ \h -> B.hPut h txt
readFile f = withFile f ReadMode $ \h ->
-- | Append a 'ByteString' to a file. h >>= B.hGet h . fromIntegral
appendFile :: FilePath -> ByteString -> IO ()
appendFile-- | Write a 'ByteString' to a file.f txt = withFile f AppendMode $ \h -> B.hPut h txt
writeFile :: FilePath -> ByteString -> IO ()
writeFile------------------------------------------------------------------------ txt = withFile f WriteMode $ \h -> B.hPut h txt
-- ** I\/O with Handles
-- | Append a 'ByteString' to a file.
appendFile-- | Write a ByteString to a handle, appending a newline byte:: FilePath -> ByteString -> IO ()
appendFilehPutStrLn :: txtHandle= withFile-> ByteString AppendMode-> IO ($ \h -> B.hPut h txt
hPutStrLn h v
------------------------------------------------------------------------| VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
-- ** I\/O with Handles| otherwise = do B.hPut h v
                     B.hPut h $ VS.singleton nl -- don't copy
-- | Write a ByteString to a handle, appending a newline bytewhere
hPutStrLnnl =::c2w'\n' -> ByteString -> IO ()
hPutStrLn h v
    | VS.length v < 1024 = B.hPut h $ v `VS.snoc` nl
------------------------------------------------------------------------ otherwise = do B.hPut h v
                                                                   -- * Utils           B.hPut h $ VS.singleton nl -- don't copy
------------------------------------------------------------------------where
      nl = c2w '\n'
-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
-- the check for the empty case, which is good for performance, but
-- there is an obligation on the programmer to provide a proof that the------------------------------------------------------------------------
-- * Utils-- ByteString is non-empty.
unsafeHead------------------------------------------------------------------------:: ByteString -> Char
unsafeHead  = w2c . VS.unsafeHead
{-# INLINE-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omitsunsafeHead #-}
-- the check for the empty case, which is good for performance, but
-- there is an obligation on the programmer to provide a proof that the

</pre>