<a href="Progress.hs11909597451912844175.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Project.hs343098142456880399.out.html">next</a></br></br><pre>19d18
< import "base" Control.Monad ( (=<<), (>>), return, when )
20d18
< import "base" Data.Bool     ( otherwise )
21d18
< import "base" Data.Function ( ($), (.) )
22d18
< import "base" Data.List     ( null, length, genericLength, genericReplicate )
23d18
< import "base" Data.Maybe    ( maybe )
24d18
< import "base" Data.Ord      ( min, max, (>=) )
25d18
< import "base" Data.Ratio    ( (%) )
26d18
< import "base" Data.String   ( String )
27d18
< import "base" Prelude       ( (+), (-), round, floor, Bool(..) )
28d18
< import "base" System.IO     ( IO, putStr, putChar )
29d18
< import "base" Text.Printf   ( printf )
30d18
< import "base" Text.Show     ( show )
31d18
< import "base"  Control.Concurrent ( ThreadId, forkIO )
32d18
< import "stm"  Control.Concurrent.STM ( TVar, readTVar, writeTVar, newTVar, atomically, STM )
33d18
< import "stm-chans"  Control.Concurrent.STM.TMQueue ( TMQueue, readTMQueue, closeTMQueue, writeTMQueue, newTMQueue )
34d18
< import "base-unicode-symbols" Data.Bool.Unicode ( (∧) )
35d18
< import "base-unicode-symbols" Data.Eq.Unicode   ( (≢) )
36c19
< import "base-unicode-symbols" Prelude.Unicode   ( ℤ, ℚ, (⋅) )
---
> import  Control.Monad ( (=<<), (>>), return, when )
36a20
> import  Data.Bool     ( otherwise )
36a21
> import  Data.Function ( ($), (.) )
36a22
> import  Data.List     ( null, length, genericLength, genericReplicate )
36a23
> import  Data.Maybe    ( maybe )
36a24
> import  Data.Ord      ( min, max, (>=) )
36a25
> import  Data.Ratio    ( (%) )
36a26
> import  Data.String   ( String )
36a27
> import  Prelude       ( (+), (-), round, floor, Bool(..) )
36a28
> import  System.IO     ( IO, putStr, putChar )
36a29
> import  Text.Printf   ( printf )
36a30
> import  Text.Show     ( show )
36a31
> import   Control.Concurrent ( ThreadId, forkIO )
36a32
> import   Control.Concurrent.STM ( TVar, readTVar, writeTVar, newTVar, atomically, STM )
36a33
> import   Control.Concurrent.STM.TMQueue ( TMQueue, readTMQueue, closeTMQueue, writeTMQueue, newTMQueue )
36a34
> import  Data.Bool.Unicode ( (∧) )
36a35
> import  Data.Eq.Unicode   ( (≢) )
36a36
> import  Prelude.Unicode   ( ℤ, ℚ, (⋅) )
49d48
< progressBar ∷ Label -- ^ Prefixed label.
50d48
<             → Label -- ^ Postfixed label.
51d48
<             → ℤ     -- ^ Total progress bar width in characters.
52d48
<             → ℤ     -- ^ Amount of work completed.
53d48
<             → ℤ     -- ^ Total amount of work.
54c49
<             → IO ()
---
> progressBar :: Label -- ^ Prefixed label.
54a50
>             -> Label -- ^ Postfixed label.
54a51
>             -> ℤ     -- ^ Total progress bar width in characters.
54a52
>             -> ℤ     -- ^ Amount of work completed.
54a53
>             -> ℤ     -- ^ Total amount of work.
54a54
>             -> IO ()
63d62
< mkProgressBar ∷ Label -- ^ Prefixed label.
64d62
<               → Label -- ^ Postfixed label.
65d62
<               → ℤ     -- ^ Total progress bar width in characters.
66d62
<               → ℤ     -- ^ Amount of work completed.
67d62
<               → ℤ     -- ^ Total amount of work.
68c63
<               → String
---
> mkProgressBar :: Label -- ^ Prefixed label.
68a64
>               -> Label -- ^ Postfixed label.
68a65
>               -> ℤ     -- ^ Total progress bar width in characters.
68a66
>               -> ℤ     -- ^ Amount of work completed.
68a67
>               -> ℤ     -- ^ Total amount of work.
68a68
>               -> String
82c82
<     fraction ∷ ℚ
---
>     fraction :: ℚ
96c96
<     numCompletedChars ∷ ℚ
---
>     numCompletedChars :: ℚ
99c99
<     completed, remaining ∷ ℤ
---
>     completed, remaining :: ℤ
103c103
<     preLabel, postLabel ∷ String
---
>     preLabel, postLabel :: String
107c107
<     prePad, postPad ∷ String
---
>     prePad, postPad :: String
111c111
<     pad ∷ String → String
---
>     pad :: String -> String
117c117
< type Label = ℤ → ℤ → String
---
> type Label = ℤ -> ℤ -> String
123c123
< noLabel ∷ Label
---
> noLabel :: Label
130c130
< msg ∷ String → Label
---
> msg :: String -> Label
142d141
< percentage ∷ Label
143c142
< percentage done todo = printf "%3i%%" (round (done % todo ⋅ 100) ∷ ℤ)
---
> percentage :: Label
143a143
> percentage done todo = printf "%3i%%" (round (done % todo ⋅ 100) :: ℤ)
155c155
< exact ∷ Label
---
> exact :: Label
162d161
< data ProgressRef = ProgressRef { prPrefix    ∷ Label
163d161
<                                , prPostfix   ∷ Label
164d161
<                                , prWidth     ∷ ℤ
165d161
<                                , prCompleted ∷ TVar ℤ
166d161
<                                , prTotal     ∷ ℤ
167c162
<                                , prQueue     ∷ TMQueue ℤ }
---
> data ProgressRef = ProgressRef { prPrefix    :: Label
167a163
>                                , prPostfix   :: Label
167a164
>                                , prWidth     :: ℤ
167a165
>                                , prCompleted :: TVar ℤ
167a166
>                                , prTotal     :: ℤ
167a167
>                                , prQueue     :: TMQueue ℤ }
171d170
< startProgress ∷ Label -- ^ Prefixed label.
172d170
<               → Label -- ^ Postfixed label.
173d170
<               → ℤ     -- ^ Total progress bar width in characters.
174d170
<               → ℤ     -- ^ Total amount of work.
175c171
<               → IO (ProgressRef, ThreadId)
---
> startProgress :: Label -- ^ Prefixed label.
175a172
>               -> Label -- ^ Postfixed label.
175a173
>               -> ℤ     -- ^ Total progress bar width in characters.
175a174
>               -> ℤ     -- ^ Total amount of work.
175a175
>               -> IO (ProgressRef, ThreadId)
189d188
< incProgress ∷ ProgressRef
190d188
<             → ℤ
191c189
<             → IO ()
---
> incProgress :: ProgressRef
191a190
>             -> ℤ
191a191
>             -> IO ()
194d193
< reportProgress ∷ ProgressRef
195c194
<                → IO ()
---
> reportProgress :: ProgressRef
195a195
>                -> IO ()
201d200
< updateProgress ∷ ProgressRef
202c201
<                → STM Bool
---
> updateProgress :: ProgressRef
202a202
>                -> STM Bool
215d214
< renderProgress ∷ ProgressRef
216c215
<                → IO ()
---
> renderProgress :: ProgressRef
216a216
>                -> IO ()
219a220
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude, PackageImports, NamedFieldPuns, RecordWildCards, UnicodeSyntax #-}

module System.ProgressBar
    ( -- * Progress bars
      progressBar
    , mkProgressBar
      -- * Labels
    , Label
    , noLabel
    , msg
    , percentage
    , exact
    -- * auto-printing
    , ProgressRef
    , startProgress
    , incProgress
    ) where

import "base" Control.Monad ( (=<<), (>>), return, when )
import "base" Data.Bool     ( otherwise )
import "base" Data.Function ( ($), (.) )
import "base" Data.List     ( null, length, genericLength, genericReplicate )
import "base" Data.Maybe    ( maybe )
import "base" Data.Ord      ( min, max, (>=) )
import "base" Data.Ratio    ( (%) )
import "base" Data.String   ( String )
import "base" Prelude       ( (+), (-), round, floor, Bool(..) )
import "base" System.IO     ( IO, putStr, putChar )
import "base" Text.Printf   ( printf )
import "base" Text.Show     ( show )
import "base"  Control.Concurrent ( ThreadId, forkIO )
import "stm"  Control.Concurrent.STM ( TVar, readTVar, writeTVar, newTVar, atomically, STM )
import "stm-chans"  Control.Concurrent.STM.TMQueue ( TMQueue, readTMQueue, closeTMQueue, writeTMQueue, newTMQueue )
import "base-unicode-symbols" Data.Bool.Unicode ( (∧) )
import "base-unicode-symbols" Data.Eq.Unicode   ( (≢) )
import "base-unicode-symbols" Prelude.Unicode   ( ℤ, ℚ, (⋅) )


-- | Print a progress bar
--
-- Erases the current line! (by outputting '\r') Does not print a
-- newline '\n'. Subsequent invocations will overwrite the previous
-- output.
--
-- Remember to set the correct buffering mode for stdout:
--
-- > import System.IO ( hSetBuffering, BufferMode(NoBuffering), stdout )
-- > hSetBuffering stdout NoBuffering
progressBar ∷ Label -- ^ Prefixed label.
            → Label -- ^ Postfixed label.
            → ℤ     -- ^ Total progress bar width in characters.
            → ℤ     -- ^ Amount of work completed.
            → ℤ     -- ^ Total amount of work.
            → IO ()
progressBar mkPreLabel mkPostLabel width todo done = do
    putChar '\r'
    putStr $ mkProgressBar mkPreLabel mkPostLabel width todo done

-- | Renders a progress bar
--
-- >>> mkProgressBar (msg "Working") percentage 40 30 100
-- "Working [=======>.................]  30%"
mkProgressBar ∷ Label -- ^ Prefixed label.
              → Label -- ^ Postfixed label.
              → ℤ     -- ^ Total progress bar width in characters.
              → ℤ     -- ^ Amount of work completed.
              → ℤ     -- ^ Total amount of work.
              → String
mkProgressBar mkPreLabel mkPostLabel width todo done =
    printf "%s%s[%s%s%s]%s%s"
           preLabel
           prePad
           (genericReplicate completed '=')
           (if remaining ≢ 0 ∧ completed ≢ 0 then ">" else "")
           (genericReplicate (remaining - if completed ≢ 0 then 1 else 0)
                             '.'
           )
           postPad
           postLabel
  where
    -- Amount of work completed.
    fraction ∷ ℚ
    fraction | done ≢ 0  = todo % done
             | otherwise = 0 % 1

    -- Amount of characters available to visualize the progress.
    effectiveWidth = max 0 $ width - usedSpace
    usedSpace = 2 + genericLength preLabel
                  + genericLength postLabel
                  + genericLength prePad
                  + genericLength postPad

    -- Number of characters needed to represent the amount of work
    -- that is completed. Note that this can not always be represented
    -- by an integer.
    numCompletedChars ∷ ℚ
    numCompletedChars = fraction ⋅ (effectiveWidth % 1)

    completed, remaining ∷ ℤ
    completed = min effectiveWidth $ floor numCompletedChars
    remaining = effectiveWidth - completed

    preLabel, postLabel ∷ String
    preLabel  = mkPreLabel  todo done
    postLabel = mkPostLabel todo done

    prePad, postPad ∷ String
    prePad  = pad preLabel
    postPad = pad postLabel

    pad ∷ String → String
    pad s | null s    = ""
          | otherwise = " "


-- | A label that can be pre- or postfixed to a progress bar.
type Label = ℤ → ℤ → String

-- | The empty label.
--
-- >>> noLabel 30 100
-- ""
noLabel ∷ Label
noLabel = msg ""

-- | A label consisting of a static string.
--
-- >>> msg "foo" 30 100
-- "foo"
msg ∷ String → Label
msg s _ _ = s

-- | A label which displays the progress as a percentage.
--
-- Constant width property:
-- &#x2200; d t : &#x2115;. d &#x2264; t &#x2192; length (percentage d t) &#x2261; 4
--
-- >>> percentage 30 100
-- " 30%"

-- ∀ d t : ℕ. d ≤ t → length (percentage d t) ≡ 3
percentage ∷ Label
percentage done todo = printf "%3i%%" (round (done % todo ⋅ 100) ∷ ℤ)

-- | A label which displays the progress as a fraction of the total
-- amount of work.
--
-- Equal width property:
-- &#x2200; d&#x2081; d&#x2082; t : &#x2115;. d&#x2081; &#x2264; d&#x2082; &#x2264; t &#x2192; length (exact d&#x2081; t) &#x2261; length (exact d&#x2082; t)
--
-- >>> exact 30 100
-- " 30/100"

-- ∀ d₁ d₂ t : ℕ. d₁ ≤ d₂ ≤ t → length (exact d₁ t) ≡ length (exact d₂ t)
exact ∷ Label
exact done total = printf "%*i/%s" (length totalStr) done totalStr
  where
    totalStr = show total

-- * Auto-Printing Progress

data ProgressRef = ProgressRef { prPrefix    ∷ Label
                               , prPostfix   ∷ Label
                               , prWidth     ∷ ℤ
                               , prCompleted ∷ TVar ℤ
                               , prTotal     ∷ ℤ
                               , prQueue     ∷ TMQueue ℤ }

-- | Start a thread to automatically display progress. Use incProgress to step
-- the progress bar.
startProgress ∷ Label -- ^ Prefixed label.
              → Label -- ^ Postfixed label.
              → ℤ     -- ^ Total progress bar width in characters.
              → ℤ     -- ^ Total amount of work.
              → IO (ProgressRef, ThreadId)
startProgress mkPreLabel mkPostLabel width total = do
    pr  <- buildProgressRef
    tid <- forkIO $ reportProgress pr
    return (pr, tid)
    where
      buildProgressRef = do
        completed <- atomically $ newTVar 0
        queue     <- atomically $ newTMQueue
        return $ ProgressRef mkPreLabel mkPostLabel width completed total queue

-- | Increment the progress bar. Negative values will reverse the progress.
-- Progress will never be negative and will silently stop taking data when it
-- completes.
incProgress ∷ ProgressRef
            → ℤ
            → IO ()
incProgress ProgressRef {prQueue} = atomically . writeTMQueue prQueue

reportProgress ∷ ProgressRef
               → IO ()
reportProgress pr = do
  continue <- atomically $ updateProgress pr
  renderProgress pr
  when continue $ reportProgress pr

updateProgress ∷ ProgressRef
               → STM Bool
updateProgress ProgressRef {prCompleted, prQueue, prTotal} = do
  maybe dontContinue doUpdate =<< readTMQueue prQueue
  where
    dontContinue = return False
    doUpdate countDiff = do
      count <- readTVar prCompleted
      let newCount = min prTotal $ max 0 $ count + countDiff
      writeTVar prCompleted newCount
      if newCount >= prTotal
        then closeTMQueue prQueue >> dontContinue
        else return True

renderProgress ∷ ProgressRef
               → IO ()
renderProgress ProgressRef {..} = do
  completed <- atomically $ readTVar prCompleted
  progressBar prPrefix prPostfix prWidth completed prTotal
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude, PackageImports, NamedFieldPuns, RecordWildCards, UnicodeSyntax #-}

module System.ProgressBar
    ( -- * Progress bars
      progressBar
    , mkProgressBar
      -- * Labels
    , Label
    , noLabel
    , msg
    , percentage
    , exact
    -- * auto-printing
    , ProgressRef
    , startProgress
    , incProgress
    ) where

import  Control.Monad ( (=<<), (>>), return, when )
import  Data.Bool     ( otherwise )
import  Data.Function ( ($), (.) )
import  Data.List     ( null, length, genericLength, genericReplicate )
import  Data.Maybe    ( maybe )
import  Data.Ord      ( min, max, (>=) )
import  Data.Ratio    ( (%) )
import  Data.String   ( String )
import  Prelude       ( (+), (-), round, floor, Bool(..) )
import  System.IO     ( IO, putStr, putChar )
import  Text.Printf   ( printf )
import  Text.Show     ( show )
import   Control.Concurrent ( ThreadId, forkIO )
import   Control.Concurrent.STM ( TVar, readTVar, writeTVar, newTVar, atomically, STM )
import   Control.Concurrent.STM.TMQueue ( TMQueue, readTMQueue, closeTMQueue, writeTMQueue, newTMQueue )
import  Data.Bool.Unicode ( (∧) )
import  Data.Eq.Unicode   ( (≢) )
import  Prelude.Unicode   ( ℤ, ℚ, (⋅) )


-- | Print a progress bar
--
-- Erases the current line! (by outputting '\r') Does not print a
-- newline '\n'. Subsequent invocations will overwrite the previous
-- output.
--
-- Remember to set the correct buffering mode for stdout:
--
-- > import System.IO ( hSetBuffering, BufferMode(NoBuffering), stdout )
-- > hSetBuffering stdout NoBuffering
progressBar :: Label -- ^ Prefixed label.
            -> Label -- ^ Postfixed label.
            -> ℤ     -- ^ Total progress bar width in characters.
            -> ℤ     -- ^ Amount of work completed.
            -> ℤ     -- ^ Total amount of work.
            -> IO ()
progressBar mkPreLabel mkPostLabel width todo done = do
    putChar '\r'
    putStr $ mkProgressBar mkPreLabel mkPostLabel width todo done

-- | Renders a progress bar
--
-- >>> mkProgressBar (msg "Working") percentage 40 30 100
-- "Working [=======>.................]  30%"
mkProgressBar :: Label -- ^ Prefixed label.
              -> Label -- ^ Postfixed label.
              -> ℤ     -- ^ Total progress bar width in characters.
              -> ℤ     -- ^ Amount of work completed.
              -> ℤ     -- ^ Total amount of work.
              -> String
mkProgressBar mkPreLabel mkPostLabel width todo done =
    printf "%s%s[%s%s%s]%s%s"
           preLabel
           prePad
           (genericReplicate completed '=')
           (if remaining ≢ 0 ∧ completed ≢ 0 then ">" else "")
           (genericReplicate (remaining - if completed ≢ 0 then 1 else 0)
                             '.'
           )
           postPad
           postLabel
  where
    -- Amount of work completed.
    fraction :: ℚ
    fraction | done ≢ 0  = todo % done
             | otherwise = 0 % 1

    -- Amount of characters available to visualize the progress.
    effectiveWidth = max 0 $ width - usedSpace
    usedSpace = 2 + genericLength preLabel
                  + genericLength postLabel
                  + genericLength prePad
                  + genericLength postPad

    -- Number of characters needed to represent the amount of work
    -- that is completed. Note that this can not always be represented
    -- by an integer.
    numCompletedChars :: ℚ
    numCompletedChars = fraction ⋅ (effectiveWidth % 1)

    completed, remaining :: ℤ
    completed = min effectiveWidth $ floor numCompletedChars
    remaining = effectiveWidth - completed

    preLabel, postLabel :: String
    preLabel  = mkPreLabel  todo done
    postLabel = mkPostLabel todo done

    prePad, postPad :: String
    prePad  = pad preLabel
    postPad = pad postLabel

    pad :: String -> String
    pad s | null s    = ""
          | otherwise = " "


-- | A label that can be pre- or postfixed to a progress bar.
type Label = ℤ -> ℤ -> String

-- | The empty label.
--
-- >>> noLabel 30 100
-- ""
noLabel :: Label
noLabel = msg ""

-- | A label consisting of a static string.
--
-- >>> msg "foo" 30 100
-- "foo"
msg :: String -> Label
msg s _ _ = s

-- | A label which displays the progress as a percentage.
--
-- Constant width property:
-- &#x2200; d t : &#x2115;. d &#x2264; t &#x2192; length (percentage d t) &#x2261; 4
--
-- >>> percentage 30 100
-- " 30%"

-- ∀ d t : ℕ. d ≤ t → length (percentage d t) ≡ 3
percentage :: Label
percentage done todo = printf "%3i%%" (round (done % todo ⋅ 100) :: ℤ)

-- | A label which displays the progress as a fraction of the total
-- amount of work.
--
-- Equal width property:
-- &#x2200; d&#x2081; d&#x2082; t : &#x2115;. d&#x2081; &#x2264; d&#x2082; &#x2264; t &#x2192; length (exact d&#x2081; t) &#x2261; length (exact d&#x2082; t)
--
-- >>> exact 30 100
-- " 30/100"

-- ∀ d₁ d₂ t : ℕ. d₁ ≤ d₂ ≤ t → length (exact d₁ t) ≡ length (exact d₂ t)
exact :: Label
exact done total = printf "%*i/%s" (length totalStr) done totalStr
  where
    totalStr = show total

-- * Auto-Printing Progress

data ProgressRef = ProgressRef { prPrefix    :: Label
                               , prPostfix   :: Label
                               , prWidth     :: ℤ
                               , prCompleted :: TVar ℤ
                               , prTotal     :: ℤ
                               , prQueue     :: TMQueue ℤ }

-- | Start a thread to automatically display progress. Use incProgress to step
-- the progress bar.
startProgress :: Label -- ^ Prefixed label.
              -> Label -- ^ Postfixed label.
              -> ℤ     -- ^ Total progress bar width in characters.
              -> ℤ     -- ^ Total amount of work.
              -> IO (ProgressRef, ThreadId)
startProgress mkPreLabel mkPostLabel width total = do
    pr  <- buildProgressRef
    tid <- forkIO $ reportProgress pr
    return (pr, tid)
    where
      buildProgressRef = do
        completed <- atomically $ newTVar 0
        queue     <- atomically $ newTMQueue
        return $ ProgressRef mkPreLabel mkPostLabel width completed total queue

-- | Increment the progress bar. Negative values will reverse the progress.
-- Progress will never be negative and will silently stop taking data when it
-- completes.
incProgress :: ProgressRef
            -> ℤ
            -> IO ()
incProgress ProgressRef {prQueue} = atomically . writeTMQueue prQueue

reportProgress :: ProgressRef
               -> IO ()
reportProgress pr = do
  continue <- atomically $ updateProgress pr
  renderProgress pr
  when continue $ reportProgress pr

updateProgress :: ProgressRef
               -> STM Bool
updateProgress ProgressRef {prCompleted, prQueue, prTotal} = do
  maybe dontContinue doUpdate =<< readTMQueue prQueue
  where
    dontContinue = return False
    doUpdate countDiff = do
      count <- readTVar prCompleted
      let newCount = min prTotal $ max 0 $ count + countDiff
      writeTVar prCompleted newCount
      if newCount >= prTotal
        then closeTMQueue prQueue >> dontContinue
        else return True

renderProgress :: ProgressRef
               -> IO ()
renderProgress ProgressRef {..} = do
  completed <- atomically $ readTVar prCompleted
  progressBar prPrefix prPostfix prWidth completed prTotal

</pre>