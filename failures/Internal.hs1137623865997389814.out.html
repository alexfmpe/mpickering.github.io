<a href="Internal.hs1108728549685118024.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Internal.hs12648177091998097157.out.html">next</a></br></br><pre>12c12
< data Graph n = Graph {nodeMap ∷ IntMap n, edgeMap ∷ IntMap IntSet, nextKey ∷ Int}
---
> data Graph n = Graph {nodeMap :: IntMap n, edgeMap :: IntMap IntSet, nextKey :: Int}
14c14
< newtype Rewrite n a = Rewrite {rewrite ∷ State (Graph n) a}
---
> newtype Rewrite n a = Rewrite {rewrite :: State (Graph n) a}
17d16
< newtype Node = Node {nKey ∷ Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
18c17
< newtype Port = Edge {eKey ∷ Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
---
> newtype Node = Node {nKey :: Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
18a18
> newtype Port = Edge {eKey :: Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
28c28
< readRef ∷ Monad m ⇒ Int → IntMap a → m a
---
> readRef :: Monad m => Int -> IntMap a -> m a
31c31
< readEdge ∷ MonadReader (Graph n) r ⇒ Edge → r IntSet
---
> readEdge :: MonadReader (Graph n) r => Edge -> r IntSet
34d33
< modifyNodeMap ∷ (IntMap n → IntMap n) → Rewrite n ()
35c34
< modifyNodeMap f = modify $ \g → g {nodeMap = f $ nodeMap g}
---
> modifyNodeMap :: (IntMap n -> IntMap n) -> Rewrite n ()
35a35
> modifyNodeMap f = modify $ \g -> g {nodeMap = f $ nodeMap g}
37d36
< modifyEdgeMap ∷ (IntMap IntSet → IntMap IntSet) → Rewrite n ()
38c37
< modifyEdgeMap f = modify $ \g → g {edgeMap = f $ edgeMap g}
---
> modifyEdgeMap :: (IntMap IntSet -> IntMap IntSet) -> Rewrite n ()
38a38
> modifyEdgeMap f = modify $ \g -> g {edgeMap = f $ edgeMap g}
41c41
< newRef ∷ Rewrite n Int
---
> newRef :: Rewrite n Int
43d42
<     i ← gets nextKey
44c43
<     modify $ \g → g {nextKey = i + 1}
---
>     i <- gets nextKey
44a44
>     modify $ \g -> g {nextKey = i + 1}
48c48
< freeRefs ∷ MonadReader (Graph n) r ⇒ r [Int]
---
> freeRefs :: MonadReader (Graph n) r => r [Int]
51d50
< reserveRefs ∷ [Int] → Rewrite n ()
52c51
< reserveRefs refs = modify $ \g → g {nextKey = maximum refs}
---
> reserveRefs :: [Int] -> Rewrite n ()
52a52
> reserveRefs refs = modify $ \g -> g {nextKey = maximum refs}
52a53
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, TypeSynonymInstances, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, GeneralizedNewtypeDeriving #-}
module GraphRewriting.Graph.Internal where

import Prelude.Unicode
import Control.Monad.State
import Data.IntMap as Map (IntMap, lookup)
import Data.IntSet (IntSet)
import Control.Monad.Reader


-- | Hypergraph that holds nodes of type @n@. Nodes can be referenced by type 'Node', edges by type 'Edge', see "GraphRewriting.Graph.Read" and "GraphRewriting.Graph.Write"
data Graph n = Graph {nodeMap ∷ IntMap n, edgeMap ∷ IntMap IntSet, nextKey ∷ Int}

newtype Rewrite n a = Rewrite {rewrite ∷ State (Graph n) a}
    deriving (MonadState (Graph n), Monad, Functor, MonadFix)

newtype Node = Node {nKey ∷ Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
newtype Port = Edge {eKey ∷ Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
type Edge = Port -- ^ a hyperedge really, connecting a non-empty subset of the graph's nodes (see 'attachedNodes')

instance Show Node where show = show . nKey
instance Show Edge where show = show . eKey

instance MonadReader (Graph n) (Rewrite n) where
    ask = Rewrite get
    local f m = Rewrite $ liftM (evalState (rewrite m) . f) get

readRef ∷ Monad m ⇒ Int → IntMap a → m a
readRef key = maybe (fail "readRef: referentiation failed") return . Map.lookup key

readEdge ∷ MonadReader (Graph n) r ⇒ Edge → r IntSet
readEdge (Edge e) = maybe (fail $ "readEdge: edge with ID " ⧺ show e ⧺ " does not exist") return . readRef e =<< asks edgeMap

modifyNodeMap ∷ (IntMap n → IntMap n) → Rewrite n ()
modifyNodeMap f = modify $ \g → g {nodeMap = f $ nodeMap g}

modifyEdgeMap ∷ (IntMap IntSet → IntMap IntSet) → Rewrite n ()
modifyEdgeMap f = modify $ \g → g {edgeMap = f $ edgeMap g}

-- | allocate and reserve a new ref
newRef ∷ Rewrite n Int
newRef = do
    i ← gets nextKey
    modify $ \g → g {nextKey = i + 1}
    return i

-- | Hand out an infinite number of fresh refs, without reserving them (obviously).
freeRefs ∷ MonadReader (Graph n) r ⇒ r [Int]
freeRefs = enumFrom `liftM` asks nextKey

reserveRefs ∷ [Int] → Rewrite n ()
reserveRefs refs = modify $ \g → g {nextKey = maximum refs}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, TypeSynonymInstances, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, GeneralizedNewtypeDeriving #-}
module GraphRewriting.Graph.Internal where

import Prelude.Unicode
import Control.Monad.State
import Data.IntMap as Map (IntMap, lookup)
import Data.IntSet (IntSet)
import Control.Monad.Reader


-- | Hypergraph that holds nodes of type @n@. Nodes can be referenced by type 'Node', edges by type 'Edge', see "GraphRewriting.Graph.Read" and "GraphRewriting.Graph.Write"
data Graph n = Graph {nodeMap :: IntMap n, edgeMap :: IntMap IntSet, nextKey :: Int}

newtype Rewrite n a = Rewrite {rewrite :: State (Graph n) a}
    deriving (MonadState (Graph n), Monad, Functor, MonadFix)

newtype Node = Node {nKey :: Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
newtype Port = Edge {eKey :: Int} deriving (Eq, Ord) -- TODO: change this into Integer to avert overflow
type Edge = Port -- ^ a hyperedge really, connecting a non-empty subset of the graph's nodes (see 'attachedNodes')

instance Show Node where show = show . nKey
instance Show Edge where show = show . eKey

instance MonadReader (Graph n) (Rewrite n) where
    ask = Rewrite get
    local f m = Rewrite $ liftM (evalState (rewrite m) . f) get

readRef :: Monad m => Int -> IntMap a -> m a
readRef key = maybe (fail "readRef: referentiation failed") return . Map.lookup key

readEdge :: MonadReader (Graph n) r => Edge -> r IntSet
readEdge (Edge e) = maybe (fail $ "readEdge: edge with ID " ⧺ show e ⧺ " does not exist") return . readRef e =<< asks edgeMap

modifyNodeMap :: (IntMap n -> IntMap n) -> Rewrite n ()
modifyNodeMap f = modify $ \g -> g {nodeMap = f $ nodeMap g}

modifyEdgeMap :: (IntMap IntSet -> IntMap IntSet) -> Rewrite n ()
modifyEdgeMap f = modify $ \g -> g {edgeMap = f $ edgeMap g}

-- | allocate and reserve a new ref
newRef :: Rewrite n Int
newRef = do
    i <- gets nextKey
    modify $ \g -> g {nextKey = i + 1}
    return i

-- | Hand out an infinite number of fresh refs, without reserving them (obviously).
freeRefs :: MonadReader (Graph n) r => r [Int]
freeRefs = enumFrom `liftM` asks nextKey

reserveRefs :: [Int] -> Rewrite n ()
reserveRefs refs = modify $ \g -> g {nextKey = maximum refs}

</pre>