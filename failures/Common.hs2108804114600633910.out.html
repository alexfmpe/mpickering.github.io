<a href="CommandLine.hs17214211741025979034.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Common.hs21341814571915875605.out.html">next</a></br></br><pre>26c26
< {-# LINE 49 "src/ehc/Scanner/Common.chs" #-}
---
> 
26a27
> 
26a28
> 
26a29
> 
26a30
> 
26a31
> 
26a32
> 
26a33
> 
26a34
> 
26a35
> 
26a36
> 
26a37
> 
26a38
> 
26a39
> 
26a40
> 
26a41
> 
26a42
> 
26a43
> 
26a44
> 
26a45
> 
26a46
> 
26a47
> 
26a48
> 
30c52
< {-# LINE 54 "src/ehc/Scanner/Common.chs" #-}
---
> 
30a53
> 
35c58
< {-# LINE 60 "src/ehc/Scanner/Common.chs" #-}
---
> 
35a59
> 
37c61
< {-# LINE 63 "src/ehc/Scanner/Common.chs" #-}
---
> 
37a62
> 
39c64
< {-# LINE 66 "src/ehc/Scanner/Common.chs" #-}
---
> 
39a65
> 
41c67
< {-# LINE 69 "src/ehc/Scanner/Common.chs" #-}
---
> 
41a68
> 
43c70
< {-# LINE 72 "src/ehc/Scanner/Common.chs" #-}
---
> 
43a71
> 
45c73
< {-# LINE 75 "src/ehc/Scanner/Common.chs" #-}
---
> 
45a74
> 
47c76
< {-# LINE 78 "src/ehc/Scanner/Common.chs" #-}
---
> 
47a77
> 
49c79
< {-# LINE 81 "src/ehc/Scanner/Common.chs" #-}
---
> 
49a80
> 
51c82
< {-# LINE 84 "src/ehc/Scanner/Common.chs" #-}
---
> 
51a83
> 
53c85
< {-# LINE 87 "src/ehc/Scanner/Common.chs" #-}
---
> 
53a86
> 
55c88
< {-# LINE 90 "src/ehc/Scanner/Common.chs" #-}
---
> 
55a89
> 
59c93
< {-# LINE 95 "src/ehc/Scanner/Common.chs" #-}
---
> 
59a94
> 
61c96
< {-# LINE 98 "src/ehc/Scanner/Common.chs" #-}
---
> 
61a97
> 
63c99
< {-# LINE 101 "src/ehc/Scanner/Common.chs" #-}
---
> 
63a100
> 
65c102
< {-# LINE 104 "src/ehc/Scanner/Common.chs" #-}
---
> 
65a103
> 
67c105
< {-# LINE 107 "src/ehc/Scanner/Common.chs" #-}
---
> 
67a106
> 
69c108
< {-# LINE 110 "src/ehc/Scanner/Common.chs" #-}
---
> 
69a109
> 
71c111
< {-# LINE 113 "src/ehc/Scanner/Common.chs" #-}
---
> 
71a112
> 
73c114
< {-# LINE 116 "src/ehc/Scanner/Common.chs" #-}
---
> 
73a115
> 
75c117
< {-# LINE 119 "src/ehc/Scanner/Common.chs" #-}
---
> 
75a118
> 
77c120
< {-# LINE 122 "src/ehc/Scanner/Common.chs" #-}
---
> 
77a121
> 
82c126
< {-# LINE 128 "src/ehc/Scanner/Common.chs" #-}
---
> 
82a127
> 
88c133
< {-# LINE 140 "src/ehc/Scanner/Common.chs" #-}
---
> 
88a134
> 
88a135
> 
88a136
> 
88a137
> 
88a138
> 
88a139
> 
104c155
< {-# LINE 165 "src/ehc/Scanner/Common.chs" #-}
---
> 
104a156
> 
104a157
> 
104a158
> 
104a159
> 
104a160
> 
104a161
> 
104a162
> 
104a163
> 
104a164
> 
108c168
< {-# LINE 170 "src/ehc/Scanner/Common.chs" #-}
---
> 
108a169
> 
124c185
< {-# LINE 205 "src/ehc/Scanner/Common.chs" #-}
---
> 
124a186
> 
124a187
> 
124a188
> 
124a189
> 
124a190
> 
124a191
> 
124a192
> 
124a193
> 
124a194
> 
124a195
> 
124a196
> 
124a197
> 
124a198
> 
124a199
> 
124a200
> 
124a201
> 
124a202
> 
124a203
> 
124a204
> 
129c209
< {-# LINE 211 "src/ehc/Scanner/Common.chs" #-}
---
> 
129a210
> 
145c226
< {-# LINE 246 "src/ehc/Scanner/Common.chs" #-}
---
> 
145a227
> 
145a228
> 
145a229
> 
145a230
> 
145a231
> 
145a232
> 
145a233
> 
145a234
> 
145a235
> 
145a236
> 
145a237
> 
145a238
> 
145a239
> 
145a240
> 
145a241
> 
145a242
> 
145a243
> 
145a244
> 
145a245
> 
158c258
< {-# LINE 264 "src/ehc/Scanner/Common.chs" #-}
---
> 
158a259
> 
158a260
> 
158a261
> 
158a262
> 
158a263
> 
187c292
< {-# LINE 300 "src/ehc/Scanner/Common.chs" #-}
---
> 
187a293
> 
187a294
> 
187a295
> 
187a296
> 
187a297
> 
187a298
> 
187a299
> 
205c317
< {-# LINE 321 "src/ehc/Scanner/Common.chs" #-}
---
> 
205a318
> 
205a319
> 
205a320
> 
225c340
< {-# LINE 352 "src/ehc/Scanner/Common.chs" #-}
---
> 
225a341
> 
225a342
> 
225a343
> 
225a344
> 
225a345
> 
225a346
> 
225a347
> 
225a348
> 
225a349
> 
225a350
> 
225a351
> 
250c376
< {-# LINE 384 "src/ehc/Scanner/Common.chs" #-}
---
> 
250a377
> 
250a378
> 
250a379
> 
250a380
> 
250a381
> 
250a382
> 
250a383
> 
257c390
< {-# LINE 392 "src/ehc/Scanner/Common.chs" #-}
---
> 
257a391
> 
292c426
< {-# LINE 441 "src/ehc/Scanner/Common.chs" #-}
---
> 
292a427
> 
292a428
> 
292a429
> 
292a430
> 
292a431
> 
292a432
> 
292a433
> 
292a434
> 
292a435
> 
292a436
> 
292a437
> 
292a438
> 
292a439
> 
292a440
> 
308c456
< {-# LINE 480 "src/ehc/Scanner/Common.chs" #-}
---
> 
308a457
> 
308a458
> 
308a459
> 
308a460
> 
308a461
> 
308a462
> 
308a463
> 
308a464
> 
308a465
> 
308a466
> 
308a467
> 
308a468
> 
308a469
> 
308a470
> 
308a471
> 
308a472
> 
308a473
> 
308a474
> 
308a475
> 
308a476
> 
308a477
> 
308a478
> 
308a479
> 
317c488
< {-# LINE 490 "src/ehc/Scanner/Common.chs" #-}
---
> 
317a489
> 
333c505
< {-# LINE 515 "src/ehc/Scanner/Common.chs" #-}
---
> 
333a506
> 
333a507
> 
333a508
> 
333a509
> 
333a510
> 
333a511
> 
333a512
> 
333a513
> 
333a514
> 
352c533
< {-# LINE 540 "src/ehc/Scanner/Common.chs" #-}
---
> 
352a534
> 
352a535
> 
352a536
> 
352a537
> 
352a538
> 
352a539
> 
361c548
< {-# LINE 550 "src/ehc/Scanner/Common.chs" #-}
---
> 
361a549
> 
366c554
< {-# LINE 556 "src/ehc/Scanner/Common.chs" #-}
---
> 
366a555
> 
369c558
< {-# LINE 564 "src/ehc/Scanner/Common.chs" #-}
---
> 
369a559
> 
369a560
> 
369a561
> 
369a562
> 
369a563
> 
372c566
< {-# LINE 568 "src/ehc/Scanner/Common.chs" #-}
---
> 
372a567
> 
393c588
< {-# LINE 596 "src/ehc/Scanner/Common.chs" #-}
---
> 
393a589
> 
393a590
> 
393a591
> 
393a592
> 
393a593
> 
393a594
> 
393a595
> 
399c601
< {-# LINE 607 "src/ehc/Scanner/Common.chs" #-}
---
> 
399a602
> 
399a603
> 
399a604
> 
399a605
> 
399a606
> 
409c616
< {-# LINE 627 "src/ehc/Scanner/Common.chs" #-}
---
> 
409a617
> 
409a618
> 
409a619
> 
409a620
> 
409a621
> 
409a622
> 
409a623
> 
409a624
> 
409a625
> 
409a626
> 
417c634
< {-# LINE 640 "src/ehc/Scanner/Common.chs" #-}
---
> 
417a635
> 
417a636
> 
417a637
> 
417a638
> 
417a639
> 
428c650
< {-# LINE 662 "src/ehc/Scanner/Common.chs" #-}
---
> 
428a651
> 
428a652
> 
428a653
> 
428a654
> 
428a655
> 
428a656
> 
428a657
> 
428a658
> 
428a659
> 
428a660
> 
428a661
> 
435c668
< {-# LINE 674 "src/ehc/Scanner/Common.chs" #-}
---
> 
435a669
> 
435a670
> 
435a671
> 
435a672
> 
435a673
> 
469c707
< {-# LINE 709 "src/ehc/Scanner/Common.chs" #-}
---
> 
469a708
> 
507c746
< {-# LINE 748 "src/ehc/Scanner/Common.chs" #-}
---
> 
507a747
> 
512c752
< {-# LINE 754 "src/ehc/Scanner/Common.chs" #-}
---
> 
512a753
> 
519c760
< {-# LINE 762 "src/ehc/Scanner/Common.chs" #-}
---
> 
519a761
> 
523c765
< {-# LINE 767 "src/ehc/Scanner/Common.chs" #-}
---
> 
523a766
> 
529c772
< {-# LINE 774 "src/ehc/Scanner/Common.chs" #-}
---
> 
529a773
> 
539c783
< {-# LINE 785 "src/ehc/Scanner/Common.chs" #-}
---
> 
539a784
> 
552c797
< {-# LINE 799 "src/ehc/Scanner/Common.chs" #-}
---
> 
552a798
> 
569c815
< {-# LINE 817 "src/ehc/Scanner/Common.chs" #-}
---
> 
569a816
> 
574c821
< {-# LINE 823 "src/ehc/Scanner/Common.chs" #-}
---
> 
574a822
> 
584c832
< {-# LINE 834 "src/ehc/Scanner/Common.chs" #-}
---
> 
584a833
> 
595c844
< {-# LINE 846 "src/ehc/Scanner/Common.chs" #-}
---
> 
595a845
> 
605c855
< {-# LINE 857 "src/ehc/Scanner/Common.chs" #-}
---
> 
605a856
> 
609c860
< {-# LINE 862 "src/ehc/Scanner/Common.chs" #-}
---
> 
609a861
> 
619c871
< {-# LINE 873 "src/ehc/Scanner/Common.chs" #-}
---
> 
619a872
> 
633c886
< {-# LINE 890 "src/ehc/Scanner/Common.chs" #-}
---
> 
633a887
> 
633a888
> 
633a889
> 
639c895
< {-# LINE 900 "src/ehc/Scanner/Common.chs" #-}
---
> 
639a896
> 
639a897
> 
639a898
> 
639a899
> 
649c909
< {-# LINE 911 "src/ehc/Scanner/Common.chs" #-}
---
> 
649a910
> 
663c924
< {-# LINE 926 "src/ehc/Scanner/Common.chs" #-}
---
> 
663a925
> 
667c929
< {-# LINE 934 "src/ehc/Scanner/Common.chs" #-}
---
> 
667a930
> 
667a931
> 
667a932
> 
667a933
> 
671c937
< {-# LINE 939 "src/ehc/Scanner/Common.chs" #-}
---
> 
671a938
> 
674c941
< {-# LINE 943 "src/ehc/Scanner/Common.chs" #-}
---
> 
674a942
> 
680c948
< {-# LINE 950 "src/ehc/Scanner/Common.chs" #-}
---
> 
680a949
> 
687c956
< {-# LINE 958 "src/ehc/Scanner/Common.chs" #-}
---
> 
687a957
> 
696c966
< {-# LINE 968 "src/ehc/Scanner/Common.chs" #-}
---
> 
696a967
> 
704c975
< {-# LINE 977 "src/ehc/Scanner/Common.chs" #-}
---
> 
704a976
> 
729c1001
< {-# LINE 1003 "src/ehc/Scanner/Common.chs" #-}
---
> 
729a1002
> 
742c1015
< {-# LINE 1017 "src/ehc/Scanner/Common.chs" #-}
---
> 
742a1016
> 
760a1035
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Scanner.Common
( module UHC.Light.Compiler.Scanner.Common
, module UHC.Light.Compiler.Scanner.Scanner )
where
import System.IO
import UU.Parsing
import UU.Parsing.Offside
import UU.Scanner.Position
import UU.Scanner.GenToken
import UU.Scanner.GenTokenParser
import UHC.Util.ScanUtils ()
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import qualified Data.Set as Set
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Scanner.Scanner
import UHC.Util.ParseUtils
import UHC.Light.Compiler.Base.Target
import Data.Ratio





{-# LINE 49 "src/ehc/Scanner/Common.chs" #-}
ehScanOpts :: EHCOpts -> ScanOpts
ehScanOpts opts
  =  defaultScanOpts
{-# LINE 54 "src/ehc/Scanner/Common.chs" #-}
        {   scoKeywordsTxt      =
                Set.fromList $
                       tokKeywStrsEH1
                    ++ offsideTrigs
{-# LINE 60 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH4
{-# LINE 63 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH5
{-# LINE 66 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH6
{-# LINE 69 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH8
{-# LINE 72 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH9
{-# LINE 75 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH11
{-# LINE 78 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH12
{-# LINE 81 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH90
{-# LINE 84 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokKeywStrsEH91
{-# LINE 87 "src/ehc/Scanner/Common.chs" #-}
                    ++ (if ehcOptFusion opts then tokKeywStrsEH93 else [])
{-# LINE 90 "src/ehc/Scanner/Common.chs" #-}
        ,   scoKeywordsOps      =
                Set.fromList $
                       tokOpStrsEH1
{-# LINE 95 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH2
{-# LINE 98 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH3
{-# LINE 101 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH4
{-# LINE 104 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH5
{-# LINE 107 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH6
{-# LINE 110 "src/ehc/Scanner/Common.chs" #-}
                    ++ (if ehcOptExtensibleRecords opts then tokOpStrsEH7 else [])
{-# LINE 113 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH9
{-# LINE 116 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH10
{-# LINE 119 "src/ehc/Scanner/Common.chs" #-}
                    ++ tokOpStrsEH11
{-# LINE 122 "src/ehc/Scanner/Common.chs" #-}
        ,   scoSpecChars        = Set.fromList $
                "();,[]{}`"
        ,   scoOpChars          = Set.fromList $
                "!#$%&*+/<=>?@\\^|-:.~"
{-# LINE 128 "src/ehc/Scanner/Common.chs" #-}
        ,   scoSpecPairs        = Set.fromList $
                [  show hsnORow, show hsnCRow
                ,  show hsnOSum, show hsnCSum
                ,  show hsnOImpl, show hsnCImpl
                ]
{-# LINE 140 "src/ehc/Scanner/Common.chs" #-}
        ,   scoOffsideTrigs     =   offsideTrigs
        ,   scoOffsideTrigsGE   =   offsideTrigsGE
        ,   scoOffsideModule    =   "let"
        ,   scoOffsideOpen      =   "{"
        ,   scoOffsideClose     =   "}"
        }
  where offsideTrigs     =
            [  "let", "where"
            ,  "of"
            ,  "letstrict"
            ]
        offsideTrigsGE   =
            [  "do"
            ]

{-# LINE 165 "src/ehc/Scanner/Common.chs" #-}
hsScanOpts :: EHCOpts -> ScanOpts
hsScanOpts opts
  = ehScanOpts'
{-# LINE 170 "src/ehc/Scanner/Common.chs" #-}
        {   scoKeywordsTxt      =
                scoKeywordsTxt ehScanOpts' `Set.union`
                (Set.fromList $
                       offsideTrigs
                    ++ tokKeywStrsHS1
                    ++ tokKeywStrsHS4
                    ++ tokKeywStrsHS5
                    ++ tokKeywStrsHS6
                    ++ tokKeywStrsHS8
                    ++ tokKeywStrsHS9
                    ++ tokKeywStrsHS11
                    ++ tokKeywStrsHS12
                    ++ tokKeywStrsHS90
                    ++ (if ehcOptFusion opts then tokKeywStrsHS93 else [])
                )
{-# LINE 205 "src/ehc/Scanner/Common.chs" #-}
        ,   scoPragmasTxt      =
                (Set.fromList $
                       tokPragmaStrsHS99
                )
{-# LINE 211 "src/ehc/Scanner/Common.chs" #-}
        ,   scoKeywordsOps      =
                scoKeywordsOps ehScanOpts'
                `Set.union`
                (Set.fromList $
                       tokOpStrsHS1
                    ++ tokOpStrsHS2
                    ++ tokOpStrsHS3
                    ++ tokOpStrsHS4
                    ++ tokOpStrsHS5
                    ++ tokOpStrsHS6
                    ++ tokOpStrsHS7
                    ++ tokOpStrsHS9
                    ++ tokOpStrsHS10
                    ++ tokOpStrsHS11
                )
{-# LINE 246 "src/ehc/Scanner/Common.chs" #-}
        ,   scoOffsideTrigs     =
                scoOffsideTrigs ehScanOpts'
                ++ offsideTrigs
        ,   scoOffsideTrigsGE   =
                scoOffsideTrigsGE ehScanOpts'
        ,   scoOffsideModule    =   "module"
        }
  where offsideTrigs     =
            [  "where"
            ]
        ehScanOpts' = ehScanOpts opts

{-# LINE 264 "src/ehc/Scanner/Common.chs" #-}
-- | 'ScanOpts' for 'Core' tokenization before parsing
coreScanOpts :: EHCOpts -> ScanOpts
coreScanOpts opts
  =  grinScanOpts
        {   scoKeywordsTxt      =   (Set.fromList $
                                        [ "let", "in", "case", "of", "rec", "foreign", "uniq"
                                        , "Int", "Char", "String", "Tag", "Rec"
                                        , "module", "default"
                                        , "import", "export"
                                        , "BINDPLAIN", "BINDFUNCTION0", "BINDFUNCTION1", "BINDAPPLY0"
                                        , "VAL"
                                        , "FAIL"
                                        , "DICT", "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED", "TRACK"
                                        , "Integer"
                                        , "foreignexport"
                                        ])
                                    `Set.union` scoKeywordsTxt tyScanOpts
                                    `Set.union` scoKeywordsTxt hsScanOpts'
        ,   scoKeywExtraChars   =   Set.fromList "."
        ,   scoKeywordsOps      =   scoKeywordsOps grinScanOpts `Set.union` scoKeywordsOps hsScanOpts'
        ,   scoDollarIdent      =   True
        ,   scoOpChars          =   Set.fromList "<->:=+*"
        ,   scoSpecChars        =   Set.fromList "!=();{}#\\|,`"
        ,   scoSpecPairs        =   Set.fromList [] `Set.union` scoSpecPairs ehScanOpts'
        }
  where hsScanOpts' = hsScanOpts opts
        ehScanOpts' = ehScanOpts opts

{-# LINE 300 "src/ehc/Scanner/Common.chs" #-}
-- | 'ScanOpts' for 'CoreRun' tokenization before parsing
corerunScanOpts :: {- EHCOpts -> -} ScanOpts
corerunScanOpts -- opts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList $
                                        [ "alloc", "module", "tail", "eval", "case", "of", "let", "in", "app", "ffi", "dbg", "tag"
                                        , "g", "d", "l", "i", "m"
                                        , "data", "import"
                                        ]
        -- ,    scoKeywExtraChars   =   Set.fromList "."
        ,   scoKeywordsOps      =   Set.fromList [ "->", "." ]
        ,   scoSpecChars        =   Set.fromList "();,=\\"
        ,   scoOpChars          =   Set.fromList "->."
        ,   scoAllowFloat       =   False
        ,   scoDollarIdent      =   True
        }

{-# LINE 321 "src/ehc/Scanner/Common.chs" #-}
tycoreScanOpts :: ScanOpts
tycoreScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   (Set.fromList $
                                        [ "let", "in", "case", "of", "rec", "foreign", "uniq"
                                        , "Int", "Char", "String", "Tag", "Rec"
                                        , "module", "default"
                                        , "BINDPLAIN", "BINDFUNCTION0", "BINDFUNCTION1", "BINDAPPLY0"
                                        , "VAL"
                                        , "DICT", "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED"
                                        , "Integer"
                                        , "foreignexport"
                                        ])
        ,   scoKeywordsOps      =   Set.fromList [ "->", "=", ":", "::", "|", "\\" ]
        ,   scoSpecChars        =   Set.fromList "();{},[]"
        ,   scoOpChars          =   Set.fromList "|\\:=-<>"
        ,   scoDollarIdent      =   True
        }

{-# LINE 352 "src/ehc/Scanner/Common.chs" #-}
grinScanOpts :: ScanOpts
grinScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList $
                                        [ "eval", "apply"
                                        , "call"
                                        , "module", "update", "fetch", "store", "unit", "of", "rec", "case", "ffi", "fetchupdate"
                                        , "throw", "try", "catch", "ctags", "applymap", "evalmap"
                                        , "C", "F", "P", "A", "R", "H", "U", "W"
                                        , "basicnode", "enumnode", "opaquenode", "ptrnode", "basicannot", "enumannot", "opaqueannot", "ptrannot"
                                        , "annotfromtaggedptr", "annottotaggedptr", "annotdflt"
                                        , "word"
                                        , "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED", "SPECIALIZED"
                                        , "_"
                                        , "float", "double"
                                        , "True", "False"  -- for FFI annotation
                                        ]
                                        ++ map show allFFIWays
        ,   scoKeywordsOps      =   Set.fromList [ "<-", "->", "=", "+=", "-=", ":=", "-", "*" ]
        ,   scoSpecChars        =   Set.fromList "();{}#/\\|,"
        ,   scoOpChars          =   Set.fromList "<->:=+*"
        ,   scoDollarIdent      =   True
        }

{-# LINE 384 "src/ehc/Scanner/Common.chs" #-}
tyScanOpts :: ScanOpts
tyScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList [ "uid" ]
        }

{-# LINE 392 "src/ehc/Scanner/Common.chs" #-}
hsnScanOpts :: ScanOpts
hsnScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList
                                        [ "NEW"
                                        , "ERR"
                                        , "UNQ"
                                        , "EVL"
                                        , "FLD"
                                        , "CLS"
                                        , "DCT"
                                        , "SDC"
                                        , "RDC"
                                        , "SUP"
                                        , "DFL"
                                        , "INL"
                                        , "UND"
                                        , "OFF"
                                        , "CCN"
                                        , "UPD"
                                        , "FFI"
                                        , "LBL"
                                        , "ASP"
                                        , "STR"
                                        , "GEN"
                                        , "FFE"
                                        , "FFC"
                                        ]
        ,   scoSpecChars        =   Set.fromList ".{},`"
        ,   scoOpChars          =   Set.fromList "[]:" `Set.union` scoOpChars hsScanOpts'
        ,   scoAllowQualified   =   False
        }
  where hsScanOpts' = hsScanOpts emptyEHCOpts

{-# LINE 441 "src/ehc/Scanner/Common.chs" #-}
foreignEntScanOpts :: FFIWay -> ScanOpts
foreignEntScanOpts way
  =  o {   scoKeywordsTxt      =   Set.fromList [ "dynamic", "wrapper", "h", "static", "new", "js" ]
       ,   scoSpecChars        =   Set.fromList ",.&%[]()*{}"
       ,   scoDollarIdent      =   False
       ,   scoKeywExtraChars   =   Set.fromList wayKeywExtraChars
       ,   scoAllowQualified   =   False
       ,   scoStringDelims     =   scoStringDelims o ++ wayStringDelims
       }
  where o = defaultScanOpts
        (wayKeywExtraChars,wayStringDelims)
          = case way of
              _                 -> ("" , "" )


{-# LINE 480 "src/ehc/Scanner/Common.chs" #-}
splitTokensOnModuleTrigger :: ScanOpts -> [Token] -> Maybe ([Token],[Token])
splitTokensOnModuleTrigger scanOpts ts
  = case break ismod ts of
      (ts1,ts2@[]) -> Nothing
      tss          -> Just tss
  where ismod (Reserved s _) | s == scoOffsideModule scanOpts = True
        ismod _                                               = False

{-# LINE 490 "src/ehc/Scanner/Common.chs" #-}
offsideScanHandle :: ScanOpts -> FilePath -> Handle -> IO (OffsideInput [Token] Token (Maybe Token))
offsideScanHandle scanOpts fn fh
  = do  {  tokens <- scanHandle scanOpts fn fh
        -- ;  putStrLn (" tokens: " ++ show tokens)
        ;  case splitTokensOnModuleTrigger scanOpts tokens of
             Just (ts1,ts2) -> return $ scanLiftTokensToOffside ts1
                                      $ scanOffsideWithTriggers moduleT oBrace cBrace triggers ts2
             _              -> return $ scanOffsideWithTriggers moduleT oBrace cBrace triggers tokens
        }
  where   moduleT   = reserved (scoOffsideModule scanOpts) noPos
          oBrace    = reserved (scoOffsideOpen scanOpts) noPos
          cBrace    = reserved (scoOffsideClose scanOpts) noPos
          triggers  =  [ (Trigger_IndentGT,reserved x noPos) | x <- scoOffsideTrigs   scanOpts ]
                    ++ [ (Trigger_IndentGE,reserved x noPos) | x <- scoOffsideTrigsGE scanOpts ]

{-# LINE 515 "src/ehc/Scanner/Common.chs" #-}
floatDenot2NomDenom :: String -> (Integer,Integer)
floatDenot2NomDenom denot
  = (numerator f,denominator f)
  where (n,m,e) = getRational denot
        f :: Rational
        f = ((read n * md + mn) * en) % (ed * md)
        en, ed, mn, md :: Integer
        (en,ed) = case e of
                    Just (Just "-",e) -> (1,10 ^ read e)
                    Just (_,e)        -> (10 ^ read e,1)
                    _                 -> (1,1)
        (mn,md) = case m of
                    Just m -> (read m,10 ^ length m)
                    _      -> (1,1)

intDenot2Integer :: Int -> String -> Integer
intDenot2Integer b s = getBaseNumber (toInteger b) s

{-# LINE 540 "src/ehc/Scanner/Common.chs" #-}
pKeyTk, pKeyTk'         ::  IsParser p Token
                              => String -> p Token
pKeyTk  key             =   pCostReserved' 9 key
pKeyTk' key             =   pCostReserved' 8 key

pKeyw                   ::  (IsParser p Token,Show k) => k -> p Token
pKeyw k                 =   pKeyTk (show k)

{-# LINE 550 "src/ehc/Scanner/Common.chs" #-}
pKeywHsNname            ::  (IsParser p Token,Show k) => k -> p HsName
pKeywHsNname k          =   tokMkQName <$> pKeyw k


{-# LINE 556 "src/ehc/Scanner/Common.chs" #-}
pStringTk, pCharTk,
  pInteger8Tk, pInteger10Tk, pInteger16Tk, pFractionTk,
{-# LINE 564 "src/ehc/Scanner/Common.chs" #-}
  pQVaridTk, pQConidTk,
  pQVarsymTk, pQConsymTk,
{-# LINE 568 "src/ehc/Scanner/Common.chs" #-}
  pVaridTk , pConidTk ,
  pVaridTk', pConidTk',
  pTextnmTk, pTextlnTk, pIntegerTk, pVarsymTk, pConsymTk
    :: IsParser p Token => p Token

pStringTk     =   pHsCostValToken' 7 TkString    ""
pCharTk       =   pHsCostValToken' 7 TkChar      "\NUL"
pInteger8Tk   =   pHsCostValToken' 7 TkInteger8  "0"
pInteger10Tk  =   pHsCostValToken' 7 TkInteger10 "0"
pInteger16Tk  =   pHsCostValToken' 7 TkInteger16 "0"
pFractionTk   =   pHsCostValToken' 7 TkFraction  "0.0"
pVaridTk      =   pHsCostValToken' 7 TkVarid     "<identifier>"
pVaridTk'     =   pHsCostValToken' 6 TkVarid     "<identifier>"
pConidTk      =   pHsCostValToken' 7 TkConid     "<Identifier>"
pConidTk'     =   pHsCostValToken' 6 TkConid     "<Identifier>"
pConsymTk     =   pHsCostValToken' 7 TkConOp     "<conoperator>"
pVarsymTk     =   pHsCostValToken' 7 TkOp        "<operator>"
pTextnmTk     =   pHsCostValToken' 7 TkTextnm    "<name>"
pTextlnTk     =   pHsCostValToken' 7 TkTextln    "<line>"
pIntegerTk    =   pInteger10Tk
{-# LINE 596 "src/ehc/Scanner/Common.chs" #-}
pQVaridTk     =   pHsCostValToken' 7 TkQVarid     "<identifier>"
pQConidTk     =   pHsCostValToken' 7 TkQConid     "<Identifier>"
pQConsymTk    =   pHsCostValToken' 7 TkQConOp     "<conoperator>"
pQVarsymTk    =   pHsCostValToken' 7 TkQOp        "<operator>"

{-# LINE 607 "src/ehc/Scanner/Common.chs" #-}
pCONID, pCONID', pCONSYM, pVARID, pVARID', pVARSYM :: IsParser p Token => p Token

pCONID           = pConidTk
pCONID'          = pConidTk
pCONSYM          = pConsymTk
pVARID           = pVaridTk
pVARID'          = pVaridTk'
pVARSYM          = pVarsymTk

{-# LINE 627 "src/ehc/Scanner/Common.chs" #-}
pQCONID, pQCONSYM, pQVARID, pQVARSYM :: IsParser p Token => p Token

pQCONID          = pQConidTk
pQCONSYM         = pQConsymTk
pQVARID          = pQVaridTk
pQVARSYM         = pQVarsymTk

{-# LINE 640 "src/ehc/Scanner/Common.chs" #-}
tokGetVal :: Token -> String
tokGetVal x
  = tokenVal x

pV :: (IsParser p Token) => p Token -> p String
pV p = tokGetVal <$> p

pHNm :: (IsParser p Token) => p Token -> p HsName
pHNm p = (hsnFromString . tokGetVal) <$> p

{-# LINE 662 "src/ehc/Scanner/Common.chs" #-}
tokConcat :: Token -> Token -> Token
tokConcat t1 t2 = Reserved (tokenVal t1 ++ tokenVal t2) (position t1)

tokEmpty :: Token
tokEmpty = Reserved "" noPos

{-# LINE 674 "src/ehc/Scanner/Common.chs" #-}
pMODULE        ,
    pWHERE     ,
    pSEMI      ,
    pDCOLON    ,
    pCOLON     ,
    pOBRACK    ,
    pCBRACK    ,
    pOCURLY    ,
    pCCURLY    ,
    pVOCURLY   ,
    pVCCURLY   ,
    pAT        ,
    pPERCENT   ,
    pDOT       ,
    pCOMMA     ,
    pOPAREN    ,
    pCPAREN    ,
    pINFIX     ,
    pINFIXL    ,
    pINFIXR    ,
    pMINUS     ,
    pSTAR      ,
    pBANG      ,
    pEQUAL     ,
    pRARROW    ,
    pBACKQUOTE ,
    pLET       ,
    pLAM       ,
    pSLASH     ,
    pUNDERSCORE,
    pIN
  :: IsParser p Token => p Token

{-# LINE 709 "src/ehc/Scanner/Common.chs" #-}
pMODULE          = pKeyTk "module"
pWHERE           = pKeyTk "where"
pSEMI            = pKeyTk ";"
pCOLON           = pKeyTk ":"
pDCOLON          = pKeyTk "::"
pOBRACK          = pKeyTk "["
pCBRACK          = pKeyTk "]"
pOCURLY          = pKeyTk "{"
pCCURLY          = pKeyTk "}"
pVOCURLY         = pKeyTk "{-layout"
pVCCURLY         = pKeyTk "}-layout"
pAT              = pKeyTk "@"
pPERCENT         = pKeyTk "%"
pDOT             = pKeyTk "."
pCOMMA           = pKeyTk ","
pOPAREN          = pKeyTk "("
pCPAREN          = pKeyTk ")"
pINFIX           = pKeyTk "infix"
pINFIXL          = pKeyTk "infixl"
pINFIXR          = pKeyTk "infixr"
pMINUS           = pKeyTk "-"
pSTAR            = pKeyTk "*"
pBANG            = pKeyTk "!"
pEQUAL           = pKeyTk "="
pRARROW          = pKeyw hsnArrow
pBACKQUOTE       = pKeyTk "`"
pLET             = pKeyTk "let"
pLAM             = pKeyTk "\\"
pSLASH           = pKeyTk "/"
pUNDERSCORE      = pKeyTk "_"
pIN              = pKeyTk "in"

tokKeywStrsEH1 = [ "in", "let" ]
tokKeywStrsHS1 = [ "module", "where", "infix", "infixl", "infixr" ]
tokOpStrsEH1   = [ "=", "\\", show hsnArrow, "::", "@" ]
tokOpStrsHS1   = [ "-", "*", "!", "_", "%", "." ]

{-# LINE 748 "src/ehc/Scanner/Common.chs" #-}
pTDOT       ,
    pQDOT
  :: IsParser p Token => p Token

{-# LINE 754 "src/ehc/Scanner/Common.chs" #-}
pTDOT            = pKeyTk "..."
pQDOT            = pKeyTk "...."

tokOpStrsEH2   = [ "...", "...." ]
tokOpStrsHS2   = [  ]

{-# LINE 762 "src/ehc/Scanner/Common.chs" #-}
tokOpStrsEH3   = [ "%" ]
tokOpStrsHS3   = [  ]

{-# LINE 767 "src/ehc/Scanner/Common.chs" #-}
pFORALL       ,
    pEXISTS   ,
    pTILDE
  :: IsParser p Token => p Token

{-# LINE 774 "src/ehc/Scanner/Common.chs" #-}
pFORALL          = pKeyTk "forall"
pEXISTS          = pKeyTk "exists"
pTILDE           = pKeyTk (show hsnEqTilde)

tokKeywStrsEH4 = [ "forall", "exists" ]
tokKeywStrsHS4 = [  ]
tokOpStrsEH4   = [ ".", show hsnEqTilde ]
tokOpStrsHS4   = [  ]

{-# LINE 785 "src/ehc/Scanner/Common.chs" #-}
pLARROW        ,
    pVBAR      ,
    pDATA      ,
    pNEWTYPE   ,
    pCASE      ,
    pOF        ,
    pIF        ,
    pTHEN      ,
    pELSE      ,
    pDOTDOT
  :: IsParser p Token => p Token

{-# LINE 799 "src/ehc/Scanner/Common.chs" #-}
pLARROW          = pKeyTk "<-"
pVBAR            = pKeyTk "|"
pDATA            = pKeyTk "data"
pNEWTYPE         = pKeyTk "newtype"
pCASE            = pKeyTk "case"
pOF              = pKeyTk "of"
pIF              = pKeyTk "if"
pTHEN            = pKeyTk "then"
pELSE            = pKeyTk "else"
pDOTDOT          = pKeyTk ".."

tokKeywStrsEH5 = [ "data", "case", "if", "then", "else", "of" ]
tokKeywStrsHS5 = [ "newtype" ]
tokOpStrsEH5   = [ "|" ]
tokOpStrsHS5   = [ "<-", "..", ":" ]

{-# LINE 817 "src/ehc/Scanner/Common.chs" #-}
pFFORALL      ,
    pEEXISTS
  :: IsParser p Token => p Token

{-# LINE 823 "src/ehc/Scanner/Common.chs" #-}
pFFORALL         = pKeyTk "Forall"
pEEXISTS         = pKeyTk "Exists"

tokKeywStrsEH6 = [  ]
tokKeywStrsHS6 = [  ]
tokKeywStrsHI6 = [ "Forall", "Exists" ]
tokOpStrsEH6   = [ "*" ]
tokOpStrsHS6   = [  ]

{-# LINE 834 "src/ehc/Scanner/Common.chs" #-}
pOROWREC        ,
    pCROWREC    ,
    pOROWROW    ,
    pCROWROW    ,
    pOROWSUM    ,
    pCROWSUM    ,
    pCOLEQUAL   ,
    pHASH
  :: IsParser p Token => p Token

{-# LINE 846 "src/ehc/Scanner/Common.chs" #-}
pOROWREC         = pKeyTk (show hsnORec)
pCROWREC         = pKeyTk (show hsnCRec)
pOROWROW         = pKeyTk (show hsnORow)
pCROWROW         = pKeyTk (show hsnCRow)
pOROWSUM         = pKeyTk (show hsnOSum)
pCROWSUM         = pKeyTk (show hsnCSum)
pCOLEQUAL        = pKeyTk ":="
pHASH            = pKeyTk "#"

{-# LINE 857 "src/ehc/Scanner/Common.chs" #-}
tokOpStrsEH7   = [ ":=", "#" ]
tokOpStrsHS7   = [  ]

{-# LINE 862 "src/ehc/Scanner/Common.chs" #-}
pLABEL          ,
    pLETSTRICT  ,
    pSAFE       ,
    pFOREIGN    ,
    pDEFAULT    ,
    pIMPORT     ,
    pEXPORT
  :: IsParser p Token => p Token

{-# LINE 873 "src/ehc/Scanner/Common.chs" #-}
pLABEL           = pKeyTk "label"
pLETSTRICT       = pKeyTk "letstrict"
pSAFE            = pKeyTk "safe"
pFOREIGN         = pKeyTk "foreign"
pDEFAULT         = pKeyTk "default"
pIMPORT          = pKeyTk "import"
pEXPORT          = pKeyTk "export"

tokKeywStrsEH8
  =  [ "letstrict", "foreign", "import" ]
  ++ map show allFFIWays
tokKeywStrsHS8 = [ "default", "export", "label", "safe" ]

{-# LINE 890 "src/ehc/Scanner/Common.chs" #-}
pFFIWay :: IsParser p Token => p (FFIWay,Token)
pFFIWay
  =   pAnyKey (\way -> (,) way <$> pKeyTk (show way)) allFFIWays
  <?> "pFFIWay"

{-# LINE 900 "src/ehc/Scanner/Common.chs" #-}
pDARROW         ,
    pLTCOLON    ,
    pOIMPL      ,
    pCIMPL      ,
    pCLASS      ,
    pINSTANCE   ,
    pDO
  :: IsParser p Token => p Token

{-# LINE 911 "src/ehc/Scanner/Common.chs" #-}
pDARROW          = pKeyTk (show hsnPrArrow)
pLTCOLON         = pKeyTk "<:"
pOIMPL           = pKeyTk (show hsnOImpl)
pCIMPL           = pKeyTk (show hsnCImpl)
pCLASS           = pKeyTk "class"
pINSTANCE        = pKeyTk "instance"
pDO              = pKeyTk "do"

tokKeywStrsEH9 = [ "class", "instance" ]
tokKeywStrsHS9 = [ "do" ]
tokOpStrsEH9   = [ show hsnPrArrow, "<:" ]
tokOpStrsHS9   = [  ]

{-# LINE 926 "src/ehc/Scanner/Common.chs" #-}
tokOpStrsEH10  = [] -- [ show hsnDynVar ]
tokOpStrsHS10  = [  ]

{-# LINE 934 "src/ehc/Scanner/Common.chs" #-}
pTYPE
  :: IsParser p Token => p Token

{-# LINE 939 "src/ehc/Scanner/Common.chs" #-}
pTYPE            = pKeyTk "type"

{-# LINE 943 "src/ehc/Scanner/Common.chs" #-}
tokKeywStrsEH11 = [ "type" ]
tokKeywStrsHS11 = [  ]
tokOpStrsEH11   = [  ]
tokOpStrsHS11   = [  ]

{-# LINE 950 "src/ehc/Scanner/Common.chs" #-}
pQUALIFIED      ,
    pQUESTQUEST ,
    pAS         ,
    pHIDING
  :: IsParser p Token => p Token

{-# LINE 958 "src/ehc/Scanner/Common.chs" #-}
pQUALIFIED       = pKeyTk "qualified"
pAS              = pKeyTk "as"
pHIDING          = pKeyTk "hiding"
pQUESTQUEST      = pKeyTk "??"

tokKeywStrsEH12 = [  ]
tokKeywStrsHS12 = [ "qualified", "as", "hiding" ]

{-# LINE 968 "src/ehc/Scanner/Common.chs" #-}
pDERIVING
  :: IsParser p Token => p Token

pDERIVING        = pKeyTk "deriving"

tokKeywStrsEH91 = [ "deriving" ]

{-# LINE 977 "src/ehc/Scanner/Common.chs" #-}
pUNSAFE     ,
    pTHREADSAFE ,
    pDYNAMIC    ,
    pWRAPPER    ,
    pSTATIC     ,
    pH          ,
    pNEW        ,
    pJS         ,
    pAMPERSAND
  :: IsParser p Token => p Token

pUNSAFE          = pKeyTk "unsafe"
pTHREADSAFE      = pKeyTk "threadsafe"
pDYNAMIC         = pKeyTk "dynamic"
pWRAPPER         = pKeyTk "wrapper" -- not a HS keyword, but only for foreign function entity
pSTATIC          = pKeyTk "static" -- not a HS keyword, but only for foreign function entity
pH               = pKeyTk "h" -- not a HS keyword, but only for foreign function entity
pAMPERSAND       = pKeyTk "&" -- not a HS keyword, but only for foreign function entity
pNEW             = pKeyTk "new"
pJS              = pKeyTk "js"

tokKeywStrsEH90  = [  ]
tokKeywStrsHS90  = [ "unsafe", "threadsafe", "dynamic" ]

{-# LINE 1003 "src/ehc/Scanner/Common.chs" #-}
pFUSE         ,
    -- pWITH     ,
    pCONVERT
  :: IsParser p Token => p Token

pFUSE    = pKeyTk "fuse"
-- pWITH    = pKeyTk "with"
pCONVERT = pKeyTk "convert"

tokKeywStrsEH93  = [  ]
tokKeywStrsHS93  = [ "fuse", "convert" ]

{-# LINE 1017 "src/ehc/Scanner/Common.chs" #-}
pLANGUAGE_prag          ,
    pOPTIONSUHC_prag    ,
    pDERIVABLE_prag     ,
    pEXCLUDEIFTARGET_prag,
    pOPRAGMA            ,
    pCPRAGMA
  :: IsParser p Token => p Token

pLANGUAGE_prag   = pKeyTk "LANGUAGE"
pDERIVABLE_prag  = pKeyTk "DERIVABLE"
pEXCLUDEIFTARGET_prag  = pKeyTk "EXCLUDE_IF_TARGET"
pOPTIONSUHC_prag = pKeyTk "OPTIONS_UHC"
pOPRAGMA         = pKeyTk "{-#"
pCPRAGMA         = pKeyTk "#-}"

tokPragmaStrsHS99= [ "LANGUAGE", "DERIVABLE", "EXCLUDE_IF_TARGET", "OPTIONS_UHC" {- , "INLINE", "NOINLINE", "SPECIALIZE" -} ]


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Scanner.Common
( module UHC.Light.Compiler.Scanner.Common
, module UHC.Light.Compiler.Scanner.Scanner )
where
import System.IO
import UU.Parsing
import UU.Parsing.Offside
import UU.Scanner.Position
import UU.Scanner.GenToken
import UU.Scanner.GenTokenParser
import UHC.Util.ScanUtils ()
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import qualified Data.Set as Set
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Scanner.Scanner
import UHC.Util.ParseUtils
import UHC.Light.Compiler.Base.Target
import Data.Ratio




























ehScanOpts :: EHCOpts -> ScanOpts
ehScanOpts opts
  =  defaultScanOpts


        {   scoKeywordsTxt      =
                Set.fromList $
                       tokKeywStrsEH1
                    ++ offsideTrigs


                    ++ tokKeywStrsEH4


                    ++ tokKeywStrsEH5


                    ++ tokKeywStrsEH6


                    ++ tokKeywStrsEH8


                    ++ tokKeywStrsEH9


                    ++ tokKeywStrsEH11


                    ++ tokKeywStrsEH12


                    ++ tokKeywStrsEH90


                    ++ tokKeywStrsEH91


                    ++ (if ehcOptFusion opts then tokKeywStrsEH93 else [])


        ,   scoKeywordsOps      =
                Set.fromList $
                       tokOpStrsEH1


                    ++ tokOpStrsEH2


                    ++ tokOpStrsEH3


                    ++ tokOpStrsEH4


                    ++ tokOpStrsEH5


                    ++ tokOpStrsEH6


                    ++ (if ehcOptExtensibleRecords opts then tokOpStrsEH7 else [])


                    ++ tokOpStrsEH9


                    ++ tokOpStrsEH10


                    ++ tokOpStrsEH11


        ,   scoSpecChars        = Set.fromList $
                "();,[]{}`"
        ,   scoOpChars          = Set.fromList $
                "!#$%&*+/<=>?@\\^|-:.~"


        ,   scoSpecPairs        = Set.fromList $
                [  show hsnORow, show hsnCRow
                ,  show hsnOSum, show hsnCSum
                ,  show hsnOImpl, show hsnCImpl
                ]







        ,   scoOffsideTrigs     =   offsideTrigs
        ,   scoOffsideTrigsGE   =   offsideTrigsGE
        ,   scoOffsideModule    =   "let"
        ,   scoOffsideOpen      =   "{"
        ,   scoOffsideClose     =   "}"
        }
  where offsideTrigs     =
            [  "let", "where"
            ,  "of"
            ,  "letstrict"
            ]
        offsideTrigsGE   =
            [  "do"
            ]











hsScanOpts :: EHCOpts -> ScanOpts
hsScanOpts opts
  = ehScanOpts'


        {   scoKeywordsTxt      =
                scoKeywordsTxt ehScanOpts' `Set.union`
                (Set.fromList $
                       offsideTrigs
                    ++ tokKeywStrsHS1
                    ++ tokKeywStrsHS4
                    ++ tokKeywStrsHS5
                    ++ tokKeywStrsHS6
                    ++ tokKeywStrsHS8
                    ++ tokKeywStrsHS9
                    ++ tokKeywStrsHS11
                    ++ tokKeywStrsHS12
                    ++ tokKeywStrsHS90
                    ++ (if ehcOptFusion opts then tokKeywStrsHS93 else [])
                )




















        ,   scoPragmasTxt      =
                (Set.fromList $
                       tokPragmaStrsHS99
                )


        ,   scoKeywordsOps      =
                scoKeywordsOps ehScanOpts'
                `Set.union`
                (Set.fromList $
                       tokOpStrsHS1
                    ++ tokOpStrsHS2
                    ++ tokOpStrsHS3
                    ++ tokOpStrsHS4
                    ++ tokOpStrsHS5
                    ++ tokOpStrsHS6
                    ++ tokOpStrsHS7
                    ++ tokOpStrsHS9
                    ++ tokOpStrsHS10
                    ++ tokOpStrsHS11
                )




















        ,   scoOffsideTrigs     =
                scoOffsideTrigs ehScanOpts'
                ++ offsideTrigs
        ,   scoOffsideTrigsGE   =
                scoOffsideTrigsGE ehScanOpts'
        ,   scoOffsideModule    =   "module"
        }
  where offsideTrigs     =
            [  "where"
            ]
        ehScanOpts' = ehScanOpts opts







-- | 'ScanOpts' for 'Core' tokenization before parsing
coreScanOpts :: EHCOpts -> ScanOpts
coreScanOpts opts
  =  grinScanOpts
        {   scoKeywordsTxt      =   (Set.fromList $
                                        [ "let", "in", "case", "of", "rec", "foreign", "uniq"
                                        , "Int", "Char", "String", "Tag", "Rec"
                                        , "module", "default"
                                        , "import", "export"
                                        , "BINDPLAIN", "BINDFUNCTION0", "BINDFUNCTION1", "BINDAPPLY0"
                                        , "VAL"
                                        , "FAIL"
                                        , "DICT", "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED", "TRACK"
                                        , "Integer"
                                        , "foreignexport"
                                        ])
                                    `Set.union` scoKeywordsTxt tyScanOpts
                                    `Set.union` scoKeywordsTxt hsScanOpts'
        ,   scoKeywExtraChars   =   Set.fromList "."
        ,   scoKeywordsOps      =   scoKeywordsOps grinScanOpts `Set.union` scoKeywordsOps hsScanOpts'
        ,   scoDollarIdent      =   True
        ,   scoOpChars          =   Set.fromList "<->:=+*"
        ,   scoSpecChars        =   Set.fromList "!=();{}#\\|,`"
        ,   scoSpecPairs        =   Set.fromList [] `Set.union` scoSpecPairs ehScanOpts'
        }
  where hsScanOpts' = hsScanOpts opts
        ehScanOpts' = ehScanOpts opts









-- | 'ScanOpts' for 'CoreRun' tokenization before parsing
corerunScanOpts :: {- EHCOpts -> -} ScanOpts
corerunScanOpts -- opts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList $
                                        [ "alloc", "module", "tail", "eval", "case", "of", "let", "in", "app", "ffi", "dbg", "tag"
                                        , "g", "d", "l", "i", "m"
                                        , "data", "import"
                                        ]
        -- ,    scoKeywExtraChars   =   Set.fromList "."
        ,   scoKeywordsOps      =   Set.fromList [ "->", "." ]
        ,   scoSpecChars        =   Set.fromList "();,=\\"
        ,   scoOpChars          =   Set.fromList "->."
        ,   scoAllowFloat       =   False
        ,   scoDollarIdent      =   True
        }





tycoreScanOpts :: ScanOpts
tycoreScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   (Set.fromList $
                                        [ "let", "in", "case", "of", "rec", "foreign", "uniq"
                                        , "Int", "Char", "String", "Tag", "Rec"
                                        , "module", "default"
                                        , "BINDPLAIN", "BINDFUNCTION0", "BINDFUNCTION1", "BINDAPPLY0"
                                        , "VAL"
                                        , "DICT", "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED"
                                        , "Integer"
                                        , "foreignexport"
                                        ])
        ,   scoKeywordsOps      =   Set.fromList [ "->", "=", ":", "::", "|", "\\" ]
        ,   scoSpecChars        =   Set.fromList "();{},[]"
        ,   scoOpChars          =   Set.fromList "|\\:=-<>"
        ,   scoDollarIdent      =   True
        }













grinScanOpts :: ScanOpts
grinScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList $
                                        [ "eval", "apply"
                                        , "call"
                                        , "module", "update", "fetch", "store", "unit", "of", "rec", "case", "ffi", "fetchupdate"
                                        , "throw", "try", "catch", "ctags", "applymap", "evalmap"
                                        , "C", "F", "P", "A", "R", "H", "U", "W"
                                        , "basicnode", "enumnode", "opaquenode", "ptrnode", "basicannot", "enumannot", "opaqueannot", "ptrannot"
                                        , "annotfromtaggedptr", "annottotaggedptr", "annotdflt"
                                        , "word"
                                        , "DICTCLASS", "DICTINSTANCE", "DICTOVERLOADED", "SPECIALIZED"
                                        , "_"
                                        , "float", "double"
                                        , "True", "False"  -- for FFI annotation
                                        ]
                                        ++ map show allFFIWays
        ,   scoKeywordsOps      =   Set.fromList [ "<-", "->", "=", "+=", "-=", ":=", "-", "*" ]
        ,   scoSpecChars        =   Set.fromList "();{}#/\\|,"
        ,   scoOpChars          =   Set.fromList "<->:=+*"
        ,   scoDollarIdent      =   True
        }









tyScanOpts :: ScanOpts
tyScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList [ "uid" ]
        }



hsnScanOpts :: ScanOpts
hsnScanOpts
  =  defaultScanOpts
        {   scoKeywordsTxt      =   Set.fromList
                                        [ "NEW"
                                        , "ERR"
                                        , "UNQ"
                                        , "EVL"
                                        , "FLD"
                                        , "CLS"
                                        , "DCT"
                                        , "SDC"
                                        , "RDC"
                                        , "SUP"
                                        , "DFL"
                                        , "INL"
                                        , "UND"
                                        , "OFF"
                                        , "CCN"
                                        , "UPD"
                                        , "FFI"
                                        , "LBL"
                                        , "ASP"
                                        , "STR"
                                        , "GEN"
                                        , "FFE"
                                        , "FFC"
                                        ]
        ,   scoSpecChars        =   Set.fromList ".{},`"
        ,   scoOpChars          =   Set.fromList "[]:" `Set.union` scoOpChars hsScanOpts'
        ,   scoAllowQualified   =   False
        }
  where hsScanOpts' = hsScanOpts emptyEHCOpts
















foreignEntScanOpts :: FFIWay -> ScanOpts
foreignEntScanOpts way
  =  o {   scoKeywordsTxt      =   Set.fromList [ "dynamic", "wrapper", "h", "static", "new", "js" ]
       ,   scoSpecChars        =   Set.fromList ",.&%[]()*{}"
       ,   scoDollarIdent      =   False
       ,   scoKeywExtraChars   =   Set.fromList wayKeywExtraChars
       ,   scoAllowQualified   =   False
       ,   scoStringDelims     =   scoStringDelims o ++ wayStringDelims
       }
  where o = defaultScanOpts
        (wayKeywExtraChars,wayStringDelims)
          = case way of
              _                 -> ("" , "" )


























splitTokensOnModuleTrigger :: ScanOpts -> [Token] -> Maybe ([Token],[Token])
splitTokensOnModuleTrigger scanOpts ts
  = case break ismod ts of
      (ts1,ts2@[]) -> Nothing
      tss          -> Just tss
  where ismod (Reserved s _) | s == scoOffsideModule scanOpts = True
        ismod _                                               = False



offsideScanHandle :: ScanOpts -> FilePath -> Handle -> IO (OffsideInput [Token] Token (Maybe Token))
offsideScanHandle scanOpts fn fh
  = do  {  tokens <- scanHandle scanOpts fn fh
        -- ;  putStrLn (" tokens: " ++ show tokens)
        ;  case splitTokensOnModuleTrigger scanOpts tokens of
             Just (ts1,ts2) -> return $ scanLiftTokensToOffside ts1
                                      $ scanOffsideWithTriggers moduleT oBrace cBrace triggers ts2
             _              -> return $ scanOffsideWithTriggers moduleT oBrace cBrace triggers tokens
        }
  where   moduleT   = reserved (scoOffsideModule scanOpts) noPos
          oBrace    = reserved (scoOffsideOpen scanOpts) noPos
          cBrace    = reserved (scoOffsideClose scanOpts) noPos
          triggers  =  [ (Trigger_IndentGT,reserved x noPos) | x <- scoOffsideTrigs   scanOpts ]
                    ++ [ (Trigger_IndentGE,reserved x noPos) | x <- scoOffsideTrigsGE scanOpts ]











floatDenot2NomDenom :: String -> (Integer,Integer)
floatDenot2NomDenom denot
  = (numerator f,denominator f)
  where (n,m,e) = getRational denot
        f :: Rational
        f = ((read n * md + mn) * en) % (ed * md)
        en, ed, mn, md :: Integer
        (en,ed) = case e of
                    Just (Just "-",e) -> (1,10 ^ read e)
                    Just (_,e)        -> (10 ^ read e,1)
                    _                 -> (1,1)
        (mn,md) = case m of
                    Just m -> (read m,10 ^ length m)
                    _      -> (1,1)

intDenot2Integer :: Int -> String -> Integer
intDenot2Integer b s = getBaseNumber (toInteger b) s








pKeyTk, pKeyTk'         ::  IsParser p Token
                              => String -> p Token
pKeyTk  key             =   pCostReserved' 9 key
pKeyTk' key             =   pCostReserved' 8 key

pKeyw                   ::  (IsParser p Token,Show k) => k -> p Token
pKeyw k                 =   pKeyTk (show k)



pKeywHsNname            ::  (IsParser p Token,Show k) => k -> p HsName
pKeywHsNname k          =   tokMkQName <$> pKeyw k




pStringTk, pCharTk,
  pInteger8Tk, pInteger10Tk, pInteger16Tk, pFractionTk,






  pQVaridTk, pQConidTk,
  pQVarsymTk, pQConsymTk,


  pVaridTk , pConidTk ,
  pVaridTk', pConidTk',
  pTextnmTk, pTextlnTk, pIntegerTk, pVarsymTk, pConsymTk
    :: IsParser p Token => p Token

pStringTk     =   pHsCostValToken' 7 TkString    ""
pCharTk       =   pHsCostValToken' 7 TkChar      "\NUL"
pInteger8Tk   =   pHsCostValToken' 7 TkInteger8  "0"
pInteger10Tk  =   pHsCostValToken' 7 TkInteger10 "0"
pInteger16Tk  =   pHsCostValToken' 7 TkInteger16 "0"
pFractionTk   =   pHsCostValToken' 7 TkFraction  "0.0"
pVaridTk      =   pHsCostValToken' 7 TkVarid     "<identifier>"
pVaridTk'     =   pHsCostValToken' 6 TkVarid     "<identifier>"
pConidTk      =   pHsCostValToken' 7 TkConid     "<Identifier>"
pConidTk'     =   pHsCostValToken' 6 TkConid     "<Identifier>"
pConsymTk     =   pHsCostValToken' 7 TkConOp     "<conoperator>"
pVarsymTk     =   pHsCostValToken' 7 TkOp        "<operator>"
pTextnmTk     =   pHsCostValToken' 7 TkTextnm    "<name>"
pTextlnTk     =   pHsCostValToken' 7 TkTextln    "<line>"
pIntegerTk    =   pInteger10Tk








pQVaridTk     =   pHsCostValToken' 7 TkQVarid     "<identifier>"
pQConidTk     =   pHsCostValToken' 7 TkQConid     "<Identifier>"
pQConsymTk    =   pHsCostValToken' 7 TkQConOp     "<conoperator>"
pQVarsymTk    =   pHsCostValToken' 7 TkQOp        "<operator>"







pCONID, pCONID', pCONSYM, pVARID, pVARID', pVARSYM :: IsParser p Token => p Token

pCONID           = pConidTk
pCONID'          = pConidTk
pCONSYM          = pConsymTk
pVARID           = pVaridTk
pVARID'          = pVaridTk'
pVARSYM          = pVarsymTk












pQCONID, pQCONSYM, pQVARID, pQVARSYM :: IsParser p Token => p Token

pQCONID          = pQConidTk
pQCONSYM         = pQConsymTk
pQVARID          = pQVaridTk
pQVARSYM         = pQVarsymTk







tokGetVal :: Token -> String
tokGetVal x
  = tokenVal x

pV :: (IsParser p Token) => p Token -> p String
pV p = tokGetVal <$> p

pHNm :: (IsParser p Token) => p Token -> p HsName
pHNm p = (hsnFromString . tokGetVal) <$> p













tokConcat :: Token -> Token -> Token
tokConcat t1 t2 = Reserved (tokenVal t1 ++ tokenVal t2) (position t1)

tokEmpty :: Token
tokEmpty = Reserved "" noPos







pMODULE        ,
    pWHERE     ,
    pSEMI      ,
    pDCOLON    ,
    pCOLON     ,
    pOBRACK    ,
    pCBRACK    ,
    pOCURLY    ,
    pCCURLY    ,
    pVOCURLY   ,
    pVCCURLY   ,
    pAT        ,
    pPERCENT   ,
    pDOT       ,
    pCOMMA     ,
    pOPAREN    ,
    pCPAREN    ,
    pINFIX     ,
    pINFIXL    ,
    pINFIXR    ,
    pMINUS     ,
    pSTAR      ,
    pBANG      ,
    pEQUAL     ,
    pRARROW    ,
    pBACKQUOTE ,
    pLET       ,
    pLAM       ,
    pSLASH     ,
    pUNDERSCORE,
    pIN
  :: IsParser p Token => p Token



pMODULE          = pKeyTk "module"
pWHERE           = pKeyTk "where"
pSEMI            = pKeyTk ";"
pCOLON           = pKeyTk ":"
pDCOLON          = pKeyTk "::"
pOBRACK          = pKeyTk "["
pCBRACK          = pKeyTk "]"
pOCURLY          = pKeyTk "{"
pCCURLY          = pKeyTk "}"
pVOCURLY         = pKeyTk "{-layout"
pVCCURLY         = pKeyTk "}-layout"
pAT              = pKeyTk "@"
pPERCENT         = pKeyTk "%"
pDOT             = pKeyTk "."
pCOMMA           = pKeyTk ","
pOPAREN          = pKeyTk "("
pCPAREN          = pKeyTk ")"
pINFIX           = pKeyTk "infix"
pINFIXL          = pKeyTk "infixl"
pINFIXR          = pKeyTk "infixr"
pMINUS           = pKeyTk "-"
pSTAR            = pKeyTk "*"
pBANG            = pKeyTk "!"
pEQUAL           = pKeyTk "="
pRARROW          = pKeyw hsnArrow
pBACKQUOTE       = pKeyTk "`"
pLET             = pKeyTk "let"
pLAM             = pKeyTk "\\"
pSLASH           = pKeyTk "/"
pUNDERSCORE      = pKeyTk "_"
pIN              = pKeyTk "in"

tokKeywStrsEH1 = [ "in", "let" ]
tokKeywStrsHS1 = [ "module", "where", "infix", "infixl", "infixr" ]
tokOpStrsEH1   = [ "=", "\\", show hsnArrow, "::", "@" ]
tokOpStrsHS1   = [ "-", "*", "!", "_", "%", "." ]



pTDOT       ,
    pQDOT
  :: IsParser p Token => p Token



pTDOT            = pKeyTk "..."
pQDOT            = pKeyTk "...."

tokOpStrsEH2   = [ "...", "...." ]
tokOpStrsHS2   = [  ]



tokOpStrsEH3   = [ "%" ]
tokOpStrsHS3   = [  ]



pFORALL       ,
    pEXISTS   ,
    pTILDE
  :: IsParser p Token => p Token



pFORALL          = pKeyTk "forall"
pEXISTS          = pKeyTk "exists"
pTILDE           = pKeyTk (show hsnEqTilde)

tokKeywStrsEH4 = [ "forall", "exists" ]
tokKeywStrsHS4 = [  ]
tokOpStrsEH4   = [ ".", show hsnEqTilde ]
tokOpStrsHS4   = [  ]



pLARROW        ,
    pVBAR      ,
    pDATA      ,
    pNEWTYPE   ,
    pCASE      ,
    pOF        ,
    pIF        ,
    pTHEN      ,
    pELSE      ,
    pDOTDOT
  :: IsParser p Token => p Token



pLARROW          = pKeyTk "<-"
pVBAR            = pKeyTk "|"
pDATA            = pKeyTk "data"
pNEWTYPE         = pKeyTk "newtype"
pCASE            = pKeyTk "case"
pOF              = pKeyTk "of"
pIF              = pKeyTk "if"
pTHEN            = pKeyTk "then"
pELSE            = pKeyTk "else"
pDOTDOT          = pKeyTk ".."

tokKeywStrsEH5 = [ "data", "case", "if", "then", "else", "of" ]
tokKeywStrsHS5 = [ "newtype" ]
tokOpStrsEH5   = [ "|" ]
tokOpStrsHS5   = [ "<-", "..", ":" ]



pFFORALL      ,
    pEEXISTS
  :: IsParser p Token => p Token



pFFORALL         = pKeyTk "Forall"
pEEXISTS         = pKeyTk "Exists"

tokKeywStrsEH6 = [  ]
tokKeywStrsHS6 = [  ]
tokKeywStrsHI6 = [ "Forall", "Exists" ]
tokOpStrsEH6   = [ "*" ]
tokOpStrsHS6   = [  ]



pOROWREC        ,
    pCROWREC    ,
    pOROWROW    ,
    pCROWROW    ,
    pOROWSUM    ,
    pCROWSUM    ,
    pCOLEQUAL   ,
    pHASH
  :: IsParser p Token => p Token



pOROWREC         = pKeyTk (show hsnORec)
pCROWREC         = pKeyTk (show hsnCRec)
pOROWROW         = pKeyTk (show hsnORow)
pCROWROW         = pKeyTk (show hsnCRow)
pOROWSUM         = pKeyTk (show hsnOSum)
pCROWSUM         = pKeyTk (show hsnCSum)
pCOLEQUAL        = pKeyTk ":="
pHASH            = pKeyTk "#"



tokOpStrsEH7   = [ ":=", "#" ]
tokOpStrsHS7   = [  ]



pLABEL          ,
    pLETSTRICT  ,
    pSAFE       ,
    pFOREIGN    ,
    pDEFAULT    ,
    pIMPORT     ,
    pEXPORT
  :: IsParser p Token => p Token



pLABEL           = pKeyTk "label"
pLETSTRICT       = pKeyTk "letstrict"
pSAFE            = pKeyTk "safe"
pFOREIGN         = pKeyTk "foreign"
pDEFAULT         = pKeyTk "default"
pIMPORT          = pKeyTk "import"
pEXPORT          = pKeyTk "export"

tokKeywStrsEH8
  =  [ "letstrict", "foreign", "import" ]
  ++ map show allFFIWays
tokKeywStrsHS8 = [ "default", "export", "label", "safe" ]





pFFIWay :: IsParser p Token => p (FFIWay,Token)
pFFIWay
  =   pAnyKey (\way -> (,) way <$> pKeyTk (show way)) allFFIWays
  <?> "pFFIWay"






pDARROW         ,
    pLTCOLON    ,
    pOIMPL      ,
    pCIMPL      ,
    pCLASS      ,
    pINSTANCE   ,
    pDO
  :: IsParser p Token => p Token



pDARROW          = pKeyTk (show hsnPrArrow)
pLTCOLON         = pKeyTk "<:"
pOIMPL           = pKeyTk (show hsnOImpl)
pCIMPL           = pKeyTk (show hsnCImpl)
pCLASS           = pKeyTk "class"
pINSTANCE        = pKeyTk "instance"
pDO              = pKeyTk "do"

tokKeywStrsEH9 = [ "class", "instance" ]
tokKeywStrsHS9 = [ "do" ]
tokOpStrsEH9   = [ show hsnPrArrow, "<:" ]
tokOpStrsHS9   = [  ]



tokOpStrsEH10  = [] -- [ show hsnDynVar ]
tokOpStrsHS10  = [  ]






pTYPE
  :: IsParser p Token => p Token



pTYPE            = pKeyTk "type"



tokKeywStrsEH11 = [ "type" ]
tokKeywStrsHS11 = [  ]
tokOpStrsEH11   = [  ]
tokOpStrsHS11   = [  ]



pQUALIFIED      ,
    pQUESTQUEST ,
    pAS         ,
    pHIDING
  :: IsParser p Token => p Token



pQUALIFIED       = pKeyTk "qualified"
pAS              = pKeyTk "as"
pHIDING          = pKeyTk "hiding"
pQUESTQUEST      = pKeyTk "??"

tokKeywStrsEH12 = [  ]
tokKeywStrsHS12 = [ "qualified", "as", "hiding" ]



pDERIVING
  :: IsParser p Token => p Token

pDERIVING        = pKeyTk "deriving"

tokKeywStrsEH91 = [ "deriving" ]



pUNSAFE     ,
    pTHREADSAFE ,
    pDYNAMIC    ,
    pWRAPPER    ,
    pSTATIC     ,
    pH          ,
    pNEW        ,
    pJS         ,
    pAMPERSAND
  :: IsParser p Token => p Token

pUNSAFE          = pKeyTk "unsafe"
pTHREADSAFE      = pKeyTk "threadsafe"
pDYNAMIC         = pKeyTk "dynamic"
pWRAPPER         = pKeyTk "wrapper" -- not a HS keyword, but only for foreign function entity
pSTATIC          = pKeyTk "static" -- not a HS keyword, but only for foreign function entity
pH               = pKeyTk "h" -- not a HS keyword, but only for foreign function entity
pAMPERSAND       = pKeyTk "&" -- not a HS keyword, but only for foreign function entity
pNEW             = pKeyTk "new"
pJS              = pKeyTk "js"

tokKeywStrsEH90  = [  ]
tokKeywStrsHS90  = [ "unsafe", "threadsafe", "dynamic" ]



pFUSE         ,
    -- pWITH     ,
    pCONVERT
  :: IsParser p Token => p Token

pFUSE    = pKeyTk "fuse"
-- pWITH    = pKeyTk "with"
pCONVERT = pKeyTk "convert"

tokKeywStrsEH93  = [  ]
tokKeywStrsHS93  = [ "fuse", "convert" ]



pLANGUAGE_prag          ,
    pOPTIONSUHC_prag    ,
    pDERIVABLE_prag     ,
    pEXCLUDEIFTARGET_prag,
    pOPRAGMA            ,
    pCPRAGMA
  :: IsParser p Token => p Token

pLANGUAGE_prag   = pKeyTk "LANGUAGE"
pDERIVABLE_prag  = pKeyTk "DERIVABLE"
pEXCLUDEIFTARGET_prag  = pKeyTk "EXCLUDE_IF_TARGET"
pOPTIONSUHC_prag = pKeyTk "OPTIONS_UHC"
pOPRAGMA         = pKeyTk "{-#"
pCPRAGMA         = pKeyTk "#-}"

tokPragmaStrsHS99= [ "LANGUAGE", "DERIVABLE", "EXCLUDE_IF_TARGET", "OPTIONS_UHC" {- , "INLINE", "NOINLINE", "SPECIALIZE" -} ]



</pre>