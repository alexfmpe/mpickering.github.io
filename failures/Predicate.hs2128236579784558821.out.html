<a href="Predicate.hs144128232716531729.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Preferences.hs1144108930470211272.out.html">next</a></br></br><pre>12c12
< is :: (a → b) → (b → Bool) → (a → Bool)
---
> is :: (a -> b) -> (b -> Bool) -> (a -> Bool)
18c18
< isn't :: (a → b) → (b → Bool) → (a → Bool)
---
> isn't :: (a -> b) -> (b -> Bool) -> (a -> Bool)
28c28
< equals :: (Eq b) ⇒ (a → b) → b → a → Bool
---
> equals :: (Eq b) => (a -> b) -> b -> a -> Bool
29a30
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}

-- | Provides a couple of convenience functions to be used for forming predicates.
module Data.Function.Predicate
(is,isn't,equals)
where

-- |An example will explain this more than anything:
--
-- > listsLongerThan3Elements :: [[a]] -> [[a]]
-- > listsLongerThan3Elements = filter (length `is` (>3))
is :: (a → b) → (b → Bool) → (a → Bool)
is = flip (.)

-- |The inverse of 'is'.
--
-- > listsShorterThanFourElements = filter (length `isn't` (>3))
isn't :: (a → b) → (b → Bool) → (a → Bool)
isn't p x y = not $ (p `is` x) y

-- |This is 'is' with a fixed equality condition.
--
-- Example:
--
-- > data Color = White | Black deriving (Eq)
-- > data ChessPiece = { color :: Color, name :: String }
-- > whitePieces = filter (color `equals` White)
equals :: (Eq b) ⇒ (a → b) → b → a → Bool
equals p y x = p x == y
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}

-- | Provides a couple of convenience functions to be used for forming predicates.
module Data.Function.Predicate
(is,isn't,equals)
where

-- |An example will explain this more than anything:
--
-- > listsLongerThan3Elements :: [[a]] -> [[a]]
-- > listsLongerThan3Elements = filter (length `is` (>3))
is :: (a -> b) -> (b -> Bool) -> (a -> Bool)
is = flip (.)

-- |The inverse of 'is'.
--
-- > listsShorterThanFourElements = filter (length `isn't` (>3))
isn't :: (a -> b) -> (b -> Bool) -> (a -> Bool)
isn't p x y = not $ (p `is` x) y

-- |This is 'is' with a fixed equality condition.
--
-- Example:
--
-- > data Color = White | Black deriving (Eq)
-- > data ChessPiece = { color :: Color, name :: String }
-- > whitePieces = filter (color `equals` White)
equals :: (Eq b) => (a -> b) -> b -> a -> Bool
equals p y x = p x == y

</pre>