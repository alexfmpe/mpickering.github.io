<a href="EHC.hs837204200578134256.out.html">prev</a></br><a href="failures.html">home</a></br><a href="endless.hs16683066481683337704.out.html">next</a></br></br><pre>18c18
< {-# LINE 25 "src/ehc/EHCRun.chs" #-}
---
> 
18a19
> 
18a20
> 
18a21
> 
18a22
> 
18a23
> 
18a24
> 
57a64
> 
</pre></br><h2>original</h2></br><pre>module Main
where
import UHC.Light.Compiler.EHC.Main
import UHC.Light.Compiler.EHC.Main.Utils
import UHC.Light.Compiler.Base.API
import UHC.Light.Compiler.CoreRun.API
import UHC.Util.Pretty
import UHC.Util.FPath
import System.Exit
import System.FilePath
import System.Console.GetOpt
import System.IO
import Control.Monad
import System.Environment
import Data.List
import qualified Data.ByteString.Char8 as B

{-# LINE 25 "src/ehc/EHCRun.chs" #-}
-- | Top level main. TBD: hooks & customization
main :: IO ()
main = do
    args <- getArgs
    progName <- getProgName
    let opts0         = defaultEHCOpts
                          {ehcProgName = mkFPath progName}
        oo@(o,n,errs) = ehcrunCmdLineOptsApply args opts0
        opts          = maybe opts0 id o

    case ehcOptImmQuit opts of
      Just immq     -> handleImmQuitOption ehcrunCmdLineOpts ["rcr", "crr", "cr"] immq opts
      _             -> case (n,errs) of
        ([fname], []) -> do
          let (bname,ext) = splitExtension fname
          case ext of
            ".rcr" -> runRCR opts fname
            ".crr" -> runRCR opts fname
            ".cr"  -> mainEHC $ opts
                        { ehcOptMbTarget = JustOk Target_None_Core_AsIs
                        , ehcOptCoreOpts = CoreOpt_Run : ehcOptCoreOpts opts
                        , ehcOptOptimizationScope = OptimizationScope_WholeCore
                        , ehcOptVerbosity = VerboseQuiet
                        }
            _      -> return ()
        (_      , es) -> do
          putStr (head errs)
          exitFailure

  where runRCR opts fname = do
            inp <- B.readFile fname
            case parseModFromString $ B.unpack inp of
              Left  es  -> forM_ es putStrLn
              Right mod -> do
                res <- runCoreRunIO opts mod
                case res of
                  Left  e   -> putStrLn $ show $ pp e
                  Right val -> putStrLn $ show $ pp val

</pre></br><h2>printed</h2></br><pre>module Main
where
import UHC.Light.Compiler.EHC.Main
import UHC.Light.Compiler.EHC.Main.Utils
import UHC.Light.Compiler.Base.API
import UHC.Light.Compiler.CoreRun.API
import UHC.Util.Pretty
import UHC.Util.FPath
import System.Exit
import System.FilePath
import System.Console.GetOpt
import System.IO
import Control.Monad
import System.Environment
import Data.List
import qualified Data.ByteString.Char8 as B








-- | Top level main. TBD: hooks & customization
main :: IO ()
main = do
    args <- getArgs
    progName <- getProgName
    let opts0         = defaultEHCOpts
                          {ehcProgName = mkFPath progName}
        oo@(o,n,errs) = ehcrunCmdLineOptsApply args opts0
        opts          = maybe opts0 id o

    case ehcOptImmQuit opts of
      Just immq     -> handleImmQuitOption ehcrunCmdLineOpts ["rcr", "crr", "cr"] immq opts
      _             -> case (n,errs) of
        ([fname], []) -> do
          let (bname,ext) = splitExtension fname
          case ext of
            ".rcr" -> runRCR opts fname
            ".crr" -> runRCR opts fname
            ".cr"  -> mainEHC $ opts
                        { ehcOptMbTarget = JustOk Target_None_Core_AsIs
                        , ehcOptCoreOpts = CoreOpt_Run : ehcOptCoreOpts opts
                        , ehcOptOptimizationScope = OptimizationScope_WholeCore
                        , ehcOptVerbosity = VerboseQuiet
                        }
            _      -> return ()
        (_      , es) -> do
          putStr (head errs)
          exitFailure

  where runRCR opts fname = do
            inp <- B.readFile fname
            case parseModFromString $ B.unpack inp of
              Left  es  -> forM_ es putStrLn
              Right mod -> do
                res <- runCoreRunIO opts mod
                case res of
                  Left  e   -> putStrLn $ show $ pp e
                  Right val -> putStrLn $ show $ pp val


</pre>