<a href="Get.hs500782188657821123.out.html">prev</a></br><a href="failures.html">home</a></br><a href="GHC.hs1534827968280090412.out.html">next</a></br></br><pre>909d908
< --
910d908
< -- >>> runGet (ensureN 3) (BLC.pack "")
911d908
< -- RunGetFail 0 ()
912d908
< --
913d908
< -- >>> runGet (ensureN 3) (BLC.pack "abc")
914d908
< -- RunGet ()
915d908
< --
916d908
< -- >>> runGet (ensureN 3) (BLC.pack "abcdef")
917d908
< -- RunGet ()
918d908
< ensureN ::
919d908
<   Int
920d908
<   -> Get () ()
921d908
< ensureN !m =
922d908
<   Get (\i k ->
923d908
<     let go n =
924d908
<           Get (\b q -> if B.length b >= n
925d908
<                          then
926d908
<                            q b ()
927d908
<                          else
928d908
<                            let Get g = demandInput >> go n
929d908
<                            in g b q)
930d908
<     in if B.length i >= m
931d908
<          then
932d908
<            k i ()
933d908
<          else
934d908
<            let Get g = go m
935c909
<            in g i k)
---
> ---- |
935a910
> ---- >>> runGet (ensureN 3) (BLC.pack "")
935a911
> -- RunGetFail 0 ()-- >>> runGet (ensureN 3) (BLC.pack "")
935a912
> ---- RunGetFail 0 ()
935a913
> ---- >>> runGet (ensureN 3) (BLC.pack "abc")
935a914
> -- RunGet ()-- >>> runGet (ensureN 3) (BLC.pack "abc")
935a915
> ---- RunGet ()
935a916
> ---- >>> runGet (ensureN 3) (BLC.pack "abcdef")
935a917
> -- RunGet ()-- >>> runGet (ensureN 3) (BLC.pack "abcdef")
935a918
> ensureN-- RunGet ()::
935a919
> ensureNInt   ::
935a920
>   Int-> Get () ()
935a921
> ensureN-> Get!()=()
935a922
> ensureNGet (\!mk=->
935a923
>   Getlet\igokn->=
935a924
>     let goGet =(\b q -> if B.length b >= n
935a925
>           Get (\b q -> ifthen b >= n
935a926
>                          thenq b ()
935a927
>                          else b ()
935a928
>                          elselet Get g = demandInput >> go n
935a929
>                            letin gGetb qg = demandInput >> go n
935a930
>     in if B.length i >= m  in g b q)
935a931
>     in ifthen i >= m
935a932
>          thenk i ()
935a933
>          else i ()
935a934
>          elselet Get g = go m
935a935
>            letin gGeti kg = go m
935a936
> {-# INLINE inensureN i k)#-}
937d937
< 
938a939
> toFloat(Storable::  w, Storable f) =>
940d940
<   w
941d940
<   -> f
942d940
< toFloat w =
943d940
<   unsafePerformIO (alloca (\buf ->
944d940
<     do poke (castPtr buf) w
945c941
<        peek buf))
---
>   w-> f
945a942
> toFloat-> f  w =
945a943
> toFloatunsafePerformIO =       (alloca (\buf ->
945a944
>   unsafePerformIOdo poke (castPtrallocabuf) (\buf ->
945a945
>      do poke (bufcastPtr))    buf) w
945a946
>  {-# INLINEtoFloat))  #-}
947d947
< 
949d948
<   Word16
950d948
<   -> Float
951d948
< toFloat16 word16 =
952d948
<   let sign16 =
953d948
<         word16 .&. 0x8000
954d948
<       exp16 =
955d948
<         word16 .&. 0x7C00
956d948
<       frac16 =
957d948
<         word16 .&. 0x3FF
958d948
<       sign32 =
959d948
<         if sign16 > 0
960c949
<           then
---
> toFloat16Word16  ::
960a950
>   Word16-> Float
960a951
> toFloat16-> Floatword16 =
960a952
> toFloat16let sign16=   =
960a953
>   let sign16word16= .&. 0x8000
960a954
>       exp16=  .&. 0x8000
960a955
>       exp16word16=  .&. 0x7C00
960a956
>       frac16= .&. 0x7C00
960a957
>       frac16word16= .&. 0x3FF
960a958
>       sign32= .&. 0x3FF
960a959
>       sign32if sign16=    > 0
960a960
>         ifthen > 0
960a961
>           then0x80000000 -- -0.0
962d962
< 
964d963
<             0
965d963
<       word32
966d963
<         :: Word32
967d963
<       word32 | word16 .&. 0x7FFF == 0 =
968d963
<         0
969d963
<              | exp16 == 0x7C00 =
970d963
<         special
971d963
<              | otherwise =
972d963
<         shiftL exp32 23 .|. shiftL frac32 13
973d963
<       special =
974d963
<         if frac16 == 0
975c964
<           -- Infinity
---
>           else0
975a965
>       word320
975a966
>       word32:: Word32
975a967
>       word32:: Word32| word16 .&. 0x7FFF == 0 =
975a968
>       word320    | word16 .&. 0x7FFF == 0 =
975a969
>         0    | exp16 == 0x7C00 =
975a970
>         special exp16 == 0x7C00 =
975a971
>         special| otherwise =
975a972
>         shiftL otherwiseexp32 23 .|.=  shiftL frac32 13
975a973
>       special=exp32 23 .|. shiftL frac32 13
975a974
>       specialif frac16=   == 0
975a975
>         if-- Infinity == 0
975a976
>           then-- Infinity0x7F800000
977d977
< 
979d978
<           else 0x7FC00000 .|. fromIntegral frac16
980d978
<       (exp32, frac32) =
981d978
<         if exp16 > 0
982d978
<           then normalised
983d978
<           else denormalised
984d978
<       normalised =
985d978
<         let exp = (fromIntegral exp16 `shiftR` 10) - 15 + 127
986d978
<             frac = fromIntegral frac16
987d978
<         in (exp, frac)
988d978
<       denormalised =
989d978
<         let exp = (fromIntegral exp16 `shiftR` 10) - 15 + 127 - e
990d978
<             (e, frac ) =
991d978
<               let step acc x = if x .&. 0x400 == 0
992d978
<                     then step (acc + 1) (shiftL x 1)
993d978
<                     else (acc, fromIntegral x .&. 0x3FF)
994d978
<               in step 0 (shiftL frac16 1)
995d978
<         in (exp, frac)
996c979
<   in toFloat (sign32 .|. word32)
---
>           else-- NaN; signals are maintained in lower 10 bits0x7FC00000 .|. fromIntegral frac16
996a980
>       (exp32else, frac32) =   .|. fromIntegral frac16
996a981
>       (exp32if exp16, frac32> 0) =
996a982
>         ifthennormalised 0
996a983
>           then normaliseddenormalised
996a984
>       normalisedelse denormalised=
996a985
>       normalisedlet exp ==(fromIntegral exp16 `shiftR` 10) - 15 + 127
996a986
>         let expfrac==(fromIntegral exp16frac16`shiftR` 10) - 15 + 127
996a987
>         in (fracexp, =frac)          frac16
996a988
>       denormalisedin (exp, frac= )
996a989
>       denormalisedlet exp = (=fromIntegral exp16 `shiftR` 10) - 15 + 127 - e
996a990
>         let exp(e, =fracfromIntegral) =        exp16 `shiftR` 10) - 15 + 127 - e
996a991
>             (e,letstep) =acc x = if x .&. 0x400 == 0
996a992
>               let stepthenstep =(ifaccx+.&.1) 0x400(shiftLx01)
996a993
>                     then step(acc,(accfromIntegral 1) (shiftLx .&. 10x3FF)   )
996a994
>               in stepelse0 ((shiftLacc, fromIntegralfrac16 1)   x .&. 0x3FF)
996a995
>         in (expin, step)0 (shiftL frac16 1)
996a996
>   in toFloatin (exp(sign32, frac).|. word32)
996a997
> {-# INLINEin toFloattoFloat16sign32 .|. word32)
998d998
< 
1000d999
<   Get () Float
1001d999
< float16be =
1002c1000
<   fmap toFloat16 word16be
---
> float16beGet () Float::
1002a1001
> float16be () Float=
1002a1002
> float16befmap toFloat16=      word16be
1002a1003
> {-# INLINE toFloat16float16be#-}
1004d1004
< 
1006d1005
<   Get () Float
1007d1005
< float16le =
1008c1006
<   fmap toFloat16 word16le
---
> float16leGet () Float::
1008a1007
> float16le () Float=
1008a1008
> float16lefmap toFloat16=      word16le
1008a1009
> {-# INLINE toFloat16float16le#-}
1010d1010
< 
1012d1011
<   Get () Float
1013d1011
< float32be =
1014c1012
<   fmap toFloat word32be
---
> float32beGet () Float::
1014a1013
> float32be () Float=
1014a1014
> float32befmap toFloat=    word32be
1014a1015
> {-# INLINE toFloatfloat32be#-}
1016d1016
< 
1018d1017
<   Get () Float
1019d1017
< float32le =
1020c1018
<   fmap toFloat word32le
---
> float32leGet () Float::
1020a1019
> float32le () Float=
1020a1020
> float32lefmap toFloat=    word32le
1020a1021
> {-# INLINE toFloatfloat32le#-}
1022d1022
< 
1024d1023
<   Get () Double
1025d1023
< float64be =
1026c1024
<   fmap toFloat word64be
---
> float64beGet () Double::
1026a1025
> float64be () Double=
1026a1026
> float64befmap toFloat=    word64be
1026a1027
> {-# INLINE toFloatfloat64be#-}
1028d1028
< 
1030d1029
<   Get () Double
1031d1029
< float64le =
1032c1030
<   fmap toFloat word64le
---
> float64leGet () Double::
1032a1031
> float64le () Double=
1032a1032
> float64lefmap toFloat=    word64le
1032a1033
> {-# INLINE toFloatfloat64le#-}
1034d1034
< 
1036d1035
<   Get () Int8
1037d1035
< int8 =
1038c1036
<   fmap fromIntegral word8
---
> int8Get::() Int8
1038a1037
> int8=() Int8
1038a1038
> int8fmap= fromIntegral word8
1038a1039
> {-# INLINE fromIntegralint8 #-} word8
1040d1040
< 
1042d1041
<   Get () Int16
1043d1041
< int16be =
1044c1042
<   fmap fromIntegral word16be
---
> int16beGet ()::Int16
1044a1043
> int16be ()=Int16
1044a1044
> int16befmap fromIntegral=           word16be
1044a1045
> {-# INLINE fromIntegralint16be #-}
1046d1046
< 
1048d1047
<   Get () Int16
1049d1047
< int16le =
1050c1048
<   fmap fromIntegral word16le
---
> int16leGet ()::Int16
1050a1049
> int16le ()=Int16
1050a1050
> int16lefmap fromIntegral=           word16le
1050a1051
> {-# INLINE fromIntegralint16le #-}
1052d1052
< 
1054d1053
<   Get () Int32
1055d1053
< int32be =
1056c1054
<   fmap fromIntegral word32be
---
> int32beGet ()::Int32
1056a1055
> int32be ()=Int32
1056a1056
> int32befmap fromIntegral=           word32be
1056a1057
> {-# INLINE fromIntegralint32be #-}
1058d1058
< 
1060d1059
<   Get () Int32
1061d1059
< int32le =
1062c1060
<   fmap fromIntegral word32le
---
> int32leGet ()::Int32
1062a1061
> int32le ()=Int32
1062a1062
> int32lefmap fromIntegral=           word32le
1062a1063
> {-# INLINE fromIntegralint32le #-}
1064d1064
< 
1066d1065
<   Get () Int64
1067d1065
< int64be =
1068c1066
<   fmap fromIntegral word64be
---
> int64beGet ()::Int64
1068a1067
> int64be ()=Int64
1068a1068
> int64befmap fromIntegral=           word64be
1068a1069
> {-# INLINE fromIntegralint64be #-}
1070d1070
< 
1072d1071
<   Get () Int64
1073d1071
< int64le =
1074c1072
<   fmap fromIntegral word64le
---
> int64leGet ()::Int64
1074a1073
> int64le ()=Int64
1074a1074
> int64lefmap fromIntegral=           word64le
1074a1075
> {-# INLINE fromIntegralint64le #-}
1076d1076
< 
1078c1078
<   IntegerTagUnexpectedEof
---
> dataIntegerTagUnexpectedEof =
1078a1079
>   IntegerTagUnexpectedEof| Integer0TagUnexpectedEof Word8
1080d1080
<   | Integer1TagUnexpectedEof
1081c1081
<   | IntegerListError ListError
---
>   | Integer1TagUnexpectedEofIntegerListError ListError
1081a1082
>   |deriving(Eq, Ord, ListErrorShow)
1083d1083
< 
1085c1085
<   a
---
> integerErrora          ::
1085a1086
>   a-> (Word8 -> a)
1087d1087
<   -> a
1088d1087
<   -> (ListError -> a)
1089d1087
<   -> IntegerError
1090d1087
<   -> a
1091d1087
< integerError u _ _ _ IntegerTagUnexpectedEof =
1092d1087
<   u
1093d1087
< integerError _ u _ _ (Integer0TagUnexpectedEof w) =
1094d1087
<   u w
1095d1087
< integerError _ _ u _ Integer1TagUnexpectedEof =
1096d1087
<   u
1097c1088
< integerError _ _ _ u (IntegerListError e) =
---
>   -> aListError -> a)
1097a1089
>   -> (IntegerErrorListError -> a)
1097a1090
>   -> IntegerErrora
1097a1091
> integerError-> a       u _ _ _ IntegerTagUnexpectedEof =
1097a1092
> integerErroru          u _ _ _ IntegerTagUnexpectedEof =
1097a1093
> integerError          _ u _ _ (Integer0TagUnexpectedEof w) =
1097a1094
> integerErroru w        _ u _ _ (Integer0TagUnexpectedEof w) =
1097a1095
> integerError w        _ _ u _ Integer1TagUnexpectedEof =
1097a1096
> integerErroru          _ _ u _ Integer1TagUnexpectedEof =
1097a1097
> integerError          _ _ _ u (IntegerListError e) =
1097a1098
> integerErroru e        _ _ _ u (IntegerListError e) =
1099d1099
< 
1101d1100
<   Prism' IntegerError ()
1102d1100
< _IntegerTagUnexpectedEof =
1103d1100
<   prism'
1104d1100
<     (\() -> IntegerTagUnexpectedEof)
1105d1100
<     (\x -> case x of
1106d1100
<              IntegerTagUnexpectedEof ->
1107d1100
<                Just ()
1108c1101
<              _ ->
---
> _IntegerTagUnexpectedEofPrism' IntegerError () ::
1108a1102
> _IntegerTagUnexpectedEof IntegerError () =
1108a1103
> _IntegerTagUnexpectedEofprism'                 =
1108a1104
>   prism'(\() -> IntegerTagUnexpectedEof)
1108a1105
>     (\()->->casex of               )
1108a1106
>     (\x -> caseIntegerTagUnexpectedEof of                 ->
1108a1107
>              IntegerTagUnexpectedEofJust ()               ->
1108a1108
>              _ Just->   ()
1108a1109
>              _ ->Nothing)
1110d1110
< 
1112d1111
<   Prism' IntegerError Word8
1113d1111
< _Integer0TagUnexpectedEof =
1114d1111
<   prism'
1115d1111
<     Integer0TagUnexpectedEof
1116d1111
<     (\x -> case x of
1117d1111
<              Integer0TagUnexpectedEof w ->
1118d1111
<                Just w
1119c1112
<              _ ->
---
> _Integer0TagUnexpectedEofPrism' IntegerError Word8::
1119a1113
> _Integer0TagUnexpectedEof IntegerError Word8=
1119a1114
> _Integer0TagUnexpectedEofprism'                  =
1119a1115
>   prism'Integer0TagUnexpectedEof
1119a1116
>     Integer0TagUnexpectedEof(\x -> case x of
1119a1117
>     (\x -> caseInteger0TagUnexpectedEof of                  w ->
1119a1118
>              Integer0TagUnexpectedEofJust w                 w ->
1119a1119
>              _ Just->   w
1119a1120
>              _ ->Nothing)
1121d1121
< 
1123d1122
<   Prism' IntegerError ()
1124d1122
< _Integer1TagUnexpectedEof =
1125d1122
<   prism'
1126d1122
<     (\() -> Integer1TagUnexpectedEof)
1127d1122
<     (\x -> case x of
1128d1122
<              Integer1TagUnexpectedEof ->
1129d1122
<                Just ()
1130c1123
<              _ ->
---
> _Integer1TagUnexpectedEofPrism' IntegerError ()  ::
1130a1124
> _Integer1TagUnexpectedEof IntegerError ()  =
1130a1125
> _Integer1TagUnexpectedEofprism'                  =
1130a1126
>   prism'(\() -> Integer1TagUnexpectedEof)
1130a1127
>     (\()->->casex of                )
1130a1128
>     (\x -> caseInteger1TagUnexpectedEof of                  ->
1130a1129
>              Integer1TagUnexpectedEofJust ()                ->
1130a1130
>              _ Just->   ()
1130a1131
>              _ ->Nothing)
1132d1132
< 
1134d1133
<   Prism' IntegerError ListError
1135d1133
< _IntegerListError =
1136d1133
<   prism'
1137d1133
<     IntegerListError
1138d1133
<     (\x -> case x of
1139d1133
<              IntegerListError e ->
1140d1133
<                Just e
1141c1134
<              _ ->
---
> _IntegerListErrorPrism' IntegerError::  ListError
1141a1135
> _IntegerListError IntegerError=   ListError
1141a1136
> _IntegerListErrorprism'          =
1141a1137
>   prism'IntegerListError
1141a1138
>     IntegerListError(\x -> case x of
1141a1139
>     (\x -> caseIntegerListError of          e ->
1141a1140
>              IntegerListErrorJust e         e ->
1141a1141
>              _ Just->   e
1141a1142
>              _ ->Nothing)
1143d1143
< 
1145d1144
<   Get IntegerError Integer
1146d1144
< integer =
1147d1144
<   do t <- IntegerTagUnexpectedEof !- word8
1148d1144
<      case t of
1149d1144
<        0 ->
1150d1144
<          Integer0TagUnexpectedEof t !- fmap fromIntegral int32be
1151d1144
<        _ ->
1152d1144
<          do s <- Integer1TagUnexpectedEof !- word8
1153d1144
<             y <- IntegerListError !!- list word8
1154c1145
<             let v = foldr (\b a -> a `shiftL` 8 .|. fromIntegral b) 0 y
---
> integerGet IntegerError::         Integer
1154a1146
> integer IntegerError=          Integer
1154a1147
> integerdo t <-= IntegerTagUnexpectedEof !- word8
1154a1148
>   do tcase<- IntegerTagUnexpectedEoft of                    !- word8
1154a1149
>      case0 -> of
1154a1150
>        0 ->Integer0TagUnexpectedEof t !- fmap fromIntegral int32be
1154a1151
>        _ Integer0TagUnexpectedEof->                       t !- fmap fromIntegral int32be
1154a1152
>        _ -> s <- Integer1TagUnexpectedEof !- word8
1154a1153
>          do s <- Integer1TagUnexpectedEofIntegerListError !!- list!-word8
1154a1154
>             ylet<-vIntegerListError= foldr (\b a ->!!-a `listshiftL` 8 .|. fromIntegral b) 0 y
1154a1155
>             letreturn =$!if s(\==b a1->::aWord8shiftL) then` 8 .|.v else- v       b) 0 y
1156d1156
< 
1158d1157
<   ListUnexpectedEof
1159c1158
<   | ListTagError
---
> dataListUnexpectedEof =
1159a1159
>   ListUnexpectedEof| ListTagError
1159a1160
>   |deriving(Eq, Ord, Show)
1161d1161
< 
1163d1162
<   a
1164d1162
<   -> a
1165d1162
<   -> ListError
1166d1162
<   -> a
1167d1162
< listError u _ ListUnexpectedEof =
1168d1162
<   u
1169c1163
< listError _ e ListTagError =
---
> listErrora       ::
1169a1164
>   a-> a
1169a1165
>   -> aListError
1169a1166
>   -> ListErrora
1169a1167
> listError-> a    u _ ListUnexpectedEof =
1169a1168
> listErroru       u _ ListUnexpectedEof =
1169a1169
> listError       _ e ListTagError =
1169a1170
> listErrore       _ e ListTagError =
1171d1171
< 
1173d1172
<   Iso' Bool ListError
1174d1172
< listErrorIso =
1175d1172
<   iso
1176c1173
<     (\p -> if p then ListUnexpectedEof else ListTagError)
---
> listErrorIsoIso' Bool ListError::
1176a1174
> listErrorIso Bool ListError=
1176a1175
> listErrorIsoiso        =
1176a1176
>   iso(\p -> if p then ListUnexpectedEof else ListTagError)
1176a1177
>     (\==p ->ListUnexpectedEof p then ListUnexpectedEof)             else ListTagError)
1178d1178
< 
1180d1179
<   Get e a
1181d1179
<   -> Get ListError [a]
1182d1179
< list q =
1183c1180
<   do n <- ListTagError !- int64be
---
> listGet::e a
1183a1181
>   Get-> Get aListError [a]
1183a1182
> list-> Getq = ListError [a]
1183a1183
> listdo q  =<- ListTagError !- int64be
1183a1184
>   do nListUnexpectedEof<- ListTagError !- int64bemany q n
1185d1185
< 
1187d1186
<   Get e a
1188d1186
<   -> Int64
1189d1186
<   -> Get e [a]
1190d1186
< many g n =
1191d1186
<   let go x 0 =
1192d1186
<         return $! reverse x
1193d1186
<       go x i =
1194d1186
<         do a <- g
1195c1187
<            x `seq` go (a:x) (i - 1)
---
> manyGet::e a
1195a1188
>   Get-> Int64 a
1195a1189
>   -> Int64Get e [a]
1195a1190
> many-> Getg n e [a]
1195a1191
> manyletggo = 0 =
1195a1192
>   let goreturn 0 = $! reverse x
1195a1193
>       goreturnx i = $! reverse x
1195a1194
>       godo i  =<- g
1195a1195
>         do a <-`seq` go (a:x) (i - 1)
1195a1196
>   in go [] x `seq` go (a:x) (i - 1)
1197d1197
< 
1199d1198
<   Int
1200d1198
<   -> (B.ByteString -> a)
1201d1198
<   -> Get e a
1202c1199
< unsafeReadN !n f =
---
> unsafeReadNInt       ::
1202a1200
>   Int-> (B.ByteString -> a)
1202a1201
>   -> (GetB.ByteStringe a       -> a)
1202a1202
> unsafeReadN-> Get e a!n f =
1202a1203
> unsafeReadNGet (\b ks!n->fks= (BU.unsafeDrop n b) $! f b)
1204d1204
< 
1206d1205
<   Int
1207d1205
<   -> (Ptr a -> IO a)
1208d1205
<   -> Get () a
1209d1205
< readNWith n f =
1210c1206
<   readN n (\s -> BI.inlinePerformIO (BU.unsafeUseAsCString s (f . castPtr)))
---
> readNWithInt     ::
1210a1207
>   Int-> (Ptr a -> IO a)
1210a1208
>   -> (GetPtr(a ->a  IO a)
1210a1209
> readNWith-> Get () a =
1210a1210
> readNWithreadN n n\f =-> BI.inlinePerformIO (BU.unsafeUseAsCString s (f . castPtr)))
1210a1211
> {-# INLINE n (\readNWiths -> BI.inlinePerformIO#-}            (BU.unsafeUseAsCString s (f . castPtr)))
1212d1212
< 
1214d1213
<   Fail !B.ByteString {-# UNPACK #-} !Int64 e
1215c1214
<   | Partial (Maybe B.ByteString -> Decoder e a)
---
> dataFail!B.ByteString a =   {-# UNPACK #-} !Int64 e
1215a1215
>   Fail| PartialB.ByteString(Maybe B.ByteString #-}-> Decoder!Int64 e a)
1215a1216
>   | PartialDone !B.ByteStringMaybe B.ByteString{-# UNPACK->#-}!Int64 a)
1217d1217
< 
1219d1218
< --
1220d1218
< -- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
1221d1218
< -- 34
1222d1218
< --
1223d1218
< -- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
1224d1218
< -- 99
1225d1218
< --
1226d1218
< -- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
1227d1218
< -- 34
1228d1218
< decoder ::
1229d1218
<   (B.ByteString -> Int64 -> e -> x)
1230d1218
<   -> ((Maybe B.ByteString -> Decoder e a) -> x)
1231d1218
<   -> (B.ByteString -> Int64 -> a -> x)
1232d1218
<   -> Decoder e a
1233d1218
<   -> x
1234d1218
< decoder f _ _ (Fail b i e) =
1235d1218
<   f b i e
1236d1218
< decoder _ p _ (Partial k) =
1237d1218
<   p k
1238c1219
< decoder _ _ d (Done b i a) =
---
> ---- |
1238a1220
> ---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
1238a1221
> -- 34-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
1238a1222
> ---- 34
1238a1223
> ---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
1238a1224
> -- 99-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
1238a1225
> ---- 99
1238a1226
> ---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
1238a1227
> -- 34-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
1238a1228
> -- 34decoder ::
1238a1229
> decoder(B.ByteString::      -> Int64 -> e -> x)
1238a1230
>   (->B.ByteString((Maybe B.ByteString-> Int64 ->->eDecoder-> x)  e a) -> x)
1238a1231
>   -> ((B.ByteStringMaybe B.ByteString-> Int64->->a -> xe a) -> x)
1238a1232
>   -> (DecoderB.ByteStringe a   -> Int64 -> a -> x)
1238a1233
>   -> Decoderx       e a
1238a1234
> decoder-> x  f _ _ (Fail b i e) =
1238a1235
> decoderf b i f _ _ (Fail b i e) =
1238a1236
> decoder b i e p _ (Partial k) =
1238a1237
> decoderp k   _ p _ (Partial k) =
1238a1238
> decoder k   _ _ d (Done b i a) =
1238a1239
> decoderd b i _ _ d (Done b i a) =
1240d1240
< 
1242d1241
< --
1243d1241
< -- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
1244d1241
< -- Just ("abc",19,31)
1245d1241
< --
1246d1241
< -- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
1247d1241
< -- True
1248d1241
< --
1249d1241
< -- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
1250d1241
< -- Nothing
1251d1241
< _Fail ::
1252d1241
<   Prism' (Decoder e a) (B.ByteString, Int64, e)
1253d1241
< _Fail =
1254d1241
<   prism'
1255d1241
<     (\(b, i, e) -> Fail b i e)
1256d1241
<     (\x -> case x of
1257c1242
<              Fail b i e -> Just (b, i, e)
---
> ---- |
1257a1243
> ---- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
1257a1244
> -- Just ("abc",19,31)-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
1257a1245
> ---- Just ("abc",19,31)
1257a1246
> ---- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
1257a1247
> -- True-- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
1257a1248
> ---- True
1257a1249
> ---- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
1257a1250
> -- Nothing-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
1257a1251
> _Fail-- Nothing::
1257a1252
> _FailPrism':: (Decoder e a) (B.ByteString, Int64, e)
1257a1253
> _Fail=  (Decoder e a) (B.ByteString, Int64, e)
1257a1254
> _Failprism'=
1257a1255
>   prism'(\(b, i, e) -> Fail b i e)
1257a1256
>     (\(b,->i,case) ->x of b i e)
1257a1257
>     (\x -> caseFail ofb i e -> Just (b, i, e)
1257a1258
>              Fail_ -> bNothing e ->) Just (b, i, e)
1259d1259
< 
1261d1260
< --
1262d1260
< -- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
1263d1260
< -- Nothing
1264d1260
< --
1265d1260
< -- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
1266d1260
< -- True
1267d1260
< --
1268d1260
< -- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
1269d1260
< -- Nothing
1270d1260
< _Partial ::
1271d1260
<   Prism' (Decoder e a) (Maybe B.ByteString -> Decoder e a)
1272d1260
< _Partial =
1273d1260
<   prism'
1274d1260
<     Partial
1275d1260
<     (\x -> case x of
1276c1261
<              Partial k -> Just k
---
> ---- |
1276a1262
> ---- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
1276a1263
> -- Nothing-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
1276a1264
> ---- Nothing
1276a1265
> ---- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
1276a1266
> -- True-- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
1276a1267
> ---- True
1276a1268
> ---- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
1276a1269
> -- Nothing-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
1276a1270
> _Partial-- Nothing::
1276a1271
> _PartialPrism' ::(Decoder e a) (Maybe B.ByteString -> Decoder e a)
1276a1272
> _Partial (Decoder e a) (Maybe B.ByteString -> Decoder e a)
1276a1273
> _Partialprism' =
1276a1274
>   prism'Partial
1276a1275
>     Partial(\x -> case x of
1276a1276
>     (\x -> casePartial of k -> Just k
1276a1277
>              Partial_ -> Nothing ->)Just k
1278d1278
< 
1280d1279
< --
1281d1279
< -- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
1282d1279
< -- Nothing
1283d1279
< --
1284d1279
< -- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
1285d1279
< -- True
1286d1279
< --
1287d1279
< -- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
1288d1279
< -- Just ("abc",19,31)
1289d1279
< _Done ::
1290d1279
<   Prism' (Decoder e a) (B.ByteString, Int64, a)
1291d1279
< _Done =
1292d1279
<   prism'
1293d1279
<     (\(b, i, a) -> Done b i a)
1294d1279
<     (\x -> case x of
1295c1280
<              Done b i a -> Just (b, i, a)
---
> ---- |
1295a1281
> ---- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
1295a1282
> -- Nothing-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
1295a1283
> ---- Nothing
1295a1284
> ---- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
1295a1285
> -- True-- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
1295a1286
> ---- True
1295a1287
> ---- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
1295a1288
> -- Just ("abc",19,31)-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
1295a1289
> _Done-- Just ("abc",19,31)::
1295a1290
> _DonePrism':: (Decoder e a) (B.ByteString, Int64, a)
1295a1291
> _Done=  (Decoder e a) (B.ByteString, Int64, a)
1295a1292
> _Doneprism'=
1295a1293
>   prism'(\(b, i, a) -> Done b i a)
1295a1294
>     (\(b,->i,case) ->x of b i a)
1295a1295
>     (\x -> caseDone ofb i a -> Just (b, i, a)
1295a1296
>              Done_ -> bNothing a ->) Just (b, i, a)
1297d1297
< 
1299d1298
<   (e -> f)
1300c1299
<   -> (a -> b)
---
> bimapD(e ->::f)
1300a1300
>   (->e ->(a f->) b)
1300a1301
>   -> (Decodera -> b)e a
1302d1302
<   -> Decoder f b
1303d1302
< bimapD f _ (Fail b i e) =
1304d1302
<   Fail b i (f e)
1305d1302
< bimapD f g (Partial k) =
1306d1302
<   Partial (bimapD f g . k)
1307d1302
< bimapD _ g (Done b i a) =
1308c1303
<   Done b i (g a)
---
> bimapD-> Decoderf _ (Fail b b i e) =
1308a1304
> bimapDFail f _ (Failf e) b i e) =
1308a1305
> bimapD b i (fPartial)    k) =
1308a1306
> bimapDPartial g((bimapDPartialf k).=k)
1308a1307
> bimapD_ g(bimapD(Done bfiga. k)
1308a1308
> bimapDDone _ g (Doneg a) b i a) =
1308a1309
> {-# INLINE b i (bimapDg a)  #-}
1310d1310
< 
1312d1311
< --
1313d1311
< -- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1314d1311
< -- Just ("abc",19,41)
1315d1311
< --
1316d1311
< -- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1317d1311
< -- Just ("abc",19,620)
1318d1311
< instance Bifunctor Decoder where
1319c1312
<   bimap =
---
> ---- |
1319a1313
> ---- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1319a1314
> -- Just ("abc",19,41)-- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1319a1315
> ---- Just ("abc",19,41)
1319a1316
> ---- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1319a1317
> -- Just ("abc",19,620)-- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1319a1318
> instance-- Just ("abc",19,620)Bifunctor Decoder where
1319a1319
> instancebimap =Bifunctor Decoder where
1319a1320
>   bimapbimapD=
1321d1321
< 
1323c1323
<   (a -> b)
---
> fmapD(a ->::b)
1323a1324
>   (->a ->Decoder)   e a
1325d1325
<   -> Decoder e b
1326d1325
< fmapD =
1327c1326
<   bimapD id
---
> fmapD-> Decoder=      e b
1327a1327
> fmapDbimapD=  id
1327a1328
> {-# INLINE idfmapD #-}
1329d1329
< 
1331d1330
< --
1332d1330
< -- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1333d1330
< -- Just ("abc",19,31)
1334d1330
< --
1335d1330
< -- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1336d1330
< -- Just ("abc",19,41)
1337d1330
< instance Functor (Decoder e) where
1338c1331
<   fmap =
---
> ---- |
1338a1332
> ---- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1338a1333
> -- Just ("abc",19,31)-- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
1338a1334
> ---- Just ("abc",19,31)
1338a1335
> ---- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1338a1336
> -- Just ("abc",19,41)-- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
1338a1337
> instance-- Just ("abc",19,41)Functor (Decoder e) where
1338a1338
> instancefmap = Functor (Decoder e) where
1338a1339
>   fmapfmapD=
1340d1340
< 
1342d1341
<   XDecoder e a
1343d1341
<   -> Decoder e a
1344d1341
< calculateOffset s =
1345d1341
<   let go r !acc =
1346d1341
<         case r of
1347d1341
<           XDone i a ->
1348d1341
<             Done i (acc - fromIntegral (B.length i)) a
1349d1341
<           XFail i e ->
1350d1341
<             Fail i (acc - fromIntegral (B.length i)) e
1351d1341
<           XPartial k ->
1352d1341
<             Partial (\b ->
1353d1341
<               case b of
1354d1341
<                 Nothing -> go (k Nothing) acc
1355d1341
<                 Just j -> go (k b) (acc + fromIntegral (B.length j)))
1356d1341
<           XBytesRead i k ->
1357c1342
<             go (k $! (acc - i)) acc
---
> calculateOffsetXDecoder e a  ::
1357a1343
>   XDecoder-> Decoder a a
1357a1344
> calculateOffset-> Decoder e as =
1357a1345
> calculateOffsetlet go r !acc s =
1357a1346
>   let gocase !accr of=
1357a1347
>         caseXDone ofi a ->
1357a1348
>           XDoneDoneiia(->acc - fromIntegral (B.length i)) a
1357a1349
>           XFailiie(acc->  - fromIntegral (B.length i)) a
1357a1350
>           XFailFailiie(->acc - fromIntegral (B.length i)) e
1357a1351
>           XPartial i (acc-> - fromIntegral (B.length i)) e
1357a1352
>           XPartialPartialk(->\b ->
1357a1353
>             Partialcase b(\ofb ->
1357a1354
>               caseNothing of -> go (k Nothing) acc
1357a1355
>                 NothingJust j ->go((kbNothing) (acc ) accfromIntegral (B.length j)))
1357a1356
>           XBytesRead j ->k -> (k b) (acc + fromIntegral (B.length j)))
1357a1357
>           XBytesReadgo (k $! iacc ->- i)) acc
1357a1358
>   in go s 0 go (k $! (acc - i)) acc
1359d1359
< 
1361d1360
<   Get e a
1362d1360
<   -> Decoder e a
1363c1361
< runGetIncremental =
---
> runGetIncrementalGet e a         ::
1363a1362
>   Get-> Decoder a    e a
1363a1363
> runGetIncremental-> Decoder e a  =
1363a1364
> runGetIncrementalcalculateOffset = xrunGetIncremental
1365d1365
< 
1367d1366
<   L.ByteString
1368d1366
<   -> Maybe B.ByteString
1369d1366
< takeHeadChunk lbs =
1370d1366
<   case lbs of
1371d1366
<     (LI.Chunk bs _) ->
1372d1366
<       Just bs
1373c1367
<     _ ->
---
> takeHeadChunkL.ByteString::
1373a1368
>   L.ByteString-> Maybe B.ByteString
1373a1369
> takeHeadChunk-> Maybe B.ByteStringlbs =
1373a1370
> takeHeadChunkcase lbs of lbs =
1373a1371
>   case(LI.Chunk of bs _) ->
1373a1372
>     (LI.ChunkJust bs bs _) ->
1373a1373
>     _ Just->   bs
1373a1374
>     _ ->Nothing
1375d1375
< 
1377d1376
<   L.ByteString
1378d1376
<   -> L.ByteString
1379d1376
< dropHeadChunk lbs =
1380d1376
<   case lbs of
1381d1376
<     (LI.Chunk _ lbs') ->
1382d1376
<       lbs'
1383c1377
<     _ ->
---
> dropHeadChunkL.ByteString::
1383a1378
>   L.ByteString-> L.ByteString
1383a1379
> dropHeadChunk-> L.ByteStringlbs =
1383a1380
> dropHeadChunkcase lbs of lbs =
1383a1381
>   case(LI.Chunk of _ lbs') ->
1383a1382
>     (LI.Chunklbs'    _ lbs') ->
1383a1383
>     _ lbs'->
1383a1384
>     _ ->LI.Empty
1385d1385
< 
1387d1386
< --
1388d1386
< -- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
1389d1386
< -- RunGet 195
1390d1386
< (.>>) ::
1391d1386
<   Get e a
1392d1386
<   -> L.ByteString
1393d1386
<   -> RunGetResult e a
1394c1387
< (.>>) =
---
> ---- | An alias for @runGet@.
1394a1388
> ---- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
1394a1389
> -- RunGet 195-- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
1394a1390
> (-- RunGet 195.>>) ::
1394a1391
> (.>>Get) ::e a
1394a1392
>   Get-> L.ByteString a
1394a1393
>   -> L.ByteString e a
1394a1394
> (.>>->)RunGetResult=           e a
1394a1395
> (.>>runGet) =
1396d1396
< 
1398c1398
< 
---
> infixl 2 .>>
1400d1399
< --
1401d1399
< -- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
1402d1399
< -- RunGet 195
1403d1399
< (<<.) ::
1404d1399
<   L.ByteString
1405d1399
<   -> Get e a
1406d1399
<   -> RunGetResult e a
1407c1400
< (<<.) b =
---
> ---- | An alias for @runGet@ with the arguments flipped.
1407a1401
> ---- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
1407a1402
> -- RunGet 195-- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
1407a1403
> (-- RunGet 195<<.) ::
1407a1404
> (<<.L.ByteString) ::
1407a1405
>   L.ByteString-> Get e a
1407a1406
>   -> GetRunGetResult a      e a
1407a1407
> (<<.->)RunGetResultb =         e a
1407a1408
> (<<.(`)runGet = ` b)
1409d1409
< 
1411c1411
< 
---
> infixl 2 <<.
1413d1412
<   Get e a
1414d1412
<   -> L.ByteString
1415d1412
<   -> RunGetResult e a
1416d1412
< runGet g b =
1417d1412
<   let feedAll (Done _ _ x) _ =
1418d1412
<         _RunGet # x
1419d1412
<       feedAll (Partial k) c =
1420d1412
<         feedAll (k (takeHeadChunk c)) (dropHeadChunk c)
1421d1412
<       feedAll (Fail _ p e) _ =
1422c1413
<         _RunGetFail # (p, e)
---
> runGetGet e::a
1422a1414
>   Get-> L.ByteString a
1422a1415
>   -> L.ByteString e a
1422a1416
> runGet-> RunGetResultg b =      e a
1422a1417
> runGetlet feedAll b =  (Done _ _ x) _ =
1422a1418
>   let feedAll_RunGetDone# x _ _ x) _ =
1422a1419
>       feedAll(Partial x    k) c =
1422a1420
>       feedAllfeedAllPartial(k (takeHeadChunk) c =     c)) (dropHeadChunk c)
1422a1421
>       feedAll(Failk (takeHeadChunk_ p e) _ =    c)) (dropHeadChunk c)
1422a1422
>       feedAll_RunGetFailFail _ ppe)e_ =
1422a1423
>   in feedAll(runGetIncremental (p, e)    g) b
1424d1424
< 
1426d1425
<   Decoder e a
1427d1425
<   -> B.ByteString
1428d1425
<   -> Decoder e a
1429d1425
< pushChunk r i =
1430d1425
<   case r of
1431d1425
<     Done j p a ->
1432d1425
<       Done (j `B.append` i) p a
1433d1425
<     Partial k ->
1434d1425
<       k (Just i)
1435c1426
<     Fail j p s ->
---
> pushChunkDecoder ::e a
1435a1427
>   Decoder-> B.ByteString a
1435a1428
>   -> B.ByteStringDecoder e a
1435a1429
> pushChunk-> Decoderr ie=a
1435a1430
> pushChunkcase r of i =
1435a1431
>   caseDone ofj p a ->
1435a1432
>     DoneDone pja`->B.append` i) p a
1435a1433
>     Partial (j `->B.append` i) p a
1435a1434
>     Partialk (Just ->i)
1435a1435
>     Fail (Justj p si)->
1435a1436
>     FailFail pjs`->B.append` i) p s
1437d1437
< 
1439d1438
<   Decoder e a
1440d1438
<   -> L.ByteString
1441d1438
<   -> Decoder e a
1442d1438
< pushChunks r0 =
1443d1438
<   let go r [] =
1444d1438
<         r
1445d1438
<       go (Done i p a) xs =
1446d1438
<         Done (B.concat (i:xs)) p a
1447d1438
<       go (Fail i p s) xs =
1448d1438
<         Fail (B.concat (i:xs)) p s
1449d1438
<       go (Partial k) (x:xs) =
1450c1439
<         go (k (Just x)) xs
---
> pushChunksDecoder e::a
1450a1440
>   Decoder-> L.ByteString a
1450a1441
>   -> L.ByteStringDecoder e a
1450a1442
> pushChunks-> Decoderr0e=a
1450a1443
> pushChunkslet go r r0[] =
1450a1444
>   let gorr [] =
1450a1445
>       gor(Done i p a) xs =
1450a1446
>       goDoneDone(B.concat p a) xs(i=xs)) p a
1450a1447
>       goDone(FailB.concati p s) xsi:xs)) p a
1450a1448
>       goFailFail(B.concat p s) xs(i=xs)) p s
1450a1449
>       goFail(PartialB.concatk) (x(ixs:xs) )) p s
1450a1450
>       gogoPartial(k (Just)x(x:xs) =
1450a1451
>   in go go (kL.toChunksJust x)) xs
1452d1452
< 
1454d1453
<   Decoder e a
1455d1453
<   -> Decoder e a
1456d1453
< pushEndOfInput r =
1457d1453
<   case r of
1458d1453
<     Done {} -> r
1459c1454
<     Partial k -> k Nothing
---
> pushEndOfInputDecoder e a  ::
1459a1455
>   Decoder-> Decoder ae a
1459a1456
> pushEndOfInput-> Decoder e a =
1459a1457
> pushEndOfInputcase r of    r =
1459a1458
>   caseDone of{} -> r
1459a1459
>     DonePartial{} ->k -> k Nothing
1459a1460
>     PartialFail {} k->->r k Nothing
1461d1461
< 
1463d1462
< --
1464d1462
< -- >>> runGet (lazyByteString 5) (BLC.pack "")
1465d1462
< -- RunGetFail 0 ()
1466d1462
< --
1467d1462
< -- >>> runGet (lazyByteString 5) (BLC.pack "abc")
1468d1462
< -- RunGetFail 3 ()
1469d1462
< --
1470d1462
< -- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
1471d1462
< -- RunGet "abcde"
1472d1462
< lazyByteString ::
1473d1462
<   Int64
1474d1462
<   -> Get () L.ByteString
1475d1462
< lazyByteString =
1476d1462
<   let consume n s =
1477d1462
<         if fromIntegral (B.length s) >= n
1478d1462
<           then
1479d1462
<             Right (B.splitAt (fromIntegral n) s)
1480d1462
<           else
1481d1462
<             Left (fromIntegral (B.length s))
1482d1462
<       go n =
1483d1462
<         do s <- get
1484d1462
<            case consume n s of
1485d1462
<              Left u ->
1486d1462
<                do put B.empty
1487d1462
<                   demandInput
1488d1462
<                   fmap (s:) (go (n - u))
1489d1462
<              Right (w, r) ->
1490d1462
<                do put r
1491c1463
<                   return [w]
---
> ---- |
1491a1464
> ---- >>> runGet (lazyByteString 5) (BLC.pack "")
1491a1465
> -- RunGetFail 0 ()-- >>> runGet (lazyByteString 5) (BLC.pack "")
1491a1466
> ---- RunGetFail 0 ()
1491a1467
> ---- >>> runGet (lazyByteString 5) (BLC.pack "abc")
1491a1468
> -- RunGetFail 3 ()-- >>> runGet (lazyByteString 5) (BLC.pack "abc")
1491a1469
> ---- RunGetFail 3 ()
1491a1470
> ---- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
1491a1471
> -- RunGet "abcde"-- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
1491a1472
> lazyByteString-- RunGet "abcde"::
1491a1473
> lazyByteStringInt64        ::
1491a1474
>   Int64-> Get () L.ByteString
1491a1475
> lazyByteString-> Get () L.ByteString=
1491a1476
> lazyByteStringlet consume n=s =
1491a1477
>   let consumeif fromIntegral s =     (B.length s) >= n
1491a1478
>         ifthen (B.length s) >= n
1491a1479
>           thenRight (B.splitAt (fromIntegral n) s)
1491a1480
>           else (B.splitAt (fromIntegral n) s)
1491a1481
>           elseLeft (fromIntegral (B.length s))
1491a1482
>       go n =Left (fromIntegral (B.length s))
1491a1483
>       godo =  <- get
1491a1484
>         do scase<- getconsume n s of
1491a1485
>            caseLeftu ->  n s of
1491a1486
>              Leftdo uputB.empty
1491a1487
>                do putdemandInput
1491a1488
>                   demandInputfmap (s:) (go (n - u))
1491a1489
>              Rightfmap(w, (s:)->(go (n - u))
1491a1490
>              Rightdo putw,rr) ->
1491a1491
>                do putreturn  [w]
1491a1492
>   in fmap L.fromChunks. [gow]
1493d1493
< 
1495d1494
< --
1496d1494
< -- >>> runGet lazyByteStringNul (BLC.pack "")
1497d1494
< -- RunGetFail 0 ()
1498d1494
< --
1499d1494
< -- >>> runGet lazyByteStringNul (BLC.pack "abc")
1500d1494
< -- RunGetFail 3 ()
1501d1494
< --
1502d1494
< -- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
1503d1494
< -- RunGet "abc"
1504d1494
< --
1505d1494
< -- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
1506d1494
< -- RunGet "abc"
1507d1494
< lazyByteStringNul ::
1508d1494
<   Get () L.ByteString
1509d1494
< lazyByteStringNul =
1510d1494
<   let findNull s =
1511d1494
<         case B.break (==0) s of
1512d1494
<           (w, r) ->
1513d1494
<             if B.null r
1514d1494
<               then
1515c1495
<                 Nothing
---
> ---- |
1515a1496
> ---- >>> runGet lazyByteStringNul (BLC.pack "")
1515a1497
> -- RunGetFail 0 ()-- >>> runGet lazyByteStringNul (BLC.pack "")
1515a1498
> ---- RunGetFail 0 ()
1515a1499
> ---- >>> runGet lazyByteStringNul (BLC.pack "abc")
1515a1500
> -- RunGetFail 3 ()-- >>> runGet lazyByteStringNul (BLC.pack "abc")
1515a1501
> ---- RunGetFail 3 ()
1515a1502
> ---- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
1515a1503
> -- RunGet "abc"-- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
1515a1504
> ---- RunGet "abc"
1515a1505
> ---- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
1515a1506
> -- RunGet "abc"-- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
1515a1507
> -- RunGet "abc"lazyByteStringNul ::
1515a1508
> lazyByteStringNulGet () L.ByteString::
1515a1509
> lazyByteStringNul () L.ByteString=
1515a1510
> lazyByteStringNullet findNull s ==
1515a1511
>   let findNullcase B.break =   (==0) s of
1515a1512
>         case(w,B.breakr) ->  (==0) s of
1515a1513
>           (w,ifr)B.null   r
1515a1514
>             ifthen r
1515a1515
>               thenNothing
1517d1516
<                 Just (w, B.drop 1 r)
1518d1516
<       go =
1519d1516
<         do s <- get
1520d1516
<            case findNull s of
1521d1516
<              Nothing ->
1522d1516
<                do put B.empty
1523d1516
<                   demandInput
1524d1516
<                   fmap (s:) go
1525d1516
<              Just (w, r) ->
1526d1516
<                do put r
1527c1517
<                   return [w]
---
>               elseJust (w, B.drop 1 r)
1527a1518
>       go =      Just (w, B.drop 1 r)
1527a1519
>       godo= s <- get
1527a1520
>         do scase<- getfindNull s of
1527a1521
>            caseNothing->  s of
1527a1522
>              Nothingdo put->B.empty
1527a1523
>                do putdemandInput
1527a1524
>                   demandInputfmap (s:) go
1527a1525
>              Just fmap(w, r(s:->) go
1527a1526
>              Justdo (putw, r) ->
1527a1527
>                do putreturn  [w]
1527a1528
>   in fmap L.fromChunksgo[w]
1529d1529
< 
1531d1530
< --
1532d1530
< -- >>> runGet remainingLazyByteString  (BLC.pack "")
1533d1530
< -- RunGet ""
1534d1530
< --
1535d1530
< -- >>> runGet remainingLazyByteString  (BLC.pack "abc")
1536d1530
< -- RunGet "abc"
1537d1530
< remainingLazyByteString ::
1538d1530
<   Get e L.ByteString
1539d1530
< remainingLazyByteString =
1540d1530
<   let go =
1541d1530
<         do s <- get
1542d1530
<            put B.empty
1543d1530
<            d <- isEmpty
1544d1530
<            if d
1545d1530
<              then
1546d1530
<                return [s]
1547d1530
<              else
1548c1531
<                fmap (s:) go
---
> ---- |
1548a1532
> ---- >>> runGet remainingLazyByteString  (BLC.pack "")
1548a1533
> -- RunGet ""-- >>> runGet remainingLazyByteString  (BLC.pack "")
1548a1534
> ---- RunGet ""
1548a1535
> ---- >>> runGet remainingLazyByteString  (BLC.pack "abc")
1548a1536
> -- RunGet "abc"-- >>> runGet remainingLazyByteString  (BLC.pack "abc")
1548a1537
> -- RunGet "abc"remainingLazyByteString ::
1548a1538
> remainingLazyByteStringGet e L.ByteString    ::
1548a1539
> remainingLazyByteString e L.ByteString    =
1548a1540
> remainingLazyByteStringlet go =              =
1548a1541
>   let godo= s <- get
1548a1542
>         do sput<-B.empty
1548a1543
>            putd <-B.emptyisEmpty
1548a1544
>            dif<-d isEmpty
1548a1545
>            ifthen
1548a1546
>              thenreturn [s]
1548a1547
>              else [s]
1548a1548
>              elsefmap (s:) go
1548a1549
>   in fmap L.fromChunks (s:)gogo
1550d1550
< 
1552d1551
<   Storable a =>
1553d1551
<   Int
1554d1551
<   -> Get () a
1555d1551
< ptr n =
1556c1552
<   readNWith n peek
---
> ptrStorable::     a =>
1556a1553
>   StorableInt      a =>
1556a1554
>   Int-> Get () a
1556a1555
> ptr->nGet=  () a
1556a1556
> ptrreadNWith =     n peek
1556a1557
> {-# INLINEptr peek#-}
1558d1558
< 
1560c1560
< 
---
> {-# RULES
1561a1562
> "word8/readN"readN 1 BU.unsafeHead =
1563d1563
< 
1564a1565
> "word16be/readN"readN 2 word16be' =
1566d1566
< 
1567a1568
> "word16le/readN"readN 2 word16le' =
1569d1569
< 
1570a1571
> "word32be/readN"readN 4 word32be' =
1572d1572
< 
1573a1574
> "word32le/readN"readN 4 word32le' =
1575d1575
< 
1576a1577
> "word64be/readN"readN 8 word64be' =
1578d1578
< 
1579a1580
> "word64le/readN"readN 8 word64le' =
1581d1581
< 
1583c1583
< 
---
>   #-}
1586d1585
< -- >>> runGet word8 (BLC.pack "abc")
1587d1585
< -- RunGet 97
1588d1585
< --
1589d1585
< -- >>> runGet word8 (BLC.pack "123")
1590d1585
< -- RunGet 49
1591d1585
< word8 ::
1592d1585
<   Get () Word8
1593c1586
< word8 =
---
> -- |-- >>> runGet word8 (BLC.pack "abc")
1593a1587
> ---- RunGet 97
1593a1588
> ---- >>> runGet word8 (BLC.pack "abc")
1593a1589
> -- RunGet 97-- >>> runGet word8 (BLC.pack "123")
1593a1590
> ---- RunGet 49
1593a1591
> word8-- >>> runGet word8 (BLC.pack "123")::
1593a1592
> -- RunGet 49Get () Word8
1593a1593
> word8 ::=
1593a1594
>   GetreadN)1Word8BU.unsafeHead
1593a1595
> word8{-# INLINE=    [0] word8 #-}
1595d1596
< {-# INLINE [0] word8 #-}
1596d1596
< 
1597c1597
< word16be' ::
---
> {-# INLINEword16be' ::[0] word8 #-}
1599d1598
<   -> Word16
1600d1598
< word16be' s =
1601c1599
<     (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW16` 8) .|.
---
> word16be'-> Word16::
1601a1600
> word16be's =
1601a1601
>   ->(Word16fromIntegral (s `BU.unsafeIndex` 0) `shiftlW16` 8) .|.
1601a1602
> word16be'fromIntegral =    (s `BU.unsafeIndex` 1)
1601a1603
> {-# INLINEfromIntegralword16be's `#-}BU.unsafeIndex` 0) `shiftlW16` 8) .|.
1603d1604
< {-# INLINE word16be' #-}
1604d1604
< 
1605d1604
< -- |
1606d1604
< --
1607d1604
< -- >>> runGet word16be (BLC.pack "abc")
1608c1605
< -- RunGet 24930
---
> {-# INLINE-- |       word16be' #-}
1610d1606
< -- >>> runGet word16be (BLC.pack "123")
1611d1606
< -- RunGet 12594
1612d1606
< word16be ::
1613d1606
<   Get () Word16
1614c1607
< word16be =
---
> -- |-- >>> runGet word16be (BLC.pack "abc")
1614a1608
> ---- RunGet 24930
1614a1609
> ---- >>> runGet word16be (BLC.pack "abc")
1614a1610
> -- RunGet 24930-- >>> runGet word16be (BLC.pack "123")
1614a1611
> ---- RunGet 12594
1614a1612
> word16be-- >>> runGet word16be (BLC.pack "123")::
1614a1613
> -- RunGet 12594Get () Word16
1614a1614
> word16be ::=
1614a1615
>   GetreadN)2Word16word16be'
1614a1616
> word16be{-# INLINE= [0] word16be #-}
1616d1617
< {-# INLINE [0] word16be #-}
1617d1617
< 
1618c1618
< word16le' ::
---
> {-# INLINEword16le' ::[0] word16be #-}
1620d1619
<   -> Word16
1621d1619
< word16le' s =
1622c1620
<     (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW16` 8) .|.
---
> word16le'-> Word16::
1622a1621
> word16le's =
1622a1622
>   ->(Word16fromIntegral (s `BU.unsafeIndex` 1) `shiftlW16` 8) .|.
1622a1623
> word16le'fromIntegral =    (s `BU.unsafeIndex` 0)
1622a1624
> {-# INLINEfromIntegralword16le's `#-}BU.unsafeIndex` 1) `shiftlW16` 8) .|.
1624d1625
< {-# INLINE word16le' #-}
1625d1625
< 
1626d1625
< -- |
1627d1625
< --
1628d1625
< -- >>> runGet word16le (BLC.pack "abc")
1629c1626
< -- RunGet 25185
---
> {-# INLINE-- |       word16le' #-}
1631d1627
< -- >>> runGet word16le (BLC.pack "123")
1632d1627
< -- RunGet 12849
1633d1627
< word16le ::
1634d1627
<   Get () Word16
1635c1628
< word16le =
---
> -- |-- >>> runGet word16le (BLC.pack "abc")
1635a1629
> ---- RunGet 25185
1635a1630
> ---- >>> runGet word16le (BLC.pack "abc")
1635a1631
> -- RunGet 25185-- >>> runGet word16le (BLC.pack "123")
1635a1632
> ---- RunGet 12849
1635a1633
> word16le-- >>> runGet word16le (BLC.pack "123")::
1635a1634
> -- RunGet 12849Get () Word16
1635a1635
> word16le ::=
1635a1636
>   GetreadN)2Word16word16le'
1635a1637
> word16le{-# INLINE= [0] word16le #-}
1637d1638
< {-# INLINE [0] word16le #-}
1638d1638
< 
1639c1639
< word32be' ::
---
> {-# INLINEword32be' ::[0] word16le #-}
1641d1640
<   -> Word32
1642d1640
< word32be' s =
1643d1640
<     (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 24) .|.
1644d1640
<     (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW32` 16) .|.
1645c1641
<     (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW32`  8) .|.
---
> word32be'-> Word32::
1645a1642
> word32be's =
1645a1643
>   ->(Word32fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 24) .|.
1645a1644
> word32be'(fromIntegral =     (s `BU.unsafeIndex` 1) `shiftlW32` 16) .|.
1645a1645
>     (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 248) .|.
1645a1646
>     (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``31) `shiftlW32` 16) .|.
1645a1647
> {-# INLINEfromIntegralword32be's `#-}BU.unsafeIndex` 2) `shiftlW32`  8) .|.
1647d1648
< {-# INLINE word32be' #-}
1648d1648
< 
1649d1648
< -- |
1650d1648
< --
1651d1648
< -- >>> runGet word32be (BLC.pack "abcdef")
1652c1649
< -- RunGet 1633837924
---
> {-# INLINE-- |       word32be' #-}
1654d1650
< -- >>> runGet word32be (BLC.pack "123456")
1655d1650
< -- RunGet 825373492
1656d1650
< word32be ::
1657d1650
<   Get () Word32
1658c1651
< word32be =
---
> -- |-- >>> runGet word32be (BLC.pack "abcdef")
1658a1652
> ---- RunGet 1633837924
1658a1653
> ---- >>> runGet word32be (BLC.pack "abcdef")
1658a1654
> -- RunGet 1633837924-- >>> runGet word32be (BLC.pack "123456")
1658a1655
> ---- RunGet 825373492
1658a1656
> word32be-- >>> runGet word32be (BLC.pack "123456")::
1658a1657
> -- RunGet 825373492Get () Word32
1658a1658
> word32be ::=
1658a1659
>   GetreadN)4Word32word32be'
1658a1660
> word32be{-# INLINE= [0] word32be #-}
1660d1661
< {-# INLINE [0] word32be #-}
1661d1661
< 
1662c1662
< word32le' ::
---
> {-# INLINEword32le' ::[0] word32be #-}
1664d1663
<   -> Word32
1665d1663
< word32le' s =
1666d1663
<     (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 24) .|.
1667d1663
<     (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW32` 16) .|.
1668c1664
<     (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW32`  8) .|.
---
> word32le'-> Word32::
1668a1665
> word32le's =
1668a1666
>   ->(Word32fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 24) .|.
1668a1667
> word32le'(fromIntegral =     (s `BU.unsafeIndex` 2) `shiftlW32` 16) .|.
1668a1668
>     (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 248) .|.
1668a1669
>     (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``02) `shiftlW32` 16) .|.
1668a1670
> {-# INLINEfromIntegralword32le's `#-}BU.unsafeIndex` 1) `shiftlW32`  8) .|.
1670d1671
< {-# INLINE word32le' #-}
1671d1671
< 
1672d1671
< -- |
1673d1671
< --
1674d1671
< -- -- >>> runGet word32le (BLC.pack "abcdef")
1675c1672
< -- RunGet 1684234849
---
> {-# INLINE-- |       word32le' #-}
1677d1673
< -- >>> runGet word32le (BLC.pack "123456")
1678d1673
< -- RunGet 875770417
1679d1673
< word32le ::
1680d1673
<   Get () Word32
1681c1674
< word32le =
---
> -- |-- -- >>> runGet word32le (BLC.pack "abcdef")
1681a1675
> ---- RunGet 1684234849
1681a1676
> ---- -- >>> runGet word32le (BLC.pack "abcdef")
1681a1677
> -- RunGet 1684234849-- >>> runGet word32le (BLC.pack "123456")
1681a1678
> ---- RunGet 875770417
1681a1679
> word32le-- >>> runGet word32le (BLC.pack "123456")::
1681a1680
> -- RunGet 875770417Get () Word32
1681a1681
> word32le ::=
1681a1682
>   GetreadN)4Word32word32le'
1681a1683
> word32le{-# INLINE= [0] word32le #-}
1683d1684
< {-# INLINE [0] word32le #-}
1684d1684
< 
1685c1685
< word64be' ::
---
> {-# INLINEword64be' ::[0] word32le #-}
1687d1686
<   -> Word64
1688c1687
< word64be' s =
---
> word64be'-> Word64::
1688a1688
> word64be's =
1688a1689
>   ->(Word64fromIntegral (s `BU.unsafeIndex` 0) `shiftlW64` 56) .|.
1688a1690
> word64be'(fromIntegral =     (s `BU.unsafeIndex` 1) `shiftlW64` 48) .|.
1693d1694
<     (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 24) .|.
1694d1694
<     (fromIntegral (s `BU.unsafeIndex` 5) `shiftlW64` 16) .|.
1695c1695
<     (fromIntegral (s `BU.unsafeIndex` 6) `shiftlW64`  8) .|.
---
>     (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 248) .|.
1695a1696
>     (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``75) `shiftlW64` 16) .|.
1695a1697
> {-# INLINEfromIntegralword64be's `#-}BU.unsafeIndex` 6) `shiftlW64`  8) .|.
1697d1698
< {-# INLINE word64be' #-}
1698d1698
< 
1699d1698
< -- |
1700d1698
< --
1701d1698
< -- >>> runGet word64be (BLC.pack "abcdefghi")
1702c1699
< -- RunGet 7017280452245743464
---
> {-# INLINE-- |       word64be' #-}
1704d1700
< -- >>> runGet word64be (BLC.pack "123456789")
1705d1700
< -- RunGet 3544952156018063160
1706d1700
< word64be ::
1707d1700
<   Get () Word64
1708c1701
< word64be =
---
> -- |-- >>> runGet word64be (BLC.pack "abcdefghi")
1708a1702
> ---- RunGet 7017280452245743464
1708a1703
> ---- >>> runGet word64be (BLC.pack "abcdefghi")
1708a1704
> -- RunGet 7017280452245743464-- >>> runGet word64be (BLC.pack "123456789")
1708a1705
> ---- RunGet 3544952156018063160
1708a1706
> word64be-- >>> runGet word64be (BLC.pack "123456789")::
1708a1707
> -- RunGet 3544952156018063160Get () Word64
1708a1708
> word64be ::=
1708a1709
>   GetreadN)8Word64word64be'
1708a1710
> word64be{-# INLINE= [0] word64be #-}
1710d1711
< {-# INLINE [0] word64be #-}
1711d1711
< 
1712c1712
< word64le' ::
---
> {-# INLINEword64le' ::[0] word64be #-}
1714d1713
<   -> Word64
1715c1714
< word64le' s =
---
> word64le'-> Word64::
1715a1715
> word64le's =
1715a1716
>   ->(Word64fromIntegral (s `BU.unsafeIndex` 7) `shiftlW64` 56) .|.
1715a1717
> word64le'(fromIntegral =     (s `BU.unsafeIndex` 6) `shiftlW64` 48) .|.
1720d1721
<     (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 24) .|.
1721d1721
<     (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW64` 16) .|.
1722c1722
<     (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW64`  8) .|.
---
>     (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 248) .|.
1722a1723
>     (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``02) `shiftlW64` 16) .|.
1722a1724
> {-# INLINEfromIntegralword64le's `#-}BU.unsafeIndex` 1) `shiftlW64`  8) .|.
1724d1725
< {-# INLINE word64le' #-}
1725d1725
< 
1726d1725
< -- |
1727d1725
< --
1728d1725
< -- >>> runGet word64le (BLC.pack "abcdefghi")
1729c1726
< -- RunGet 7523094288207667809
---
> {-# INLINE-- |       word64le' #-}
1731d1727
< -- >>> runGet word64le (BLC.pack "123456789")
1732d1727
< -- RunGet 4050765991979987505
1733d1727
< word64le ::
1734d1727
<   Get () Word64
1735c1728
< word64le =
---
> -- |-- >>> runGet word64le (BLC.pack "abcdefghi")
1735a1729
> ---- RunGet 7523094288207667809
1735a1730
> ---- >>> runGet word64le (BLC.pack "abcdefghi")
1735a1731
> -- RunGet 7523094288207667809-- >>> runGet word64le (BLC.pack "123456789")
1735a1732
> ---- RunGet 4050765991979987505
1735a1733
> word64le-- >>> runGet word64le (BLC.pack "123456789")::
1735a1734
> -- RunGet 4050765991979987505Get () Word64
1735a1735
> word64le ::=
1735a1736
>   GetreadN)8Word64word64le'
1735a1737
> word64le{-# INLINE= [0] word64le #-}
1737d1738
< {-# INLINE [0] word64le #-}
1738d1738
< 
1739d1738
< -- |
1740d1738
< --
1741d1738
< -- >>> runGet wordhost (BLC.pack "abcdefghi")
1742c1739
< -- RunGet 7523094288207667809
---
> {-# INLINE-- |       [0] word64le #-}
1744d1740
< -- >>> runGet wordhost (BLC.pack "123456789")
1745d1740
< -- RunGet 4050765991979987505
1746d1740
< wordhost ::
1747d1740
<   Get () Word
1748c1741
< wordhost =
---
> -- |-- >>> runGet wordhost (BLC.pack "abcdefghi")
1748a1742
> ---- RunGet 7523094288207667809
1748a1743
> ---- >>> runGet wordhost (BLC.pack "abcdefghi")
1748a1744
> -- RunGet 7523094288207667809-- >>> runGet wordhost (BLC.pack "123456789")
1748a1745
> ---- RunGet 4050765991979987505
1748a1746
> wordhost-- >>> runGet wordhost (BLC.pack "123456789")::
1748a1747
> -- RunGet 4050765991979987505Get () Word
1748a1748
> wordhost ::=
1748a1749
>   Get ()sizeOf (undefined :: Word))
1748a1750
> wordhost{-# INLINE= wordhost #-}
1750d1751
< {-# INLINE wordhost #-}
1751d1751
< 
1752d1751
< -- |
1753d1751
< --
1754d1751
< -- >>> runGet word16host (BLC.pack "abcde")
1755c1752
< -- RunGet 25185
---
> {-# INLINE-- |       wordhost #-}
1757d1753
< -- >>> runGet word16host (BLC.pack "12345")
1758d1753
< -- RunGet 12849
1759d1753
< word16host ::
1760d1753
<   Get () Word16
1761c1754
< word16host =
---
> -- |-- >>> runGet word16host (BLC.pack "abcde")
1761a1755
> ---- RunGet 25185
1761a1756
> ---- >>> runGet word16host (BLC.pack "abcde")
1761a1757
> -- RunGet 25185-- >>> runGet word16host (BLC.pack "12345")
1761a1758
> ---- RunGet 12849
1761a1759
> word16host-- >>> runGet word16host (BLC.pack "12345")::
1761a1760
> -- RunGet 12849Get () Word16
1761a1761
> word16host ::=
1761a1762
>   Get ()sizeOf(undefined :: Word16))
1761a1763
> word16host =word16host #-}
1763d1764
< {-# INLINE word16host #-}
1764d1764
< 
1765d1764
< -- |
1766d1764
< --
1767d1764
< -- >>> runGet word32host (BLC.pack "abcde")
1768c1765
< -- RunGet 1684234849
---
> {-# INLINE-- |       word16host #-}
1770d1766
< -- >>> runGet word32host (BLC.pack "12345")
1771d1766
< -- RunGet 875770417
1772d1766
< word32host ::
1773d1766
<   Get () Word32
1774c1767
< word32host =
---
> -- |-- >>> runGet word32host (BLC.pack "abcde")
1774a1768
> ---- RunGet 1684234849
1774a1769
> ---- >>> runGet word32host (BLC.pack "abcde")
1774a1770
> -- RunGet 1684234849-- >>> runGet word32host (BLC.pack "12345")
1774a1771
> ---- RunGet 875770417
1774a1772
> word32host-- >>> runGet word32host (BLC.pack "12345")::
1774a1773
> -- RunGet 875770417Get () Word32
1774a1774
> word32host ::=
1774a1775
>   Get ()sizeOf(undefined :: Word32))
1774a1776
> word32host =word32host #-}
1776d1777
< {-# INLINE word32host #-}
1777d1777
< 
1778d1777
< -- |
1779d1777
< --
1780d1777
< -- >>> runGet word64host (BLC.pack "abcdeghi")
1781c1778
< -- RunGet 7595434456733934177
---
> {-# INLINE-- |       word32host #-}
1783d1779
< -- >>> runGet word64host (BLC.pack "123456789")
1784d1779
< -- RunGet 4050765991979987505
1785d1779
< word64host ::
1786d1779
<   Get () Word64
1787c1780
< word64host =
---
> -- |-- >>> runGet word64host (BLC.pack "abcdeghi")
1787a1781
> ---- RunGet 7595434456733934177
1787a1782
> ---- >>> runGet word64host (BLC.pack "abcdeghi")
1787a1783
> -- RunGet 7595434456733934177-- >>> runGet word64host (BLC.pack "123456789")
1787a1784
> ---- RunGet 4050765991979987505
1787a1785
> word64host-- >>> runGet word64host (BLC.pack "123456789")::
1787a1786
> -- RunGet 4050765991979987505Get () Word64
1787a1787
> word64host ::=
1787a1788
>   Get ()sizeOf(undefined :: Word64))
1787a1789
> word64host =word64host #-}
1789d1790
< {-# INLINE word64host #-}
1790d1790
< 
1791c1791
< ------------------------------------------------------------------------
---
> {-# INLINE------------------------------------------------------------------------ #-}
1793d1792
< 
1794c1793
< shiftlW16 ::
---
> ------------------------------------------------------------------------
1794a1794
> shiftlW16-- Unchecked shifts::
1796d1795
<   -> Int
1797d1795
<   -> Word16
1798d1795
< shiftlW32 ::
1799d1795
<   Word32
1800d1795
<   -> Int
1801d1795
<   -> Word32
1802d1795
< shiftlW64 ::
1803c1796
<   Word64
---
> shiftlW16-> Int  ::
1803a1797
>   Word16-> Word16
1803a1798
> shiftlW32-> Int  ::
1803a1799
>   ->Word32
1803a1800
> shiftlW32-> Int  ::
1803a1801
>   Word32-> Word32
1803a1802
> shiftlW64-> Int  ::
1803a1803
>   ->Word64
1803a1804
> shiftlW64-> Int  ::
1803a1805
>   Word64-> Word64
1805d1806
<   -> Word64
1806d1806
< 
1807c1807
< #if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
---
> #if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)-> Word64
1809a1810
> shiftlW16 (W16# w) (I# i) =
1809a1811
>   W16# (w `uncheckedShiftL#`   i)
1811d1812
<   W32# (w `uncheckedShiftL#`   i)
1812d1812
< 
1813c1813
< #if WORD_SIZE_IN_BITS < 64
---
> #if WORD_SIZE_IN_BITS < 64 (w `uncheckedShiftL#`   i)
2063a2064
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE Trustworthy #-}

#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
#include "MachDeps.h"
#endif

module Data.Tickle.Get(
  -- * Get data type
  Get
  -- ** Primitive parsers
, lazyByteString
, lazyByteStringNul
, remainingLazyByteString
, ptr
, word8
, word16be
, word16le
, word32be
, word32le
, word64be
, word64le
, wordhost
, word16host
, word32host
, word64host
, failGet
, constant
, bytesRead
, demandInput
, skip
, isNotEmpty
, isEmpty
, getByteString
, modify
, readN
, ensureN
  -- ** Higher-level parsers
  -- *** IEEE754 parsers
, toFloat
, toFloat16
, float16be
, float16le
, float32be
, float32le
, float64be
, float64le
  -- *** Integer parsers
, int8
, int16be
, int16le
, int32be
, int32le
, int64be
, int64le
, IntegerError
, integerError
, _IntegerTagUnexpectedEof
, _Integer0TagUnexpectedEof
, _Integer1TagUnexpectedEof
, _IntegerListError
, integer
  -- *** List parsers
, ListError
, listError
, listErrorIso
, list
, many
  -- ** Higher-level combinators
, runAndKeepTrack
, pushBack
, pushFront
, xrunGetIncremental
, noMeansNo
, prompt
, isolate
, lookAhead
, lookAheadM
, lookAheadE
, readNWith
, calculateOffset
, pushChunk
, pushChunks
, pushEndOfInput
  -- ** Error label
, (!+)
, addLabel
, (!-)
, setLabel
, (!!-)
, modifyLabel
  -- * Decoder
, Decoder
, decoder
, _Fail
, _Partial
, _Done
  -- ** Run Get parser
, runGet
, (.>>)
, (<<.)
, runGetIncremental
  -- * XDecoder data type
, XDecoder
  -- ** Reduction
, xdecoder
  -- ** Prisms
, _XFail
, _XPartial
, _XDone
, _XBytesRead
  -- * CompletedXDecoder data type
, CompletedXDecoder
  -- ** Reduction
, completedXDecoder
  -- ** Prism
, _CompletedFail
, _CompletedDone
  -- ** Isomorphism
, completedIso
  -- ** Lens
, completedByteString
, completedValue
  -- ** Prism
, uncomplete
  -- ** Traversal
, uncompletedByteString
, uncompletedValue
) where

import Control.Applicative(Applicative((<*>), pure), (<$>))
import Control.Category(Category((.), id))
import Control.Lens.Iso(Iso', iso)
import Control.Lens.Lens(lens)
import Control.Lens.Prism(Prism', prism')
import Control.Lens.Review((#))
import Control.Lens.Type(Iso, Lens', Traversal')
import Control.Monad(Monad((>>=), (>>), return), ap)
import Data.Bifoldable(Bifoldable(bifoldMap))
import Data.Bifunctor(Bifunctor(bimap))
import Data.Bitraversable(Bitraversable(bitraverse))
import Data.Bits((.|.), (.&.), shiftL, shiftR)
import Data.Bool(Bool(False, True), (&&), not, otherwise)
import qualified Data.ByteString as B(ByteString, concat, append, length, splitAt, empty, null, break, drop)
import qualified Data.ByteString.Internal as BI
import qualified Data.ByteString.Lazy as L(ByteString, toChunks, fromChunks)
import qualified Data.ByteString.Lazy.Internal as LI(ByteString(Chunk, Empty))
import qualified Data.ByteString.Unsafe as BU(unsafeDrop, unsafeTake, unsafeHead, unsafeIndex, unsafeUseAsCString)
import Data.Either(Either(Left, Right), either)
import Data.Eq(Eq((==)))
import Data.Foldable(Foldable(foldMap))
import Data.Function(const)
import Data.Functor(Functor(fmap))
import Data.Functor.Apply(Apply((<.>)))
import Data.Functor.Alt(Alt((<!>)))
import qualified Data.Functor.Alt as Al(Alt(some, many))
import Data.Functor.Bind(Bind((>>-)))
import Data.Int(Int, Int8, Int16, Int32, Int64)
import Data.List(reverse, foldr)
import Data.Maybe(Maybe(Nothing, Just), maybe, isJust)
import Data.Monoid(Monoid(mempty))
import Data.Ord(Ord((>), (>=), (<), (>=)))
import Data.Semigroup(Semigroup((<>)))
import Data.Tickle.IsolateError(IsolateError, _NegativeSize, _IsolateXFail, _UnexpectedConsumed)
import Data.Tickle.RunGetResult(RunGetResult, _RunGet, _RunGetFail)
import Data.Traversable(Traversable(traverse))
import Data.Tuple(uncurry)
import Foreign(Ptr, castPtr, Storable(peek), sizeOf, alloca, poke)
import System.IO.Unsafe(unsafePerformIO)
#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
import GHC.Word(Word, Word8, Word16(W16#), Word32(W32#), Word64(W64#))
import GHC.Base(uncheckedShiftL#, Int(I#))
#endif
import Prelude(Num((-), (+)), Float, Double, Integer, ($!), Show, fromIntegral, undefined, seq)
import System.IO(IO)

-- $setup
-- >>> import Control.Lens.Fold((^?))
-- >>> import Control.Lens.Prism(_Right, _Left)
-- >>> import qualified Data.ByteString.Lazy.Char8 as BLC(pack)
-- >>> import qualified Data.ByteString.Char8 as BC(ByteString, pack)
-- >>> import Data.String(String)
-- >>> import Data.List((++))
-- >>> import Data.Maybe(fromMaybe, isNothing)
-- >>> import Data.Validation(_Success, _Failure)
-- >>> import Prelude(Num((*)), subtract, even, mod)

newtype Get e a =
  Get (forall r.
    B.ByteString ->
    (B.ByteString -> a -> XDecoder e r) ->
    XDecoder e r)

bimapG ::
  (e -> f)
  -> (a -> b)
  -> Get e a
  -> Get f b
bimapG f g (Get z) =
  Get (\b q ->
    let r = z b XDone
        go (XDone i a) = q i (g a)
        go (XPartial k) = XPartial (go . k)
        go (XFail i s) = XFail i (f s)
        go (XBytesRead u k) = XBytesRead u (go . k)
    in go r)
{-# INLINE bimapG #-}

-- | Map on the error and result of a @Get@ decoder.
--
-- >>> runGet (bimap (const True) (\x -> x + x) word8) (BLC.pack "")
-- RunGetFail 0 True
--
-- >>> runGet (bimap (const True) (\x -> x + x) word8) (BLC.pack "abc")
-- RunGet 194
instance Bifunctor Get where
  bimap =
    bimapG

fmapG ::
  (a -> b)
  -> Get e a
  -> Get e b
fmapG =
  bimapG id
{-# INLINE fmapG #-}

-- | Map on the result of a @Get@ decoder.
--
-- >>> runGet (fmap (\x -> x + x) word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (\x -> x + x) word8) (BLC.pack "abc")
-- RunGet 194
instance Functor (Get e) where
  fmap =
    fmapG

-- | Apply a function on the @Get@ decoder result.
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "abc")
-- RunGet 195
instance Apply (Get e) where
  (<.>) =
    ap

apG ::
  Get e (a -> b)
  -> Get e a
  -> Get e b
apG d e =
  do b <- d
     a <- e
     return (b a)
{-# INLINE [0] apG #-}

-- | Apply a function on the @Get@ decoder result.
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "abc")
-- RunGet 195
--
-- >>> runGet (pure 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (pure x :: Get () Int) (BLC.pack "abc") == _RunGet # x
instance Applicative (Get e) where
  pure =
    return
  {-# INLINE pure #-}
  (<*>) =
    apG
  {-# INLINE (<*>) #-}

-- | Sequence an action through the @Get@ decoder.
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "abc")
-- RunGet 195
instance Bind (Get e) where
  (>>-) =
    (>>=)

returnG ::
  a
  -> Get e a
returnG a =
    Get (\b q -> q b a)
{-# INLINE [0] returnG #-}

bindG ::
  Get e a
  -> (a -> Get e b)
  -> Get e b
Get k `bindG` f =
  Get (\b q -> k b (\c a ->
    let Get l = f a
    in l c q))
{-# INLINE bindG #-}

-- | Sequence an action through the @Get@ decoder.
--
-- >>> runGet (return 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (return x :: Get () Int) (BLC.pack "abc") == _RunGet # x
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "abc")
-- RunGet 195
instance Monad (Get e) where
  return =
    returnG
  (>>=) =
    bindG

-- | Pick between two @Get@ decoders, finding the first to not fail.
--
-- >>> runGet ((+1) <$> word8 <!> subtract 1 <$> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet ((+1) <$> word8 <!> subtract 1 <$> word8) (BLC.pack "abc")
-- RunGet 98
--
-- >>> runGet (word8 <!> failGet ()) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 <!> failGet ()) (BLC.pack "abc")
-- RunGet 97
--
-- >>> runGet (Al.some word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (Al.some word8) (BLC.pack "a")
-- RunGet [97]
--
-- >>> runGet (Al.some word8) (BLC.pack "abc")
-- RunGet [97,98,99]
--
-- >>> runGet (Al.many word8) (BLC.pack "")
-- RunGet []
--
-- >>> runGet (Al.many word8) (BLC.pack "a")
-- RunGet [97]
--
-- >>> runGet (Al.many word8) (BLC.pack "abc")
-- RunGet [97,98,99]
instance Alt (Get e) where
  f <!> g =
    do (d, bs) <- runAndKeepTrack f
       case d of
         CompletedDone b a -> Get (\_ q -> q b a)
         CompletedFail _ _ -> pushBack bs >> g
  some p =
    (:) <$> p <*> Al.many p
  many p =
    (p >>= \x ->
     fmap (x:) (Al.many p)) <!> pure []

-- | Pick between two @Get@ decoders, finding the first to not fail.
--
-- >>> runGet (((+1) <$> word8) <> (subtract 1 <$> word8)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (((+1) <$> word8) <> (subtract 1 <$> word8)) (BLC.pack "abc")
-- RunGet 98
--
-- >>> runGet (word8 <> failGet ()) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 <> failGet ()) (BLC.pack "abc")
-- RunGet 97
instance Semigroup (Get e a) where
  (<>) =
    (<!>)

-- | A @Get@ decoder that always fails with the given value.
--
-- prop> runGet (failGet x :: Get Int ()) (BLC.pack s) == _RunGetFail # (0, x)
--
-- >>> runGet (failGet "abc" :: Get String ()) (BLC.pack "def")
-- RunGetFail 0 "abc"
failGet ::
  e
  -> Get e a
failGet e =
  Get (\i _ -> XFail i e)

constant ::
  (forall r. XDecoder e r)
  -> Get e a
constant d =
  Get (\_ _ -> d)

-- | Run a @Get@ decoder, but keep a track of the input that ran it to completion.
--
-- >>> runGet (runAndKeepTrack word8 :: Get () (CompletedXDecoder () Word8, [BC.ByteString])) (BLC.pack "")
-- RunGet (CompletedFail "" (),[])
--
-- >>> runGet (runAndKeepTrack word8 :: Get () (CompletedXDecoder () Word8, [BC.ByteString])) (BLC.pack "abc")
-- RunGet (CompletedDone "bc" 97,["abc"])
runAndKeepTrack ::
  Get e a
  -> Get x (CompletedXDecoder e a, [B.ByteString])
runAndKeepTrack (Get k) =
  Get (\b q ->
    let go !acc w = case w of
                      XDone c a -> q b (CompletedDone c a, reverse acc)
                      XPartial l -> XPartial (\c -> go (maybe acc (:acc) c) (l c))
                      XFail c e -> q b (CompletedFail c e, reverse acc)
                      XBytesRead i l -> XBytesRead i (go acc . l)
    in go [] (k b XDone))
{-# INLINE runAndKeepTrack #-}

-- |
--
-- >>> runGet (pushBack [] :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushBack [] :: Get () ()) (BLC.pack "abc")
-- RunGet ()
--
-- >>> runGet (pushBack [BC.pack "def"] :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushBack [BC.pack "def"] :: Get () ()) (BLC.pack "abc")
-- RunGet ()
pushBack ::
  [B.ByteString]
  -> Get e ()
pushBack z =
  let y [] = id
      y _ = B.concat . (:z)
  in Get (\b q -> q (y z b) ())
{-# INLINE pushBack #-}

-- |
--
-- >>> runGet (pushFront (BC.pack "def") :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushFront (BC.pack "def") :: Get () ()) (BLC.pack "abc")
-- RunGet ()
pushFront ::
  B.ByteString
  -> Get e ()
pushFront b =
  Get (\c q -> q (B.append b c) ())
{-# INLINE pushFront #-}

xrunGetIncremental ::
  Get e a
  -> XDecoder e a
xrunGetIncremental (Get k) =
  noMeansNo (k B.empty XDone)

noMeansNo ::
  XDecoder e a
  -> XDecoder e a
noMeansNo =
  let neverAgain (XPartial k) =
        neverAgain (k Nothing)
      neverAgain (XBytesRead i k) =
        XBytesRead i (neverAgain . k)
      neverAgain r@(XDone _ _) =
        r
      neverAgain r@(XFail _ _) =
        r
      go (XPartial k) =
        XPartial (\b ->
          (if isJust b then go else neverAgain) (k b))
      go (XBytesRead i k) =
        XBytesRead i (go . k)
      go r@(XDone _ _) =
        r
      go r@(XFail _ _) =
        r
  in go

prompt ::
  B.ByteString
  -> XDecoder e a
  -> (B.ByteString -> XDecoder e a)
  -> XDecoder e a
prompt b d f =
  let loop = XPartial (maybe d (\s -> if B.null s then loop else f (b `B.append` s)))
  in loop

-- |
--
-- >>> runGet (bytesRead :: Get () Int64) (BLC.pack "")
-- RunGet 0
--
-- >>> runGet (bytesRead :: Get () Int64) (BLC.pack "abc")
-- RunGet 0
--
-- >>> runGet (word8 >> word16be >> word32le >> bytesRead) (BLC.pack "abcdefghijk")
-- RunGet 7
bytesRead ::
  Get e Int64
bytesRead =
  Get (\b q -> XBytesRead (fromIntegral (B.length b)) (q b))

-- |
--
-- >>> runGet (isolate 1 word8) (BLC.pack "ab")
-- RunGet 97
--
-- >>> runGet (isolate 1 word8) (BLC.pack "abcde")
-- RunGet 97
--
-- >>> runGet (isolate 2 word16le) (BLC.pack "abcde")
-- RunGet 25185
--
-- >>> runGet (isolate 1 word16le) (BLC.pack "abcde")
-- RunGetFail 0 (IsolateXFail ())
--
-- >>> runGet (isolate (-3) word16le) (BLC.pack "abcde")
-- RunGetFail 0 NegativeSize
--
-- >>> runGet (isolate 3 word16le) (BLC.pack "abcde")
-- RunGetFail 2 (UnexpectedConsumed 2 3)
isolate ::
  Int
  -> Get e a
  -> Get (IsolateError e) a
isolate m (Get k) =
  let go !n (XDone l x) =
        if n == 0 && B.null l
          then
            return x
          else
            do pushFront l
               failGet (_UnexpectedConsumed # (m - n - B.length l, m))
      go 0 (XPartial r) =
        go 0 (r Nothing)
      go n (XPartial r) =
        do i <- Get (\b q -> let takeLimited t =
                                   let (j, o) = B.splitAt n t
                                   in q o (Just j)
                             in if B.null b
                                  then
                                    prompt b (q B.empty Nothing) takeLimited
                                  else
                                    takeLimited b)
           case i of
             Nothing ->
               go n (r Nothing)
             Just u ->
               go (n - B.length u) (r (Just u))
      go _ (XFail b e) =
        pushFront b >> failGet (_IsolateXFail # e)
      go n (XBytesRead i r) =
        go n (r $! fromIntegral m - fromIntegral n - i)
  in if m < 0
       then
         failGet (_NegativeSize # ())
       else
         go m (k B.empty XDone)

-- |
--
-- >>> runGet demandInput (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet demandInput (BLC.pack "a")
-- RunGet ()
--
-- >>> runGet demandInput (BLC.pack "abc")
-- RunGet ()
demandInput ::
  Get () ()
demandInput =
  Get (\b q ->
    prompt b (XFail b ()) (`q` ()))

-- |
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "abcdefghi")
-- RunGet (97,100)
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "abc")
-- RunGetFail 3 ()
skip ::
  Int
  -> Get () ()
skip n =
  readN n (return ())
{-# INLINE skip #-}

-- |
--
-- >>> runGet isNotEmpty (BLC.pack "")
-- RunGet False
--
-- >>> runGet isNotEmpty (BLC.pack "abc")
-- RunGet True
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "abc")
-- RunGet (97,True)
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "a")
-- RunGet (97,True)
isNotEmpty ::
  Get e Bool
isNotEmpty =
  fmap not isEmpty

-- |
--
-- >>> runGet isEmpty (BLC.pack "")
-- RunGet True
--
-- >>> runGet isEmpty (BLC.pack "abc")
-- RunGet False
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "abc")
-- RunGet (97,False)
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "a")
-- RunGet (97,False)
isEmpty ::
  Get e Bool
isEmpty =
  Get (\b q ->
    if B.null b
      then
        prompt b (q b True) (`q` False)
      else
        q b False)

-- |
--
-- >>> runGet (lookAhead word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (lookAhead word8) (BLC.pack "abc")
-- RunGet 97
--
-- >>> runGet (lookAhead word8) (BLC.pack "a")
-- RunGet 97
lookAhead ::
  Get e a
  -> Get e a
lookAhead g =
  do (d, bs) <- runAndKeepTrack g
     case d of
       CompletedDone _ a ->
         pushBack bs >> return a
       CompletedFail inp s ->
         constant (XFail inp s)

-- |
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "abc")
-- RunGet Nothing
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "bc")
-- RunGet (Just 103)
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "")
-- RunGetFail 0 ()
lookAheadM ::
  Get e (Maybe a)
  -> Get e (Maybe a)
lookAheadM g =
  let g' = fmap (maybe (Left ()) Right) g
  in fmap (either (return Nothing) Just) (lookAheadE g')

-- |
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "abc")
-- RunGet (Right 93)
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "bc")
-- RunGet (Left 103)
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "")
-- RunGetFail 0 ()
lookAheadE ::
  Get e (Either a b)
  -> Get e (Either a b)
lookAheadE g =
  do (d, b) <- runAndKeepTrack g
     case d of
       CompletedDone _ (Left x) ->
         pushBack b >> return (Left x)
       CompletedDone i (Right x) ->
         Get (\_ q -> q i (Right x))
       CompletedFail i s ->
         constant (XFail i s)

-- |
--
-- >>> runGet ([(), ()] !+ (setLabel [] word8)) (BLC.pack "")
-- RunGetFail 0 [(),()]
--
-- >>> runGet ([(), ()] !+ (setLabel [] word8)) (BLC.pack "abc")
-- RunGet 97
(!+) ::
  Semigroup e =>
  e
  -> Get e a
  -> Get e a
(!+) =
  addLabel

infixl 3 !+

-- |
--
-- >>> runGet ([(), ()] `addLabel` (setLabel [] word8)) (BLC.pack "")
-- RunGetFail 0 [(),()]
--
-- >>> runGet ([(), ()] `addLabel` (setLabel [] word8)) (BLC.pack "abc")
-- RunGet 97
addLabel ::
  Semigroup e =>
  e
  -> Get e a
  -> Get e a
addLabel m =
  modifyLabel (<> m)

-- |
--
-- >>> runGet ("error" !- word8) (BLC.pack "")
-- RunGetFail 0 "error"
--
-- >>> runGet ("error" !- word8) (BLC.pack "abc")
-- RunGet 97
(!-) ::
  e
  -> Get d a
  -> Get e a
(!-) =
  setLabel

infixl 3 !-

-- |
--
-- >>> runGet ("error" `setLabel` word8) (BLC.pack "")
-- RunGetFail 0 "error"
--
-- >>> runGet ("error" `setLabel` word8) (BLC.pack "abc")
-- RunGet 97
setLabel ::
  e
  -> Get d a
  -> Get e a
setLabel =
  modifyLabel . return

-- |
--
-- >>> runGet (reverse !!- setLabel "error" word8) (BLC.pack "")
-- RunGetFail 0 "rorre"
--
-- >>> runGet (reverse !!- setLabel "error" word8) (BLC.pack "abc")
-- RunGet 97
(!!-) ::
  (d -> e)
  -> Get d a
  -> Get e a
(!!-) =
  modifyLabel

infixl 3 !!-

-- |
--
-- >>> runGet (reverse `modifyLabel` setLabel "error" word8) (BLC.pack "")
-- RunGetFail 0 "rorre"
--
-- >>> runGet (reverse `modifyLabel` setLabel "error" word8) (BLC.pack "abc")
-- RunGet 97
modifyLabel ::
  (d -> e)
  -> Get d a
  -> Get e a
modifyLabel m =
  bimap m id

-- |
--
-- >>> runGet (getByteString (-3)) (BLC.pack "")
-- RunGet ""
--
-- >>> runGet (getByteString 3) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (getByteString 3) (BLC.pack "abc")
-- RunGet "abc"
--
-- >>> runGet (getByteString 3) (BLC.pack "abcdef")
-- RunGet "abc"
getByteString ::
  Int
  -> Get () B.ByteString
getByteString n =
  if n > 0
    then
      readN n (BU.unsafeTake n)
    else
      return B.empty
{-# INLINE getByteString #-}

modify ::
  (B.ByteString -> B.ByteString)
  -> Get e ()
modify f =
  Get (\b q -> q (f b) ())

get ::
  Get e B.ByteString
get =
  Get (\b q -> q b b)

put ::
  B.ByteString -> Get e ()
put s =
  Get (\_ q -> q s ())

-- |
--
-- >>> runGet (readN 3 id) (BLC.pack "abc")
-- RunGet "abc"
--
-- >>> runGet (readN 3 id) (BLC.pack "ab")
-- RunGetFail 0 ()
--
-- >>> runGet (readN 3 id) (BLC.pack "abcdef")
-- RunGet "abcdef"
--
-- >>> runGet (readN (-3) id) (BLC.pack "abcdef")
-- RunGet ""
readN ::
  Int
  -> (B.ByteString -> a)
  -> Get () a
readN !n f =
  ensureN n >> unsafeReadN n f
{-# INLINE [0] readN #-}

{-# RULES

"readN/readN merge" forall n m f g.
  readN n f `apG` readN m g =
    readN (n+m) (\bs -> f bs (g (BU.unsafeDrop n bs)))

"returnG/readN swap" [~1] forall f.
  returnG f =
    readN 0 (const f)

"readN 0/returnG swapback" [1] forall f.
  readN 0 f =
    returnG (f B.empty)

  #-}

-- |
--
-- >>> runGet (ensureN 3) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (ensureN 3) (BLC.pack "abc")
-- RunGet ()
--
-- >>> runGet (ensureN 3) (BLC.pack "abcdef")
-- RunGet ()
ensureN ::
  Int
  -> Get () ()
ensureN !m =
  Get (\i k ->
    let go n =
          Get (\b q -> if B.length b >= n
                         then
                           q b ()
                         else
                           let Get g = demandInput >> go n
                           in g b q)
    in if B.length i >= m
         then
           k i ()
         else
           let Get g = go m
           in g i k)
{-# INLINE ensureN #-}

toFloat ::
  (Storable w, Storable f) =>
  w
  -> f
toFloat w =
  unsafePerformIO (alloca (\buf ->
    do poke (castPtr buf) w
       peek buf))
{-# INLINE toFloat #-}

toFloat16 ::
  Word16
  -> Float
toFloat16 word16 =
  let sign16 =
        word16 .&. 0x8000
      exp16 =
        word16 .&. 0x7C00
      frac16 =
        word16 .&. 0x3FF
      sign32 =
        if sign16 > 0
          then
            0x80000000 -- -0.0

          else
            0
      word32
        :: Word32
      word32 | word16 .&. 0x7FFF == 0 =
        0
             | exp16 == 0x7C00 =
        special
             | otherwise =
        shiftL exp32 23 .|. shiftL frac32 13
      special =
        if frac16 == 0
          -- Infinity
          then 0x7F800000

          -- NaN; signals are maintained in lower 10 bits
          else 0x7FC00000 .|. fromIntegral frac16
      (exp32, frac32) =
        if exp16 > 0
          then normalised
          else denormalised
      normalised =
        let exp = (fromIntegral exp16 `shiftR` 10) - 15 + 127
            frac = fromIntegral frac16
        in (exp, frac)
      denormalised =
        let exp = (fromIntegral exp16 `shiftR` 10) - 15 + 127 - e
            (e, frac ) =
              let step acc x = if x .&. 0x400 == 0
                    then step (acc + 1) (shiftL x 1)
                    else (acc, fromIntegral x .&. 0x3FF)
              in step 0 (shiftL frac16 1)
        in (exp, frac)
  in toFloat (sign32 .|. word32)
{-# INLINE toFloat16 #-}

float16be ::
  Get () Float
float16be =
  fmap toFloat16 word16be
{-# INLINE float16be #-}

float16le ::
  Get () Float
float16le =
  fmap toFloat16 word16le
{-# INLINE float16le #-}

float32be ::
  Get () Float
float32be =
  fmap toFloat word32be
{-# INLINE float32be #-}

float32le ::
  Get () Float
float32le =
  fmap toFloat word32le
{-# INLINE float32le #-}

float64be ::
  Get () Double
float64be =
  fmap toFloat word64be
{-# INLINE float64be #-}

float64le ::
  Get () Double
float64le =
  fmap toFloat word64le
{-# INLINE float64le #-}

int8 ::
  Get () Int8
int8 =
  fmap fromIntegral word8
{-# INLINE int8 #-}

int16be ::
  Get () Int16
int16be =
  fmap fromIntegral word16be
{-# INLINE int16be #-}

int16le ::
  Get () Int16
int16le =
  fmap fromIntegral word16le
{-# INLINE int16le #-}

int32be ::
  Get () Int32
int32be =
  fmap fromIntegral word32be
{-# INLINE int32be #-}

int32le ::
  Get () Int32
int32le =
  fmap fromIntegral word32le
{-# INLINE int32le #-}

int64be ::
  Get () Int64
int64be =
  fmap fromIntegral word64be
{-# INLINE int64be #-}

int64le ::
  Get () Int64
int64le =
  fmap fromIntegral word64le
{-# INLINE int64le #-}

data IntegerError =
  IntegerTagUnexpectedEof
  | Integer0TagUnexpectedEof Word8
  | Integer1TagUnexpectedEof
  | IntegerListError ListError
  deriving (Eq, Ord, Show)

integerError ::
  a
  -> (Word8 -> a)
  -> a
  -> (ListError -> a)
  -> IntegerError
  -> a
integerError u _ _ _ IntegerTagUnexpectedEof =
  u
integerError _ u _ _ (Integer0TagUnexpectedEof w) =
  u w
integerError _ _ u _ Integer1TagUnexpectedEof =
  u
integerError _ _ _ u (IntegerListError e) =
  u e

_IntegerTagUnexpectedEof ::
  Prism' IntegerError ()
_IntegerTagUnexpectedEof =
  prism'
    (\() -> IntegerTagUnexpectedEof)
    (\x -> case x of
             IntegerTagUnexpectedEof ->
               Just ()
             _ ->
               Nothing)

_Integer0TagUnexpectedEof ::
  Prism' IntegerError Word8
_Integer0TagUnexpectedEof =
  prism'
    Integer0TagUnexpectedEof
    (\x -> case x of
             Integer0TagUnexpectedEof w ->
               Just w
             _ ->
               Nothing)

_Integer1TagUnexpectedEof ::
  Prism' IntegerError ()
_Integer1TagUnexpectedEof =
  prism'
    (\() -> Integer1TagUnexpectedEof)
    (\x -> case x of
             Integer1TagUnexpectedEof ->
               Just ()
             _ ->
               Nothing)

_IntegerListError ::
  Prism' IntegerError ListError
_IntegerListError =
  prism'
    IntegerListError
    (\x -> case x of
             IntegerListError e ->
               Just e
             _ ->
               Nothing)

integer ::
  Get IntegerError Integer
integer =
  do t <- IntegerTagUnexpectedEof !- word8
     case t of
       0 ->
         Integer0TagUnexpectedEof t !- fmap fromIntegral int32be
       _ ->
         do s <- Integer1TagUnexpectedEof !- word8
            y <- IntegerListError !!- list word8
            let v = foldr (\b a -> a `shiftL` 8 .|. fromIntegral b) 0 y
            return $! if s == (1 :: Word8) then v else - v

data ListError =
  ListUnexpectedEof
  | ListTagError
  deriving (Eq, Ord, Show)

listError ::
  a
  -> a
  -> ListError
  -> a
listError u _ ListUnexpectedEof =
  u
listError _ e ListTagError =
  e

listErrorIso ::
  Iso' Bool ListError
listErrorIso =
  iso
    (\p -> if p then ListUnexpectedEof else ListTagError)
    (== ListUnexpectedEof)

list ::
  Get e a
  -> Get ListError [a]
list q =
  do n <- ListTagError !- int64be
     ListUnexpectedEof !- many q n

many ::
  Get e a
  -> Int64
  -> Get e [a]
many g n =
  let go x 0 =
        return $! reverse x
      go x i =
        do a <- g
           x `seq` go (a:x) (i - 1)
  in go [] n

unsafeReadN ::
  Int
  -> (B.ByteString -> a)
  -> Get e a
unsafeReadN !n f =
  Get (\b ks -> ks (BU.unsafeDrop n b) $! f b)

readNWith ::
  Int
  -> (Ptr a -> IO a)
  -> Get () a
readNWith n f =
  readN n (\s -> BI.inlinePerformIO (BU.unsafeUseAsCString s (f . castPtr)))
{-# INLINE readNWith #-}

data Decoder e a =
  Fail !B.ByteString {-# UNPACK #-} !Int64 e
  | Partial (Maybe B.ByteString -> Decoder e a)
  | Done !B.ByteString {-# UNPACK #-} !Int64 a

-- |
--
-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
-- 34
--
-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
-- 99
--
-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
-- 34
decoder ::
  (B.ByteString -> Int64 -> e -> x)
  -> ((Maybe B.ByteString -> Decoder e a) -> x)
  -> (B.ByteString -> Int64 -> a -> x)
  -> Decoder e a
  -> x
decoder f _ _ (Fail b i e) =
  f b i e
decoder _ p _ (Partial k) =
  p k
decoder _ _ d (Done b i a) =
  d b i a

-- |
--
-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
-- Just ("abc",19,31)
--
-- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
-- True
--
-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
-- Nothing
_Fail ::
  Prism' (Decoder e a) (B.ByteString, Int64, e)
_Fail =
  prism'
    (\(b, i, e) -> Fail b i e)
    (\x -> case x of
             Fail b i e -> Just (b, i, e)
             _ -> Nothing)

-- |
--
-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
-- Nothing
--
-- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
-- True
--
-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
-- Nothing
_Partial ::
  Prism' (Decoder e a) (Maybe B.ByteString -> Decoder e a)
_Partial =
  prism'
    Partial
    (\x -> case x of
             Partial k -> Just k
             _ -> Nothing)

-- |
--
-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
-- Nothing
--
-- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
-- True
--
-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
-- Just ("abc",19,31)
_Done ::
  Prism' (Decoder e a) (B.ByteString, Int64, a)
_Done =
  prism'
    (\(b, i, a) -> Done b i a)
    (\x -> case x of
             Done b i a -> Just (b, i, a)
             _ -> Nothing)

bimapD ::
  (e -> f)
  -> (a -> b)
  -> Decoder e a
  -> Decoder f b
bimapD f _ (Fail b i e) =
  Fail b i (f e)
bimapD f g (Partial k) =
  Partial (bimapD f g . k)
bimapD _ g (Done b i a) =
  Done b i (g a)
{-# INLINE bimapD #-}

-- |
--
-- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
-- Just ("abc",19,41)
--
-- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
-- Just ("abc",19,620)
instance Bifunctor Decoder where
  bimap =
    bimapD

fmapD ::
  (a -> b)
  -> Decoder e a
  -> Decoder e b
fmapD =
  bimapD id
{-# INLINE fmapD #-}

-- |
--
-- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
-- Just ("abc",19,31)
--
-- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
-- Just ("abc",19,41)
instance Functor (Decoder e) where
  fmap =
    fmapD

calculateOffset ::
  XDecoder e a
  -> Decoder e a
calculateOffset s =
  let go r !acc =
        case r of
          XDone i a ->
            Done i (acc - fromIntegral (B.length i)) a
          XFail i e ->
            Fail i (acc - fromIntegral (B.length i)) e
          XPartial k ->
            Partial (\b ->
              case b of
                Nothing -> go (k Nothing) acc
                Just j -> go (k b) (acc + fromIntegral (B.length j)))
          XBytesRead i k ->
            go (k $! (acc - i)) acc
  in go s 0

runGetIncremental ::
  Get e a
  -> Decoder e a
runGetIncremental =
  calculateOffset . xrunGetIncremental

takeHeadChunk ::
  L.ByteString
  -> Maybe B.ByteString
takeHeadChunk lbs =
  case lbs of
    (LI.Chunk bs _) ->
      Just bs
    _ ->
      Nothing

dropHeadChunk ::
  L.ByteString
  -> L.ByteString
dropHeadChunk lbs =
  case lbs of
    (LI.Chunk _ lbs') ->
      lbs'
    _ ->
      LI.Empty

-- | An alias for @runGet@.
--
-- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
-- RunGet 195
(.>>) ::
  Get e a
  -> L.ByteString
  -> RunGetResult e a
(.>>) =
  runGet

infixl 2 .>>

-- | An alias for @runGet@ with the arguments flipped.
--
-- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
-- RunGet 195
(<<.) ::
  L.ByteString
  -> Get e a
  -> RunGetResult e a
(<<.) b =
  (`runGet` b)

infixl 2 <<.

runGet ::
  Get e a
  -> L.ByteString
  -> RunGetResult e a
runGet g b =
  let feedAll (Done _ _ x) _ =
        _RunGet # x
      feedAll (Partial k) c =
        feedAll (k (takeHeadChunk c)) (dropHeadChunk c)
      feedAll (Fail _ p e) _ =
        _RunGetFail # (p, e)
  in feedAll (runGetIncremental g) b

pushChunk ::
  Decoder e a
  -> B.ByteString
  -> Decoder e a
pushChunk r i =
  case r of
    Done j p a ->
      Done (j `B.append` i) p a
    Partial k ->
      k (Just i)
    Fail j p s ->
      Fail (j `B.append` i) p s

pushChunks ::
  Decoder e a
  -> L.ByteString
  -> Decoder e a
pushChunks r0 =
  let go r [] =
        r
      go (Done i p a) xs =
        Done (B.concat (i:xs)) p a
      go (Fail i p s) xs =
        Fail (B.concat (i:xs)) p s
      go (Partial k) (x:xs) =
        go (k (Just x)) xs
  in go r0 . L.toChunks

pushEndOfInput ::
  Decoder e a
  -> Decoder e a
pushEndOfInput r =
  case r of
    Done {} -> r
    Partial k -> k Nothing
    Fail {} -> r

-- |
--
-- >>> runGet (lazyByteString 5) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (lazyByteString 5) (BLC.pack "abc")
-- RunGetFail 3 ()
--
-- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
-- RunGet "abcde"
lazyByteString ::
  Int64
  -> Get () L.ByteString
lazyByteString =
  let consume n s =
        if fromIntegral (B.length s) >= n
          then
            Right (B.splitAt (fromIntegral n) s)
          else
            Left (fromIntegral (B.length s))
      go n =
        do s <- get
           case consume n s of
             Left u ->
               do put B.empty
                  demandInput
                  fmap (s:) (go (n - u))
             Right (w, r) ->
               do put r
                  return [w]
  in fmap L.fromChunks . go

-- |
--
-- >>> runGet lazyByteStringNul (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet lazyByteStringNul (BLC.pack "abc")
-- RunGetFail 3 ()
--
-- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
-- RunGet "abc"
--
-- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
-- RunGet "abc"
lazyByteStringNul ::
  Get () L.ByteString
lazyByteStringNul =
  let findNull s =
        case B.break (==0) s of
          (w, r) ->
            if B.null r
              then
                Nothing
              else
                Just (w, B.drop 1 r)
      go =
        do s <- get
           case findNull s of
             Nothing ->
               do put B.empty
                  demandInput
                  fmap (s:) go
             Just (w, r) ->
               do put r
                  return [w]
  in fmap L.fromChunks go

-- |
--
-- >>> runGet remainingLazyByteString  (BLC.pack "")
-- RunGet ""
--
-- >>> runGet remainingLazyByteString  (BLC.pack "abc")
-- RunGet "abc"
remainingLazyByteString ::
  Get e L.ByteString
remainingLazyByteString =
  let go =
        do s <- get
           put B.empty
           d <- isEmpty
           if d
             then
               return [s]
             else
               fmap (s:) go
  in fmap L.fromChunks go

ptr ::
  Storable a =>
  Int
  -> Get () a
ptr n =
  readNWith n peek
{-# INLINE ptr #-}

{-# RULES

"word8/readN" word8 =
  readN 1 BU.unsafeHead

"word16be/readN" word16be =
  readN 2 word16be'

"word16le/readN" word16le =
  readN 2 word16le'

"word32be/readN" word32be =
  readN 4 word32be'

"word32le/readN" word32le =
  readN 4 word32le'

"word64be/readN" word64be =
  readN 8 word64be'

"word64le/readN" word64le =
  readN 8 word64le'

  #-}

-- |
--
-- >>> runGet word8 (BLC.pack "abc")
-- RunGet 97
--
-- >>> runGet word8 (BLC.pack "123")
-- RunGet 49
word8 ::
  Get () Word8
word8 =
  readN 1 BU.unsafeHead
{-# INLINE [0] word8 #-}

word16be' ::
  B.ByteString
  -> Word16
word16be' s =
    (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW16` 8) .|.
    fromIntegral (s `BU.unsafeIndex` 1)
{-# INLINE word16be' #-}

-- |
--
-- >>> runGet word16be (BLC.pack "abc")
-- RunGet 24930
--
-- >>> runGet word16be (BLC.pack "123")
-- RunGet 12594
word16be ::
  Get () Word16
word16be =
  readN 2 word16be'
{-# INLINE [0] word16be #-}

word16le' ::
  B.ByteString
  -> Word16
word16le' s =
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW16` 8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE word16le' #-}

-- |
--
-- >>> runGet word16le (BLC.pack "abc")
-- RunGet 25185
--
-- >>> runGet word16le (BLC.pack "123")
-- RunGet 12849
word16le ::
  Get () Word16
word16le =
  readN 2 word16le'
{-# INLINE [0] word16le #-}

word32be' ::
  B.ByteString
  -> Word32
word32be' s =
    (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 24) .|.
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW32` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW32`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 3)
{-# INLINE word32be' #-}

-- |
--
-- >>> runGet word32be (BLC.pack "abcdef")
-- RunGet 1633837924
--
-- >>> runGet word32be (BLC.pack "123456")
-- RunGet 825373492
word32be ::
  Get () Word32
word32be =
  readN 4 word32be'
{-# INLINE [0] word32be #-}

word32le' ::
  B.ByteString
  -> Word32
word32le' s =
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 24) .|.
    (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW32` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW32`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE word32le' #-}

-- |
--
-- -- >>> runGet word32le (BLC.pack "abcdef")
-- RunGet 1684234849
--
-- >>> runGet word32le (BLC.pack "123456")
-- RunGet 875770417
word32le ::
  Get () Word32
word32le =
  readN 4 word32le'
{-# INLINE [0] word32le #-}

word64be' ::
  B.ByteString
  -> Word64
word64be' s =
    (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW64` 56) .|.
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW64` 40) .|.
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 32) .|.
    (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 24) .|.
    (fromIntegral (s `BU.unsafeIndex` 5) `shiftlW64` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 6) `shiftlW64`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 7)
{-# INLINE word64be' #-}

-- |
--
-- >>> runGet word64be (BLC.pack "abcdefghi")
-- RunGet 7017280452245743464
--
-- >>> runGet word64be (BLC.pack "123456789")
-- RunGet 3544952156018063160
word64be ::
  Get () Word64
word64be =
  readN 8 word64be'
{-# INLINE [0] word64be #-}

word64le' ::
  B.ByteString
  -> Word64
word64le' s =
    (fromIntegral (s `BU.unsafeIndex` 7) `shiftlW64` 56) .|.
    (fromIntegral (s `BU.unsafeIndex` 6) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 5) `shiftlW64` 40) .|.
    (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 32) .|.
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 24) .|.
    (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW64` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW64`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE word64le' #-}

-- |
--
-- >>> runGet word64le (BLC.pack "abcdefghi")
-- RunGet 7523094288207667809
--
-- >>> runGet word64le (BLC.pack "123456789")
-- RunGet 4050765991979987505
word64le ::
  Get () Word64
word64le =
  readN 8 word64le'
{-# INLINE [0] word64le #-}

-- |
--
-- >>> runGet wordhost (BLC.pack "abcdefghi")
-- RunGet 7523094288207667809
--
-- >>> runGet wordhost (BLC.pack "123456789")
-- RunGet 4050765991979987505
wordhost ::
  Get () Word
wordhost =
  ptr (sizeOf (undefined :: Word))
{-# INLINE wordhost #-}

-- |
--
-- >>> runGet word16host (BLC.pack "abcde")
-- RunGet 25185
--
-- >>> runGet word16host (BLC.pack "12345")
-- RunGet 12849
word16host ::
  Get () Word16
word16host =
  ptr (sizeOf (undefined :: Word16))
{-# INLINE word16host #-}

-- |
--
-- >>> runGet word32host (BLC.pack "abcde")
-- RunGet 1684234849
--
-- >>> runGet word32host (BLC.pack "12345")
-- RunGet 875770417
word32host ::
  Get () Word32
word32host =
  ptr (sizeOf (undefined :: Word32))
{-# INLINE word32host #-}

-- |
--
-- >>> runGet word64host (BLC.pack "abcdeghi")
-- RunGet 7595434456733934177
--
-- >>> runGet word64host (BLC.pack "123456789")
-- RunGet 4050765991979987505
word64host ::
  Get () Word64
word64host =
  ptr (sizeOf (undefined :: Word64))
{-# INLINE word64host #-}

------------------------------------------------------------------------
-- Unchecked shifts

shiftlW16 ::
  Word16
  -> Int
  -> Word16
shiftlW32 ::
  Word32
  -> Int
  -> Word32
shiftlW64 ::
  Word64
  -> Int
  -> Word64

#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
shiftlW16 (W16# w) (I# i) =
  W16# (w `uncheckedShiftL#`   i)
shiftlW32 (W32# w) (I# i) =
  W32# (w `uncheckedShiftL#`   i)

#if WORD_SIZE_IN_BITS < 64
shiftlW64 (W64# w) (I# i) =
  W64# (w `uncheckedShiftL64#` i)

#if __GLASGOW_HASKELL__ <= 606
-- Exported by GHC.Word in GHC 6.8 and higher
foreign import ccall unsafe "stg_uncheckedShiftL64"
  uncheckedShiftL64# ::
    Word64#
    -> Int#
    -> Word64#
#endif

#else
shiftlW64 (W64# w) (I# i) =
  W64# (w `uncheckedShiftL#` i)
#endif

#else
shiftlW16 =
  shiftL
shiftlW32 =
  shiftL
shiftlW64 =
  shiftL
#endif

----

data XDecoder e a =
  XFail !B.ByteString e
  | XPartial (Maybe B.ByteString -> XDecoder e a)
  | XDone !B.ByteString a
  | XBytesRead {-# UNPACK #-} !Int64 (Int64 -> XDecoder e a)

xdecoder ::
  (B.ByteString -> e -> x)
  -> ((Maybe B.ByteString -> XDecoder e a) -> x)
  -> (B.ByteString -> a -> x)
  -> (Int64 -> (Int64 -> XDecoder e a) -> x)
  -> XDecoder e a
  -> x
xdecoder f _ _ _ (XFail b e) =
  f b e
xdecoder _ p _ _ (XPartial k) =
  p k
xdecoder _ _ d _ (XDone b a) =
  d b a
xdecoder _ _ _ r (XBytesRead i k) =
  r i k

_XFail ::
  Prism' (XDecoder e a) (B.ByteString, e)
_XFail =
  prism'
    (uncurry XFail)
    (\x -> case x of
             XFail b e -> Just (b, e)
             _ -> Nothing)

_XPartial ::
  Prism' (XDecoder e a) (Maybe B.ByteString -> XDecoder e a)
_XPartial =
  prism'
    XPartial
    (\x -> case x of
             XPartial k -> Just k
             _ -> Nothing)

_XDone ::
  Prism' (XDecoder e a) (B.ByteString, a)
_XDone =
  prism'
    (uncurry XDone)
    (\x -> case x of
             XDone b a -> Just (b, a)
             _ -> Nothing)
_XBytesRead ::
  Prism' (XDecoder e a) (Int64, Int64 -> XDecoder e a)
_XBytesRead =
  prism'
    (uncurry XBytesRead)
    (\x -> case x of
             XBytesRead i k -> Just (i, k)
             _ -> Nothing)

{-# INLINE _XFail #-}
{-# INLINE _XPartial #-}
{-# INLINE _XDone #-}
{-# INLINE _XBytesRead #-}

instance Functor (XDecoder e) where
  fmap =
    bimap id

instance Bifunctor XDecoder where
  bimap f _ (XFail b e) =
    XFail b (f e)
  bimap f g (XPartial k) =
    XPartial (bimap f g . k)
  bimap _ g (XDone b a) =
    XDone b (g a)
  bimap f g (XBytesRead i k) =
    XBytesRead i (bimap f g . k)

instance Bifoldable XDecoder where
  bifoldMap f _ (XFail _ e) =
    f e
  bifoldMap _ _ (XPartial _) =
    mempty
  bifoldMap _ g (XDone _ a) =
    g a
  bifoldMap _ _ (XBytesRead _ _) =
    mempty

instance Foldable (XDecoder e) where
  foldMap _ (XFail _ _) =
    mempty
  foldMap _ (XPartial _) =
    mempty
  foldMap f (XDone _ a) =
    f a
  foldMap _ (XBytesRead _ _) =
    mempty

data CompletedXDecoder e a =
  CompletedFail !B.ByteString e
  | CompletedDone !B.ByteString a
  deriving (Eq, Ord, Show)

completedXDecoder ::
  (B.ByteString -> e -> x)
  -> (B.ByteString -> a -> x)
  -> CompletedXDecoder e a
  -> x
completedXDecoder f _ (CompletedFail b e) =
  f b e
completedXDecoder _ d (CompletedDone b a) =
  d b a

_CompletedFail ::
  Prism' (CompletedXDecoder e a) (B.ByteString, e)
_CompletedFail =
  prism'
    (uncurry CompletedFail)
    (\x -> case x of
             CompletedFail b e -> Just (b, e)
             _ -> Nothing)

_CompletedDone ::
  Prism' (CompletedXDecoder e a) (B.ByteString, a)
_CompletedDone =
  prism'
    (uncurry CompletedDone)
    (\x -> case x of
             CompletedDone b a -> Just (b, a)
             _ -> Nothing)

completedIso ::
  Iso (CompletedXDecoder e a) (CompletedXDecoder f b) (Either e a, B.ByteString) (Either f b, B.ByteString)
completedIso =
  iso
    (\d -> case d of
             CompletedFail b e -> (Left e, b)
             CompletedDone b a -> (Right a, b))
    (\z -> case z of
             (Left e, b) -> CompletedFail b e
             (Right a, b) -> CompletedDone b a)
{-# INLINE completedIso #-}

completedByteString ::
  Lens' (CompletedXDecoder e a) B.ByteString
completedByteString =
  lens
    (\d -> case d of
             CompletedFail b _ -> b
             CompletedDone b _ -> b)
    (\d b -> case d of
               CompletedFail _ e -> CompletedFail b e
               CompletedDone _ a -> CompletedDone b a)
{-# INLINE completedByteString #-}

completedValue ::
  Lens' (CompletedXDecoder e a) (Either e a)
completedValue =
  lens
    (\d -> case d of
             CompletedFail _ e -> Left e
             CompletedDone _ a -> Right a)
    (\d z -> case d of
               CompletedFail b e -> CompletedFail b (either id (pure e) z)
               CompletedDone b a -> CompletedDone b (either (pure a) id z))
{-# INLINE completedValue #-}

instance Functor (CompletedXDecoder e) where
  fmap =
    bimap id

instance Bifunctor CompletedXDecoder where
  bimap f _ (CompletedFail b e) =
    CompletedFail b (f e)
  bimap _ g (CompletedDone b a) =
    CompletedDone b (g a)

instance Foldable (CompletedXDecoder e) where
  foldMap _ (CompletedFail _ _) =
    mempty
  foldMap f (CompletedDone _ a) =
    f a

instance Traversable (CompletedXDecoder e) where
  traverse =
    bitraverse pure

instance Bifoldable CompletedXDecoder where
  bifoldMap f _ (CompletedFail _ e) =
    f e
  bifoldMap _ g (CompletedDone _ a) =
    g a

instance Bitraversable CompletedXDecoder where
  bitraverse f _ (CompletedFail b e) =
    fmap (CompletedFail b) (f e)
  bitraverse _ g (CompletedDone b a) =
    fmap (CompletedDone b) (g a)

uncomplete ::
  Prism' (XDecoder e a) (CompletedXDecoder e a)
uncomplete =
  prism'
    (\d -> case d of
             CompletedFail b e -> XFail b e
             CompletedDone b a -> XDone b a)
    (\d -> case d of
             XFail b e -> Just (CompletedFail b e)
             XPartial _ -> Nothing
             XDone b a -> Just (CompletedDone b a)
             XBytesRead _ _ -> Nothing)
{-# INLINE uncomplete #-}

uncompletedByteString ::
  Traversal' (XDecoder e a) B.ByteString
uncompletedByteString =
  uncomplete . completedByteString
{-# INLINE uncompletedByteString #-}

uncompletedValue ::
  Traversal' (XDecoder e a) (Either e a)
uncompletedValue =
  uncomplete . completedValue
{-# INLINE uncompletedValue #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE Trustworthy #-}

#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
#include "MachDeps.h"
#endif

module Data.Tickle.Get(
  -- * Get data type
  Get
  -- ** Primitive parsers
, lazyByteString
, lazyByteStringNul
, remainingLazyByteString
, ptr
, word8
, word16be
, word16le
, word32be
, word32le
, word64be
, word64le
, wordhost
, word16host
, word32host
, word64host
, failGet
, constant
, bytesRead
, demandInput
, skip
, isNotEmpty
, isEmpty
, getByteString
, modify
, readN
, ensureN
  -- ** Higher-level parsers
  -- *** IEEE754 parsers
, toFloat
, toFloat16
, float16be
, float16le
, float32be
, float32le
, float64be
, float64le
  -- *** Integer parsers
, int8
, int16be
, int16le
, int32be
, int32le
, int64be
, int64le
, IntegerError
, integerError
, _IntegerTagUnexpectedEof
, _Integer0TagUnexpectedEof
, _Integer1TagUnexpectedEof
, _IntegerListError
, integer
  -- *** List parsers
, ListError
, listError
, listErrorIso
, list
, many
  -- ** Higher-level combinators
, runAndKeepTrack
, pushBack
, pushFront
, xrunGetIncremental
, noMeansNo
, prompt
, isolate
, lookAhead
, lookAheadM
, lookAheadE
, readNWith
, calculateOffset
, pushChunk
, pushChunks
, pushEndOfInput
  -- ** Error label
, (!+)
, addLabel
, (!-)
, setLabel
, (!!-)
, modifyLabel
  -- * Decoder
, Decoder
, decoder
, _Fail
, _Partial
, _Done
  -- ** Run Get parser
, runGet
, (.>>)
, (<<.)
, runGetIncremental
  -- * XDecoder data type
, XDecoder
  -- ** Reduction
, xdecoder
  -- ** Prisms
, _XFail
, _XPartial
, _XDone
, _XBytesRead
  -- * CompletedXDecoder data type
, CompletedXDecoder
  -- ** Reduction
, completedXDecoder
  -- ** Prism
, _CompletedFail
, _CompletedDone
  -- ** Isomorphism
, completedIso
  -- ** Lens
, completedByteString
, completedValue
  -- ** Prism
, uncomplete
  -- ** Traversal
, uncompletedByteString
, uncompletedValue
) where

import Control.Applicative(Applicative((<*>), pure), (<$>))
import Control.Category(Category((.), id))
import Control.Lens.Iso(Iso', iso)
import Control.Lens.Lens(lens)
import Control.Lens.Prism(Prism', prism')
import Control.Lens.Review((#))
import Control.Lens.Type(Iso, Lens', Traversal')
import Control.Monad(Monad((>>=), (>>), return), ap)
import Data.Bifoldable(Bifoldable(bifoldMap))
import Data.Bifunctor(Bifunctor(bimap))
import Data.Bitraversable(Bitraversable(bitraverse))
import Data.Bits((.|.), (.&.), shiftL, shiftR)
import Data.Bool(Bool(False, True), (&&), not, otherwise)
import qualified Data.ByteString as B(ByteString, concat, append, length, splitAt, empty, null, break, drop)
import qualified Data.ByteString.Internal as BI
import qualified Data.ByteString.Lazy as L(ByteString, toChunks, fromChunks)
import qualified Data.ByteString.Lazy.Internal as LI(ByteString(Chunk, Empty))
import qualified Data.ByteString.Unsafe as BU(unsafeDrop, unsafeTake, unsafeHead, unsafeIndex, unsafeUseAsCString)
import Data.Either(Either(Left, Right), either)
import Data.Eq(Eq((==)))
import Data.Foldable(Foldable(foldMap))
import Data.Function(const)
import Data.Functor(Functor(fmap))
import Data.Functor.Apply(Apply((<.>)))
import Data.Functor.Alt(Alt((<!>)))
import qualified Data.Functor.Alt as Al(Alt(some, many))
import Data.Functor.Bind(Bind((>>-)))
import Data.Int(Int, Int8, Int16, Int32, Int64)
import Data.List(reverse, foldr)
import Data.Maybe(Maybe(Nothing, Just), maybe, isJust)
import Data.Monoid(Monoid(mempty))
import Data.Ord(Ord((>), (>=), (<), (>=)))
import Data.Semigroup(Semigroup((<>)))
import Data.Tickle.IsolateError(IsolateError, _NegativeSize, _IsolateXFail, _UnexpectedConsumed)
import Data.Tickle.RunGetResult(RunGetResult, _RunGet, _RunGetFail)
import Data.Traversable(Traversable(traverse))
import Data.Tuple(uncurry)
import Foreign(Ptr, castPtr, Storable(peek), sizeOf, alloca, poke)
import System.IO.Unsafe(unsafePerformIO)
#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)
import GHC.Word(Word, Word8, Word16(W16#), Word32(W32#), Word64(W64#))
import GHC.Base(uncheckedShiftL#, Int(I#))
#endif
import Prelude(Num((-), (+)), Float, Double, Integer, ($!), Show, fromIntegral, undefined, seq)
import System.IO(IO)

-- $setup
-- >>> import Control.Lens.Fold((^?))
-- >>> import Control.Lens.Prism(_Right, _Left)
-- >>> import qualified Data.ByteString.Lazy.Char8 as BLC(pack)
-- >>> import qualified Data.ByteString.Char8 as BC(ByteString, pack)
-- >>> import Data.String(String)
-- >>> import Data.List((++))
-- >>> import Data.Maybe(fromMaybe, isNothing)
-- >>> import Data.Validation(_Success, _Failure)
-- >>> import Prelude(Num((*)), subtract, even, mod)

newtype Get e a =
  Get (forall r.
    B.ByteString ->
    (B.ByteString -> a -> XDecoder e r) ->
    XDecoder e r)

bimapG ::
  (e -> f)
  -> (a -> b)
  -> Get e a
  -> Get f b
bimapG f g (Get z) =
  Get (\b q ->
    let r = z b XDone
        go (XDone i a) = q i (g a)
        go (XPartial k) = XPartial (go . k)
        go (XFail i s) = XFail i (f s)
        go (XBytesRead u k) = XBytesRead u (go . k)
    in go r)
{-# INLINE bimapG #-}

-- | Map on the error and result of a @Get@ decoder.
--
-- >>> runGet (bimap (const True) (\x -> x + x) word8) (BLC.pack "")
-- RunGetFail 0 True
--
-- >>> runGet (bimap (const True) (\x -> x + x) word8) (BLC.pack "abc")
-- RunGet 194
instance Bifunctor Get where
  bimap =
    bimapG

fmapG ::
  (a -> b)
  -> Get e a
  -> Get e b
fmapG =
  bimapG id
{-# INLINE fmapG #-}

-- | Map on the result of a @Get@ decoder.
--
-- >>> runGet (fmap (\x -> x + x) word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (\x -> x + x) word8) (BLC.pack "abc")
-- RunGet 194
instance Functor (Get e) where
  fmap =
    fmapG

-- | Apply a function on the @Get@ decoder result.
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (fmap (+) word8 <.> word8) (BLC.pack "abc")
-- RunGet 195
instance Apply (Get e) where
  (<.>) =
    ap

apG ::
  Get e (a -> b)
  -> Get e a
  -> Get e b
apG d e =
  do b <- d
     a <- e
     return (b a)
{-# INLINE [0] apG #-}

-- | Apply a function on the @Get@ decoder result.
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (fmap (+) word8 <*> word8) (BLC.pack "abc")
-- RunGet 195
--
-- >>> runGet (pure 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (pure x :: Get () Int) (BLC.pack "abc") == _RunGet # x
instance Applicative (Get e) where
  pure =
    return
  {-# INLINE pure #-}
  (<*>) =
    apG
  {-# INLINE (<*>) #-}

-- | Sequence an action through the @Get@ decoder.
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (word8 >>- \c1 -> fmap (\c2 -> c1 + c2) word8) (BLC.pack "abc")
-- RunGet 195
instance Bind (Get e) where
  (>>-) =
    (>>=)

returnG ::
  a
  -> Get e a
returnG a =
    Get (\b q -> q b a)
{-# INLINE [0] returnG #-}

bindG ::
  Get e a
  -> (a -> Get e b)
  -> Get e b
Get k `bindG` f =
  Get (\b q -> k b (\c a ->
    let Get l = f a
    in l c q))
{-# INLINE bindG #-}

-- | Sequence an action through the @Get@ decoder.
--
-- >>> runGet (return 7 :: Get () Int) (BLC.pack "abc")
-- RunGet 7
--
-- prop> runGet (return x :: Get () Int) (BLC.pack "abc") == _RunGet # x
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "a")
-- RunGetFail 1 ()
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "ab")
-- RunGet 195
--
-- >>> runGet (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) (BLC.pack "abc")
-- RunGet 195
instance Monad (Get e) where
  return =
    returnG
  (>>=) =
    bindG

-- | Pick between two @Get@ decoders, finding the first to not fail.
--
-- >>> runGet ((+1) <$> word8 <!> subtract 1 <$> word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet ((+1) <$> word8 <!> subtract 1 <$> word8) (BLC.pack "abc")
-- RunGet 98
--
-- >>> runGet (word8 <!> failGet ()) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 <!> failGet ()) (BLC.pack "abc")
-- RunGet 97
--
-- >>> runGet (Al.some word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (Al.some word8) (BLC.pack "a")
-- RunGet [97]
--
-- >>> runGet (Al.some word8) (BLC.pack "abc")
-- RunGet [97,98,99]
--
-- >>> runGet (Al.many word8) (BLC.pack "")
-- RunGet []
--
-- >>> runGet (Al.many word8) (BLC.pack "a")
-- RunGet [97]
--
-- >>> runGet (Al.many word8) (BLC.pack "abc")
-- RunGet [97,98,99]
instance Alt (Get e) where
  f <!> g =
    do (d, bs) <- runAndKeepTrack f
       case d of
         CompletedDone b a -> Get (\_ q -> q b a)
         CompletedFail _ _ -> pushBack bs >> g
  some p =
    (:) <$> p <*> Al.many p
  many p =
    (p >>= \x ->
     fmap (x:) (Al.many p)) <!> pure []

-- | Pick between two @Get@ decoders, finding the first to not fail.
--
-- >>> runGet (((+1) <$> word8) <> (subtract 1 <$> word8)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (((+1) <$> word8) <> (subtract 1 <$> word8)) (BLC.pack "abc")
-- RunGet 98
--
-- >>> runGet (word8 <> failGet ()) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 <> failGet ()) (BLC.pack "abc")
-- RunGet 97
instance Semigroup (Get e a) where
  (<>) =
    (<!>)

-- | A @Get@ decoder that always fails with the given value.
--
-- prop> runGet (failGet x :: Get Int ()) (BLC.pack s) == _RunGetFail # (0, x)
--
-- >>> runGet (failGet "abc" :: Get String ()) (BLC.pack "def")
-- RunGetFail 0 "abc"
failGet ::
  e
  -> Get e a
failGet e =
  Get (\i _ -> XFail i e)

constant ::
  (forall r. XDecoder e r)
  -> Get e a
constant d =
  Get (\_ _ -> d)

-- | Run a @Get@ decoder, but keep a track of the input that ran it to completion.
--
-- >>> runGet (runAndKeepTrack word8 :: Get () (CompletedXDecoder () Word8, [BC.ByteString])) (BLC.pack "")
-- RunGet (CompletedFail "" (),[])
--
-- >>> runGet (runAndKeepTrack word8 :: Get () (CompletedXDecoder () Word8, [BC.ByteString])) (BLC.pack "abc")
-- RunGet (CompletedDone "bc" 97,["abc"])
runAndKeepTrack ::
  Get e a
  -> Get x (CompletedXDecoder e a, [B.ByteString])
runAndKeepTrack (Get k) =
  Get (\b q ->
    let go !acc w = case w of
                      XDone c a -> q b (CompletedDone c a, reverse acc)
                      XPartial l -> XPartial (\c -> go (maybe acc (:acc) c) (l c))
                      XFail c e -> q b (CompletedFail c e, reverse acc)
                      XBytesRead i l -> XBytesRead i (go acc . l)
    in go [] (k b XDone))
{-# INLINE runAndKeepTrack #-}

-- |
--
-- >>> runGet (pushBack [] :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushBack [] :: Get () ()) (BLC.pack "abc")
-- RunGet ()
--
-- >>> runGet (pushBack [BC.pack "def"] :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushBack [BC.pack "def"] :: Get () ()) (BLC.pack "abc")
-- RunGet ()
pushBack ::
  [B.ByteString]
  -> Get e ()
pushBack z =
  let y [] = id
      y _ = B.concat . (:z)
  in Get (\b q -> q (y z b) ())
{-# INLINE pushBack #-}

-- |
--
-- >>> runGet (pushFront (BC.pack "def") :: Get () ()) (BLC.pack "")
-- RunGet ()
--
-- >>> runGet (pushFront (BC.pack "def") :: Get () ()) (BLC.pack "abc")
-- RunGet ()
pushFront ::
  B.ByteString
  -> Get e ()
pushFront b =
  Get (\c q -> q (B.append b c) ())
{-# INLINE pushFront #-}

xrunGetIncremental ::
  Get e a
  -> XDecoder e a
xrunGetIncremental (Get k) =
  noMeansNo (k B.empty XDone)

noMeansNo ::
  XDecoder e a
  -> XDecoder e a
noMeansNo =
  let neverAgain (XPartial k) =
        neverAgain (k Nothing)
      neverAgain (XBytesRead i k) =
        XBytesRead i (neverAgain . k)
      neverAgain r@(XDone _ _) =
        r
      neverAgain r@(XFail _ _) =
        r
      go (XPartial k) =
        XPartial (\b ->
          (if isJust b then go else neverAgain) (k b))
      go (XBytesRead i k) =
        XBytesRead i (go . k)
      go r@(XDone _ _) =
        r
      go r@(XFail _ _) =
        r
  in go

prompt ::
  B.ByteString
  -> XDecoder e a
  -> (B.ByteString -> XDecoder e a)
  -> XDecoder e a
prompt b d f =
  let loop = XPartial (maybe d (\s -> if B.null s then loop else f (b `B.append` s)))
  in loop

-- |
--
-- >>> runGet (bytesRead :: Get () Int64) (BLC.pack "")
-- RunGet 0
--
-- >>> runGet (bytesRead :: Get () Int64) (BLC.pack "abc")
-- RunGet 0
--
-- >>> runGet (word8 >> word16be >> word32le >> bytesRead) (BLC.pack "abcdefghijk")
-- RunGet 7
bytesRead ::
  Get e Int64
bytesRead =
  Get (\b q -> XBytesRead (fromIntegral (B.length b)) (q b))

-- |
--
-- >>> runGet (isolate 1 word8) (BLC.pack "ab")
-- RunGet 97
--
-- >>> runGet (isolate 1 word8) (BLC.pack "abcde")
-- RunGet 97
--
-- >>> runGet (isolate 2 word16le) (BLC.pack "abcde")
-- RunGet 25185
--
-- >>> runGet (isolate 1 word16le) (BLC.pack "abcde")
-- RunGetFail 0 (IsolateXFail ())
--
-- >>> runGet (isolate (-3) word16le) (BLC.pack "abcde")
-- RunGetFail 0 NegativeSize
--
-- >>> runGet (isolate 3 word16le) (BLC.pack "abcde")
-- RunGetFail 2 (UnexpectedConsumed 2 3)
isolate ::
  Int
  -> Get e a
  -> Get (IsolateError e) a
isolate m (Get k) =
  let go !n (XDone l x) =
        if n == 0 && B.null l
          then
            return x
          else
            do pushFront l
               failGet (_UnexpectedConsumed # (m - n - B.length l, m))
      go 0 (XPartial r) =
        go 0 (r Nothing)
      go n (XPartial r) =
        do i <- Get (\b q -> let takeLimited t =
                                   let (j, o) = B.splitAt n t
                                   in q o (Just j)
                             in if B.null b
                                  then
                                    prompt b (q B.empty Nothing) takeLimited
                                  else
                                    takeLimited b)
           case i of
             Nothing ->
               go n (r Nothing)
             Just u ->
               go (n - B.length u) (r (Just u))
      go _ (XFail b e) =
        pushFront b >> failGet (_IsolateXFail # e)
      go n (XBytesRead i r) =
        go n (r $! fromIntegral m - fromIntegral n - i)
  in if m < 0
       then
         failGet (_NegativeSize # ())
       else
         go m (k B.empty XDone)

-- |
--
-- >>> runGet demandInput (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet demandInput (BLC.pack "a")
-- RunGet ()
--
-- >>> runGet demandInput (BLC.pack "abc")
-- RunGet ()
demandInput ::
  Get () ()
demandInput =
  Get (\b q ->
    prompt b (XFail b ()) (`q` ()))

-- |
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "abcdefghi")
-- RunGet (97,100)
--
-- >>> runGet (word8 >>= \c -> skip 2 >> word8 >>= \d -> return (c,d)) (BLC.pack "abc")
-- RunGetFail 3 ()
skip ::
  Int
  -> Get () ()
skip n =
  readN n (return ())
{-# INLINE skip #-}

-- |
--
-- >>> runGet isNotEmpty (BLC.pack "")
-- RunGet False
--
-- >>> runGet isNotEmpty (BLC.pack "abc")
-- RunGet True
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "abc")
-- RunGet (97,True)
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (isNotEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "a")
-- RunGet (97,True)
isNotEmpty ::
  Get e Bool
isNotEmpty =
  fmap not isEmpty

-- |
--
-- >>> runGet isEmpty (BLC.pack "")
-- RunGet True
--
-- >>> runGet isEmpty (BLC.pack "abc")
-- RunGet False
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "abc")
-- RunGet (97,False)
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (isEmpty >>= \p -> word8 >>= \w -> return (w, p)) (BLC.pack "a")
-- RunGet (97,False)
isEmpty ::
  Get e Bool
isEmpty =
  Get (\b q ->
    if B.null b
      then
        prompt b (q b True) (`q` False)
      else
        q b False)

-- |
--
-- >>> runGet (lookAhead word8) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (lookAhead word8) (BLC.pack "abc")
-- RunGet 97
--
-- >>> runGet (lookAhead word8) (BLC.pack "a")
-- RunGet 97
lookAhead ::
  Get e a
  -> Get e a
lookAhead g =
  do (d, bs) <- runAndKeepTrack g
     case d of
       CompletedDone _ a ->
         pushBack bs >> return a
       CompletedFail inp s ->
         constant (XFail inp s)

-- |
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "abc")
-- RunGet Nothing
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "bc")
-- RunGet (Just 103)
--
-- >>> runGet (lookAheadM (word8 >>= \w -> return (if even w then Just (w + 5) else Nothing))) (BLC.pack "")
-- RunGetFail 0 ()
lookAheadM ::
  Get e (Maybe a)
  -> Get e (Maybe a)
lookAheadM g =
  let g' = fmap (maybe (Left ()) Right) g
  in fmap (either (return Nothing) Just) (lookAheadE g')

-- |
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "abc")
-- RunGet (Right 93)
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "bc")
-- RunGet (Left 103)
--
-- >>> runGet (lookAheadE (word8 >>= \w -> return (if even w then Left (w + 5) else Right (w - 4)))) (BLC.pack "")
-- RunGetFail 0 ()
lookAheadE ::
  Get e (Either a b)
  -> Get e (Either a b)
lookAheadE g =
  do (d, b) <- runAndKeepTrack g
     case d of
       CompletedDone _ (Left x) ->
         pushBack b >> return (Left x)
       CompletedDone i (Right x) ->
         Get (\_ q -> q i (Right x))
       CompletedFail i s ->
         constant (XFail i s)

-- |
--
-- >>> runGet ([(), ()] !+ (setLabel [] word8)) (BLC.pack "")
-- RunGetFail 0 [(),()]
--
-- >>> runGet ([(), ()] !+ (setLabel [] word8)) (BLC.pack "abc")
-- RunGet 97
(!+) ::
  Semigroup e =>
  e
  -> Get e a
  -> Get e a
(!+) =
  addLabel

infixl 3 !+

-- |
--
-- >>> runGet ([(), ()] `addLabel` (setLabel [] word8)) (BLC.pack "")
-- RunGetFail 0 [(),()]
--
-- >>> runGet ([(), ()] `addLabel` (setLabel [] word8)) (BLC.pack "abc")
-- RunGet 97
addLabel ::
  Semigroup e =>
  e
  -> Get e a
  -> Get e a
addLabel m =
  modifyLabel (<> m)

-- |
--
-- >>> runGet ("error" !- word8) (BLC.pack "")
-- RunGetFail 0 "error"
--
-- >>> runGet ("error" !- word8) (BLC.pack "abc")
-- RunGet 97
(!-) ::
  e
  -> Get d a
  -> Get e a
(!-) =
  setLabel

infixl 3 !-

-- |
--
-- >>> runGet ("error" `setLabel` word8) (BLC.pack "")
-- RunGetFail 0 "error"
--
-- >>> runGet ("error" `setLabel` word8) (BLC.pack "abc")
-- RunGet 97
setLabel ::
  e
  -> Get d a
  -> Get e a
setLabel =
  modifyLabel . return

-- |
--
-- >>> runGet (reverse !!- setLabel "error" word8) (BLC.pack "")
-- RunGetFail 0 "rorre"
--
-- >>> runGet (reverse !!- setLabel "error" word8) (BLC.pack "abc")
-- RunGet 97
(!!-) ::
  (d -> e)
  -> Get d a
  -> Get e a
(!!-) =
  modifyLabel

infixl 3 !!-

-- |
--
-- >>> runGet (reverse `modifyLabel` setLabel "error" word8) (BLC.pack "")
-- RunGetFail 0 "rorre"
--
-- >>> runGet (reverse `modifyLabel` setLabel "error" word8) (BLC.pack "abc")
-- RunGet 97
modifyLabel ::
  (d -> e)
  -> Get d a
  -> Get e a
modifyLabel m =
  bimap m id

-- |
--
-- >>> runGet (getByteString (-3)) (BLC.pack "")
-- RunGet ""
--
-- >>> runGet (getByteString 3) (BLC.pack "")
-- RunGetFail 0 ()
--
-- >>> runGet (getByteString 3) (BLC.pack "abc")
-- RunGet "abc"
--
-- >>> runGet (getByteString 3) (BLC.pack "abcdef")
-- RunGet "abc"
getByteString ::
  Int
  -> Get () B.ByteString
getByteString n =
  if n > 0
    then
      readN n (BU.unsafeTake n)
    else
      return B.empty
{-# INLINE getByteString #-}

modify ::
  (B.ByteString -> B.ByteString)
  -> Get e ()
modify f =
  Get (\b q -> q (f b) ())

get ::
  Get e B.ByteString
get =
  Get (\b q -> q b b)

put ::
  B.ByteString -> Get e ()
put s =
  Get (\_ q -> q s ())

-- |
--
-- >>> runGet (readN 3 id) (BLC.pack "abc")
-- RunGet "abc"
--
-- >>> runGet (readN 3 id) (BLC.pack "ab")
-- RunGetFail 0 ()
--
-- >>> runGet (readN 3 id) (BLC.pack "abcdef")
-- RunGet "abcdef"
--
-- >>> runGet (readN (-3) id) (BLC.pack "abcdef")
-- RunGet ""
readN ::
  Int
  -> (B.ByteString -> a)
  -> Get () a
readN !n f =
  ensureN n >> unsafeReadN n f
{-# INLINE [0] readN #-}

{-# RULES

"readN/readN merge" forall n m f g.
  readN n f `apG` readN m g =
    readN (n+m) (\bs -> f bs (g (BU.unsafeDrop n bs)))

"returnG/readN swap" [~1] forall f.
  returnG f =
    readN 0 (const f)

"readN 0/returnG swapback" [1] forall f.
  readN 0 f =
    returnG (f B.empty)

  #-}

-- |
---- |
---- >>> runGet (ensureN 3) (BLC.pack "")
-- RunGetFail 0 ()-- >>> runGet (ensureN 3) (BLC.pack "")
---- RunGetFail 0 ()
---- >>> runGet (ensureN 3) (BLC.pack "abc")
-- RunGet ()-- >>> runGet (ensureN 3) (BLC.pack "abc")
---- RunGet ()
---- >>> runGet (ensureN 3) (BLC.pack "abcdef")
-- RunGet ()-- >>> runGet (ensureN 3) (BLC.pack "abcdef")
ensureN-- RunGet ()::
ensureNInt   ::
  Int-> Get () ()
ensureN-> Get!()=()
ensureNGet (\!mk=->
  Getlet\igokn->=
    let goGet =(\b q -> if B.length b >= n
          Get (\b q -> ifthen b >= n
                         thenq b ()
                         else b ()
                         elselet Get g = demandInput >> go n
                           letin gGetb qg = demandInput >> go n
    in if B.length i >= m  in g b q)
    in ifthen i >= m
         thenk i ()
         else i ()
         elselet Get g = go m
           letin gGeti kg = go m
{-# INLINE inensureN i k)#-}
{-# INLINE ensureN #-}
toFloat ::
toFloat(Storable::  w, Storable f) =>
  (Storable w, Storable f) =>
  w-> f
toFloat-> f  w =
toFloatunsafePerformIO =       (alloca (\buf ->
  unsafePerformIOdo poke (castPtrallocabuf) (\buf ->
     do poke (bufcastPtr))    buf) w
 {-# INLINEtoFloat))  #-}
{-# INLINE toFloat #-}
toFloat16 ::
toFloat16Word16  ::
  Word16-> Float
toFloat16-> Floatword16 =
toFloat16let sign16=   =
  let sign16word16= .&. 0x8000
      exp16=  .&. 0x8000
      exp16word16=  .&. 0x7C00
      frac16= .&. 0x7C00
      frac16word16= .&. 0x3FF
      sign32= .&. 0x3FF
      sign32if sign16=    > 0
        ifthen > 0
          then0x80000000 -- -0.0
            0x80000000 -- -0.0
          else
          else0
      word320
      word32:: Word32
      word32:: Word32| word16 .&. 0x7FFF == 0 =
      word320    | word16 .&. 0x7FFF == 0 =
        0    | exp16 == 0x7C00 =
        special exp16 == 0x7C00 =
        special| otherwise =
        shiftL otherwiseexp32 23 .|.=  shiftL frac32 13
      special=exp32 23 .|. shiftL frac32 13
      specialif frac16=   == 0
        if-- Infinity == 0
          then-- Infinity0x7F800000
          then 0x7F800000
          -- NaN; signals are maintained in lower 10 bits
          else-- NaN; signals are maintained in lower 10 bits0x7FC00000 .|. fromIntegral frac16
      (exp32else, frac32) =   .|. fromIntegral frac16
      (exp32if exp16, frac32> 0) =
        ifthennormalised 0
          then normaliseddenormalised
      normalisedelse denormalised=
      normalisedlet exp ==(fromIntegral exp16 `shiftR` 10) - 15 + 127
        let expfrac==(fromIntegral exp16frac16`shiftR` 10) - 15 + 127
        in (fracexp, =frac)          frac16
      denormalisedin (exp, frac= )
      denormalisedlet exp = (=fromIntegral exp16 `shiftR` 10) - 15 + 127 - e
        let exp(e, =fracfromIntegral) =        exp16 `shiftR` 10) - 15 + 127 - e
            (e,letstep) =acc x = if x .&. 0x400 == 0
              let stepthenstep =(ifaccx+.&.1) 0x400(shiftLx01)
                    then step(acc,(accfromIntegral 1) (shiftLx .&. 10x3FF)   )
              in stepelse0 ((shiftLacc, fromIntegralfrac16 1)   x .&. 0x3FF)
        in (expin, step)0 (shiftL frac16 1)
  in toFloatin (exp(sign32, frac).|. word32)
{-# INLINEin toFloattoFloat16sign32 .|. word32)
{-# INLINE toFloat16 #-}
float16be ::
float16beGet () Float::
float16be () Float=
float16befmap toFloat16=      word16be
{-# INLINE toFloat16float16be#-}
{-# INLINE float16be #-}
float16le ::
float16leGet () Float::
float16le () Float=
float16lefmap toFloat16=      word16le
{-# INLINE toFloat16float16le#-}
{-# INLINE float16le #-}
float32be ::
float32beGet () Float::
float32be () Float=
float32befmap toFloat=    word32be
{-# INLINE toFloatfloat32be#-}
{-# INLINE float32be #-}
float32le ::
float32leGet () Float::
float32le () Float=
float32lefmap toFloat=    word32le
{-# INLINE toFloatfloat32le#-}
{-# INLINE float32le #-}
float64be ::
float64beGet () Double::
float64be () Double=
float64befmap toFloat=    word64be
{-# INLINE toFloatfloat64be#-}
{-# INLINE float64be #-}
float64le ::
float64leGet () Double::
float64le () Double=
float64lefmap toFloat=    word64le
{-# INLINE toFloatfloat64le#-}
{-# INLINE float64le #-}
int8 ::
int8Get::() Int8
int8=() Int8
int8fmap= fromIntegral word8
{-# INLINE fromIntegralint8 #-} word8
{-# INLINE int8 #-}
int16be ::
int16beGet ()::Int16
int16be ()=Int16
int16befmap fromIntegral=           word16be
{-# INLINE fromIntegralint16be #-}
{-# INLINE int16be #-}
int16le ::
int16leGet ()::Int16
int16le ()=Int16
int16lefmap fromIntegral=           word16le
{-# INLINE fromIntegralint16le #-}
{-# INLINE int16le #-}
int32be ::
int32beGet ()::Int32
int32be ()=Int32
int32befmap fromIntegral=           word32be
{-# INLINE fromIntegralint32be #-}
{-# INLINE int32be #-}
int32le ::
int32leGet ()::Int32
int32le ()=Int32
int32lefmap fromIntegral=           word32le
{-# INLINE fromIntegralint32le #-}
{-# INLINE int32le #-}
int64be ::
int64beGet ()::Int64
int64be ()=Int64
int64befmap fromIntegral=           word64be
{-# INLINE fromIntegralint64be #-}
{-# INLINE int64be #-}
int64le ::
int64leGet ()::Int64
int64le ()=Int64
int64lefmap fromIntegral=           word64le
{-# INLINE fromIntegralint64le #-}
{-# INLINE int64le #-}
data IntegerError =
dataIntegerTagUnexpectedEof =
  IntegerTagUnexpectedEof| Integer0TagUnexpectedEof Word8
  | Integer0TagUnexpectedEof Word8
  | Integer1TagUnexpectedEofIntegerListError ListError
  |deriving(Eq, Ord, ListErrorShow)
  deriving (Eq, Ord, Show)
integerError ::
integerErrora          ::
  a-> (Word8 -> a)
  -> (Word8 -> a)
  -> aListError -> a)
  -> (IntegerErrorListError -> a)
  -> IntegerErrora
integerError-> a       u _ _ _ IntegerTagUnexpectedEof =
integerErroru          u _ _ _ IntegerTagUnexpectedEof =
integerError          _ u _ _ (Integer0TagUnexpectedEof w) =
integerErroru w        _ u _ _ (Integer0TagUnexpectedEof w) =
integerError w        _ _ u _ Integer1TagUnexpectedEof =
integerErroru          _ _ u _ Integer1TagUnexpectedEof =
integerError          _ _ _ u (IntegerListError e) =
integerErroru e        _ _ _ u (IntegerListError e) =
  u e
_IntegerTagUnexpectedEof ::
_IntegerTagUnexpectedEofPrism' IntegerError () ::
_IntegerTagUnexpectedEof IntegerError () =
_IntegerTagUnexpectedEofprism'                 =
  prism'(\() -> IntegerTagUnexpectedEof)
    (\()->->casex of               )
    (\x -> caseIntegerTagUnexpectedEof of                 ->
             IntegerTagUnexpectedEofJust ()               ->
             _ Just->   ()
             _ ->Nothing)
               Nothing)
_Integer0TagUnexpectedEof ::
_Integer0TagUnexpectedEofPrism' IntegerError Word8::
_Integer0TagUnexpectedEof IntegerError Word8=
_Integer0TagUnexpectedEofprism'                  =
  prism'Integer0TagUnexpectedEof
    Integer0TagUnexpectedEof(\x -> case x of
    (\x -> caseInteger0TagUnexpectedEof of                  w ->
             Integer0TagUnexpectedEofJust w                 w ->
             _ Just->   w
             _ ->Nothing)
               Nothing)
_Integer1TagUnexpectedEof ::
_Integer1TagUnexpectedEofPrism' IntegerError ()  ::
_Integer1TagUnexpectedEof IntegerError ()  =
_Integer1TagUnexpectedEofprism'                  =
  prism'(\() -> Integer1TagUnexpectedEof)
    (\()->->casex of                )
    (\x -> caseInteger1TagUnexpectedEof of                  ->
             Integer1TagUnexpectedEofJust ()                ->
             _ Just->   ()
             _ ->Nothing)
               Nothing)
_IntegerListError ::
_IntegerListErrorPrism' IntegerError::  ListError
_IntegerListError IntegerError=   ListError
_IntegerListErrorprism'          =
  prism'IntegerListError
    IntegerListError(\x -> case x of
    (\x -> caseIntegerListError of          e ->
             IntegerListErrorJust e         e ->
             _ Just->   e
             _ ->Nothing)
               Nothing)
integer ::
integerGet IntegerError::         Integer
integer IntegerError=          Integer
integerdo t <-= IntegerTagUnexpectedEof !- word8
  do tcase<- IntegerTagUnexpectedEoft of                    !- word8
     case0 -> of
       0 ->Integer0TagUnexpectedEof t !- fmap fromIntegral int32be
       _ Integer0TagUnexpectedEof->                       t !- fmap fromIntegral int32be
       _ -> s <- Integer1TagUnexpectedEof !- word8
         do s <- Integer1TagUnexpectedEofIntegerListError !!- list!-word8
            ylet<-vIntegerListError= foldr (\b a ->!!-a `listshiftL` 8 .|. fromIntegral b) 0 y
            letreturn =$!if s(\==b a1->::aWord8shiftL) then` 8 .|.v else- v       b) 0 y
            return $! if s == (1 :: Word8) then v else - v
data ListError =
dataListUnexpectedEof =
  ListUnexpectedEof| ListTagError
  |deriving(Eq, Ord, Show)
  deriving (Eq, Ord, Show)
listError ::
listErrora       ::
  a-> a
  -> aListError
  -> ListErrora
listError-> a    u _ ListUnexpectedEof =
listErroru       u _ ListUnexpectedEof =
listError       _ e ListTagError =
listErrore       _ e ListTagError =
  e
listErrorIso ::
listErrorIsoIso' Bool ListError::
listErrorIso Bool ListError=
listErrorIsoiso        =
  iso(\p -> if p then ListUnexpectedEof else ListTagError)
    (\==p ->ListUnexpectedEof p then ListUnexpectedEof)             else ListTagError)
    (== ListUnexpectedEof)
list ::
listGet::e a
  Get-> Get aListError [a]
list-> Getq = ListError [a]
listdo q  =<- ListTagError !- int64be
  do nListUnexpectedEof<- ListTagError !- int64bemany q n
     ListUnexpectedEof !- many q n
many ::
manyGet::e a
  Get-> Int64 a
  -> Int64Get e [a]
many-> Getg n e [a]
manyletggo = 0 =
  let goreturn 0 = $! reverse x
      goreturnx i = $! reverse x
      godo i  =<- g
        do a <-`seq` go (a:x) (i - 1)
  in go [] x `seq` go (a:x) (i - 1)
  in go [] n
unsafeReadN ::
unsafeReadNInt       ::
  Int-> (B.ByteString -> a)
  -> (GetB.ByteStringe a       -> a)
unsafeReadN-> Get e a!n f =
unsafeReadNGet (\b ks!n->fks= (BU.unsafeDrop n b) $! f b)
  Get (\b ks -> ks (BU.unsafeDrop n b) $! f b)
readNWith ::
readNWithInt     ::
  Int-> (Ptr a -> IO a)
  -> (GetPtr(a ->a  IO a)
readNWith-> Get () a =
readNWithreadN n n\f =-> BI.inlinePerformIO (BU.unsafeUseAsCString s (f . castPtr)))
{-# INLINE n (\readNWiths -> BI.inlinePerformIO#-}            (BU.unsafeUseAsCString s (f . castPtr)))
{-# INLINE readNWith #-}
data Decoder e a =
dataFail!B.ByteString a =   {-# UNPACK #-} !Int64 e
  Fail| PartialB.ByteString(Maybe B.ByteString #-}-> Decoder!Int64 e a)
  | PartialDone !B.ByteStringMaybe B.ByteString{-# UNPACK->#-}!Int64 a)
  | Done !B.ByteString {-# UNPACK #-} !Int64 a
-- |
---- |
---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
-- 34-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Fail # (BC.pack "abc", 12, 19))
---- 34
---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
-- 99-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19)))
---- 99
---- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
-- 34-- >>> decoder (\b i n -> B.length b + fromIntegral i + n) (\_ -> 99) (\b n a -> B.length b + fromIntegral n + a) (_Done # (BC.pack "abc", 12, 19))
-- 34decoder ::
decoder(B.ByteString::      -> Int64 -> e -> x)
  (->B.ByteString((Maybe B.ByteString-> Int64 ->->eDecoder-> x)  e a) -> x)
  -> ((B.ByteStringMaybe B.ByteString-> Int64->->a -> xe a) -> x)
  -> (DecoderB.ByteStringe a   -> Int64 -> a -> x)
  -> Decoderx       e a
decoder-> x  f _ _ (Fail b i e) =
decoderf b i f _ _ (Fail b i e) =
decoder b i e p _ (Partial k) =
decoderp k   _ p _ (Partial k) =
decoder k   _ _ d (Done b i a) =
decoderd b i _ _ d (Done b i a) =
  d b i a
-- |
---- |
---- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
-- Just ("abc",19,31)-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Fail
---- Just ("abc",19,31)
---- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
-- True-- >>> isNothing ((_Fail # (BC.pack "abc", 19, 31)) ^? _Partial)
---- True
---- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
-- Nothing-- >>> (_Fail # (BC.pack "abc", 19, 31)) ^? _Done
_Fail-- Nothing::
_FailPrism':: (Decoder e a) (B.ByteString, Int64, e)
_Fail=  (Decoder e a) (B.ByteString, Int64, e)
_Failprism'=
  prism'(\(b, i, e) -> Fail b i e)
    (\(b,->i,case) ->x of b i e)
    (\x -> caseFail ofb i e -> Just (b, i, e)
             Fail_ -> bNothing e ->) Just (b, i, e)
             _ -> Nothing)
-- |
---- |
---- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
-- Nothing-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Fail
---- Nothing
---- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
-- True-- >>> isJust ((_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Partial)
---- True
---- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
-- Nothing-- >>> (_Partial # (\b -> _Fail # (fromMaybe (BC.pack "abc") b, 12, 19))) ^? _Done
_Partial-- Nothing::
_PartialPrism' ::(Decoder e a) (Maybe B.ByteString -> Decoder e a)
_Partial (Decoder e a) (Maybe B.ByteString -> Decoder e a)
_Partialprism' =
  prism'Partial
    Partial(\x -> case x of
    (\x -> casePartial of k -> Just k
             Partial_ -> Nothing ->)Just k
             _ -> Nothing)
-- |
---- |
---- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
-- Nothing-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Fail
---- Nothing
---- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
-- True-- >>> isNothing ((_Done # (BC.pack "abc", 19, 31)) ^? _Partial)
---- True
---- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
-- Just ("abc",19,31)-- >>> (_Done # (BC.pack "abc", 19, 31)) ^? _Done
_Done-- Just ("abc",19,31)::
_DonePrism':: (Decoder e a) (B.ByteString, Int64, a)
_Done=  (Decoder e a) (B.ByteString, Int64, a)
_Doneprism'=
  prism'(\(b, i, a) -> Done b i a)
    (\(b,->i,case) ->x of b i a)
    (\x -> caseDone ofb i a -> Just (b, i, a)
             Done_ -> bNothing a ->) Just (b, i, a)
             _ -> Nothing)
bimapD ::
bimapD(e ->::f)
  (->e ->(a f->) b)
  -> (Decodera -> b)e a
  -> Decoder e a
bimapD-> Decoderf _ (Fail b b i e) =
bimapDFail f _ (Failf e) b i e) =
bimapD b i (fPartial)    k) =
bimapDPartial g((bimapDPartialf k).=k)
bimapD_ g(bimapD(Done bfiga. k)
bimapDDone _ g (Doneg a) b i a) =
{-# INLINE b i (bimapDg a)  #-}
{-# INLINE bimapD #-}
-- |
---- |
---- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
-- Just ("abc",19,41)-- >>> (bimap (+10) (*20) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
---- Just ("abc",19,41)
---- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
-- Just ("abc",19,620)-- >>> (bimap (+10) (*20) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
instance-- Just ("abc",19,620)Bifunctor Decoder where
instancebimap =Bifunctor Decoder where
  bimapbimapD=
    bimapD
fmapD ::
fmapD(a ->::b)
  (->a ->Decoder)   e a
  -> Decoder e a
fmapD-> Decoder=      e b
fmapDbimapD=  id
{-# INLINE idfmapD #-}
{-# INLINE fmapD #-}
-- |
---- |
---- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
-- Just ("abc",19,31)-- >>> (fmap (+10) (_Fail # (BC.pack "abc", 19, 31))) ^? _Fail
---- Just ("abc",19,31)
---- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
-- Just ("abc",19,41)-- >>> (fmap (+10) (_Done # (BC.pack "abc", 19, 31))) ^? _Done
instance-- Just ("abc",19,41)Functor (Decoder e) where
instancefmap = Functor (Decoder e) where
  fmapfmapD=
    fmapD
calculateOffset ::
calculateOffsetXDecoder e a  ::
  XDecoder-> Decoder a a
calculateOffset-> Decoder e as =
calculateOffsetlet go r !acc s =
  let gocase !accr of=
        caseXDone ofi a ->
          XDoneDoneiia(->acc - fromIntegral (B.length i)) a
          XFailiie(acc->  - fromIntegral (B.length i)) a
          XFailFailiie(->acc - fromIntegral (B.length i)) e
          XPartial i (acc-> - fromIntegral (B.length i)) e
          XPartialPartialk(->\b ->
            Partialcase b(\ofb ->
              caseNothing of -> go (k Nothing) acc
                NothingJust j ->go((kbNothing) (acc ) accfromIntegral (B.length j)))
          XBytesRead j ->k -> (k b) (acc + fromIntegral (B.length j)))
          XBytesReadgo (k $! iacc ->- i)) acc
  in go s 0 go (k $! (acc - i)) acc
  in go s 0
runGetIncremental ::
runGetIncrementalGet e a         ::
  Get-> Decoder a    e a
runGetIncremental-> Decoder e a  =
runGetIncrementalcalculateOffset = xrunGetIncremental
  calculateOffset . xrunGetIncremental
takeHeadChunk ::
takeHeadChunkL.ByteString::
  L.ByteString-> Maybe B.ByteString
takeHeadChunk-> Maybe B.ByteStringlbs =
takeHeadChunkcase lbs of lbs =
  case(LI.Chunk of bs _) ->
    (LI.ChunkJust bs bs _) ->
    _ Just->   bs
    _ ->Nothing
      Nothing
dropHeadChunk ::
dropHeadChunkL.ByteString::
  L.ByteString-> L.ByteString
dropHeadChunk-> L.ByteStringlbs =
dropHeadChunkcase lbs of lbs =
  case(LI.Chunk of _ lbs') ->
    (LI.Chunklbs'    _ lbs') ->
    _ lbs'->
    _ ->LI.Empty
      LI.Empty
-- | An alias for @runGet@.
---- | An alias for @runGet@.
---- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
-- RunGet 195-- >>> (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2)) .>> BLC.pack "abc"
(-- RunGet 195.>>) ::
(.>>Get) ::e a
  Get-> L.ByteString a
  -> L.ByteString e a
(.>>->)RunGetResult=           e a
(.>>runGet) =
  runGet
infixl 2 .>>
infixl 2 .>>
-- | An alias for @runGet@ with the arguments flipped.
---- | An alias for @runGet@ with the arguments flipped.
---- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
-- RunGet 195-- >>> BLC.pack "abc" <<. (word8 >>= \c1 -> word8 >>= \c2 -> return (c1 + c2))
(-- RunGet 195<<.) ::
(<<.L.ByteString) ::
  L.ByteString-> Get e a
  -> GetRunGetResult a      e a
(<<.->)RunGetResultb =         e a
(<<.(`)runGet = ` b)
  (`runGet` b)
infixl 2 <<.
infixl 2 <<.
runGet ::
runGetGet e::a
  Get-> L.ByteString a
  -> L.ByteString e a
runGet-> RunGetResultg b =      e a
runGetlet feedAll b =  (Done _ _ x) _ =
  let feedAll_RunGetDone# x _ _ x) _ =
      feedAll(Partial x    k) c =
      feedAllfeedAllPartial(k (takeHeadChunk) c =     c)) (dropHeadChunk c)
      feedAll(Failk (takeHeadChunk_ p e) _ =    c)) (dropHeadChunk c)
      feedAll_RunGetFailFail _ ppe)e_ =
  in feedAll(runGetIncremental (p, e)    g) b
  in feedAll (runGetIncremental g) b
pushChunk ::
pushChunkDecoder ::e a
  Decoder-> B.ByteString a
  -> B.ByteStringDecoder e a
pushChunk-> Decoderr ie=a
pushChunkcase r of i =
  caseDone ofj p a ->
    DoneDone pja`->B.append` i) p a
    Partial (j `->B.append` i) p a
    Partialk (Just ->i)
    Fail (Justj p si)->
    FailFail pjs`->B.append` i) p s
      Fail (j `B.append` i) p s
pushChunks ::
pushChunksDecoder e::a
  Decoder-> L.ByteString a
  -> L.ByteStringDecoder e a
pushChunks-> Decoderr0e=a
pushChunkslet go r r0[] =
  let gorr [] =
      gor(Done i p a) xs =
      goDoneDone(B.concat p a) xs(i=xs)) p a
      goDone(FailB.concati p s) xsi:xs)) p a
      goFailFail(B.concat p s) xs(i=xs)) p s
      goFail(PartialB.concatk) (x(ixs:xs) )) p s
      gogoPartial(k (Just)x(x:xs) =
  in go go (kL.toChunksJust x)) xs
  in go r0 . L.toChunks
pushEndOfInput ::
pushEndOfInputDecoder e a  ::
  Decoder-> Decoder ae a
pushEndOfInput-> Decoder e a =
pushEndOfInputcase r of    r =
  caseDone of{} -> r
    DonePartial{} ->k -> k Nothing
    PartialFail {} k->->r k Nothing
    Fail {} -> r
-- |
---- |
---- >>> runGet (lazyByteString 5) (BLC.pack "")
-- RunGetFail 0 ()-- >>> runGet (lazyByteString 5) (BLC.pack "")
---- RunGetFail 0 ()
---- >>> runGet (lazyByteString 5) (BLC.pack "abc")
-- RunGetFail 3 ()-- >>> runGet (lazyByteString 5) (BLC.pack "abc")
---- RunGetFail 3 ()
---- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
-- RunGet "abcde"-- >>> runGet (lazyByteString 5) (BLC.pack "abcdefg")
lazyByteString-- RunGet "abcde"::
lazyByteStringInt64        ::
  Int64-> Get () L.ByteString
lazyByteString-> Get () L.ByteString=
lazyByteStringlet consume n=s =
  let consumeif fromIntegral s =     (B.length s) >= n
        ifthen (B.length s) >= n
          thenRight (B.splitAt (fromIntegral n) s)
          else (B.splitAt (fromIntegral n) s)
          elseLeft (fromIntegral (B.length s))
      go n =Left (fromIntegral (B.length s))
      godo =  <- get
        do scase<- getconsume n s of
           caseLeftu ->  n s of
             Leftdo uputB.empty
               do putdemandInput
                  demandInputfmap (s:) (go (n - u))
             Rightfmap(w, (s:)->(go (n - u))
             Rightdo putw,rr) ->
               do putreturn  [w]
  in fmap L.fromChunks. [gow]
  in fmap L.fromChunks . go
-- |
---- |
---- >>> runGet lazyByteStringNul (BLC.pack "")
-- RunGetFail 0 ()-- >>> runGet lazyByteStringNul (BLC.pack "")
---- RunGetFail 0 ()
---- >>> runGet lazyByteStringNul (BLC.pack "abc")
-- RunGetFail 3 ()-- >>> runGet lazyByteStringNul (BLC.pack "abc")
---- RunGetFail 3 ()
---- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
-- RunGet "abc"-- >>> runGet lazyByteStringNul (BLC.pack "abc\0")
---- RunGet "abc"
---- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
-- RunGet "abc"-- >>> runGet lazyByteStringNul (BLC.pack "abc\0def")
-- RunGet "abc"lazyByteStringNul ::
lazyByteStringNulGet () L.ByteString::
lazyByteStringNul () L.ByteString=
lazyByteStringNullet findNull s ==
  let findNullcase B.break =   (==0) s of
        case(w,B.breakr) ->  (==0) s of
          (w,ifr)B.null   r
            ifthen r
              thenNothing
              else
              elseJust (w, B.drop 1 r)
      go =      Just (w, B.drop 1 r)
      godo= s <- get
        do scase<- getfindNull s of
           caseNothing->  s of
             Nothingdo put->B.empty
               do putdemandInput
                  demandInputfmap (s:) go
             Just fmap(w, r(s:->) go
             Justdo (putw, r) ->
               do putreturn  [w]
  in fmap L.fromChunksgo[w]
  in fmap L.fromChunks go
-- |
---- |
---- >>> runGet remainingLazyByteString  (BLC.pack "")
-- RunGet ""-- >>> runGet remainingLazyByteString  (BLC.pack "")
---- RunGet ""
---- >>> runGet remainingLazyByteString  (BLC.pack "abc")
-- RunGet "abc"-- >>> runGet remainingLazyByteString  (BLC.pack "abc")
-- RunGet "abc"remainingLazyByteString ::
remainingLazyByteStringGet e L.ByteString    ::
remainingLazyByteString e L.ByteString    =
remainingLazyByteStringlet go =              =
  let godo= s <- get
        do sput<-B.empty
           putd <-B.emptyisEmpty
           dif<-d isEmpty
           ifthen
             thenreturn [s]
             else [s]
             elsefmap (s:) go
  in fmap L.fromChunks (s:)gogo
  in fmap L.fromChunks go
ptr ::
ptrStorable::     a =>
  StorableInt      a =>
  Int-> Get () a
ptr->nGet=  () a
ptrreadNWith =     n peek
{-# INLINEptr peek#-}
{-# INLINE ptr #-}
{-# RULES
{-# RULES
"word8/readN" word8 =
"word8/readN"readN 1 BU.unsafeHead =
  readN 1 BU.unsafeHead
"word16be/readN" word16be =
"word16be/readN"readN 2 word16be' =
  readN 2 word16be'
"word16le/readN" word16le =
"word16le/readN"readN 2 word16le' =
  readN 2 word16le'
"word32be/readN" word32be =
"word32be/readN"readN 4 word32be' =
  readN 4 word32be'
"word32le/readN" word32le =
"word32le/readN"readN 4 word32le' =
  readN 4 word32le'
"word64be/readN" word64be =
"word64be/readN"readN 8 word64be' =
  readN 8 word64be'
"word64le/readN" word64le =
"word64le/readN"readN 8 word64le' =
  readN 8 word64le'
  #-}
  #-}
-- |
--
-- |-- >>> runGet word8 (BLC.pack "abc")
---- RunGet 97
---- >>> runGet word8 (BLC.pack "abc")
-- RunGet 97-- >>> runGet word8 (BLC.pack "123")
---- RunGet 49
word8-- >>> runGet word8 (BLC.pack "123")::
-- RunGet 49Get () Word8
word8 ::=
  GetreadN)1Word8BU.unsafeHead
word8{-# INLINE=    [0] word8 #-}
  readN 1 BU.unsafeHead
{-# INLINEword16be' ::[0] word8 #-}
  B.ByteString
word16be'-> Word16::
word16be's =
  ->(Word16fromIntegral (s `BU.unsafeIndex` 0) `shiftlW16` 8) .|.
word16be'fromIntegral =    (s `BU.unsafeIndex` 1)
{-# INLINEfromIntegralword16be's `#-}BU.unsafeIndex` 0) `shiftlW16` 8) .|.
    fromIntegral (s `BU.unsafeIndex` 1)
{-# INLINE-- |       word16be' #-}
--
-- |-- >>> runGet word16be (BLC.pack "abc")
---- RunGet 24930
---- >>> runGet word16be (BLC.pack "abc")
-- RunGet 24930-- >>> runGet word16be (BLC.pack "123")
---- RunGet 12594
word16be-- >>> runGet word16be (BLC.pack "123")::
-- RunGet 12594Get () Word16
word16be ::=
  GetreadN)2Word16word16be'
word16be{-# INLINE= [0] word16be #-}
  readN 2 word16be'
{-# INLINEword16le' ::[0] word16be #-}
  B.ByteString
word16le'-> Word16::
word16le's =
  ->(Word16fromIntegral (s `BU.unsafeIndex` 1) `shiftlW16` 8) .|.
word16le'fromIntegral =    (s `BU.unsafeIndex` 0)
{-# INLINEfromIntegralword16le's `#-}BU.unsafeIndex` 1) `shiftlW16` 8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE-- |       word16le' #-}
--
-- |-- >>> runGet word16le (BLC.pack "abc")
---- RunGet 25185
---- >>> runGet word16le (BLC.pack "abc")
-- RunGet 25185-- >>> runGet word16le (BLC.pack "123")
---- RunGet 12849
word16le-- >>> runGet word16le (BLC.pack "123")::
-- RunGet 12849Get () Word16
word16le ::=
  GetreadN)2Word16word16le'
word16le{-# INLINE= [0] word16le #-}
  readN 2 word16le'
{-# INLINEword32be' ::[0] word16le #-}
  B.ByteString
word32be'-> Word32::
word32be's =
  ->(Word32fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 24) .|.
word32be'(fromIntegral =     (s `BU.unsafeIndex` 1) `shiftlW32` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW32` 248) .|.
    (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``31) `shiftlW32` 16) .|.
{-# INLINEfromIntegralword32be's `#-}BU.unsafeIndex` 2) `shiftlW32`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 3)
{-# INLINE-- |       word32be' #-}
--
-- |-- >>> runGet word32be (BLC.pack "abcdef")
---- RunGet 1633837924
---- >>> runGet word32be (BLC.pack "abcdef")
-- RunGet 1633837924-- >>> runGet word32be (BLC.pack "123456")
---- RunGet 825373492
word32be-- >>> runGet word32be (BLC.pack "123456")::
-- RunGet 825373492Get () Word32
word32be ::=
  GetreadN)4Word32word32be'
word32be{-# INLINE= [0] word32be #-}
  readN 4 word32be'
{-# INLINEword32le' ::[0] word32be #-}
  B.ByteString
word32le'-> Word32::
word32le's =
  ->(Word32fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 24) .|.
word32le'(fromIntegral =     (s `BU.unsafeIndex` 2) `shiftlW32` 16) .|.
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW32` 248) .|.
    (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``02) `shiftlW32` 16) .|.
{-# INLINEfromIntegralword32le's `#-}BU.unsafeIndex` 1) `shiftlW32`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE-- |       word32le' #-}
--
-- |-- -- >>> runGet word32le (BLC.pack "abcdef")
---- RunGet 1684234849
---- -- >>> runGet word32le (BLC.pack "abcdef")
-- RunGet 1684234849-- >>> runGet word32le (BLC.pack "123456")
---- RunGet 875770417
word32le-- >>> runGet word32le (BLC.pack "123456")::
-- RunGet 875770417Get () Word32
word32le ::=
  GetreadN)4Word32word32le'
word32le{-# INLINE= [0] word32le #-}
  readN 4 word32le'
{-# INLINEword64be' ::[0] word32le #-}
  B.ByteString
word64be'-> Word64::
word64be's =
  ->(Word64fromIntegral (s `BU.unsafeIndex` 0) `shiftlW64` 56) .|.
word64be'(fromIntegral =     (s `BU.unsafeIndex` 1) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 0) `shiftlW64` 56) .|.
    (fromIntegral (s `BU.unsafeIndex` 1) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 2) `shiftlW64` 40) .|.
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 32) .|.
    (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 248) .|.
    (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``75) `shiftlW64` 16) .|.
{-# INLINEfromIntegralword64be's `#-}BU.unsafeIndex` 6) `shiftlW64`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 7)
{-# INLINE-- |       word64be' #-}
--
-- |-- >>> runGet word64be (BLC.pack "abcdefghi")
---- RunGet 7017280452245743464
---- >>> runGet word64be (BLC.pack "abcdefghi")
-- RunGet 7017280452245743464-- >>> runGet word64be (BLC.pack "123456789")
---- RunGet 3544952156018063160
word64be-- >>> runGet word64be (BLC.pack "123456789")::
-- RunGet 3544952156018063160Get () Word64
word64be ::=
  GetreadN)8Word64word64be'
word64be{-# INLINE= [0] word64be #-}
  readN 8 word64be'
{-# INLINEword64le' ::[0] word64be #-}
  B.ByteString
word64le'-> Word64::
word64le's =
  ->(Word64fromIntegral (s `BU.unsafeIndex` 7) `shiftlW64` 56) .|.
word64le'(fromIntegral =     (s `BU.unsafeIndex` 6) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 7) `shiftlW64` 56) .|.
    (fromIntegral (s `BU.unsafeIndex` 6) `shiftlW64` 48) .|.
    (fromIntegral (s `BU.unsafeIndex` 5) `shiftlW64` 40) .|.
    (fromIntegral (s `BU.unsafeIndex` 4) `shiftlW64` 32) .|.
    (fromIntegral (s `BU.unsafeIndex` 3) `shiftlW64` 248) .|.
    (fromIntegralfromIntegral((s``BU.unsafeIndexBU.unsafeIndex``02) `shiftlW64` 16) .|.
{-# INLINEfromIntegralword64le's `#-}BU.unsafeIndex` 1) `shiftlW64`  8) .|.
    fromIntegral (s `BU.unsafeIndex` 0)
{-# INLINE-- |       word64le' #-}
--
-- |-- >>> runGet word64le (BLC.pack "abcdefghi")
---- RunGet 7523094288207667809
---- >>> runGet word64le (BLC.pack "abcdefghi")
-- RunGet 7523094288207667809-- >>> runGet word64le (BLC.pack "123456789")
---- RunGet 4050765991979987505
word64le-- >>> runGet word64le (BLC.pack "123456789")::
-- RunGet 4050765991979987505Get () Word64
word64le ::=
  GetreadN)8Word64word64le'
word64le{-# INLINE= [0] word64le #-}
  readN 8 word64le'
{-# INLINE-- |       [0] word64le #-}
--
-- |-- >>> runGet wordhost (BLC.pack "abcdefghi")
---- RunGet 7523094288207667809
---- >>> runGet wordhost (BLC.pack "abcdefghi")
-- RunGet 7523094288207667809-- >>> runGet wordhost (BLC.pack "123456789")
---- RunGet 4050765991979987505
wordhost-- >>> runGet wordhost (BLC.pack "123456789")::
-- RunGet 4050765991979987505Get () Word
wordhost ::=
  Get ()sizeOf (undefined :: Word))
wordhost{-# INLINE= wordhost #-}
  ptr (sizeOf (undefined :: Word))
{-# INLINE-- |       wordhost #-}
--
-- |-- >>> runGet word16host (BLC.pack "abcde")
---- RunGet 25185
---- >>> runGet word16host (BLC.pack "abcde")
-- RunGet 25185-- >>> runGet word16host (BLC.pack "12345")
---- RunGet 12849
word16host-- >>> runGet word16host (BLC.pack "12345")::
-- RunGet 12849Get () Word16
word16host ::=
  Get ()sizeOf(undefined :: Word16))
word16host =word16host #-}
  ptr (sizeOf (undefined :: Word16))
{-# INLINE-- |       word16host #-}
--
-- |-- >>> runGet word32host (BLC.pack "abcde")
---- RunGet 1684234849
---- >>> runGet word32host (BLC.pack "abcde")
-- RunGet 1684234849-- >>> runGet word32host (BLC.pack "12345")
---- RunGet 875770417
word32host-- >>> runGet word32host (BLC.pack "12345")::
-- RunGet 875770417Get () Word32
word32host ::=
  Get ()sizeOf(undefined :: Word32))
word32host =word32host #-}
  ptr (sizeOf (undefined :: Word32))
{-# INLINE-- |       word32host #-}
--
-- |-- >>> runGet word64host (BLC.pack "abcdeghi")
---- RunGet 7595434456733934177
---- >>> runGet word64host (BLC.pack "abcdeghi")
-- RunGet 7595434456733934177-- >>> runGet word64host (BLC.pack "123456789")
---- RunGet 4050765991979987505
word64host-- >>> runGet word64host (BLC.pack "123456789")::
-- RunGet 4050765991979987505Get () Word64
word64host ::=
  Get ()sizeOf(undefined :: Word64))
word64host =word64host #-}
  ptr (sizeOf (undefined :: Word64))
{-# INLINE------------------------------------------------------------------------ #-}
-- Unchecked shifts
------------------------------------------------------------------------
shiftlW16-- Unchecked shifts::
  Word16
shiftlW16-> Int  ::
  Word16-> Word16
shiftlW32-> Int  ::
  ->Word32
shiftlW32-> Int  ::
  Word32-> Word32
shiftlW64-> Int  ::
  ->Word64
shiftlW64-> Int  ::
  Word64-> Word64
  -> Int
#if defined(__GLASGOW_HASKELL__) && !defined(__HADDOCK__)-> Word64
shiftlW16 (W16# w) (I# i) =
  W16# (w `uncheckedShiftL#`   i)
shiftlW16 (W16# w) (I# i) =
  W16# (w `uncheckedShiftL#`   i)
shiftlW32 (W32# w) (I# i) =
#if WORD_SIZE_IN_BITS < 64 (w `uncheckedShiftL#`   i)
shiftlW64 (W64# w) (I# i) =
  W64# (w `uncheckedShiftL64#` i)

#if __GLASGOW_HASKELL__ <= 606
-- Exported by GHC.Word in GHC 6.8 and higher
foreign import ccall unsafe "stg_uncheckedShiftL64"
  uncheckedShiftL64# ::
    Word64#
    -> Int#
    -> Word64#
#endif

#else
shiftlW64 (W64# w) (I# i) =
  W64# (w `uncheckedShiftL#` i)
#endif

#else
shiftlW16 =
  shiftL
shiftlW32 =
  shiftL
shiftlW64 =
  shiftL
#endif

----

data XDecoder e a =
  XFail !B.ByteString e
  | XPartial (Maybe B.ByteString -> XDecoder e a)
  | XDone !B.ByteString a
  | XBytesRead {-# UNPACK #-} !Int64 (Int64 -> XDecoder e a)

xdecoder ::
  (B.ByteString -> e -> x)
  -> ((Maybe B.ByteString -> XDecoder e a) -> x)
  -> (B.ByteString -> a -> x)
  -> (Int64 -> (Int64 -> XDecoder e a) -> x)
  -> XDecoder e a
  -> x
xdecoder f _ _ _ (XFail b e) =
  f b e
xdecoder _ p _ _ (XPartial k) =
  p k
xdecoder _ _ d _ (XDone b a) =
  d b a
xdecoder _ _ _ r (XBytesRead i k) =
  r i k

_XFail ::
  Prism' (XDecoder e a) (B.ByteString, e)
_XFail =
  prism'
    (uncurry XFail)
    (\x -> case x of
             XFail b e -> Just (b, e)
             _ -> Nothing)

_XPartial ::
  Prism' (XDecoder e a) (Maybe B.ByteString -> XDecoder e a)
_XPartial =
  prism'
    XPartial
    (\x -> case x of
             XPartial k -> Just k
             _ -> Nothing)

_XDone ::
  Prism' (XDecoder e a) (B.ByteString, a)
_XDone =
  prism'
    (uncurry XDone)
    (\x -> case x of
             XDone b a -> Just (b, a)
             _ -> Nothing)
_XBytesRead ::
  Prism' (XDecoder e a) (Int64, Int64 -> XDecoder e a)
_XBytesRead =
  prism'
    (uncurry XBytesRead)
    (\x -> case x of
             XBytesRead i k -> Just (i, k)
             _ -> Nothing)

{-# INLINE _XFail #-}
{-# INLINE _XPartial #-}
{-# INLINE _XDone #-}
{-# INLINE _XBytesRead #-}

instance Functor (XDecoder e) where
  fmap =
    bimap id

instance Bifunctor XDecoder where
  bimap f _ (XFail b e) =
    XFail b (f e)
  bimap f g (XPartial k) =
    XPartial (bimap f g . k)
  bimap _ g (XDone b a) =
    XDone b (g a)
  bimap f g (XBytesRead i k) =
    XBytesRead i (bimap f g . k)

instance Bifoldable XDecoder where
  bifoldMap f _ (XFail _ e) =
    f e
  bifoldMap _ _ (XPartial _) =
    mempty
  bifoldMap _ g (XDone _ a) =
    g a
  bifoldMap _ _ (XBytesRead _ _) =
    mempty

instance Foldable (XDecoder e) where
  foldMap _ (XFail _ _) =
    mempty
  foldMap _ (XPartial _) =
    mempty
  foldMap f (XDone _ a) =
    f a
  foldMap _ (XBytesRead _ _) =
    mempty

data CompletedXDecoder e a =
  CompletedFail !B.ByteString e
  | CompletedDone !B.ByteString a
  deriving (Eq, Ord, Show)

completedXDecoder ::
  (B.ByteString -> e -> x)
  -> (B.ByteString -> a -> x)
  -> CompletedXDecoder e a
  -> x
completedXDecoder f _ (CompletedFail b e) =
  f b e
completedXDecoder _ d (CompletedDone b a) =
  d b a

_CompletedFail ::
  Prism' (CompletedXDecoder e a) (B.ByteString, e)
_CompletedFail =
  prism'
    (uncurry CompletedFail)
    (\x -> case x of
             CompletedFail b e -> Just (b, e)
             _ -> Nothing)

_CompletedDone ::
  Prism' (CompletedXDecoder e a) (B.ByteString, a)
_CompletedDone =
  prism'
    (uncurry CompletedDone)
    (\x -> case x of
             CompletedDone b a -> Just (b, a)
             _ -> Nothing)

completedIso ::
  Iso (CompletedXDecoder e a) (CompletedXDecoder f b) (Either e a, B.ByteString) (Either f b, B.ByteString)
completedIso =
  iso
    (\d -> case d of
             CompletedFail b e -> (Left e, b)
             CompletedDone b a -> (Right a, b))
    (\z -> case z of
             (Left e, b) -> CompletedFail b e
             (Right a, b) -> CompletedDone b a)
{-# INLINE completedIso #-}

completedByteString ::
  Lens' (CompletedXDecoder e a) B.ByteString
completedByteString =
  lens
    (\d -> case d of
             CompletedFail b _ -> b
             CompletedDone b _ -> b)
    (\d b -> case d of
               CompletedFail _ e -> CompletedFail b e
               CompletedDone _ a -> CompletedDone b a)
{-# INLINE completedByteString #-}

completedValue ::
  Lens' (CompletedXDecoder e a) (Either e a)
completedValue =
  lens
    (\d -> case d of
             CompletedFail _ e -> Left e
             CompletedDone _ a -> Right a)
    (\d z -> case d of
               CompletedFail b e -> CompletedFail b (either id (pure e) z)
               CompletedDone b a -> CompletedDone b (either (pure a) id z))
{-# INLINE completedValue #-}

instance Functor (CompletedXDecoder e) where
  fmap =
    bimap id

instance Bifunctor CompletedXDecoder where
  bimap f _ (CompletedFail b e) =
    CompletedFail b (f e)
  bimap _ g (CompletedDone b a) =
    CompletedDone b (g a)

instance Foldable (CompletedXDecoder e) where
  foldMap _ (CompletedFail _ _) =
    mempty
  foldMap f (CompletedDone _ a) =
    f a

instance Traversable (CompletedXDecoder e) where
  traverse =
    bitraverse pure

instance Bifoldable CompletedXDecoder where
  bifoldMap f _ (CompletedFail _ e) =
    f e
  bifoldMap _ g (CompletedDone _ a) =
    g a

instance Bitraversable CompletedXDecoder where
  bitraverse f _ (CompletedFail b e) =
    fmap (CompletedFail b) (f e)
  bitraverse _ g (CompletedDone b a) =
    fmap (CompletedDone b) (g a)

uncomplete ::
  Prism' (XDecoder e a) (CompletedXDecoder e a)
uncomplete =
  prism'
    (\d -> case d of
             CompletedFail b e -> XFail b e
             CompletedDone b a -> XDone b a)
    (\d -> case d of
             XFail b e -> Just (CompletedFail b e)
             XPartial _ -> Nothing
             XDone b a -> Just (CompletedDone b a)
             XBytesRead _ _ -> Nothing)
{-# INLINE uncomplete #-}

uncompletedByteString ::
  Traversal' (XDecoder e a) B.ByteString
uncompletedByteString =
  uncomplete . completedByteString
{-# INLINE uncompletedByteString #-}

uncompletedValue ::
  Traversal' (XDecoder e a) (Either e a)
uncompletedValue =
  uncomplete . completedValue
{-# INLINE uncompletedValue #-}

</pre>