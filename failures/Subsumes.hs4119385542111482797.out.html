<a href="SubsumeCommon.hs11105611131420250114.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Sugar.hs2128236579784558821.out.html">next</a></br></br><pre>23c23
<         , ts2       <- Sum.singleton k $ crushEffect t2
---
>           ts2       <- Sum.singleton k $ crushEffect t2
28c28
<         , Just ts2  <- liftM (Sum.singleton k) $ trimClosure t2
---
>           Just ts2  <- liftM (Sum.singleton k) $ trimClosure t2
32a33
> 
</pre></br><h2>original</h2></br><pre>module DDC.Type.Subsumes
        (subsumesT)
where
import DDC.Type.Exp
import DDC.Type.Predicates
import DDC.Type.Transform.Crush
import DDC.Type.Transform.Trim
import qualified DDC.Type.Sum   as Sum
import Control.Monad


-- | Check whether the first type subsumes the second.
--
--   Both arguments are converted to sums, and we check that every
--   element of the second sum is equivalent to an element in the first.
--
--   This only works for well formed types of effect and closure kind.
--   Other types will yield `False`.
subsumesT :: Ord n => Kind n -> Type n -> Type n -> Bool
subsumesT k t1 t2
        | isEffectKind k
        , ts1       <- Sum.singleton k $ crushEffect t1
        , ts2       <- Sum.singleton k $ crushEffect t2
        = and $ [ Sum.elem t ts1 | t <- Sum.toList ts2 ]

        | isClosureKind k
        , Just ts1  <- liftM (Sum.singleton k) $ trimClosure t1
        , Just ts2  <- liftM (Sum.singleton k) $ trimClosure t2
        = and $ [ Sum.elem t ts1 | t <- Sum.toList ts2 ]

        | otherwise
        = False
</pre></br><h2>printed</h2></br><pre>module DDC.Type.Subsumes
        (subsumesT)
where
import DDC.Type.Exp
import DDC.Type.Predicates
import DDC.Type.Transform.Crush
import DDC.Type.Transform.Trim
import qualified DDC.Type.Sum   as Sum
import Control.Monad


-- | Check whether the first type subsumes the second.
--
--   Both arguments are converted to sums, and we check that every
--   element of the second sum is equivalent to an element in the first.
--
--   This only works for well formed types of effect and closure kind.
--   Other types will yield `False`.
subsumesT :: Ord n => Kind n -> Type n -> Type n -> Bool
subsumesT k t1 t2
        | isEffectKind k
        , ts1       <- Sum.singleton k $ crushEffect t1
          ts2       <- Sum.singleton k $ crushEffect t2
        = and $ [ Sum.elem t ts1 | t <- Sum.toList ts2 ]

        | isClosureKind k
        , Just ts1  <- liftM (Sum.singleton k) $ trimClosure t1
          Just ts2  <- liftM (Sum.singleton k) $ trimClosure t2
        = and $ [ Sum.elem t ts1 | t <- Sum.toList ts2 ]

        | otherwise
        = False

</pre>