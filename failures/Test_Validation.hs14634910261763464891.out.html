<a href="Test.hs16814847111976226904.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TestArith.hs1132610790494500522.out.html">next</a></br></br><pre>1c1
< {-# LINE 24 "Validation.lhs" #-}
---
> 
1a2
> 
1a3
> 
1a4
> 
1a5
> 
1a6
> 
1a7
> 
1a8
> 
1a9
> 
1a10
> 
1a11
> 
1a12
> 
1a13
> 
1a14
> 
1a15
> 
1a16
> 
1a17
> 
1a18
> 
1a19
> 
1a20
> 
1a21
> 
1a22
> 
1a23
> 
8c30
< {-# LINE 148 "Validation.lhs" #-}
---
> 
8a31
> 
8a32
> 
8a33
> 
8a34
> 
8a35
> 
8a36
> 
8a37
> 
8a38
> 
8a39
> 
8a40
> 
8a41
> 
8a42
> 
8a43
> 
8a44
> 
8a45
> 
8a46
> 
8a47
> 
8a48
> 
8a49
> 
8a50
> 
8a51
> 
8a52
> 
8a53
> 
8a54
> 
8a55
> 
8a56
> 
8a57
> 
8a58
> 
8a59
> 
8a60
> 
8a61
> 
8a62
> 
8a63
> 
8a64
> 
8a65
> 
8a66
> 
8a67
> 
8a68
> 
8a69
> 
8a70
> 
8a71
> 
8a72
> 
8a73
> 
8a74
> 
8a75
> 
8a76
> 
8a77
> 
8a78
> 
8a79
> 
8a80
> 
8a81
> 
8a82
> 
8a83
> 
8a84
> 
8a85
> 
8a86
> 
8a87
> 
8a88
> 
8a89
> 
8a90
> 
8a91
> 
8a92
> 
8a93
> 
8a94
> 
8a95
> 
8a96
> 
8a97
> 
8a98
> 
8a99
> 
8a100
> 
8a101
> 
8a102
> 
8a103
> 
8a104
> 
8a105
> 
8a106
> 
8a107
> 
8a108
> 
8a109
> 
8a110
> 
8a111
> 
8a112
> 
8a113
> 
8a114
> 
8a115
> 
8a116
> 
8a117
> 
8a118
> 
8a119
> 
8a120
> 
8a121
> 
8a122
> 
8a123
> 
8a124
> 
8a125
> 
8a126
> 
8a127
> 
8a128
> 
8a129
> 
8a130
> 
8a131
> 
8a132
> 
8a133
> 
8a134
> 
8a135
> 
8a136
> 
8a137
> 
8a138
> 
8a139
> 
8a140
> 
8a141
> 
8a142
> 
8a143
> 
8a144
> 
8a145
> 
8a146
> 
8a147
> 
11c150
< {-# LINE 154 "Validation.lhs" #-}
---
> 
11a151
> 
11a152
> 
11a153
> 
14c156
< {-# LINE 158 "Validation.lhs" #-}
---
> 
14a157
> 
17c160
< {-# LINE 176 "Validation.lhs" #-}
---
> 
17a161
> 
17a162
> 
17a163
> 
17a164
> 
17a165
> 
17a166
> 
17a167
> 
17a168
> 
17a169
> 
17a170
> 
17a171
> 
17a172
> 
17a173
> 
17a174
> 
17a175
> 
20c178
< {-# LINE 192 "Validation.lhs" #-}
---
> 
20a179
> 
20a180
> 
20a181
> 
20a182
> 
20a183
> 
20a184
> 
20a185
> 
20a186
> 
20a187
> 
20a188
> 
20a189
> 
20a190
> 
20a191
> 
23c194
< {-# LINE 207 "Validation.lhs" #-}
---
> 
23a195
> 
23a196
> 
23a197
> 
23a198
> 
23a199
> 
23a200
> 
23a201
> 
23a202
> 
23a203
> 
23a204
> 
23a205
> 
23a206
> 
26c209
< {-# LINE 237 "Validation.lhs" #-}
---
> 
26a210
> 
26a211
> 
26a212
> 
26a213
> 
26a214
> 
26a215
> 
26a216
> 
26a217
> 
26a218
> 
26a219
> 
26a220
> 
26a221
> 
26a222
> 
26a223
> 
26a224
> 
26a225
> 
26a226
> 
26a227
> 
26a228
> 
26a229
> 
26a230
> 
26a231
> 
26a232
> 
26a233
> 
26a234
> 
26a235
> 
26a236
> 
29c239
< {-# LINE 254 "Validation.lhs" #-}
---
> 
29a240
> 
29a241
> 
29a242
> 
29a243
> 
29a244
> 
29a245
> 
29a246
> 
29a247
> 
29a248
> 
29a249
> 
29a250
> 
29a251
> 
29a252
> 
29a253
> 
32c256
< {-# LINE 291 "Validation.lhs" #-}
---
> 
32a257
> 
32a258
> 
32a259
> 
32a260
> 
32a261
> 
32a262
> 
32a263
> 
32a264
> 
32a265
> 
32a266
> 
32a267
> 
32a268
> 
32a269
> 
32a270
> 
32a271
> 
32a272
> 
32a273
> 
32a274
> 
32a275
> 
32a276
> 
32a277
> 
32a278
> 
32a279
> 
32a280
> 
32a281
> 
32a282
> 
32a283
> 
32a284
> 
32a285
> 
32a286
> 
32a287
> 
32a288
> 
32a289
> 
32a290
> 
35c293
< {-# LINE 328 "Validation.lhs" #-}
---
> 
35a294
> 
35a295
> 
35a296
> 
35a297
> 
35a298
> 
35a299
> 
35a300
> 
35a301
> 
35a302
> 
35a303
> 
35a304
> 
35a305
> 
35a306
> 
35a307
> 
35a308
> 
35a309
> 
35a310
> 
35a311
> 
35a312
> 
35a313
> 
35a314
> 
35a315
> 
35a316
> 
35a317
> 
35a318
> 
35a319
> 
35a320
> 
35a321
> 
35a322
> 
35a323
> 
35a324
> 
35a325
> 
35a326
> 
35a327
> 
38c330
< {-# LINE 370 "Validation.lhs" #-}
---
> 
38a331
> 
38a332
> 
38a333
> 
38a334
> 
38a335
> 
38a336
> 
38a337
> 
38a338
> 
38a339
> 
38a340
> 
38a341
> 
38a342
> 
38a343
> 
38a344
> 
38a345
> 
38a346
> 
38a347
> 
38a348
> 
38a349
> 
38a350
> 
38a351
> 
38a352
> 
38a353
> 
38a354
> 
38a355
> 
38a356
> 
38a357
> 
38a358
> 
38a359
> 
38a360
> 
38a361
> 
38a362
> 
38a363
> 
38a364
> 
38a365
> 
38a366
> 
38a367
> 
38a368
> 
38a369
> 
41c372
< {-# LINE 396 "Validation.lhs" #-}
---
> 
41a373
> 
41a374
> 
41a375
> 
41a376
> 
41a377
> 
41a378
> 
41a379
> 
41a380
> 
41a381
> 
41a382
> 
41a383
> 
41a384
> 
41a385
> 
41a386
> 
41a387
> 
41a388
> 
41a389
> 
41a390
> 
41a391
> 
41a392
> 
41a393
> 
41a394
> 
41a395
> 
170a525
> 
</pre></br><h2>original</h2></br><pre>{-# LINE 24 "Validation.lhs" #-}
{-#  OPTIONS -Wall -fno-warn-type-defaults  #-}

module Tests.Src.Test_Validation where

import Data.Char
import Data.List
{-# LINE 148 "Validation.lhs" #-}
-- @@ Export
toDigitsRev :: Integer -> [Integer]
{-# LINE 154 "Validation.lhs" #-}
-- @@ Export
toDigits :: Integer -> [Integer]
{-# LINE 158 "Validation.lhs" #-}
-- @@ Export
toDigitsRev = reverse . toDigits
{-# LINE 176 "Validation.lhs" #-}
-- @@ Export
doubleSecond :: [Integer] -> [Integer]
{-# LINE 192 "Validation.lhs" #-}
-- @@ Export
sumDigits :: [Integer] -> Integer
{-# LINE 207 "Validation.lhs" #-}
-- @@ Export
validate :: Integer -> Bool
{-# LINE 237 "Validation.lhs" #-}
-- @@ Export
readCC :: String -> Integer
{-# LINE 254 "Validation.lhs" #-}
-- @@ Export
showCC :: Integer -> String
{-# LINE 291 "Validation.lhs" #-}
-- @@ Export
lookupIssuer :: String -> Integer -> IO String
{-# LINE 328 "Validation.lhs" #-}
-- @@ Export
checkCC :: String -> IO ()
{-# LINE 370 "Validation.lhs" #-}
-- @@ Export
toDigitsRevG :: Integer -> Integer -> [Integer]
{-# LINE 396 "Validation.lhs" #-}
toDigitsRev' :: Integer -> [Integer]
toDigitsRev' 0    = [0]
toDigitsRev' num  = go (abs num)
  where
    go 0  = []
    go n  = r : go q
      where (q, r) = quotRem n 10

toDigits = reverse . toDigitsRev'

--  Tricky cases:
--  * base too small
--  * num == minBound
toDigitsRevG base num
  | base < 2                        = []
  | abs num >= 0 && abs num < base  = abs num : []
  | num < 0                         = let (q, r) = quotRem num base in negate r : go (negate q)
  | otherwise                       = let (q, r) = quotRem num base in r : go q
  where
    go n
      | n < base   = n : []
      | otherwise  = let (q, r) = quotRem n base in r : go q

toDigitsRevG' :: (Integral a) => a -> a -> [a]
toDigitsRevG' base num
  | base < 2                        = []
  | num == 0                        = [0]
  | otherwise                       = map fromInteger . go . abs $ toInteger num
  where
    go 0  = []
    go n  = r : go q
      where (q, r) = quotRem n (toInteger base)

doubleSecond = go1
  where
    d x = x + x
    go1 []      = []
    go1 (x:xs)  = x   : go2 xs
    go2 []      = []
    go2 (x:xs)  = d x : go1 xs

sumDigits = sum . concatMap toDigitsRev

validate n = s `mod` 10 == 0
  where
    d1 = toDigitsRev n
    d2 = doubleSecond d1
    s  = sumDigits d2

ds :: String -> String
ds = dropWhile isSpace

readCC s = read s3 * (10 ^ 12) + read s2 * 10 ^ 8 + read s1 * 10 ^ 4 + read s0
  where
    (s3, s210) = splitAt 4 (ds s)
    (s2, s10)  = splitAt 4 (ds s210)
    (s1, s0r)  = splitAt 4 (ds s10)
    s0         = ds s0r

readCC' :: String -> Integer
readCC' s = n3 * (10 ^ 12) + n2 * 10 ^ 8 + n1 * 10 ^ 4 + n0
  where
    (n3, s210):_ = reads (ds s)
    (n2, s10):_  = reads (ds s210)
    (n1, s0r):_  = reads (ds s10)
    (n0, _):_    = reads (ds s0r)

showCC n = s3 ++ " " ++ s2 ++ " " ++ s1 ++ " " ++ s0
  where
    ns = show n
    zs = replicate (16 - length ns) '0'
    s = zs ++ ns
    (s3, s210) = splitAt 4 s
    (s2, s10)  = splitAt 4 s210
    (s1, s0)   = splitAt 4 s10

lookupIssuer file num = do

  --  Read the file in as String
  text <- readFile file

  --  Transform string lines into triples
  let entries = toEntries text

  --  Account for longer prefixes that override shorter ones by doing a
  --  reverse lexicographical sort on the prefix digits.
  let sorted = reverse $ sort $ entries

  --  Get the possible issuer by searching the sorted entries until we arrive at
  --  one that matches the prefix of the number and matches the length.
  let issuer = toIssuer sorted num

  --  Account for unknown issuer
  case issuer of
    []     -> return "Unknown"
    name:_ -> return name

--  Format entries as [(<prefix digits>, <length>, <issuer>)]
toEntries :: String -> [([Integer], Int, String)]
toEntries text = do
  ln <- lines text
  (prefix, rest) <- reads ln
  let prefixDigits = toDigits prefix
  (expectedLength, _:issuer) <- reads rest
  return (prefixDigits, expectedLength, issuer)

toIssuer :: [([Integer], Int, String)] -> Integer -> [String]
toIssuer entries num = do
  (prefixDigits, expectedLength, issuer) <- entries
  if prefixMatch prefixDigits numDigits && expectedLength == numLength
    then return issuer
    else []
  where
    prefixMatch xs ys = and $ zipWith (==) xs ys
    numDigits = toDigits num
    numLength = length numDigits


checkCC file = do
  putStr "Enter credit card number: "
  numText <- getLine
  let numIn = readCC numText
  issuer <- lookupIssuer file numIn
  let s1 = "The number " ++ showCC numIn ++ " is "
  let s2 = if validate numIn
             then ("valid and the type is " ++ issuer ++ ".")
             else ("not a valid credit card number.")
  putStrLn (s1 ++ s2)
  checkCC file
</pre></br><h2>printed</h2></br><pre>






















{-#  OPTIONS -Wall -fno-warn-type-defaults  #-}

module Tests.Src.Test_Validation where

import Data.Char
import Data.List






















































































































-- @@ Export
toDigitsRev :: Integer -> [Integer]




-- @@ Export
toDigits :: Integer -> [Integer]


-- @@ Export
toDigitsRev = reverse . toDigits
















-- @@ Export
doubleSecond :: [Integer] -> [Integer]














-- @@ Export
sumDigits :: [Integer] -> Integer













-- @@ Export
validate :: Integer -> Bool




























-- @@ Export
readCC :: String -> Integer















-- @@ Export
showCC :: Integer -> String



































-- @@ Export
lookupIssuer :: String -> Integer -> IO String



































-- @@ Export
checkCC :: String -> IO ()








































-- @@ Export
toDigitsRevG :: Integer -> Integer -> [Integer]
























toDigitsRev' :: Integer -> [Integer]
toDigitsRev' 0    = [0]
toDigitsRev' num  = go (abs num)
  where
    go 0  = []
    go n  = r : go q
      where (q, r) = quotRem n 10

toDigits = reverse . toDigitsRev'

--  Tricky cases:
--  * base too small
--  * num == minBound
toDigitsRevG base num
  | base < 2                        = []
  | abs num >= 0 && abs num < base  = abs num : []
  | num < 0                         = let (q, r) = quotRem num base in negate r : go (negate q)
  | otherwise                       = let (q, r) = quotRem num base in r : go q
  where
    go n
      | n < base   = n : []
      | otherwise  = let (q, r) = quotRem n base in r : go q

toDigitsRevG' :: (Integral a) => a -> a -> [a]
toDigitsRevG' base num
  | base < 2                        = []
  | num == 0                        = [0]
  | otherwise                       = map fromInteger . go . abs $ toInteger num
  where
    go 0  = []
    go n  = r : go q
      where (q, r) = quotRem n (toInteger base)

doubleSecond = go1
  where
    d x = x + x
    go1 []      = []
    go1 (x:xs)  = x   : go2 xs
    go2 []      = []
    go2 (x:xs)  = d x : go1 xs

sumDigits = sum . concatMap toDigitsRev

validate n = s `mod` 10 == 0
  where
    d1 = toDigitsRev n
    d2 = doubleSecond d1
    s  = sumDigits d2

ds :: String -> String
ds = dropWhile isSpace

readCC s = read s3 * (10 ^ 12) + read s2 * 10 ^ 8 + read s1 * 10 ^ 4 + read s0
  where
    (s3, s210) = splitAt 4 (ds s)
    (s2, s10)  = splitAt 4 (ds s210)
    (s1, s0r)  = splitAt 4 (ds s10)
    s0         = ds s0r

readCC' :: String -> Integer
readCC' s = n3 * (10 ^ 12) + n2 * 10 ^ 8 + n1 * 10 ^ 4 + n0
  where
    (n3, s210):_ = reads (ds s)
    (n2, s10):_  = reads (ds s210)
    (n1, s0r):_  = reads (ds s10)
    (n0, _):_    = reads (ds s0r)

showCC n = s3 ++ " " ++ s2 ++ " " ++ s1 ++ " " ++ s0
  where
    ns = show n
    zs = replicate (16 - length ns) '0'
    s = zs ++ ns
    (s3, s210) = splitAt 4 s
    (s2, s10)  = splitAt 4 s210
    (s1, s0)   = splitAt 4 s10

lookupIssuer file num = do

  --  Read the file in as String
  text <- readFile file

  --  Transform string lines into triples
  let entries = toEntries text

  --  Account for longer prefixes that override shorter ones by doing a
  --  reverse lexicographical sort on the prefix digits.
  let sorted = reverse $ sort $ entries

  --  Get the possible issuer by searching the sorted entries until we arrive at
  --  one that matches the prefix of the number and matches the length.
  let issuer = toIssuer sorted num

  --  Account for unknown issuer
  case issuer of
    []     -> return "Unknown"
    name:_ -> return name

--  Format entries as [(<prefix digits>, <length>, <issuer>)]
toEntries :: String -> [([Integer], Int, String)]
toEntries text = do
  ln <- lines text
  (prefix, rest) <- reads ln
  let prefixDigits = toDigits prefix
  (expectedLength, _:issuer) <- reads rest
  return (prefixDigits, expectedLength, issuer)

toIssuer :: [([Integer], Int, String)] -> Integer -> [String]
toIssuer entries num = do
  (prefixDigits, expectedLength, issuer) <- entries
  if prefixMatch prefixDigits numDigits && expectedLength == numLength
    then return issuer
    else []
  where
    prefixMatch xs ys = and $ zipWith (==) xs ys
    numDigits = toDigits num
    numLength = length numDigits


checkCC file = do
  putStr "Enter credit card number: "
  numText <- getLine
  let numIn = readCC numText
  issuer <- lookupIssuer file numIn
  let s1 = "The number " ++ showCC numIn ++ " is "
  let s2 = if validate numIn
             then ("valid and the type is " ++ issuer ++ ".")
             else ("not a valid credit card number.")
  putStrLn (s1 ++ s2)
  checkCC file

</pre>