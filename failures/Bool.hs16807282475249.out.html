<a href="BodyEnd.hs2458322992092396112.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Bool.hs41654197624301412.out.html">next</a></br></br><pre>19c19
<   If, type (&&), type (||), Not
---
>   If, type &&, type ||, Not
34d33
< type family a && b where
35d33
<   False && a     = False
36d33
<   True  && a     = a
37d33
<   a     && False = False
38d33
<   a     && True  = a
39c34
<   a     && a     = a
---
> type family   &&    b where
39a35
>         &&    a     = False
39a36
>         &&     a     = a
39a37
>         &&        False = False
39a38
>         &&        True  = a
39a39
>         &&        a     = a
43d42
< type family a || b where
44d42
<   False || a     = a
45d42
<   True  || a     = True
46d42
<   a     || False = a
47d42
<   a     || True  = True
48c43
<   a     || a     = a
---
> type family   ||    b where
48a44
>         ||    a     = a
48a45
>         ||     a     = True
48a46
>         ||        False = a
48a47
>         ||        True  = True
48a48
>         ||        a     = a
56a57
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, TypeOperators, DataKinds, NoImplicitPrelude,
             PolyKinds #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Type.Bool
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  not portable
--
-- Basic operations on type-level Booleans.
--
-- /Since: 4.7.0.0/
-----------------------------------------------------------------------------

module Data.Type.Bool (
  If, type (&&), type (||), Not
  ) where

import Data.Bool

-- This needs to be in base because (&&) is used in Data.Type.Equality.
-- The other functions do not need to be in base, but seemed to be appropriate
-- here.

-- | Type-level "If". @If True a b@ ==> @a@; @If False a b@ ==> @b@
type family If cond tru fls where
  If True  tru fls = tru
  If False tru fls = fls

-- | Type-level "and"
type family a && b where
  False && a     = False
  True  && a     = a
  a     && False = False
  a     && True  = a
  a     && a     = a
infixr 3 &&

-- | Type-level "or"
type family a || b where
  False || a     = a
  True  || a     = True
  a     || False = a
  a     || True  = True
  a     || a     = a
infixr 2 ||

-- | Type-level "not"
type family Not a where
  Not False = True
  Not True  = False


</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, TypeOperators, DataKinds, NoImplicitPrelude,
             PolyKinds #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Type.Bool
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  experimental
-- Portability :  not portable
--
-- Basic operations on type-level Booleans.
--
-- /Since: 4.7.0.0/
-----------------------------------------------------------------------------

module Data.Type.Bool (
  If, type &&, type ||, Not
  ) where

import Data.Bool

-- This needs to be in base because (&&) is used in Data.Type.Equality.
-- The other functions do not need to be in base, but seemed to be appropriate
-- here.

-- | Type-level "If". @If True a b@ ==> @a@; @If False a b@ ==> @b@
type family If cond tru fls where
  If True  tru fls = tru
  If False tru fls = fls

-- | Type-level "and"
type family   &&    b where
        &&    a     = False
        &&     a     = a
        &&        False = False
        &&        True  = a
        &&        a     = a
infixr 3 &&

-- | Type-level "or"
type family   ||    b where
        ||    a     = a
        ||     a     = True
        ||        False = a
        ||        True  = True
        ||        a     = a
infixr 2 ||

-- | Type-level "not"
type family Not a where
  Not False = True
  Not True  = False



</pre>