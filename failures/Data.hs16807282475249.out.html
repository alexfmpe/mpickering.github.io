<a href="Data.hs1622650073984943658.out.html">prev</a></br><a href="failures.html">home</a></br><a href="DataOnly.hs1144108930470211272.out.html">next</a></br></br><pre>133c133
<         mkPrimDispatch(mallocPrim,Prim.mallocArray)
---
>         ;mkPrimDispatch ArrayEltRint(mallocPrim,=Prim.mallocArray)  ; mallocPrim ArrayEltRint8 = Prim.mallocArray ; mallocPrim ArrayEltRint16 = Prim.mallocArray ; mallocPrim ArrayEltRint32 = Prim.mallocArray ; mallocPrim ArrayEltRint64 = Prim.mallocArray ; mallocPrim ArrayEltRword = Prim.mallocArray ; mallocPrim ArrayEltRword8 = Prim.mallocArray ; mallocPrim ArrayEltRword16 = Prim.mallocArray ; mallocPrim ArrayEltRword32 = Prim.mallocArray ; mallocPrim ArrayEltRword64 = Prim.mallocArray ; mallocPrim ArrayEltRfloat = Prim.mallocArray ; mallocPrim ArrayEltRdouble = Prim.mallocArray ; mallocPrim ArrayEltRbool = Prim.mallocArray ; mallocPrim ArrayEltRchar = Prim.mallocArray ; mallocPrim ArrayEltRcshort = Prim.mallocArray ; mallocPrim ArrayEltRcushort = Prim.mallocArray ; mallocPrim ArrayEltRcint = Prim.mallocArray ; mallocPrim ArrayEltRcuint = Prim.mallocArray ; mallocPrim ArrayEltRclong = Prim.mallocArray ; mallocPrim ArrayEltRculong = Prim.mallocArray ; mallocPrim ArrayEltRcllong = Prim.mallocArray ; mallocPrim ArrayEltRcullong = Prim.mallocArray ; mallocPrim ArrayEltRcfloat = Prim.mallocArray ; mallocPrim ArrayEltRcdouble = Prim.mallocArray ; mallocPrim ArrayEltRcchar = Prim.mallocArray ; mallocPrim ArrayEltRcschar = Prim.mallocArray ; mallocPrim ArrayEltRcuchar = Prim.mallocArray ; mallocPrim _ = error "mkPrimDispatcher: not primitive"
150c150
<         mkPrimDispatch(usePrim,Prim.useArray)
---
>         ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useArray)  ; usePrim ArrayEltRint8 = Prim.useArray ; usePrim ArrayEltRint16 = Prim.useArray ; usePrim ArrayEltRint32 = Prim.useArray ; usePrim ArrayEltRint64 = Prim.useArray ; usePrim ArrayEltRword = Prim.useArray ; usePrim ArrayEltRword8 = Prim.useArray ; usePrim ArrayEltRword16 = Prim.useArray ; usePrim ArrayEltRword32 = Prim.useArray ; usePrim ArrayEltRword64 = Prim.useArray ; usePrim ArrayEltRfloat = Prim.useArray ; usePrim ArrayEltRdouble = Prim.useArray ; usePrim ArrayEltRbool = Prim.useArray ; usePrim ArrayEltRchar = Prim.useArray ; usePrim ArrayEltRcshort = Prim.useArray ; usePrim ArrayEltRcushort = Prim.useArray ; usePrim ArrayEltRcint = Prim.useArray ; usePrim ArrayEltRcuint = Prim.useArray ; usePrim ArrayEltRclong = Prim.useArray ; usePrim ArrayEltRculong = Prim.useArray ; usePrim ArrayEltRcllong = Prim.useArray ; usePrim ArrayEltRcullong = Prim.useArray ; usePrim ArrayEltRcfloat = Prim.useArray ; usePrim ArrayEltRcdouble = Prim.useArray ; usePrim ArrayEltRcchar = Prim.useArray ; usePrim ArrayEltRcschar = Prim.useArray ; usePrim ArrayEltRcuchar = Prim.useArray ; usePrim _ = error "mkPrimDispatcher: not primitive"
164c164
<         mkPrimDispatch(usePrim,Prim.useArrayAsync)
---
>         ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useArrayAsync)  ; usePrim ArrayEltRint8 = Prim.useArrayAsync ; usePrim ArrayEltRint16 = Prim.useArrayAsync ; usePrim ArrayEltRint32 = Prim.useArrayAsync ; usePrim ArrayEltRint64 = Prim.useArrayAsync ; usePrim ArrayEltRword = Prim.useArrayAsync ; usePrim ArrayEltRword8 = Prim.useArrayAsync ; usePrim ArrayEltRword16 = Prim.useArrayAsync ; usePrim ArrayEltRword32 = Prim.useArrayAsync ; usePrim ArrayEltRword64 = Prim.useArrayAsync ; usePrim ArrayEltRfloat = Prim.useArrayAsync ; usePrim ArrayEltRdouble = Prim.useArrayAsync ; usePrim ArrayEltRbool = Prim.useArrayAsync ; usePrim ArrayEltRchar = Prim.useArrayAsync ; usePrim ArrayEltRcshort = Prim.useArrayAsync ; usePrim ArrayEltRcushort = Prim.useArrayAsync ; usePrim ArrayEltRcint = Prim.useArrayAsync ; usePrim ArrayEltRcuint = Prim.useArrayAsync ; usePrim ArrayEltRclong = Prim.useArrayAsync ; usePrim ArrayEltRculong = Prim.useArrayAsync ; usePrim ArrayEltRcllong = Prim.useArrayAsync ; usePrim ArrayEltRcullong = Prim.useArrayAsync ; usePrim ArrayEltRcfloat = Prim.useArrayAsync ; usePrim ArrayEltRcdouble = Prim.useArrayAsync ; usePrim ArrayEltRcchar = Prim.useArrayAsync ; usePrim ArrayEltRcschar = Prim.useArrayAsync ; usePrim ArrayEltRcuchar = Prim.useArrayAsync ; usePrim _ = error "mkPrimDispatcher: not primitive"
180c180
<         mkPrimDispatch(usePrim,Prim.useDevicePtrs)
---
>         ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useDevicePtrs)  ; usePrim ArrayEltRint8 = Prim.useDevicePtrs ; usePrim ArrayEltRint16 = Prim.useDevicePtrs ; usePrim ArrayEltRint32 = Prim.useDevicePtrs ; usePrim ArrayEltRint64 = Prim.useDevicePtrs ; usePrim ArrayEltRword = Prim.useDevicePtrs ; usePrim ArrayEltRword8 = Prim.useDevicePtrs ; usePrim ArrayEltRword16 = Prim.useDevicePtrs ; usePrim ArrayEltRword32 = Prim.useDevicePtrs ; usePrim ArrayEltRword64 = Prim.useDevicePtrs ; usePrim ArrayEltRfloat = Prim.useDevicePtrs ; usePrim ArrayEltRdouble = Prim.useDevicePtrs ; usePrim ArrayEltRbool = Prim.useDevicePtrs ; usePrim ArrayEltRchar = Prim.useDevicePtrs ; usePrim ArrayEltRcshort = Prim.useDevicePtrs ; usePrim ArrayEltRcushort = Prim.useDevicePtrs ; usePrim ArrayEltRcint = Prim.useDevicePtrs ; usePrim ArrayEltRcuint = Prim.useDevicePtrs ; usePrim ArrayEltRclong = Prim.useDevicePtrs ; usePrim ArrayEltRculong = Prim.useDevicePtrs ; usePrim ArrayEltRcllong = Prim.useDevicePtrs ; usePrim ArrayEltRcullong = Prim.useDevicePtrs ; usePrim ArrayEltRcfloat = Prim.useDevicePtrs ; usePrim ArrayEltRcdouble = Prim.useDevicePtrs ; usePrim ArrayEltRcchar = Prim.useDevicePtrs ; usePrim ArrayEltRcschar = Prim.useDevicePtrs ; usePrim ArrayEltRcuchar = Prim.useDevicePtrs ; usePrim _ = error "mkPrimDispatcher: not primitive"
195c195
<     mkPrimDispatch(devPrim,CUDA.wordPtrToDevPtr)
---
>     ;mkPrimDispatch ArrayEltRint(devPrim,=CUDA.wordPtrToDevPtr)  ; devPrim ArrayEltRint8 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint16 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint32 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint64 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword8 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword16 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword32 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword64 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRfloat = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRdouble = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRbool = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRchar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcshort = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcushort = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcint = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcuint = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRclong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRculong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcllong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcullong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcfloat = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcdouble = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcchar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcschar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcuchar = CUDA.wordPtrToDevPtr ; devPrim _ = error "mkPrimDispatcher: not primitive"
262c262
<         mkPrimDispatch(copyPrim,Prim.copyArray)
---
>         ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArray)  ; copyPrim ArrayEltRint8 = Prim.copyArray ; copyPrim ArrayEltRint16 = Prim.copyArray ; copyPrim ArrayEltRint32 = Prim.copyArray ; copyPrim ArrayEltRint64 = Prim.copyArray ; copyPrim ArrayEltRword = Prim.copyArray ; copyPrim ArrayEltRword8 = Prim.copyArray ; copyPrim ArrayEltRword16 = Prim.copyArray ; copyPrim ArrayEltRword32 = Prim.copyArray ; copyPrim ArrayEltRword64 = Prim.copyArray ; copyPrim ArrayEltRfloat = Prim.copyArray ; copyPrim ArrayEltRdouble = Prim.copyArray ; copyPrim ArrayEltRbool = Prim.copyArray ; copyPrim ArrayEltRchar = Prim.copyArray ; copyPrim ArrayEltRcshort = Prim.copyArray ; copyPrim ArrayEltRcushort = Prim.copyArray ; copyPrim ArrayEltRcint = Prim.copyArray ; copyPrim ArrayEltRcuint = Prim.copyArray ; copyPrim ArrayEltRclong = Prim.copyArray ; copyPrim ArrayEltRculong = Prim.copyArray ; copyPrim ArrayEltRcllong = Prim.copyArray ; copyPrim ArrayEltRcullong = Prim.copyArray ; copyPrim ArrayEltRcfloat = Prim.copyArray ; copyPrim ArrayEltRcdouble = Prim.copyArray ; copyPrim ArrayEltRcchar = Prim.copyArray ; copyPrim ArrayEltRcschar = Prim.copyArray ; copyPrim ArrayEltRcuchar = Prim.copyArray ; copyPrim _ = error "mkPrimDispatcher: not primitive"
279c279
<         mkPrimDispatch(copyPrim,Prim.copyArrayAsync)
---
>         ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayAsync)  ; copyPrim ArrayEltRint8 = Prim.copyArrayAsync ; copyPrim ArrayEltRint16 = Prim.copyArrayAsync ; copyPrim ArrayEltRint32 = Prim.copyArrayAsync ; copyPrim ArrayEltRint64 = Prim.copyArrayAsync ; copyPrim ArrayEltRword = Prim.copyArrayAsync ; copyPrim ArrayEltRword8 = Prim.copyArrayAsync ; copyPrim ArrayEltRword16 = Prim.copyArrayAsync ; copyPrim ArrayEltRword32 = Prim.copyArrayAsync ; copyPrim ArrayEltRword64 = Prim.copyArrayAsync ; copyPrim ArrayEltRfloat = Prim.copyArrayAsync ; copyPrim ArrayEltRdouble = Prim.copyArrayAsync ; copyPrim ArrayEltRbool = Prim.copyArrayAsync ; copyPrim ArrayEltRchar = Prim.copyArrayAsync ; copyPrim ArrayEltRcshort = Prim.copyArrayAsync ; copyPrim ArrayEltRcushort = Prim.copyArrayAsync ; copyPrim ArrayEltRcint = Prim.copyArrayAsync ; copyPrim ArrayEltRcuint = Prim.copyArrayAsync ; copyPrim ArrayEltRclong = Prim.copyArrayAsync ; copyPrim ArrayEltRculong = Prim.copyArrayAsync ; copyPrim ArrayEltRcllong = Prim.copyArrayAsync ; copyPrim ArrayEltRcullong = Prim.copyArrayAsync ; copyPrim ArrayEltRcfloat = Prim.copyArrayAsync ; copyPrim ArrayEltRcdouble = Prim.copyArrayAsync ; copyPrim ArrayEltRcchar = Prim.copyArrayAsync ; copyPrim ArrayEltRcschar = Prim.copyArrayAsync ; copyPrim ArrayEltRcuchar = Prim.copyArrayAsync ; copyPrim _ = error "mkPrimDispatcher: not primitive"
300c300
<         mkPrimDispatch(copyPrim,Prim.copyArrayPeer)
---
>         ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayPeer)  ; copyPrim ArrayEltRint8 = Prim.copyArrayPeer ; copyPrim ArrayEltRint16 = Prim.copyArrayPeer ; copyPrim ArrayEltRint32 = Prim.copyArrayPeer ; copyPrim ArrayEltRint64 = Prim.copyArrayPeer ; copyPrim ArrayEltRword = Prim.copyArrayPeer ; copyPrim ArrayEltRword8 = Prim.copyArrayPeer ; copyPrim ArrayEltRword16 = Prim.copyArrayPeer ; copyPrim ArrayEltRword32 = Prim.copyArrayPeer ; copyPrim ArrayEltRword64 = Prim.copyArrayPeer ; copyPrim ArrayEltRfloat = Prim.copyArrayPeer ; copyPrim ArrayEltRdouble = Prim.copyArrayPeer ; copyPrim ArrayEltRbool = Prim.copyArrayPeer ; copyPrim ArrayEltRchar = Prim.copyArrayPeer ; copyPrim ArrayEltRcshort = Prim.copyArrayPeer ; copyPrim ArrayEltRcushort = Prim.copyArrayPeer ; copyPrim ArrayEltRcint = Prim.copyArrayPeer ; copyPrim ArrayEltRcuint = Prim.copyArrayPeer ; copyPrim ArrayEltRclong = Prim.copyArrayPeer ; copyPrim ArrayEltRculong = Prim.copyArrayPeer ; copyPrim ArrayEltRcllong = Prim.copyArrayPeer ; copyPrim ArrayEltRcullong = Prim.copyArrayPeer ; copyPrim ArrayEltRcfloat = Prim.copyArrayPeer ; copyPrim ArrayEltRcdouble = Prim.copyArrayPeer ; copyPrim ArrayEltRcchar = Prim.copyArrayPeer ; copyPrim ArrayEltRcschar = Prim.copyArrayPeer ; copyPrim ArrayEltRcuchar = Prim.copyArrayPeer ; copyPrim _ = error "mkPrimDispatcher: not primitive"
317c317
<         mkPrimDispatch(copyPrim,Prim.copyArrayPeerAsync)
---
>         ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayPeerAsync)  ; copyPrim ArrayEltRint8 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint16 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint32 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint64 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword8 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword16 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword32 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword64 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRfloat = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRdouble = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRbool = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRchar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcshort = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcushort = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcint = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcuint = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRclong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRculong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcllong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcullong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcfloat = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcdouble = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcchar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcschar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcuchar = Prim.copyArrayPeerAsync ; copyPrim _ = error "mkPrimDispatcher: not primitive"
334c334
<         mkPrimDispatch(peekPrim,Prim.peekArray)
---
>         ;mkPrimDispatch ArrayEltRint(peekPrim,=Prim.peekArray)  ; peekPrim ArrayEltRint8 = Prim.peekArray ; peekPrim ArrayEltRint16 = Prim.peekArray ; peekPrim ArrayEltRint32 = Prim.peekArray ; peekPrim ArrayEltRint64 = Prim.peekArray ; peekPrim ArrayEltRword = Prim.peekArray ; peekPrim ArrayEltRword8 = Prim.peekArray ; peekPrim ArrayEltRword16 = Prim.peekArray ; peekPrim ArrayEltRword32 = Prim.peekArray ; peekPrim ArrayEltRword64 = Prim.peekArray ; peekPrim ArrayEltRfloat = Prim.peekArray ; peekPrim ArrayEltRdouble = Prim.peekArray ; peekPrim ArrayEltRbool = Prim.peekArray ; peekPrim ArrayEltRchar = Prim.peekArray ; peekPrim ArrayEltRcshort = Prim.peekArray ; peekPrim ArrayEltRcushort = Prim.peekArray ; peekPrim ArrayEltRcint = Prim.peekArray ; peekPrim ArrayEltRcuint = Prim.peekArray ; peekPrim ArrayEltRclong = Prim.peekArray ; peekPrim ArrayEltRculong = Prim.peekArray ; peekPrim ArrayEltRcllong = Prim.peekArray ; peekPrim ArrayEltRcullong = Prim.peekArray ; peekPrim ArrayEltRcfloat = Prim.peekArray ; peekPrim ArrayEltRcdouble = Prim.peekArray ; peekPrim ArrayEltRcchar = Prim.peekArray ; peekPrim ArrayEltRcschar = Prim.peekArray ; peekPrim ArrayEltRcuchar = Prim.peekArray ; peekPrim _ = error "mkPrimDispatcher: not primitive"
348c348
<         mkPrimDispatch(peekPrim,Prim.peekArrayAsync)
---
>         ;mkPrimDispatch ArrayEltRint(peekPrim,=Prim.peekArrayAsync)  ; peekPrim ArrayEltRint8 = Prim.peekArrayAsync ; peekPrim ArrayEltRint16 = Prim.peekArrayAsync ; peekPrim ArrayEltRint32 = Prim.peekArrayAsync ; peekPrim ArrayEltRint64 = Prim.peekArrayAsync ; peekPrim ArrayEltRword = Prim.peekArrayAsync ; peekPrim ArrayEltRword8 = Prim.peekArrayAsync ; peekPrim ArrayEltRword16 = Prim.peekArrayAsync ; peekPrim ArrayEltRword32 = Prim.peekArrayAsync ; peekPrim ArrayEltRword64 = Prim.peekArrayAsync ; peekPrim ArrayEltRfloat = Prim.peekArrayAsync ; peekPrim ArrayEltRdouble = Prim.peekArrayAsync ; peekPrim ArrayEltRbool = Prim.peekArrayAsync ; peekPrim ArrayEltRchar = Prim.peekArrayAsync ; peekPrim ArrayEltRcshort = Prim.peekArrayAsync ; peekPrim ArrayEltRcushort = Prim.peekArrayAsync ; peekPrim ArrayEltRcint = Prim.peekArrayAsync ; peekPrim ArrayEltRcuint = Prim.peekArrayAsync ; peekPrim ArrayEltRclong = Prim.peekArrayAsync ; peekPrim ArrayEltRculong = Prim.peekArrayAsync ; peekPrim ArrayEltRcllong = Prim.peekArrayAsync ; peekPrim ArrayEltRcullong = Prim.peekArrayAsync ; peekPrim ArrayEltRcfloat = Prim.peekArrayAsync ; peekPrim ArrayEltRcdouble = Prim.peekArrayAsync ; peekPrim ArrayEltRcchar = Prim.peekArrayAsync ; peekPrim ArrayEltRcschar = Prim.peekArrayAsync ; peekPrim ArrayEltRcuchar = Prim.peekArrayAsync ; peekPrim _ = error "mkPrimDispatcher: not primitive"
365c365
<         mkPrimDispatch(pokePrim,Prim.pokeArray)
---
>         ;mkPrimDispatch ArrayEltRint(pokePrim,=Prim.pokeArray)  ; pokePrim ArrayEltRint8 = Prim.pokeArray ; pokePrim ArrayEltRint16 = Prim.pokeArray ; pokePrim ArrayEltRint32 = Prim.pokeArray ; pokePrim ArrayEltRint64 = Prim.pokeArray ; pokePrim ArrayEltRword = Prim.pokeArray ; pokePrim ArrayEltRword8 = Prim.pokeArray ; pokePrim ArrayEltRword16 = Prim.pokeArray ; pokePrim ArrayEltRword32 = Prim.pokeArray ; pokePrim ArrayEltRword64 = Prim.pokeArray ; pokePrim ArrayEltRfloat = Prim.pokeArray ; pokePrim ArrayEltRdouble = Prim.pokeArray ; pokePrim ArrayEltRbool = Prim.pokeArray ; pokePrim ArrayEltRchar = Prim.pokeArray ; pokePrim ArrayEltRcshort = Prim.pokeArray ; pokePrim ArrayEltRcushort = Prim.pokeArray ; pokePrim ArrayEltRcint = Prim.pokeArray ; pokePrim ArrayEltRcuint = Prim.pokeArray ; pokePrim ArrayEltRclong = Prim.pokeArray ; pokePrim ArrayEltRculong = Prim.pokeArray ; pokePrim ArrayEltRcllong = Prim.pokeArray ; pokePrim ArrayEltRcullong = Prim.pokeArray ; pokePrim ArrayEltRcfloat = Prim.pokeArray ; pokePrim ArrayEltRcdouble = Prim.pokeArray ; pokePrim ArrayEltRcchar = Prim.pokeArray ; pokePrim ArrayEltRcschar = Prim.pokeArray ; pokePrim ArrayEltRcuchar = Prim.pokeArray ; pokePrim _ = error "mkPrimDispatcher: not primitive"
379c379
<         mkPrimDispatch(pokePrim,Prim.pokeArrayAsync)
---
>         ;mkPrimDispatch ArrayEltRint(pokePrim,=Prim.pokeArrayAsync)  ; pokePrim ArrayEltRint8 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint16 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint32 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint64 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword = Prim.pokeArrayAsync ; pokePrim ArrayEltRword8 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword16 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword32 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword64 = Prim.pokeArrayAsync ; pokePrim ArrayEltRfloat = Prim.pokeArrayAsync ; pokePrim ArrayEltRdouble = Prim.pokeArrayAsync ; pokePrim ArrayEltRbool = Prim.pokeArrayAsync ; pokePrim ArrayEltRchar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcshort = Prim.pokeArrayAsync ; pokePrim ArrayEltRcushort = Prim.pokeArrayAsync ; pokePrim ArrayEltRcint = Prim.pokeArrayAsync ; pokePrim ArrayEltRcuint = Prim.pokeArrayAsync ; pokePrim ArrayEltRclong = Prim.pokeArrayAsync ; pokePrim ArrayEltRculong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcllong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcullong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcfloat = Prim.pokeArrayAsync ; pokePrim ArrayEltRcdouble = Prim.pokeArrayAsync ; pokePrim ArrayEltRcchar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcschar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcuchar = Prim.pokeArrayAsync ; pokePrim _ = error "mkPrimDispatcher: not primitive"
394c394
<     mkPrimDispatch(wordPrim,const CUDA.devPtrToWordPtr)
---
>     ;mkPrimDispatch ArrayEltRint(wordPrim,=constCUDA.devPtrToWordPtr)  ; wordPrim ArrayEltRint8 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint16 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint32 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint64 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword8 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword16 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword32 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword64 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRfloat = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRdouble = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRbool = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRchar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcshort = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcushort = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcint = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcuint = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRclong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRculong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcllong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcullong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcfloat = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcdouble = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcchar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcschar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcuchar = const CUDA.devPtrToWordPtr ; wordPrim _ = error "mkPrimDispatcher: not primitive"
417c417
<         mkPrimDispatch(marshalPrim,Prim.marshalArrayData)
---
>         ;mkPrimDispatch ArrayEltRint(marshalPrim,=Prim.marshalArrayData)  ; marshalPrim ArrayEltRint8 = Prim.marshalArrayData ; marshalPrim ArrayEltRint16 = Prim.marshalArrayData ; marshalPrim ArrayEltRint32 = Prim.marshalArrayData ; marshalPrim ArrayEltRint64 = Prim.marshalArrayData ; marshalPrim ArrayEltRword = Prim.marshalArrayData ; marshalPrim ArrayEltRword8 = Prim.marshalArrayData ; marshalPrim ArrayEltRword16 = Prim.marshalArrayData ; marshalPrim ArrayEltRword32 = Prim.marshalArrayData ; marshalPrim ArrayEltRword64 = Prim.marshalArrayData ; marshalPrim ArrayEltRfloat = Prim.marshalArrayData ; marshalPrim ArrayEltRdouble = Prim.marshalArrayData ; marshalPrim ArrayEltRbool = Prim.marshalArrayData ; marshalPrim ArrayEltRchar = Prim.marshalArrayData ; marshalPrim ArrayEltRcshort = Prim.marshalArrayData ; marshalPrim ArrayEltRcushort = Prim.marshalArrayData ; marshalPrim ArrayEltRcint = Prim.marshalArrayData ; marshalPrim ArrayEltRcuint = Prim.marshalArrayData ; marshalPrim ArrayEltRclong = Prim.marshalArrayData ; marshalPrim ArrayEltRculong = Prim.marshalArrayData ; marshalPrim ArrayEltRcllong = Prim.marshalArrayData ; marshalPrim ArrayEltRcullong = Prim.marshalArrayData ; marshalPrim ArrayEltRcfloat = Prim.marshalArrayData ; marshalPrim ArrayEltRcdouble = Prim.marshalArrayData ; marshalPrim ArrayEltRcchar = Prim.marshalArrayData ; marshalPrim ArrayEltRcschar = Prim.marshalArrayData ; marshalPrim ArrayEltRcuchar = Prim.marshalArrayData ; marshalPrim _ = error "mkPrimDispatcher: not primitive"
440c440
<         mkPrimDispatch(marshalPrim,Prim.marshalTextureData)
---
>         ;mkPrimDispatch ArrayEltRint(marshalPrim,=Prim.marshalTextureData)  ; marshalPrim ArrayEltRint8 = Prim.marshalTextureData ; marshalPrim ArrayEltRint16 = Prim.marshalTextureData ; marshalPrim ArrayEltRint32 = Prim.marshalTextureData ; marshalPrim ArrayEltRint64 = Prim.marshalTextureData ; marshalPrim ArrayEltRword = Prim.marshalTextureData ; marshalPrim ArrayEltRword8 = Prim.marshalTextureData ; marshalPrim ArrayEltRword16 = Prim.marshalTextureData ; marshalPrim ArrayEltRword32 = Prim.marshalTextureData ; marshalPrim ArrayEltRword64 = Prim.marshalTextureData ; marshalPrim ArrayEltRfloat = Prim.marshalTextureData ; marshalPrim ArrayEltRdouble = Prim.marshalTextureData ; marshalPrim ArrayEltRbool = Prim.marshalTextureData ; marshalPrim ArrayEltRchar = Prim.marshalTextureData ; marshalPrim ArrayEltRcshort = Prim.marshalTextureData ; marshalPrim ArrayEltRcushort = Prim.marshalTextureData ; marshalPrim ArrayEltRcint = Prim.marshalTextureData ; marshalPrim ArrayEltRcuint = Prim.marshalTextureData ; marshalPrim ArrayEltRclong = Prim.marshalTextureData ; marshalPrim ArrayEltRculong = Prim.marshalTextureData ; marshalPrim ArrayEltRcllong = Prim.marshalTextureData ; marshalPrim ArrayEltRcullong = Prim.marshalTextureData ; marshalPrim ArrayEltRcfloat = Prim.marshalTextureData ; marshalPrim ArrayEltRcdouble = Prim.marshalTextureData ; marshalPrim ArrayEltRcchar = Prim.marshalTextureData ; marshalPrim ArrayEltRcschar = Prim.marshalTextureData ; marshalPrim ArrayEltRcuchar = Prim.marshalTextureData ; marshalPrim _ = error "mkPrimDispatcher: not primitive"
457c457
<         mkPrimDispatch(ptrsPrim,Prim.devicePtrsOfArrayData)
---
>         ;mkPrimDispatch ArrayEltRint(ptrsPrim,=Prim.devicePtrsOfArrayData)  ; ptrsPrim ArrayEltRint8 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint16 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint32 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint64 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword8 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword16 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword32 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword64 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRfloat = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRdouble = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRbool = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRchar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcshort = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcushort = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcint = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcuint = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRclong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRculong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcllong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcullong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcfloat = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcdouble = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcchar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcschar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcuchar = Prim.devicePtrsOfArrayData ; ptrsPrim _ = error "mkPrimDispatcher: not primitive"
472c472
<     mkPrimDispatch(advancePrim,Prim.advancePtrsOfArrayData n)
---
>     ;mkPrimDispatch ArrayEltRint(advancePrim,=Prim.advancePtrsOfArrayDatan)n ; advancePrim ArrayEltRint8 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint16 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint32 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint64 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword8 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword16 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword32 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword64 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRfloat = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRdouble = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRbool = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRchar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcshort = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcushort = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcint = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcuint = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRclong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRculong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcllong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcullong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcfloat = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcdouble = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcchar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcschar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcuchar = Prim.advancePtrsOfArrayData n ; advancePrim _ = error "mkPrimDispatcher: not primitive"
473a474
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE BangPatterns        #-}
{-# LANGUAGE CPP                 #-}
{-# LANGUAGE GADTs               #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE TypeFamilies        #-}
-- |
-- Module      : Data.Array.Accelerate.CUDA.Array.Data
-- Copyright   : [2008..2014] Manuel M T Chakravarty, Gabriele Keller
--               [2009..2014] Trevor L. McDonell
--               [2013..2014] Robert Clifton-Everest
-- License     : BSD3
--
-- Maintainer  : Trevor L. McDonell <tmcdonell@cse.unsw.edu.au>
-- Stability   : experimental
-- Portability : non-portable (GHC extensions)
--

module Data.Array.Accelerate.CUDA.Array.Data (

  -- * Array operations and representations
  mallocArray, indexArray,
  useArray,  useArrayAsync,
  useDevicePtrs,
  copyArray, copyArrayAsync, copyArrayPeer, copyArrayPeerAsync,
  peekArray, peekArrayAsync,
  pokeArray, pokeArrayAsync,
  marshalArrayData, marshalTextureData, marshalDevicePtrs,
  devicePtrsOfArrayData, advancePtrsOfArrayData,
  devicePtrsFromList, devicePtrsToWordPtrs,

  -- * Garbage collection
  cleanupArrayData

) where

-- libraries
import Prelude                                          hiding ( fst, snd )
import qualified Prelude                                as P
import Control.Applicative
import Control.Monad.Reader                             ( asks )
import Control.Monad.State                              ( gets )
import Control.Monad.Trans                              ( liftIO )
import Foreign.C.Types
import Foreign.Ptr

-- friends
import Data.Array.Accelerate.Error
import Data.Array.Accelerate.Array.Data
import Data.Array.Accelerate.Array.Sugar                ( Array(..), Shape, Elt, toElt, EltRepr )
import Data.Array.Accelerate.Array.Representation       ( size )
import Data.Array.Accelerate.CUDA.State
import Data.Array.Accelerate.CUDA.Array.Table
import qualified Data.Array.Accelerate.CUDA.Array.Prim  as Prim
import qualified Foreign.CUDA.Driver                    as CUDA
import qualified Foreign.CUDA.Driver.Stream             as CUDA
import qualified Foreign.CUDA.Driver.Texture            as CUDA


-- Array Operations
-- ----------------

-- Garbage collection
--
cleanupArrayData :: CIO ()
cleanupArrayData = liftIO . reclaim =<< gets memoryTable

-- Array tuple extraction
--
fst :: ArrayData (a,b) -> ArrayData a
fst = fstArrayData

snd :: ArrayData (a,b) -> ArrayData b
snd = sndArrayData

-- Extract the state information to pass along to the primitive data handlers
--
{-# INLINE run #-}
run :: (Context -> MemoryTable -> IO a) -> CIO a
run f = do
  ctx    <- asks activeContext
  mt     <- gets memoryTable
  liftIO $! f ctx mt

-- CPP hackery to generate the cases where we dispatch to the worker function handling
-- elementary types.
--
#define mkPrimDispatch(dispatcher,worker)                                       \
; dispatcher ArrayEltRint     = worker                                          \
; dispatcher ArrayEltRint8    = worker                                          \
; dispatcher ArrayEltRint16   = worker                                          \
; dispatcher ArrayEltRint32   = worker                                          \
; dispatcher ArrayEltRint64   = worker                                          \
; dispatcher ArrayEltRword    = worker                                          \
; dispatcher ArrayEltRword8   = worker                                          \
; dispatcher ArrayEltRword16  = worker                                          \
; dispatcher ArrayEltRword32  = worker                                          \
; dispatcher ArrayEltRword64  = worker                                          \
; dispatcher ArrayEltRfloat   = worker                                          \
; dispatcher ArrayEltRdouble  = worker                                          \
; dispatcher ArrayEltRbool    = worker                                          \
; dispatcher ArrayEltRchar    = worker                                          \
; dispatcher ArrayEltRcshort  = worker                                          \
; dispatcher ArrayEltRcushort = worker                                          \
; dispatcher ArrayEltRcint    = worker                                          \
; dispatcher ArrayEltRcuint   = worker                                          \
; dispatcher ArrayEltRclong   = worker                                          \
; dispatcher ArrayEltRculong  = worker                                          \
; dispatcher ArrayEltRcllong  = worker                                          \
; dispatcher ArrayEltRcullong = worker                                          \
; dispatcher ArrayEltRcfloat  = worker                                          \
; dispatcher ArrayEltRcdouble = worker                                          \
; dispatcher ArrayEltRcchar   = worker                                          \
; dispatcher ArrayEltRcschar  = worker                                          \
; dispatcher ArrayEltRcuchar  = worker                                          \
; dispatcher _                = error "mkPrimDispatcher: not primitive"


-- |Allocate a new device array to accompany the given host-side array.
--
mallocArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
mallocArray (Array !sh !adata) = run doMalloc
  where
    !n                = size sh
    doMalloc !ctx !mt = mallocR arrayElt adata
      where
        mallocR :: ArrayEltR e -> ArrayData e -> IO ()
        mallocR ArrayEltRunit             _  = return ()
        mallocR (ArrayEltRpair aeR1 aeR2) ad = mallocR aeR1 (fst ad) >> mallocR aeR2 (snd ad)
        mallocR aer                       ad = mallocPrim aer ctx mt ad n
        --
        mallocPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        mkPrimDispatch(mallocPrim,Prim.mallocArray)


-- |Upload an existing array to the device
--
useArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
useArray (Array !sh !adata) = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = useR arrayElt adata
      where
        useR :: ArrayEltR e -> ArrayData e -> IO ()
        useR ArrayEltRunit             _  = return ()
        useR (ArrayEltRpair aeR1 aeR2) ad = useR aeR1 (fst ad) >> useR aeR2 (snd ad)
        useR aer                       ad = usePrim aer ctx mt ad n
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        mkPrimDispatch(usePrim,Prim.useArray)

useArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
useArrayAsync (Array !sh !adata) ms = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = useR arrayElt adata
      where
        useR :: ArrayEltR e -> ArrayData e -> IO ()
        useR ArrayEltRunit             _  = return ()
        useR (ArrayEltRpair aeR1 aeR2) ad = useR aeR1 (fst ad) >> useR aeR2 (snd ad)
        useR aer                       ad = usePrim aer ctx mt ad n ms
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        mkPrimDispatch(usePrim,Prim.useArrayAsync)


useDevicePtrs :: (Shape sh, Elt e) => EltRepr sh -> Prim.DevicePtrs (EltRepr e) -> CIO (Array sh e)
useDevicePtrs sh ptrs = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = Array sh <$> useD arrayElt ptrs
      where
        useD :: ArrayEltR e -> Prim.DevicePtrs e -> IO (ArrayData e)
        useD ArrayEltRunit             _  = return AD_Unit
        useD (ArrayEltRpair aeR1 aeR2) ps = AD_Pair <$> useD aeR1 (P.fst ps)
                                                    <*> useD aeR2 (P.snd ps)
        useD aer                       ps = usePrim aer ctx mt ps n
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> Prim.DevicePtrs e -> Int -> IO (ArrayData e)
        mkPrimDispatch(usePrim,Prim.useDevicePtrs)

devicePtrsFromList :: ArrayEltR e -> [WordPtr] -> Prim.DevicePtrs e
devicePtrsFromList aeR = P.fst . (devP aeR)
  where
    devP :: ArrayEltR e -> [WordPtr] -> (Prim.DevicePtrs e, [WordPtr])
    devP ArrayEltRunit             ps     = ((),ps)
    devP (ArrayEltRpair aeR1 aeR2) ps     = let
        (d1, ps')  = devP aeR1 ps
        (d2, ps'') = devP aeR2 ps'
      in ((d1,d2), ps'')
    devP aer                       (p:ps) = (devPrim aer p, ps)
    devP _                         []     = error "devicePtrsFromList: incorrect number of device pointers for element type"
    --
    devPrim :: ArrayEltR e -> WordPtr -> Prim.DevicePtrs e
    mkPrimDispatch(devPrim,CUDA.wordPtrToDevPtr)


-- |Read a single element from an array at the given row-major index. This is a
-- synchronous operation.
--
indexArray :: (Shape dim, Elt e) => Array dim e -> Int -> CIO e
indexArray (Array _ !adata) i = run doIndex
  where
    doIndex !ctx !mt = toElt <$> indexR arrayElt adata
      where
        indexR :: ArrayEltR e -> ArrayData e -> IO e
        indexR ArrayEltRunit             _  = return ()
        indexR (ArrayEltRpair aeR1 aeR2) ad = (,) <$> indexR aeR1 (fst ad)
                                                  <*> indexR aeR2 (snd ad)
        --
        indexR ArrayEltRint              ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint8             ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint16            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint32            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint64            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword             ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword8            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword16           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword32           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword64           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRfloat            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRdouble           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRchar             ad = Prim.indexArray ctx mt ad i
        --
        indexR ArrayEltRcshort           ad = CShort  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcushort          ad = CUShort <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcint             ad = CInt    <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcuint            ad = CUInt   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRclong            ad = CLong   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRculong           ad = CULong  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcllong           ad = CLLong  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcullong          ad = CULLong <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcchar            ad = CChar   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcschar           ad = CSChar  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcuchar           ad = CUChar  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcfloat           ad = CFloat  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcdouble          ad = CDouble <$> Prim.indexArray ctx mt ad i
        --
        indexR ArrayEltRbool             ad = toBool  <$> Prim.indexArray ctx mt ad i
          where toBool 0 = False
                toBool _ = True


-- |Copy data between two device arrays. The operation is asynchronous with
-- respect to the host, but will never overlap kernel execution.
--
copyArray :: (Shape dim, Elt e) => Array dim e -> Array dim e -> CIO ()
copyArray (Array !sh1 !adata1) (Array !sh2 !adata2)
  = $boundsCheck "copyArray" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n              = size sh1
    doCopy !ctx !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer ctx mt ad1 ad2 n
        --
        copyPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> ArrayData e -> Int -> IO ()
        mkPrimDispatch(copyPrim,Prim.copyArray)

copyArrayAsync :: (Shape dim, Elt e) => Array dim e -> Array dim e -> Maybe CUDA.Stream -> CIO ()
copyArrayAsync (Array !sh1 !adata1) (Array !sh2 !adata2) ms
  = $boundsCheck "copyArrayAsync" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n              = size sh1
    doCopy !ctx !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer ctx mt ad1 ad2 n ms
        --
        copyPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        mkPrimDispatch(copyPrim,Prim.copyArrayAsync)


-- |Copy data between two device arrays which reside in different contexts. This
-- might entail copying between devices.
--
copyArrayPeer :: (Shape dim, Elt e) => Array dim e -> Context -> Array dim e -> Context -> CIO ()
copyArrayPeer (Array !sh1 !adata1) !ctxSrc (Array !sh2 !adata2) !ctxDst
  = $boundsCheck "copyArrayPeer" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n           = size sh1
    doCopy _ !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer mt ad1 ctxSrc ad2 ctxDst n
        --
        copyPrim :: ArrayEltR e -> MemoryTable -> ArrayData e -> Context -> ArrayData e -> Context -> Int -> IO ()
        mkPrimDispatch(copyPrim,Prim.copyArrayPeer)

copyArrayPeerAsync :: (Shape dim, Elt e) => Array dim e -> Context -> Array dim e -> Context -> Maybe CUDA.Stream -> CIO ()
copyArrayPeerAsync (Array !sh1 !adata1) !ctxSrc (Array !sh2 !adata2) !ctxDst !ms
  = $boundsCheck "copyArrayPeerAsync" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n           = size sh1
    doCopy _ !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer mt ad1 ctxSrc ad2 ctxDst n ms
        --
        copyPrim :: ArrayEltR e -> MemoryTable -> ArrayData e -> Context -> ArrayData e -> Context -> Int -> Maybe CUDA.Stream -> IO ()
        mkPrimDispatch(copyPrim,Prim.copyArrayPeerAsync)


-- Copy data from the device into the associated Accelerate host-side array
--
peekArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
peekArray (Array !sh !adata) = run doPeek
  where
    !n              = size sh
    doPeek !ctx !mt = peekR arrayElt adata
      where
        peekR :: ArrayEltR e -> ArrayData e -> IO ()
        peekR ArrayEltRunit             _  = return ()
        peekR (ArrayEltRpair aeR1 aeR2) ad = peekR aeR1 (fst ad) >> peekR aeR2 (snd ad)
        peekR aer                       ad = peekPrim aer ctx mt ad n
        --
        peekPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        mkPrimDispatch(peekPrim,Prim.peekArray)

peekArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
peekArrayAsync (Array !sh !adata) !ms = run doPeek
  where
    !n              = size sh
    doPeek !ctx !mt = peekR arrayElt adata
      where
        peekR :: ArrayEltR e -> ArrayData e -> IO ()
        peekR ArrayEltRunit             _  = return ()
        peekR (ArrayEltRpair aeR1 aeR2) ad = peekR aeR1 (fst ad) >> peekR aeR2 (snd ad)
        peekR aer                       ad = peekPrim aer ctx mt ad n ms
        --
        peekPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        mkPrimDispatch(peekPrim,Prim.peekArrayAsync)


-- Copy data from an Accelerate array into the associated device array
--
pokeArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
pokeArray (Array !sh !adata) = run doPoke
  where
    !n              = size sh
    doPoke !ctx !mt = pokeR arrayElt adata
      where
        pokeR :: ArrayEltR e -> ArrayData e -> IO ()
        pokeR ArrayEltRunit             _  = return ()
        pokeR (ArrayEltRpair aeR1 aeR2) ad = pokeR aeR1 (fst ad) >> pokeR aeR2 (snd ad)
        pokeR aer                       ad = pokePrim aer ctx mt ad n
        --
        pokePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        mkPrimDispatch(pokePrim,Prim.pokeArray)

pokeArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
pokeArrayAsync (Array !sh !adata) !ms = run doPoke
  where
    !n              = size sh
    doPoke !ctx !mt = pokeR arrayElt adata
      where
        pokeR :: ArrayEltR e -> ArrayData e -> IO ()
        pokeR ArrayEltRunit             _  = return ()
        pokeR (ArrayEltRpair aeR1 aeR2) ad = pokeR aeR1 (fst ad) >> pokeR aeR2 (snd ad)
        pokeR aer                       ad = pokePrim aer ctx mt ad n ms
        --
        pokePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        mkPrimDispatch(pokePrim,Prim.pokeArrayAsync)


-- |Convert the device pointers into a list of word pointers
--
devicePtrsToWordPtrs :: ArrayElt e => ArrayData e -> Prim.DevicePtrs e -> [WordPtr]
devicePtrsToWordPtrs !adata = wordR arrayElt adata
  where
    wordR :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> [WordPtr]
    wordR ArrayEltRunit             _  _       = []
    wordR (ArrayEltRpair aeR1 aeR2) ad (p1,p2) = wordR aeR1 (fst ad) p1 ++
                                                 wordR aeR2 (snd ad) p2
    wordR aer                       ad ptr     = [wordPrim aer ad ptr]
    --
    wordPrim :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> WordPtr
    mkPrimDispatch(wordPrim,const CUDA.devPtrToWordPtr)

-- |Wrap device pointers into arguments that can be passed to a kernel
-- invocation
--
marshalDevicePtrs :: ArrayElt e => ArrayData e -> Prim.DevicePtrs e -> [CUDA.FunParam]
marshalDevicePtrs !adata ptrs = map (CUDA.VArg . CUDA.wordPtrToDevPtr) $ devicePtrsToWordPtrs adata ptrs

-- |Wrap the device pointers corresponding to a host-side array into arguments
-- that can be passed to a kernel upon invocation.
--
marshalArrayData :: ArrayElt e => ArrayData e -> CIO [CUDA.FunParam]
marshalArrayData !adata = run doMarshal
  where
    doMarshal !ctx !mt = marshalR arrayElt adata
      where
        marshalR :: ArrayEltR e -> ArrayData e -> IO [CUDA.FunParam]
        marshalR ArrayEltRunit             _  = return []
        marshalR (ArrayEltRpair aeR1 aeR2) ad = (++) <$> marshalR aeR1 (fst ad)
                                                     <*> marshalR aeR2 (snd ad)
        marshalR aer                       ad = return <$> marshalPrim aer ctx mt ad
        --
        marshalPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> IO CUDA.FunParam
        mkPrimDispatch(marshalPrim,Prim.marshalArrayData)


-- |Bind the device memory arrays to the given texture reference(s), setting
-- appropriate type. The arrays are bound, and the list of textures thereby
-- consumed, in projection index order --- i.e. right-to-left
--
marshalTextureData :: ArrayElt e => ArrayData e -> Int -> [CUDA.Texture] -> CIO ()
marshalTextureData !adata !n !texs = run doMarshal
  where
    doMarshal !ctx !mt = marshalR arrayElt adata texs >> return ()
      where
        marshalR :: ArrayEltR e -> ArrayData e -> [CUDA.Texture] -> IO Int
        marshalR ArrayEltRunit             _  _ = return 0
        marshalR (ArrayEltRpair aeR1 aeR2) ad t
          = do r <- marshalR aeR2 (snd ad) t
               l <- marshalR aeR1 (fst ad) (drop r t)
               return (l + r)
        marshalR aer                       ad t
          = do marshalPrim aer ctx mt ad n (head t)
               return 1
        --
        marshalPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> CUDA.Texture -> IO ()
        mkPrimDispatch(marshalPrim,Prim.marshalTextureData)


-- |Raw device pointers associated with a host-side array
--
devicePtrsOfArrayData :: ArrayElt e => ArrayData e -> CIO (Prim.DevicePtrs e)
devicePtrsOfArrayData !adata = run ptrs
  where
    ptrs !ctx !mt = ptrsR arrayElt adata
      where
        ptrsR :: ArrayEltR e -> ArrayData e -> IO (Prim.DevicePtrs e)
        ptrsR ArrayEltRunit             _  = return ()
        ptrsR (ArrayEltRpair aeR1 aeR2) ad = (,) <$> ptrsR aeR1 (fst ad)
                                                 <*> ptrsR aeR2 (snd ad)
        ptrsR aer                       ad = ptrsPrim aer ctx mt ad
        --
        ptrsPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> IO (Prim.DevicePtrs e)
        mkPrimDispatch(ptrsPrim,Prim.devicePtrsOfArrayData)


-- |Advance a set of device pointers by the given number of elements each
--
advancePtrsOfArrayData :: ArrayElt e => ArrayData e -> Int -> Prim.DevicePtrs e -> Prim.DevicePtrs e
advancePtrsOfArrayData !adata !n = advanceR arrayElt adata
  where
    advanceR :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> Prim.DevicePtrs e
    advanceR ArrayEltRunit             _  _       = ()
    advanceR (ArrayEltRpair aeR1 aeR2) ad (p1,p2) = (advanceR aeR1 (fst ad) p1
                                                    ,advanceR aeR2 (snd ad) p2)
    advanceR aer                       ad ptr     = advancePrim aer ad ptr
    --
    advancePrim :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> Prim.DevicePtrs e
    mkPrimDispatch(advancePrim,Prim.advancePtrsOfArrayData n)

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE BangPatterns        #-}
{-# LANGUAGE CPP                 #-}
{-# LANGUAGE GADTs               #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE TypeFamilies        #-}
-- |
-- Module      : Data.Array.Accelerate.CUDA.Array.Data
-- Copyright   : [2008..2014] Manuel M T Chakravarty, Gabriele Keller
--               [2009..2014] Trevor L. McDonell
--               [2013..2014] Robert Clifton-Everest
-- License     : BSD3
--
-- Maintainer  : Trevor L. McDonell <tmcdonell@cse.unsw.edu.au>
-- Stability   : experimental
-- Portability : non-portable (GHC extensions)
--

module Data.Array.Accelerate.CUDA.Array.Data (

  -- * Array operations and representations
  mallocArray, indexArray,
  useArray,  useArrayAsync,
  useDevicePtrs,
  copyArray, copyArrayAsync, copyArrayPeer, copyArrayPeerAsync,
  peekArray, peekArrayAsync,
  pokeArray, pokeArrayAsync,
  marshalArrayData, marshalTextureData, marshalDevicePtrs,
  devicePtrsOfArrayData, advancePtrsOfArrayData,
  devicePtrsFromList, devicePtrsToWordPtrs,

  -- * Garbage collection
  cleanupArrayData

) where

-- libraries
import Prelude                                          hiding ( fst, snd )
import qualified Prelude                                as P
import Control.Applicative
import Control.Monad.Reader                             ( asks )
import Control.Monad.State                              ( gets )
import Control.Monad.Trans                              ( liftIO )
import Foreign.C.Types
import Foreign.Ptr

-- friends
import Data.Array.Accelerate.Error
import Data.Array.Accelerate.Array.Data
import Data.Array.Accelerate.Array.Sugar                ( Array(..), Shape, Elt, toElt, EltRepr )
import Data.Array.Accelerate.Array.Representation       ( size )
import Data.Array.Accelerate.CUDA.State
import Data.Array.Accelerate.CUDA.Array.Table
import qualified Data.Array.Accelerate.CUDA.Array.Prim  as Prim
import qualified Foreign.CUDA.Driver                    as CUDA
import qualified Foreign.CUDA.Driver.Stream             as CUDA
import qualified Foreign.CUDA.Driver.Texture            as CUDA


-- Array Operations
-- ----------------

-- Garbage collection
--
cleanupArrayData :: CIO ()
cleanupArrayData = liftIO . reclaim =<< gets memoryTable

-- Array tuple extraction
--
fst :: ArrayData (a,b) -> ArrayData a
fst = fstArrayData

snd :: ArrayData (a,b) -> ArrayData b
snd = sndArrayData

-- Extract the state information to pass along to the primitive data handlers
--
{-# INLINE run #-}
run :: (Context -> MemoryTable -> IO a) -> CIO a
run f = do
  ctx    <- asks activeContext
  mt     <- gets memoryTable
  liftIO $! f ctx mt

-- CPP hackery to generate the cases where we dispatch to the worker function handling
-- elementary types.
--
#define mkPrimDispatch(dispatcher,worker)                                       \
; dispatcher ArrayEltRint     = worker                                          \
; dispatcher ArrayEltRint8    = worker                                          \
; dispatcher ArrayEltRint16   = worker                                          \
; dispatcher ArrayEltRint32   = worker                                          \
; dispatcher ArrayEltRint64   = worker                                          \
; dispatcher ArrayEltRword    = worker                                          \
; dispatcher ArrayEltRword8   = worker                                          \
; dispatcher ArrayEltRword16  = worker                                          \
; dispatcher ArrayEltRword32  = worker                                          \
; dispatcher ArrayEltRword64  = worker                                          \
; dispatcher ArrayEltRfloat   = worker                                          \
; dispatcher ArrayEltRdouble  = worker                                          \
; dispatcher ArrayEltRbool    = worker                                          \
; dispatcher ArrayEltRchar    = worker                                          \
; dispatcher ArrayEltRcshort  = worker                                          \
; dispatcher ArrayEltRcushort = worker                                          \
; dispatcher ArrayEltRcint    = worker                                          \
; dispatcher ArrayEltRcuint   = worker                                          \
; dispatcher ArrayEltRclong   = worker                                          \
; dispatcher ArrayEltRculong  = worker                                          \
; dispatcher ArrayEltRcllong  = worker                                          \
; dispatcher ArrayEltRcullong = worker                                          \
; dispatcher ArrayEltRcfloat  = worker                                          \
; dispatcher ArrayEltRcdouble = worker                                          \
; dispatcher ArrayEltRcchar   = worker                                          \
; dispatcher ArrayEltRcschar  = worker                                          \
; dispatcher ArrayEltRcuchar  = worker                                          \
; dispatcher _                = error "mkPrimDispatcher: not primitive"


-- |Allocate a new device array to accompany the given host-side array.
--
mallocArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
mallocArray (Array !sh !adata) = run doMalloc
  where
    !n                = size sh
    doMalloc !ctx !mt = mallocR arrayElt adata
      where
        mallocR :: ArrayEltR e -> ArrayData e -> IO ()
        mallocR ArrayEltRunit             _  = return ()
        mallocR (ArrayEltRpair aeR1 aeR2) ad = mallocR aeR1 (fst ad) >> mallocR aeR2 (snd ad)
        mallocR aer                       ad = mallocPrim aer ctx mt ad n
        --
        mallocPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(mallocPrim,=Prim.mallocArray)  ; mallocPrim ArrayEltRint8 = Prim.mallocArray ; mallocPrim ArrayEltRint16 = Prim.mallocArray ; mallocPrim ArrayEltRint32 = Prim.mallocArray ; mallocPrim ArrayEltRint64 = Prim.mallocArray ; mallocPrim ArrayEltRword = Prim.mallocArray ; mallocPrim ArrayEltRword8 = Prim.mallocArray ; mallocPrim ArrayEltRword16 = Prim.mallocArray ; mallocPrim ArrayEltRword32 = Prim.mallocArray ; mallocPrim ArrayEltRword64 = Prim.mallocArray ; mallocPrim ArrayEltRfloat = Prim.mallocArray ; mallocPrim ArrayEltRdouble = Prim.mallocArray ; mallocPrim ArrayEltRbool = Prim.mallocArray ; mallocPrim ArrayEltRchar = Prim.mallocArray ; mallocPrim ArrayEltRcshort = Prim.mallocArray ; mallocPrim ArrayEltRcushort = Prim.mallocArray ; mallocPrim ArrayEltRcint = Prim.mallocArray ; mallocPrim ArrayEltRcuint = Prim.mallocArray ; mallocPrim ArrayEltRclong = Prim.mallocArray ; mallocPrim ArrayEltRculong = Prim.mallocArray ; mallocPrim ArrayEltRcllong = Prim.mallocArray ; mallocPrim ArrayEltRcullong = Prim.mallocArray ; mallocPrim ArrayEltRcfloat = Prim.mallocArray ; mallocPrim ArrayEltRcdouble = Prim.mallocArray ; mallocPrim ArrayEltRcchar = Prim.mallocArray ; mallocPrim ArrayEltRcschar = Prim.mallocArray ; mallocPrim ArrayEltRcuchar = Prim.mallocArray ; mallocPrim _ = error "mkPrimDispatcher: not primitive"


-- |Upload an existing array to the device
--
useArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
useArray (Array !sh !adata) = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = useR arrayElt adata
      where
        useR :: ArrayEltR e -> ArrayData e -> IO ()
        useR ArrayEltRunit             _  = return ()
        useR (ArrayEltRpair aeR1 aeR2) ad = useR aeR1 (fst ad) >> useR aeR2 (snd ad)
        useR aer                       ad = usePrim aer ctx mt ad n
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useArray)  ; usePrim ArrayEltRint8 = Prim.useArray ; usePrim ArrayEltRint16 = Prim.useArray ; usePrim ArrayEltRint32 = Prim.useArray ; usePrim ArrayEltRint64 = Prim.useArray ; usePrim ArrayEltRword = Prim.useArray ; usePrim ArrayEltRword8 = Prim.useArray ; usePrim ArrayEltRword16 = Prim.useArray ; usePrim ArrayEltRword32 = Prim.useArray ; usePrim ArrayEltRword64 = Prim.useArray ; usePrim ArrayEltRfloat = Prim.useArray ; usePrim ArrayEltRdouble = Prim.useArray ; usePrim ArrayEltRbool = Prim.useArray ; usePrim ArrayEltRchar = Prim.useArray ; usePrim ArrayEltRcshort = Prim.useArray ; usePrim ArrayEltRcushort = Prim.useArray ; usePrim ArrayEltRcint = Prim.useArray ; usePrim ArrayEltRcuint = Prim.useArray ; usePrim ArrayEltRclong = Prim.useArray ; usePrim ArrayEltRculong = Prim.useArray ; usePrim ArrayEltRcllong = Prim.useArray ; usePrim ArrayEltRcullong = Prim.useArray ; usePrim ArrayEltRcfloat = Prim.useArray ; usePrim ArrayEltRcdouble = Prim.useArray ; usePrim ArrayEltRcchar = Prim.useArray ; usePrim ArrayEltRcschar = Prim.useArray ; usePrim ArrayEltRcuchar = Prim.useArray ; usePrim _ = error "mkPrimDispatcher: not primitive"

useArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
useArrayAsync (Array !sh !adata) ms = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = useR arrayElt adata
      where
        useR :: ArrayEltR e -> ArrayData e -> IO ()
        useR ArrayEltRunit             _  = return ()
        useR (ArrayEltRpair aeR1 aeR2) ad = useR aeR1 (fst ad) >> useR aeR2 (snd ad)
        useR aer                       ad = usePrim aer ctx mt ad n ms
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useArrayAsync)  ; usePrim ArrayEltRint8 = Prim.useArrayAsync ; usePrim ArrayEltRint16 = Prim.useArrayAsync ; usePrim ArrayEltRint32 = Prim.useArrayAsync ; usePrim ArrayEltRint64 = Prim.useArrayAsync ; usePrim ArrayEltRword = Prim.useArrayAsync ; usePrim ArrayEltRword8 = Prim.useArrayAsync ; usePrim ArrayEltRword16 = Prim.useArrayAsync ; usePrim ArrayEltRword32 = Prim.useArrayAsync ; usePrim ArrayEltRword64 = Prim.useArrayAsync ; usePrim ArrayEltRfloat = Prim.useArrayAsync ; usePrim ArrayEltRdouble = Prim.useArrayAsync ; usePrim ArrayEltRbool = Prim.useArrayAsync ; usePrim ArrayEltRchar = Prim.useArrayAsync ; usePrim ArrayEltRcshort = Prim.useArrayAsync ; usePrim ArrayEltRcushort = Prim.useArrayAsync ; usePrim ArrayEltRcint = Prim.useArrayAsync ; usePrim ArrayEltRcuint = Prim.useArrayAsync ; usePrim ArrayEltRclong = Prim.useArrayAsync ; usePrim ArrayEltRculong = Prim.useArrayAsync ; usePrim ArrayEltRcllong = Prim.useArrayAsync ; usePrim ArrayEltRcullong = Prim.useArrayAsync ; usePrim ArrayEltRcfloat = Prim.useArrayAsync ; usePrim ArrayEltRcdouble = Prim.useArrayAsync ; usePrim ArrayEltRcchar = Prim.useArrayAsync ; usePrim ArrayEltRcschar = Prim.useArrayAsync ; usePrim ArrayEltRcuchar = Prim.useArrayAsync ; usePrim _ = error "mkPrimDispatcher: not primitive"


useDevicePtrs :: (Shape sh, Elt e) => EltRepr sh -> Prim.DevicePtrs (EltRepr e) -> CIO (Array sh e)
useDevicePtrs sh ptrs = run doUse
  where
    !n             = size sh
    doUse !ctx !mt = Array sh <$> useD arrayElt ptrs
      where
        useD :: ArrayEltR e -> Prim.DevicePtrs e -> IO (ArrayData e)
        useD ArrayEltRunit             _  = return AD_Unit
        useD (ArrayEltRpair aeR1 aeR2) ps = AD_Pair <$> useD aeR1 (P.fst ps)
                                                    <*> useD aeR2 (P.snd ps)
        useD aer                       ps = usePrim aer ctx mt ps n
        --
        usePrim :: ArrayEltR e -> Context -> MemoryTable -> Prim.DevicePtrs e -> Int -> IO (ArrayData e)
        ;mkPrimDispatch ArrayEltRint(usePrim,=Prim.useDevicePtrs)  ; usePrim ArrayEltRint8 = Prim.useDevicePtrs ; usePrim ArrayEltRint16 = Prim.useDevicePtrs ; usePrim ArrayEltRint32 = Prim.useDevicePtrs ; usePrim ArrayEltRint64 = Prim.useDevicePtrs ; usePrim ArrayEltRword = Prim.useDevicePtrs ; usePrim ArrayEltRword8 = Prim.useDevicePtrs ; usePrim ArrayEltRword16 = Prim.useDevicePtrs ; usePrim ArrayEltRword32 = Prim.useDevicePtrs ; usePrim ArrayEltRword64 = Prim.useDevicePtrs ; usePrim ArrayEltRfloat = Prim.useDevicePtrs ; usePrim ArrayEltRdouble = Prim.useDevicePtrs ; usePrim ArrayEltRbool = Prim.useDevicePtrs ; usePrim ArrayEltRchar = Prim.useDevicePtrs ; usePrim ArrayEltRcshort = Prim.useDevicePtrs ; usePrim ArrayEltRcushort = Prim.useDevicePtrs ; usePrim ArrayEltRcint = Prim.useDevicePtrs ; usePrim ArrayEltRcuint = Prim.useDevicePtrs ; usePrim ArrayEltRclong = Prim.useDevicePtrs ; usePrim ArrayEltRculong = Prim.useDevicePtrs ; usePrim ArrayEltRcllong = Prim.useDevicePtrs ; usePrim ArrayEltRcullong = Prim.useDevicePtrs ; usePrim ArrayEltRcfloat = Prim.useDevicePtrs ; usePrim ArrayEltRcdouble = Prim.useDevicePtrs ; usePrim ArrayEltRcchar = Prim.useDevicePtrs ; usePrim ArrayEltRcschar = Prim.useDevicePtrs ; usePrim ArrayEltRcuchar = Prim.useDevicePtrs ; usePrim _ = error "mkPrimDispatcher: not primitive"

devicePtrsFromList :: ArrayEltR e -> [WordPtr] -> Prim.DevicePtrs e
devicePtrsFromList aeR = P.fst . (devP aeR)
  where
    devP :: ArrayEltR e -> [WordPtr] -> (Prim.DevicePtrs e, [WordPtr])
    devP ArrayEltRunit             ps     = ((),ps)
    devP (ArrayEltRpair aeR1 aeR2) ps     = let
        (d1, ps')  = devP aeR1 ps
        (d2, ps'') = devP aeR2 ps'
      in ((d1,d2), ps'')
    devP aer                       (p:ps) = (devPrim aer p, ps)
    devP _                         []     = error "devicePtrsFromList: incorrect number of device pointers for element type"
    --
    devPrim :: ArrayEltR e -> WordPtr -> Prim.DevicePtrs e
    ;mkPrimDispatch ArrayEltRint(devPrim,=CUDA.wordPtrToDevPtr)  ; devPrim ArrayEltRint8 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint16 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint32 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRint64 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword8 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword16 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword32 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRword64 = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRfloat = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRdouble = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRbool = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRchar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcshort = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcushort = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcint = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcuint = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRclong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRculong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcllong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcullong = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcfloat = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcdouble = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcchar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcschar = CUDA.wordPtrToDevPtr ; devPrim ArrayEltRcuchar = CUDA.wordPtrToDevPtr ; devPrim _ = error "mkPrimDispatcher: not primitive"


-- |Read a single element from an array at the given row-major index. This is a
-- synchronous operation.
--
indexArray :: (Shape dim, Elt e) => Array dim e -> Int -> CIO e
indexArray (Array _ !adata) i = run doIndex
  where
    doIndex !ctx !mt = toElt <$> indexR arrayElt adata
      where
        indexR :: ArrayEltR e -> ArrayData e -> IO e
        indexR ArrayEltRunit             _  = return ()
        indexR (ArrayEltRpair aeR1 aeR2) ad = (,) <$> indexR aeR1 (fst ad)
                                                  <*> indexR aeR2 (snd ad)
        --
        indexR ArrayEltRint              ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint8             ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint16            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint32            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRint64            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword             ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword8            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword16           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword32           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRword64           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRfloat            ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRdouble           ad = Prim.indexArray ctx mt ad i
        indexR ArrayEltRchar             ad = Prim.indexArray ctx mt ad i
        --
        indexR ArrayEltRcshort           ad = CShort  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcushort          ad = CUShort <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcint             ad = CInt    <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcuint            ad = CUInt   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRclong            ad = CLong   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRculong           ad = CULong  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcllong           ad = CLLong  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcullong          ad = CULLong <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcchar            ad = CChar   <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcschar           ad = CSChar  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcuchar           ad = CUChar  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcfloat           ad = CFloat  <$> Prim.indexArray ctx mt ad i
        indexR ArrayEltRcdouble          ad = CDouble <$> Prim.indexArray ctx mt ad i
        --
        indexR ArrayEltRbool             ad = toBool  <$> Prim.indexArray ctx mt ad i
          where toBool 0 = False
                toBool _ = True


-- |Copy data between two device arrays. The operation is asynchronous with
-- respect to the host, but will never overlap kernel execution.
--
copyArray :: (Shape dim, Elt e) => Array dim e -> Array dim e -> CIO ()
copyArray (Array !sh1 !adata1) (Array !sh2 !adata2)
  = $boundsCheck "copyArray" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n              = size sh1
    doCopy !ctx !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer ctx mt ad1 ad2 n
        --
        copyPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> ArrayData e -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArray)  ; copyPrim ArrayEltRint8 = Prim.copyArray ; copyPrim ArrayEltRint16 = Prim.copyArray ; copyPrim ArrayEltRint32 = Prim.copyArray ; copyPrim ArrayEltRint64 = Prim.copyArray ; copyPrim ArrayEltRword = Prim.copyArray ; copyPrim ArrayEltRword8 = Prim.copyArray ; copyPrim ArrayEltRword16 = Prim.copyArray ; copyPrim ArrayEltRword32 = Prim.copyArray ; copyPrim ArrayEltRword64 = Prim.copyArray ; copyPrim ArrayEltRfloat = Prim.copyArray ; copyPrim ArrayEltRdouble = Prim.copyArray ; copyPrim ArrayEltRbool = Prim.copyArray ; copyPrim ArrayEltRchar = Prim.copyArray ; copyPrim ArrayEltRcshort = Prim.copyArray ; copyPrim ArrayEltRcushort = Prim.copyArray ; copyPrim ArrayEltRcint = Prim.copyArray ; copyPrim ArrayEltRcuint = Prim.copyArray ; copyPrim ArrayEltRclong = Prim.copyArray ; copyPrim ArrayEltRculong = Prim.copyArray ; copyPrim ArrayEltRcllong = Prim.copyArray ; copyPrim ArrayEltRcullong = Prim.copyArray ; copyPrim ArrayEltRcfloat = Prim.copyArray ; copyPrim ArrayEltRcdouble = Prim.copyArray ; copyPrim ArrayEltRcchar = Prim.copyArray ; copyPrim ArrayEltRcschar = Prim.copyArray ; copyPrim ArrayEltRcuchar = Prim.copyArray ; copyPrim _ = error "mkPrimDispatcher: not primitive"

copyArrayAsync :: (Shape dim, Elt e) => Array dim e -> Array dim e -> Maybe CUDA.Stream -> CIO ()
copyArrayAsync (Array !sh1 !adata1) (Array !sh2 !adata2) ms
  = $boundsCheck "copyArrayAsync" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n              = size sh1
    doCopy !ctx !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer ctx mt ad1 ad2 n ms
        --
        copyPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayAsync)  ; copyPrim ArrayEltRint8 = Prim.copyArrayAsync ; copyPrim ArrayEltRint16 = Prim.copyArrayAsync ; copyPrim ArrayEltRint32 = Prim.copyArrayAsync ; copyPrim ArrayEltRint64 = Prim.copyArrayAsync ; copyPrim ArrayEltRword = Prim.copyArrayAsync ; copyPrim ArrayEltRword8 = Prim.copyArrayAsync ; copyPrim ArrayEltRword16 = Prim.copyArrayAsync ; copyPrim ArrayEltRword32 = Prim.copyArrayAsync ; copyPrim ArrayEltRword64 = Prim.copyArrayAsync ; copyPrim ArrayEltRfloat = Prim.copyArrayAsync ; copyPrim ArrayEltRdouble = Prim.copyArrayAsync ; copyPrim ArrayEltRbool = Prim.copyArrayAsync ; copyPrim ArrayEltRchar = Prim.copyArrayAsync ; copyPrim ArrayEltRcshort = Prim.copyArrayAsync ; copyPrim ArrayEltRcushort = Prim.copyArrayAsync ; copyPrim ArrayEltRcint = Prim.copyArrayAsync ; copyPrim ArrayEltRcuint = Prim.copyArrayAsync ; copyPrim ArrayEltRclong = Prim.copyArrayAsync ; copyPrim ArrayEltRculong = Prim.copyArrayAsync ; copyPrim ArrayEltRcllong = Prim.copyArrayAsync ; copyPrim ArrayEltRcullong = Prim.copyArrayAsync ; copyPrim ArrayEltRcfloat = Prim.copyArrayAsync ; copyPrim ArrayEltRcdouble = Prim.copyArrayAsync ; copyPrim ArrayEltRcchar = Prim.copyArrayAsync ; copyPrim ArrayEltRcschar = Prim.copyArrayAsync ; copyPrim ArrayEltRcuchar = Prim.copyArrayAsync ; copyPrim _ = error "mkPrimDispatcher: not primitive"


-- |Copy data between two device arrays which reside in different contexts. This
-- might entail copying between devices.
--
copyArrayPeer :: (Shape dim, Elt e) => Array dim e -> Context -> Array dim e -> Context -> CIO ()
copyArrayPeer (Array !sh1 !adata1) !ctxSrc (Array !sh2 !adata2) !ctxDst
  = $boundsCheck "copyArrayPeer" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n           = size sh1
    doCopy _ !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer mt ad1 ctxSrc ad2 ctxDst n
        --
        copyPrim :: ArrayEltR e -> MemoryTable -> ArrayData e -> Context -> ArrayData e -> Context -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayPeer)  ; copyPrim ArrayEltRint8 = Prim.copyArrayPeer ; copyPrim ArrayEltRint16 = Prim.copyArrayPeer ; copyPrim ArrayEltRint32 = Prim.copyArrayPeer ; copyPrim ArrayEltRint64 = Prim.copyArrayPeer ; copyPrim ArrayEltRword = Prim.copyArrayPeer ; copyPrim ArrayEltRword8 = Prim.copyArrayPeer ; copyPrim ArrayEltRword16 = Prim.copyArrayPeer ; copyPrim ArrayEltRword32 = Prim.copyArrayPeer ; copyPrim ArrayEltRword64 = Prim.copyArrayPeer ; copyPrim ArrayEltRfloat = Prim.copyArrayPeer ; copyPrim ArrayEltRdouble = Prim.copyArrayPeer ; copyPrim ArrayEltRbool = Prim.copyArrayPeer ; copyPrim ArrayEltRchar = Prim.copyArrayPeer ; copyPrim ArrayEltRcshort = Prim.copyArrayPeer ; copyPrim ArrayEltRcushort = Prim.copyArrayPeer ; copyPrim ArrayEltRcint = Prim.copyArrayPeer ; copyPrim ArrayEltRcuint = Prim.copyArrayPeer ; copyPrim ArrayEltRclong = Prim.copyArrayPeer ; copyPrim ArrayEltRculong = Prim.copyArrayPeer ; copyPrim ArrayEltRcllong = Prim.copyArrayPeer ; copyPrim ArrayEltRcullong = Prim.copyArrayPeer ; copyPrim ArrayEltRcfloat = Prim.copyArrayPeer ; copyPrim ArrayEltRcdouble = Prim.copyArrayPeer ; copyPrim ArrayEltRcchar = Prim.copyArrayPeer ; copyPrim ArrayEltRcschar = Prim.copyArrayPeer ; copyPrim ArrayEltRcuchar = Prim.copyArrayPeer ; copyPrim _ = error "mkPrimDispatcher: not primitive"

copyArrayPeerAsync :: (Shape dim, Elt e) => Array dim e -> Context -> Array dim e -> Context -> Maybe CUDA.Stream -> CIO ()
copyArrayPeerAsync (Array !sh1 !adata1) !ctxSrc (Array !sh2 !adata2) !ctxDst !ms
  = $boundsCheck "copyArrayPeerAsync" "shape mismatch" (sh1 == sh2)
  $ run doCopy
  where
    !n           = size sh1
    doCopy _ !mt = copyR arrayElt adata1 adata2
      where
        copyR :: ArrayEltR e -> ArrayData e -> ArrayData e -> IO ()
        copyR ArrayEltRunit             _   _   = return ()
        copyR (ArrayEltRpair aeR1 aeR2) ad1 ad2 = copyR aeR1 (fst ad1) (fst ad2) >>
                                                  copyR aeR2 (snd ad1) (snd ad2)
        copyR aer                       ad1 ad2 = copyPrim aer mt ad1 ctxSrc ad2 ctxDst n ms
        --
        copyPrim :: ArrayEltR e -> MemoryTable -> ArrayData e -> Context -> ArrayData e -> Context -> Int -> Maybe CUDA.Stream -> IO ()
        ;mkPrimDispatch ArrayEltRint(copyPrim,=Prim.copyArrayPeerAsync)  ; copyPrim ArrayEltRint8 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint16 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint32 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRint64 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword8 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword16 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword32 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRword64 = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRfloat = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRdouble = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRbool = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRchar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcshort = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcushort = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcint = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcuint = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRclong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRculong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcllong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcullong = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcfloat = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcdouble = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcchar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcschar = Prim.copyArrayPeerAsync ; copyPrim ArrayEltRcuchar = Prim.copyArrayPeerAsync ; copyPrim _ = error "mkPrimDispatcher: not primitive"


-- Copy data from the device into the associated Accelerate host-side array
--
peekArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
peekArray (Array !sh !adata) = run doPeek
  where
    !n              = size sh
    doPeek !ctx !mt = peekR arrayElt adata
      where
        peekR :: ArrayEltR e -> ArrayData e -> IO ()
        peekR ArrayEltRunit             _  = return ()
        peekR (ArrayEltRpair aeR1 aeR2) ad = peekR aeR1 (fst ad) >> peekR aeR2 (snd ad)
        peekR aer                       ad = peekPrim aer ctx mt ad n
        --
        peekPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(peekPrim,=Prim.peekArray)  ; peekPrim ArrayEltRint8 = Prim.peekArray ; peekPrim ArrayEltRint16 = Prim.peekArray ; peekPrim ArrayEltRint32 = Prim.peekArray ; peekPrim ArrayEltRint64 = Prim.peekArray ; peekPrim ArrayEltRword = Prim.peekArray ; peekPrim ArrayEltRword8 = Prim.peekArray ; peekPrim ArrayEltRword16 = Prim.peekArray ; peekPrim ArrayEltRword32 = Prim.peekArray ; peekPrim ArrayEltRword64 = Prim.peekArray ; peekPrim ArrayEltRfloat = Prim.peekArray ; peekPrim ArrayEltRdouble = Prim.peekArray ; peekPrim ArrayEltRbool = Prim.peekArray ; peekPrim ArrayEltRchar = Prim.peekArray ; peekPrim ArrayEltRcshort = Prim.peekArray ; peekPrim ArrayEltRcushort = Prim.peekArray ; peekPrim ArrayEltRcint = Prim.peekArray ; peekPrim ArrayEltRcuint = Prim.peekArray ; peekPrim ArrayEltRclong = Prim.peekArray ; peekPrim ArrayEltRculong = Prim.peekArray ; peekPrim ArrayEltRcllong = Prim.peekArray ; peekPrim ArrayEltRcullong = Prim.peekArray ; peekPrim ArrayEltRcfloat = Prim.peekArray ; peekPrim ArrayEltRcdouble = Prim.peekArray ; peekPrim ArrayEltRcchar = Prim.peekArray ; peekPrim ArrayEltRcschar = Prim.peekArray ; peekPrim ArrayEltRcuchar = Prim.peekArray ; peekPrim _ = error "mkPrimDispatcher: not primitive"

peekArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
peekArrayAsync (Array !sh !adata) !ms = run doPeek
  where
    !n              = size sh
    doPeek !ctx !mt = peekR arrayElt adata
      where
        peekR :: ArrayEltR e -> ArrayData e -> IO ()
        peekR ArrayEltRunit             _  = return ()
        peekR (ArrayEltRpair aeR1 aeR2) ad = peekR aeR1 (fst ad) >> peekR aeR2 (snd ad)
        peekR aer                       ad = peekPrim aer ctx mt ad n ms
        --
        peekPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        ;mkPrimDispatch ArrayEltRint(peekPrim,=Prim.peekArrayAsync)  ; peekPrim ArrayEltRint8 = Prim.peekArrayAsync ; peekPrim ArrayEltRint16 = Prim.peekArrayAsync ; peekPrim ArrayEltRint32 = Prim.peekArrayAsync ; peekPrim ArrayEltRint64 = Prim.peekArrayAsync ; peekPrim ArrayEltRword = Prim.peekArrayAsync ; peekPrim ArrayEltRword8 = Prim.peekArrayAsync ; peekPrim ArrayEltRword16 = Prim.peekArrayAsync ; peekPrim ArrayEltRword32 = Prim.peekArrayAsync ; peekPrim ArrayEltRword64 = Prim.peekArrayAsync ; peekPrim ArrayEltRfloat = Prim.peekArrayAsync ; peekPrim ArrayEltRdouble = Prim.peekArrayAsync ; peekPrim ArrayEltRbool = Prim.peekArrayAsync ; peekPrim ArrayEltRchar = Prim.peekArrayAsync ; peekPrim ArrayEltRcshort = Prim.peekArrayAsync ; peekPrim ArrayEltRcushort = Prim.peekArrayAsync ; peekPrim ArrayEltRcint = Prim.peekArrayAsync ; peekPrim ArrayEltRcuint = Prim.peekArrayAsync ; peekPrim ArrayEltRclong = Prim.peekArrayAsync ; peekPrim ArrayEltRculong = Prim.peekArrayAsync ; peekPrim ArrayEltRcllong = Prim.peekArrayAsync ; peekPrim ArrayEltRcullong = Prim.peekArrayAsync ; peekPrim ArrayEltRcfloat = Prim.peekArrayAsync ; peekPrim ArrayEltRcdouble = Prim.peekArrayAsync ; peekPrim ArrayEltRcchar = Prim.peekArrayAsync ; peekPrim ArrayEltRcschar = Prim.peekArrayAsync ; peekPrim ArrayEltRcuchar = Prim.peekArrayAsync ; peekPrim _ = error "mkPrimDispatcher: not primitive"


-- Copy data from an Accelerate array into the associated device array
--
pokeArray :: (Shape dim, Elt e) => Array dim e -> CIO ()
pokeArray (Array !sh !adata) = run doPoke
  where
    !n              = size sh
    doPoke !ctx !mt = pokeR arrayElt adata
      where
        pokeR :: ArrayEltR e -> ArrayData e -> IO ()
        pokeR ArrayEltRunit             _  = return ()
        pokeR (ArrayEltRpair aeR1 aeR2) ad = pokeR aeR1 (fst ad) >> pokeR aeR2 (snd ad)
        pokeR aer                       ad = pokePrim aer ctx mt ad n
        --
        pokePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> IO ()
        ;mkPrimDispatch ArrayEltRint(pokePrim,=Prim.pokeArray)  ; pokePrim ArrayEltRint8 = Prim.pokeArray ; pokePrim ArrayEltRint16 = Prim.pokeArray ; pokePrim ArrayEltRint32 = Prim.pokeArray ; pokePrim ArrayEltRint64 = Prim.pokeArray ; pokePrim ArrayEltRword = Prim.pokeArray ; pokePrim ArrayEltRword8 = Prim.pokeArray ; pokePrim ArrayEltRword16 = Prim.pokeArray ; pokePrim ArrayEltRword32 = Prim.pokeArray ; pokePrim ArrayEltRword64 = Prim.pokeArray ; pokePrim ArrayEltRfloat = Prim.pokeArray ; pokePrim ArrayEltRdouble = Prim.pokeArray ; pokePrim ArrayEltRbool = Prim.pokeArray ; pokePrim ArrayEltRchar = Prim.pokeArray ; pokePrim ArrayEltRcshort = Prim.pokeArray ; pokePrim ArrayEltRcushort = Prim.pokeArray ; pokePrim ArrayEltRcint = Prim.pokeArray ; pokePrim ArrayEltRcuint = Prim.pokeArray ; pokePrim ArrayEltRclong = Prim.pokeArray ; pokePrim ArrayEltRculong = Prim.pokeArray ; pokePrim ArrayEltRcllong = Prim.pokeArray ; pokePrim ArrayEltRcullong = Prim.pokeArray ; pokePrim ArrayEltRcfloat = Prim.pokeArray ; pokePrim ArrayEltRcdouble = Prim.pokeArray ; pokePrim ArrayEltRcchar = Prim.pokeArray ; pokePrim ArrayEltRcschar = Prim.pokeArray ; pokePrim ArrayEltRcuchar = Prim.pokeArray ; pokePrim _ = error "mkPrimDispatcher: not primitive"

pokeArrayAsync :: (Shape dim, Elt e) => Array dim e -> Maybe CUDA.Stream -> CIO ()
pokeArrayAsync (Array !sh !adata) !ms = run doPoke
  where
    !n              = size sh
    doPoke !ctx !mt = pokeR arrayElt adata
      where
        pokeR :: ArrayEltR e -> ArrayData e -> IO ()
        pokeR ArrayEltRunit             _  = return ()
        pokeR (ArrayEltRpair aeR1 aeR2) ad = pokeR aeR1 (fst ad) >> pokeR aeR2 (snd ad)
        pokeR aer                       ad = pokePrim aer ctx mt ad n ms
        --
        pokePrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> Maybe CUDA.Stream -> IO ()
        ;mkPrimDispatch ArrayEltRint(pokePrim,=Prim.pokeArrayAsync)  ; pokePrim ArrayEltRint8 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint16 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint32 = Prim.pokeArrayAsync ; pokePrim ArrayEltRint64 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword = Prim.pokeArrayAsync ; pokePrim ArrayEltRword8 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword16 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword32 = Prim.pokeArrayAsync ; pokePrim ArrayEltRword64 = Prim.pokeArrayAsync ; pokePrim ArrayEltRfloat = Prim.pokeArrayAsync ; pokePrim ArrayEltRdouble = Prim.pokeArrayAsync ; pokePrim ArrayEltRbool = Prim.pokeArrayAsync ; pokePrim ArrayEltRchar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcshort = Prim.pokeArrayAsync ; pokePrim ArrayEltRcushort = Prim.pokeArrayAsync ; pokePrim ArrayEltRcint = Prim.pokeArrayAsync ; pokePrim ArrayEltRcuint = Prim.pokeArrayAsync ; pokePrim ArrayEltRclong = Prim.pokeArrayAsync ; pokePrim ArrayEltRculong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcllong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcullong = Prim.pokeArrayAsync ; pokePrim ArrayEltRcfloat = Prim.pokeArrayAsync ; pokePrim ArrayEltRcdouble = Prim.pokeArrayAsync ; pokePrim ArrayEltRcchar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcschar = Prim.pokeArrayAsync ; pokePrim ArrayEltRcuchar = Prim.pokeArrayAsync ; pokePrim _ = error "mkPrimDispatcher: not primitive"


-- |Convert the device pointers into a list of word pointers
--
devicePtrsToWordPtrs :: ArrayElt e => ArrayData e -> Prim.DevicePtrs e -> [WordPtr]
devicePtrsToWordPtrs !adata = wordR arrayElt adata
  where
    wordR :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> [WordPtr]
    wordR ArrayEltRunit             _  _       = []
    wordR (ArrayEltRpair aeR1 aeR2) ad (p1,p2) = wordR aeR1 (fst ad) p1 ++
                                                 wordR aeR2 (snd ad) p2
    wordR aer                       ad ptr     = [wordPrim aer ad ptr]
    --
    wordPrim :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> WordPtr
    ;mkPrimDispatch ArrayEltRint(wordPrim,=constCUDA.devPtrToWordPtr)  ; wordPrim ArrayEltRint8 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint16 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint32 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRint64 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword8 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword16 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword32 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRword64 = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRfloat = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRdouble = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRbool = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRchar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcshort = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcushort = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcint = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcuint = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRclong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRculong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcllong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcullong = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcfloat = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcdouble = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcchar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcschar = const CUDA.devPtrToWordPtr ; wordPrim ArrayEltRcuchar = const CUDA.devPtrToWordPtr ; wordPrim _ = error "mkPrimDispatcher: not primitive"

-- |Wrap device pointers into arguments that can be passed to a kernel
-- invocation
--
marshalDevicePtrs :: ArrayElt e => ArrayData e -> Prim.DevicePtrs e -> [CUDA.FunParam]
marshalDevicePtrs !adata ptrs = map (CUDA.VArg . CUDA.wordPtrToDevPtr) $ devicePtrsToWordPtrs adata ptrs

-- |Wrap the device pointers corresponding to a host-side array into arguments
-- that can be passed to a kernel upon invocation.
--
marshalArrayData :: ArrayElt e => ArrayData e -> CIO [CUDA.FunParam]
marshalArrayData !adata = run doMarshal
  where
    doMarshal !ctx !mt = marshalR arrayElt adata
      where
        marshalR :: ArrayEltR e -> ArrayData e -> IO [CUDA.FunParam]
        marshalR ArrayEltRunit             _  = return []
        marshalR (ArrayEltRpair aeR1 aeR2) ad = (++) <$> marshalR aeR1 (fst ad)
                                                     <*> marshalR aeR2 (snd ad)
        marshalR aer                       ad = return <$> marshalPrim aer ctx mt ad
        --
        marshalPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> IO CUDA.FunParam
        ;mkPrimDispatch ArrayEltRint(marshalPrim,=Prim.marshalArrayData)  ; marshalPrim ArrayEltRint8 = Prim.marshalArrayData ; marshalPrim ArrayEltRint16 = Prim.marshalArrayData ; marshalPrim ArrayEltRint32 = Prim.marshalArrayData ; marshalPrim ArrayEltRint64 = Prim.marshalArrayData ; marshalPrim ArrayEltRword = Prim.marshalArrayData ; marshalPrim ArrayEltRword8 = Prim.marshalArrayData ; marshalPrim ArrayEltRword16 = Prim.marshalArrayData ; marshalPrim ArrayEltRword32 = Prim.marshalArrayData ; marshalPrim ArrayEltRword64 = Prim.marshalArrayData ; marshalPrim ArrayEltRfloat = Prim.marshalArrayData ; marshalPrim ArrayEltRdouble = Prim.marshalArrayData ; marshalPrim ArrayEltRbool = Prim.marshalArrayData ; marshalPrim ArrayEltRchar = Prim.marshalArrayData ; marshalPrim ArrayEltRcshort = Prim.marshalArrayData ; marshalPrim ArrayEltRcushort = Prim.marshalArrayData ; marshalPrim ArrayEltRcint = Prim.marshalArrayData ; marshalPrim ArrayEltRcuint = Prim.marshalArrayData ; marshalPrim ArrayEltRclong = Prim.marshalArrayData ; marshalPrim ArrayEltRculong = Prim.marshalArrayData ; marshalPrim ArrayEltRcllong = Prim.marshalArrayData ; marshalPrim ArrayEltRcullong = Prim.marshalArrayData ; marshalPrim ArrayEltRcfloat = Prim.marshalArrayData ; marshalPrim ArrayEltRcdouble = Prim.marshalArrayData ; marshalPrim ArrayEltRcchar = Prim.marshalArrayData ; marshalPrim ArrayEltRcschar = Prim.marshalArrayData ; marshalPrim ArrayEltRcuchar = Prim.marshalArrayData ; marshalPrim _ = error "mkPrimDispatcher: not primitive"


-- |Bind the device memory arrays to the given texture reference(s), setting
-- appropriate type. The arrays are bound, and the list of textures thereby
-- consumed, in projection index order --- i.e. right-to-left
--
marshalTextureData :: ArrayElt e => ArrayData e -> Int -> [CUDA.Texture] -> CIO ()
marshalTextureData !adata !n !texs = run doMarshal
  where
    doMarshal !ctx !mt = marshalR arrayElt adata texs >> return ()
      where
        marshalR :: ArrayEltR e -> ArrayData e -> [CUDA.Texture] -> IO Int
        marshalR ArrayEltRunit             _  _ = return 0
        marshalR (ArrayEltRpair aeR1 aeR2) ad t
          = do r <- marshalR aeR2 (snd ad) t
               l <- marshalR aeR1 (fst ad) (drop r t)
               return (l + r)
        marshalR aer                       ad t
          = do marshalPrim aer ctx mt ad n (head t)
               return 1
        --
        marshalPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> Int -> CUDA.Texture -> IO ()
        ;mkPrimDispatch ArrayEltRint(marshalPrim,=Prim.marshalTextureData)  ; marshalPrim ArrayEltRint8 = Prim.marshalTextureData ; marshalPrim ArrayEltRint16 = Prim.marshalTextureData ; marshalPrim ArrayEltRint32 = Prim.marshalTextureData ; marshalPrim ArrayEltRint64 = Prim.marshalTextureData ; marshalPrim ArrayEltRword = Prim.marshalTextureData ; marshalPrim ArrayEltRword8 = Prim.marshalTextureData ; marshalPrim ArrayEltRword16 = Prim.marshalTextureData ; marshalPrim ArrayEltRword32 = Prim.marshalTextureData ; marshalPrim ArrayEltRword64 = Prim.marshalTextureData ; marshalPrim ArrayEltRfloat = Prim.marshalTextureData ; marshalPrim ArrayEltRdouble = Prim.marshalTextureData ; marshalPrim ArrayEltRbool = Prim.marshalTextureData ; marshalPrim ArrayEltRchar = Prim.marshalTextureData ; marshalPrim ArrayEltRcshort = Prim.marshalTextureData ; marshalPrim ArrayEltRcushort = Prim.marshalTextureData ; marshalPrim ArrayEltRcint = Prim.marshalTextureData ; marshalPrim ArrayEltRcuint = Prim.marshalTextureData ; marshalPrim ArrayEltRclong = Prim.marshalTextureData ; marshalPrim ArrayEltRculong = Prim.marshalTextureData ; marshalPrim ArrayEltRcllong = Prim.marshalTextureData ; marshalPrim ArrayEltRcullong = Prim.marshalTextureData ; marshalPrim ArrayEltRcfloat = Prim.marshalTextureData ; marshalPrim ArrayEltRcdouble = Prim.marshalTextureData ; marshalPrim ArrayEltRcchar = Prim.marshalTextureData ; marshalPrim ArrayEltRcschar = Prim.marshalTextureData ; marshalPrim ArrayEltRcuchar = Prim.marshalTextureData ; marshalPrim _ = error "mkPrimDispatcher: not primitive"


-- |Raw device pointers associated with a host-side array
--
devicePtrsOfArrayData :: ArrayElt e => ArrayData e -> CIO (Prim.DevicePtrs e)
devicePtrsOfArrayData !adata = run ptrs
  where
    ptrs !ctx !mt = ptrsR arrayElt adata
      where
        ptrsR :: ArrayEltR e -> ArrayData e -> IO (Prim.DevicePtrs e)
        ptrsR ArrayEltRunit             _  = return ()
        ptrsR (ArrayEltRpair aeR1 aeR2) ad = (,) <$> ptrsR aeR1 (fst ad)
                                                 <*> ptrsR aeR2 (snd ad)
        ptrsR aer                       ad = ptrsPrim aer ctx mt ad
        --
        ptrsPrim :: ArrayEltR e -> Context -> MemoryTable -> ArrayData e -> IO (Prim.DevicePtrs e)
        ;mkPrimDispatch ArrayEltRint(ptrsPrim,=Prim.devicePtrsOfArrayData)  ; ptrsPrim ArrayEltRint8 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint16 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint32 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRint64 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword8 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword16 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword32 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRword64 = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRfloat = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRdouble = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRbool = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRchar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcshort = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcushort = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcint = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcuint = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRclong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRculong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcllong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcullong = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcfloat = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcdouble = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcchar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcschar = Prim.devicePtrsOfArrayData ; ptrsPrim ArrayEltRcuchar = Prim.devicePtrsOfArrayData ; ptrsPrim _ = error "mkPrimDispatcher: not primitive"


-- |Advance a set of device pointers by the given number of elements each
--
advancePtrsOfArrayData :: ArrayElt e => ArrayData e -> Int -> Prim.DevicePtrs e -> Prim.DevicePtrs e
advancePtrsOfArrayData !adata !n = advanceR arrayElt adata
  where
    advanceR :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> Prim.DevicePtrs e
    advanceR ArrayEltRunit             _  _       = ()
    advanceR (ArrayEltRpair aeR1 aeR2) ad (p1,p2) = (advanceR aeR1 (fst ad) p1
                                                    ,advanceR aeR2 (snd ad) p2)
    advanceR aer                       ad ptr     = advancePrim aer ad ptr
    --
    advancePrim :: ArrayEltR e -> ArrayData e -> Prim.DevicePtrs e -> Prim.DevicePtrs e
    ;mkPrimDispatch ArrayEltRint(advancePrim,=Prim.advancePtrsOfArrayDatan)n ; advancePrim ArrayEltRint8 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint16 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint32 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRint64 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword8 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword16 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword32 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRword64 = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRfloat = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRdouble = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRbool = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRchar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcshort = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcushort = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcint = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcuint = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRclong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRculong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcllong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcullong = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcfloat = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcdouble = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcchar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcschar = Prim.advancePtrsOfArrayData n ; advancePrim ArrayEltRcuchar = Prim.advancePtrsOfArrayData n ; advancePrim _ = error "mkPrimDispatcher: not primitive"


</pre>