<a href="InteractionNet.hs18645465171351934195.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Interface.hs10040168551732267506.out.html">next</a></br></br><pre>41c41
<                 a' <- typeOf n t2,
---
>                 a' <- typeOf n t2
43a44
> 
</pre></br><h2>original</h2></br><pre>-- |
-- Copyright : © 2009 CNRS - École Polytechnique - INRIA
-- License   : GPL

module Dedukti.Driver.Interactive where

import qualified Dedukti.Core as Core
import Dedukti.Module
import Dedukti.Parser
import qualified Dedukti.Rule as Rule
import Data.ByteString.Lazy (ByteString)
import Dedukti.Runtime


type Scope = Term -> Term

abstract :: Int -> Term -> Scope
abstract n t = \x -> capture n x t
  where capture n x t@(Box ty (Var n')) | n == n' = x
                                        | otherwise = t
        capture n x (TLam ty f) = TLam (capture ty) (\y -> capture n x (f y))
        capture n x (TPi ty f) = TPi (capture ty) (\y -> capture n x (f y))
        capture n x (TApp t1 t2) = TApp (capture n x t1) (capture n x t2)
        capture n x t = t

instantiate :: Term -> Scope -> Term
instantiate = flip ($)

mkVar :: Int -> Code -> Term
mkVar x ty = Box (Var x) ty

mkCon :: ByteString -> Code -> Term
mkCon c ty = Box (Con c) ty

mkLam, mkPi :: Int -> Term -> Term -> Term
mkLam n ty t = TLam ty (abstract n t)
mkPi n ty t = TPi ty (abstract n t)

mkApp :: Int -> Term -> Term -> Term
mkApp n t1 t2 | Pi a f <- typeOf n t1,
                a' <- typeOf n t2,
                convertible a a' = Box (f t2) (TApp t1 t2)

</pre></br><h2>printed</h2></br><pre>-- |
-- Copyright : © 2009 CNRS - École Polytechnique - INRIA
-- License   : GPL

module Dedukti.Driver.Interactive where

import qualified Dedukti.Core as Core
import Dedukti.Module
import Dedukti.Parser
import qualified Dedukti.Rule as Rule
import Data.ByteString.Lazy (ByteString)
import Dedukti.Runtime


type Scope = Term -> Term

abstract :: Int -> Term -> Scope
abstract n t = \x -> capture n x t
  where capture n x t@(Box ty (Var n')) | n == n' = x
                                        | otherwise = t
        capture n x (TLam ty f) = TLam (capture ty) (\y -> capture n x (f y))
        capture n x (TPi ty f) = TPi (capture ty) (\y -> capture n x (f y))
        capture n x (TApp t1 t2) = TApp (capture n x t1) (capture n x t2)
        capture n x t = t

instantiate :: Term -> Scope -> Term
instantiate = flip ($)

mkVar :: Int -> Code -> Term
mkVar x ty = Box (Var x) ty

mkCon :: ByteString -> Code -> Term
mkCon c ty = Box (Con c) ty

mkLam, mkPi :: Int -> Term -> Term -> Term
mkLam n ty t = TLam ty (abstract n t)
mkPi n ty t = TPi ty (abstract n t)

mkApp :: Int -> Term -> Term -> Term
mkApp n t1 t2 | Pi a f <- typeOf n t1,
                a' <- typeOf n t2
                convertible a a' = Box (f t2) (TApp t1 t2)


</pre>