<a href="Cond.hs12648177091998097157.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Condition.hs3077388201025725764.out.html">next</a></br></br><pre>12c12
<     type AltInv m s t = ()
---
>          AltInv m s t   ()
22a23
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, ConstraintKinds, PolyKinds #-}

module Control.Effect.Cond where

import GHC.Prim

{-| Provides a conditional using an 'alternation' operation, as opposed to using
   'Subeffect' -}

class Cond (m :: k -> * -> *) where
    type AltInv m (s :: k) (t :: k) :: Constraint
    type AltInv m s t = ()

    {-| Type family for describing how to combine effects of the two
        branches of an if -}
    type Alt m (s :: k) (t :: k) :: k

    {-| Conditional on effectful operations -}
    ifM :: AltInv m s t => Bool -> m s a -> m t a -> m (Alt m s t) a

-- Related to indexed 'applicative' functors/idioms
--            which are indexed monoidal functors
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, ConstraintKinds, PolyKinds #-}

module Control.Effect.Cond where

import GHC.Prim

{-| Provides a conditional using an 'alternation' operation, as opposed to using
   'Subeffect' -}

class Cond (m :: k -> * -> *) where
    type AltInv m (s :: k) (t :: k) :: Constraint
         AltInv m s t   ()

    {-| Type family for describing how to combine effects of the two
        branches of an if -}
    type Alt m (s :: k) (t :: k) :: k

    {-| Conditional on effectful operations -}
    ifM :: AltInv m s t => Bool -> m s a -> m t a -> m (Alt m s t) a

-- Related to indexed 'applicative' functors/idioms
--            which are indexed monoidal functors

</pre>