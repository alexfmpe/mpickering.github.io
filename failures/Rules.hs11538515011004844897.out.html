<a href="RuleLib.hs12672485902051724831.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Rules.hs1194314738318153057.out.html">next</a></br></br><pre>11c11
< arity0 ∷ (View [Port] n, View Vertex n) ⇒ Edge → Pattern n Vertex
---
> arity0 :: (View [Port] n, View Vertex n) => Edge -> Pattern n Vertex
13d12
<     c = do {c@Combinator {} ← nodeAt i; return c}
14d12
<     v = do {v@Variable   {} ← nodeAt i; return v}
15c13
<     e = do {e@Eraser     {} ← nodeAt i; return e}
---
>     c = do {c@Combinator {} <- nodeAt i; return c}
15a14
>     v = do {v@Variable   {} <- nodeAt i; return v}
15a15
>     e = do {e@Eraser     {} <- nodeAt i; return e}
17c17
< erase0 ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> erase0 :: (View [Port] n, View Vertex n) => Rule n
19d18
<     Eraser {out = o} ← node
20c19
<     n ← arity0 o
---
>     Eraser {out = o} <- node
20a20
>     n <- arity0 o
23c23
< eraseApplicator ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> eraseApplicator :: (View [Port] n, View Vertex n) => Rule n
25d24
<     Eraser {out = o} ← node
26c25
<     Applicator {inp = i, out1 = o1, out2 = o2} ← nodeAt o
---
>     Eraser {out = o} <- node
26a26
>     Applicator {inp = i, out1 = o1, out2 = o2} <- nodeAt o
30c30
< duplicate ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> duplicate :: (View [Port] n, View Vertex n) => Rule n
32d31
<     Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
33c32
<     n ← arity0 o
---
>     Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
33a33
>     n <- arity0 o
36c36
< duplicateApplicator ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> duplicateApplicator :: (View [Port] n, View Vertex n) => Rule n
38d37
<     Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
39d37
<     Applicator {inp = i, out1 = o1, out2 = o2} ← nodeAt o
40c38
<     replace4 $ \l1 l2 x1 x2 →
---
>     Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
40a39
>     Applicator {inp = i, out1 = o1, out2 = o2} <- nodeAt o
40a40
>     replace4 $ \l1 l2 x1 x2 ->
46c46
< eliminate ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> eliminate :: (View [Port] n, View Vertex n) => Rule n
48d47
<     Eraser {out = oE} ← node
49c48
<     Duplicator {out = oD, inp1 = i1, inp2 = i2} ← nodeAt oE
---
>     Eraser {out = oE} <- node
49a49
>     Duplicator {out = oD, inp1 = i1, inp2 = i2} <- nodeAt oE
55c55
< combinatorPattern ∷ (View [Port] n, View Vertex n) ⇒ Combinator → Int → Pattern n (Edge, [Edge])
---
> combinatorPattern :: (View [Port] n, View Vertex n) => Combinator -> Int -> Pattern n (Edge, [Edge])
57c57
<     Combinator {inp = i, combinator = c'} ← node
---
>     Combinator {inp = i, combinator = c'} <- node
63c63
<         Applicator {inp = iA, out1 = o1, out2 = o2} ← nodeAt i
---
>         Applicator {inp = iA, out1 = o1, out2 = o2} <- nodeAt i
65c65
<         (i',args) ← accumulateArguments iA (n-1)
---
>         (i',args) <- accumulateArguments iA (n-1)
70c70
< combinatorS ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorS :: (View [Port] n, View Vertex n) => Rule n
72d71
<     (i, [f,g,x]) ← combinatorPattern S 3
73c72
<     replace4 $ \l lr r rr →
---
>     (i, [f,g,x]) <- combinatorPattern S 3
73a73
>     replace4 $ \l lr r rr ->
79c79
< combinatorK ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorK :: (View [Port] n, View Vertex n) => Rule n
81c81
<     (i, [x,y]) ← combinatorPattern K 2
---
>     (i, [x,y]) <- combinatorPattern K 2
84c84
< combinatorI ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorI :: (View [Port] n, View Vertex n) => Rule n
86c86
<     (i, [x]) ← combinatorPattern I 1
---
>     (i, [x]) <- combinatorPattern I 1
89c89
< combinatorB ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorB :: (View [Port] n, View Vertex n) => Rule n
91d90
<     (i, [x,y,z]) ← combinatorPattern B 3
92c91
<     replace1 $ \r →
---
>     (i, [x,y,z]) <- combinatorPattern B 3
92a92
>     replace1 $ \r ->
96c96
< combinatorC ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorC :: (View [Port] n, View Vertex n) => Rule n
98d97
<     (i, [x,y,z]) ← combinatorPattern C 3
99c98
<     replace1 $ \l →
---
>     (i, [x,y,z]) <- combinatorPattern C 3
99a99
>     replace1 $ \l ->
103c103
< combinatorS' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorS' :: (View [Port] n, View Vertex n) => Rule n
105d104
<     (i, [k,x,y,z]) ← combinatorPattern S' 4
106c105
<     replace5 $ \l lr lrr r rr →
---
>     (i, [k,x,y,z]) <- combinatorPattern S' 4
106a106
>     replace5 $ \l lr lrr r rr ->
113c113
< combinatorB' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorB' :: (View [Port] n, View Vertex n) => Rule n
115d114
<     (i, [k,x,y,z]) ← combinatorPattern B' 4
116c115
<     replace2 $ \l r →
---
>     (i, [k,x,y,z]) <- combinatorPattern B' 4
116a116
>     replace2 $ \l r ->
121c121
< combinatorC' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorC' :: (View [Port] n, View Vertex n) => Rule n
123d122
<     (i, [k,x,y,z]) ← combinatorPattern C' 4
124c123
<     replace2 $ \l lr →
---
>     (i, [k,x,y,z]) <- combinatorPattern C' 4
124a124
>     replace2 $ \l lr ->
129c129
< combinatorW ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> combinatorW :: (View [Port] n, View Vertex n) => Rule n
131d130
<     (i, [x,y]) ← combinatorPattern W 2
132c131
<     replace3 $ \l lr r →
---
>     (i, [x,y]) <- combinatorPattern W 2
132a132
>     replace3 $ \l lr r ->
135a136
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
module Rules where

import Prelude.Unicode
import Graph
import GraphRewriting


-- The set-up ----------------------------------------------------------------

arity0 ∷ (View [Port] n, View Vertex n) ⇒ Edge → Pattern n Vertex
arity0 i = anyOf [c,v,e] where
    c = do {c@Combinator {} ← nodeAt i; return c}
    v = do {v@Variable   {} ← nodeAt i; return v}
    e = do {e@Eraser     {} ← nodeAt i; return e}

erase0 ∷ (View [Port] n, View Vertex n) ⇒ Rule n
erase0 = linear $ do
    Eraser {out = o} ← node
    n ← arity0 o
    erase

eraseApplicator ∷ (View [Port] n, View Vertex n) ⇒ Rule n
eraseApplicator = linear $ do
    Eraser {out = o} ← node
    Applicator {inp = i, out1 = o1, out2 = o2} ← nodeAt o
    require (o ≡ i)
    replace0 [Node $ Eraser {out = o1}, Node $ Eraser {out = o2}]

duplicate ∷ (View [Port] n, View Vertex n) ⇒ Rule n
duplicate = duplicateApplicator <|> do
    Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
    n ← arity0 o
    replace0 $ [Node $ n {inp = i1}, Node $ n {inp = i2}]

duplicateApplicator ∷ (View [Port] n, View Vertex n) ⇒ Rule n
duplicateApplicator = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
    Applicator {inp = i, out1 = o1, out2 = o2} ← nodeAt o
    replace4 $ \l1 l2 x1 x2 →
        [Node $ Applicator {inp = i1, out1 = l1, out2 = x1},
         Node $ Applicator {inp = i2, out1 = x2, out2 = l2},
         Node $ Duplicator {inp1 = l1, inp2 = x2, out = o1},
         Node $ Duplicator {inp1 = x1, inp2 = l2, out = o2}]

eliminate ∷ (View [Port] n, View Vertex n) ⇒ Rule n
eliminate = do
    Eraser {out = oE} ← node
    Duplicator {out = oD, inp1 = i1, inp2 = i2} ← nodeAt oE
    require (oE ≡ i1 ∨ oE ≡ i2)
    if oE ≡ i1
        then rewire [[oD,i2]]
        else rewire [[oD,i1]]

combinatorPattern ∷ (View [Port] n, View Vertex n) ⇒ Combinator → Int → Pattern n (Edge, [Edge])
combinatorPattern c arity = do
    Combinator {inp = i, combinator = c'} ← node
    require (c ≡ c')
    accumulateArguments i arity
    where
    accumulateArguments i 0 = return (i,[])
    accumulateArguments i n = do
        Applicator {inp = iA, out1 = o1, out2 = o2} ← nodeAt i
        require (i ≡ o1)
        (i',args) ← accumulateArguments iA (n-1)
        return (i',o2:args)

-- The show-down -------------------------------------------------------------

combinatorS ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorS = do
    (i, [f,g,x]) ← combinatorPattern S 3
    replace4 $ \l lr r rr →
        [Node $ Applicator {inp = l, out1 = f, out2 = lr},
         Node $ Applicator {inp = r, out1 = g, out2 = rr},
         Node $ Duplicator {inp1 = lr, inp2 = rr, out = x},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorK ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorK = do
    (i, [x,y]) ← combinatorPattern K 2
    replace0 [Node $ Eraser {out = y}, Wire i x]

combinatorI ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorI = do
    (i, [x]) ← combinatorPattern I 1
    rewire [[i,x]]

combinatorB ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorB = do
    (i, [x,y,z]) ← combinatorPattern B 3
    replace1 $ \r →
        [Node $ Applicator {inp = r, out1 = y, out2 = z},
         Node $ Applicator {inp = i, out1 = x, out2 = r}]

combinatorC ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorC = do
    (i, [x,y,z]) ← combinatorPattern C 3
    replace1 $ \l →
        [Node $ Applicator {inp = l, out1 = x, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = y}]

combinatorS' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorS' = do
    (i, [k,x,y,z]) ← combinatorPattern S' 4
    replace5 $ \l lr lrr r rr →
        [Node $ Applicator {inp = lr, out1 = x, out2 = lrr},
         Node $ Applicator {inp = l, out1 = k, out2 = lr},
         Node $ Applicator {inp = r, out1 = y, out2 = rr},
         Node $ Duplicator {inp1 = lrr, inp2 = rr, out = z},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorB' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorB' = do
    (i, [k,x,y,z]) ← combinatorPattern B' 4
    replace2 $ \l r →
        [Node $ Applicator {inp = l, out1 = k, out2 = x},
         Node $ Applicator {inp = r, out1 = y, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorC' ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorC' = do
    (i, [k,x,y,z]) ← combinatorPattern C' 4
    replace2 $ \l lr →
        [Node $ Applicator {inp = l, out1 = k, out2 = lr},
         Node $ Applicator {inp = lr, out1 = x, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = y}]

combinatorW ∷ (View [Port] n, View Vertex n) ⇒ Rule n
combinatorW = do
    (i, [x,y]) ← combinatorPattern W 2
    replace3 $ \l lr r →
        [Node $ Applicator {inp = l, out1 = x, out2 = lr},
         Node $ Duplicator {inp1 = lr, inp2 = r, out = y},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
module Rules where

import Prelude.Unicode
import Graph
import GraphRewriting


-- The set-up ----------------------------------------------------------------

arity0 :: (View [Port] n, View Vertex n) => Edge -> Pattern n Vertex
arity0 i = anyOf [c,v,e] where
    c = do {c@Combinator {} <- nodeAt i; return c}
    v = do {v@Variable   {} <- nodeAt i; return v}
    e = do {e@Eraser     {} <- nodeAt i; return e}

erase0 :: (View [Port] n, View Vertex n) => Rule n
erase0 = linear $ do
    Eraser {out = o} <- node
    n <- arity0 o
    erase

eraseApplicator :: (View [Port] n, View Vertex n) => Rule n
eraseApplicator = linear $ do
    Eraser {out = o} <- node
    Applicator {inp = i, out1 = o1, out2 = o2} <- nodeAt o
    require (o ≡ i)
    replace0 [Node $ Eraser {out = o1}, Node $ Eraser {out = o2}]

duplicate :: (View [Port] n, View Vertex n) => Rule n
duplicate = duplicateApplicator <|> do
    Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
    n <- arity0 o
    replace0 $ [Node $ n {inp = i1}, Node $ n {inp = i2}]

duplicateApplicator :: (View [Port] n, View Vertex n) => Rule n
duplicateApplicator = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
    Applicator {inp = i, out1 = o1, out2 = o2} <- nodeAt o
    replace4 $ \l1 l2 x1 x2 ->
        [Node $ Applicator {inp = i1, out1 = l1, out2 = x1},
         Node $ Applicator {inp = i2, out1 = x2, out2 = l2},
         Node $ Duplicator {inp1 = l1, inp2 = x2, out = o1},
         Node $ Duplicator {inp1 = x1, inp2 = l2, out = o2}]

eliminate :: (View [Port] n, View Vertex n) => Rule n
eliminate = do
    Eraser {out = oE} <- node
    Duplicator {out = oD, inp1 = i1, inp2 = i2} <- nodeAt oE
    require (oE ≡ i1 ∨ oE ≡ i2)
    if oE ≡ i1
        then rewire [[oD,i2]]
        else rewire [[oD,i1]]

combinatorPattern :: (View [Port] n, View Vertex n) => Combinator -> Int -> Pattern n (Edge, [Edge])
combinatorPattern c arity = do
    Combinator {inp = i, combinator = c'} <- node
    require (c ≡ c')
    accumulateArguments i arity
    where
    accumulateArguments i 0 = return (i,[])
    accumulateArguments i n = do
        Applicator {inp = iA, out1 = o1, out2 = o2} <- nodeAt i
        require (i ≡ o1)
        (i',args) <- accumulateArguments iA (n-1)
        return (i',o2:args)

-- The show-down -------------------------------------------------------------

combinatorS :: (View [Port] n, View Vertex n) => Rule n
combinatorS = do
    (i, [f,g,x]) <- combinatorPattern S 3
    replace4 $ \l lr r rr ->
        [Node $ Applicator {inp = l, out1 = f, out2 = lr},
         Node $ Applicator {inp = r, out1 = g, out2 = rr},
         Node $ Duplicator {inp1 = lr, inp2 = rr, out = x},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorK :: (View [Port] n, View Vertex n) => Rule n
combinatorK = do
    (i, [x,y]) <- combinatorPattern K 2
    replace0 [Node $ Eraser {out = y}, Wire i x]

combinatorI :: (View [Port] n, View Vertex n) => Rule n
combinatorI = do
    (i, [x]) <- combinatorPattern I 1
    rewire [[i,x]]

combinatorB :: (View [Port] n, View Vertex n) => Rule n
combinatorB = do
    (i, [x,y,z]) <- combinatorPattern B 3
    replace1 $ \r ->
        [Node $ Applicator {inp = r, out1 = y, out2 = z},
         Node $ Applicator {inp = i, out1 = x, out2 = r}]

combinatorC :: (View [Port] n, View Vertex n) => Rule n
combinatorC = do
    (i, [x,y,z]) <- combinatorPattern C 3
    replace1 $ \l ->
        [Node $ Applicator {inp = l, out1 = x, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = y}]

combinatorS' :: (View [Port] n, View Vertex n) => Rule n
combinatorS' = do
    (i, [k,x,y,z]) <- combinatorPattern S' 4
    replace5 $ \l lr lrr r rr ->
        [Node $ Applicator {inp = lr, out1 = x, out2 = lrr},
         Node $ Applicator {inp = l, out1 = k, out2 = lr},
         Node $ Applicator {inp = r, out1 = y, out2 = rr},
         Node $ Duplicator {inp1 = lrr, inp2 = rr, out = z},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorB' :: (View [Port] n, View Vertex n) => Rule n
combinatorB' = do
    (i, [k,x,y,z]) <- combinatorPattern B' 4
    replace2 $ \l r ->
        [Node $ Applicator {inp = l, out1 = k, out2 = x},
         Node $ Applicator {inp = r, out1 = y, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

combinatorC' :: (View [Port] n, View Vertex n) => Rule n
combinatorC' = do
    (i, [k,x,y,z]) <- combinatorPattern C' 4
    replace2 $ \l lr ->
        [Node $ Applicator {inp = l, out1 = k, out2 = lr},
         Node $ Applicator {inp = lr, out1 = x, out2 = z},
         Node $ Applicator {inp = i, out1 = l, out2 = y}]

combinatorW :: (View [Port] n, View Vertex n) => Rule n
combinatorW = do
    (i, [x,y]) <- combinatorPattern W 2
    replace3 $ \l lr r ->
        [Node $ Applicator {inp = l, out1 = x, out2 = lr},
         Node $ Duplicator {inp1 = lr, inp2 = r, out = y},
         Node $ Applicator {inp = i, out1 = l, out2 = r}]

</pre>