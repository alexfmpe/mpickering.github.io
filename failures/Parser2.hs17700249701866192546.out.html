<a href="Parser.hs933963922050098034.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Parsers.hs10994561871610836121.out.html">next</a></br></br><pre>22c22
< {-# LINE 41 "src/ehc/Base/Parser2.chs" #-}
---
> 
22a23
> 
22a24
> 
22a25
> 
22a26
> 
22a27
> 
22a28
> 
22a29
> 
22a30
> 
22a31
> 
22a32
> 
22a33
> 
22a34
> 
22a35
> 
22a36
> 
22a37
> 
22a38
> 
22a39
> 
22a40
> 
29c47
< {-# LINE 49 "src/ehc/Base/Parser2.chs" #-}
---
> 
29a48
> 
38c57
< {-# LINE 63 "src/ehc/Base/Parser2.chs" #-}
---
> 
38a58
> 
38a59
> 
38a60
> 
38a61
> 
38a62
> 
49a74
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.Parser2
( pModEntRel
, parsePkgKey, parsePkgKeys )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Scanner.Scanner
import UHC.Light.Compiler.Base.ParseUtils
import UHC.Light.Compiler.Base.Parser
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.FileSearchLocation
import UHC.Light.Compiler.Module.ImportExport
import qualified Data.Set as Set
import qualified UHC.Util.Rel as Rel
import Data.Version



{-# LINE 41 "src/ehc/Base/Parser2.chs" #-}
pPkgKey :: P PkgKey
pPkgKey = (concat <$> pList1_ng (pVarid <|> pConid <|> ("-" <$ pMINUS))) <+> pMb (pMINUS *> pVersion)

pVersion :: P Version
pVersion = (\v -> Version (map read v) []) <$> pList1Sep pDOT pInteger10

{-# LINE 49 "src/ehc/Base/Parser2.chs" #-}
scanOptsPkgKey = defaultScanOpts {scoSpecChars = Set.fromList ".-", scoAllowFloat = False}

parsePkgKey :: String -> Maybe PkgKey
parsePkgKey = parseString scanOptsPkgKey pPkgKey

parsePkgKeys :: String -> Maybe [PkgKey]
parsePkgKeys = parseString scanOptsPkgKey (pList pPkgKey)

{-# LINE 63 "src/ehc/Base/Parser2.chs" #-}
pModEnt :: P ModEnt
pModEnt
  = (\kind occ owns -> ModEnt kind occ owns emptyRange)
    <$  pOCURLY <*> pIdOccKind <* pCOMMA <*> pIdOcc
    <*> pMaybe Set.empty id (Set.fromList <$ pCOMMA <* pOCURLY <*> pListSep pCOMMA pModEnt <* pCCURLY)
    <*  pCCURLY

pModEntRel :: P ModEntRel
pModEntRel
  = Rel.fromList <$> pAssocL pDollNm pModEnt

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.Parser2
( pModEntRel
, parsePkgKey, parsePkgKeys )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Scanner.Scanner
import UHC.Light.Compiler.Base.ParseUtils
import UHC.Light.Compiler.Base.Parser
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.FileSearchLocation
import UHC.Light.Compiler.Module.ImportExport
import qualified Data.Set as Set
import qualified UHC.Util.Rel as Rel
import Data.Version






















pPkgKey :: P PkgKey
pPkgKey = (concat <$> pList1_ng (pVarid <|> pConid <|> ("-" <$ pMINUS))) <+> pMb (pMINUS *> pVersion)

pVersion :: P Version
pVersion = (\v -> Version (map read v) []) <$> pList1Sep pDOT pInteger10



scanOptsPkgKey = defaultScanOpts {scoSpecChars = Set.fromList ".-", scoAllowFloat = False}

parsePkgKey :: String -> Maybe PkgKey
parsePkgKey = parseString scanOptsPkgKey pPkgKey

parsePkgKeys :: String -> Maybe [PkgKey]
parsePkgKeys = parseString scanOptsPkgKey (pList pPkgKey)







pModEnt :: P ModEnt
pModEnt
  = (\kind occ owns -> ModEnt kind occ owns emptyRange)
    <$  pOCURLY <*> pIdOccKind <* pCOMMA <*> pIdOcc
    <*> pMaybe Set.empty id (Set.fromList <$ pCOMMA <* pOCURLY <*> pListSep pCOMMA pModEnt <* pCCURLY)
    <*  pCCURLY

pModEntRel :: P ModEntRel
pModEntRel
  = Rel.fromList <$> pAssocL pDollNm pModEnt


</pre>