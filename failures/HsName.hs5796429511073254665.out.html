<a href="hslinks.hs12936551941338403330.out.html">prev</a></br><a href="failures.html">home</a></br><a href="HsToken.hs129358050083021272.out.html">next</a></br></br><pre>57c57
< import Numeric
---
> import-- | A HsNameUniqifier represents the 'type' of unificationNumeric
59d58
< import Data.Char
60d58
< import Control.Monad
61d58
< import UHC.Util.Binary
62d58
< import UHC.Util.Serialize
63d58
< import Data.Hashable
64d58
< 
65d58
< 
66d58
< 
67d58
< 
68d58
< 
69d58
< 
70d58
< 
71d58
< 
72d58
< 
73d58
< {-# LINE 57 "src/ehc/Base/HsName.chs" #-}
74d58
< -- | A HsNameUniqifier represents the 'type' of unification
75d58
< data HsNameUniqifier
76d58
<   = HsNameUniqifier_Blank               -- just a new identifier, with an empty show
77d58
<   | HsNameUniqifier_New                 -- just a new identifier
78d58
<   | HsNameUniqifier_Error               -- error
79c59
<   | HsNameUniqifier_GloballyUnique      -- globally unique
---
> import Data.Char                        -- just a new identifier, with an empty show
79a60
> import Control.Monad                    -- just a new identifier
79a61
> import UHC.Util.Binary                  -- error
79a62
> import UHC.Util.Serialize               -- globally unique
79a63
> import Data.Hashable HsNameUniqifier
79a64
>   = HsNameUniqifier_Blank
79a65
>   | HsNameUniqifier_New
79a66
>   | HsNameUniqifier_Error
79a67
>   | HsNameUniqifier_GloballyUnique
131c119
< {-# LINE 146 "src/ehc/Base/HsName.chs" #-}
---
> 
131a120
> 
131a121
> 
131a122
> 
131a123
> 
131a124
> 
131a125
> 
131a126
> 
131a127
> 
131a128
> 
131a129
> 
131a130
> 
131a131
> 
131a132
> 
131a133
> 
131a134
> 
131a135
> 
131a136
> 
131a137
> 
131a138
> 
131a139
> 
131a140
> 
131a141
> 
131a142
> 
131a143
> 
131a144
> 
131a145
> 
131a146
> 
131a147
> 
131a148
> 
131a149
> 
131a150
> 
149c168
< {-# LINE 165 "src/ehc/Base/HsName.chs" #-}
---
> 
149a169
> 
169c189
< {-# LINE 200 "src/ehc/Base/HsName.chs" #-}
---
> 
169a190
> 
169a191
> 
169a192
> 
169a193
> 
169a194
> 
169a195
> 
169a196
> 
169a197
> 
169a198
> 
169a199
> 
169a200
> 
169a201
> 
169a202
> 
169a203
> 
169a204
> 
176c211
< {-# LINE 212 "src/ehc/Base/HsName.chs" #-}
---
> 
176a212
> 
176a213
> 
176a214
> 
176a215
> 
176a216
> 
203c243
< {-# LINE 240 "src/ehc/Base/HsName.chs" #-}
---
> 
203a244
> 
211c252
< {-# LINE 249 "src/ehc/Base/HsName.chs" #-}
---
> 
211a253
> 
221c263
< {-# LINE 264 "src/ehc/Base/HsName.chs" #-}
---
> 
221a264
> 
221a265
> 
221a266
> 
221a267
> 
221a268
> 
248c295
< {-# LINE 292 "src/ehc/Base/HsName.chs" #-}
---
> 
248a296
> 
255c303
< {-# LINE 306 "src/ehc/Base/HsName.chs" #-}
---
> 
255a304
> 
255a305
> 
255a306
> 
255a307
> 
255a308
> 
255a309
> 
255a310
> 
276c331
< {-# LINE 332 "src/ehc/Base/HsName.chs" #-}
---
> 
276a332
> 
276a333
> 
276a334
> 
276a335
> 
276a336
> 
280c340
< {-# LINE 346 "src/ehc/Base/HsName.chs" #-}
---
> 
280a341
> 
280a342
> 
280a343
> 
280a344
> 
280a345
> 
280a346
> 
280a347
> 
280a348
> 
280a349
> 
280a350
> 
290c360
< {-# LINE 357 "src/ehc/Base/HsName.chs" #-}
---
> 
290a361
> 
300c371
< {-# LINE 368 "src/ehc/Base/HsName.chs" #-}
---
> 
300a372
> 
307c379
< {-# LINE 380 "src/ehc/Base/HsName.chs" #-}
---
> 
307a380
> 
307a381
> 
307a382
> 
307a383
> 
307a384
> 
313c390
< {-# LINE 395 "src/ehc/Base/HsName.chs" #-}
---
> 
313a391
> 
313a392
> 
313a393
> 
313a394
> 
313a395
> 
313a396
> 
313a397
> 
313a398
> 
313a399
> 
318c404
< {-# LINE 405 "src/ehc/Base/HsName.chs" #-}
---
> 
318a405
> 
318a406
> 
318a407
> 
318a408
> 
318a409
> 
325c416
< {-# LINE 415 "src/ehc/Base/HsName.chs" #-}
---
> 
325a417
> 
325a418
> 
325a419
> 
338c432
< {-# LINE 433 "src/ehc/Base/HsName.chs" #-}
---
> 
338a433
> 
338a434
> 
338a435
> 
338a436
> 
338a437
> 
353c452
< {-# LINE 449 "src/ehc/Base/HsName.chs" #-}
---
> 
353a453
> 
358c458
< {-# LINE 459 "src/ehc/Base/HsName.chs" #-}
---
> 
358a459
> 
358a460
> 
358a461
> 
358a462
> 
358a463
> 
364c469
< {-# LINE 474 "src/ehc/Base/HsName.chs" #-}
---
> 
364a470
> 
364a471
> 
364a472
> 
364a473
> 
364a474
> 
364a475
> 
364a476
> 
364a477
> 
364a478
> 
369c483
< {-# LINE 485 "src/ehc/Base/HsName.chs" #-}
---
> 
369a484
> 
369a485
> 
369a486
> 
369a487
> 
369a488
> 
369a489
> 
377c497
< {-# LINE 494 "src/ehc/Base/HsName.chs" #-}
---
> 
377a498
> 
381c502
< {-# LINE 500 "src/ehc/Base/HsName.chs" #-}
---
> 
381a503
> 
381a504
> 
403c526
< {-# LINE 525 "src/ehc/Base/HsName.chs" #-}
---
> 
403a527
> 
403a528
> 
403a529
> 
407c533
< {-# LINE 535 "src/ehc/Base/HsName.chs" #-}
---
> 
407a534
> 
407a535
> 
407a536
> 
407a537
> 
407a538
> 
407a539
> 
413c545
< {-# LINE 544 "src/ehc/Base/HsName.chs" #-}
---
> 
413a546
> 
413a547
> 
413a548
> 
417c552
< {-# LINE 549 "src/ehc/Base/HsName.chs" #-}
---
> 
417a553
> 
421c557
< {-# LINE 554 "src/ehc/Base/HsName.chs" #-}
---
> 
421a558
> 
433c570
< {-# LINE 567 "src/ehc/Base/HsName.chs" #-}
---
> 
433a571
> 
438c576
< {-# LINE 580 "src/ehc/Base/HsName.chs" #-}
---
> 
438a577
> 
438a578
> 
438a579
> 
438a580
> 
438a581
> 
438a582
> 
438a583
> 
438a584
> 
468c614
< {-# LINE 613 "src/ehc/Base/HsName.chs" #-}
---
> 
468a615
> 
468a616
> 
468a617
> 
488c637
< {-# LINE 637 "src/ehc/Base/HsName.chs" #-}
---
> 
488a638
> 
488a639
> 
488a640
> 
488a641
> 
497c650
< {-# LINE 648 "src/ehc/Base/HsName.chs" #-}
---
> 
497a651
> 
497a652
> 
501c656
< {-# LINE 657 "src/ehc/Base/HsName.chs" #-}
---
> 
501a657
> 
501a658
> 
501a659
> 
501a660
> 
501a661
> 
506c666
< {-# LINE 667 "src/ehc/Base/HsName.chs" #-}
---
> 
506a667
> 
506a668
> 
506a669
> 
506a670
> 
506a671
> 
532c697
< {-# LINE 694 "src/ehc/Base/HsName.chs" #-}
---
> 
532a698
> 
545c711
< {-# LINE 720 "src/ehc/Base/HsName.chs" #-}
---
> 
545a712
> 
545a713
> 
545a714
> 
545a715
> 
545a716
> 
545a717
> 
545a718
> 
545a719
> 
545a720
> 
545a721
> 
545a722
> 
545a723
> 
545a724
> 
556c735
< {-# LINE 736 "src/ehc/Base/HsName.chs" #-}
---
> 
556a736
> 
556a737
> 
556a738
> 
556a739
> 
556a740
> 
567c751
< {-# LINE 752 "src/ehc/Base/HsName.chs" #-}
---
> 
567a752
> 
567a753
> 
567a754
> 
567a755
> 
567a756
> 
572c761
< {-# LINE 762 "src/ehc/Base/HsName.chs" #-}
---
> 
572a762
> 
572a763
> 
572a764
> 
572a765
> 
572a766
> 
579c773
< {-# LINE 774 "src/ehc/Base/HsName.chs" #-}
---
> 
579a774
> 
579a775
> 
579a776
> 
579a777
> 
579a778
> 
590c789
< {-# LINE 786 "src/ehc/Base/HsName.chs" #-}
---
> 
590a790
> 
595c795
< {-# LINE 797 "src/ehc/Base/HsName.chs" #-}
---
> 
595a796
> 
595a797
> 
595a798
> 
595a799
> 
595a800
> 
595a801
> 
600c806
< {-# LINE 803 "src/ehc/Base/HsName.chs" #-}
---
> 
600a807
> 
613c820
< {-# LINE 826 "src/ehc/Base/HsName.chs" #-}
---
> 
613a821
> 
613a822
> 
613a823
> 
613a824
> 
613a825
> 
613a826
> 
613a827
> 
613a828
> 
613a829
> 
613a830
> 
619c836
< {-# LINE 837 "src/ehc/Base/HsName.chs" #-}
---
> 
619a837
> 
619a838
> 
619a839
> 
619a840
> 
619a841
> 
638c860
< {-# LINE 861 "src/ehc/Base/HsName.chs" #-}
---
> 
638a861
> 
638a862
> 
638a863
> 
638a864
> 
638a865
> 
705c932
< {-# LINE 933 "src/ehc/Base/HsName.chs" #-}
---
> 
705a933
> 
705a934
> 
705a935
> 
705a936
> 
705a937
> 
720c952
< {-# LINE 959 "src/ehc/Base/HsName.chs" #-}
---
> 
720a953
> 
720a954
> 
720a955
> 
720a956
> 
720a957
> 
720a958
> 
720a959
> 
720a960
> 
720a961
> 
720a962
> 
720a963
> 
735c978
< {-# LINE 985 "src/ehc/Base/HsName.chs" #-}
---
> 
735a979
> 
735a980
> 
735a981
> 
735a982
> 
735a983
> 
735a984
> 
735a985
> 
735a986
> 
735a987
> 
735a988
> 
735a989
> 
740c994
< {-# LINE 991 "src/ehc/Base/HsName.chs" #-}
---
> 
740a995
> 
746c1001
< {-# LINE 1002 "src/ehc/Base/HsName.chs" #-}
---
> 
746a1002
> 
746a1003
> 
746a1004
> 
746a1005
> 
746a1006
> 
749c1009
< {-# LINE 1010 "src/ehc/Base/HsName.chs" #-}
---
> 
749a1010
> 
749a1011
> 
749a1012
> 
749a1013
> 
749a1014
> 
760c1025
< {-# LINE 1037 "src/ehc/Base/HsName.chs" #-}
---
> 
760a1026
> 
760a1027
> 
760a1028
> 
760a1029
> 
760a1030
> 
760a1031
> 
760a1032
> 
760a1033
> 
760a1034
> 
760a1035
> 
760a1036
> 
760a1037
> 
760a1038
> 
760a1039
> 
760a1040
> 
760a1041
> 
764c1045
< {-# LINE 1046 "src/ehc/Base/HsName.chs" #-}
---
> 
764a1046
> 
764a1047
> 
764a1048
> 
764a1049
> 
764a1050
> 
770c1056
< {-# LINE 1057 "src/ehc/Base/HsName.chs" #-}
---
> 
770a1057
> 
770a1058
> 
770a1059
> 
770a1060
> 
770a1061
> 
786c1077
< {-# LINE 1074 "src/ehc/Base/HsName.chs" #-}
---
> 
786a1078
> 
791c1083
< {-# LINE 1084 "src/ehc/Base/HsName.chs" #-}
---
> 
791a1084
> 
791a1085
> 
791a1086
> 
791a1087
> 
791a1088
> 
795d1091
< {-# LINE 1093 "src/ehc/Base/HsName.chs" #-}
796a1093
> 
796a1094
> 
796a1095
> 
796a1096
> 
796a1097
> 
796a1098
> 
806d1107
< {-# LINE 1105 "src/ehc/Base/HsName.chs" #-}
807a1109
> 
807a1110
> 
828a1132
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.HsName
( HSNM (..)
, HsName
, hsnEmpty
, mkHNmBase
, hsnEnsureIsBase
, hsnBaseUnpack', hsnBaseUnpack
, hsnMbBaseString, hsnIsBaseString, hsnBaseString
, hsnFromString
, hsnInitLast
, hsnPrefix, hsnSuffix, mkHNmPrefix
, IdOccKind (..)
, IdOcc (..)
, hsnUnknown
, HsNameS
, HsNameUniqifier (..)
, HsNameUnique (..)
, HsNameUniqifierMp
, hsnUniqify, hsnUniqifyUID, hsnUniqifyStr, hsnUniqifyInt, hsnUniqifyEval
, hsnMbPos, hsnIsPos
, hsnMkModf
, mkHNmPos
, cmpHsNameOnNm
, hsnShow, hsnShow'
, rowLabCmp
, OrigName (..)
, hsnStripUniqify
, hsnSimplifications
, hsnMbNr, hsnIsNr
, hsnMkNr
, hsnShowAlphanumeric, hsnShowAlphanumericShort
, hsnSplitQualify, hsnQualified, hsnPrefixQual, hsnMapQualified
, hsnQualifier, hsnSetQual, hsnIsQual
, hsnFixUniqifiers
, hsnStripUniqifiers
, hsnSafeJavaLike
, FvS, FvSMp
, HsNameMp, hsnRepl
, RPatNm (..)
, rpatNmIsOrig
, Track (..)
, hsnConcat
, hsnMapQual, hsnSetLevQual
, hsnQualUniqify )
where
import UHC.Util.Utils
import UHC.Util.Pretty
import Data.List
import UHC.Light.Compiler.Base.UID
import UU.Scanner.Position
import qualified Data.Set as Set
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe
import Data.Char
import Numeric
import UHC.Util.FPath
import Data.Char
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize
import Data.Hashable









{-# LINE 57 "src/ehc/Base/HsName.chs" #-}
-- | A HsNameUniqifier represents the 'type' of unification
data HsNameUniqifier
  = HsNameUniqifier_Blank               -- just a new identifier, with an empty show
  | HsNameUniqifier_New                 -- just a new identifier
  | HsNameUniqifier_Error               -- error
  | HsNameUniqifier_GloballyUnique      -- globally unique
  | HsNameUniqifier_Evaluated           -- evaluated
  | HsNameUniqifier_Field               -- extracted field
  | HsNameUniqifier_Class               -- class
  | HsNameUniqifier_ClassDict           -- dictionary
  | HsNameUniqifier_SelfDict            -- dictionary under construction itself, passed as arg in tying the knot recursion
  | HsNameUniqifier_ResultDict          -- dictionary under construction result
  | HsNameUniqifier_SuperClass          -- super class field
  | HsNameUniqifier_DictField           -- dictionary field
  | HsNameUniqifier_Inline              -- new identifier because of inlining
  | HsNameUniqifier_GloballyUniqueDict  -- globally unique dictionary
  | HsNameUniqifier_FieldOffset         -- offset for a field
  | HsNameUniqifier_CaseContinuation    -- continuation of a case expression
  | HsNameUniqifier_GrinUpdated         -- Grin: updated value
  | HsNameUniqifier_FFIArg              -- arg evaluated for FFI
  | HsNameUniqifier_LacksLabel          -- label used in lacking predicates
  | HsNameUniqifier_BindAspect          -- binding aspect
  | HsNameUniqifier_Strict              -- strict variant of binding
  | HsNameUniqifier_GenericClass        -- a name introduced by generics
  | HsNameUniqifier_FFE                 -- name of value to be ff exported
  | HsNameUniqifier_FFECoerced          -- name of possibly coerced value to be ff exported
  | HsNameUniqifier_CoreAPI             -- Used by the Core API, to allow external programs to generate new identifiers.
  deriving (Eq,Ord,Enum)

-- | The show of a HsNameUniqifier is found back in the pretty printed code, current convention is 3 uppercase letters, as a balance between size and clarity of meaning
instance Show HsNameUniqifier where
  show HsNameUniqifier_Blank                = ""
  show HsNameUniqifier_New                  = "NEW"
  show HsNameUniqifier_Error                = "ERR"
  show HsNameUniqifier_GloballyUnique       = "UNQ"
  show HsNameUniqifier_Evaluated            = "EVL"
  show HsNameUniqifier_Field                = "FLD"
  show HsNameUniqifier_Class                = "CLS"
  show HsNameUniqifier_ClassDict            = "DCT"
  show HsNameUniqifier_SelfDict             = "SDC"
  show HsNameUniqifier_ResultDict           = "RDC"
  show HsNameUniqifier_SuperClass           = "SUP"
  show HsNameUniqifier_DictField            = "DFL"
  show HsNameUniqifier_Inline               = "INL"
  show HsNameUniqifier_GloballyUniqueDict   = "UND"
  show HsNameUniqifier_FieldOffset          = "OFF"
  show HsNameUniqifier_CaseContinuation     = "CCN"
  show HsNameUniqifier_GrinUpdated          = "UPD"
  show HsNameUniqifier_FFIArg               = "FFI"
  show HsNameUniqifier_LacksLabel           = "LBL"
  show HsNameUniqifier_BindAspect           = "ASP"
  show HsNameUniqifier_Strict               = "STR"
  show HsNameUniqifier_GenericClass         = "GEN"
  show HsNameUniqifier_FFE                  = "FFE"
  show HsNameUniqifier_FFECoerced           = "FFC"
  show HsNameUniqifier_CoreAPI              = "CRA"

{-# LINE 146 "src/ehc/Base/HsName.chs" #-}
-- | A HsNameUnique represents the optional additional info to make the uniqification even more unique
data HsNameUnique
  = HsNameUnique_None
  | HsNameUnique_String     !String
  | HsNameUnique_Int        !Int
  | HsNameUnique_UID        !UID
  deriving (Eq,Ord)

showHsNameUnique :: (UID -> String) -> (String -> String) -> HsNameUnique -> String
showHsNameUnique _    _    (HsNameUnique_None    ) = ""
showHsNameUnique _    shws (HsNameUnique_String s) = shws s
showHsNameUnique _    _    (HsNameUnique_Int    i) = show i
showHsNameUnique shwu _    (HsNameUnique_UID    u) = shwu u

instance Show HsNameUnique where
  show = showHsNameUnique hsnShowUID id

{-# LINE 165 "src/ehc/Base/HsName.chs" #-}
type HsNameUniqifierMp = Map.Map HsNameUniqifier [HsNameUnique]

emptyHsNameUniqifierMp :: HsNameUniqifierMp
emptyHsNameUniqifierMp = Map.empty

-- | Show uniqifier map, parseable back again when properly parameterized.
showHsNameUniqifierMp'' :: (UID -> String) -> (String -> String) -> (String -> String) -> Bool -> String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp'' shwu shws brk showLen usep us
  = [ usep ++ slen u ++ show uqf ++ (brk $ concat [ usep ++ showHsNameUnique shwu shws uu | uu <- u, uu /= HsNameUnique_None ]) | (uqf,u) <- Map.toList us ]
  where slen u | showLen && l /= 1  = usep ++ show l
               | otherwise          = ""
               where l = length u

showHsNameUniqifierMp' :: Bool -> String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp' = showHsNameUniqifierMp'' hsnShowUID id id

showHsNameUniqifierMp :: String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp = showHsNameUniqifierMp' True

{-# LINE 200 "src/ehc/Base/HsName.chs" #-}
uniqifierMpAdd :: HsNameUniqifier -> HsNameUnique -> HsNameUniqifierMp -> HsNameUniqifierMp
uniqifierMpAdd ufier u m = Map.unionWith (++) (Map.singleton ufier [u]) m

uniqifierMpUnion :: HsNameUniqifierMp -> HsNameUniqifierMp -> HsNameUniqifierMp
uniqifierMpUnion = Map.unionWith (++)

{-# LINE 212 "src/ehc/Base/HsName.chs" #-}
hsnUniqify' :: HsNameUniqifier -> HsNameUnique -> HsName -> HsName
hsnUniqify' ufier u
  = mk
  where mk n@(HsName_Modf {hsnUniqifiers=us}) = hsnFixateHash (n {hsnUniqifiers = uniqifierMpAdd ufier u us})
        mk n                                  = mk (hsnMkModf [] n Map.empty)

-- | Uniqify with just a name suffix
hsnUniqify :: HsNameUniqifier -> HsName -> HsName
hsnUniqify ufier = hsnUniqify' ufier HsNameUnique_None

-- | Uniqify with a name suffix + extra Int uniq info
hsnUniqifyInt :: HsNameUniqifier -> Int -> HsName -> HsName
hsnUniqifyInt ufier u = hsnUniqify' ufier (HsNameUnique_Int u)

-- | Uniqify with a name suffix + extra UID uniq info
hsnUniqifyUID :: HsNameUniqifier -> UID -> HsName -> HsName
hsnUniqifyUID ufier u = hsnUniqify' ufier (HsNameUnique_UID u)

-- | Uniqify with a name suffix + extra String uniq info
hsnUniqifyStr :: HsNameUniqifier -> String -> HsName -> HsName
hsnUniqifyStr ufier u = hsnUniqify' ufier (HsNameUnique_String u)

-- | Uniqify for use as evaluated name
hsnUniqifyEval :: HsName -> HsName
hsnUniqifyEval = hsnUniqify HsNameUniqifier_Evaluated

{-# LINE 240 "src/ehc/Base/HsName.chs" #-}
-- | Remove uniqification, if present
hsnStripUniqify :: HsName -> Maybe HsName
hsnStripUniqify n@(HsName_Modf {hsnUniqifiers=us})
  | Map.null us   = Nothing
  | otherwise     = Just $ n {hsnUniqifiers = Map.empty}
hsnStripUniqify _ = Nothing

{-# LINE 249 "src/ehc/Base/HsName.chs" #-}
-- | Simplify name into list of simplifications of increasing complexity, all strictly simpler than the one given. [] therefore means no simplifications exist
hsnSimplifications :: HsName -> [HsName]
hsnSimplifications n@(HsName_Modf {}) = case hsnStripUniqify n of
    Just n' -> hsnSimplifications n' ++ [n']
    _       -> hsnSimplifications $ hsnBase n
hsnSimplifications   (HsName_UID  {hsnUID = u}) = map mkHNm $ uidSimplifications u
-- hsnSimplifications n@(HsName_Base {}          ) = [] -- [n]
hsnSimplifications _                            = []

{-# LINE 264 "src/ehc/Base/HsName.chs" #-}
hsnHashWithSalt :: Int -> HsName -> Int
hsnHashWithSalt salt (HsName_Base s      ) = hashWithSalt salt s
hsnHashWithSalt salt (HsName_UID  i      ) = hashWithSalt salt i
hsnHashWithSalt salt (HsName_Pos  p      ) = hashWithSalt salt p
hsnHashWithSalt salt (HsName_Modf _ q b u) = hashWithSalt salt q `hashWithSalt` hashWithSalt salt b `hashWithSalt` hashWithSalt salt (Map.toList u)
hsnHashWithSalt salt (HsName_Nr i n      ) = i `hashWithSalt` hashWithSalt salt n

instance Hashable HsName where
  hashWithSalt salt n@(HsName_Modf h _ _ _) | h /= 0 = h
  hashWithSalt salt n                                = hsnHashWithSalt salt n

instance Hashable OrigName where
  hashWithSalt salt (OrigNone    ) = salt
  hashWithSalt salt (OrigLocal  n) = 23 `hashWithSalt` hashWithSalt salt n
  hashWithSalt salt (OrigGlobal n) = 19 `hashWithSalt` hashWithSalt salt n
  hashWithSalt salt (OrigFunc   n) = 17 `hashWithSalt` hashWithSalt salt n

instance Hashable HsNameUnique where
  hashWithSalt salt (HsNameUnique_None    ) = salt
  hashWithSalt salt (HsNameUnique_String s) = hashWithSalt salt s
  hashWithSalt salt (HsNameUnique_Int    i) = hashWithSalt salt i
  hashWithSalt salt (HsNameUnique_UID    u) = hashWithSalt salt u

instance Hashable HsNameUniqifier where
  hashWithSalt salt u = hashWithSalt salt (fromEnum u)

{-# LINE 292 "src/ehc/Base/HsName.chs" #-}
-- | Fixate hash
hsnFixateHash :: HsName -> HsName
hsnFixateHash n@(HsName_Modf _ _ _ _) = n {hsnHash = hsnHashWithSalt 17 n}
hsnFixateHash n                       = n
{-# INLINE hsnFixateHash #-}

{-# LINE 306 "src/ehc/Base/HsName.chs" #-}
-- | Haskell name representation, exports of constructors only intented for internal use
data HsName
  =   HsName_Base
        { hsnBaseStr            ::  !String
        }
  |   HsName_UID
        { hsnUID                ::  !UID
        }
  |   HsName_Modf
        {
          -- a secret hash, prefixing other fields as to enforce comparison on the hash first; only used at variant 99 and onwards to avoid clutter
          hsnHash               ::  !Int
        , hsnQualifiers         ::  ![String]
        , hsnBase               ::  !HsName
        , hsnUniqifiers         ::  !HsNameUniqifierMp
        }
  |   HsName_Pos                    !Int
  |   HsName_Nr                     !Int !OrigName
  deriving (Eq,Ord)

{-# LINE 332 "src/ehc/Base/HsName.chs" #-}
hsnEmpty :: HsName
hsnEmpty = mkHNm ""

{-# LINE 346 "src/ehc/Base/HsName.chs" #-}
-- | Is HsName a HsName_Pos?
hsnMbPos :: HsName -> Maybe Int
hsnMbPos (HsName_Pos p) = Just p
hsnMbPos _              = Nothing

hsnIsPos :: HsName -> Bool
hsnIsPos = isJust . hsnMbPos
{-# INLINE hsnIsPos #-}

{-# LINE 357 "src/ehc/Base/HsName.chs" #-}
-- | Is HsName a HsName_Pos?
hsnMbNr :: HsName -> Maybe (Int,OrigName)
hsnMbNr (HsName_Nr i o) = Just (i,o)
hsnMbNr _               = Nothing

hsnIsNr :: HsName -> Bool
hsnIsNr = isJust . hsnMbNr
{-# INLINE hsnIsNr #-}

{-# LINE 368 "src/ehc/Base/HsName.chs" #-}
-- | Smart constructor for HsName_Modf
hsnMkModf :: [String] -> HsName -> HsNameUniqifierMp -> HsName
-- hsnMkModf q b u = hsnFixateHash $ HsName_Modf 0 q b u
hsnMkModf q b u = hsnFixateHash $ either (\(_,n) -> n {hsnQualifiers = q, hsnUniqifiers = hsnUniqifiers n `uniqifierMpUnion` u}) (\b -> HsName_Modf 0 q b u) $ hsnCanonicSplit b
{-# INLINE hsnMkModf #-}

{-# LINE 380 "src/ehc/Base/HsName.chs" #-}
-- | Smart constructor for HsName_Nr
hsnMkNr :: Int -> OrigName -> HsName
hsnMkNr = HsName_Nr
{-# INLINE hsnMkNr #-}

{-# LINE 395 "src/ehc/Base/HsName.chs" #-}
-- | Just lift a string to the base HsName variant
mkHNmBase :: String -> HsName
mkHNmBase s = hsnMkModf [] (HsName_Base s) Map.empty

{-# LINE 405 "src/ehc/Base/HsName.chs" #-}
-- | Eliminate alternative internal representations
hsnEnsureIsBase :: HsName -> HsName
hsnEnsureIsBase n@(HsName_UID _) = mkHNm $ show n
hsnEnsureIsBase   (HsName_Pos i) = mkHNm $ show i
hsnEnsureIsBase n                = n

{-# LINE 415 "src/ehc/Base/HsName.chs" #-}
-- | unpack a HsName into qualifiers + base string + repack function
hsnBaseUnpack' :: HsName -> Maybe ([String],String,[String] -> String -> HsName)
hsnBaseUnpack' (HsName_Base s    ) = Just ([],s,\_ s -> HsName_Base s)
hsnBaseUnpack' (HsName_Modf _ q b u) = fmap (\(bs,mk) -> (q, bs, \q s -> hsnMkModf q (mk s) u)) (hsnBaseUnpack b)
hsnBaseUnpack' _                     = Nothing

-- | unpack a HsName into base string + repack function
hsnBaseUnpack :: HsName -> Maybe (String,String -> HsName)
hsnBaseUnpack (HsName_Base s    ) = Just (s,HsName_Base)
hsnBaseUnpack (HsName_Modf _ q b u) = fmap (\(bs,mk) -> (bs, \s -> hsnMkModf q (mk s) u)) (hsnBaseUnpack b)
hsnBaseUnpack _                     = Nothing

{-# LINE 433 "src/ehc/Base/HsName.chs" #-}
-- | If name is a HsName_Base after some unpacking, return the base string, without qualifiers, without uniqifiers
hsnMbBaseString :: HsName -> Maybe String
hsnMbBaseString = fmap fst . hsnBaseUnpack
{-# INLINE hsnMbBaseString #-}

-- | Is name is a HsName_Base after some unpacking?
hsnIsBaseString :: HsName -> Bool
hsnIsBaseString = isJust . hsnMbBaseString
{-# INLINE hsnIsBaseString #-}

hsnBaseString :: HsName -> String
hsnBaseString = maybe "??" id . hsnMbBaseString


{-# LINE 449 "src/ehc/Base/HsName.chs" #-}
-- | Just lift a int to the int HsName variant
mkHNmPos :: Int -> HsName
mkHNmPos s = hsnMkModf [] (HsName_Pos s) Map.empty

{-# LINE 459 "src/ehc/Base/HsName.chs" #-}
-- | Compare, ignoring hash
cmpHsNameOnNm :: HsName -> HsName -> Ordering
cmpHsNameOnNm (HsName_Modf _ q1 b1 u1) (HsName_Modf _ q2 b2 u2) = compare (HsName_Modf 0 q1 b1 u1)  (HsName_Modf 0 q2 b2 u2)
cmpHsNameOnNm n1                       n2                       = compare n1                        n2

{-# LINE 474 "src/ehc/Base/HsName.chs" #-}
hsnFromString :: String -> HsName
hsnFromString = mkHNmBase
{-# INLINE hsnFromString #-}

{-# LINE 485 "src/ehc/Base/HsName.chs" #-}
data OrigName
  = OrigNone
  | OrigLocal  HsName
  | OrigGlobal HsName
  | OrigFunc   HsName
  deriving (Eq,Ord)

{-# LINE 494 "src/ehc/Base/HsName.chs" #-}
instance PP HsName where
  pp h = pp (show h)

{-# LINE 500 "src/ehc/Base/HsName.chs" #-}
-- | Parameterizable show of HsName when used from within the Show instance for HsName, or for a parseable representation used by (e.g.) Core pretty printing
hsnShow' :: (UID -> String) -> (String -> String) -> (String -> String) -> String -> String -> HsName -> String
hsnShow' shwu shws brk qsep usep n
    = shw n
  where shw n = case n of
          HsName_Base   s                 -> s
          HsName_UID    i                 -> shwu i
          HsName_Modf _ qs b us           -> concat $ (intersperse qsep $ qs ++ [shw b]) ++ showHsNameUniqifierMp'' shwu shws brk False usep us
          HsName_Pos    p                 -> show p
          HsName_Nr n OrigNone            -> "x_"        ++ show n
          HsName_Nr n (OrigLocal  hsn)    -> "x_"        ++ show n ++ "_" ++ shw hsn
          HsName_Nr n (OrigGlobal hsn)    -> "global_x_" ++ show n ++ "_" ++ shw hsn
          HsName_Nr n (OrigFunc   hsn)    -> "fun_x_"    ++ show n ++ "_" ++ shw hsn

-- | Parseable show of HsName when used from within the Show instance for HsName
hsnShow :: String -> String -> HsName -> String
hsnShow q u n = hsnShow' hsnShowUID id id q u n
{-# INLINE hsnShow #-}

hsnShowUID i = 'u' : show i

{-# LINE 525 "src/ehc/Base/HsName.chs" #-}
instance Show HsName where
  show = hsnShow "." "_@"

{-# LINE 535 "src/ehc/Base/HsName.chs" #-}
-- | A HsName is either a complex/aggregrate name or a base case
hsnCanonicSplit :: HsName -> Either ([String],HsName) HsName
hsnCanonicSplit n@(HsName_Modf _ qs _ _) = Left $ (qs, hsnFixateHash (n {hsnQualifiers = []}))
hsnCanonicSplit n                        = Right n

{-# LINE 544 "src/ehc/Base/HsName.chs" #-}
hsnToList :: HsName -> [HsName]
hsnToList n = either (\(qs,b) -> map mkHNmBase qs ++ [b]) (:[]) (hsnCanonicSplit n)

{-# LINE 549 "src/ehc/Base/HsName.chs" #-}
hsnInitLast :: HsName -> ([HsName],HsName)
hsnInitLast n = either (\(qs,b) -> (map mkHNmBase qs, b)) (\x -> ([],x)) (hsnCanonicSplit n)

{-# LINE 554 "src/ehc/Base/HsName.chs" #-}
hsnPrefix                           ::  String -> HsName -> HsName
hsnPrefix   p   hsn
  = maybe (mkHNmBase $ p ++ show hsn) (\(s,mk) -> mk $ p ++ s) $ hsnBaseUnpack hsn

hsnSuffix                           ::  HsName -> String -> HsName
hsnSuffix       hsn   p
  = maybe (mkHNmBase $ show hsn ++ p) (\(s,mk) -> mk $ s ++ p) $ hsnBaseUnpack hsn

mkHNmPrefix :: HSNM x => String -> x -> HsName
mkHNmPrefix p = hsnPrefix p . mkHNm

{-# LINE 567 "src/ehc/Base/HsName.chs" #-}
stringAlphanumeric :: String -> String
stringAlphanumeric s
  = concat (map (charAlphanumeric) s)

{-# LINE 580 "src/ehc/Base/HsName.chs" #-}
charAlphanumeric :: Char -> String
charAlphanumeric '\'' = "prime"
charAlphanumeric ':' = "colon"
charAlphanumeric '!' = "exclam"
charAlphanumeric '@' = "at"
charAlphanumeric '#' = "number"
charAlphanumeric '$' = "dollar"
charAlphanumeric '%' = "percent"
charAlphanumeric '^' = "circon"
charAlphanumeric '&' = "amp"
charAlphanumeric '*' = "star"
charAlphanumeric '+' = "plus"
charAlphanumeric '-' = "minus"
charAlphanumeric '.' = "dot"
charAlphanumeric '/' = "slash"
charAlphanumeric '\\' = "backsl"
charAlphanumeric '|' = "bar"
charAlphanumeric '<' = "lt"
charAlphanumeric '=' = "eq"
charAlphanumeric '>' = "gt"
charAlphanumeric '?' = "quest"
charAlphanumeric '~' = "tilde"
charAlphanumeric '[' = "sub"    -- although this is not a legal Haskell operator symbol, it can be part of the Nil constructor
charAlphanumeric ']' = "bus"
charAlphanumeric '(' = "open"    -- although this is not a legal Haskell operator symbol, it can be part of the tuple constructor
charAlphanumeric ',' = "comma"
charAlphanumeric ')' = "close"
charAlphanumeric  c  = [c]

{-# LINE 613 "src/ehc/Base/HsName.chs" #-}
dontStartWithDigit :: String -> String
dontStartWithDigit xs@(a:_) | isDigit a || a=='_' = "y"++xs
                            | otherwise           = xs

hsnShowAlphanumericShort :: HsName -> String
hsnShowAlphanumericShort (HsName_Nr n (OrigFunc   orig)) = hsnShowAlphanumeric orig
hsnShowAlphanumericShort x = hsnShowAlphanumeric x

hsnShowAlphanumeric :: HsName -> String
hsnShowAlphanumeric (HsName_Base s  )           = dontStartWithDigit(stringAlphanumeric s)
hsnShowAlphanumeric (HsName_UID  i  )           = "u" ++ show i
hsnShowAlphanumeric (HsName_Pos p)              = "y" ++ show p
hsnShowAlphanumeric (HsName_Nr n OrigNone)          = "x" ++ show n
hsnShowAlphanumeric (HsName_Nr n (OrigLocal orig))  = "x" ++ show n   -- hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Nr n (OrigGlobal orig)) = "global_" ++ hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Nr n (OrigFunc   orig)) = "fun_"    ++ hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Modf _ q b u)         = concat $ intersperse "_" $ q ++ [hsnShowAlphanumeric b] ++ map stringAlphanumeric (showHsNameUniqifierMp "_" u)
-- hsnShowAlphanumeric n                           = concat $ intersperse "_" $ map hsnShowAlphanumeric $ hsnToList n

{-# LINE 637 "src/ehc/Base/HsName.chs" #-}
hsnToFPath :: HsName -> FPath
hsnToFPath n
  = mkFPathFromDirsFile qs b
  where (qs,b) = hsnInitLast n

instance FPATH HsName where
  mkFPath = hsnToFPath

{-# LINE 648 "src/ehc/Base/HsName.chs" #-}
hsnConcat                           ::  HsName -> HsName -> HsName
hsnConcat       h1    h2            =   hsnFromString (show h1 ++ show h2)

{-# LINE 657 "src/ehc/Base/HsName.chs" #-}
-- compare for row labels, lexicographic ordering (currently)
rowLabCmp :: HsName -> HsName -> Ordering
rowLabCmp = cmpHsNameOnNm

{-# LINE 667 "src/ehc/Base/HsName.chs" #-}
-- qualifier (i.e. module name) and qualified part of name
hsnSplitQualify :: HsName -> (Maybe HsName,HsName)
hsnSplitQualify n
  = case hsnInitLast n of
      ([],n') -> (Nothing,n')
      (ns,n') -> (Just (mkHNm ns),n')

-- qualified part of a name
hsnQualified :: HsName -> HsName
hsnQualified = snd . hsnSplitQualify

-- prefix/qualify with module name, on top of possible previous qualifier
hsnPrefixQual :: HsName -> HsName -> HsName
hsnPrefixQual m n = mkHNm (hsnToList m ++ hsnToList n)

-- map qualified part
hsnMapQualified :: (String -> String) -> HsName -> HsName
hsnMapQualified f qn
  = maybe qn (\(s,mk) -> mk $ f s) $ hsnBaseUnpack qn
{-
  = case hsnSplitQualify qn of
      (Nothing,n) -> f n
      (Just q ,n) -> hsnPrefixQual q (f n)
-}

{-# LINE 694 "src/ehc/Base/HsName.chs" #-}
-- qualifier (i.e. module name) of name
hsnQualifier :: HsName -> Maybe HsName
hsnQualifier = fst . hsnSplitQualify

-- replace/set qualifier
hsnSetQual :: HsName -> HsName -> HsName
hsnSetQual m = hsnPrefixQual m . hsnQualified

-- is qualified?
hsnIsQual :: HsName -> Bool
hsnIsQual = isJust . hsnQualifier

{-# LINE 720 "src/ehc/Base/HsName.chs" #-}
hsnMapQual :: (HsName -> HsName) -> HsName -> HsName
hsnMapQual f qn
  = case hsnSplitQualify qn of
      (Nothing,n) -> qn
      (Just q ,n) -> hsnSetQual (f q) n

hsnSetLevQual :: Int -> HsName -> HsName -> HsName
hsnSetLevQual 0 m n = hsnSetQual m n
hsnSetLevQual _ _ n = n

{-# LINE 736 "src/ehc/Base/HsName.chs" #-}
hsnFixUniqifiers' :: Bool -> String -> HsName -> HsName
hsnFixUniqifiers' showlen sep (HsName_Modf _ qs n us) = hsnMkModf qs (hsnSuffix n (concat $ showHsNameUniqifierMp' showlen sep us)) Map.empty
hsnFixUniqifiers' _       _   n                       = n

hsnFixUniqifiers :: HsName -> HsName
hsnFixUniqifiers = hsnFixUniqifiers' True "_@"

hsnJavalikeFixUniqifiers :: HsName -> HsName
hsnJavalikeFixUniqifiers = hsnFixUniqifiers' False ""

{-# LINE 752 "src/ehc/Base/HsName.chs" #-}
hsnStripUniqifiers :: HsName -> HsName
hsnStripUniqifiers (HsName_Modf _ qs n us) = hsnMkModf qs n emptyHsNameUniqifierMp
hsnStripUniqifiers n                       = n

{-# LINE 762 "src/ehc/Base/HsName.chs" #-}
hsnQualUniqify :: HsName -> HsName -> HsName
hsnQualUniqify modNm n
  = if hsnIsQual n
    then n
    else hsnSetQual modNm n

{-# LINE 774 "src/ehc/Base/HsName.chs" #-}
class HSNM a where
  mkHNm :: a -> HsName

instance HSNM HsName where
  mkHNm = id

instance HSNM Int where
  mkHNm = mkHNm . show


{-# LINE 786 "src/ehc/Base/HsName.chs" #-}
instance HSNM UID where
  mkHNm = HsName_UID
  -- mkHNm x = hsnFromString ('_' : show x)

{-# LINE 797 "src/ehc/Base/HsName.chs" #-}
instance HSNM String where
  mkHNm s
    = mkHNm $ map hsnFromString $ splitForQualified s

{-# LINE 803 "src/ehc/Base/HsName.chs" #-}
instance HSNM ([HsName],HsName) where
  mkHNm (l,n) = mkHNm (l ++ [n])

instance HSNM [HsName] where
  mkHNm [n] = n
  mkHNm []  = hsnFromString "" -- ????, or empty alternative of HsName
  mkHNm ns  = case initlast ns of
                Just (i,l) -> case l of
                                n@(HsName_Modf _ _ _ _) -> hsnFixateHash (n {hsnQualifiers = qs})
                                n                       -> hsnMkModf qs n Map.empty
                           where qs = catMaybes $ map hsnMbBaseString i

{-# LINE 826 "src/ehc/Base/HsName.chs" #-}
instance Position HsName where
  line   _ = (-1)
  column _ = (-1)
  file   _ = ""

{-# LINE 837 "src/ehc/Base/HsName.chs" #-}
deriving instance Typeable HsNameUniqifier
deriving instance Data HsNameUniqifier

deriving instance Typeable HsNameUnique
deriving instance Data HsNameUnique

deriving instance Typeable HsName
deriving instance Data HsName

deriving instance Typeable OrigName
deriving instance Data OrigName

deriving instance Typeable IdOccKind
deriving instance Data IdOccKind

deriving instance Typeable IdOcc
deriving instance Data IdOcc

{-# LINE 861 "src/ehc/Base/HsName.chs" #-}
instance Binary HsNameUniqifier where
  put = putEnum8
  get = getEnum8

instance Binary HsNameUnique where
  put (HsNameUnique_String  a    ) = putWord8 0 >> put a
  put (HsNameUnique_Int     a    ) = putWord8 1 >> put a
  put (HsNameUnique_UID     a    ) = putWord8 2 >> put a
  put (HsNameUnique_None         ) = putWord8 3
  get = do t <- getWord8
           case t of
             0 -> liftM  HsNameUnique_String    get
             1 -> liftM  HsNameUnique_Int       get
             2 -> liftM  HsNameUnique_UID       get
             3 -> return HsNameUnique_None

instance Binary HsName where
  put (HsName_Base  a    ) = putWord8 0 >> put a
  put (HsName_UID   a    ) = putWord8 1 >> put a
  put (HsName_Pos   a    ) = putWord8 2 >> put a
  put (HsName_Nr        a b  ) = putWord8 3 >> put a >> put b
  put (HsName_Modf  a b c d) = putWord8 4 >> put a >> put b >> put c >> put d
  get = do t <- getWord8
           case t of
             0 -> liftM  HsName_Base    get
             1 -> liftM  HsName_UID     get
             2 -> liftM  HsName_Pos     get
             3 -> liftM2 HsName_Nr      get get
             4 -> liftM4 HsName_Modf    get get get get

instance Serialize HsName where
  sput = sputShared
  sget = sgetShared
  sputNested = sputPlain
  sgetNested = sgetPlain

instance Binary OrigName where
  put (OrigNone    ) = putWord8 0
  put (OrigLocal  a) = putWord8 1 >> put a
  put (OrigGlobal a) = putWord8 2 >> put a
  put (OrigFunc   a) = putWord8 3 >> put a
  get = do t <- getWord8
           case t of
             0 -> return OrigNone
             1 -> liftM  OrigLocal  get
             2 -> liftM  OrigGlobal get
             3 -> liftM  OrigFunc   get

instance Binary IdOccKind where
  put = putEnum8
  get = getEnum8

instance Serialize IdOccKind where
  sput = sputPlain
  sget = sgetPlain

instance Binary IdOcc where
  put (IdOcc a b) = put a >> put b
  get = liftM2 IdOcc get get

instance Serialize IdOcc where
  sput = sputShared
  sget = sgetShared
  sputNested = sputPlain
  sgetNested = sgetPlain

{-# LINE 933 "src/ehc/Base/HsName.chs" #-}
data IdOccKind
  = IdOcc_Val
  | IdOcc_Pat
  | IdOcc_Type
  | IdOcc_Kind
  | IdOcc_Fld
  | IdOcc_Class
  | IdOcc_Inst
  | IdOcc_Dflt
  | IdOcc_Any
  | IdOcc_Data
  | IdOcc_Fusion
  deriving (Eq,Ord,Enum)

{-# LINE 959 "src/ehc/Base/HsName.chs" #-}
-- intended for parsing
instance Show IdOccKind where
  show IdOcc_Val      = "Value"
  show IdOcc_Pat      = "Pat"
  show IdOcc_Type     = "Type"
  show IdOcc_Kind     = "Kind"
  show IdOcc_Fld      = "Field"
  show IdOcc_Class    = "Class"
  show IdOcc_Inst     = "Instance"
  show IdOcc_Dflt     = "Default"
  show IdOcc_Any      = "Any"
  show IdOcc_Data     = "Data"
  show IdOcc_Fusion   = "Fusion"

{-# LINE 985 "src/ehc/Base/HsName.chs" #-}
-- intended for parsing
instance PP IdOccKind where
  pp = text . show

{-# LINE 991 "src/ehc/Base/HsName.chs" #-}
data IdOcc
  = IdOcc { ioccNm :: !HsName, ioccKind :: !IdOccKind }
  deriving (Show,Eq,Ord)


{-# LINE 1002 "src/ehc/Base/HsName.chs" #-}
type HsNameS = Set.Set HsName

{-# LINE 1010 "src/ehc/Base/HsName.chs" #-}
-- ensure a name valid for backends which are more restrictive in their allowed identifier character set
hsnSafeJavaLike :: HsName -> HsName
hsnSafeJavaLike
  = hsnMapQualified (concatMap safe . first) . hsnJavalikeFixUniqifiers . hsnEnsureIsBase
  where safe '_'                                      = "__"
        safe c | isDigit c || isLetter c || c == '_'  = [c]
               | otherwise                            = "_" ++ showHex (ord c) ""
        first s@(c:_) | isDigit c = '_' : s
        first s                   =       s

{-# LINE 1037 "src/ehc/Base/HsName.chs" #-}
type FvS = HsNameS
type FvSMp = Map.Map HsName FvS

{-# LINE 1046 "src/ehc/Base/HsName.chs" #-}
type HsNameMp = Map.Map HsName HsName

hsnRepl :: HsNameMp -> HsName -> HsName
hsnRepl m n = Map.findWithDefault n n m

{-# LINE 1057 "src/ehc/Base/HsName.chs" #-}
data RPatNm
  = RPatNmOrig {rpatNmNm :: !HsName}
  | RPatNmUniq {rpatNmNm :: !HsName}
  deriving Eq

instance Ord RPatNm where
  x `compare` y = rpatNmNm x `cmpHsNameOnNm` rpatNmNm y

instance Show RPatNm where
  show pnm = show (rpatNmNm pnm)

instance PP RPatNm where
  pp (RPatNmOrig n) = n >|< "(O)"
  pp (RPatNmUniq n) = n >|< "(U)"

{-# LINE 1074 "src/ehc/Base/HsName.chs" #-}
rpatNmIsOrig :: RPatNm -> Bool
rpatNmIsOrig (RPatNmOrig _) = True
rpatNmIsOrig _              = False

{-# LINE 1084 "src/ehc/Base/HsName.chs" #-}
hsnUnknown ::  HsName
hsnUnknown =   hsnFromString "??"

{-# LINE 1093 "src/ehc/Base/HsName.chs" #-}

data Track
  = TrackNone
  | TrackSelf
  | TrackCtx Int
  | TrackSelect Int Track
  | TrackVarApply HsName [Track]
  deriving (Eq, Ord, Show)


{-# LINE 1105 "src/ehc/Base/HsName.chs" #-}

instance Serialize Track where
  sput (TrackNone             ) = sputWord8 0
  sput (TrackSelf             ) = sputWord8 1
  sput (TrackCtx        a     ) = sputWord8 2 >> sput a
  sput (TrackSelect     a  b  ) = sputWord8 3 >> sput a >> sput b
  sput (TrackVarApply   a  b  ) = sputWord8 4 >> sput a >> sput b

  sget
    = do t <- sgetWord8
         case t of
           0 -> return TrackNone
           1 -> return TrackSelf
           2 -> liftM  TrackCtx      sget
           3 -> liftM2 TrackSelect   sget sget
           4 -> liftM2 TrackVarApply sget sget

deriving instance Data Track
deriving instance Typeable Track



</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.HsName
( HSNM (..)
, HsName
, hsnEmpty
, mkHNmBase
, hsnEnsureIsBase
, hsnBaseUnpack', hsnBaseUnpack
, hsnMbBaseString, hsnIsBaseString, hsnBaseString
, hsnFromString
, hsnInitLast
, hsnPrefix, hsnSuffix, mkHNmPrefix
, IdOccKind (..)
, IdOcc (..)
, hsnUnknown
, HsNameS
, HsNameUniqifier (..)
, HsNameUnique (..)
, HsNameUniqifierMp
, hsnUniqify, hsnUniqifyUID, hsnUniqifyStr, hsnUniqifyInt, hsnUniqifyEval
, hsnMbPos, hsnIsPos
, hsnMkModf
, mkHNmPos
, cmpHsNameOnNm
, hsnShow, hsnShow'
, rowLabCmp
, OrigName (..)
, hsnStripUniqify
, hsnSimplifications
, hsnMbNr, hsnIsNr
, hsnMkNr
, hsnShowAlphanumeric, hsnShowAlphanumericShort
, hsnSplitQualify, hsnQualified, hsnPrefixQual, hsnMapQualified
, hsnQualifier, hsnSetQual, hsnIsQual
, hsnFixUniqifiers
, hsnStripUniqifiers
, hsnSafeJavaLike
, FvS, FvSMp
, HsNameMp, hsnRepl
, RPatNm (..)
, rpatNmIsOrig
, Track (..)
, hsnConcat
, hsnMapQual, hsnSetLevQual
, hsnQualUniqify )
where
import UHC.Util.Utils
import UHC.Util.Pretty
import Data.List
import UHC.Light.Compiler.Base.UID
import UU.Scanner.Position
import qualified Data.Set as Set
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe
import Data.Char
import-- | A HsNameUniqifier represents the 'type' of unificationNumeric
import UHC.Util.FPath
import Data.Char                        -- just a new identifier, with an empty show
import Control.Monad                    -- just a new identifier
import UHC.Util.Binary                  -- error
import UHC.Util.Serialize               -- globally unique
import Data.Hashable HsNameUniqifier
  = HsNameUniqifier_Blank
  | HsNameUniqifier_New
  | HsNameUniqifier_Error
  | HsNameUniqifier_GloballyUnique
  | HsNameUniqifier_Evaluated           -- evaluated
  | HsNameUniqifier_Field               -- extracted field
  | HsNameUniqifier_Class               -- class
  | HsNameUniqifier_ClassDict           -- dictionary
  | HsNameUniqifier_SelfDict            -- dictionary under construction itself, passed as arg in tying the knot recursion
  | HsNameUniqifier_ResultDict          -- dictionary under construction result
  | HsNameUniqifier_SuperClass          -- super class field
  | HsNameUniqifier_DictField           -- dictionary field
  | HsNameUniqifier_Inline              -- new identifier because of inlining
  | HsNameUniqifier_GloballyUniqueDict  -- globally unique dictionary
  | HsNameUniqifier_FieldOffset         -- offset for a field
  | HsNameUniqifier_CaseContinuation    -- continuation of a case expression
  | HsNameUniqifier_GrinUpdated         -- Grin: updated value
  | HsNameUniqifier_FFIArg              -- arg evaluated for FFI
  | HsNameUniqifier_LacksLabel          -- label used in lacking predicates
  | HsNameUniqifier_BindAspect          -- binding aspect
  | HsNameUniqifier_Strict              -- strict variant of binding
  | HsNameUniqifier_GenericClass        -- a name introduced by generics
  | HsNameUniqifier_FFE                 -- name of value to be ff exported
  | HsNameUniqifier_FFECoerced          -- name of possibly coerced value to be ff exported
  | HsNameUniqifier_CoreAPI             -- Used by the Core API, to allow external programs to generate new identifiers.
  deriving (Eq,Ord,Enum)

-- | The show of a HsNameUniqifier is found back in the pretty printed code, current convention is 3 uppercase letters, as a balance between size and clarity of meaning
instance Show HsNameUniqifier where
  show HsNameUniqifier_Blank                = ""
  show HsNameUniqifier_New                  = "NEW"
  show HsNameUniqifier_Error                = "ERR"
  show HsNameUniqifier_GloballyUnique       = "UNQ"
  show HsNameUniqifier_Evaluated            = "EVL"
  show HsNameUniqifier_Field                = "FLD"
  show HsNameUniqifier_Class                = "CLS"
  show HsNameUniqifier_ClassDict            = "DCT"
  show HsNameUniqifier_SelfDict             = "SDC"
  show HsNameUniqifier_ResultDict           = "RDC"
  show HsNameUniqifier_SuperClass           = "SUP"
  show HsNameUniqifier_DictField            = "DFL"
  show HsNameUniqifier_Inline               = "INL"
  show HsNameUniqifier_GloballyUniqueDict   = "UND"
  show HsNameUniqifier_FieldOffset          = "OFF"
  show HsNameUniqifier_CaseContinuation     = "CCN"
  show HsNameUniqifier_GrinUpdated          = "UPD"
  show HsNameUniqifier_FFIArg               = "FFI"
  show HsNameUniqifier_LacksLabel           = "LBL"
  show HsNameUniqifier_BindAspect           = "ASP"
  show HsNameUniqifier_Strict               = "STR"
  show HsNameUniqifier_GenericClass         = "GEN"
  show HsNameUniqifier_FFE                  = "FFE"
  show HsNameUniqifier_FFECoerced           = "FFC"
  show HsNameUniqifier_CoreAPI              = "CRA"

































-- | A HsNameUnique represents the optional additional info to make the uniqification even more unique
data HsNameUnique
  = HsNameUnique_None
  | HsNameUnique_String     !String
  | HsNameUnique_Int        !Int
  | HsNameUnique_UID        !UID
  deriving (Eq,Ord)

showHsNameUnique :: (UID -> String) -> (String -> String) -> HsNameUnique -> String
showHsNameUnique _    _    (HsNameUnique_None    ) = ""
showHsNameUnique _    shws (HsNameUnique_String s) = shws s
showHsNameUnique _    _    (HsNameUnique_Int    i) = show i
showHsNameUnique shwu _    (HsNameUnique_UID    u) = shwu u

instance Show HsNameUnique where
  show = showHsNameUnique hsnShowUID id



type HsNameUniqifierMp = Map.Map HsNameUniqifier [HsNameUnique]

emptyHsNameUniqifierMp :: HsNameUniqifierMp
emptyHsNameUniqifierMp = Map.empty

-- | Show uniqifier map, parseable back again when properly parameterized.
showHsNameUniqifierMp'' :: (UID -> String) -> (String -> String) -> (String -> String) -> Bool -> String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp'' shwu shws brk showLen usep us
  = [ usep ++ slen u ++ show uqf ++ (brk $ concat [ usep ++ showHsNameUnique shwu shws uu | uu <- u, uu /= HsNameUnique_None ]) | (uqf,u) <- Map.toList us ]
  where slen u | showLen && l /= 1  = usep ++ show l
               | otherwise          = ""
               where l = length u

showHsNameUniqifierMp' :: Bool -> String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp' = showHsNameUniqifierMp'' hsnShowUID id id

showHsNameUniqifierMp :: String -> HsNameUniqifierMp -> [String]
showHsNameUniqifierMp = showHsNameUniqifierMp' True

















uniqifierMpAdd :: HsNameUniqifier -> HsNameUnique -> HsNameUniqifierMp -> HsNameUniqifierMp
uniqifierMpAdd ufier u m = Map.unionWith (++) (Map.singleton ufier [u]) m

uniqifierMpUnion :: HsNameUniqifierMp -> HsNameUniqifierMp -> HsNameUniqifierMp
uniqifierMpUnion = Map.unionWith (++)







hsnUniqify' :: HsNameUniqifier -> HsNameUnique -> HsName -> HsName
hsnUniqify' ufier u
  = mk
  where mk n@(HsName_Modf {hsnUniqifiers=us}) = hsnFixateHash (n {hsnUniqifiers = uniqifierMpAdd ufier u us})
        mk n                                  = mk (hsnMkModf [] n Map.empty)

-- | Uniqify with just a name suffix
hsnUniqify :: HsNameUniqifier -> HsName -> HsName
hsnUniqify ufier = hsnUniqify' ufier HsNameUnique_None

-- | Uniqify with a name suffix + extra Int uniq info
hsnUniqifyInt :: HsNameUniqifier -> Int -> HsName -> HsName
hsnUniqifyInt ufier u = hsnUniqify' ufier (HsNameUnique_Int u)

-- | Uniqify with a name suffix + extra UID uniq info
hsnUniqifyUID :: HsNameUniqifier -> UID -> HsName -> HsName
hsnUniqifyUID ufier u = hsnUniqify' ufier (HsNameUnique_UID u)

-- | Uniqify with a name suffix + extra String uniq info
hsnUniqifyStr :: HsNameUniqifier -> String -> HsName -> HsName
hsnUniqifyStr ufier u = hsnUniqify' ufier (HsNameUnique_String u)

-- | Uniqify for use as evaluated name
hsnUniqifyEval :: HsName -> HsName
hsnUniqifyEval = hsnUniqify HsNameUniqifier_Evaluated



-- | Remove uniqification, if present
hsnStripUniqify :: HsName -> Maybe HsName
hsnStripUniqify n@(HsName_Modf {hsnUniqifiers=us})
  | Map.null us   = Nothing
  | otherwise     = Just $ n {hsnUniqifiers = Map.empty}
hsnStripUniqify _ = Nothing



-- | Simplify name into list of simplifications of increasing complexity, all strictly simpler than the one given. [] therefore means no simplifications exist
hsnSimplifications :: HsName -> [HsName]
hsnSimplifications n@(HsName_Modf {}) = case hsnStripUniqify n of
    Just n' -> hsnSimplifications n' ++ [n']
    _       -> hsnSimplifications $ hsnBase n
hsnSimplifications   (HsName_UID  {hsnUID = u}) = map mkHNm $ uidSimplifications u
-- hsnSimplifications n@(HsName_Base {}          ) = [] -- [n]
hsnSimplifications _                            = []







hsnHashWithSalt :: Int -> HsName -> Int
hsnHashWithSalt salt (HsName_Base s      ) = hashWithSalt salt s
hsnHashWithSalt salt (HsName_UID  i      ) = hashWithSalt salt i
hsnHashWithSalt salt (HsName_Pos  p      ) = hashWithSalt salt p
hsnHashWithSalt salt (HsName_Modf _ q b u) = hashWithSalt salt q `hashWithSalt` hashWithSalt salt b `hashWithSalt` hashWithSalt salt (Map.toList u)
hsnHashWithSalt salt (HsName_Nr i n      ) = i `hashWithSalt` hashWithSalt salt n

instance Hashable HsName where
  hashWithSalt salt n@(HsName_Modf h _ _ _) | h /= 0 = h
  hashWithSalt salt n                                = hsnHashWithSalt salt n

instance Hashable OrigName where
  hashWithSalt salt (OrigNone    ) = salt
  hashWithSalt salt (OrigLocal  n) = 23 `hashWithSalt` hashWithSalt salt n
  hashWithSalt salt (OrigGlobal n) = 19 `hashWithSalt` hashWithSalt salt n
  hashWithSalt salt (OrigFunc   n) = 17 `hashWithSalt` hashWithSalt salt n

instance Hashable HsNameUnique where
  hashWithSalt salt (HsNameUnique_None    ) = salt
  hashWithSalt salt (HsNameUnique_String s) = hashWithSalt salt s
  hashWithSalt salt (HsNameUnique_Int    i) = hashWithSalt salt i
  hashWithSalt salt (HsNameUnique_UID    u) = hashWithSalt salt u

instance Hashable HsNameUniqifier where
  hashWithSalt salt u = hashWithSalt salt (fromEnum u)



-- | Fixate hash
hsnFixateHash :: HsName -> HsName
hsnFixateHash n@(HsName_Modf _ _ _ _) = n {hsnHash = hsnHashWithSalt 17 n}
hsnFixateHash n                       = n
{-# INLINE hsnFixateHash #-}









-- | Haskell name representation, exports of constructors only intented for internal use
data HsName
  =   HsName_Base
        { hsnBaseStr            ::  !String
        }
  |   HsName_UID
        { hsnUID                ::  !UID
        }
  |   HsName_Modf
        {
          -- a secret hash, prefixing other fields as to enforce comparison on the hash first; only used at variant 99 and onwards to avoid clutter
          hsnHash               ::  !Int
        , hsnQualifiers         ::  ![String]
        , hsnBase               ::  !HsName
        , hsnUniqifiers         ::  !HsNameUniqifierMp
        }
  |   HsName_Pos                    !Int
  |   HsName_Nr                     !Int !OrigName
  deriving (Eq,Ord)







hsnEmpty :: HsName
hsnEmpty = mkHNm ""












-- | Is HsName a HsName_Pos?
hsnMbPos :: HsName -> Maybe Int
hsnMbPos (HsName_Pos p) = Just p
hsnMbPos _              = Nothing

hsnIsPos :: HsName -> Bool
hsnIsPos = isJust . hsnMbPos
{-# INLINE hsnIsPos #-}



-- | Is HsName a HsName_Pos?
hsnMbNr :: HsName -> Maybe (Int,OrigName)
hsnMbNr (HsName_Nr i o) = Just (i,o)
hsnMbNr _               = Nothing

hsnIsNr :: HsName -> Bool
hsnIsNr = isJust . hsnMbNr
{-# INLINE hsnIsNr #-}



-- | Smart constructor for HsName_Modf
hsnMkModf :: [String] -> HsName -> HsNameUniqifierMp -> HsName
-- hsnMkModf q b u = hsnFixateHash $ HsName_Modf 0 q b u
hsnMkModf q b u = hsnFixateHash $ either (\(_,n) -> n {hsnQualifiers = q, hsnUniqifiers = hsnUniqifiers n `uniqifierMpUnion` u}) (\b -> HsName_Modf 0 q b u) $ hsnCanonicSplit b
{-# INLINE hsnMkModf #-}







-- | Smart constructor for HsName_Nr
hsnMkNr :: Int -> OrigName -> HsName
hsnMkNr = HsName_Nr
{-# INLINE hsnMkNr #-}











-- | Just lift a string to the base HsName variant
mkHNmBase :: String -> HsName
mkHNmBase s = hsnMkModf [] (HsName_Base s) Map.empty







-- | Eliminate alternative internal representations
hsnEnsureIsBase :: HsName -> HsName
hsnEnsureIsBase n@(HsName_UID _) = mkHNm $ show n
hsnEnsureIsBase   (HsName_Pos i) = mkHNm $ show i
hsnEnsureIsBase n                = n





-- | unpack a HsName into qualifiers + base string + repack function
hsnBaseUnpack' :: HsName -> Maybe ([String],String,[String] -> String -> HsName)
hsnBaseUnpack' (HsName_Base s    ) = Just ([],s,\_ s -> HsName_Base s)
hsnBaseUnpack' (HsName_Modf _ q b u) = fmap (\(bs,mk) -> (q, bs, \q s -> hsnMkModf q (mk s) u)) (hsnBaseUnpack b)
hsnBaseUnpack' _                     = Nothing

-- | unpack a HsName into base string + repack function
hsnBaseUnpack :: HsName -> Maybe (String,String -> HsName)
hsnBaseUnpack (HsName_Base s    ) = Just (s,HsName_Base)
hsnBaseUnpack (HsName_Modf _ q b u) = fmap (\(bs,mk) -> (bs, \s -> hsnMkModf q (mk s) u)) (hsnBaseUnpack b)
hsnBaseUnpack _                     = Nothing







-- | If name is a HsName_Base after some unpacking, return the base string, without qualifiers, without uniqifiers
hsnMbBaseString :: HsName -> Maybe String
hsnMbBaseString = fmap fst . hsnBaseUnpack
{-# INLINE hsnMbBaseString #-}

-- | Is name is a HsName_Base after some unpacking?
hsnIsBaseString :: HsName -> Bool
hsnIsBaseString = isJust . hsnMbBaseString
{-# INLINE hsnIsBaseString #-}

hsnBaseString :: HsName -> String
hsnBaseString = maybe "??" id . hsnMbBaseString




-- | Just lift a int to the int HsName variant
mkHNmPos :: Int -> HsName
mkHNmPos s = hsnMkModf [] (HsName_Pos s) Map.empty







-- | Compare, ignoring hash
cmpHsNameOnNm :: HsName -> HsName -> Ordering
cmpHsNameOnNm (HsName_Modf _ q1 b1 u1) (HsName_Modf _ q2 b2 u2) = compare (HsName_Modf 0 q1 b1 u1)  (HsName_Modf 0 q2 b2 u2)
cmpHsNameOnNm n1                       n2                       = compare n1                        n2











hsnFromString :: String -> HsName
hsnFromString = mkHNmBase
{-# INLINE hsnFromString #-}








data OrigName
  = OrigNone
  | OrigLocal  HsName
  | OrigGlobal HsName
  | OrigFunc   HsName
  deriving (Eq,Ord)



instance PP HsName where
  pp h = pp (show h)




-- | Parameterizable show of HsName when used from within the Show instance for HsName, or for a parseable representation used by (e.g.) Core pretty printing
hsnShow' :: (UID -> String) -> (String -> String) -> (String -> String) -> String -> String -> HsName -> String
hsnShow' shwu shws brk qsep usep n
    = shw n
  where shw n = case n of
          HsName_Base   s                 -> s
          HsName_UID    i                 -> shwu i
          HsName_Modf _ qs b us           -> concat $ (intersperse qsep $ qs ++ [shw b]) ++ showHsNameUniqifierMp'' shwu shws brk False usep us
          HsName_Pos    p                 -> show p
          HsName_Nr n OrigNone            -> "x_"        ++ show n
          HsName_Nr n (OrigLocal  hsn)    -> "x_"        ++ show n ++ "_" ++ shw hsn
          HsName_Nr n (OrigGlobal hsn)    -> "global_x_" ++ show n ++ "_" ++ shw hsn
          HsName_Nr n (OrigFunc   hsn)    -> "fun_x_"    ++ show n ++ "_" ++ shw hsn

-- | Parseable show of HsName when used from within the Show instance for HsName
hsnShow :: String -> String -> HsName -> String
hsnShow q u n = hsnShow' hsnShowUID id id q u n
{-# INLINE hsnShow #-}

hsnShowUID i = 'u' : show i





instance Show HsName where
  show = hsnShow "." "_@"








-- | A HsName is either a complex/aggregrate name or a base case
hsnCanonicSplit :: HsName -> Either ([String],HsName) HsName
hsnCanonicSplit n@(HsName_Modf _ qs _ _) = Left $ (qs, hsnFixateHash (n {hsnQualifiers = []}))
hsnCanonicSplit n                        = Right n





hsnToList :: HsName -> [HsName]
hsnToList n = either (\(qs,b) -> map mkHNmBase qs ++ [b]) (:[]) (hsnCanonicSplit n)



hsnInitLast :: HsName -> ([HsName],HsName)
hsnInitLast n = either (\(qs,b) -> (map mkHNmBase qs, b)) (\x -> ([],x)) (hsnCanonicSplit n)



hsnPrefix                           ::  String -> HsName -> HsName
hsnPrefix   p   hsn
  = maybe (mkHNmBase $ p ++ show hsn) (\(s,mk) -> mk $ p ++ s) $ hsnBaseUnpack hsn

hsnSuffix                           ::  HsName -> String -> HsName
hsnSuffix       hsn   p
  = maybe (mkHNmBase $ show hsn ++ p) (\(s,mk) -> mk $ s ++ p) $ hsnBaseUnpack hsn

mkHNmPrefix :: HSNM x => String -> x -> HsName
mkHNmPrefix p = hsnPrefix p . mkHNm



stringAlphanumeric :: String -> String
stringAlphanumeric s
  = concat (map (charAlphanumeric) s)










charAlphanumeric :: Char -> String
charAlphanumeric '\'' = "prime"
charAlphanumeric ':' = "colon"
charAlphanumeric '!' = "exclam"
charAlphanumeric '@' = "at"
charAlphanumeric '#' = "number"
charAlphanumeric '$' = "dollar"
charAlphanumeric '%' = "percent"
charAlphanumeric '^' = "circon"
charAlphanumeric '&' = "amp"
charAlphanumeric '*' = "star"
charAlphanumeric '+' = "plus"
charAlphanumeric '-' = "minus"
charAlphanumeric '.' = "dot"
charAlphanumeric '/' = "slash"
charAlphanumeric '\\' = "backsl"
charAlphanumeric '|' = "bar"
charAlphanumeric '<' = "lt"
charAlphanumeric '=' = "eq"
charAlphanumeric '>' = "gt"
charAlphanumeric '?' = "quest"
charAlphanumeric '~' = "tilde"
charAlphanumeric '[' = "sub"    -- although this is not a legal Haskell operator symbol, it can be part of the Nil constructor
charAlphanumeric ']' = "bus"
charAlphanumeric '(' = "open"    -- although this is not a legal Haskell operator symbol, it can be part of the tuple constructor
charAlphanumeric ',' = "comma"
charAlphanumeric ')' = "close"
charAlphanumeric  c  = [c]





dontStartWithDigit :: String -> String
dontStartWithDigit xs@(a:_) | isDigit a || a=='_' = "y"++xs
                            | otherwise           = xs

hsnShowAlphanumericShort :: HsName -> String
hsnShowAlphanumericShort (HsName_Nr n (OrigFunc   orig)) = hsnShowAlphanumeric orig
hsnShowAlphanumericShort x = hsnShowAlphanumeric x

hsnShowAlphanumeric :: HsName -> String
hsnShowAlphanumeric (HsName_Base s  )           = dontStartWithDigit(stringAlphanumeric s)
hsnShowAlphanumeric (HsName_UID  i  )           = "u" ++ show i
hsnShowAlphanumeric (HsName_Pos p)              = "y" ++ show p
hsnShowAlphanumeric (HsName_Nr n OrigNone)          = "x" ++ show n
hsnShowAlphanumeric (HsName_Nr n (OrigLocal orig))  = "x" ++ show n   -- hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Nr n (OrigGlobal orig)) = "global_" ++ hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Nr n (OrigFunc   orig)) = "fun_"    ++ hsnShowAlphanumeric orig
hsnShowAlphanumeric (HsName_Modf _ q b u)         = concat $ intersperse "_" $ q ++ [hsnShowAlphanumeric b] ++ map stringAlphanumeric (showHsNameUniqifierMp "_" u)
-- hsnShowAlphanumeric n                           = concat $ intersperse "_" $ map hsnShowAlphanumeric $ hsnToList n






hsnToFPath :: HsName -> FPath
hsnToFPath n
  = mkFPathFromDirsFile qs b
  where (qs,b) = hsnInitLast n

instance FPATH HsName where
  mkFPath = hsnToFPath




hsnConcat                           ::  HsName -> HsName -> HsName
hsnConcat       h1    h2            =   hsnFromString (show h1 ++ show h2)







-- compare for row labels, lexicographic ordering (currently)
rowLabCmp :: HsName -> HsName -> Ordering
rowLabCmp = cmpHsNameOnNm







-- qualifier (i.e. module name) and qualified part of name
hsnSplitQualify :: HsName -> (Maybe HsName,HsName)
hsnSplitQualify n
  = case hsnInitLast n of
      ([],n') -> (Nothing,n')
      (ns,n') -> (Just (mkHNm ns),n')

-- qualified part of a name
hsnQualified :: HsName -> HsName
hsnQualified = snd . hsnSplitQualify

-- prefix/qualify with module name, on top of possible previous qualifier
hsnPrefixQual :: HsName -> HsName -> HsName
hsnPrefixQual m n = mkHNm (hsnToList m ++ hsnToList n)

-- map qualified part
hsnMapQualified :: (String -> String) -> HsName -> HsName
hsnMapQualified f qn
  = maybe qn (\(s,mk) -> mk $ f s) $ hsnBaseUnpack qn
{-
  = case hsnSplitQualify qn of
      (Nothing,n) -> f n
      (Just q ,n) -> hsnPrefixQual q (f n)
-}



-- qualifier (i.e. module name) of name
hsnQualifier :: HsName -> Maybe HsName
hsnQualifier = fst . hsnSplitQualify

-- replace/set qualifier
hsnSetQual :: HsName -> HsName -> HsName
hsnSetQual m = hsnPrefixQual m . hsnQualified

-- is qualified?
hsnIsQual :: HsName -> Bool
hsnIsQual = isJust . hsnQualifier















hsnMapQual :: (HsName -> HsName) -> HsName -> HsName
hsnMapQual f qn
  = case hsnSplitQualify qn of
      (Nothing,n) -> qn
      (Just q ,n) -> hsnSetQual (f q) n

hsnSetLevQual :: Int -> HsName -> HsName -> HsName
hsnSetLevQual 0 m n = hsnSetQual m n
hsnSetLevQual _ _ n = n







hsnFixUniqifiers' :: Bool -> String -> HsName -> HsName
hsnFixUniqifiers' showlen sep (HsName_Modf _ qs n us) = hsnMkModf qs (hsnSuffix n (concat $ showHsNameUniqifierMp' showlen sep us)) Map.empty
hsnFixUniqifiers' _       _   n                       = n

hsnFixUniqifiers :: HsName -> HsName
hsnFixUniqifiers = hsnFixUniqifiers' True "_@"

hsnJavalikeFixUniqifiers :: HsName -> HsName
hsnJavalikeFixUniqifiers = hsnFixUniqifiers' False ""







hsnStripUniqifiers :: HsName -> HsName
hsnStripUniqifiers (HsName_Modf _ qs n us) = hsnMkModf qs n emptyHsNameUniqifierMp
hsnStripUniqifiers n                       = n







hsnQualUniqify :: HsName -> HsName -> HsName
hsnQualUniqify modNm n
  = if hsnIsQual n
    then n
    else hsnSetQual modNm n







class HSNM a where
  mkHNm :: a -> HsName

instance HSNM HsName where
  mkHNm = id

instance HSNM Int where
  mkHNm = mkHNm . show




instance HSNM UID where
  mkHNm = HsName_UID
  -- mkHNm x = hsnFromString ('_' : show x)








instance HSNM String where
  mkHNm s
    = mkHNm $ map hsnFromString $ splitForQualified s



instance HSNM ([HsName],HsName) where
  mkHNm (l,n) = mkHNm (l ++ [n])

instance HSNM [HsName] where
  mkHNm [n] = n
  mkHNm []  = hsnFromString "" -- ????, or empty alternative of HsName
  mkHNm ns  = case initlast ns of
                Just (i,l) -> case l of
                                n@(HsName_Modf _ _ _ _) -> hsnFixateHash (n {hsnQualifiers = qs})
                                n                       -> hsnMkModf qs n Map.empty
                           where qs = catMaybes $ map hsnMbBaseString i












instance Position HsName where
  line   _ = (-1)
  column _ = (-1)
  file   _ = ""







deriving instance Typeable HsNameUniqifier
deriving instance Data HsNameUniqifier

deriving instance Typeable HsNameUnique
deriving instance Data HsNameUnique

deriving instance Typeable HsName
deriving instance Data HsName

deriving instance Typeable OrigName
deriving instance Data OrigName

deriving instance Typeable IdOccKind
deriving instance Data IdOccKind

deriving instance Typeable IdOcc
deriving instance Data IdOcc







instance Binary HsNameUniqifier where
  put = putEnum8
  get = getEnum8

instance Binary HsNameUnique where
  put (HsNameUnique_String  a    ) = putWord8 0 >> put a
  put (HsNameUnique_Int     a    ) = putWord8 1 >> put a
  put (HsNameUnique_UID     a    ) = putWord8 2 >> put a
  put (HsNameUnique_None         ) = putWord8 3
  get = do t <- getWord8
           case t of
             0 -> liftM  HsNameUnique_String    get
             1 -> liftM  HsNameUnique_Int       get
             2 -> liftM  HsNameUnique_UID       get
             3 -> return HsNameUnique_None

instance Binary HsName where
  put (HsName_Base  a    ) = putWord8 0 >> put a
  put (HsName_UID   a    ) = putWord8 1 >> put a
  put (HsName_Pos   a    ) = putWord8 2 >> put a
  put (HsName_Nr        a b  ) = putWord8 3 >> put a >> put b
  put (HsName_Modf  a b c d) = putWord8 4 >> put a >> put b >> put c >> put d
  get = do t <- getWord8
           case t of
             0 -> liftM  HsName_Base    get
             1 -> liftM  HsName_UID     get
             2 -> liftM  HsName_Pos     get
             3 -> liftM2 HsName_Nr      get get
             4 -> liftM4 HsName_Modf    get get get get

instance Serialize HsName where
  sput = sputShared
  sget = sgetShared
  sputNested = sputPlain
  sgetNested = sgetPlain

instance Binary OrigName where
  put (OrigNone    ) = putWord8 0
  put (OrigLocal  a) = putWord8 1 >> put a
  put (OrigGlobal a) = putWord8 2 >> put a
  put (OrigFunc   a) = putWord8 3 >> put a
  get = do t <- getWord8
           case t of
             0 -> return OrigNone
             1 -> liftM  OrigLocal  get
             2 -> liftM  OrigGlobal get
             3 -> liftM  OrigFunc   get

instance Binary IdOccKind where
  put = putEnum8
  get = getEnum8

instance Serialize IdOccKind where
  sput = sputPlain
  sget = sgetPlain

instance Binary IdOcc where
  put (IdOcc a b) = put a >> put b
  get = liftM2 IdOcc get get

instance Serialize IdOcc where
  sput = sputShared
  sget = sgetShared
  sputNested = sputPlain
  sgetNested = sgetPlain







data IdOccKind
  = IdOcc_Val
  | IdOcc_Pat
  | IdOcc_Type
  | IdOcc_Kind
  | IdOcc_Fld
  | IdOcc_Class
  | IdOcc_Inst
  | IdOcc_Dflt
  | IdOcc_Any
  | IdOcc_Data
  | IdOcc_Fusion
  deriving (Eq,Ord,Enum)













-- intended for parsing
instance Show IdOccKind where
  show IdOcc_Val      = "Value"
  show IdOcc_Pat      = "Pat"
  show IdOcc_Type     = "Type"
  show IdOcc_Kind     = "Kind"
  show IdOcc_Fld      = "Field"
  show IdOcc_Class    = "Class"
  show IdOcc_Inst     = "Instance"
  show IdOcc_Dflt     = "Default"
  show IdOcc_Any      = "Any"
  show IdOcc_Data     = "Data"
  show IdOcc_Fusion   = "Fusion"













-- intended for parsing
instance PP IdOccKind where
  pp = text . show



data IdOcc
  = IdOcc { ioccNm :: !HsName, ioccKind :: !IdOccKind }
  deriving (Show,Eq,Ord)








type HsNameS = Set.Set HsName







-- ensure a name valid for backends which are more restrictive in their allowed identifier character set
hsnSafeJavaLike :: HsName -> HsName
hsnSafeJavaLike
  = hsnMapQualified (concatMap safe . first) . hsnJavalikeFixUniqifiers . hsnEnsureIsBase
  where safe '_'                                      = "__"
        safe c | isDigit c || isLetter c || c == '_'  = [c]
               | otherwise                            = "_" ++ showHex (ord c) ""
        first s@(c:_) | isDigit c = '_' : s
        first s                   =       s


















type FvS = HsNameS
type FvSMp = Map.Map HsName FvS







type HsNameMp = Map.Map HsName HsName

hsnRepl :: HsNameMp -> HsName -> HsName
hsnRepl m n = Map.findWithDefault n n m







data RPatNm
  = RPatNmOrig {rpatNmNm :: !HsName}
  | RPatNmUniq {rpatNmNm :: !HsName}
  deriving Eq

instance Ord RPatNm where
  x `compare` y = rpatNmNm x `cmpHsNameOnNm` rpatNmNm y

instance Show RPatNm where
  show pnm = show (rpatNmNm pnm)

instance PP RPatNm where
  pp (RPatNmOrig n) = n >|< "(O)"
  pp (RPatNmUniq n) = n >|< "(U)"



rpatNmIsOrig :: RPatNm -> Bool
rpatNmIsOrig (RPatNmOrig _) = True
rpatNmIsOrig _              = False







hsnUnknown ::  HsName
hsnUnknown =   hsnFromString "??"








data Track
  = TrackNone
  | TrackSelf
  | TrackCtx Int
  | TrackSelect Int Track
  | TrackVarApply HsName [Track]
  deriving (Eq, Ord, Show)





instance Serialize Track where
  sput (TrackNone             ) = sputWord8 0
  sput (TrackSelf             ) = sputWord8 1
  sput (TrackCtx        a     ) = sputWord8 2 >> sput a
  sput (TrackSelect     a  b  ) = sputWord8 3 >> sput a >> sput b
  sput (TrackVarApply   a  b  ) = sputWord8 4 >> sput a >> sput b

  sget
    = do t <- sgetWord8
         case t of
           0 -> return TrackNone
           1 -> return TrackSelf
           2 -> liftM  TrackCtx      sget
           3 -> liftM2 TrackSelect   sget sget
           4 -> liftM2 TrackVarApply sget sget

deriving instance Data Track
deriving instance Typeable Track




</pre>