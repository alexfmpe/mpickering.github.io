<a href="Graph.hs12609736711815859901.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Graph.hs340756291478446501.out.html">next</a></br></br><pre>13d12
<     = Initiator   {out ∷ Port}
14d12
<     | Applicator  {inp, func, arg ∷ Port}
15d12
<     | Abstractor  {inp, body, var ∷ Port, name ∷ String}
16d12
<     | Constant    {inp ∷ Port, args ∷ [Port], name ∷ String}
17d12
<     | Eraser      {inp ∷ Port}
18d12
<     | Duplicator  {level ∷ Int, inp, out1, out2 ∷ Port}
19d12
<     | Delimiter   {level ∷ Int, inp, out ∷ Port}
20d12
<     | Multiplexer {out ∷ Port, ins ∷ [Port]} -- only intermediate compilation result
21d12
<     | Case        {inp ∷ Port, out ∷ Port, alts ∷ [Port], names ∷ [String]}
22d12
<     | Operator    {inp ∷ Port, ops ∷ [Port], arity ∷ Int, lmop ∷ Int,
23c13
<                    function ∷ [String] → Maybe String, name ∷ String}
---
>     = Initiator   {out :: Port}
23a14
>     | Applicator  {inp, func, arg :: Port}
23a15
>     | Abstractor  {inp, body, var :: Port, name :: String}
23a16
>     | Constant    {inp :: Port, args :: [Port], name :: String}
23a17
>     | Eraser      {inp :: Port}
23a18
>     | Duplicator  {level :: Int, inp, out1, out2 :: Port}
23a19
>     | Delimiter   {level :: Int, inp, out :: Port}
23a20
>     | Multiplexer {out :: Port, ins :: [Port]} -- only intermediate compilation result
23a21
>     | Case        {inp :: Port, out :: Port, alts :: [Port], names :: [String]}
23a22
>     | Operator    {inp :: Port, ops :: [Port], arity :: Int, lmop :: Int,
23a23
>                    function :: [String] -> Maybe String, name :: String}
34d33
<         Initiator   {out = o}                       → [o]
35d33
<         Applicator  {inp = i, func = f, arg = a}    → [i,f,a]
36d33
<         Abstractor  {inp = i, body = b, var = v}    → [i,b,v]
37d33
<         Constant    {inp = i, args = as}            → i:as
38d33
<         Eraser      {inp = i}                       → [i]
39d33
<         Duplicator  {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
40d33
<         Delimiter   {inp = i, out = o}              → [i,o]
41d33
<         Multiplexer {out = o, ins = is}             → o:is
42d33
<         Case        {inp = i, out = o, alts = as}   → i:o:as
43c34
<         Operator    {inp = i, ops = os}             → i:os
---
>         Initiator   {out = o}                       -> [o]
43a35
>         Applicator  {inp = i, func = f, arg = a}    -> [i,f,a]
43a36
>         Abstractor  {inp = i, body = b, var = v}    -> [i,b,v]
43a37
>         Constant    {inp = i, args = as}            -> i:as
43a38
>         Eraser      {inp = i}                       -> [i]
43a39
>         Duplicator  {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
43a40
>         Delimiter   {inp = i, out = o}              -> [i,o]
43a41
>         Multiplexer {out = o, ins = is}             -> o:is
43a42
>         Case        {inp = i, out = o, alts = as}   -> i:o:as
43a43
>         Operator    {inp = i, ops = os}             -> i:os
45d44
<         Initiator   {} → node {out = o}                       where [o]       = ports
46d44
<         Applicator  {} → node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
47d44
<         Abstractor  {} → node {inp = i, body = b, var = v}    where [i,b,v]   = ports
48d44
<         Constant    {} → node {inp = i, args = as}            where i:as      = ports
49d44
<         Eraser      {} → node {inp = i}                       where [i]       = ports
50d44
<         Duplicator  {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
51d44
<         Delimiter   {} → node {inp = i, out = o}              where [i,o]     = ports
52d44
<         Multiplexer {} → node {out = o, ins = is}             where o:is      = ports
53d44
<         Case        {} → node {inp = i, out = o, alts = as}   where i:o:as    = ports
54c45
<         Operator    {} → node {inp = i, ops = os}             where i:os      = ports
---
>         Initiator   {} -> node {out = o}                       where [o]       = ports
54a46
>         Applicator  {} -> node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
54a47
>         Abstractor  {} -> node {inp = i, body = b, var = v}    where [i,b,v]   = ports
54a48
>         Constant    {} -> node {inp = i, args = as}            where i:as      = ports
54a49
>         Eraser      {} -> node {inp = i}                       where [i]       = ports
54a50
>         Duplicator  {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
54a51
>         Delimiter   {} -> node {inp = i, out = o}              where [i,o]     = ports
54a52
>         Multiplexer {} -> node {out = o, ins = is}             where o:is      = ports
54a53
>         Case        {} -> node {inp = i, out = o, alts = as}   where i:o:as    = ports
54a54
>         Operator    {} -> node {inp = i, ops = os}             where i:os      = ports
59c59
< pp ∷ NodeLS → Port
---
> pp :: NodeLS -> Port
61d60
<     Initiator   {out = o}                       → o
62d60
<     Applicator  {inp = i, func = f, arg = a}    → f
63d60
<     Abstractor  {inp = i, body = b, var = v}    → i
64d60
<     Constant    {inp = i, args = as}            → i
65d60
<     Eraser      {inp = i}                       → i
66d60
<     Duplicator  {inp = i, out1 = o1, out2 = o2} → i
67d60
<     Delimiter   {inp = i, out = o}              → i
68d60
<     Multiplexer {out = o, ins = is}             → o
69d60
<     Case        {inp = i, out = o, alts = as}   → o
70c61
<     Operator    {lmop = i, ops = os}            → inspect node !! i
---
>     Initiator   {out = o}                       -> o
70a62
>     Applicator  {inp = i, func = f, arg = a}    -> f
70a63
>     Abstractor  {inp = i, body = b, var = v}    -> i
70a64
>     Constant    {inp = i, args = as}            -> i
70a65
>     Eraser      {inp = i}                       -> i
70a66
>     Duplicator  {inp = i, out1 = o1, out2 = o2} -> i
70a67
>     Delimiter   {inp = i, out = o}              -> i
70a68
>     Multiplexer {out = o, ins = is}             -> o
70a69
>     Case        {inp = i, out = o, alts = as}   -> o
70a70
>     Operator    {lmop = i, ops = os}            -> inspect node !! i
74c74
< lmo ∷ NodeLS → Maybe Port
---
> lmo :: NodeLS -> Maybe Port
76d75
<     Initiator   {out = o}                       → Just o
77d75
<     Applicator  {inp = i, func = f, arg = a}    → Just f
78d75
<     Abstractor  {inp = i, body = b, var = v}    → Nothing
79d75
<     Constant    {inp = i, args = as}            → Nothing
80d75
<     Eraser      {inp = i}                       → Just i
81d75
<     Duplicator  {inp = i, out1 = o1, out2 = o2} → Just i
82d75
<     Delimiter   {inp = i, out = o}              → Just i
83d75
<     Case        {inp = i, out = o, alts = as}   → Just o
84c76
<     Operator    {lmop = i, ops = os}            → Just $ inspect node !! i
---
>     Initiator   {out = o}                       -> Just o
84a77
>     Applicator  {inp = i, func = f, arg = a}    -> Just f
84a78
>     Abstractor  {inp = i, body = b, var = v}    -> Nothing
84a79
>     Constant    {inp = i, args = as}            -> Nothing
84a80
>     Eraser      {inp = i}                       -> Just i
84a81
>     Duplicator  {inp = i, out1 = o1, out2 = o2} -> Just i
84a82
>     Delimiter   {inp = i, out = o}              -> Just i
84a83
>     Case        {inp = i, out = o, alts = as}   -> Just o
84a84
>     Operator    {lmop = i, ops = os}            -> Just $ inspect node !! i
84a85
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Prelude.Unicode
import Data.View
import GraphRewriting.Graph.Types
import GraphRewriting.Pattern.InteractionNet
-- import Control
import GraphRewriting.Strategies.LeftmostOutermost

-- | The signature of our graph
data NodeLS
    = Initiator   {out ∷ Port}
    | Applicator  {inp, func, arg ∷ Port}
    | Abstractor  {inp, body, var ∷ Port, name ∷ String}
    | Constant    {inp ∷ Port, args ∷ [Port], name ∷ String}
    | Eraser      {inp ∷ Port}
    | Duplicator  {level ∷ Int, inp, out1, out2 ∷ Port}
    | Delimiter   {level ∷ Int, inp, out ∷ Port}
    | Multiplexer {out ∷ Port, ins ∷ [Port]} -- only intermediate compilation result
    | Case        {inp ∷ Port, out ∷ Port, alts ∷ [Port], names ∷ [String]}
    | Operator    {inp ∷ Port, ops ∷ [Port], arity ∷ Int, lmop ∷ Int,
                   function ∷ [String] → Maybe String, name ∷ String}

-- | equality as defined in the paper with only the relevant cases included
instance Eq NodeLS where
    Eraser     {}           == Eraser     {} = True
    Duplicator {level = l1} == Duplicator {level = l2} = l1 ≡ l2
    Delimiter  {level = l1} == Delimiter  {level = l2} = l1 ≡ l2
    _ == _ = False

instance View [Port] NodeLS where
    inspect node = case node of
        Initiator   {out = o}                       → [o]
        Applicator  {inp = i, func = f, arg = a}    → [i,f,a]
        Abstractor  {inp = i, body = b, var = v}    → [i,b,v]
        Constant    {inp = i, args = as}            → i:as
        Eraser      {inp = i}                       → [i]
        Duplicator  {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
        Delimiter   {inp = i, out = o}              → [i,o]
        Multiplexer {out = o, ins = is}             → o:is
        Case        {inp = i, out = o, alts = as}   → i:o:as
        Operator    {inp = i, ops = os}             → i:os
    update ports node = case node of
        Initiator   {} → node {out = o}                       where [o]       = ports
        Applicator  {} → node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
        Abstractor  {} → node {inp = i, body = b, var = v}    where [i,b,v]   = ports
        Constant    {} → node {inp = i, args = as}            where i:as      = ports
        Eraser      {} → node {inp = i}                       where [i]       = ports
        Duplicator  {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Delimiter   {} → node {inp = i, out = o}              where [i,o]     = ports
        Multiplexer {} → node {out = o, ins = is}             where o:is      = ports
        Case        {} → node {inp = i, out = o, alts = as}   where i:o:as    = ports
        Operator    {} → node {inp = i, ops = os}             where i:os      = ports

instance INet NodeLS where principalPort = pp

-- The number is an index that specifies which port is the principal port out of the list of ports
pp ∷ NodeLS → Port
pp node = case node of
    Initiator   {out = o}                       → o
    Applicator  {inp = i, func = f, arg = a}    → f
    Abstractor  {inp = i, body = b, var = v}    → i
    Constant    {inp = i, args = as}            → i
    Eraser      {inp = i}                       → i
    Duplicator  {inp = i, out1 = o1, out2 = o2} → i
    Delimiter   {inp = i, out = o}              → i
    Multiplexer {out = o, ins = is}             → o
    Case        {inp = i, out = o, alts = as}   → o
    Operator    {lmop = i, ops = os}            → inspect node !! i

instance LeftmostOutermost NodeLS where lmoPort = lmo

lmo ∷ NodeLS → Maybe Port
lmo node = case node of
    Initiator   {out = o}                       → Just o
    Applicator  {inp = i, func = f, arg = a}    → Just f
    Abstractor  {inp = i, body = b, var = v}    → Nothing
    Constant    {inp = i, args = as}            → Nothing
    Eraser      {inp = i}                       → Just i
    Duplicator  {inp = i, out1 = o1, out2 = o2} → Just i
    Delimiter   {inp = i, out = o}              → Just i
    Case        {inp = i, out = o, alts = as}   → Just o
    Operator    {lmop = i, ops = os}            → Just $ inspect node !! i
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Prelude.Unicode
import Data.View
import GraphRewriting.Graph.Types
import GraphRewriting.Pattern.InteractionNet
-- import Control
import GraphRewriting.Strategies.LeftmostOutermost

-- | The signature of our graph
data NodeLS
    = Initiator   {out :: Port}
    | Applicator  {inp, func, arg :: Port}
    | Abstractor  {inp, body, var :: Port, name :: String}
    | Constant    {inp :: Port, args :: [Port], name :: String}
    | Eraser      {inp :: Port}
    | Duplicator  {level :: Int, inp, out1, out2 :: Port}
    | Delimiter   {level :: Int, inp, out :: Port}
    | Multiplexer {out :: Port, ins :: [Port]} -- only intermediate compilation result
    | Case        {inp :: Port, out :: Port, alts :: [Port], names :: [String]}
    | Operator    {inp :: Port, ops :: [Port], arity :: Int, lmop :: Int,
                   function :: [String] -> Maybe String, name :: String}

-- | equality as defined in the paper with only the relevant cases included
instance Eq NodeLS where
    Eraser     {}           == Eraser     {} = True
    Duplicator {level = l1} == Duplicator {level = l2} = l1 ≡ l2
    Delimiter  {level = l1} == Delimiter  {level = l2} = l1 ≡ l2
    _ == _ = False

instance View [Port] NodeLS where
    inspect node = case node of
        Initiator   {out = o}                       -> [o]
        Applicator  {inp = i, func = f, arg = a}    -> [i,f,a]
        Abstractor  {inp = i, body = b, var = v}    -> [i,b,v]
        Constant    {inp = i, args = as}            -> i:as
        Eraser      {inp = i}                       -> [i]
        Duplicator  {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
        Delimiter   {inp = i, out = o}              -> [i,o]
        Multiplexer {out = o, ins = is}             -> o:is
        Case        {inp = i, out = o, alts = as}   -> i:o:as
        Operator    {inp = i, ops = os}             -> i:os
    update ports node = case node of
        Initiator   {} -> node {out = o}                       where [o]       = ports
        Applicator  {} -> node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
        Abstractor  {} -> node {inp = i, body = b, var = v}    where [i,b,v]   = ports
        Constant    {} -> node {inp = i, args = as}            where i:as      = ports
        Eraser      {} -> node {inp = i}                       where [i]       = ports
        Duplicator  {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Delimiter   {} -> node {inp = i, out = o}              where [i,o]     = ports
        Multiplexer {} -> node {out = o, ins = is}             where o:is      = ports
        Case        {} -> node {inp = i, out = o, alts = as}   where i:o:as    = ports
        Operator    {} -> node {inp = i, ops = os}             where i:os      = ports

instance INet NodeLS where principalPort = pp

-- The number is an index that specifies which port is the principal port out of the list of ports
pp :: NodeLS -> Port
pp node = case node of
    Initiator   {out = o}                       -> o
    Applicator  {inp = i, func = f, arg = a}    -> f
    Abstractor  {inp = i, body = b, var = v}    -> i
    Constant    {inp = i, args = as}            -> i
    Eraser      {inp = i}                       -> i
    Duplicator  {inp = i, out1 = o1, out2 = o2} -> i
    Delimiter   {inp = i, out = o}              -> i
    Multiplexer {out = o, ins = is}             -> o
    Case        {inp = i, out = o, alts = as}   -> o
    Operator    {lmop = i, ops = os}            -> inspect node !! i

instance LeftmostOutermost NodeLS where lmoPort = lmo

lmo :: NodeLS -> Maybe Port
lmo node = case node of
    Initiator   {out = o}                       -> Just o
    Applicator  {inp = i, func = f, arg = a}    -> Just f
    Abstractor  {inp = i, body = b, var = v}    -> Nothing
    Constant    {inp = i, args = as}            -> Nothing
    Eraser      {inp = i}                       -> Just i
    Duplicator  {inp = i, out1 = o1, out2 = o2} -> Just i
    Delimiter   {inp = i, out = o}              -> Just i
    Case        {inp = i, out = o, alts = as}   -> Just o
    Operator    {lmop = i, ops = os}            -> Just $ inspect node !! i

</pre>