<a href="TIP.hs19745939281935350805.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ToCHR.hs14582327061433710178.out.html">next</a></br></br><pre>9c9
< instance (Subset '[x] ys, Subset xs ys) => Subset (x ': xs) ys
---
> instance (Subset '[x] ys, Subset xs ys) => Subset (x  : xs) ys
22d21
<         IsMember x (x ': xs) = True
23c22
<         IsMember y (x ': xs) = IsMember y xs
---
>         IsMember x (x  : xs) = True
23a23
>         IsMember y (x  : xs) = IsMember y xs
27d26
<         Remove x (x ': xs) = Remove x xs
28c27
<         Remove x (y ': xs) = y ': Remove x xs
---
>         Remove x (x  : xs) = Remove x xs
28a28
>         Remove x (y  : xs) = y  : Remove x xs
32c32
<         Difference xs (y ': ys) = Difference (Remove y xs) ys
---
>         Difference xs (y  : ys) = Difference (Remove y xs) ys
36c36
<         Append (x ': xs) ys = x ': Append xs ys
---
>         Append (x  : xs) ys = x  : Append xs ys
40d39
<         Insert y (y ': xs) = y ': xs
41c40
<         Insert y (x ': xs) = x ': Insert y xs
---
>         Insert y (y  : xs) = y  : xs
41a41
>         Insert y (x  : xs) = x  : Insert y xs
45c45
<         Union (x ': xs) ys = Union xs (Insert x ys)
---
>         Union (x  : xs) ys = Union xs (Insert x ys)
49a50
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds, KindSignatures, MultiParamTypeClasses, TypeFamilies,
             TypeOperators, UndecidableInstances, FlexibleContexts,
             FlexibleInstances, ConstraintKinds, PolyKinds #-}

module FWGL.Internal.TList where

class Subset (xs :: [*]) (ys :: [*])
instance Subset '[] ys
instance (Subset '[x] ys, Subset xs ys) => Subset (x ': xs) ys
-- BUG: Subset x x?

-- class Equal (xs :: [*]) (ys :: [*])
-- instance (Subset xs ys, Subset ys xs) => Equal xs ys
type Equal xs ys = (Subset xs ys, Subset ys xs)

type Member x xs = Subset '[x] xs

type NotMember x xs = IsMember x xs ~ False

type family IsMember x (xs :: [*]) :: Bool where
        IsMember x '[] = False
        IsMember x (x ': xs) = True
        IsMember y (x ': xs) = IsMember y xs

type family Remove x (xs :: [*]) where
        Remove x '[] = '[]
        Remove x (x ': xs) = Remove x xs
        Remove x (y ': xs) = y ': Remove x xs

type family Difference (xs :: [*]) (ys :: [*]) where
        Difference xs '[] = xs
        Difference xs (y ': ys) = Difference (Remove y xs) ys

type family Append (xs :: [*]) (ys :: [*]) where
        Append '[] ys = ys
        Append (x ': xs) ys = x ': Append xs ys

type family Insert y (xs :: [*]) where
        Insert y '[] = '[y]
        Insert y (y ': xs) = y ': xs
        Insert y (x ': xs) = x ': Insert y xs

type family Union (xs :: [*]) (ys :: [*]) where
        Union '[] ys = ys
        Union (x ': xs) ys = Union xs (Insert x ys)

type family TypeEq (x :: k) (y :: k) :: Bool where
        TypeEq x x = True
        TypeEq x y = False
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds, KindSignatures, MultiParamTypeClasses, TypeFamilies,
             TypeOperators, UndecidableInstances, FlexibleContexts,
             FlexibleInstances, ConstraintKinds, PolyKinds #-}

module FWGL.Internal.TList where

class Subset (xs :: [*]) (ys :: [*])
instance Subset '[] ys
instance (Subset '[x] ys, Subset xs ys) => Subset (x  : xs) ys
-- BUG: Subset x x?

-- class Equal (xs :: [*]) (ys :: [*])
-- instance (Subset xs ys, Subset ys xs) => Equal xs ys
type Equal xs ys = (Subset xs ys, Subset ys xs)

type Member x xs = Subset '[x] xs

type NotMember x xs = IsMember x xs ~ False

type family IsMember x (xs :: [*]) :: Bool where
        IsMember x '[] = False
        IsMember x (x  : xs) = True
        IsMember y (x  : xs) = IsMember y xs

type family Remove x (xs :: [*]) where
        Remove x '[] = '[]
        Remove x (x  : xs) = Remove x xs
        Remove x (y  : xs) = y  : Remove x xs

type family Difference (xs :: [*]) (ys :: [*]) where
        Difference xs '[] = xs
        Difference xs (y  : ys) = Difference (Remove y xs) ys

type family Append (xs :: [*]) (ys :: [*]) where
        Append '[] ys = ys
        Append (x  : xs) ys = x  : Append xs ys

type family Insert y (xs :: [*]) where
        Insert y '[] = '[y]
        Insert y (y  : xs) = y  : xs
        Insert y (x  : xs) = x  : Insert y xs

type family Union (xs :: [*]) (ys :: [*]) where
        Union '[] ys = ys
        Union (x  : xs) ys = Union xs (Insert x ys)

type family TypeEq (x :: k) (y :: k) :: Bool where
        TypeEq x x = True
        TypeEq x y = False

</pre>