<a href="PartialTypeSigs.hs7125429201340040768.out.html">prev</a></br><a href="failures.html">home</a></br><a href="PatternConstruction.hs1974930991404280278.out.html">next</a></br></br><pre>18c18
<   Cons :: RecEntry h -> Pattern t -> Pattern (h ': t)
---
>   Cons :: RecEntry h -> Pattern t -> Pattern (h  : t)
35a36
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TypeOperators #-}
module SNet.Pattern
  ( Pattern (..)
  , length
  , foldPattern
  , foldWithPattern
  ) where

import Prelude hiding (length)
import SNet.Types (RecEntry)

data Pattern :: [*] -> * where
  Nil :: Pattern '[]
  Cons :: RecEntry h -> Pattern t -> Pattern (h ': t)

length :: Integral i => Pattern p -> i
length Nil = 0
length (Cons _ t) = 1 + length t

foldPattern :: Pattern p -> (forall e . RecEntry e -> a -> a) -> a -> a
foldPattern Nil        _ base = base
foldPattern (Cons h t) f base = foldPattern t f (f h base)

foldWithPattern :: (forall e . RecEntry e -> val -> a -> a)
                -> a
                -> [val]
                -> Pattern p
                -> a
foldWithPattern _ r []     Nil         = r
foldWithPattern f r (v:vs) (Cons p ps) = foldWithPattern f (f p v r) vs ps
foldWithPattern _ _ _ _ = error "foldWithPattern: Pattern/list length mismatch!"
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TypeOperators #-}
module SNet.Pattern
  ( Pattern (..)
  , length
  , foldPattern
  , foldWithPattern
  ) where

import Prelude hiding (length)
import SNet.Types (RecEntry)

data Pattern :: [*] -> * where
  Nil :: Pattern '[]
  Cons :: RecEntry h -> Pattern t -> Pattern (h  : t)

length :: Integral i => Pattern p -> i
length Nil = 0
length (Cons _ t) = 1 + length t

foldPattern :: Pattern p -> (forall e . RecEntry e -> a -> a) -> a -> a
foldPattern Nil        _ base = base
foldPattern (Cons h t) f base = foldPattern t f (f h base)

foldWithPattern :: (forall e . RecEntry e -> val -> a -> a)
                -> a
                -> [val]
                -> Pattern p
                -> a
foldWithPattern _ r []     Nil         = r
foldWithPattern f r (v:vs) (Cons p ps) = foldWithPattern f (f p v r) vs ps
foldWithPattern _ _ _ _ = error "foldWithPattern: Pattern/list length mismatch!"

</pre>