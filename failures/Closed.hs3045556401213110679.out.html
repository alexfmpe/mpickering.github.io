<a href="Class.hs14951700531616927224.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Cmd.hs12893357351755699915.out.html">next</a></br></br><pre>60c60
< unitCCC :: CCC k => a `k` Exp k b (Product k b a)
---
> unitCCC-- * Free @'Adjunction' (Product (<=) a) (Exp (<=) a) (<=) (<=)@:: CCC k => a `k` Exp k b (Product k b a)
60a61
> unitCCC ::= curry kbraid=> a `k` Exp k b (Product k b a)
62d62
< 
63a64
> counitCCC ::= apply k.=>braid k b (Exp k b a) `k` a
65d65
< 
67c67
< 
---
> -- * A Co-(Closed Cartesian Category)
69c69
< 
---
> -- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials
71c71
< 
---
> -- You probably also want an instance for @'Bifunctor' ('coexp' hom) ('Dual' hom) hom hom@.
73d72
<     type Coexp k :: * -> * -> *
74d72
<     coapply :: b `k` Sum k (Coexp k a b) a
75c73
<     cocurry :: c `k` Sum k a b -> Coexp k b c `k` a
---
> classtypeCoexp k :: =>* ->* ->k*where
75a74
>     typecoapply:: k ::`k`*Sum-> * ->(Coexp   k a b) a
75a75
>     coapply :: b `k` Sum k (Coexpb -> kCoexp b)kab c `k` a
75a76
>     cocurryuncocurry:::: `Coexpk` Sumk k a bk->` aCoexp-> c kkb cSumk` a b
77d77
< 
79c79
< "cocurry coapply" cocurry coapply = id
---
> {-# RULES"cocurry coapply" cocurry coapply = id
79a80
> "cocurry coapply"-- "cocurry . uncocurry"   cocurry . uncocurry = id coapply = id
81c82
< -- "uncocurry . cocurry"   uncocurry . cocurry = id
---
> -- "uncocurry . cocurry"   uncocurry . cocurry = id#-}
83d83
< 
86d85
< unitCoCCC = swap . coapply
87d85
< 
88c86
< counitCoCCC :: CoCCC k => Coexp k b (Sum k b a) `k` a
---
> unitCoCCC-- * Free @'Adjunction' ('Coexp' (<=) a) ('Sum' (<=) a) (<=) (<=)@= swap . coapply
88a87
> unitCoCCC :: CoCCC k => a `k` Sum k b (Coexp k b a)
88a88
> unitCoCCCcounitCoCCC= swap:: CoCCC coapplyk => Coexp k b (Sum k b a) `k` a
89a90
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 702
{-# LANGUAGE Trustworthy #-}
#endif
{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, TypeOperators, FlexibleContexts #-}
-------------------------------------------------------------------------------------------
-- |
-- Module     : Control.Category.Cartesian.Closed
-- Copyright  : 2008 Edward Kmett
-- License    : BSD
--
-- Maintainer : Edward Kmett <ekmett@gmail.com>
-- Stability  : experimental
-- Portability: non-portable (class-associated types)
--
-------------------------------------------------------------------------------------------
module Control.Category.Cartesian.Closed
    (
    -- * Cartesian Closed Category
      CCC(..)
    , unitCCC, counitCCC
    -- * Co-(Cartesian Closed Category)
    , CoCCC(..)
    , unitCoCCC, counitCoCCC
    ) where

import Prelude ()
import qualified Prelude

import Control.Category
import Control.Category.Braided
import Control.Category.Cartesian

-- * Closed Cartesian Category

-- | A 'CCC' has full-fledged monoidal finite products and exponentials

-- Ideally you also want an instance for @'Bifunctor' ('Exp' hom) ('Dual' hom) hom hom@.
-- or at least @'Functor' ('Exp' hom a) hom hom@, which cannot be expressed in the constraints here.

class Cartesian k => CCC k where
    type Exp k :: * -> * -> *
    apply :: Product k (Exp k a b) a `k` b
    curry :: Product k a b `k` c -> a `k` Exp k b c
    uncurry :: a `k` Exp k b c -> Product k a b `k` c

instance CCC (->) where
  type Exp (->) = (->)
  apply (f,a) = f a
  curry = Prelude.curry
  uncurry = Prelude.uncurry

{-# RULES
"curry apply"         curry apply = id
-- "curry . uncurry"     curry . uncurry = id
-- "uncurry . curry"     uncurry . curry = id
 #-}

-- * Free @'Adjunction' (Product (<=) a) (Exp (<=) a) (<=) (<=)@
unitCCC :: CCC k => a `k` Exp k b (Product k b a)
unitCCC = curry braid

counitCCC :: CCC k => Product k b (Exp k b a) `k` a
counitCCC = apply . braid

-- * A Co-(Closed Cartesian Category)

-- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials

-- You probably also want an instance for @'Bifunctor' ('coexp' hom) ('Dual' hom) hom hom@.

class CoCartesian k => CoCCC k where
    type Coexp k :: * -> * -> *
    coapply :: b `k` Sum k (Coexp k a b) a
    cocurry :: c `k` Sum k a b -> Coexp k b c `k` a
    uncocurry :: Coexp k b c `k` a -> c `k` Sum k a b

{-# RULES
"cocurry coapply" cocurry coapply = id
-- "cocurry . uncocurry"   cocurry . uncocurry = id
-- "uncocurry . cocurry"   uncocurry . cocurry = id
 #-}

-- * Free @'Adjunction' ('Coexp' (<=) a) ('Sum' (<=) a) (<=) (<=)@
unitCoCCC :: CoCCC k => a `k` Sum k b (Coexp k b a)
unitCoCCC = swap . coapply

counitCoCCC :: CoCCC k => Coexp k b (Sum k b a) `k` a
counitCoCCC = cocurry swap
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 702
{-# LANGUAGE Trustworthy #-}
#endif
{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, TypeOperators, FlexibleContexts #-}
-------------------------------------------------------------------------------------------
-- |
-- Module     : Control.Category.Cartesian.Closed
-- Copyright  : 2008 Edward Kmett
-- License    : BSD
--
-- Maintainer : Edward Kmett <ekmett@gmail.com>
-- Stability  : experimental
-- Portability: non-portable (class-associated types)
--
-------------------------------------------------------------------------------------------
module Control.Category.Cartesian.Closed
    (
    -- * Cartesian Closed Category
      CCC(..)
    , unitCCC, counitCCC
    -- * Co-(Cartesian Closed Category)
    , CoCCC(..)
    , unitCoCCC, counitCoCCC
    ) where

import Prelude ()
import qualified Prelude

import Control.Category
import Control.Category.Braided
import Control.Category.Cartesian

-- * Closed Cartesian Category

-- | A 'CCC' has full-fledged monoidal finite products and exponentials

-- Ideally you also want an instance for @'Bifunctor' ('Exp' hom) ('Dual' hom) hom hom@.
-- or at least @'Functor' ('Exp' hom a) hom hom@, which cannot be expressed in the constraints here.

class Cartesian k => CCC k where
    type Exp k :: * -> * -> *
    apply :: Product k (Exp k a b) a `k` b
    curry :: Product k a b `k` c -> a `k` Exp k b c
    uncurry :: a `k` Exp k b c -> Product k a b `k` c

instance CCC (->) where
  type Exp (->) = (->)
  apply (f,a) = f a
  curry = Prelude.curry
  uncurry = Prelude.uncurry

{-# RULES
"curry apply"         curry apply = id
-- "curry . uncurry"     curry . uncurry = id
-- "uncurry . curry"     uncurry . curry = id
 #-}

-- * Free @'Adjunction' (Product (<=) a) (Exp (<=) a) (<=) (<=)@
unitCCC-- * Free @'Adjunction' (Product (<=) a) (Exp (<=) a) (<=) (<=)@:: CCC k => a `k` Exp k b (Product k b a)
unitCCC ::= curry kbraid=> a `k` Exp k b (Product k b a)
unitCCC = curry braid
counitCCC :: CCC k => Product k b (Exp k b a) `k` a
counitCCC ::= apply k.=>braid k b (Exp k b a) `k` a
counitCCC = apply . braid
-- * A Co-(Closed Cartesian Category)
-- * A Co-(Closed Cartesian Category)
-- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials
-- | A Co-CCC has full-fledged comonoidal finite coproducts and coexponentials
-- You probably also want an instance for @'Bifunctor' ('coexp' hom) ('Dual' hom) hom hom@.
-- You probably also want an instance for @'Bifunctor' ('coexp' hom) ('Dual' hom) hom hom@.
class CoCartesian k => CoCCC k where
classtypeCoexp k :: =>* ->* ->k*where
    typecoapply:: k ::`k`*Sum-> * ->(Coexp   k a b) a
    coapply :: b `k` Sum k (Coexpb -> kCoexp b)kab c `k` a
    cocurryuncocurry:::: `Coexpk` Sumk k a bk->` aCoexp-> c kkb cSumk` a b
    uncocurry :: Coexp k b c `k` a -> c `k` Sum k a b
{-# RULES
{-# RULES"cocurry coapply" cocurry coapply = id
"cocurry coapply"-- "cocurry . uncocurry"   cocurry . uncocurry = id coapply = id
-- "cocurry . uncocurry"   cocurry . uncocurry = id
-- "uncocurry . cocurry"   uncocurry . cocurry = id#-}
 #-}
-- * Free @'Adjunction' ('Coexp' (<=) a) ('Sum' (<=) a) (<=) (<=)@
unitCoCCC :: CoCCC k => a `k` Sum k b (Coexp k b a)
unitCoCCC-- * Free @'Adjunction' ('Coexp' (<=) a) ('Sum' (<=) a) (<=) (<=)@= swap . coapply
unitCoCCC :: CoCCC k => a `k` Sum k b (Coexp k b a)
unitCoCCCcounitCoCCC= swap:: CoCCC coapplyk => Coexp k b (Sum k b a) `k` a
counitCoCCC = cocurry swap

</pre>