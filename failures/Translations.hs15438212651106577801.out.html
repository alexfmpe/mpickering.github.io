<a href="Transformations.hs6100593591180715935.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Traversal.hs2128236579784558821.out.html">next</a></br></br><pre>33c33
< {-# LINE 97 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
---
> 
33a34
> 
33a35
> 
33a36
> 
33a37
> 
33a38
> 
33a39
> 
33a40
> 
33a41
> 
33a42
> 
33a43
> 
33a44
> 
33a45
> 
33a46
> 
33a47
> 
33a48
> 
33a49
> 
33a50
> 
33a51
> 
33a52
> 
33a53
> 
33a54
> 
33a55
> 
33a56
> 
33a57
> 
33a58
> 
33a59
> 
33a60
> 
33a61
> 
33a62
> 
33a63
> 
33a64
> 
33a65
> 
33a66
> 
33a67
> 
33a68
> 
33a69
> 
33a70
> 
33a71
> 
33a72
> 
33a73
> 
33a74
> 
33a75
> 
33a76
> 
33a77
> 
33a78
> 
33a79
> 
33a80
> 
33a81
> 
33a82
> 
33a83
> 
33a84
> 
33a85
> 
33a86
> 
33a87
> 
33a88
> 
33a89
> 
33a90
> 
33a91
> 
33a92
> 
33a93
> 
33a94
> 
33a95
> 
33a96
> 
52c115
< {-# LINE 117 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
---
> 
52a116
> 
71c135
< {-# LINE 162 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
---
> 
71a136
> 
71a137
> 
71a138
> 
71a139
> 
71a140
> 
71a141
> 
71a142
> 
71a143
> 
71a144
> 
71a145
> 
71a146
> 
71a147
> 
71a148
> 
71a149
> 
71a150
> 
71a151
> 
71a152
> 
71a153
> 
71a154
> 
71a155
> 
71a156
> 
71a157
> 
71a158
> 
71a159
> 
71a160
> 
71a161
> 
83a174
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Translations
( cpTranslateHs2EH
, cpTranslateEH2Output
, cpTranslateEH2Core )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.Base.Target
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import qualified UHC.Light.Compiler.HS.MainAG as HSSem
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.Core.Trf.ElimNonCodegenConstructs
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.CodeGen.ValAccess as VA
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.EHC.CompilePhase.Common
import UHC.Light.Compiler.CodeGen.ModuleImportExportImpl









{-# LINE 97 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
cpTranslateHs2EH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateHs2EH modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbHsSem= ecuMbHSSem ecu
                 hsSem  = panicJust "cpTranslateHs2EH" mbHsSem
                 eh     = HSSem.eh_Syn_AGItf hsSem
                 errs   = Seq.toList $ HSSem.errSq_Syn_AGItf hsSem
         ;  when (isJust mbHsSem)
                 (do { cpUpdCU modNm (ecuStoreEH eh)
                     ; cpSetLimitErrsWhen 5 "Dependency/name analysis" errs
                     ; when (ehcOptEmitHS opts)
                            (liftIO $ putPPFPath (mkOutputFPath opts modNm fp "hs2") (HSSem.pp_Syn_AGItf hsSem) 1000)
                     ; when (ehcOptShowHS opts)
                            (liftIO $ putWidthPPLn 120 (HSSem.pp_Syn_AGItf hsSem))
                     })
         }

{-# LINE 117 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
cpTranslateEH2Output :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateEH2Output modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbEHSem= ecuMbEHSem ecu
                 ehSem  = panicJust "cpTranslateEH2Output" mbEHSem
                 about  = "EH analyses: Type checking"
                 errs   = Seq.toList $ EHSem.allErrSq_Syn_AGItf ehSem
         ;  when (isJust mbEHSem)
                 (do { cpSetLimitErrsWhen 5 about errs
                     ; when (ehcOptEmitEH opts)
                            (liftIO $ putPPFPath (mkOutputFPath opts modNm fp "eh2") (EHSem.pp_Syn_AGItf ehSem) 1000)
                     ; when (ehcOptShowEH opts)
                            (liftIO $ putWidthPPLn 120 (EHSem.pp_Syn_AGItf ehSem))
                     }
                 )
         }

{-# LINE 162 "src/ehc/EHC/CompilePhase/Translations.chs" #-}
cpTranslateEH2Core :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateEH2Core modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbEHSem= ecuMbEHSem ecu
                 ehSem  = panicJust "cpTranslateEH2Core" mbEHSem
                 core   = cmodTrfElimNonCodegenConstructs opts $ EHSem.cmodule_Syn_AGItf  ehSem
         ;  when (isJust mbEHSem)
                 (cpUpdCU modNm ( ecuStoreCore core
                                ))
         }

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Translations
( cpTranslateHs2EH
, cpTranslateEH2Output
, cpTranslateEH2Core )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.Base.Target
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import qualified UHC.Light.Compiler.HS.MainAG as HSSem
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.Core.Trf.ElimNonCodegenConstructs
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.CodeGen.ValAccess as VA
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.EHC.CompilePhase.Common
import UHC.Light.Compiler.CodeGen.ModuleImportExportImpl









































































cpTranslateHs2EH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateHs2EH modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbHsSem= ecuMbHSSem ecu
                 hsSem  = panicJust "cpTranslateHs2EH" mbHsSem
                 eh     = HSSem.eh_Syn_AGItf hsSem
                 errs   = Seq.toList $ HSSem.errSq_Syn_AGItf hsSem
         ;  when (isJust mbHsSem)
                 (do { cpUpdCU modNm (ecuStoreEH eh)
                     ; cpSetLimitErrsWhen 5 "Dependency/name analysis" errs
                     ; when (ehcOptEmitHS opts)
                            (liftIO $ putPPFPath (mkOutputFPath opts modNm fp "hs2") (HSSem.pp_Syn_AGItf hsSem) 1000)
                     ; when (ehcOptShowHS opts)
                            (liftIO $ putWidthPPLn 120 (HSSem.pp_Syn_AGItf hsSem))
                     })
         }



cpTranslateEH2Output :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateEH2Output modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbEHSem= ecuMbEHSem ecu
                 ehSem  = panicJust "cpTranslateEH2Output" mbEHSem
                 about  = "EH analyses: Type checking"
                 errs   = Seq.toList $ EHSem.allErrSq_Syn_AGItf ehSem
         ;  when (isJust mbEHSem)
                 (do { cpSetLimitErrsWhen 5 about errs
                     ; when (ehcOptEmitEH opts)
                            (liftIO $ putPPFPath (mkOutputFPath opts modNm fp "eh2") (EHSem.pp_Syn_AGItf ehSem) 1000)
                     ; when (ehcOptShowEH opts)
                            (liftIO $ putWidthPPLn 120 (EHSem.pp_Syn_AGItf ehSem))
                     }
                 )
         }




























cpTranslateEH2Core :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpTranslateEH2Core modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mbEHSem= ecuMbEHSem ecu
                 ehSem  = panicJust "cpTranslateEH2Core" mbEHSem
                 core   = cmodTrfElimNonCodegenConstructs opts $ EHSem.cmodule_Syn_AGItf  ehSem
         ;  when (isJust mbEHSem)
                 (cpUpdCU modNm ( ecuStoreCore core
                                ))
         }


</pre>