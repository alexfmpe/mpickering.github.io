<a href="GaloisPkg.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Game.hs9483987951114919531.out.html">next</a></br></br><pre>53c53
< {-# LINE 95 "src/ehc/Gam.chs" #-}
---
> 
53a54
> 
53a55
> 
53a56
> 
53a57
> 
53a58
> 
53a59
> 
53a60
> 
53a61
> 
53a62
> 
53a63
> 
53a64
> 
53a65
> 
53a66
> 
53a67
> 
53a68
> 
53a69
> 
53a70
> 
53a71
> 
53a72
> 
53a73
> 
53a74
> 
53a75
> 
53a76
> 
53a77
> 
53a78
> 
53a79
> 
53a80
> 
53a81
> 
53a82
> 
53a83
> 
53a84
> 
53a85
> 
53a86
> 
53a87
> 
53a88
> 
53a89
> 
53a90
> 
53a91
> 
53a92
> 
53a93
> 
53a94
> 
90c131
< {-# LINE 145 "src/ehc/Gam.chs" #-}
---
> 
90a132
> 
90a133
> 
90a134
> 
90a135
> 
90a136
> 
90a137
> 
90a138
> 
90a139
> 
90a140
> 
90a141
> 
90a142
> 
90a143
> 
90a144
> 
98c152
< {-# LINE 158 "src/ehc/Gam.chs" #-}
---
> 
98a153
> 
98a154
> 
98a155
> 
98a156
> 
98a157
> 
102c161
< {-# LINE 163 "src/ehc/Gam.chs" #-}
---
> 
102a162
> 
108c168
< {-# LINE 174 "src/ehc/Gam.chs" #-}
---
> 
108a169
> 
108a170
> 
108a171
> 
108a172
> 
108a173
> 
113c178
< {-# LINE 180 "src/ehc/Gam.chs" #-}
---
> 
113a179
> 
117c183
< {-# LINE 185 "src/ehc/Gam.chs" #-}
---
> 
117a184
> 
122c189
< {-# LINE 206 "src/ehc/Gam.chs" #-}
---
> 
122a190
> 
122a191
> 
122a192
> 
122a193
> 
122a194
> 
122a195
> 
122a196
> 
122a197
> 
122a198
> 
122a199
> 
122a200
> 
122a201
> 
122a202
> 
122a203
> 
122a204
> 
122a205
> 
125c208
< {-# LINE 210 "src/ehc/Gam.chs" #-}
---
> 
125a209
> 
133c217
< {-# LINE 235 "src/ehc/Gam.chs" #-}
---
> 
133a218
> 
133a219
> 
133a220
> 
133a221
> 
133a222
> 
133a223
> 
133a224
> 
133a225
> 
133a226
> 
133a227
> 
133a228
> 
133a229
> 
133a230
> 
133a231
> 
133a232
> 
133a233
> 
133a234
> 
142c243
< {-# LINE 251 "src/ehc/Gam.chs" #-}
---
> 
142a244
> 
142a245
> 
142a246
> 
142a247
> 
142a248
> 
142a249
> 
142a250
> 
146c254
< {-# LINE 256 "src/ehc/Gam.chs" #-}
---
> 
146a255
> 
150c259
< {-# LINE 266 "src/ehc/Gam.chs" #-}
---
> 
150a260
> 
150a261
> 
150a262
> 
150a263
> 
150a264
> 
150a265
> 
154c269
< {-# LINE 275 "src/ehc/Gam.chs" #-}
---
> 
154a270
> 
154a271
> 
154a272
> 
154a273
> 
154a274
> 
160a281
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Gam
( module UHC.Light.Compiler.Gam.Base
, ppGam, ppGamDup
, IdDefOccGam, IdDefOccAsc
, idDefOccGamUnion
, gamDoTyWithVarMp
, SoGam, SoGamInfo (..)
, initSoGam
, idDefOccGamPartitionByKind
, idDefOccGamByKind
, idDefOccGamStrip
, IdQualGam
, idGam2QualGam, idQualGamReplacement )
where
import UHC.Light.Compiler.Gam.Base
import Data.List
import UHC.Util.Utils
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.NameAspect
import UHC.Light.Compiler.Error
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty.Pretty
import qualified Data.Set as Set
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Opts.Base
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Light.Compiler.Core
import UHC.Util.ScopeMapGam
import UHC.Light.Compiler.Base.Debug
import UHC.Light.Compiler.Core.Subst
import UHC.Light.Compiler.VarLookup
















{-# LINE 95 "src/ehc/Gam.chs" #-}
-- Do something with each Ty in a Gam.
-- The global VarMp is kept separately so a new tyvar binding can be computed, which is threaded separatedly and also returned.
-- This allows the retainment of the original tyvar in the Gam, which is required when used twice with different VarMp's.
gamDoTyWithVarMp
  :: Ord key =>
     (info -> Ty,Ty -> info -> info)                                    -- get/set from/into info in Gam
                                                                        -- do whatever must be done given
     -> (key                                                            --   name in gam
         -> (Ty,VarMp)                                                  --   Ty + cycles
         -> VarMp                                                       --   new subst
         -> thr                                                         --   thread
         -> (Ty,VarMp,thr))                                             --   result: new Ty, new subst, thread
     -> VarMp                                                           -- subst for Gam entries
     -> thr                                                             -- initial value for thread
     -> Gam key info                                                    -- the Gam (env)
     -> (Gam key info,VarMp,thr)                                        -- result: new gam, new subst, thread
gamDoTyWithVarMp (get,set) f gamVarMp thr gam
  = (g,c,thr')
  where (g,(thr',c))
           = gamMapThr
               (\(n,gi) (thr,c)
                   -> let t = get gi
                          (t',c',thr') = f n (gamVarMp `varUpdCyc` t) c thr
                          (tg,cg)      = case (tyUnAnn t,tyUnAnn t') of
                                           (Ty_Var v1 _  ,Ty_Var v2 _) | v1 == v2
                                             -> dflt
                                           (Ty_Var v  cat,_          ) | not (tvCatIsFixed cat)
                                             -> (t ,v `varmpTyUnit` t')
                                           _ -> dflt
                                       where dflt = (t',emptyVarMp)
                      in  ((n,set ({- tr "gamDoTyWithVarMp.set" (ppTy tg) $ -} tg) gi)
                          ,(thr',{- (\v -> tr "gamDoTyWithVarMp" (pp v) v) $ -} cg `varmpPlus` c')
                          )
               )
               (thr,emptyVarMp) gam

{-# LINE 145 "src/ehc/Gam.chs" #-}
data SoGamInfo
  = SoGamInfo
      { sgiSo :: Ty }
      deriving Show

type SoGam = Gam HsName SoGamInfo

{-# LINE 158 "src/ehc/Gam.chs" #-}
type IdDefOccGam = Gam    IdOcc  IdDefOcc
type IdDefOccAsc = AssocL IdOcc [IdDefOcc]

{-# LINE 163 "src/ehc/Gam.chs" #-}
-- | Union gam, but tailored to maintaining duplicate definition info
idDefOccGamUnion :: IdDefOccGam -> IdDefOccGam -> IdDefOccGam
idDefOccGamUnion = gamUnionWith idDefOccLCmb
{-# INLINE idDefOccGamUnion #-}

{-# LINE 174 "src/ehc/Gam.chs" #-}
idDefOccGamPartitionByKind :: [IdOccKind] -> IdDefOccGam -> (IdDefOccAsc,IdDefOccAsc)
idDefOccGamPartitionByKind ks
  = partition (\(IdOcc n k',_) -> k' `elem` ks) . gamToAssocDupL

{-# LINE 180 "src/ehc/Gam.chs" #-}
idDefOccGamByKind :: IdOccKind -> IdDefOccGam -> AssocL HsName IdDefOcc
idDefOccGamByKind k g = [ (n,head i) | (IdOcc n _,i) <- fst (idDefOccGamPartitionByKind [k] g) ]

{-# LINE 185 "src/ehc/Gam.chs" #-}
-- | Strip references to original source file location
idDefOccGamStrip :: IdDefOccGam -> IdDefOccGam
idDefOccGamStrip g = gamMap (\(k,v) -> (k,doccStrip v)) g

{-# LINE 206 "src/ehc/Gam.chs" #-}
type IdQualGam = Gam IdOcc HsName

{-# LINE 210 "src/ehc/Gam.chs" #-}
idGam2QualGam :: IdDefOccGam -> IdQualGam
idGam2QualGam = gamMap (\(iocc,docc) -> (iocc {ioccNm = hsnQualified $ ioccNm iocc},ioccNm $ doccOcc $ docc))

idQualGamReplacement :: IdQualGam -> IdOccKind -> HsName -> HsName
idQualGamReplacement g k n = maybe n id $ gamLookup (IdOcc n k) g
{-# INLINE idQualGamReplacement #-}

{-# LINE 235 "src/ehc/Gam.chs" #-}
instance (Ord tk,VarUpdatable vv subst) => VarUpdatable (SGam tk vv) subst where
  s `varUpd`  g    =   gamMapElts (s `varUpd`) g
  s `varUpdCyc` g    =   (g',varmpUnions $ gamElts gm)
              where (g',gm) = sgamUnzip $ gamMapElts (s `varUpdCyc`) g

instance (Ord tk,Ord k,VarExtractable vv k) => VarExtractable (SGam tk vv) k where
  varFreeSet g    =   Set.unions $ map varFreeSet $ gamElts g

{-# LINE 251 "src/ehc/Gam.chs" #-}
ppGam :: (Ord k, PP k, PP v) => Gam k v -> PP_Doc
ppGam g = ppAssocL (gamToAssocL g)

{-# LINE 256 "src/ehc/Gam.chs" #-}
ppGamDup :: (Ord k,PP k, PP v) => Gam k v -> PP_Doc
ppGamDup g = ppAssocL $ map (\(k,v) -> (k,ppBracketsCommas v)) $ gamToAssocDupL $ g

{-# LINE 266 "src/ehc/Gam.chs" #-}
instance (Ord k, PP k, PP v) => PP (SGam k v) where
  pp g = ppGam g

{-# LINE 275 "src/ehc/Gam.chs" #-}
initSoGam :: SoGam
initSoGam
  = assocLToGam
      [ (hsnKindStar,   SoGamInfo kiStar)
      ]

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Gam
( module UHC.Light.Compiler.Gam.Base
, ppGam, ppGamDup
, IdDefOccGam, IdDefOccAsc
, idDefOccGamUnion
, gamDoTyWithVarMp
, SoGam, SoGamInfo (..)
, initSoGam
, idDefOccGamPartitionByKind
, idDefOccGamByKind
, idDefOccGamStrip
, IdQualGam
, idGam2QualGam, idQualGamReplacement )
where
import UHC.Light.Compiler.Gam.Base
import Data.List
import UHC.Util.Utils
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.NameAspect
import UHC.Light.Compiler.Error
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty.Pretty
import qualified Data.Set as Set
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Opts.Base
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Light.Compiler.Core
import UHC.Util.ScopeMapGam
import UHC.Light.Compiler.Base.Debug
import UHC.Light.Compiler.Core.Subst
import UHC.Light.Compiler.VarLookup


























































-- Do something with each Ty in a Gam.
-- The global VarMp is kept separately so a new tyvar binding can be computed, which is threaded separatedly and also returned.
-- This allows the retainment of the original tyvar in the Gam, which is required when used twice with different VarMp's.
gamDoTyWithVarMp
  :: Ord key =>
     (info -> Ty,Ty -> info -> info)                                    -- get/set from/into info in Gam
                                                                        -- do whatever must be done given
     -> (key                                                            --   name in gam
         -> (Ty,VarMp)                                                  --   Ty + cycles
         -> VarMp                                                       --   new subst
         -> thr                                                         --   thread
         -> (Ty,VarMp,thr))                                             --   result: new Ty, new subst, thread
     -> VarMp                                                           -- subst for Gam entries
     -> thr                                                             -- initial value for thread
     -> Gam key info                                                    -- the Gam (env)
     -> (Gam key info,VarMp,thr)                                        -- result: new gam, new subst, thread
gamDoTyWithVarMp (get,set) f gamVarMp thr gam
  = (g,c,thr')
  where (g,(thr',c))
           = gamMapThr
               (\(n,gi) (thr,c)
                   -> let t = get gi
                          (t',c',thr') = f n (gamVarMp `varUpdCyc` t) c thr
                          (tg,cg)      = case (tyUnAnn t,tyUnAnn t') of
                                           (Ty_Var v1 _  ,Ty_Var v2 _) | v1 == v2
                                             -> dflt
                                           (Ty_Var v  cat,_          ) | not (tvCatIsFixed cat)
                                             -> (t ,v `varmpTyUnit` t')
                                           _ -> dflt
                                       where dflt = (t',emptyVarMp)
                      in  ((n,set ({- tr "gamDoTyWithVarMp.set" (ppTy tg) $ -} tg) gi)
                          ,(thr',{- (\v -> tr "gamDoTyWithVarMp" (pp v) v) $ -} cg `varmpPlus` c')
                          )
               )
               (thr,emptyVarMp) gam















data SoGamInfo
  = SoGamInfo
      { sgiSo :: Ty }
      deriving Show

type SoGam = Gam HsName SoGamInfo







type IdDefOccGam = Gam    IdOcc  IdDefOcc
type IdDefOccAsc = AssocL IdOcc [IdDefOcc]



-- | Union gam, but tailored to maintaining duplicate definition info
idDefOccGamUnion :: IdDefOccGam -> IdDefOccGam -> IdDefOccGam
idDefOccGamUnion = gamUnionWith idDefOccLCmb
{-# INLINE idDefOccGamUnion #-}







idDefOccGamPartitionByKind :: [IdOccKind] -> IdDefOccGam -> (IdDefOccAsc,IdDefOccAsc)
idDefOccGamPartitionByKind ks
  = partition (\(IdOcc n k',_) -> k' `elem` ks) . gamToAssocDupL



idDefOccGamByKind :: IdOccKind -> IdDefOccGam -> AssocL HsName IdDefOcc
idDefOccGamByKind k g = [ (n,head i) | (IdOcc n _,i) <- fst (idDefOccGamPartitionByKind [k] g) ]



-- | Strip references to original source file location
idDefOccGamStrip :: IdDefOccGam -> IdDefOccGam
idDefOccGamStrip g = gamMap (\(k,v) -> (k,doccStrip v)) g


















type IdQualGam = Gam IdOcc HsName



idGam2QualGam :: IdDefOccGam -> IdQualGam
idGam2QualGam = gamMap (\(iocc,docc) -> (iocc {ioccNm = hsnQualified $ ioccNm iocc},ioccNm $ doccOcc $ docc))

idQualGamReplacement :: IdQualGam -> IdOccKind -> HsName -> HsName
idQualGamReplacement g k n = maybe n id $ gamLookup (IdOcc n k) g
{-# INLINE idQualGamReplacement #-}



















instance (Ord tk,VarUpdatable vv subst) => VarUpdatable (SGam tk vv) subst where
  s `varUpd`  g    =   gamMapElts (s `varUpd`) g
  s `varUpdCyc` g    =   (g',varmpUnions $ gamElts gm)
              where (g',gm) = sgamUnzip $ gamMapElts (s `varUpdCyc`) g

instance (Ord tk,Ord k,VarExtractable vv k) => VarExtractable (SGam tk vv) k where
  varFreeSet g    =   Set.unions $ map varFreeSet $ gamElts g









ppGam :: (Ord k, PP k, PP v) => Gam k v -> PP_Doc
ppGam g = ppAssocL (gamToAssocL g)



ppGamDup :: (Ord k,PP k, PP v) => Gam k v -> PP_Doc
ppGamDup g = ppAssocL $ map (\(k,v) -> (k,ppBracketsCommas v)) $ gamToAssocDupL $ g








instance (Ord k, PP k, PP v) => PP (SGam k v) where
  pp g = ppGam g







initSoGam :: SoGam
initSoGam
  = assocLToGam
      [ (hsnKindStar,   SoGamInfo kiStar)
      ]


</pre>