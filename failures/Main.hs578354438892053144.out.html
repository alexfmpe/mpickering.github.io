<a href="Main.hs571540977194847408.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs5950286351962408013.out.html">next</a></br></br><pre>20c20
< main ∷ IO ()
---
> main :: IO ()
22d21
<     (prog,args) ← UI.initialise
23d21
<     file ← case args of
24d21
<         [f] → return f
25d21
<         ___ → error "usage: comb [GLUT-options] <file>"
26c22
<     term ← parseFile file
---
>     (prog,args) <- UI.initialise
26a23
>     file <- case args of
26a24
>         [f] -> return f
26a25
>         ___ -> error "usage: comb [GLUT-options] <file>"
26a26
>     term <- parseFile file
31d30
<     (cgf, cf, sf, rot) ← readOnly $ do
32d30
<         cgf ← centralGravitation n
33d30
<         cf ← coulombForce n
34d30
<         sf ← springForce 1.5 n
35c31
<         rot ← angularMomentum n
---
>     (cgf, cf, sf, rot) <- readOnly $ do
35a32
>         cgf <- centralGravitation n
35a33
>         cf <- coulombForce n
35a34
>         sf <- springForce 1.5 n
35a35
>         rot <- angularMomentum n
37c37
<     Unsafe.adjustNode (Position . sf (*0.9) . cgf (*0.01) . cf (\x → min (100/(x^2+0.1)) 10) . position) n
---
>     Unsafe.adjustNode (Position . sf (*0.9) . cgf (*0.01) . cf (\x -> min (100/(x^2+0.1)) 10) . position) n
64a65
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Main where

import GraphRewriting.GL.Render
import GraphRewriting.GL.UI as UI
import Term (parseFile)
import Graph
import GL ()
import Rules
import GraphRewriting
import GraphRewriting.Graph.Write.Unsafe as Unsafe
import GraphRewriting.Layout.Coulomb
import GraphRewriting.Layout.SpringEmbedder
import GraphRewriting.Layout.Gravitation
import GraphRewriting.Layout.Wrapper


instance Render (Wrapper Vertex) where render = render . wrappee

main ∷ IO ()
main = do
    (prog,args) ← UI.initialise
    file ← case args of
        [f] → return f
        ___ → error "usage: comb [GLUT-options] <file>"
    term ← parseFile file
    let graph = fromTerm term
    UI.run 40 id layoutStep (wrapGraph graph) ruleTree

layoutStep n = do
    (cgf, cf, sf, rot) ← readOnly $ do
        cgf ← centralGravitation n
        cf ← coulombForce n
        sf ← springForce 1.5 n
        rot ← angularMomentum n
        return (cgf, cf, sf, rot)
    Unsafe.adjustNode (Position . sf (*0.9) . cgf (*0.01) . cf (\x → min (100/(x^2+0.1)) 10) . position) n
    -- Unsafe.adjustNode (rot (*0.9)) n

-- anyRule = anyOf [ eliminate, ruleI, ruleK0, ruleK1, ruleS0, ruleS1, ruleS2, ruleE0, ruleE1, ruleE2, ruleD0, ruleD1, ruleD2]

ruleTree = Branch "All"
--  [Branch "Optimisation"
--      [Leaf "S(Kx)(Ky) -> K(xy)" optimStoK,
--       Leaf "S(Kx)I    -> x"     optimStox,
--       Leaf "S(Kx)y    -> Bxy"   optimStoB,
--       Leaf "Sx(Ky)    -> Cxy"   optimStoC,
--       Leaf "S(Bkx)y   -> S'kxy" optimStoS',
--       Leaf "B(kx)y    -> B'kxy" optimBtoB',
--       Leaf "C(Bkx)y   -> C'kxy" optimCtoC'],
    [Branch "General"
        [Leaf "Eliminate" eliminate,
         Leaf "Erase" (erase0 <|> eraseApplicator),
         Leaf "Duplicate" duplicate],
     Branch "Combinators"
        [Leaf "S" combinatorS,
         Leaf "K" combinatorK,
         Leaf "I" combinatorI,
         Leaf "B" combinatorB,
         Leaf "C" combinatorC,
         Leaf "S'" combinatorS',
         Leaf "B'" combinatorB',
         Leaf "C'" combinatorC',
         Leaf "W" combinatorW]]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Main where

import GraphRewriting.GL.Render
import GraphRewriting.GL.UI as UI
import Term (parseFile)
import Graph
import GL ()
import Rules
import GraphRewriting
import GraphRewriting.Graph.Write.Unsafe as Unsafe
import GraphRewriting.Layout.Coulomb
import GraphRewriting.Layout.SpringEmbedder
import GraphRewriting.Layout.Gravitation
import GraphRewriting.Layout.Wrapper


instance Render (Wrapper Vertex) where render = render . wrappee

main :: IO ()
main = do
    (prog,args) <- UI.initialise
    file <- case args of
        [f] -> return f
        ___ -> error "usage: comb [GLUT-options] <file>"
    term <- parseFile file
    let graph = fromTerm term
    UI.run 40 id layoutStep (wrapGraph graph) ruleTree

layoutStep n = do
    (cgf, cf, sf, rot) <- readOnly $ do
        cgf <- centralGravitation n
        cf <- coulombForce n
        sf <- springForce 1.5 n
        rot <- angularMomentum n
        return (cgf, cf, sf, rot)
    Unsafe.adjustNode (Position . sf (*0.9) . cgf (*0.01) . cf (\x -> min (100/(x^2+0.1)) 10) . position) n
    -- Unsafe.adjustNode (rot (*0.9)) n

-- anyRule = anyOf [ eliminate, ruleI, ruleK0, ruleK1, ruleS0, ruleS1, ruleS2, ruleE0, ruleE1, ruleE2, ruleD0, ruleD1, ruleD2]

ruleTree = Branch "All"
--  [Branch "Optimisation"
--      [Leaf "S(Kx)(Ky) -> K(xy)" optimStoK,
--       Leaf "S(Kx)I    -> x"     optimStox,
--       Leaf "S(Kx)y    -> Bxy"   optimStoB,
--       Leaf "Sx(Ky)    -> Cxy"   optimStoC,
--       Leaf "S(Bkx)y   -> S'kxy" optimStoS',
--       Leaf "B(kx)y    -> B'kxy" optimBtoB',
--       Leaf "C(Bkx)y   -> C'kxy" optimCtoC'],
    [Branch "General"
        [Leaf "Eliminate" eliminate,
         Leaf "Erase" (erase0 <|> eraseApplicator),
         Leaf "Duplicate" duplicate],
     Branch "Combinators"
        [Leaf "S" combinatorS,
         Leaf "K" combinatorK,
         Leaf "I" combinatorI,
         Leaf "B" combinatorB,
         Leaf "C" combinatorC,
         Leaf "S'" combinatorS',
         Leaf "B'" combinatorB',
         Leaf "C'" combinatorC',
         Leaf "W" combinatorW]]

</pre>