<a href="Hash1.hs8235644401115438165.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Haskell.hs388471006681910962.out.html">next</a></br></br><pre>1a2
> module Data.Homeomorphic.Hash2(
1a3
> #define NAME Hash2, empty, insert, find, findOne
1a4
> #include "Include/Hash.hs") where
3d5
< #define NAME Hash2
4c6
< #include "Include/Hash.hs"
---
> import Data.Homeomorphic.Internal
4a7
> import-- how many of each arityData.Maybe
5a9
> import Data.List(foldl')
5a10
> import qualified Data.Set as Set
5a11
> import qualified Data.IntMap as IntMap
7d12
< -- how many of each arity
8d12
< type Hash k = [(Int,Int)]
10d13
< calcHash :: Ord k => Shell k -> Hash k
11d13
< calcHash = IntMap.toAscList . f IntMap.empty
12c14
<     where f x (Shell a b c) = foldl' f (IntMap.insertWith (\_ i -> i+1) b 1 x) c
---
> data-- important: calculate the hash of y only once per invokation k v = Homeomorphic [(Shell k, Hash k, v)]
14d15
< -- important: calculate the hash of y only once per invokation
15d15
< checkHash :: Ord k => Shell k -> Hash k -> Bool
16d15
< checkHash y = (`listSubset` calcHash y)
18d16
< listSubset [] _ = True
19d16
< listSubset ((x1,x2):xs) ((y1,y2):ys) =
20d16
<     case compare x1 y1 of
21d16
<         EQ -> x2 <= y2 && listSubset xs ys
22d16
<         LT -> False
23d16
<         GT -> listSubset ((x1,x2):xs) ys
24c17
< listSubset _ _ = False
---
> empty :: Homeomorphic k v
24a18
> empty = Homeomorphic []
24a19
> 
24a20
> insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
24a21
> insert k v (Homeomorphic xs) = Homeomorphic ((k,calcHash k,v):xs)
24a22
> 
24a23
> find :: Ord k => Shell k -> Homeomorphic k v -> [v]
24a24
> find k (Homeomorphic xs) = [c | (a,b,c) <- xs, check b, a <<| k]
24a25
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}

#define NAME Hash2
#include "Include/Hash.hs"


-- how many of each arity
type Hash k = [(Int,Int)]

calcHash :: Ord k => Shell k -> Hash k
calcHash = IntMap.toAscList . f IntMap.empty
    where f x (Shell a b c) = foldl' f (IntMap.insertWith (\_ i -> i+1) b 1 x) c

-- important: calculate the hash of y only once per invokation
checkHash :: Ord k => Shell k -> Hash k -> Bool
checkHash y = (`listSubset` calcHash y)

listSubset [] _ = True
listSubset ((x1,x2):xs) ((y1,y2):ys) =
    case compare x1 y1 of
        EQ -> x2 <= y2 && listSubset xs ys
        LT -> False
        GT -> listSubset ((x1,x2):xs) ys
listSubset _ _ = False
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
module Data.Homeomorphic.Hash2(
#define NAME Hash2, empty, insert, find, findOne
#include "Include/Hash.hs") where

import Data.Homeomorphic.Internal
import-- how many of each arityData.Maybe

import Data.List(foldl')
import qualified Data.Set as Set
import qualified Data.IntMap as IntMap


data-- important: calculate the hash of y only once per invokation k v = Homeomorphic [(Shell k, Hash k, v)]


empty :: Homeomorphic k v
empty = Homeomorphic []

insert :: Ord k => Shell k -> v -> Homeomorphic k v -> Homeomorphic k v
insert k v (Homeomorphic xs) = Homeomorphic ((k,calcHash k,v):xs)

find :: Ord k => Shell k -> Homeomorphic k v -> [v]
find k (Homeomorphic xs) = [c | (a,b,c) <- xs, check b, a <<| k]

</pre>