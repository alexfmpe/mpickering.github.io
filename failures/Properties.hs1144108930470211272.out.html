<a href="Propellor.hs16353394251654001669.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Properties.hs1622650073984943658.out.html">next</a></br></br><pre>34c34
< prop_divRndUp_min ∷ Integral α ⇒ α → α → Property
---
> prop_divRndUp_min :: Integral α => α -> α -> Property
42c42
< prop_divRndUp_max ∷ Integral α ⇒ α → α → Property
---
> prop_divRndUp_max :: Integral α => α -> α -> Property
47c47
< prop_divRndUp_ceilFrac ∷ Integral α ⇒ α → α → Property
---
> prop_divRndUp_ceilFrac :: Integral α => α -> α -> Property
49d48
<     let x' = fromIntegral x ∷ Double
50c49
<         y' = fromIntegral y ∷ Double
---
>     let x' = fromIntegral x :: Double
50a50
>         y' = fromIntegral y :: Double
53c53
< prop_divRndUp2 ∷ Integral α ⇒ α → α → Property
---
> prop_divRndUp2 :: Integral α => α -> α -> Property
56d55
< prop_clamp ∷ ∀ α. (Bounded α, Ord α) ⇒ α → Property
57c56
< prop_clamp x = (minBound ∷ α) ≤ (maxBound ∷ α)
---
> prop_clamp :: forall α. (Bounded α, Ord α) => α -> Property
57a57
> prop_clamp x = (minBound :: α) ≤ (maxBound :: α)
63c63
< ceilFrac ∷ (Fractional α, RealFrac α, Integral β) ⇒ α → α → β
---
> ceilFrac :: (Fractional α, RealFrac α, Integral β) => α -> α -> β
66c66
< divRndUp2 ∷ Integral α ⇒ α → α → α
---
> divRndUp2 :: Integral α => α -> α -> α
69a70
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , ScopedTypeVariables
           , UnicodeSyntax
  #-}

module System.FTDI.Utils.Properties where

-- base
import Control.Monad ( (>>) )
import Data.Bool     ( otherwise )
import Data.Function ( ($) )
import Data.Ord      ( Ord )
import Prelude       ( Integral, RealFrac, Fractional, Double
                     , Bounded, minBound, maxBound
                     , fromInteger, toInteger, fromIntegral
                     , (+), abs, mod, ceiling, div
                     )

-- base-unicode
import Data.Bool.Unicode ( (∧) )
import Data.Eq.Unicode   ( (≡), (≢) )
import Data.Ord.Unicode  ( (≤), (≥) )
import Prelude.Unicode   ( (⋅), (÷) )

-- ftdi
import System.FTDI.Utils ( clamp, divRndUp )

-- QuickCheck
import Test.QuickCheck ( Property, (==>) )


-------------------------------------------------------------------------------

prop_divRndUp_min ∷ Integral α ⇒ α → α → Property
prop_divRndUp_min x y = y ≢ 0 ==>
    let d  = divRndUp x (abs y)
        d' = toInteger d
        y' = toInteger y
        x' = toInteger x
    in d' ⋅ abs y' ≥ x'

prop_divRndUp_max ∷ Integral α ⇒ α → α → Property
prop_divRndUp_max x y = y ≢ 0 ==>
    let d = divRndUp x y
    in x `div` y ≤ d

prop_divRndUp_ceilFrac ∷ Integral α ⇒ α → α → Property
prop_divRndUp_ceilFrac x y = y ≢ 0 ==>
    let x' = fromIntegral x ∷ Double
        y' = fromIntegral y ∷ Double
    in divRndUp x y ≡ ceilFrac x' y'

prop_divRndUp2 ∷ Integral α ⇒ α → α → Property
prop_divRndUp2 x y = y ≢ 0 ==> divRndUp x y ≡ divRndUp2 x y

prop_clamp ∷ ∀ α. (Bounded α, Ord α) ⇒ α → Property
prop_clamp x = (minBound ∷ α) ≤ (maxBound ∷ α)
               ==> minBound ≤ cx ∧ cx ≤ maxBound
    where cx = clamp x

-------------------------------------------------------------------------------

ceilFrac ∷ (Fractional α, RealFrac α, Integral β) ⇒ α → α → β
ceilFrac x y = ceiling $ x ÷ y

divRndUp2 ∷ Integral α ⇒ α → α → α
divRndUp2 x y = let r | mod x y ≡ 0 = 0
                      | otherwise   = 1
                in div x y + r
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , ScopedTypeVariables
           , UnicodeSyntax
  #-}

module System.FTDI.Utils.Properties where

-- base
import Control.Monad ( (>>) )
import Data.Bool     ( otherwise )
import Data.Function ( ($) )
import Data.Ord      ( Ord )
import Prelude       ( Integral, RealFrac, Fractional, Double
                     , Bounded, minBound, maxBound
                     , fromInteger, toInteger, fromIntegral
                     , (+), abs, mod, ceiling, div
                     )

-- base-unicode
import Data.Bool.Unicode ( (∧) )
import Data.Eq.Unicode   ( (≡), (≢) )
import Data.Ord.Unicode  ( (≤), (≥) )
import Prelude.Unicode   ( (⋅), (÷) )

-- ftdi
import System.FTDI.Utils ( clamp, divRndUp )

-- QuickCheck
import Test.QuickCheck ( Property, (==>) )


-------------------------------------------------------------------------------

prop_divRndUp_min :: Integral α => α -> α -> Property
prop_divRndUp_min x y = y ≢ 0 ==>
    let d  = divRndUp x (abs y)
        d' = toInteger d
        y' = toInteger y
        x' = toInteger x
    in d' ⋅ abs y' ≥ x'

prop_divRndUp_max :: Integral α => α -> α -> Property
prop_divRndUp_max x y = y ≢ 0 ==>
    let d = divRndUp x y
    in x `div` y ≤ d

prop_divRndUp_ceilFrac :: Integral α => α -> α -> Property
prop_divRndUp_ceilFrac x y = y ≢ 0 ==>
    let x' = fromIntegral x :: Double
        y' = fromIntegral y :: Double
    in divRndUp x y ≡ ceilFrac x' y'

prop_divRndUp2 :: Integral α => α -> α -> Property
prop_divRndUp2 x y = y ≢ 0 ==> divRndUp x y ≡ divRndUp2 x y

prop_clamp :: forall α. (Bounded α, Ord α) => α -> Property
prop_clamp x = (minBound :: α) ≤ (maxBound :: α)
               ==> minBound ≤ cx ∧ cx ≤ maxBound
    where cx = clamp x

-------------------------------------------------------------------------------

ceilFrac :: (Fractional α, RealFrac α, Integral β) => α -> α -> β
ceilFrac x y = ceiling $ x ÷ y

divRndUp2 :: Integral α => α -> α -> α
divRndUp2 x y = let r | mod x y ≡ 0 = 0
                      | otherwise   = 1
                in div x y + r

</pre>