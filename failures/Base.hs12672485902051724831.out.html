<a href="Base.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Base.hs15810301051557810404.out.html">next</a></br></br><pre>186d185
< -- have to specialize manually.  This is unfortunate since it is less general.
187d185
< {-# RULES
188d185
< "freeze/IOCArray/Int"    freeze      = freezeIOCArray :: (Ix i) => IOCArray i Int -> IO (CArray i Int)
189d185
< "freeze/IOCArray/Float"  freeze      = freezeIOCArray :: (Ix i) => IOCArray i Float -> IO (CArray i Float)
190d185
< "freeze/IOCArray/Double" freeze      = freezeIOCArray :: (Ix i) => IOCArray i Double -> IO (CArray i Double)
191d185
< "thaw/IOCArray/Int"      thaw        = thawIOCArray   :: (Ix i) => CArray i Int -> IO (IOCArray i Int)
192d185
< "thaw/IOCArray/Float"    thaw        = thawIOCArray   :: (Ix i) => CArray i Float -> IO (IOCArray i Float)
193c186
< "thaw/IOCArray/Double"   thaw        = thawIOCArray   :: (Ix i) => CArray i Double -> IO (IOCArray i Double)
---
> -- Since we can't parameterize the rules with the (Storable e) constraint, we-- have to specialize manually.  This is unfortunate since it is less general.
193a187
> {-# RULES-- have to specialize manually.  This is unfortunate since it is less general.
193a188
> {-# RULES"freeze/IOCArray/Int"    freeze      = freezeIOCArray :: (Ix i) => IOCArray i Int -> IO (CArray i Int)
193a189
> "freeze/IOCArray/Int""freeze/IOCArray/Float"  freeze      = freezeIOCArray :: (Ix i) => IOCArray i IntFloat->->IOCArray(CArray Inti Float)   )
193a190
> "freeze/IOCArray/Float""freeze/IOCArray/Double" freeze      = freezeIOCArray :: (Ix i) => IOCArray i FloatDouble->->IOIO(CArray(CArrayiiFloatDouble) )
193a191
> "freeze/IOCArray/Double""thaw/IOCArray/Int"      freezethaw        = freezeIOCArraythawIOCArray   :: (Ix i) => IOCArrayCArray i iInt-> IO->(IOCArray (CArrayi Int Double)     )
193a192
> "thaw/IOCArray/Int""thaw/IOCArray/Float"    thaw        = thawIOCArray   :: (Ix i) => CArray i IntFloat->->IOIOCArray(IOCArray Inti Float)   )
193a193
> "thaw/IOCArray/Float""thaw/IOCArray/Double"   thaw        = thawIOCArray   :: (Ix i) => CArray i FloatDouble->->IOIO(IOCArray(IOCArrayiiFloatDouble) )
193a194
> "thaw/IOCArray/Double"#-}                    thaw        = thawIOCArray   :: (Ix i) => CArray i Double -> IO (IOCArray i Double)
196d196
< 
199d198
<     bounds (CArray l u _ _) = (l,u)
200d198
<     {-# INLINE numElements #-}
201d198
<     numElements (CArray _ _ n _) = n
202d198
<     {-# NOINLINE unsafeArray #-}
203d198
<     unsafeArray lu ies = unsafePerformIO $ unsafeArrayCArray lu ies (zeroElem (undefined :: e))
204d198
<     {-# INLINE unsafeAt #-}
205d198
<     unsafeAt (CArray _ _ _ fp) i = S.inlinePerformIO $
206d198
<                                    withForeignPtr fp $ \a -> peekElemOff a i
207d198
<     {-# NOINLINE unsafeReplace #-}
208d198
<     unsafeReplace arr ies = unsafePerformIO $ unsafeReplaceCArray arr ies
209d198
<     {-# NOINLINE unsafeAccum #-}
210c199
<     unsafeAccum f arr ies = unsafePerformIO $ unsafeAccumCArray f arr ies
---
> instancebounds(CArrayel=>u IArray_ _) = CArray(l,u)  e where
210a200
>     {-# INLINE boundsnumElements#-}  #-}
210a201
>     boundsnumElementsCArray(CArray u ___) = (l,u)n
210a202
>     {-# INLINE{-# NOINLINEunsafeArray#-}#-}
210a203
>     numElements (luCArrayies =_unsafePerformIO n _) = n     $ unsafeArrayCArray lu ies (zeroElem (undefined :: e))
210a204
>     {-# NOINLINE{-# INLINE unsafeAt#-}  #-}
210a205
>     unsafeArrayunsafeAt (CArray ies_ = unsafePerformIO_ fp) i = S.inlinePerformIO unsafeArrayCArray$       lu ies (zeroElem (undefined :: e))
210a206
>     {-# INLINE unsafeAt #-}        withForeignPtr fp $ \a -> peekElemOff a i
210a207
>     unsafeAt{-# NOINLINECArrayunsafeReplace _ _ fp) i#-}= S.inlinePerformIO $
210a208
>     unsafeReplace arr ies = unsafePerformIO$ unsafeReplaceCArray $ \a -> peekElemOffarr iesa i
210a209
>     {-# NOINLINE unsafeReplaceunsafeAccum #-}#-}
210a210
>     unsafeReplaceunsafeAccum f arr ies = unsafePerformIO $ unsafeReplaceCArrayunsafeAccumCArray f arr ies
210a211
>     {-# NOINLINE unsafeAccumunsafeAccumArray#-}  #-}
210a212
>     unsafeAccumunsafeAccumArray arrfiese0 =luunsafePerformIOies = unsafePerformIO unsafeAccumCArray$ unsafeAccumArrayCArray arr ies   f e0 lu ies
213d214
< 
214d214
< 
217c217
< zeroElem :: Storable a => a -> a
---
> zeroElem-- | Hackish way to get the zero element for a Storable type.:: Storable a => a -> a
217a218
> {-# NOINLINEzeroElem u = zeroElemunsafePerformIO#-}    $
217a219
> zeroElemwithArray:: Storable(replicate =>(asizeOf-> a u) (0 :: Word8)) $ peek . castPtr
219d220
<     withArray (replicate (sizeOf u) (0 :: Word8)) $ peek . castPtr
220d220
< 
221c221
< {-# INLINE unsafeArrayCArray #-}
---
> {-# INLINEunsafeArrayCArrayreplicate (sizeOf#-} u) (0 :: Word8)) $ peek . castPtr
223d222
<                   => (i,i) -> [(Int, e)] -> e -> IO (CArray i e)
224d222
< unsafeArrayCArray lu ies default_elem = do
225c223
<         marr <- newArray lu default_elem
---
> {-# INLINE unsafeArrayCArray=> (i,i) ->#-}[(Int, e)] -> e -> IO (CArray i e)
225a224
> unsafeArrayCArray :: (iesStorabledefault_elem, Ix i) do
225a225
>         marr <- newArray=> (i,i)lu->default_elem(Int, e)] -> e -> IO (CArray i e)
225a226
> unsafeArrayCArraysequence_ lu[unsafeWrite default_elemmarr i = do| (i, e) <- ies]
225a227
>         marrunsafeFreezeIOCArray<- newArray lu default_elemmarr
227d228
<         unsafeFreezeIOCArray marr
228d228
< 
229c229
< {-# INLINE unsafeReplaceCArray #-}
---
> {-# INLINEunsafeReplaceCArray#-}
231d230
<                        => CArray i e -> [(Int, e)] -> IO (CArray i e)
232d230
< unsafeReplaceCArray arr ies = do
233c231
<     marr <- thawIOCArray arr
---
> {-# INLINE unsafeReplaceCArray=> CArray#-}i e -> [(Int, e)] -> IO (CArray i e)
233a232
> unsafeReplaceCArray ::arr(Storableies = do e, Ix i)
233a233
>     marr <- thawIOCArray=>arr i e -> [(Int, e)] -> IO (CArray i e)
233a234
> unsafeReplaceCArraysequence_ [unsafeWrite iesmarr= doi e | (i, e) <- ies]
233a235
>     marrunsafeFreezeIOCArray<- thawIOCArray arrmarr
235d236
<     unsafeFreezeIOCArray marr
236d236
< 
237c237
< {-# INLINE unsafeAccumCArray #-}
---
> {-# INLINEunsafeAccumCArray#-}
239d238
<                             => (e -> e' -> e) -> CArray i e -> [(Int, e')]
240d238
<                                               -> IO (CArray i e)
241d238
< unsafeAccumCArray f arr ies = do
242d238
<     marr <- thawIOCArray arr
243d238
<     sequence_ [do
244d238
<         old <- unsafeRead marr i
245c239
<         unsafeWrite marr i (f old new)
---
> {-# INLINE unsafeAccumCArray=>#-}(e -> e' -> e) -> CArray i e -> [(Int, e')]
245a240
> unsafeAccumCArray :: (Storable e, Ix i)       -> IO (CArray i e)
245a241
> unsafeAccumCArray f arr ies =>= doe -> e' -> e) -> CArray i e -> [(Int, e')]
245a242
>     marr <- thawIOCArray arr                  -> IO (CArray i e)
245a243
> unsafeAccumCArraysequence_ [do f arr ies = do
245a244
>     marrold<- thawIOCArray<- unsafeReadarrmarr i
245a245
>     sequence_unsafeWritedo   marr i (f old new)
245a246
>         old| (i<-, new) <- ies]marr i
245a247
>     unsafeFreezeIOCArray marr imarrf old new)
247d248
<     unsafeFreezeIOCArray marr
248d248
< 
249c249
< {-# INLINE unsafeAccumArrayCArray #-}
---
> {-# INLINEunsafeAccumArrayCArray     #-}
251d250
<                           => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')]
252d250
<                                             -> IO (CArray i e)
253d250
< unsafeAccumArrayCArray f e0 lu ies = do
254d250
<     marr <- newArray lu e0
255d250
<     sequence_ [do
256d250
<         old <- unsafeRead marr i
257c251
<         unsafeWrite marr i (f old new)
---
> {-# INLINE unsafeAccumArrayCArray=> (e ->#-}e' -> e) -> e -> (i,i) -> [(Int, e')]
257a252
> unsafeAccumArrayCArray :: (Storable e, Ix i)-> IO (CArray i e)
257a253
> unsafeAccumArrayCArray f e0=>lueies-> e'= do-> e) -> e -> (i,i) -> [(Int, e')]
257a254
>     marr <- newArray lu e0                  -> IO (CArray i e)
257a255
> unsafeAccumArrayCArraysequence_ [do      f e0 lu ies = do
257a256
>     marrold<- newArray<- unsafeRead e0marr i
257a257
>     sequence_unsafeWritedo   marr i (f old new)
257a258
>         old| (i<-, new) <- ies]marr i
257a259
>     unsafeFreezeIOCArray marr imarrf old new)
259d260
<     unsafeFreezeIOCArray marr
260d260
< 
261c261
< {-# INLINE eqCArray #-}
---
> {-# INLINEeqCArray #-}  marr
263d262
<                    => CArray i e -> CArray i e -> Bool
264d262
< eqCArray arr1@(CArray l1 u1 n1 _) arr2@(CArray l2 u2 n2 _) =
265c263
<     if n1 == 0 then n2 == 0 else
---
> {-# INLINE eqCArray=>#-}CArray i e -> CArray i e -> Bool
265a264
> eqCArray ::arr1Storable@(CArray el1, Ix in1, Eq_) earr2)  @(CArray l2 u2 n2 _) =
265a265
>     if n1 == 0 then=>n2CArray== 0 else e -> CArray i e -> Bool
265a266
> eqCArrayl1==@(l2CArray&& u1l1==u1u2n1&&_) arr2@(CArray l2 u2 n2 _) =
265a267
>     if n1 ==and then[unsafeAt ==arr1 elsei == unsafeAt arr2 i | i <- [0 .. n1 - 1]]
267d268
<            and [unsafeAt arr1 i == unsafeAt arr2 i | i <- [0 .. n1 - 1]]
268d268
< 
269c269
< {-# INLINE cmpCArray #-}
---
> {-# INLINE andcmpCArrayunsafeAt#-} arr1 i == unsafeAt arr2 i | i <- [0 .. n1 - 1]]
270a271
> {-# INLINE cmpCArray=>#-}CArray i e -> CArray i e -> Ordering
270a272
> cmpCArray ::arr1Storablearr2 = compare, Ix i,assocs e)arr1) (assocs arr2)
272d273
< cmpCArray arr1 arr2 = compare (assocs arr1) (assocs arr2)
273d273
< 
274c274
< {-# INLINE cmpIntCArray #-}
---
> cmpCArray{-# INLINEarr1cmpIntCArray = compare#-}   (assocs arr1) (assocs arr2)
276d275
<                        => CArray Int e -> CArray Int e -> Ordering
277d275
< cmpIntCArray arr1@(CArray l1 u1 n1 _) arr2@(CArray l2 u2 n2 _) =
278d275
<     if n1 == 0 then if n2 == 0 then EQ else LT else
279d275
<     if n2 == 0 then GT else
280d275
<     case compare l1 l2 of
281d275
<         EQ    -> foldr cmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
282d275
<         other -> other
283d275
<     where
284c276
<     cmp i rest = case compare (unsafeAt arr1 i) (unsafeAt arr2 i) of
---
> {-# INLINE cmpIntCArray=>#-}CArray Int e -> CArray Int e -> Ordering
284a277
> cmpIntCArray ::arr1Storable@(CArray el1, Ordu1 n1)_) arr2@(CArray l2 u2 n2 _) =
284a278
>     if n1 == 0 then if => CArray== 0 thenEQ ->elseLT else e -> Ordering
284a279
> cmpIntCArrayif n2 == arr10 then@(CArrayGT else u1 n1 _) arr2@(CArray l2 u2 n2 _) =
284a280
>     ifcasecompare 0 thenl1 if n2 == 0 then EQ else LT else
284a281
>     if n2EQ== 0->thenfoldr elsecmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
284a282
>     caseother-> l1other of
284a283
>     where    -> foldr cmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
284a284
>     cmp otheri rest->= othercase compare (unsafeAt arr1 i) (unsafeAt arr2 i) of
284a285
>     whereEQ    -> rest
284a286
>     cmp iother->= caseothercompare (unsafeAt arr1 i) (unsafeAt arr2 i) of
286d287
<         other -> other
287d287
< 
288c288
< {-# RULES "cmpCArray/Int" cmpCArray = cmpIntCArray #-}
---
> {-# RULES"cmpCArray/Int" other    cmpCArray = cmpIntCArray #-}
290c290
< instance (Ix ix, Eq e, Storable e) => Eq (CArray ix e) where
---
> {-# RULESinstance ("cmpCArray/Int"Ix ix, Eq e, Storablee) =>= cmpIntCArrayEq (CArray ix#-}e) where
292d291
< 
293c292
< instance (Ix ix, Ord e, Storable e) => Ord (CArray ix e) where
---
> instance (Ix ix, Eq e, Storable e) => Eq (CArray ix e) where
293a293
> instance==) =Ixix, Ord e, Storable e) => Ord (CArray ix e) where
295d294
< 
296c295
< instance (Ix ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
---
> instance (Ix ix, Ord e, Storable e) => Ord (CArray ix e) where
296a296
> instance(Ix=ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
298d297
< 
299c298
< --
---
> instance (Ix ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
299a299
> --  showsPrec = showsIArray
302d301
< 
303c302
< -- | O(1) reshape an array.  The number of elements in the new shape must not
---
> -- General purpose array operations which happen to be very fast for CArray.
303a303
> ---- | O(1) reshape an array.  The number of elements in the new shape must not
305d304
< reshape :: (Ix i, Ix j) => (j,j) -> CArray i e -> CArray j e
306c305
< reshape (l',u') (CArray _ _ n fp) | n' > n = error "reshape: new size too large"
---
> reshape-- | O(1) reshape an array.  The number of elements in the new shape must not:: (Ix i, Ix j) => (j,j) -> CArray i e -> CArray j e
306a306
> reshape-- exceed the number in the old shape.  The elements are in C-style ordering.(l',u') (CArray _ _ n fp) | n' > n = error "reshape: new size too large"
306a307
> reshape :: (Ix i, Ix j) => (j,j) ->| CArrayotherwise e=->CArrayl'ju' n' fp
306a308
> reshapewherel'n',u'=)rangeSizeCArray _(_l'n fp) | n' > n = error "reshape: new size too large"
308d309
<     where n' = rangeSize (l', u')
309d309
< 
310c310
< -- | O(1) make a rank 1 array from an arbitrary shape.
---
> -- | O(1) make a rank 1 array from an arbitrary shape.where n' = rangeSize (l', u')
311a312
> flatten-- | O(1) make a rank 1 array from an arbitrary shape.:: Ix i => CArray i e -> CArray Int e
311a313
> flatten-- It has the property that 'reshape (0, size a - 1) a == flatten a'.(CArray _ _ n fp) = CArray 0 (n - 1) n fp
313d314
< flatten (CArray _ _ n fp) = CArray 0 (n - 1) n fp
314d314
< 
315c315
< --
---
> flatten--      (CArray _ _ n fp) = CArray 0 (n - 1) n fp
317d316
< -- faster versions specialized to CArray.  In general, slicing is expensive
318c317
< -- because the slice is not contiguous in memory, so must be copied.  There are
---
> ---- faster versions specialized to CArray.  In general, slicing is expensive
318a318
> -- None of the following are specific to CArray.  Some could have slightly-- because the slice is not contiguous in memory, so must be copied.  There are
318a319
> -- many specialized versions.-- faster versions specialized to CArray.  In general, slicing is expensive
318a320
> ---- because the slice is not contiguous in memory, so must be copied.  There are
320d321
< --
321d321
< 
322c322
< -- | Generic slice and map.  This takes the new range, the inverse map on
---
> ---- | Generic slice and map.  This takes the new range, the inverse map on
324d323
< -- operation in its class.
325d323
< ixmapWithIndP :: (Ix i, Ix i', IArray a e, IArray a' e')
326c324
<                  => (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a' i' e'
---
> -- operation in its class.-- | Generic slice and map.  This takes the new range, the inverse map on
326a325
> ixmapWithIndP-- indices, and function to produce the next element.  It is the most general:: (Ix i, Ix i', IArray a e, IArray a' e')
326a326
> -- operation in its class.=> (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a' i' e'
326a327
> ixmapWithIndP :: (Ixg iarr, Ix= i'listArray, IArraylu e, IArray a' e')
326a328
>                  => (i',i')[->leti'i ->= fi)i'->in(i ->i (earr->!i'i)->i'e'|)i'-><- irange ->lu]i' e'
328d329
<                            [ let i = f i' in g i (arr ! i) i' | i' <- range lu ]
329d329
< 
330c330
< -- | Less polymorphic version.
---
> -- | Less polymorphic version. let i = f i' in g i (arr ! i) i' | i' <- range lu ]
331a332
> -- | Less polymorphic version.=> (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a i' e'
331a333
> ixmapWithInd ::= ixmapWithIndPIx i, Ix i', IArray a e, IArray a e')
333d334
< ixmapWithInd = ixmapWithIndP
334d334
< 
335c335
< -- | Perform an operation on the elements, independent of their location.
---
> ixmapWithInd-- | Perform an operation on the elements, independent of their location.= ixmapWithIndP
337c337
<                => (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a' i' e'
---
> -- | Perform an operation on the elements, independent of their location.=> (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a' i' e'
337a338
> ixmapWithP lu::f(Ixg arr, Ix= listArray, IArraylua e, IArray a' e')
337a339
>                => (i',i') ->g ((arri' ->! fi)i'->) |(ei'-><-e'range) -> alui]e -> a' i' e'
339d340
<                         [ g (arr ! f i') | i' <- range lu ]
340d340
< 
341c341
< -- | Less polymorphic version.
---
> -- | Less polymorphic version. g (arr ! f i') | i' <- range lu ]
342a343
> -- | Less polymorphic version.=> (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a i' e'
342a344
> ixmapWith =::ixmapWithPIx i, Ix i', IArray a e, IArray a e')
344d345
< ixmapWith = ixmapWithP
345d345
< 
346c346
< -- | More polymorphic version of 'ixmap'.
---
> ixmapWith-- | More polymorphic version of 'ixmap'.= ixmapWithP
347a348
> -- | More polymorphic version of 'ixmap'.=> (i',i') -> (i' -> i) -> a i e -> a' i' e
347a349
> ixmapP :: (Ixarr,=IxixmapWithP, IArrayluafe,idIArrayarr   a' e)
349d350
< ixmapP lu f arr = ixmapWithP lu f id arr
350d350
< 
351c351
< -- | More friendly sub-arrays with element mapping.
---
> ixmapP-- | More friendly sub-arrays with element mapping. f arr = ixmapWithP lu f id arr
353d352
<                     => (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a' i' e'
354d352
< sliceStrideWithP lu (start,next,end) f arr
355d352
<     | all (inRange (bounds arr)) [start,next,end] = listArray lu es
356d352
<     | otherwise = error "sliceStrideWith: out of bounds"
357c353
<     where is = offsetShapeFromThenTo (shape arr) (index' start) (index' next) (index' end)
---
> -- | More friendly sub-arrays with element mapping.=> (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a' i' e'
357a354
> sliceStrideWithP :: (Ixstart,,Shapablenext,end)i, Ixarri', IArray a e, IArray a' e')
357a355
>     | all (inRange (=>boundsi',i'arr))->) [(starti,i,i)next->,(ende ->] =e'listArray) -> a i elu->esa' i' e'
357a356
> sliceStrideWithP| otherwise =luerrorstart"sliceStrideWith: out of bounds",next,end) f arr
357a357
>     |where (isinRange= offsetShapeFromThenTobounds arr)) [start(shape,next,arrend)](=index'startlu) (esindex' next) (index' end)
357a358
>     | otherwisees = map= error(f . "sliceStrideWith: out of bounds"(unsafeAt arr)) is
357a359
>     where isindex'= offsetShapeFromThenTo= indexes arr       (shape arr) (index' start) (index' next) (index' end)
359d360
<           index' = indexes arr
360d360
< 
361c361
< -- | Less polymorphic version.
---
> -- | Less polymorphic version. = indexes arr
362a363
> -- | Less polymorphic version.=> (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a i' e'
362a364
> sliceStrideWith ::= sliceStrideWithPIx i, Shapable i, Ix i', IArray a e, IArray a e')
364d365
< sliceStrideWith = sliceStrideWithP
365d365
< 
366c366
< -- | Strided sub-array without element mapping.
---
> sliceStrideWith-- | Strided sub-array without element mapping.= sliceStrideWithP
367a368
> -- | Strided sub-array without element mapping.=> (i',i') -> (i,i,i) -> a i e -> a' i' e
367a369
> sliceStrideP :: (sneIx i,sliceStrideWithP i, Ix i'lu, IArraysne id a e, IArray a' e)
369d370
< sliceStrideP lu sne = sliceStrideWithP lu sne id
370d370
< 
371c371
< -- | Less polymorphic version.
---
> sliceStrideP-- | Less polymorphic version. sne = sliceStrideWithP lu sne id
372a373
> -- | Less polymorphic version.=> (i',i') -> (i,i,i) -> a i e -> a i' e
372a374
> sliceStride ::= sliceStridePIx i, Shapable i, Ix i', IArray a e)
374d375
< sliceStride = sliceStrideP
375d375
< 
376c376
< -- | Contiguous sub-array with element mapping.
---
> sliceStride-- | Contiguous sub-array with element mapping.= sliceStrideP
378d377
<               => (i',i') -> (i,i) -> (e -> e') -> a i e -> a' i' e'
379d377
< sliceWithP lu (start,end) f arr
380d377
<     | all (inRange (bounds arr)) [start,end] = listArray lu es
381d377
<     | otherwise = error "sliceWith: out of bounds"
382c378
<     where is = offsetShapeFromTo (shape arr) (index' start) (index' end)
---
> -- | Contiguous sub-array with element mapping.=> (i',i') -> (i,i) -> (e -> e') -> a i e -> a' i' e'
382a379
> sliceWithP :: (Ixstart,,Shapableend) f arr, Ix i', IArray a e, IArray a' e')
382a380
>     | all (inRange=> (i'(,boundsi') ->arri,i)[->starte,->ende'] ) ->listArray i e ->lua'esi' e'
382a381
> sliceWithP| otherwise (start= error,end)"sliceWith: out of bounds" arr
382a382
>     |where (isinRange= offsetShapeFromTobounds arr)) [start,end] =index'start) es(index' end)
382a383
>     | otherwisees = map= error(f . "sliceWith: out of bounds"(unsafeAt arr)) is
382a384
>     where isindex'= offsetShapeFromTo= indexes arr   (shape arr) (index' start) (index' end)
384d385
<           index' = indexes arr
385d385
< 
386c386
< -- | Less polymorphic version.
---
> -- | Less polymorphic version. = indexes arr
387a388
> -- | Less polymorphic version.=> (i',i') -> (i,i) -> (e -> e') -> a i e -> a i' e'
387a389
> sliceWith ::= sliceWithPIx i, Shapable i, Ix i', IArray a e, IArray a e')
389d390
< sliceWith = sliceWithP
390d390
< 
391c391
< -- | Contiguous sub-array without element mapping.
---
> sliceWith-- | Contiguous sub-array without element mapping.= sliceWithP
392a393
> -- | Contiguous sub-array without element mapping.=> (i',i') -> (i,i) -> a i e -> a' i' e
392a394
> sliceP :: (seIx=i,sliceWithP ilu, Ix i', IArray a e, IArray a' e)
394d395
< sliceP lu se = sliceWithP lu se id
395d395
< 
396c396
< -- | Less polymorphic version.
---
> sliceP-- | Less polymorphic version. se = sliceWithP lu se id
397a398
> -- | Less polymorphic version.=> (i',i') -> (i,i) -> a i e -> a i' e
397a399
> slice ::= slicePIx i, Shapable i, Ix i', IArray a e)
399d400
< slice = sliceP
400d400
< 
401c401
< -- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not
---
> slice-- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not= sliceP
403d402
< -- transparency!
404d402
< {-# INLINE mapCArrayInPlace #-}
405d402
< mapCArrayInPlace :: (Ix i, Storable e) => (e -> e) -> CArray i e -> CArray i e
406d402
< mapCArrayInPlace f a = S.inlinePerformIO $ do
407d402
<     withCArray a $ \p ->
408d402
<         forM_ [0 .. size a - 1] $ \i ->
409d402
<             peekElemOff p i >>= pokeElemOff p i . f
410d402
<     return a
411d402
< 
412c403
< -----------------------------------------
---
> -- transparency!-- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not
412a404
> {-# INLINE-- retain any reference to the original.  It flagrantly breaks referentialmapCArrayInPlace #-}
412a405
> -- transparency! :: (Ix i, Storable e) => (e -> e) -> CArray i e -> CArray i e
412a406
> {-# INLINEmapCArrayInPlacef a = S.inlinePerformIO#-}          $ do
412a407
> mapCArrayInPlacewithCArray a ::$ \(Ix->i, Storable e) => (e -> e) -> CArray i e -> CArray i e
412a408
> mapCArrayInPlaceforM_ [0 f..asize= S.inlinePerformIOa - 1] $ \i ->  $ do
412a409
>     withCArraypeekElemOff $ \p ->p i >>= pokeElemOff p i . f
412a410
>            returna  [0 .. size a - 1] $ \i ->
412a411
>                 peekElemOff p i >>= pokeElemOff p i . f
412a412
> ----------------------------------------- a
413a414
> indexes-----------------------------------------:: (Ix i, Shapable i, IArray a e) => a i e -> i -> [Int]
413a415
> indexes-- These are meant to be internal onlya i = map pred $ (sShape . fst . bounds) a i
415d416
< indexes a i = map pred $ (sShape . fst . bounds) a i
416d416
< 
417c417
< offsetShapeFromThenTo :: [Int] -> [Int] -> [Int] -> [Int] -> [Int]
---
> indexesoffsetShapeFromThenTo i = map pred:: (sShapeInt] ->.[fst].->[Int) a->i[Int] -> [Int]
418a419
> offsetShapeFromThenTowhere ilists = zipWith4:: [Int(]s'->a'Intb']c'->->Intmap] ->(*s'Int) $]enumFromThenTo-> [Int]      a' b' c')
418a420
> offsetShapeFromThenTostride = shapeToStride a b c = foldrs    (liftA2 (+)) [0] (ilists stride a b c)
420d421
<           stride = shapeToStride s
421d421
< 
422c422
< offsetShapeFromTo :: [Int] -> [Int] -> [Int] -> [Int]
---
> offsetShapeFromTo =::[Int] -> [Int] -> [Int] -> [Int]
424d423
< 
425c424
< offsetShapeFromTo' :: ([[Int]] -> [[Int]]) -> [Int] -> [Int] -> [Int] -> [Int]
---
> offsetShapeFromTo :: [Int] -> [Int] -> [Int] -> [Int]
425a425
> offsetShapeFromTooffsetShapeFromTo'=::([[Int]] -> [[Intid]]) -> [Int] -> [Int] -> [Int] -> [Int]
426a427
> offsetShapeFromTo'where ilists = ::zipWith3[[Int]]s'->a'[Intb' ]->])map-> [Int*s'] ->$ enumFromToInt] -> [Inta' ]b'->)  [Int]
426a428
> offsetShapeFromTo'stride = fshapeToStride a b = foldrs (liftA2 (+)) [0] (f $ ilists stride a b)
428d429
<           stride = shapeToStride s
429d429
< 
430c430
< offsets :: (Ix a, Shapable a) => (a, a) -> a -> [Int]
---
> offsets ::stride(Ix a,=Shapablea) => sa, a) -> a -> [Int]
432d431
<     where osets 0 [] = []
433d431
<           osets i' (b:bs) = r : osets d bs
434c432
<               where (d,r) = i' `divMod` b
---
> offsetswhere::osetsIx a, Shapable[] = []  a) => (a, a) -> a -> [Int]
434a433
> offsets luosets = reversei' (b:bs)osets= r :(index lud bs) . reverse . scanl1 (*) . uncurry sShape $ lu
434a434
>     where osetswhere [](=,[] = i' `divMod` b
434a435
>           osets i'_ _(b:bserror) = r"osets" osets d bs
434a436
> -----------------------------------------where (d,r) = i' `divMod` b
436d437
< -----------------------------------------
437d437
< 
438c438
< -- | p-norm on the array taken as a vector
---
> ------------------------------------------- | p-norm on the array taken as a vector
439a440
> normp-- | p-norm on the array taken as a vectorp a | 1 <= p && not (isInfinite p) = (** (1/p)) $ foldl' (\z e -> z + (abs_ e) ** p) 0 (elems a)
439a441
> normp :: (Ix| otherwise, RealFloat= error, Abs"normp: p < 1" e', IArray a e) => e' -> a i e -> e'
441d442
<           | otherwise = error "normp: p < 1"
442d442
< 
443c443
< -- | 2-norm on the array taken as a vector (Frobenius norm for matrices)
---
> -- | 2-norm on the array taken as a vector (Frobenius norm for matrices) otherwise = error "normp: p < 1"
445d444
< norm2 a = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)
446d444
< 
447c445
< -- | Sup norm on the array taken as a vector
---
> norm2-- | 2-norm on the array taken as a vector (Frobenius norm for matrices)a = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)
447a446
> norm2 :: (Ix i, Floating e', Abs e e', IArray a e) => a i e -> e'
447a447
> norm2-- | Sup norm on the array taken as a vector = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)
449d448
< normSup a = foldl' (\z e -> z `max` abs_ e) 0 (elems a)
450d448
< 
451c449
< -- | Polymorphic version of amap.
---
> normSup-- | Sup norm on the array taken as a vectora = foldl' (\z e -> z `max` abs_ e) 0 (elems a)
451a450
> normSup :: (Ix i, Num e', Ord e', Abs e e', IArray a e) => a i e -> e'
451a451
> normSup-- | Polymorphic version of amap. = foldl' (\z e -> z `max` abs_ e) 0 (elems a)
452a453
> -- | Polymorphic version of amap.=> (e -> e1) -> a i e -> a1 i e1
452a454
> liftArrayP ::f a(Ix= listArray, IArray(abounds, IArraya) (map e1f )elems a))
454d455
< liftArrayP f a = listArray (bounds a) (map f (elems a))
455d455
< 
456c456
< -- | Equivalent to amap.  Here for consistency only.
---
> liftArrayP-- | Equivalent to amap.  Here for consistency only. a = listArray (bounds a) (map f (elems a))
457a458
> -- | Equivalent to amap.  Here for consistency only.=> (e -> e1) -> a i e -> a i e1
457a459
> liftArray ::= liftArrayPIx i, IArray a e, IArray a e1)
459d460
< liftArray = liftArrayP
460d460
< 
461c461
< -- | Polymorphic 2-array lift.
---
> liftArray-- | Polymorphic 2-array lift.= liftArrayP
463d462
<               => (e -> e1 -> e2) -> a i e -> a1 i e1 -> a2 i e2
464d462
< liftArray2P f a b | aBounds == bounds b =
465c463
<                      listArray aBounds (zipWith f (elems a) (elems b))
---
> -- | Polymorphic 2-array lift.=> (e -> e1 -> e2) -> a i e -> a1 i e1 -> a2 i e2
465a464
> liftArray2P ::f a(Ixb |i,aBounds== ebounds, IArrayb =a1 e1, IArray a2 e2)
465a465
>               => (e ->listArray -> e2)aBounds-> a i(ezipWith-> a1 i e1(elems-> a2a)i(e2elems b))
465a466
> liftArray2P f a b||otherwise === boundserror "liftArray2: array bounds must match" =
465a467
>     where aBounds = boundsa   aBounds (zipWith f (elems a) (elems b))
467d468
<     where aBounds = bounds a
468d468
< 
469c469
< -- | Less polymorphic version.
---
> -- | Less polymorphic version.where aBounds = bounds a
470a471
> -- | Less polymorphic version.=> (e -> e1 -> e2) -> a i e -> a i e1 -> a i e2
470a472
> liftArray2 ::= liftArray2PIx i, IArray a e, IArray a e1, IArray a e2)
472d473
< liftArray2 = liftArray2P
473d473
< 
474c474
< -- | Polymorphic 3-array lift.
---
> liftArray2-- | Polymorphic 3-array lift.= liftArray2P
476d475
<                => (e -> e1 -> e2 -> e3) -> a i e -> a1 i e1 -> a2 i e2 -> a3 i e3
477d475
< liftArray3P f a b c | aBounds == bounds b && aBounds == bounds c =
478c476
<                        listArray aBounds (zipWith3 f (elems a) (elems b) (elems c))
---
> -- | Polymorphic 3-array lift.=> (e -> e1 -> e2 -> e3) -> a i e -> a1 i e1 -> a2 i e2 -> a3 i e3
478a477
> liftArray3P ::f a(Ixb ci, IArrayaBoundsa==,boundsba1&&e1aBounds, IArray==a2bounds, IArrayc =   a3 e3)
478a478
>                => (e ->listArray -> e2 ->aBounds) ->(zipWith3 i e ->fa1(elems e1 ->a) a2(elems e2b->) (a3elems e3c))
478a479
> liftArray3P f a b c||otherwise === boundserror "liftArray2: array bounds must match" && aBounds == bounds c =
478a480
>     where aBounds = boundsa     aBounds (zipWith3 f (elems a) (elems b) (elems c))
480d481
<     where aBounds = bounds a
481d481
< 
482c482
< -- | Less polymorphic version.
---
> -- | Less polymorphic version.where aBounds = bounds a
483a484
> -- | Less polymorphic version.=> (e -> e1 -> e2 -> e3) -> a i e -> a i e1 -> a i e2 -> a i e3
483a485
> liftArray3 ::= liftArray3PIx i, IArray a e, IArray a e1, IArray a e2, IArray a e3)
486d487
< 
487d487
< 
490d489
<     abs_ :: a -> b
491d489
< instance Abs (Complex Double) Double where
492d489
<     abs_ = magnitude
493c490
< instance Abs (Complex Float) Float where
---
> -- | Hack so that norms have a sensible type.abs_ :: a -> b
493a491
> classinstanceAbs b(|Complex -> bDoublewhere) Double where
493a492
>     abs_ ::= magnitude -> b
493a493
> instance Abs (Complex DoubleFloat))Floatwherewhere
495c495
< instance Abs Double Double where
---
> instance Abs (DoubleComplexDouble)where where
495a496
>     abs_ = magnitudeabs
495a497
> instance Abs DoubleFloat Floatwherewhere
499d500
< 
500d500
< 
503d502
< mallocForeignPtrArrayAligned n = doMalloc undefined
504c503
<   where
---
> mallocForeignPtrArrayAligned-- | Allocate an array which is 16-byte aligned.  Essential for SIMD instructions.n = doMalloc undefined
504a504
> mallocForeignPtrArrayAlignedwhere                      :: Storable a => Int -> IO (ForeignPtr a)
504a505
> mallocForeignPtrArrayAligneddoMalloc :: Storable b =>nb=->IO (ForeignPtrb)
504a506
>   wheredoMalloc dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)
506d507
<     doMalloc dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)
507d507
< 
508c508
< -- | Allocate memory which is 16-byte aligned.  This is essential for SIMD
---
> -- | Allocate memory which is 16-byte aligned.  This is essential for SIMD dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)
510d509
< -- memory, so we pad enough to be able to return the desired amount of memory
511d509
< -- after aligning our pointer.
512d509
< mallocForeignPtrBytesAligned :: Int -> IO (ForeignPtr a)
513d509
< mallocForeignPtrBytesAligned n = do
514d509
<     (ForeignPtr addr contents) <- mallocPlainForeignPtrBytes (n + pad)
515c510
<     let !(Ptr addr') = alignPtr (Ptr addr) 16
---
> -- | Allocate memory which is 16-byte aligned.  This is essential for SIMD-- memory, so we pad enough to be able to return the desired amount of memory
515a511
> -- after aligning our pointer.-- instructions.  We know that mallocPlainForeignPtrBytes will give word-aligned
515a512
> mallocForeignPtrBytesAligned-- memory, so we pad enough to be able to return the desired amount of memory:: Int -> IO (ForeignPtr a)
515a513
> mallocForeignPtrBytesAligned-- after aligning our pointer.n = do
515a514
> mallocForeignPtrBytesAligned(ForeignPtr addr contents::) <-mallocPlainForeignPtrBytes-> IO (ForeignPtr a)     (n + pad)
515a515
> mallocForeignPtrBytesAlignedlet !(Ptr addr') = alignPtr =(doPtr addr) 16
515a516
>     (returnForeignPtr(ForeignPtr contentsaddr' )contents<- mallocPlainForeignPtrBytes)                       (n + pad)
515a517
>     letwhere(Ptr    addr'= 16 ) =sizeOf(undefinedPtr addr::)Word )
517d518
<     where pad = 16 - sizeOf (undefined :: Word)
518d518
< 
519c519
< -- | Make a new CArray with an IO action.
---
> -- | Make a new CArray with an IO action.where pad = 16 - sizeOf (undefined :: Word)
521d520
< createCArray lu f = do
522c521
<     fp <- mallocForeignPtrArrayAligned (rangeSize lu)
---
> createCArray-- | Make a new CArray with an IO action.lu f = do
522a522
> createCArrayfp <- mallocForeignPtrArrayAligned:: (Ix i, Storable e) => (i,rangeSizei) -> (Ptrlue -> IO ()) -> IO (CArray i e)
522a523
> createCArraywithForeignPtr f =fpf
522a524
>     fpunsafeForeignPtrToCArray<- mallocForeignPtrArrayAlignedfp lu     (rangeSize lu)
524d525
<     unsafeForeignPtrToCArray fp lu
525c526
< 
---
> unsafeCreateCArray:: (Ix i, fpStorable    e) => (i,i) -> (Ptr e -> IO ()) -> CArray i e
525a527
> unsafeCreateCArray lu =  unsafePerformIO . createCArray lu
528d529
< 
529d529
< 
532d531
<         put (bounds a)
533d531
<         mapM_ put (elems a)
534d531
<     get = do
535d531
<         lu <- get
536d531
<         es <- replicateM (rangeSize lu) get
537c532
<         return $ listArray lu es
---
> instanceputIx(ibounds, Binarya) i, Binary e, Storable e) => Binary (CArray i e) where
537a533
>     put amapM_= doput (elems a)
537a534
>     get put= do(bounds a)
537a535
>         mapM_lu <- put (elems a)
537a536
>     get =esdo<- replicateM (rangeSize lu) get
537a537
>         lureturn<- get$ listArray lu es
537a538
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE BangPatterns #-}
#ifdef __GLASGOW_HASKELL__
#if __GLASGOW_HASKELL__ < 610
{-# OPTIONS_GHC -frewrite-rules #-}
#else
{-# OPTIONS_GHC -fenable-rewrite-rules #-}
#endif
#endif
-----------------------------------------------------------------------------
-- |
-- Module      : Data.Array.CArray.Base
-- Copyright   : (c) 2001 The University of Glasgow
--               (c) 2008 Jed Brown
-- License     : BSD-style
--
-- Maintainer  : jed@59A2.org
-- Stability   : experimental
-- Portability : non-portable
--
-- This module provides both the immutable 'CArray' and mutable 'IOCArray'.  The
-- underlying storage is exactly the same - pinned memory on the GC'd heap.
-- Elements are stored according to the class 'Storable'.  You can obtain a
-- pointer to the array contents to manipulate elements from languages like C.
--
-- 'CArray' is 16-byte aligned by default.  If you create a 'CArray' with
-- 'unsafeForeignPtrToCArray' then it may not be aligned.  This will be an issue
-- if you intend to use SIMD instructions.
--
-- 'CArray' is similar to 'Data.Array.Unboxed.UArray' but slower if you stay
-- within Haskell.  'CArray' can handle more types and can be used by external
-- libraries.
--
-- 'IOCArray' is equivalent to 'Data.Array.Storable.StorableArray' and similar
-- to 'Data.Array.IO.IOUArray' but slower.  'IOCArray' has O(1) versions of
-- 'unsafeFreeze' and 'unsafeThaw' when converting to/from 'CArray'.
-----------------------------------------------------------------------------

module Data.Array.CArray.Base where

import Control.Applicative
import Control.Monad
import Data.Ix
import Data.Ix.Shapable
import Data.Array.Base
import Data.Array.MArray        ()
import Data.Array.IArray        ()
import qualified Data.ByteString.Internal as S
import Data.Binary
import Data.Complex
import Data.List
import System.IO.Unsafe         (unsafePerformIO)
import Foreign.Storable
import Foreign.ForeignPtr
import Foreign.Ptr
import Foreign.Marshal.Array    (copyArray, withArray)
import Data.Word                ()

import Data.Generics            (Data(..), Typeable(..))
import GHC.Ptr                  (Ptr(..))
import GHC.ForeignPtr           (ForeignPtr(..), mallocPlainForeignPtrBytes)

-- | The immutable array type.
data CArray i e = CArray !i !i Int !(ForeignPtr e)
    deriving (Data, Typeable)

-- | Absolutely equivalent representation, but used for the mutable interface.
data IOCArray i e = IOCArray !i !i Int !(ForeignPtr e)
    deriving (Data, Typeable)

instance Storable e => MArray IOCArray e IO where
    getBounds (IOCArray l u _ _) = return (l,u)

    getNumElements (IOCArray _ _ n _) = return n

    newArray (l,u) e0 = do
        fp <- mallocForeignPtrArrayAligned n
        withForeignPtr fp $ \a ->
            sequence_ [pokeElemOff a i e0 | i <- [0 .. n - 1]]
        return (IOCArray l u n fp)
        where n = rangeSize (l,u)

    unsafeNewArray_ (l,u) = do
        let n = rangeSize (l,u)
        fp <- mallocForeignPtrArrayAligned n
        return (IOCArray l u n fp)

    newArray_ = unsafeNewArray_

    unsafeRead (IOCArray _ _ _ fp) i =
        withForeignPtr fp $ \a -> peekElemOff a i

    unsafeWrite (IOCArray _ _ _ fp) i e =
        withForeignPtr fp $ \a -> pokeElemOff a i e

-- | The pointer to the array contents is obtained by 'withCArray'.
-- The idea is similar to 'ForeignPtr' (used internally here).
-- The pointer should be used only during execution of the 'IO' action
-- retured by the function passed as argument to 'withCArray'.
withCArray :: CArray i e -> (Ptr e -> IO a) -> IO a
withCArray (CArray _ _ _ fp) f = withForeignPtr fp f

withIOCArray :: IOCArray i e -> (Ptr e -> IO a) -> IO a
withIOCArray (IOCArray _ _ _ fp) f = withForeignPtr fp f

-- | If you want to use it afterwards, ensure that you
-- 'touchCArray' after the last use of the pointer,
-- so the array is not freed too early.
touchIOCArray :: IOCArray i e -> IO ()
touchIOCArray (IOCArray _ _ _ fp) = touchForeignPtr fp

-- | /O(1)/ Construct a 'CArray' from an arbitrary 'ForeignPtr'.  It is
-- the caller's responsibility to ensure that the 'ForeignPtr' points to
-- an area of memory sufficient for the specified bounds.
unsafeForeignPtrToCArray
   :: Ix i => ForeignPtr e -> (i,i) -> IO (CArray i e)
unsafeForeignPtrToCArray p (l,u) =
   return (CArray l u (rangeSize (l,u)) p)

-- | /O(1)/ Construct a 'CArray' from an arbitrary 'ForeignPtr'.  It is
-- the caller's responsibility to ensure that the 'ForeignPtr' points to
-- an area of memory sufficient for the specified bounds.
unsafeForeignPtrToIOCArray
   :: Ix i => ForeignPtr e -> (i,i) -> IO (IOCArray i e)
unsafeForeignPtrToIOCArray p (l,u) =
   return (IOCArray l u (rangeSize (l,u)) p)

-- | /O(1)/ Extract ForeignPtr from a CArray.
toForeignPtr :: CArray i e -> (Int, ForeignPtr e)
toForeignPtr (CArray _ _ n fp) = (n, fp)

-- | /O(1)/ Turn a CArray into a ByteString.  Unsafe because it uses
-- 'castForeignPtr' and thus is not platform independent.
unsafeCArrayToByteString :: (Storable e) => CArray i e -> S.ByteString
unsafeCArrayToByteString (CArray _ _ l fp) = go undefined fp
    where go :: (Storable e) => e -> ForeignPtr e -> S.ByteString
          go dummy fp' = S.fromForeignPtr (castForeignPtr fp') 0 (l * sizeOf dummy)

-- | /O(1)/ Turn a ByteString into a CArray.  Unsafe because it uses
-- 'castForeignPtr' and thus is not platform independent.  Returns 'Nothing' if
-- the range specified is larger than the size of the ByteString or the start of
-- the ByteString does not fulfil the alignment requirement of the resulting
-- CArray (as specified by the Storable instance).
unsafeByteStringToCArray :: (Ix i, Storable e)
                            => (i,i) -> S.ByteString -> Maybe (CArray i e)
unsafeByteStringToCArray lu bs = go undefined lu
    where go :: (Ix i, Storable e) => e -> (i,i) -> Maybe (CArray i e)
          go dummy (l,u) | safe = Just (CArray l u n fp)
                         | otherwise = Nothing
              where n = rangeSize (l,u)
                    !((ForeignPtr addr contents), off, len) = S.toForeignPtr bs
                    !p@(Ptr addr') = Ptr addr `plusPtr` off
                    fp = ForeignPtr addr' contents
                    safe = sizeOf dummy * n <= len && p == p `alignPtr` alignment dummy

copy :: (Ix i, Storable e) => CArray i e -> IO (CArray i e)
copy ain@(CArray l u n _) =
    createCArray (l,u) $ \op ->
        withCArray ain $ \ip ->
            copyArray op ip n

freezeIOCArray :: (Ix i, Storable e) => IOCArray i e -> IO (CArray i e)
freezeIOCArray = unsafeFreezeIOCArray >=> copy

unsafeFreezeIOCArray :: (Ix i) => IOCArray i e -> IO (CArray i e)
unsafeFreezeIOCArray (IOCArray l u n fp) = return (CArray l u n fp)

thawIOCArray :: (Ix i, Storable e) => CArray i e -> IO (IOCArray i e)
thawIOCArray = copy >=> unsafeThawIOCArray

unsafeThawIOCArray :: (Ix i) => CArray i e -> IO (IOCArray i e)
unsafeThawIOCArray (CArray l u n fp) = return (IOCArray l u n fp)

-- Since we can remove the (Storable e) restriction for these, the rules are
-- compact and general.
{-# RULES
"unsafeFreeze/IOCArray" unsafeFreeze = unsafeFreezeIOCArray
"unsafeThaw/IOCArray" unsafeThaw = unsafeThawIOCArray
  #-}

-- Since we can't parameterize the rules with the (Storable e) constraint, we
-- have to specialize manually.  This is unfortunate since it is less general.
{-# RULES
"freeze/IOCArray/Int"    freeze      = freezeIOCArray :: (Ix i) => IOCArray i Int -> IO (CArray i Int)
"freeze/IOCArray/Float"  freeze      = freezeIOCArray :: (Ix i) => IOCArray i Float -> IO (CArray i Float)
"freeze/IOCArray/Double" freeze      = freezeIOCArray :: (Ix i) => IOCArray i Double -> IO (CArray i Double)
"thaw/IOCArray/Int"      thaw        = thawIOCArray   :: (Ix i) => CArray i Int -> IO (IOCArray i Int)
"thaw/IOCArray/Float"    thaw        = thawIOCArray   :: (Ix i) => CArray i Float -> IO (IOCArray i Float)
"thaw/IOCArray/Double"   thaw        = thawIOCArray   :: (Ix i) => CArray i Double -> IO (IOCArray i Double)
  #-}


instance Storable e => IArray CArray e where
    {-# INLINE bounds #-}
    bounds (CArray l u _ _) = (l,u)
    {-# INLINE numElements #-}
    numElements (CArray _ _ n _) = n
    {-# NOINLINE unsafeArray #-}
    unsafeArray lu ies = unsafePerformIO $ unsafeArrayCArray lu ies (zeroElem (undefined :: e))
    {-# INLINE unsafeAt #-}
    unsafeAt (CArray _ _ _ fp) i = S.inlinePerformIO $
                                   withForeignPtr fp $ \a -> peekElemOff a i
    {-# NOINLINE unsafeReplace #-}
    unsafeReplace arr ies = unsafePerformIO $ unsafeReplaceCArray arr ies
    {-# NOINLINE unsafeAccum #-}
    unsafeAccum f arr ies = unsafePerformIO $ unsafeAccumCArray f arr ies
    {-# NOINLINE unsafeAccumArray #-}
    unsafeAccumArray f e0 lu ies = unsafePerformIO $ unsafeAccumArrayCArray f e0 lu ies


-- | Hackish way to get the zero element for a Storable type.
{-# NOINLINE zeroElem #-}
zeroElem :: Storable a => a -> a
zeroElem u = unsafePerformIO $
    withArray (replicate (sizeOf u) (0 :: Word8)) $ peek . castPtr

{-# INLINE unsafeArrayCArray #-}
unsafeArrayCArray :: (Storable e, Ix i)
                  => (i,i) -> [(Int, e)] -> e -> IO (CArray i e)
unsafeArrayCArray lu ies default_elem = do
        marr <- newArray lu default_elem
        sequence_ [unsafeWrite marr i e | (i, e) <- ies]
        unsafeFreezeIOCArray marr

{-# INLINE unsafeReplaceCArray #-}
unsafeReplaceCArray :: (Storable e, Ix i)
                       => CArray i e -> [(Int, e)] -> IO (CArray i e)
unsafeReplaceCArray arr ies = do
    marr <- thawIOCArray arr
    sequence_ [unsafeWrite marr i e | (i, e) <- ies]
    unsafeFreezeIOCArray marr

{-# INLINE unsafeAccumCArray #-}
unsafeAccumCArray :: (Storable e, Ix i)
                            => (e -> e' -> e) -> CArray i e -> [(Int, e')]
                                              -> IO (CArray i e)
unsafeAccumCArray f arr ies = do
    marr <- thawIOCArray arr
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    unsafeFreezeIOCArray marr

{-# INLINE unsafeAccumArrayCArray #-}
unsafeAccumArrayCArray :: (Storable e, Ix i)
                          => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')]
                                            -> IO (CArray i e)
unsafeAccumArrayCArray f e0 lu ies = do
    marr <- newArray lu e0
    sequence_ [do
        old <- unsafeRead marr i
        unsafeWrite marr i (f old new)
        | (i, new) <- ies]
    unsafeFreezeIOCArray marr

{-# INLINE eqCArray #-}
eqCArray :: (Storable e, Ix i, Eq e)
                   => CArray i e -> CArray i e -> Bool
eqCArray arr1@(CArray l1 u1 n1 _) arr2@(CArray l2 u2 n2 _) =
    if n1 == 0 then n2 == 0 else
        l1 == l2 && u1 == u2 &&
           and [unsafeAt arr1 i == unsafeAt arr2 i | i <- [0 .. n1 - 1]]

{-# INLINE cmpCArray #-}
cmpCArray :: (Storable e, Ix i, Ord e)
                    => CArray i e -> CArray i e -> Ordering
cmpCArray arr1 arr2 = compare (assocs arr1) (assocs arr2)

{-# INLINE cmpIntCArray #-}
cmpIntCArray :: (Storable e, Ord e)
                       => CArray Int e -> CArray Int e -> Ordering
cmpIntCArray arr1@(CArray l1 u1 n1 _) arr2@(CArray l2 u2 n2 _) =
    if n1 == 0 then if n2 == 0 then EQ else LT else
    if n2 == 0 then GT else
    case compare l1 l2 of
        EQ    -> foldr cmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
        other -> other
    where
    cmp i rest = case compare (unsafeAt arr1 i) (unsafeAt arr2 i) of
        EQ    -> rest
        other -> other

{-# RULES "cmpCArray/Int" cmpCArray = cmpIntCArray #-}

instance (Ix ix, Eq e, Storable e) => Eq (CArray ix e) where
    (==) = eqCArray

instance (Ix ix, Ord e, Storable e) => Ord (CArray ix e) where
    compare = cmpCArray

instance (Ix ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
    showsPrec = showsIArray

--
-- General purpose array operations which happen to be very fast for CArray.
--

-- | O(1) reshape an array.  The number of elements in the new shape must not
-- exceed the number in the old shape.  The elements are in C-style ordering.
reshape :: (Ix i, Ix j) => (j,j) -> CArray i e -> CArray j e
reshape (l',u') (CArray _ _ n fp) | n' > n = error "reshape: new size too large"
                                  | otherwise = CArray l' u' n' fp
    where n' = rangeSize (l', u')

-- | O(1) make a rank 1 array from an arbitrary shape.
-- It has the property that 'reshape (0, size a - 1) a == flatten a'.
flatten :: Ix i => CArray i e -> CArray Int e
flatten (CArray _ _ n fp) = CArray 0 (n - 1) n fp

--
-- None of the following are specific to CArray.  Some could have slightly
-- faster versions specialized to CArray.  In general, slicing is expensive
-- because the slice is not contiguous in memory, so must be copied.  There are
-- many specialized versions.
--

-- | Generic slice and map.  This takes the new range, the inverse map on
-- indices, and function to produce the next element.  It is the most general
-- operation in its class.
ixmapWithIndP :: (Ix i, Ix i', IArray a e, IArray a' e')
                 => (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a' i' e'
ixmapWithIndP lu f g arr = listArray lu
                           [ let i = f i' in g i (arr ! i) i' | i' <- range lu ]

-- | Less polymorphic version.
ixmapWithInd :: (Ix i, Ix i', IArray a e, IArray a e')
                => (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a i' e'
ixmapWithInd = ixmapWithIndP

-- | Perform an operation on the elements, independent of their location.
ixmapWithP  :: (Ix i, Ix i', IArray a e, IArray a' e')
               => (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a' i' e'
ixmapWithP lu f g arr = listArray lu
                        [ g (arr ! f i') | i' <- range lu ]

-- | Less polymorphic version.
ixmapWith  :: (Ix i, Ix i', IArray a e, IArray a e')
              => (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a i' e'
ixmapWith = ixmapWithP

-- | More polymorphic version of 'ixmap'.
ixmapP :: (Ix i, Ix i', IArray a e, IArray a' e)
          => (i',i') -> (i' -> i) -> a i e -> a' i' e
ixmapP lu f arr = ixmapWithP lu f id arr

-- | More friendly sub-arrays with element mapping.
sliceStrideWithP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e')
                    => (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a' i' e'
sliceStrideWithP lu (start,next,end) f arr
    | all (inRange (bounds arr)) [start,next,end] = listArray lu es
    | otherwise = error "sliceStrideWith: out of bounds"
    where is = offsetShapeFromThenTo (shape arr) (index' start) (index' next) (index' end)
          es = map (f . (unsafeAt arr)) is
          index' = indexes arr

-- | Less polymorphic version.
sliceStrideWith :: (Ix i, Shapable i, Ix i', IArray a e, IArray a e')
                   => (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a i' e'
sliceStrideWith = sliceStrideWithP

-- | Strided sub-array without element mapping.
sliceStrideP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e)
                => (i',i') -> (i,i,i) -> a i e -> a' i' e
sliceStrideP lu sne = sliceStrideWithP lu sne id

-- | Less polymorphic version.
sliceStride :: (Ix i, Shapable i, Ix i', IArray a e)
               => (i',i') -> (i,i,i) -> a i e -> a i' e
sliceStride = sliceStrideP

-- | Contiguous sub-array with element mapping.
sliceWithP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e')
              => (i',i') -> (i,i) -> (e -> e') -> a i e -> a' i' e'
sliceWithP lu (start,end) f arr
    | all (inRange (bounds arr)) [start,end] = listArray lu es
    | otherwise = error "sliceWith: out of bounds"
    where is = offsetShapeFromTo (shape arr) (index' start) (index' end)
          es = map (f . (unsafeAt arr)) is
          index' = indexes arr

-- | Less polymorphic version.
sliceWith :: (Ix i, Shapable i, Ix i', IArray a e, IArray a e')
             => (i',i') -> (i,i) -> (e -> e') -> a i e -> a i' e'
sliceWith = sliceWithP

-- | Contiguous sub-array without element mapping.
sliceP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e)
          => (i',i') -> (i,i) -> a i e -> a' i' e
sliceP lu se = sliceWithP lu se id

-- | Less polymorphic version.
slice ::  (Ix i, Shapable i, Ix i', IArray a e)
          => (i',i') -> (i,i) -> a i e -> a i' e
slice = sliceP

-- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not
-- retain any reference to the original.  It flagrantly breaks referential
-- transparency!
{-# INLINE mapCArrayInPlace #-}
mapCArrayInPlace :: (Ix i, Storable e) => (e -> e) -> CArray i e -> CArray i e
mapCArrayInPlace f a = S.inlinePerformIO $ do
    withCArray a $ \p ->
        forM_ [0 .. size a - 1] $ \i ->
            peekElemOff p i >>= pokeElemOff p i . f
    return a

-----------------------------------------
-- These are meant to be internal only
indexes :: (Ix i, Shapable i, IArray a e) => a i e -> i -> [Int]
indexes a i = map pred $ (sShape . fst . bounds) a i

offsetShapeFromThenTo :: [Int] -> [Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromThenTo s a b c = foldr (liftA2 (+)) [0] (ilists stride a b c)
    where ilists = zipWith4 (\s' a' b' c' -> map (*s') $ enumFromThenTo a' b' c')
          stride = shapeToStride s

offsetShapeFromTo :: [Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromTo = offsetShapeFromTo' id

offsetShapeFromTo' :: ([[Int]] -> [[Int]]) -> [Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromTo' f s a b = foldr (liftA2 (+)) [0] (f $ ilists stride a b)
    where ilists = zipWith3 (\s' a' b' -> map (*s') $ enumFromTo a' b')
          stride = shapeToStride s

offsets :: (Ix a, Shapable a) => (a, a) -> a -> [Int]
offsets lu i = reverse . osets (index lu i) . reverse . scanl1 (*) . uncurry sShape $ lu
    where osets 0 [] = []
          osets i' (b:bs) = r : osets d bs
              where (d,r) = i' `divMod` b
          osets _ _ = error "osets"
-----------------------------------------

-- | p-norm on the array taken as a vector
normp :: (Ix i, RealFloat e', Abs e e', IArray a e) => e' -> a i e -> e'
normp p a | 1 <= p && not (isInfinite p) = (** (1/p)) $ foldl' (\z e -> z + (abs_ e) ** p) 0 (elems a)
          | otherwise = error "normp: p < 1"

-- | 2-norm on the array taken as a vector (Frobenius norm for matrices)
norm2 :: (Ix i, Floating e', Abs e e', IArray a e) => a i e -> e'
norm2 a = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)

-- | Sup norm on the array taken as a vector
normSup :: (Ix i, Num e', Ord e', Abs e e', IArray a e) => a i e -> e'
normSup a = foldl' (\z e -> z `max` abs_ e) 0 (elems a)

-- | Polymorphic version of amap.
liftArrayP :: (Ix i, IArray a e, IArray a1 e1)
              => (e -> e1) -> a i e -> a1 i e1
liftArrayP f a = listArray (bounds a) (map f (elems a))

-- | Equivalent to amap.  Here for consistency only.
liftArray :: (Ix i, IArray a e, IArray a e1)
              => (e -> e1) -> a i e -> a i e1
liftArray = liftArrayP

-- | Polymorphic 2-array lift.
liftArray2P :: (Ix i, IArray a e, IArray a1 e1, IArray a2 e2)
              => (e -> e1 -> e2) -> a i e -> a1 i e1 -> a2 i e2
liftArray2P f a b | aBounds == bounds b =
                     listArray aBounds (zipWith f (elems a) (elems b))
                 | otherwise = error "liftArray2: array bounds must match"
    where aBounds = bounds a

-- | Less polymorphic version.
liftArray2 :: (Ix i, IArray a e, IArray a e1, IArray a e2)
              => (e -> e1 -> e2) -> a i e -> a i e1 -> a i e2
liftArray2 = liftArray2P

-- | Polymorphic 3-array lift.
liftArray3P :: (Ix i, IArray a e, IArray a1 e1, IArray a2 e2, IArray a3 e3)
               => (e -> e1 -> e2 -> e3) -> a i e -> a1 i e1 -> a2 i e2 -> a3 i e3
liftArray3P f a b c | aBounds == bounds b && aBounds == bounds c =
                       listArray aBounds (zipWith3 f (elems a) (elems b) (elems c))
                   | otherwise = error "liftArray2: array bounds must match"
    where aBounds = bounds a

-- | Less polymorphic version.
liftArray3 :: (Ix i, IArray a e, IArray a e1, IArray a e2, IArray a e3)
              => (e -> e1 -> e2 -> e3) -> a i e -> a i e1 -> a i e2 -> a i e3
liftArray3 = liftArray3P


-- | Hack so that norms have a sensible type.
class Abs a b | a -> b where
    abs_ :: a -> b
instance Abs (Complex Double) Double where
    abs_ = magnitude
instance Abs (Complex Float) Float where
    abs_ = magnitude
instance Abs Double Double where
    abs_ = abs
instance Abs Float Float where
    abs_ = abs


-- | Allocate an array which is 16-byte aligned.  Essential for SIMD instructions.
mallocForeignPtrArrayAligned :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArrayAligned n = doMalloc undefined
  where
    doMalloc :: Storable b => b -> IO (ForeignPtr b)
    doMalloc dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)

-- | Allocate memory which is 16-byte aligned.  This is essential for SIMD
-- instructions.  We know that mallocPlainForeignPtrBytes will give word-aligned
-- memory, so we pad enough to be able to return the desired amount of memory
-- after aligning our pointer.
mallocForeignPtrBytesAligned :: Int -> IO (ForeignPtr a)
mallocForeignPtrBytesAligned n = do
    (ForeignPtr addr contents) <- mallocPlainForeignPtrBytes (n + pad)
    let !(Ptr addr') = alignPtr (Ptr addr) 16
    return (ForeignPtr addr' contents)
    where pad = 16 - sizeOf (undefined :: Word)

-- | Make a new CArray with an IO action.
createCArray :: (Ix i, Storable e) => (i,i) -> (Ptr e -> IO ()) -> IO (CArray i e)
createCArray lu f = do
    fp <- mallocForeignPtrArrayAligned (rangeSize lu)
    withForeignPtr fp f
    unsafeForeignPtrToCArray fp lu

unsafeCreateCArray :: (Ix i, Storable e) => (i,i) -> (Ptr e -> IO ()) -> CArray i e
unsafeCreateCArray lu =  unsafePerformIO . createCArray lu


instance (Ix i, Binary i, Binary e, Storable e) => Binary (CArray i e) where
    put a = do
        put (bounds a)
        mapM_ put (elems a)
    get = do
        lu <- get
        es <- replicateM (rangeSize lu) get
        return $ listArray lu es
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE BangPatterns #-}
#ifdef __GLASGOW_HASKELL__
#if __GLASGOW_HASKELL__ < 610
{-# OPTIONS_GHC -frewrite-rules #-}
#else
{-# OPTIONS_GHC -fenable-rewrite-rules #-}
#endif
#endif
-----------------------------------------------------------------------------
-- |
-- Module      : Data.Array.CArray.Base
-- Copyright   : (c) 2001 The University of Glasgow
--               (c) 2008 Jed Brown
-- License     : BSD-style
--
-- Maintainer  : jed@59A2.org
-- Stability   : experimental
-- Portability : non-portable
--
-- This module provides both the immutable 'CArray' and mutable 'IOCArray'.  The
-- underlying storage is exactly the same - pinned memory on the GC'd heap.
-- Elements are stored according to the class 'Storable'.  You can obtain a
-- pointer to the array contents to manipulate elements from languages like C.
--
-- 'CArray' is 16-byte aligned by default.  If you create a 'CArray' with
-- 'unsafeForeignPtrToCArray' then it may not be aligned.  This will be an issue
-- if you intend to use SIMD instructions.
--
-- 'CArray' is similar to 'Data.Array.Unboxed.UArray' but slower if you stay
-- within Haskell.  'CArray' can handle more types and can be used by external
-- libraries.
--
-- 'IOCArray' is equivalent to 'Data.Array.Storable.StorableArray' and similar
-- to 'Data.Array.IO.IOUArray' but slower.  'IOCArray' has O(1) versions of
-- 'unsafeFreeze' and 'unsafeThaw' when converting to/from 'CArray'.
-----------------------------------------------------------------------------

module Data.Array.CArray.Base where

import Control.Applicative
import Control.Monad
import Data.Ix
import Data.Ix.Shapable
import Data.Array.Base
import Data.Array.MArray        ()
import Data.Array.IArray        ()
import qualified Data.ByteString.Internal as S
import Data.Binary
import Data.Complex
import Data.List
import System.IO.Unsafe         (unsafePerformIO)
import Foreign.Storable
import Foreign.ForeignPtr
import Foreign.Ptr
import Foreign.Marshal.Array    (copyArray, withArray)
import Data.Word                ()

import Data.Generics            (Data(..), Typeable(..))
import GHC.Ptr                  (Ptr(..))
import GHC.ForeignPtr           (ForeignPtr(..), mallocPlainForeignPtrBytes)

-- | The immutable array type.
data CArray i e = CArray !i !i Int !(ForeignPtr e)
    deriving (Data, Typeable)

-- | Absolutely equivalent representation, but used for the mutable interface.
data IOCArray i e = IOCArray !i !i Int !(ForeignPtr e)
    deriving (Data, Typeable)

instance Storable e => MArray IOCArray e IO where
    getBounds (IOCArray l u _ _) = return (l,u)

    getNumElements (IOCArray _ _ n _) = return n

    newArray (l,u) e0 = do
        fp <- mallocForeignPtrArrayAligned n
        withForeignPtr fp $ \a ->
            sequence_ [pokeElemOff a i e0 | i <- [0 .. n - 1]]
        return (IOCArray l u n fp)
        where n = rangeSize (l,u)

    unsafeNewArray_ (l,u) = do
        let n = rangeSize (l,u)
        fp <- mallocForeignPtrArrayAligned n
        return (IOCArray l u n fp)

    newArray_ = unsafeNewArray_

    unsafeRead (IOCArray _ _ _ fp) i =
        withForeignPtr fp $ \a -> peekElemOff a i

    unsafeWrite (IOCArray _ _ _ fp) i e =
        withForeignPtr fp $ \a -> pokeElemOff a i e

-- | The pointer to the array contents is obtained by 'withCArray'.
-- The idea is similar to 'ForeignPtr' (used internally here).
-- The pointer should be used only during execution of the 'IO' action
-- retured by the function passed as argument to 'withCArray'.
withCArray :: CArray i e -> (Ptr e -> IO a) -> IO a
withCArray (CArray _ _ _ fp) f = withForeignPtr fp f

withIOCArray :: IOCArray i e -> (Ptr e -> IO a) -> IO a
withIOCArray (IOCArray _ _ _ fp) f = withForeignPtr fp f

-- | If you want to use it afterwards, ensure that you
-- 'touchCArray' after the last use of the pointer,
-- so the array is not freed too early.
touchIOCArray :: IOCArray i e -> IO ()
touchIOCArray (IOCArray _ _ _ fp) = touchForeignPtr fp

-- | /O(1)/ Construct a 'CArray' from an arbitrary 'ForeignPtr'.  It is
-- the caller's responsibility to ensure that the 'ForeignPtr' points to
-- an area of memory sufficient for the specified bounds.
unsafeForeignPtrToCArray
   :: Ix i => ForeignPtr e -> (i,i) -> IO (CArray i e)
unsafeForeignPtrToCArray p (l,u) =
   return (CArray l u (rangeSize (l,u)) p)

-- | /O(1)/ Construct a 'CArray' from an arbitrary 'ForeignPtr'.  It is
-- the caller's responsibility to ensure that the 'ForeignPtr' points to
-- an area of memory sufficient for the specified bounds.
unsafeForeignPtrToIOCArray
   :: Ix i => ForeignPtr e -> (i,i) -> IO (IOCArray i e)
unsafeForeignPtrToIOCArray p (l,u) =
   return (IOCArray l u (rangeSize (l,u)) p)

-- | /O(1)/ Extract ForeignPtr from a CArray.
toForeignPtr :: CArray i e -> (Int, ForeignPtr e)
toForeignPtr (CArray _ _ n fp) = (n, fp)

-- | /O(1)/ Turn a CArray into a ByteString.  Unsafe because it uses
-- 'castForeignPtr' and thus is not platform independent.
unsafeCArrayToByteString :: (Storable e) => CArray i e -> S.ByteString
unsafeCArrayToByteString (CArray _ _ l fp) = go undefined fp
    where go :: (Storable e) => e -> ForeignPtr e -> S.ByteString
          go dummy fp' = S.fromForeignPtr (castForeignPtr fp') 0 (l * sizeOf dummy)

-- | /O(1)/ Turn a ByteString into a CArray.  Unsafe because it uses
-- 'castForeignPtr' and thus is not platform independent.  Returns 'Nothing' if
-- the range specified is larger than the size of the ByteString or the start of
-- the ByteString does not fulfil the alignment requirement of the resulting
-- CArray (as specified by the Storable instance).
unsafeByteStringToCArray :: (Ix i, Storable e)
                            => (i,i) -> S.ByteString -> Maybe (CArray i e)
unsafeByteStringToCArray lu bs = go undefined lu
    where go :: (Ix i, Storable e) => e -> (i,i) -> Maybe (CArray i e)
          go dummy (l,u) | safe = Just (CArray l u n fp)
                         | otherwise = Nothing
              where n = rangeSize (l,u)
                    !((ForeignPtr addr contents), off, len) = S.toForeignPtr bs
                    !p@(Ptr addr') = Ptr addr `plusPtr` off
                    fp = ForeignPtr addr' contents
                    safe = sizeOf dummy * n <= len && p == p `alignPtr` alignment dummy

copy :: (Ix i, Storable e) => CArray i e -> IO (CArray i e)
copy ain@(CArray l u n _) =
    createCArray (l,u) $ \op ->
        withCArray ain $ \ip ->
            copyArray op ip n

freezeIOCArray :: (Ix i, Storable e) => IOCArray i e -> IO (CArray i e)
freezeIOCArray = unsafeFreezeIOCArray >=> copy

unsafeFreezeIOCArray :: (Ix i) => IOCArray i e -> IO (CArray i e)
unsafeFreezeIOCArray (IOCArray l u n fp) = return (CArray l u n fp)

thawIOCArray :: (Ix i, Storable e) => CArray i e -> IO (IOCArray i e)
thawIOCArray = copy >=> unsafeThawIOCArray

unsafeThawIOCArray :: (Ix i) => CArray i e -> IO (IOCArray i e)
unsafeThawIOCArray (CArray l u n fp) = return (IOCArray l u n fp)

-- Since we can remove the (Storable e) restriction for these, the rules are
-- compact and general.
{-# RULES
"unsafeFreeze/IOCArray" unsafeFreeze = unsafeFreezeIOCArray
"unsafeThaw/IOCArray" unsafeThaw = unsafeThawIOCArray
  #-}

-- Since we can't parameterize the rules with the (Storable e) constraint, we
-- Since we can't parameterize the rules with the (Storable e) constraint, we-- have to specialize manually.  This is unfortunate since it is less general.
{-# RULES-- have to specialize manually.  This is unfortunate since it is less general.
{-# RULES"freeze/IOCArray/Int"    freeze      = freezeIOCArray :: (Ix i) => IOCArray i Int -> IO (CArray i Int)
"freeze/IOCArray/Int""freeze/IOCArray/Float"  freeze      = freezeIOCArray :: (Ix i) => IOCArray i IntFloat->->IOCArray(CArray Inti Float)   )
"freeze/IOCArray/Float""freeze/IOCArray/Double" freeze      = freezeIOCArray :: (Ix i) => IOCArray i FloatDouble->->IOIO(CArray(CArrayiiFloatDouble) )
"freeze/IOCArray/Double""thaw/IOCArray/Int"      freezethaw        = freezeIOCArraythawIOCArray   :: (Ix i) => IOCArrayCArray i iInt-> IO->(IOCArray (CArrayi Int Double)     )
"thaw/IOCArray/Int""thaw/IOCArray/Float"    thaw        = thawIOCArray   :: (Ix i) => CArray i IntFloat->->IOIOCArray(IOCArray Inti Float)   )
"thaw/IOCArray/Float""thaw/IOCArray/Double"   thaw        = thawIOCArray   :: (Ix i) => CArray i FloatDouble->->IOIO(IOCArray(IOCArrayiiFloatDouble) )
"thaw/IOCArray/Double"#-}                    thaw        = thawIOCArray   :: (Ix i) => CArray i Double -> IO (IOCArray i Double)
  #-}

instance Storable e => IArray CArray e where
    {-# INLINE bounds #-}
instancebounds(CArrayel=>u IArray_ _) = CArray(l,u)  e where
    {-# INLINE boundsnumElements#-}  #-}
    boundsnumElementsCArray(CArray u ___) = (l,u)n
    {-# INLINE{-# NOINLINEunsafeArray#-}#-}
    numElements (luCArrayies =_unsafePerformIO n _) = n     $ unsafeArrayCArray lu ies (zeroElem (undefined :: e))
    {-# NOINLINE{-# INLINE unsafeAt#-}  #-}
    unsafeArrayunsafeAt (CArray ies_ = unsafePerformIO_ fp) i = S.inlinePerformIO unsafeArrayCArray$       lu ies (zeroElem (undefined :: e))
    {-# INLINE unsafeAt #-}        withForeignPtr fp $ \a -> peekElemOff a i
    unsafeAt{-# NOINLINECArrayunsafeReplace _ _ fp) i#-}= S.inlinePerformIO $
    unsafeReplace arr ies = unsafePerformIO$ unsafeReplaceCArray $ \a -> peekElemOffarr iesa i
    {-# NOINLINE unsafeReplaceunsafeAccum #-}#-}
    unsafeReplaceunsafeAccum f arr ies = unsafePerformIO $ unsafeReplaceCArrayunsafeAccumCArray f arr ies
    {-# NOINLINE unsafeAccumunsafeAccumArray#-}  #-}
    unsafeAccumunsafeAccumArray arrfiese0 =luunsafePerformIOies = unsafePerformIO unsafeAccumCArray$ unsafeAccumArrayCArray arr ies   f e0 lu ies
    {-# NOINLINE unsafeAccumArray #-}
    unsafeAccumArray f e0 lu ies = unsafePerformIO $ unsafeAccumArrayCArray f e0 lu ies
-- | Hackish way to get the zero element for a Storable type.
{-# NOINLINE zeroElem #-}
zeroElem-- | Hackish way to get the zero element for a Storable type.:: Storable a => a -> a
{-# NOINLINEzeroElem u = zeroElemunsafePerformIO#-}    $
zeroElemwithArray:: Storable(replicate =>(asizeOf-> a u) (0 :: Word8)) $ peek . castPtr
zeroElem u = unsafePerformIO $
{-# INLINEunsafeArrayCArrayreplicate (sizeOf#-} u) (0 :: Word8)) $ peek . castPtr
unsafeArrayCArray :: (Storable e, Ix i)
{-# INLINE unsafeArrayCArray=> (i,i) ->#-}[(Int, e)] -> e -> IO (CArray i e)
unsafeArrayCArray :: (iesStorabledefault_elem, Ix i) do
        marr <- newArray=> (i,i)lu->default_elem(Int, e)] -> e -> IO (CArray i e)
unsafeArrayCArraysequence_ lu[unsafeWrite default_elemmarr i = do| (i, e) <- ies]
        marrunsafeFreezeIOCArray<- newArray lu default_elemmarr
        sequence_ [unsafeWrite marr i e | (i, e) <- ies]
{-# INLINEunsafeReplaceCArray#-}
unsafeReplaceCArray :: (Storable e, Ix i)
{-# INLINE unsafeReplaceCArray=> CArray#-}i e -> [(Int, e)] -> IO (CArray i e)
unsafeReplaceCArray ::arr(Storableies = do e, Ix i)
    marr <- thawIOCArray=>arr i e -> [(Int, e)] -> IO (CArray i e)
unsafeReplaceCArraysequence_ [unsafeWrite iesmarr= doi e | (i, e) <- ies]
    marrunsafeFreezeIOCArray<- thawIOCArray arrmarr
    sequence_ [unsafeWrite marr i e | (i, e) <- ies]
{-# INLINEunsafeAccumCArray#-}
unsafeAccumCArray :: (Storable e, Ix i)
{-# INLINE unsafeAccumCArray=>#-}(e -> e' -> e) -> CArray i e -> [(Int, e')]
unsafeAccumCArray :: (Storable e, Ix i)       -> IO (CArray i e)
unsafeAccumCArray f arr ies =>= doe -> e' -> e) -> CArray i e -> [(Int, e')]
    marr <- thawIOCArray arr                  -> IO (CArray i e)
unsafeAccumCArraysequence_ [do f arr ies = do
    marrold<- thawIOCArray<- unsafeReadarrmarr i
    sequence_unsafeWritedo   marr i (f old new)
        old| (i<-, new) <- ies]marr i
    unsafeFreezeIOCArray marr imarrf old new)
        | (i, new) <- ies]
{-# INLINEunsafeAccumArrayCArray     #-}
unsafeAccumArrayCArray :: (Storable e, Ix i)
{-# INLINE unsafeAccumArrayCArray=> (e ->#-}e' -> e) -> e -> (i,i) -> [(Int, e')]
unsafeAccumArrayCArray :: (Storable e, Ix i)-> IO (CArray i e)
unsafeAccumArrayCArray f e0=>lueies-> e'= do-> e) -> e -> (i,i) -> [(Int, e')]
    marr <- newArray lu e0                  -> IO (CArray i e)
unsafeAccumArrayCArraysequence_ [do      f e0 lu ies = do
    marrold<- newArray<- unsafeRead e0marr i
    sequence_unsafeWritedo   marr i (f old new)
        old| (i<-, new) <- ies]marr i
    unsafeFreezeIOCArray marr imarrf old new)
        | (i, new) <- ies]
{-# INLINEeqCArray #-}  marr
eqCArray :: (Storable e, Ix i, Eq e)
{-# INLINE eqCArray=>#-}CArray i e -> CArray i e -> Bool
eqCArray ::arr1Storable@(CArray el1, Ix in1, Eq_) earr2)  @(CArray l2 u2 n2 _) =
    if n1 == 0 then=>n2CArray== 0 else e -> CArray i e -> Bool
eqCArrayl1==@(l2CArray&& u1l1==u1u2n1&&_) arr2@(CArray l2 u2 n2 _) =
    if n1 ==and then[unsafeAt ==arr1 elsei == unsafeAt arr2 i | i <- [0 .. n1 - 1]]
        l1 == l2 && u1 == u2 &&
{-# INLINE andcmpCArrayunsafeAt#-} arr1 i == unsafeAt arr2 i | i <- [0 .. n1 - 1]]
cmpCArray :: (Storable e, Ix i, Ord e)
{-# INLINE cmpCArray=>#-}CArray i e -> CArray i e -> Ordering
cmpCArray ::arr1Storablearr2 = compare, Ix i,assocs e)arr1) (assocs arr2)
                    => CArray i e -> CArray i e -> Ordering
cmpCArray{-# INLINEarr1cmpIntCArray = compare#-}   (assocs arr1) (assocs arr2)
cmpIntCArray :: (Storable e, Ord e)
{-# INLINE cmpIntCArray=>#-}CArray Int e -> CArray Int e -> Ordering
cmpIntCArray ::arr1Storable@(CArray el1, Ordu1 n1)_) arr2@(CArray l2 u2 n2 _) =
    if n1 == 0 then if => CArray== 0 thenEQ ->elseLT else e -> Ordering
cmpIntCArrayif n2 == arr10 then@(CArrayGT else u1 n1 _) arr2@(CArray l2 u2 n2 _) =
    ifcasecompare 0 thenl1 if n2 == 0 then EQ else LT else
    if n2EQ== 0->thenfoldr elsecmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
    caseother-> l1other of
    where    -> foldr cmp (compare u1 u2) [0 .. (n1 `min` n2) - 1]
    cmp otheri rest->= othercase compare (unsafeAt arr1 i) (unsafeAt arr2 i) of
    whereEQ    -> rest
    cmp iother->= caseothercompare (unsafeAt arr1 i) (unsafeAt arr2 i) of
        EQ    -> rest
{-# RULES"cmpCArray/Int" other    cmpCArray = cmpIntCArray #-}

{-# RULESinstance ("cmpCArray/Int"Ix ix, Eq e, Storablee) =>= cmpIntCArrayEq (CArray ix#-}e) where
    (==) = eqCArray
instance (Ix ix, Eq e, Storable e) => Eq (CArray ix e) where
instance==) =Ixix, Ord e, Storable e) => Ord (CArray ix e) where
    compare = cmpCArray
instance (Ix ix, Ord e, Storable e) => Ord (CArray ix e) where
instance(Ix=ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
    showsPrec = showsIArray
instance (Ix ix, Show ix, Show e, Storable e) => Show (CArray ix e) where
--  showsPrec = showsIArray
-- General purpose array operations which happen to be very fast for CArray.
--
-- General purpose array operations which happen to be very fast for CArray.
---- | O(1) reshape an array.  The number of elements in the new shape must not
-- exceed the number in the old shape.  The elements are in C-style ordering.
reshape-- | O(1) reshape an array.  The number of elements in the new shape must not:: (Ix i, Ix j) => (j,j) -> CArray i e -> CArray j e
reshape-- exceed the number in the old shape.  The elements are in C-style ordering.(l',u') (CArray _ _ n fp) | n' > n = error "reshape: new size too large"
reshape :: (Ix i, Ix j) => (j,j) ->| CArrayotherwise e=->CArrayl'ju' n' fp
reshapewherel'n',u'=)rangeSizeCArray _(_l'n fp) | n' > n = error "reshape: new size too large"
                                  | otherwise = CArray l' u' n' fp
-- | O(1) make a rank 1 array from an arbitrary shape.where n' = rangeSize (l', u')
-- It has the property that 'reshape (0, size a - 1) a == flatten a'.
flatten-- | O(1) make a rank 1 array from an arbitrary shape.:: Ix i => CArray i e -> CArray Int e
flatten-- It has the property that 'reshape (0, size a - 1) a == flatten a'.(CArray _ _ n fp) = CArray 0 (n - 1) n fp
flatten :: Ix i => CArray i e -> CArray Int e
flatten--      (CArray _ _ n fp) = CArray 0 (n - 1) n fp
-- None of the following are specific to CArray.  Some could have slightly
---- faster versions specialized to CArray.  In general, slicing is expensive
-- None of the following are specific to CArray.  Some could have slightly-- because the slice is not contiguous in memory, so must be copied.  There are
-- many specialized versions.-- faster versions specialized to CArray.  In general, slicing is expensive
---- because the slice is not contiguous in memory, so must be copied.  There are
-- many specialized versions.
---- | Generic slice and map.  This takes the new range, the inverse map on
-- indices, and function to produce the next element.  It is the most general
-- operation in its class.-- | Generic slice and map.  This takes the new range, the inverse map on
ixmapWithIndP-- indices, and function to produce the next element.  It is the most general:: (Ix i, Ix i', IArray a e, IArray a' e')
-- operation in its class.=> (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a' i' e'
ixmapWithIndP :: (Ixg iarr, Ix= i'listArray, IArraylu e, IArray a' e')
                 => (i',i')[->leti'i ->= fi)i'->in(i ->i (earr->!i'i)->i'e'|)i'-><- irange ->lu]i' e'
ixmapWithIndP lu f g arr = listArray lu
-- | Less polymorphic version. let i = f i' in g i (arr ! i) i' | i' <- range lu ]
ixmapWithInd :: (Ix i, Ix i', IArray a e, IArray a e')
-- | Less polymorphic version.=> (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a i' e'
ixmapWithInd ::= ixmapWithIndPIx i, Ix i', IArray a e, IArray a e')
                => (i',i') -> (i' -> i) -> (i -> e -> i' -> e') -> a i e -> a i' e'
ixmapWithInd-- | Perform an operation on the elements, independent of their location.= ixmapWithIndP
ixmapWithP  :: (Ix i, Ix i', IArray a e, IArray a' e')
-- | Perform an operation on the elements, independent of their location.=> (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a' i' e'
ixmapWithP lu::f(Ixg arr, Ix= listArray, IArraylua e, IArray a' e')
               => (i',i') ->g ((arri' ->! fi)i'->) |(ei'-><-e'range) -> alui]e -> a' i' e'
ixmapWithP lu f g arr = listArray lu
-- | Less polymorphic version. g (arr ! f i') | i' <- range lu ]
ixmapWith  :: (Ix i, Ix i', IArray a e, IArray a e')
-- | Less polymorphic version.=> (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a i' e'
ixmapWith =::ixmapWithPIx i, Ix i', IArray a e, IArray a e')
              => (i',i') -> (i' -> i) -> (e -> e') -> a i e -> a i' e'
ixmapWith-- | More polymorphic version of 'ixmap'.= ixmapWithP
ixmapP :: (Ix i, Ix i', IArray a e, IArray a' e)
-- | More polymorphic version of 'ixmap'.=> (i',i') -> (i' -> i) -> a i e -> a' i' e
ixmapP :: (Ixarr,=IxixmapWithP, IArrayluafe,idIArrayarr   a' e)
          => (i',i') -> (i' -> i) -> a i e -> a' i' e
ixmapP-- | More friendly sub-arrays with element mapping. f arr = ixmapWithP lu f id arr
sliceStrideWithP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e')
-- | More friendly sub-arrays with element mapping.=> (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a' i' e'
sliceStrideWithP :: (Ixstart,,Shapablenext,end)i, Ixarri', IArray a e, IArray a' e')
    | all (inRange (=>boundsi',i'arr))->) [(starti,i,i)next->,(ende ->] =e'listArray) -> a i elu->esa' i' e'
sliceStrideWithP| otherwise =luerrorstart"sliceStrideWith: out of bounds",next,end) f arr
    |where (isinRange= offsetShapeFromThenTobounds arr)) [start(shape,next,arrend)](=index'startlu) (esindex' next) (index' end)
    | otherwisees = map= error(f . "sliceStrideWith: out of bounds"(unsafeAt arr)) is
    where isindex'= offsetShapeFromThenTo= indexes arr       (shape arr) (index' start) (index' next) (index' end)
          es = map (f . (unsafeAt arr)) is
-- | Less polymorphic version. = indexes arr
sliceStrideWith :: (Ix i, Shapable i, Ix i', IArray a e, IArray a e')
-- | Less polymorphic version.=> (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a i' e'
sliceStrideWith ::= sliceStrideWithPIx i, Shapable i, Ix i', IArray a e, IArray a e')
                   => (i',i') -> (i,i,i) -> (e -> e') -> a i e -> a i' e'
sliceStrideWith-- | Strided sub-array without element mapping.= sliceStrideWithP
sliceStrideP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e)
-- | Strided sub-array without element mapping.=> (i',i') -> (i,i,i) -> a i e -> a' i' e
sliceStrideP :: (sneIx i,sliceStrideWithP i, Ix i'lu, IArraysne id a e, IArray a' e)
                => (i',i') -> (i,i,i) -> a i e -> a' i' e
sliceStrideP-- | Less polymorphic version. sne = sliceStrideWithP lu sne id
sliceStride :: (Ix i, Shapable i, Ix i', IArray a e)
-- | Less polymorphic version.=> (i',i') -> (i,i,i) -> a i e -> a i' e
sliceStride ::= sliceStridePIx i, Shapable i, Ix i', IArray a e)
               => (i',i') -> (i,i,i) -> a i e -> a i' e
sliceStride-- | Contiguous sub-array with element mapping.= sliceStrideP
sliceWithP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e')
-- | Contiguous sub-array with element mapping.=> (i',i') -> (i,i) -> (e -> e') -> a i e -> a' i' e'
sliceWithP :: (Ixstart,,Shapableend) f arr, Ix i', IArray a e, IArray a' e')
    | all (inRange=> (i'(,boundsi') ->arri,i)[->starte,->ende'] ) ->listArray i e ->lua'esi' e'
sliceWithP| otherwise (start= error,end)"sliceWith: out of bounds" arr
    |where (isinRange= offsetShapeFromTobounds arr)) [start,end] =index'start) es(index' end)
    | otherwisees = map= error(f . "sliceWith: out of bounds"(unsafeAt arr)) is
    where isindex'= offsetShapeFromTo= indexes arr   (shape arr) (index' start) (index' end)
          es = map (f . (unsafeAt arr)) is
-- | Less polymorphic version. = indexes arr
sliceWith :: (Ix i, Shapable i, Ix i', IArray a e, IArray a e')
-- | Less polymorphic version.=> (i',i') -> (i,i) -> (e -> e') -> a i e -> a i' e'
sliceWith ::= sliceWithPIx i, Shapable i, Ix i', IArray a e, IArray a e')
             => (i',i') -> (i,i) -> (e -> e') -> a i e -> a i' e'
sliceWith-- | Contiguous sub-array without element mapping.= sliceWithP
sliceP :: (Ix i, Shapable i, Ix i', IArray a e, IArray a' e)
-- | Contiguous sub-array without element mapping.=> (i',i') -> (i,i) -> a i e -> a' i' e
sliceP :: (seIx=i,sliceWithP ilu, Ix i', IArray a e, IArray a' e)
          => (i',i') -> (i,i) -> a i e -> a' i' e
sliceP-- | Less polymorphic version. se = sliceWithP lu se id
slice ::  (Ix i, Shapable i, Ix i', IArray a e)
-- | Less polymorphic version.=> (i',i') -> (i,i) -> a i e -> a i' e
slice ::= slicePIx i, Shapable i, Ix i', IArray a e)
          => (i',i') -> (i,i) -> a i e -> a i' e
slice-- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not= sliceP
-- retain any reference to the original.  It flagrantly breaks referential
-- transparency!-- | In-place map on CArray.  Note that this is /IN PLACE/ so you should not
{-# INLINE-- retain any reference to the original.  It flagrantly breaks referentialmapCArrayInPlace #-}
-- transparency! :: (Ix i, Storable e) => (e -> e) -> CArray i e -> CArray i e
{-# INLINEmapCArrayInPlacef a = S.inlinePerformIO#-}          $ do
mapCArrayInPlacewithCArray a ::$ \(Ix->i, Storable e) => (e -> e) -> CArray i e -> CArray i e
mapCArrayInPlaceforM_ [0 f..asize= S.inlinePerformIOa - 1] $ \i ->  $ do
    withCArraypeekElemOff $ \p ->p i >>= pokeElemOff p i . f
           returna  [0 .. size a - 1] $ \i ->
                peekElemOff p i >>= pokeElemOff p i . f
----------------------------------------- a
-- These are meant to be internal only
indexes-----------------------------------------:: (Ix i, Shapable i, IArray a e) => a i e -> i -> [Int]
indexes-- These are meant to be internal onlya i = map pred $ (sShape . fst . bounds) a i
indexes :: (Ix i, Shapable i, IArray a e) => a i e -> i -> [Int]
indexesoffsetShapeFromThenTo i = map pred:: (sShapeInt] ->.[fst].->[Int) a->i[Int] -> [Int]
offsetShapeFromThenTo s a b c = foldr (liftA2 (+)) [0] (ilists stride a b c)
offsetShapeFromThenTowhere ilists = zipWith4:: [Int(]s'->a'Intb']c'->->Intmap] ->(*s'Int) $]enumFromThenTo-> [Int]      a' b' c')
offsetShapeFromThenTostride = shapeToStride a b c = foldrs    (liftA2 (+)) [0] (ilists stride a b c)
    where ilists = zipWith4 (\s' a' b' c' -> map (*s') $ enumFromThenTo a' b' c')
offsetShapeFromTo =::[Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromTo = offsetShapeFromTo' id
offsetShapeFromTo :: [Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromTooffsetShapeFromTo'=::([[Int]] -> [[Intid]]) -> [Int] -> [Int] -> [Int] -> [Int]
offsetShapeFromTo' f s a b = foldr (liftA2 (+)) [0] (f $ ilists stride a b)
offsetShapeFromTo'where ilists = ::zipWith3[[Int]]s'->a'[Intb' ]->])map-> [Int*s'] ->$ enumFromToInt] -> [Inta' ]b'->)  [Int]
offsetShapeFromTo'stride = fshapeToStride a b = foldrs (liftA2 (+)) [0] (f $ ilists stride a b)
    where ilists = zipWith3 (\s' a' b' -> map (*s') $ enumFromTo a' b')
offsets ::stride(Ix a,=Shapablea) => sa, a) -> a -> [Int]
offsets lu i = reverse . osets (index lu i) . reverse . scanl1 (*) . uncurry sShape $ lu
offsetswhere::osetsIx a, Shapable[] = []  a) => (a, a) -> a -> [Int]
offsets luosets = reversei' (b:bs)osets= r :(index lud bs) . reverse . scanl1 (*) . uncurry sShape $ lu
    where osetswhere [](=,[] = i' `divMod` b
          osets i'_ _(b:bserror) = r"osets" osets d bs
-----------------------------------------where (d,r) = i' `divMod` b
          osets _ _ = error "osets"
------------------------------------------- | p-norm on the array taken as a vector
normp :: (Ix i, RealFloat e', Abs e e', IArray a e) => e' -> a i e -> e'
normp-- | p-norm on the array taken as a vectorp a | 1 <= p && not (isInfinite p) = (** (1/p)) $ foldl' (\z e -> z + (abs_ e) ** p) 0 (elems a)
normp :: (Ix| otherwise, RealFloat= error, Abs"normp: p < 1" e', IArray a e) => e' -> a i e -> e'
normp p a | 1 <= p && not (isInfinite p) = (** (1/p)) $ foldl' (\z e -> z + (abs_ e) ** p) 0 (elems a)
-- | 2-norm on the array taken as a vector (Frobenius norm for matrices) otherwise = error "normp: p < 1"
norm2 :: (Ix i, Floating e', Abs e e', IArray a e) => a i e -> e'
norm2-- | 2-norm on the array taken as a vector (Frobenius norm for matrices)a = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)
norm2 :: (Ix i, Floating e', Abs e e', IArray a e) => a i e -> e'
norm2-- | Sup norm on the array taken as a vector = sqrt $ foldl' (\z e -> z + abs_ e ^ (2 :: Int)) 0 (elems a)
normSup :: (Ix i, Num e', Ord e', Abs e e', IArray a e) => a i e -> e'
normSup-- | Sup norm on the array taken as a vectora = foldl' (\z e -> z `max` abs_ e) 0 (elems a)
normSup :: (Ix i, Num e', Ord e', Abs e e', IArray a e) => a i e -> e'
normSup-- | Polymorphic version of amap. = foldl' (\z e -> z `max` abs_ e) 0 (elems a)
liftArrayP :: (Ix i, IArray a e, IArray a1 e1)
-- | Polymorphic version of amap.=> (e -> e1) -> a i e -> a1 i e1
liftArrayP ::f a(Ix= listArray, IArray(abounds, IArraya) (map e1f )elems a))
              => (e -> e1) -> a i e -> a1 i e1
liftArrayP-- | Equivalent to amap.  Here for consistency only. a = listArray (bounds a) (map f (elems a))
liftArray :: (Ix i, IArray a e, IArray a e1)
-- | Equivalent to amap.  Here for consistency only.=> (e -> e1) -> a i e -> a i e1
liftArray ::= liftArrayPIx i, IArray a e, IArray a e1)
              => (e -> e1) -> a i e -> a i e1
liftArray-- | Polymorphic 2-array lift.= liftArrayP
liftArray2P :: (Ix i, IArray a e, IArray a1 e1, IArray a2 e2)
-- | Polymorphic 2-array lift.=> (e -> e1 -> e2) -> a i e -> a1 i e1 -> a2 i e2
liftArray2P ::f a(Ixb |i,aBounds== ebounds, IArrayb =a1 e1, IArray a2 e2)
              => (e ->listArray -> e2)aBounds-> a i(ezipWith-> a1 i e1(elems-> a2a)i(e2elems b))
liftArray2P f a b||otherwise === boundserror "liftArray2: array bounds must match" =
    where aBounds = boundsa   aBounds (zipWith f (elems a) (elems b))
                 | otherwise = error "liftArray2: array bounds must match"
-- | Less polymorphic version.where aBounds = bounds a
liftArray2 :: (Ix i, IArray a e, IArray a e1, IArray a e2)
-- | Less polymorphic version.=> (e -> e1 -> e2) -> a i e -> a i e1 -> a i e2
liftArray2 ::= liftArray2PIx i, IArray a e, IArray a e1, IArray a e2)
              => (e -> e1 -> e2) -> a i e -> a i e1 -> a i e2
liftArray2-- | Polymorphic 3-array lift.= liftArray2P
liftArray3P :: (Ix i, IArray a e, IArray a1 e1, IArray a2 e2, IArray a3 e3)
-- | Polymorphic 3-array lift.=> (e -> e1 -> e2 -> e3) -> a i e -> a1 i e1 -> a2 i e2 -> a3 i e3
liftArray3P ::f a(Ixb ci, IArrayaBoundsa==,boundsba1&&e1aBounds, IArray==a2bounds, IArrayc =   a3 e3)
               => (e ->listArray -> e2 ->aBounds) ->(zipWith3 i e ->fa1(elems e1 ->a) a2(elems e2b->) (a3elems e3c))
liftArray3P f a b c||otherwise === boundserror "liftArray2: array bounds must match" && aBounds == bounds c =
    where aBounds = boundsa     aBounds (zipWith3 f (elems a) (elems b) (elems c))
                   | otherwise = error "liftArray2: array bounds must match"
-- | Less polymorphic version.where aBounds = bounds a
liftArray3 :: (Ix i, IArray a e, IArray a e1, IArray a e2, IArray a e3)
-- | Less polymorphic version.=> (e -> e1 -> e2 -> e3) -> a i e -> a i e1 -> a i e2 -> a i e3
liftArray3 ::= liftArray3PIx i, IArray a e, IArray a e1, IArray a e2, IArray a e3)
              => (e -> e1 -> e2 -> e3) -> a i e -> a i e1 -> a i e2 -> a i e3
liftArray3 = liftArray3P
-- | Hack so that norms have a sensible type.
class Abs a b | a -> b where
-- | Hack so that norms have a sensible type.abs_ :: a -> b
classinstanceAbs b(|Complex -> bDoublewhere) Double where
    abs_ ::= magnitude -> b
instance Abs (Complex DoubleFloat))Floatwherewhere
    abs_ = magnitude
instance Abs (DoubleComplexDouble)where where
    abs_ = magnitudeabs
instance Abs DoubleFloat Floatwherewhere
    abs_ = abs
instance Abs Float Float where
    abs_ = abs
-- | Allocate an array which is 16-byte aligned.  Essential for SIMD instructions.
mallocForeignPtrArrayAligned :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArrayAligned-- | Allocate an array which is 16-byte aligned.  Essential for SIMD instructions.n = doMalloc undefined
mallocForeignPtrArrayAlignedwhere                      :: Storable a => Int -> IO (ForeignPtr a)
mallocForeignPtrArrayAligneddoMalloc :: Storable b =>nb=->IO (ForeignPtrb)
  wheredoMalloc dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)
    doMalloc :: Storable b => b -> IO (ForeignPtr b)
-- | Allocate memory which is 16-byte aligned.  This is essential for SIMD dummy = mallocForeignPtrBytesAligned (n * sizeOf dummy)
-- instructions.  We know that mallocPlainForeignPtrBytes will give word-aligned
-- | Allocate memory which is 16-byte aligned.  This is essential for SIMD-- memory, so we pad enough to be able to return the desired amount of memory
-- after aligning our pointer.-- instructions.  We know that mallocPlainForeignPtrBytes will give word-aligned
mallocForeignPtrBytesAligned-- memory, so we pad enough to be able to return the desired amount of memory:: Int -> IO (ForeignPtr a)
mallocForeignPtrBytesAligned-- after aligning our pointer.n = do
mallocForeignPtrBytesAligned(ForeignPtr addr contents::) <-mallocPlainForeignPtrBytes-> IO (ForeignPtr a)     (n + pad)
mallocForeignPtrBytesAlignedlet !(Ptr addr') = alignPtr =(doPtr addr) 16
    (returnForeignPtr(ForeignPtr contentsaddr' )contents<- mallocPlainForeignPtrBytes)                       (n + pad)
    letwhere(Ptr    addr'= 16 ) =sizeOf(undefinedPtr addr::)Word )
    return (ForeignPtr addr' contents)
-- | Make a new CArray with an IO action.where pad = 16 - sizeOf (undefined :: Word)
createCArray :: (Ix i, Storable e) => (i,i) -> (Ptr e -> IO ()) -> IO (CArray i e)
createCArray-- | Make a new CArray with an IO action.lu f = do
createCArrayfp <- mallocForeignPtrArrayAligned:: (Ix i, Storable e) => (i,rangeSizei) -> (Ptrlue -> IO ()) -> IO (CArray i e)
createCArraywithForeignPtr f =fpf
    fpunsafeForeignPtrToCArray<- mallocForeignPtrArrayAlignedfp lu     (rangeSize lu)
    withForeignPtr fp f
unsafeCreateCArray:: (Ix i, fpStorable    e) => (i,i) -> (Ptr e -> IO ()) -> CArray i e
unsafeCreateCArray lu =  unsafePerformIO . createCArray lu
unsafeCreateCArray :: (Ix i, Storable e) => (i,i) -> (Ptr e -> IO ()) -> CArray i e
unsafeCreateCArray lu =  unsafePerformIO . createCArray lu
instance (Ix i, Binary i, Binary e, Storable e) => Binary (CArray i e) where
    put a = do
instanceputIx(ibounds, Binarya) i, Binary e, Storable e) => Binary (CArray i e) where
    put amapM_= doput (elems a)
    get put= do(bounds a)
        mapM_lu <- put (elems a)
    get =esdo<- replicateM (rangeSize lu) get
        lureturn<- get$ listArray lu es

</pre>