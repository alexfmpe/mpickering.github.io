<a href="Label.hs1194314738318153057.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Lazy.hs20516216091606946231.out.html">next</a></br></br><pre>12d11
< -- Module      : Data.Vector.Storable.ByteString.Lazy
13d11
< -- Copyright   : (c) Don Stewart 2006
14d11
< --               (c) Duncan Coutts 2006
15d11
< --               (c) Bas van Dijk 2011
16d11
< -- License     : BSD-style
17d11
< --
18d11
< -- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
19d11
< -- Stability   : experimental
20d11
< -- Portability : portable
21d11
< --
22d11
< -- A time and space-efficient implementation of lazy byte vectors
23d11
< -- using lists of packed 'Word8' arrays, suitable for high performance
24c12
< -- use, both in terms of large data quantities, or high speed
---
> -- |-- Module      : Data.Vector.Storable.ByteString.Lazy
24a13
> -- Copyright   : (c) Don Stewart 2006-- Module      : Data.Vector.Storable.ByteString.Lazy
24a14
> -- Copyright   : (c) Don Stewart 2006--               (c) Duncan Coutts 2006
24a15
> --               (c) Bas van Dijk 2011--               (c) Duncan Coutts 2006
24a16
> -- License     : BSD-style--               (c) Bas van Dijk 2011
24a17
> ---- License     : BSD-style
24a18
> ---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
24a19
> -- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
24a20
> -- Portability : portable-- Stability   : experimental
24a21
> ---- Portability : portable
24a22
> ---- A time and space-efficient implementation of lazy byte vectors
24a23
> -- A time and space-efficient implementation of lazy byte vectors-- using lists of packed 'Word8' arrays, suitable for high performance
24a24
> -- use, both in terms of large data quantities, or high speed-- using lists of packed 'Word8' arrays, suitable for high performance
24a25
> -- use, both in terms of large data quantities, or high speed-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
26d26
< -- arrays of bytes. They provide a means to manipulate large byte vectors
27d26
< -- without requiring the entire vector be resident in memory.
28d26
< --
29d26
< -- Some operations, such as concat, append, reverse and cons, have
30d26
< -- better complexity than their "Data.ByteString" equivalents, due to
31d26
< -- optimisations resulting from the list spine structure. And for other
32d26
< -- operations lazy ByteStrings are usually within a few percent of
33d26
< -- strict ones, but with better heap usage. For data larger than the
34d26
< -- available memory, or if you have tight memory constraints, this
35d26
< -- module will be the only option. The default chunk size is 64k, which
36d26
< -- should be good in most circumstances. For people with large L2
37d26
< -- caches, you may want to increase this to fit your cache.
38d26
< --
39d26
< -- This module is intended to be imported @qualified@, to avoid name
40d26
< -- clashes with "Prelude" functions.  eg.
41d26
< --
42d26
< -- > import qualified Data.Vector.Storable.ByteString.Lazy as B
43d26
< --
44d26
< -- Original GHC implementation by Bryan O\'Sullivan.
45d26
< -- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
46d26
< -- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
47d26
< -- by David Roundy.
48d26
< -- Polished and extended by Don Stewart.
49c27
< -- Lazy variant by Duncan Coutts and Don Stewart.
---
> -- without requiring the entire vector be resident in memory.-- arrays of bytes. They provide a means to manipulate large byte vectors
49a28
> ---- without requiring the entire vector be resident in memory.
49a29
> ---- Some operations, such as concat, append, reverse and cons, have
49a30
> -- Some operations, such as concat, append, reverse and cons, have-- better complexity than their "Data.ByteString" equivalents, due to
49a31
> -- better complexity than their "Data.ByteString" equivalents, due to-- optimisations resulting from the list spine structure. And for other
49a32
> -- operations lazy ByteStrings are usually within a few percent of-- optimisations resulting from the list spine structure. And for other
49a33
> -- operations lazy ByteStrings are usually within a few percent of-- strict ones, but with better heap usage. For data larger than the
49a34
> -- available memory, or if you have tight memory constraints, this-- strict ones, but with better heap usage. For data larger than the
49a35
> -- available memory, or if you have tight memory constraints, this-- module will be the only option. The default chunk size is 64k, which
49a36
> -- should be good in most circumstances. For people with large L2-- module will be the only option. The default chunk size is 64k, which
49a37
> -- caches, you may want to increase this to fit your cache.-- should be good in most circumstances. For people with large L2
49a38
> ---- caches, you may want to increase this to fit your cache.
49a39
> ---- This module is intended to be imported @qualified@, to avoid name
49a40
> -- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
49a41
> ---- clashes with "Prelude" functions.  eg.
49a42
> ---- > import qualified Data.Vector.Storable.ByteString.Lazy as B
49a43
> ---- > import qualified Data.Vector.Storable.ByteString.Lazy as B
49a44
> ---- Original GHC implementation by Bryan O\'Sullivan.
49a45
> -- Original GHC implementation by Bryan O\'Sullivan.-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
49a46
> -- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
49a47
> -- by David Roundy.-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
49a48
> -- by David Roundy.-- Polished and extended by Don Stewart.
49a49
> -- Polished and extended by Don Stewart.-- Lazy variant by Duncan Coutts and Don Stewart.
49a50
> ---- Lazy variant by Duncan Coutts and Don Stewart.
51d51
< 
53c53
< 
---
> module Data.Vector.Storable.ByteString.Lazy (
54a55
>         ByteString-- * The @ByteString@ type,             -- instances: Eq, Ord, Show, Read, Data, Typeable
56d56
< 
58d57
<         empty,                  -- :: ByteString
59d57
<         singleton,              -- :: Word8   -> ByteString
60d57
<         pack,                   -- :: [Word8] -> ByteString
61d57
<         unpack,                 -- :: ByteString -> [Word8]
62c58
<         fromChunks,             -- :: [Strict.ByteString] -> ByteString
---
>         empty-- * Introducing and eliminating 'ByteString's,                  -- :: ByteString
62a59
>         emptysingleton,   ,              -- :: ByteString-- :: Word8   -> ByteString
62a60
>         singletonpack,    ,              -- :: Word8   -> ByteString
62a61
>         packunpack, ,                 -- :: [Word8] -> ByteString
62a62
>         unpackfromChunks,   ,             -- :: ByteString -> [Word8]-- :: [Strict.ByteString] -> ByteString
62a63
>         fromChunkstoChunks, ,             -- :: [Strict.ByteString] -> ByteString
64d64
< 
66d65
<         cons,                   -- :: Word8 -> ByteString -> ByteString
67d65
<         cons',                  -- :: Word8 -> ByteString -> ByteString
68d65
<         snoc,                   -- :: ByteString -> Word8 -> ByteString
69d65
<         append,                 -- :: ByteString -> ByteString -> ByteString
70d65
<         head,                   -- :: ByteString -> Word8
71d65
<         uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)
72c66
<         last,                   -- :: ByteString -> Word8
---
>         cons-- * Basic interface,                   -- :: Word8 -> ByteString -> ByteString
72a67
>         conscons',,                  -- :: Word8 -> ByteString -> ByteString
72a68
>         cons'snoc,,                  -- :: Word8 -> ByteString -> ByteString
72a69
>         snocappend, ,                 -- :: ByteString -> Word8 -> ByteString-- :: ByteString -> ByteString -> ByteString
72a70
>         appendhead, ,                 -- :: ByteString -> Word8-- :: ByteString -> ByteString -> ByteString
72a71
>         headuncons, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
72a72
>         unconslast, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
72a73
>         last,                   -- :: ByteString -> Word8-- :: ByteString -> ByteString
74d74
<         init,                   -- :: ByteString -> ByteString
75c75
<         null,                   -- :: ByteString -> Bool
---
>         init,                   -- :: ByteString -> Bool-- :: ByteString -> ByteString
75a76
>         nulllength, ,                 -- :: ByteString -> Bool-- :: ByteString -> Int64
77d77
< 
79d78
<         map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
80d78
<         reverse,                -- :: ByteString -> ByteString
81d78
<         intersperse,            -- :: Word8 -> ByteString -> ByteString
82c79
<         intercalate,            -- :: ByteString -> [ByteString] -> ByteString
---
>         map-- * Transforming ByteStrings,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
82a80
>         mapreverse,   ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> ByteString -> ByteString
82a81
>         reverseintersperse,   ,            -- :: ByteString -> ByteString-- :: Word8 -> ByteString -> ByteString
82a82
>         intersperse,            -- :: Word8 -> ByteString -> ByteString-- :: ByteString -> [ByteString] -> ByteString
82a83
>         intercalatetranspose, ,            -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
84d84
< 
86d85
<         foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
87d85
<         foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
88d85
<         foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
89d85
<         foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
90c86
<         foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
---
>         foldl-- * Reducing 'ByteString's (folds),                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
90a87
>         foldlfoldl',,                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
90a88
>         foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
90a89
>         foldl1foldl1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
90a90
>         foldl1'foldr, ,                -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
90a91
>         foldrfoldr1,,                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
92d92
< 
94d93
<         concat,                 -- :: [ByteString] -> ByteString
95c94
<         concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
---
>         concat-- ** Special folds,                 -- :: [ByteString] -> ByteString
95a95
>         concatconcatMap,  ,              -- :: [ByteString] -> ByteString-- :: (Word8 -> ByteString) -> ByteString -> ByteString
95a96
>         concatMapany,     ,              -- :: (Word8 -> Bool) -> ByteString -> Bool-- :: (Word8 -> ByteString) -> ByteString -> ByteString
97c98
<         all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
---
>         allmaximum,   ,                -- :: ByteString -> Word8-- :: (Word8 -> Bool) -> ByteString -> Bool
100d100
< 
102d101
<         -- ** Scans
103d101
<         scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
104d101
< --        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
105c102
< --        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
---
>         -- ** Scans-- * Building ByteStrings
105a103
>         scanl-- ** Scans,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
105a104
> --        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
105a105
> --        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
105a106
> --        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
107d107
< 
108a109
>         mapAccumL-- ** Accumulating maps,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
111d111
< 
113d112
<         repeat,                 -- :: Word8 -> ByteString
114d112
<         replicate,              -- :: Int64 -> Word8 -> ByteString
115c113
<         cycle,                  -- :: ByteString -> ByteString
---
>         repeat-- ** Infinite ByteStrings,                 -- :: Word8 -> ByteString
115a114
>         repeatreplicate,  ,              -- :: Word8 -> ByteString-- :: Int64 -> Word8 -> ByteString
115a115
>         replicatecycle,   ,              -- :: ByteString -> ByteString-- :: Int64 -> Word8 -> ByteString
115a116
>         cycleiterate, ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> Word8 -> ByteString
117d117
< 
118a119
>         unfoldr-- ** Unfolding ByteStrings,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
120d120
< 
122c122
< 
---
>         -- * Substrings
123a124
>         take-- ** Breaking strings,                   -- :: Int64 -> ByteString -> ByteString
125d125
<         drop,                   -- :: Int64 -> ByteString -> ByteString
126c126
<         splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
---
>         dropsplitAt,  ,                -- :: Int64 -> ByteString -> ByteString-- :: Int64 -> ByteString -> (ByteString, ByteString)
126a127
>         splitAttakeWhile, ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: Int64 -> ByteString -> (ByteString, ByteString)
128d128
<         dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
129d128
<         span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
130d128
<         break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
131d128
<         group,                  -- :: ByteString -> [ByteString]
132c129
<         groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
---
>         dropWhilespan,    ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
132a130
>         spanbreak,,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
132a131
>         break,                  -- :: ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
132a132
>         groupgroupBy, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
132a133
>         groupByinits, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
135d135
< 
137c137
<         split,                  -- :: Word8 -> ByteString -> [ByteString]
---
>         split-- ** Breaking into many substrings,                  -- :: Word8 -> ByteString -> [ByteString]
137a138
>         splitsplitWith,   ,              -- :: Word8 -> ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> [ByteString]
139d139
< 
140a141
>         isPrefixOf-- * Predicates,             -- :: ByteString -> ByteString -> Bool
142c143
<         isSuffixOf,             -- :: ByteString -> ByteString -> Bool
---
> --        isInfixOf,              -- :: ByteString -> ByteString -> Bool,             -- :: ByteString -> ByteString -> Bool
144d144
< 
146d145
< --        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
147c146
< --        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
---
> --        isSubstringOf,          -- :: ByteString -> ByteString -> Bool-- ** Search for arbitrary substrings
147a147
> --        isSubstringOf,          -- :: ByteString -> ByteString -> Bool--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
147a148
> --        findSubstrings,         -- :: ByteString -> ByteString -> [Int]--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
149d149
< 
151c151
< 
---
>         -- * Searching ByteStrings
153c153
<         elem,                   -- :: Word8 -> ByteString -> Bool
---
>         elem-- ** Searching by equality,                   -- :: Word8 -> ByteString -> Bool
153a154
>         elemnotElem,  ,                -- :: Word8 -> ByteString -> Bool
155d155
< 
157d156
<         find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
158c157
<         filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
---
>         find-- ** Searching with a predicate,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
158a158
>         findfilter, ,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
158a159
>         filterpartition,  ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
160d160
< 
162d161
<         index,                  -- :: ByteString -> Int64 -> Word8
163d161
<         elemIndex,              -- :: Word8 -> ByteString -> Maybe Int64
164d161
<         elemIndices,            -- :: Word8 -> ByteString -> [Int64]
165d161
<         findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
166c162
<         findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]
---
>         index-- * Indexing ByteStrings,                  -- :: ByteString -> Int64 -> Word8
166a163
>         indexelemIndex,   ,              -- :: ByteString -> Int64 -> Word8-- :: Word8 -> ByteString -> Maybe Int64
166a164
>         elemIndexelemIndices, ,            -- :: Word8 -> ByteString -> [Int64]-- :: Word8 -> ByteString -> Maybe Int64
166a165
>         elemIndicesfindIndex, ,            -- :: Word8 -> ByteString -> [Int64]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
166a166
>         findIndexfindIndices, ,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
166a167
>         findIndicescount,     ,            -- :: Word8 -> ByteString -> Int64-- :: (Word8 -> Bool) -> ByteString -> [Int64]
168d168
< 
170d169
<         zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
171c170
<         zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
---
>         zip-- * Zipping and unzipping ByteStrings,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
171a171
>         zipzipWith,   ,                -- :: ByteString -> ByteString -> [(Word8,Word8)]-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
171a172
>         zipWithunzip, ,                -- :: [(Word8,Word8)] -> (ByteString,ByteString)-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
173d173
< 
174a175
> --        sort,                   -- :: ByteString -> ByteString-- * Ordered ByteStrings
176d176
< 
178d177
<         -- ** Copying ByteStrings
179c178
<         copy,                   -- :: ByteString -> ByteString
---
>         -- ** Copying ByteStrings-- * Low level conversions
179a179
>         copy-- ** Copying ByteStrings,                   -- :: ByteString -> ByteString
179a180
> --        defrag,                -- :: ByteString -> ByteString,                   -- :: ByteString -> ByteString
181d181
< 
183c183
< 
---
>         -- * I\/O with 'ByteString's
185d184
<         getContents,            -- :: IO ByteString
186d184
<         putStr,                 -- :: ByteString -> IO ()
187c185
<         putStrLn,               -- :: ByteString -> IO ()
---
>         getContents-- ** Standard input and output,            -- :: IO ByteString
187a186
>         getContentsputStr,    ,            -- :: IO ByteString-- :: ByteString -> IO ()
187a187
>         putStrputStrLn, ,               -- :: ByteString -> IO ()
187a188
>         putStrLn,               -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
189d189
< 
191d190
<         readFile,               -- :: FilePath -> IO ByteString
192c191
<         writeFile,              -- :: FilePath -> ByteString -> IO ()
---
>         readFile-- ** Files,               -- :: FilePath -> IO ByteString
192a192
>         readFilewriteFile,,              -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
192a193
>         writeFileappendFile,,             -- :: FilePath -> ByteString -> IO ()
194d194
< 
196d195
<         hGetContents,           -- :: Handle -> IO ByteString
197d195
<         hGet,                   -- :: Handle -> Int -> IO ByteString
198d195
<         hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
199d195
<         hPut,                   -- :: Handle -> ByteString -> IO ()
200c196
<         hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
---
>         hGetContents-- ** I\/O with Handles,           -- :: Handle -> IO ByteString
200a197
>         hGetContentshGet,       ,           -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
200a198
>         hGethGetNonBlocking,          ,        -- :: Handle -> Int -> IO ByteString
200a199
>         hGetNonBlockinghPut,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
200a200
>         hPuthPutNonBlocking,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
200a201
>         hPutNonBlockinghPutStr,       ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
202d202
< 
204c204
< 
---
>   ) where
206d205
<     (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
207d205
<     ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
208d205
<     ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
209c206
<     ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
---
> import(reversePrelude,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
209a207
>     (reverseconcat,,anyhead,take,tail,drop,last,splitAt,init,null,takeWhile,length,,dropWhilemap,lines,,spanfoldl,break,foldr,elem,unlines,filter,maximum
209a208
>     ,concatminimum,any,all,take,concatMap,drop,splitAt,foldl1,takeWhilefoldr1,scanl,dropWhile, scanl1,span, scanr,break, scanr1,elem,filter,maximum
209a209
>     ,minimumrepeat,,allcycle,concatMap, interact,foldl1, iterate,foldr1,readFile,scanl,writeFile, scanr,appendFile, scanr1,replicate
209a210
>     ,repeatgetContents, cycle,getLine, interact,putStr, iterate,putStrLn,readFile,zip,,zipWithwriteFile,unzip,appendFile,notElem,replicate
211d211
< 
213d212
< import qualified Data.Vector.Storable.ByteString        as P  (ByteString) -- type name only
214d212
< import qualified Data.Vector.Storable.ByteString        as S  -- S for strict (hmm...)
215d212
< import qualified Data.Vector.Storable.ByteString.Internal as S
216c213
< import qualified Data.Vector.Storable.ByteString.Unsafe as S
---
> import qualified Data.ListData.Vector.Storable.ByteStringas L  -- L for list/lazyas P  (ByteString) -- type name only
216a214
> import qualified Data.Vector.Storable.ByteString        as P  (-- S for strict (hmm...)ByteString) -- type name only
216a215
> import qualified Data.Vector.Storable.ByteStringData.Vector.Storable.ByteString.InternalasasS S-- S for strict (hmm...)
216a216
> import qualified Data.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString.Unsafe asasS S
216a217
> import qualifiedData.Vector.Storable.ByteString.Lazy.InternalData.Vector.Storable.ByteString.Unsafe as S
218d218
< 
220c220
< 
---
> import Data.Monoid              (Monoid(..))
222c222
< import Data.Int                 (Int64)
---
> import Data.WordData.Int                 (Word8)
222a223
> import Data.IntSystem.IO                (Int64Handle),stdin,stdout,openBinaryFile,IOMode(..)
224d224
<                                 ,hClose)
225d224
< import System.IO.Error          (mkIOError, illegalOperationErrorType)
226c225
< import System.IO.Unsafe
---
> import System.IO.Error          ,hClosemkIOError)  , illegalOperationErrorType)
226a226
> import System.IO.ErrorSystem.IO.Unsafe         (mkIOError, illegalOperationErrorType)
226a227
> import System.IO.UnsafeControl.Exception        (bracket)
228d228
< 
230c230
< import Foreign.Ptr
---
> import Foreign.ForeignPtrForeign.Ptr              (withForeignPtr)
230a231
> import Foreign.PtrForeign.Storable
232d232
< 
234c234
< import qualified Data.Vector.Storable as VS
---
> import-- from vector:qualified Data.Vector.Storable as VS
234a235
> import( unsafeToForeignPtr0qualified Data.Vector.Storable, unsafeToForeignPtr0as VS    )
237d237
< 
239c239
< 
---
> -- -----------------------------------------------------------------------------
240a241
> instancewhereEq(==ByteString)    = eq
242d242
< 
243a244
> instancewhereOrdcompare= cmp
245d245
< 
247c247
<     mempty  = empty
---
> instancemempty= empty where
247a248
>     memptymappend = emptyappend
250d250
< 
252d251
< eq Empty Empty = True
253d251
< eq Empty _     = False
254d251
< eq _     Empty = False
255d251
< eq (Chunk a as) (Chunk b bs) =
256d251
<   case compare (S.length a) (S.length b) of
257d251
<     LT -> a == (S.take (S.length a) b) && eq as (Chunk (S.drop (S.length a) b) bs)
258c252
<     EQ -> a == b                       && eq as bs
---
> eq ::EmptyEmpty = ->True -> Bool
258a253
> eq Empty Empty_     = TrueFalse
258a254
> eq Empty_     _Empty = False
258a255
> eq _ChunkEmptya as)=(False b bs) =
258a256
> eqcaseChunkcompare as)((S.lengthChunk b bsa))(=S.length b) of
258a257
>   caseLT compare-> a == (S.lengthS.take (S.length) (S.lengtha) b)b)&&ofeq as (Chunk (S.drop (S.length a) b) bs)
258a258
>     LT -> a == (S.take (S.length a) b) && eq as (bsChunk (S.drop (S.length a) b) bs)
258a259
>     EQ -> aS.take b  (S.length b) a) == b && eq as(Chunk  (S.drop (S.length b) a) as) bs
260d260
< 
262d261
< cmp Empty Empty = EQ
263d261
< cmp Empty _     = LT
264d261
< cmp _     Empty = GT
265d261
< cmp (Chunk a as) (Chunk b bs) =
266d261
<   case compare (S.length a) (S.length b) of
267d261
<     LT -> case compare a (S.take (S.length a) b) of
268d261
<             EQ     -> cmp as (Chunk (S.drop (S.length a) b) bs)
269d261
<             result -> result
270d261
<     EQ -> case compare a b of
271d261
<             EQ     -> cmp as bs
272d261
<             result -> result
273d261
<     GT -> case compare (S.take (S.length b) a) b of
274c262
<             EQ     -> cmp (Chunk (S.drop (S.length b) a) as) bs
---
> cmp ::EmptyEmpty = -> ByteString -> Ordering
274a263
> cmp Empty Empty_     = EQ
274a264
> cmp Empty_     _Empty = LT
274a265
> cmp _ChunkEmptya as)=(GTChunk b bs) =
274a266
> cmpcaseChunkcompare as)S.lengthChunk babs) )S.length=       b) of
274a267
>   caseLT compare-> case (compareS.lengtha a)S.takeS.length(S.length) ofa) b) of
274a268
>     LT -> caseEQ compare-> cmp (S.takeas (ChunkS.length(S.dropa)S.length) of   a) b) bs)
274a269
>             EQresult -> cmpresult (Chunk (S.drop (S.length a) b) bs)
274a270
>     EQ -> casecompare resulta b of
274a271
>     EQ -> caseEQ compare-> cmp basofbs
274a272
>             EQresult -> cmpresult bs
274a273
>     GT -> casecompare result(S.take (S.length b) a) b of
274a274
>     GT -> caseEQ compare-> cmpS.take(ChunkS.length(S.drop b)S.length) b ofb) a) as) bs
274a275
>             EQresult -> cmpresultChunk (S.drop (S.length b) a) as) bs
276d276
< 
277a278
> -- Introducing and eliminating 'ByteString's-- -----------------------------------------------------------------------------
279d279
< 
281d280
< empty :: ByteString
282c281
< empty = Empty
---
> empty-- | /O(1)/ The empty 'ByteString':: ByteString
282a282
> empty ::= Empty
282a283
> empty{-# INLINE= Emptyempty #-}
284d284
< 
286d285
< singleton :: Word8 -> ByteString
287c286
< singleton w = Chunk (S.singleton w) Empty
---
> singleton-- | /O(1)/ Convert a 'Word8' into a 'ByteString':: Word8 -> ByteString
287a287
> singleton ::w =Word8Chunk->(S.singleton w) Empty
287a288
> singleton{-# INLINEwsingleton= Chunk (S.singleton#-}         w) Empty
289d289
< 
291d290
< pack :: [Word8] -> ByteString
292d290
< pack ws = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
293d290
<   where
294d290
<     chunks :: Int -> [a] -> [[a]]
295d290
<     chunks _    [] = []
296c291
<     chunks size xs = case L.splitAt size xs of
---
> pack-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.:: [Word8] -> ByteString
296a292
> pack :: [Word8L.foldr] ->(ByteStringChunk . S.pack) Empty (chunks defaultChunkSize ws)
296a293
> packwhere = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
296a294
>   wherechunks :: Int -> [a] -> [[a]]
296a295
>     chunks ::_  Int[]->= [a] -> [[a]]
296a296
>     chunks _size [xs] = [case]   L.splitAt size xs of
296a297
>     chunks size xs = case(xs'L.splitAt, xs'') ->sizexs' xs: chunksof    size xs''
298d298
< 
300d299
< unpack :: ByteString -> [Word8]
301c300
< unpack cs = L.concatMap S.unpack (toChunks cs)
---
> unpack-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.:: ByteString -> [Word8]
301a301
> unpack :: ByteString= L.concatMap-> [S.unpackWord8]  (toChunks cs)
301a302
> unpack--TODO: we can do better here by integrating the concat with the unpack = L.concatMap S.unpack (toChunks cs)
303d303
< 
305c305
< fromChunks :: [P.ByteString] -> ByteString
---
> fromChunks-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString':: [P.ByteString] -> ByteString
305a306
> fromChunks :: [P.ByteStringL.foldr chunk] ->Emptycs
307d307
< 
309c309
< toChunks :: ByteString -> [P.ByteString]
---
> toChunks-- | /O(n)/ Convert a lazy 'ByteString' into a list of strict 'ByteString':: ByteString -> [P.ByteString]
309a310
> toChunks :: ByteString= foldrChunks-> [P.ByteString:) [] cs    ]
311d311
< 
313c313
< 
---
> ------------------------------------------------------------------------
328d327
< 
329a329
> -- Basic interface-- ---------------------------------------------------------------------
331d330
< 
333d331
< null :: ByteString -> Bool
334d331
< null Empty = True
335c332
< null _     = False
---
> null-- | /O(1)/ Test whether a ByteString is empty.:: ByteString -> Bool
335a333
> null ::Empty= True  -> Bool
335a334
> null Empty_     = TrueFalse
335a335
> null{-# INLINE     =null#-}
337d336
< 
339d337
< length :: ByteString -> Int64
340c338
< length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
---
> length-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64':: ByteString -> Int64
340a339
> length :: ByteString= foldlChunks-> Int64(\n c -> n + fromIntegral (S.length c)) 0 cs
340a340
> length{-# INLINE =length#-}   (\n c -> n + fromIntegral (S.length c)) 0 cs
342d341
< 
344d342
< --
345d342
< cons :: Word8 -> ByteString -> ByteString
346c343
< cons c cs = Chunk (S.singleton c) cs
---
> ---- | /O(1)/ 'cons' is analogous to '(:)' for lists.
346a344
> --cons :: Word8 -> ByteString -> ByteString
346a345
> cons ::c cs= Chunk-> ByteString(S.singleton-> ByteStringc) cs
346a346
> cons{-# INLINE cs =cons#-}S.singleton c) cs
348d347
< 
349a349
> -- | /O(1)/ Unlike 'cons', 'cons\'' is-- strict in the ByteString that we are consing onto. More precisely, it forces
351d350
< -- the head and the first chunk. It does this because, for space efficiency, it
352d350
< -- may coalesce the new byte onto the first \'chunk\' rather than starting a
353d350
< -- new \'chunk\'.
354d350
< --
355d350
< -- So that means you can't use a lazy recursive contruction like this:
356d350
< --
357d350
< -- > let xs = cons\' c xs in xs
358d350
< --
359d350
< -- You can however use 'cons', as well as 'repeat' and 'cycle', to build
360d350
< -- infinite lazy ByteStrings.
361d350
< --
362d350
< cons' :: Word8 -> ByteString -> ByteString
363d350
< cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
364c351
< cons' w cs                             = Chunk (S.singleton w) cs
---
> -- may coalesce the new byte onto the first \'chunk\' rather than starting a-- the head and the first chunk. It does this because, for space efficiency, it
364a352
> -- new \'chunk\'.-- may coalesce the new byte onto the first \'chunk\' rather than starting a
364a353
> ---- new \'chunk\'.
364a354
> ---- So that means you can't use a lazy recursive contruction like this:
364a355
> ---- So that means you can't use a lazy recursive contruction like this:
364a356
> ---- > let xs = cons\' c xs in xs
364a357
> ---- > let xs = cons\' c xs in xs
364a358
> ---- You can however use 'cons', as well as 'repeat' and 'cycle', to build
364a359
> -- infinite lazy ByteStrings.-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
364a360
> ---- infinite lazy ByteStrings.
364a361
> --cons' :: Word8 -> ByteString -> ByteString
364a362
> cons' ::w (Word8 ->c cs) | S.length-> ByteStringc < 16 = Chunk (S.cons w c) cs
364a363
> cons' w (csChunk c cs) | S.length c < 16 = Chunk (S.consS.singleton c) csw) cs
364a364
> cons'{-# INLINE cs cons' #-}                   = Chunk (S.singleton w) cs
366d365
< 
368d366
< snoc :: ByteString -> Word8 -> ByteString
369c367
< snoc cs w = foldrChunks Chunk (singleton w) cs
---
> snoc-- | /O(n\/c)/ Append a byte to the end of a 'ByteString':: ByteString -> Word8 -> ByteString
369a368
> snoc :: ByteStringw = foldrChunks-> Word8Chunk->(ByteStringsingleton w) cs
369a369
> snoc{-# INLINE w =snoc#-}     Chunk (singleton w) cs
371d370
< 
373d371
< head :: ByteString -> Word8
374d371
< head Empty       = errorEmptyList "head"
375c372
< head (Chunk c _) = S.unsafeHead c
---
> head-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.:: ByteString -> Word8
375a373
> head ::Empty= ->errorEmptyList       "head"
375a374
> head Empty(Chunk c _) = errorEmptyListS.unsafeHead c "head"
375a375
> head{-# INLINEChunkhead _)#-}= S.unsafeHead c
377d376
< 
379d377
< -- if it is empty.
380d377
< uncons :: ByteString -> Maybe (Word8, ByteString)
381d377
< uncons Empty = Nothing
382d377
< uncons (Chunk c cs)
383d377
<     = Just (S.unsafeHead c,
384c378
<             if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
---
> -- if it is empty.-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
384a379
> uncons-- if it is empty.:: ByteString -> Maybe (Word8, ByteString)
384a380
> uncons ::Empty= Nothing-> Maybe (Word8, ByteString)
384a381
> uncons Empty(Chunk=cNothingcs)
384a382
> uncons= JustChunk(S.unsafeHead cs)      c,
384a383
>     = Just (S.unsafeHeadif S.length cc,== 1 then cs else Chunk (S.unsafeTail c) cs)
384a384
> {-# INLINE uncons S.length#-}   c == 1 then cs else Chunk (S.unsafeTail c) cs)
386d385
< 
388d386
< -- non-empty.
389d386
< tail :: ByteString -> ByteString
390d386
< tail Empty          = errorEmptyList "tail"
391d386
< tail (Chunk c cs)
392d386
<   | S.length c == 1 = cs
393c387
<   | otherwise       = Chunk (S.unsafeTail c) cs
---
> -- non-empty.-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
393a388
> tail-- non-empty.:: ByteString -> ByteString
393a389
> tail ::Empty ->= ByteStringerrorEmptyList "tail"
393a390
> tail Empty(Chunk c cs)   = errorEmptyList "tail"
393a391
> tail| S.lengthChunk cccs==) 1 = cs
393a392
>   | S.lengthotherwisec == 1 = csChunk (S.unsafeTail c) cs
393a393
> {-# INLINE otherwisetail #-} = Chunk (S.unsafeTail c) cs
395d394
< 
397d395
< -- and non-empty.
398d395
< last :: ByteString -> Word8
399d395
< last Empty          = errorEmptyList "last"
400d395
< last (Chunk c0 cs0) = go c0 cs0
401d395
<   where go c Empty        = S.last c
402c396
<         go _ (Chunk c cs) = go c cs
---
> -- and non-empty.-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
402a397
> last-- and non-empty.:: ByteString -> Word8
402a398
> last ::Empty ->= Word8errorEmptyList "last"
402a399
> last Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "last"
402a400
> lastwhereChunkgo cc0Empty) = go c0= cs0S.last c
402a401
>   where go c Empty(Chunk c cs) = S.lastgo c csc
402a402
> -- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet) _ (Chunk c cs) = go c cs
404d403
< 
406d404
< init :: ByteString -> ByteString
407d404
< init Empty          = errorEmptyList "init"
408d404
< init (Chunk c0 cs0) = go c0 cs0
409d404
<   where go c Empty | S.length c == 1 = Empty
410c405
<                    | otherwise       = Chunk (S.init c) Empty
---
> init-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.:: ByteString -> ByteString
410a406
> init ::Empty ->= ByteStringerrorEmptyList "init"
410a407
> init Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "init"
410a408
> initwhereChunkgo cc0Empty)|=S.length c0 cs0c == 1 = Empty
410a409
>   where go c Empty | S.lengthotherwisec == 1 = Empty (S.init c) Empty
410a410
>         go c (Chunk|c'cs)           = Chunk (S.init(go c'c)csEmpty)
412d411
< 
414d412
< append :: ByteString -> ByteString -> ByteString
415c413
< append xs ys = foldrChunks Chunk ys xs
---
> append-- | /O(n\/c)/ Append two ByteStrings:: ByteString -> ByteString -> ByteString
415a414
> append :: ByteStringys = foldrChunks-> ByteStringChunk ys->xsByteString
415a415
> append{-# INLINE ysappend= foldrChunks#-}      Chunk ys xs
417d416
< 
418a418
> -- Transformations-- ---------------------------------------------------------------------
420d419
< 
422d420
< -- element of @xs@.
423d420
< map :: (Word8 -> Word8) -> ByteString -> ByteString
424d420
< map f s = go s
425d420
<     where
426c421
<         go Empty        = Empty
---
> -- element of @xs@.-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
426a422
> map-- element of @xs@.:: (Word8 -> Word8) -> ByteString -> ByteString
426a423
> map ::f s(Word8= go s-> Word8) -> ByteString -> ByteString
426a424
> map fwhere = go s
426a425
>     wherego Empty        = Empty
426a426
>         go Empty(Chunk x xs) = Empty y ys
428d427
<             where
429d427
<                 y  = S.map f x
430c428
<                 ys = go xs
---
>             wherey  = S.map f x
430a429
>                 yys = S.mapgo xs f x
430a430
> {-# INLINE map #-} = go xs
432d431
< 
434d432
< reverse :: ByteString -> ByteString
435d432
< reverse cs0 = rev Empty cs0
436d432
<   where rev a Empty        = a
437c433
<         rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
---
> reverse-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.:: ByteString -> ByteString
437a434
> reverse ::cs0ByteString= rev Empty->cs0
437a435
> reversewhere cs0    = revEmpty cs0= a
437a436
>   where rev a Empty(Chunk c cs) = arev (Chunk (S.reverse c) a) cs
437a437
> {-# INLINEreverse (Chunk#-} cs) = rev (Chunk (S.reverse c) a) cs
439d438
< 
441d439
< -- \`intersperses\' that byte between the elements of the 'ByteString'.
442d439
< -- It is analogous to the intersperse function on Lists.
443d439
< intersperse :: Word8 -> ByteString -> ByteString
444d439
< intersperse _ Empty        = Empty
445d439
< intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
446d439
<                                    (foldrChunks (Chunk . intersperse') Empty cs)
447d439
<   where intersperse' :: P.ByteString -> P.ByteString
448d439
<         intersperse' v =
449d439
<           S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
450d439
<             poke p' w
451d439
<             S.c_intersperse (p' `plusPtr` 1) p (fromIntegral l) w
452c440
<               where
---
> -- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and-- \`intersperses\' that byte between the elements of the 'ByteString'.
452a441
> -- It is analogous to the intersperse function on Lists.-- \`intersperses\' that byte between the elements of the 'ByteString'.
452a442
> intersperse-- It is analogous to the intersperse function on Lists.:: Word8 -> ByteString -> ByteString
452a443
> intersperse ::_ Empty -> ByteString= Empty -> ByteString
452a444
> intersperse _ Empty(Chunk c cs) = Empty (S.intersperse w c)
452a445
> intersperse w (Chunk c cs) = Chunk (S.interspersefoldrChunks (Chunk c) . intersperse') Empty cs)
452a446
>   where intersperse' :: P.ByteStringfoldrChunks-> P.ByteStringChunk . intersperse') Empty cs)
452a447
>   where intersperse' ::v =P.ByteString -> P.ByteString
452a448
>         intersperse'S.unsafeCreate = (2*l) $ \p' -> withForeignPtr fp $ \p -> do
452a449
>           S.unsafeCreatepoke p' w    (2*l) $ \p' -> withForeignPtr fp $ \p -> do
452a450
>             pokeS.c_intersperse w       (p' `plusPtr` 1) p (fromIntegral l) w
452a451
>             S.c_interspersewhere         (p' `plusPtr` 1) p (fromIntegral l) w
452a452
>               where(fp, l) = VS.unsafeToForeignPtr0 v
454d453
< 
456d454
< -- 'ByteString' argument.
457d454
< transpose :: [ByteString] -> [ByteString]
458d454
< transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
459c455
<                       (L.transpose (L.map unpack css))
---
> -- 'ByteString' argument.-- | The 'transpose' function transposes the rows and columns of its
459a456
> transpose-- 'ByteString' argument.:: [ByteString] -> [ByteString]
459a457
> transpose ::css[ByteString= L.map (\]ss->->[ByteStringChunk (S.pack]   ss) Empty)
459a458
> transpose css = L.map (\L.transposess -> Chunk((L.mapS.packunpack) Emptycss))
459a459
> --TODO: make this fast(L.transpose (L.map unpack css))
461d460
< 
462a462
> -- Reducing 'ByteString's-- ---------------------------------------------------------------------
464d463
< 
466d464
< -- the left-identity of the operator), and a ByteString, reduces the
467d464
< -- ByteString using the binary operator, from left to right.
468d464
< foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
469d464
< foldl f z = go z
470d464
<   where go a Empty        = a
471c465
<         go a (Chunk c cs) = go (S.foldl f a c) cs
---
> -- the left-identity of the operator), and a ByteString, reduces the-- | 'foldl', applied to a binary operator, a starting value (typically
471a466
> -- ByteString using the binary operator, from left to right.-- the left-identity of the operator), and a ByteString, reduces the
471a467
> foldl-- ByteString using the binary operator, from left to right.:: (a -> Word8 -> a) -> a -> ByteString -> a
471a468
> foldl ::f z(a -> Word8z     -> a) -> a -> ByteString -> a
471a469
> foldlwhere zgo=agoEmpty          = a
471a470
>   where go a Empty(Chunk c cs) = ago (S.foldl f a c) cs
471a471
> {-# INLINE afoldlChunk#-}c cs) = go (S.foldl f a c) cs
473d472
< 
475d473
< foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
476d473
< foldl' f z = go z
477d473
<   where go a _ | a `seq` False = undefined
478d473
<         go a Empty        = a
479c474
<         go a (Chunk c cs) = go (S.foldl f a c) cs
---
> foldl'-- | 'foldl\'' is like 'foldl', but strict in the accumulator.:: (a -> Word8 -> a) -> a -> ByteString -> a
479a475
> foldl' ::f z(a -> Word8z     -> a) -> a -> ByteString -> a
479a476
> foldl'wherefgo = go_ |za `seq` False = undefined
479a477
>   where go a _Empty a `seq` False= a  = undefined
479a478
>         go a Empty(Chunk c cs) = ago (S.foldl f a c) cs
479a479
> {-# INLINE afoldl'Chunk#-} cs) = go (S.foldl f a c) cs
481d480
< 
483d481
< -- (typically the right-identity of the operator), and a ByteString,
484d481
< -- reduces the ByteString using the binary operator, from right to left.
485d481
< foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
486c482
< foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
---
> -- | 'foldr', applied to a binary operator, a starting value-- (typically the right-identity of the operator), and a ByteString,
486a483
> -- (typically the right-identity of the operator), and a ByteString,-- reduces the ByteString using the binary operator, from right to left.
486a484
> foldr-- reduces the ByteString using the binary operator, from right to left.:: (Word8 -> a -> a) -> a -> ByteString -> a
486a485
> foldr ::k z(Word8cs = foldrChunks-> a -> a) ->(flip ->(S.foldrk)) ->z cs
486a486
> foldr{-# INLINE z csfoldr= foldrChunks#-}       (flip (S.foldr k)) z cs
488d487
< 
490d488
< -- argument, and thus must be applied to non-empty 'ByteStrings'.
491d488
< -- This function is subject to array fusion.
492d488
< foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
493c489
< foldl1 _ Empty        = errorEmptyList "foldl1"
---
> -- | 'foldl1' is a variant of 'foldl' that has no starting value-- argument, and thus must be applied to non-empty 'ByteStrings'.
493a490
> -- This function is subject to array fusion.-- argument, and thus must be applied to non-empty 'ByteStrings'.
493a491
> foldl1-- This function is subject to array fusion.:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
493a492
> foldl1 ::_ EmptyWord8 -> Word8= errorEmptyList-> Word8) -> ByteString"foldl1"   -> Word8
493a493
> foldl1 _ Empty(Chunk c cs) = errorEmptyListfoldl f (S.unsafeHeadc) (Chunk (S.unsafeTail c) cs)
495d494
< 
497d495
< foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
498c496
< foldl1' _ Empty        = errorEmptyList "foldl1'"
---
> foldl1'-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
498a497
> foldl1' ::_ EmptyWord8 -> Word8= errorEmptyList-> Word8) -> ByteString"foldl1'"  -> Word8
498a498
> foldl1' _ Empty(Chunk c cs) = errorEmptyListfoldl' f (S.unsafeHeadc) (Chunk (S.unsafeTail c) cs)
500d499
< 
502d500
< -- and thus must be applied to non-empty 'ByteString's
503d500
< foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
504d500
< foldr1 _ Empty          = errorEmptyList "foldr1"
505d500
< foldr1 f (Chunk c0 cs0) = go c0 cs0
506c501
<   where go c Empty         = S.foldr1 f c
---
> -- and thus must be applied to non-empty 'ByteString's-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
506a502
> foldr1-- and thus must be applied to non-empty 'ByteString's:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
506a503
> foldr1 ::_ EmptyWord8 -> Word8= ->errorEmptyList) -> ByteString"foldr1" -> Word8
506a504
> foldr1 _ Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "foldr1"
506a505
> foldr1wherefgoChunkc Empty cs0) = go= c0S.foldr1   f c
506a506
>   where go c Empty(Chunk c' cs) = S.foldr1S.foldr  f cgo c' cs) c
508d507
< 
509a509
> -- Special folds-- ---------------------------------------------------------------------
511d510
< 
513d511
< concat :: [ByteString] -> ByteString
514d511
< concat css0 = to css0
515d511
<   where
516d511
<     go Empty        css = to css
517d511
<     go (Chunk c cs) css = Chunk c (go cs css)
518c512
<     to []               = Empty
---
> concat-- | /O(n)/ Concatenate a list of ByteStrings.:: [ByteString] -> ByteString
518a513
> concat ::css0ByteString= to css0] -> ByteString
518a514
> concatwherecss0 = to css0
518a515
>   wherego Empty        css = to css
518a516
>     go Empty(Chunk c cs) css = toChunkc (go cs css)
518a517
>     go (Chunk]     c cs) css = Chunk c (go cs css)
518a518
>     to []cs:css)         = Emptygo cs css
520d519
< 
522d520
< concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
523d520
< concatMap _ Empty        = Empty
524d520
< concatMap f (Chunk c0 cs0) = to c0 cs0
525d520
<   where
526d520
<     go :: ByteString -> P.ByteString -> ByteString -> ByteString
527c521
<     go Empty        c' cs' = to c' cs'
---
> concatMap-- | Map a function over a 'ByteString' and concatenate the results:: (Word8 -> ByteString) -> ByteString -> ByteString
527a522
> concatMap ::_ EmptyWord8 -> ByteString= Empty ) -> ByteString -> ByteString
527a523
> concatMap _ Empty(Chunk c0 cs0= Empty= to c0 cs0
527a524
> concatMapwhere   f (Chunk c0 cs0) = to c0 cs0
527a525
>   wherego :: ByteString -> P.ByteString -> ByteString -> ByteString
527a526
>     go ::Emptyc'->cs'= to c' cs'-> ByteString -> ByteString
527a527
>     go Empty(Chunk c cs) c' cs' = toChunk cs'c (go cs c' cs')
529d528
< 
531d529
<     to c cs | S.null c  = case cs of
532d529
<         Empty          -> Empty
533c530
<         (Chunk c' cs') -> to c' cs'
---
>     to ::c cs| S.null c ->= ByteStringcase cs of -> ByteString
533a531
>     to cEmpty | S.null c ->= caseEmptycs of
533a532
>         Empty(Chunk c' cs') -> Emptyto c' cs'
533a533
>         (Chunk| otherwise cs') ->= to c'(f cs'(S.unsafeHead c)) (S.unsafeTail c) cs
535d534
< 
537d535
< -- any element of the 'ByteString' satisfies the predicate.
538d535
< any :: (Word8 -> Bool) -> ByteString -> Bool
539d535
< any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
540c536
< {-# INLINE any #-}
---
> -- any element of the 'ByteString' satisfies the predicate.-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
540a537
> any-- any element of the 'ByteString' satisfies the predicate.:: (Word8 -> Bool) -> ByteString -> Bool
540a538
> any ::f csWord8= foldrChunks-> Bool) ->(\cByteStringrest -> S.any-> Boolf c || rest) False cs
540a539
> any{-# INLINE cs = foldrChunksany #-}     (\c rest -> S.any f c || rest) False cs
540a540
> {-# INLINE-- todo fuse #-}
542d541
< 
544d542
< -- if all elements of the 'ByteString' satisfy the predicate.
545d542
< all :: (Word8 -> Bool) -> ByteString -> Bool
546d542
< all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
547c543
< {-# INLINE all #-}
---
> -- if all elements of the 'ByteString' satisfy the predicate.-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
547a544
> all-- if all elements of the 'ByteString' satisfy the predicate.:: (Word8 -> Bool) -> ByteString -> Bool
547a545
> all ::f csWord8= foldrChunks-> Bool) ->(\cByteStringrest -> S.all-> Boolf c && rest) True cs
547a546
> all{-# INLINE cs = foldrChunksall #-}     (\c rest -> S.all f c && rest) True cs
547a547
> {-# INLINE-- todo fuse #-}
549d548
< 
551d549
< maximum :: ByteString -> Word8
552d549
< maximum Empty        = errorEmptyList "maximum"
553d549
< maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
554c550
<                                    (S.maximum c) cs
---
> maximum-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString':: ByteString -> Word8
554a551
> maximum ::Empty=->errorEmptyList        "maximum"
554a552
> maximum Empty(Chunk c cs) = errorEmptyListfoldlChunks (\n"maximum"c' -> n `max` S.maximum c')
554a553
> maximum (Chunk c cs) = foldlChunks (\S.maximumn c' -> nc`maxcs` S.maximum c')
554a554
> {-# INLINE maximum #-}             (S.maximum c) cs
556d555
< 
558d556
< minimum :: ByteString -> Word8
559d556
< minimum Empty        = errorEmptyList "minimum"
560d556
< minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
561c557
<                                      (S.minimum c) cs
---
> minimum-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString':: ByteString -> Word8
561a558
> minimum ::Empty=->errorEmptyList        "minimum"
561a559
> minimum Empty(Chunk c cs) = errorEmptyListfoldlChunks (\n"minimum"c' -> n `min` S.minimum c')
561a560
> minimum (Chunk c cs) = foldlChunks (\nS.minimum -> n `minc) `csS.minimum c')
561a561
> {-# INLINE minimum #-}               (S.minimum c) cs
563d562
< 
565d563
< -- 'foldl'; it applies a function to each element of a ByteString,
566d563
< -- passing an accumulating parameter from left to right, and returning a
567d563
< -- final value of this accumulator together with the new ByteString.
568d563
< mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
569d563
< mapAccumL f s0 cs0 = go s0 cs0
570d563
<   where
571d563
<     go s Empty        = (s, Empty)
572d563
<     go s (Chunk c cs) = (s'', Chunk c' cs')
573c564
<         where (s',  c')  = S.mapAccumL f s c
---
> -- 'foldl'; it applies a function to each element of a ByteString,-- | The 'mapAccumL' function behaves like a combination of 'map' and
573a565
> -- 'foldl'; it applies a function to each element of a ByteString,-- passing an accumulating parameter from left to right, and returning a
573a566
> -- final value of this accumulator together with the new ByteString.-- passing an accumulating parameter from left to right, and returning a
573a567
> mapAccumL-- final value of this accumulator together with the new ByteString.:: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
573a568
> mapAccumL ::f s0acccs0->= Word8go s0 ->cs0(acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
573a569
> mapAccumLwhere   f s0 cs0 = go s0 cs0
573a570
>   wherego s Empty        = (s, Empty)
573a571
>     go s Empty(Chunk c cs) = (ss'', Empty, Chunk)  c' cs')
573a572
>     go swhereChunk(s',cs)c'= (s''= S.mapAccumL, Chunk c' cs'f s)c
573a573
>         where (s's'',, c'cs')) = S.mapAccumLgo s' cs    f s c
575d574
< 
577d575
< -- 'foldr'; it applies a function to each element of a ByteString,
578d575
< -- passing an accumulating parameter from right to left, and returning a
579d575
< -- final value of this accumulator together with the new ByteString.
580d575
< mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
581d575
< mapAccumR f s0 cs0 = go s0 cs0
582d575
<   where
583d575
<     go s Empty        = (s, Empty)
584d575
<     go s (Chunk c cs) = (s'', Chunk c' cs')
585c576
<         where (s'', c') = S.mapAccumR f s' c
---
> -- 'foldr'; it applies a function to each element of a ByteString,-- | The 'mapAccumR' function behaves like a combination of 'map' and
585a577
> -- 'foldr'; it applies a function to each element of a ByteString,-- passing an accumulating parameter from right to left, and returning a
585a578
> -- final value of this accumulator together with the new ByteString.-- passing an accumulating parameter from right to left, and returning a
585a579
> mapAccumR-- final value of this accumulator together with the new ByteString.:: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
585a580
> mapAccumR ::f s0acccs0->= Word8go s0 ->cs0(acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
585a581
> mapAccumRwhere   f s0 cs0 = go s0 cs0
585a582
>   wherego s Empty        = (s, Empty)
585a583
>     go s Empty(Chunk c cs) = (ss'', Empty, Chunk)  c' cs')
585a584
>     go swhereChunk(s'' cs, )c'= (s''S.mapAccumR, Chunk c'fcs's')c
585a585
>         where (s''s',,cs') = S.mapAccumRgo s cs     f s' c
587d586
< 
588a588
> -- Building ByteStrings-- ---------------------------------------------------------------------
590d589
< 
592d590
< -- reduced values from the left. This function will fuse.
593d590
< --
594d590
< -- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
595d590
< --
596d590
< -- Note that
597d590
< --
598d590
< -- > last (scanl f z xs) == foldl f z xs.
599d590
< scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
600d590
< scanl f z = snd . foldl k (z,singleton z)
601d590
<  where
602c591
<     k (c,acc) a = let n = f c a in (n, acc `snoc` n)
---
> -- reduced values from the left. This function will fuse.-- | 'scanl' is similar to 'foldl', but returns a list of successive
602a592
> ---- reduced values from the left. This function will fuse.
602a593
> ---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
602a594
> ---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
602a595
> ---- Note that
602a596
> ---- Note that
602a597
> ---- > last (scanl f z xs) == foldl f z xs.
602a598
> scanl-- > last (scanl f z xs) == foldl f z xs.:: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
602a599
> scanl ::f z(Word8= snd ->. foldlk->(zWord8,singleton) -> Word8z)   -> ByteString -> ByteString
602a600
> scanlwheref z = snd . foldl k (z,singleton z)
602a601
>  wherek (c,acc) a = let n = f c a in (n, acc `snoc` n)
602a602
> {-# INLINE (c,accscanl) a =#-} n = f c a in (n, acc `snoc` n)
604d603
< 
605a605
> -- Unfolds and replicates-- ---------------------------------------------------------------------
607d606
< 
609d607
< -- of @f@ to @x@:
610d607
< --
611d607
< -- > iterate f x == [x, f x, f (f x), ...]
612d607
< --
613c608
< iterate :: (Word8 -> Word8) -> Word8 -> ByteString
---
> -- of @f@ to @x@:-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
613a609
> ---- of @f@ to @x@:
613a610
> ---- > iterate f x == [x, f x, f (f x), ...]
613a611
> ---- > iterate f x == [x, f x, f (f x), ...]
613a612
> --iterate :: (Word8 -> Word8) -> Word8 -> ByteString
613a613
> iterate ::f =(Word8unfoldr->(Word8\x ->)case-> Word8f x of->x'-> x' `seq` Just (x', x'))
615d614
< 
617d615
< -- element.
618d615
< --
619c616
< repeat :: Word8 -> ByteString
---
> -- element.-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
619a617
> ---- element.
619a618
> --repeat :: Word8 -> ByteString
619a619
> repeat ::w =Word8cs where-> ByteStringcs = Chunk (S.replicate smallChunkSize w) cs
621d620
< 
623d621
< -- the value of every element.
624d621
< --
625d621
< replicate :: Int64 -> Word8 -> ByteString
626d621
< replicate n w
627d621
<     | n <= 0             = Empty
628d621
<     | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
629d621
<     | r == 0             = cs -- preserve invariant
630d621
<     | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
631d621
<  where
632d621
<     c      = S.replicate smallChunkSize w
633d621
<     cs     = nChunks q
634d621
<     (q, r) = quotRem n (fromIntegral smallChunkSize)
635c622
<     nChunks 0 = Empty
---
> -- the value of every element.-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
635a623
> ---- the value of every element.
635a624
> --replicate :: Int64 -> Word8 -> ByteString
635a625
> replicate ::n wInt64 -> Word8 -> ByteString
635a626
> replicate| n <=n0w            = Empty
635a627
>     | n <=< fromIntegral           smallChunkSize= Empty      = Chunk (S.replicate (fromIntegral n) w) Empty
635a628
>     | n <==fromIntegral0           smallChunkSize= cs -- preserve invariant= Chunk (S.replicate (fromIntegral n) w) Empty
635a629
>     | rotherwise 0             = csChunk-- preserve invariant(S.unsafeTake (fromIntegral r) c) cs
635a630
>  where otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
635a631
>  wherec      = S.replicate smallChunkSize w
635a632
>     ccs     = S.replicatenChunks q   smallChunkSize w
635a633
>     cs(q, r) = nChunks q (fromIntegral smallChunkSize)
635a634
>     (nChunksq, r) =0quotRem= Emptyn (fromIntegral smallChunkSize)
635a635
>     nChunks 0 = Empty c (nChunks (m-1))
637d636
< 
639d637
< -- the infinite repetition of the original ByteString.
640d637
< --
641d637
< cycle :: ByteString -> ByteString
642c638
< cycle Empty = errorEmptyList "cycle"
---
> -- the infinite repetition of the original ByteString.-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
642a639
> ---- the infinite repetition of the original ByteString.
642a640
> --cycle :: ByteString -> ByteString
642a641
> cycle ::Empty= errorEmptyList-> ByteString"cycle"
642a642
> cycle Emptycs    = errorEmptyListcs' where cs' ="cycle"foldrChunks Chunk cs' cs
644d643
< 
646c645
< -- 'unfoldr' builds a ByteString from a seed value.  The function takes
---
> -- 'unfoldr' builds a ByteString from a seed value.  The function takes-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
646a646
> -- the element and returns 'Nothing' if it is done producing the-- 'unfoldr' builds a ByteString from a seed value.  The function takes
648d647
< -- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
649d647
< -- prepending to the ByteString and @b@ is used as the next element in a
650d647
< -- recursive call.
651d647
< unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
652d647
< unfoldr f s0 = unfoldChunk 32 s0
653d647
<   where unfoldChunk n s =
654d647
<           case S.unfoldrN n f s of
655d647
<             (c, Nothing)
656d647
<               | S.null c  -> Empty
657c648
<               | otherwise -> Chunk c Empty
---
> -- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a-- prepending to the ByteString and @b@ is used as the next element in a
657a649
> -- recursive call.-- prepending to the ByteString and @b@ is used as the next element in a
657a650
> unfoldr-- recursive call.:: (a -> Maybe (Word8, a)) -> a -> ByteString
657a651
> unfoldr ::f s0a=->unfoldChunk (Word832,s0)) -> a -> ByteString
657a652
> unfoldrwhere funfoldChunk = unfoldChunkn s =  32 s0
657a653
>   where unfoldChunkcase S.unfoldrN s = n f s of
657a654
>           case(c,S.unfoldrNNothing)  n f s of
657a655
>             (c, NothingS.null )  -> Empty
657a656
>               | S.nullotherwise  -> Empty c Empty
657a657
>             (c| otherwiseJust s')  -> Chunk c Empty(unfoldChunk (n*2) s')
659d658
< 
660a660
> -- Substrings-- ---------------------------------------------------------------------
662d661
< 
664d662
< -- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
665d662
< take :: Int64 -> ByteString -> ByteString
666d662
< take i _ | i <= 0 = Empty
667d662
< take i cs0         = take' i cs0
668d662
<   where take' 0 _            = Empty
669d662
<         take' _ Empty        = Empty
670d662
<         take' n (Chunk c cs) =
671d662
<           if n < fromIntegral (S.length c)
672c663
<             then Chunk (S.take (fromIntegral n) c) Empty
---
> -- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
672a664
> take-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.:: Int64 -> ByteString -> ByteString
672a665
> take ::i _Int64| i <=->0ByteString= Empty   -> ByteString
672a666
> take i _cs0 i <= 0 ==Emptytake' i cs0
672a667
> takewhere cs0take' 0 _  = take' i cs0= Empty
672a668
>   where take' 0 _Empty        = Empty
672a669
>         take' _ Empty(Chunk c cs) = Empty
672a670
>         take'if nn<(ChunkfromIntegral cs) =(S.length c)
672a671
>           ifthen < fromIntegralChunk (S.take(S.length(fromIntegral)   n) c) Empty
672a672
>             then Chunk (S.take(take'(fromIntegral(n - fromIntegral) c)(EmptyS.length c)) cs)
674d673
< 
676d674
< -- elements, or @[]@ if @n > 'length' xs@.
677d674
< drop  :: Int64 -> ByteString -> ByteString
678d674
< drop i p | i <= 0 = p
679d674
< drop i cs0 = drop' i cs0
680d674
<   where drop' 0 cs           = cs
681d674
<         drop' _ Empty        = Empty
682d674
<         drop' n (Chunk c cs) =
683d674
<           if n < fromIntegral (S.length c)
684c675
<             then Chunk (S.drop (fromIntegral n) c) cs
---
> -- elements, or @[]@ if @n > 'length' xs@.-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
684a676
> drop-- elements, or @[]@ if @n > 'length' xs@.:: Int64 -> ByteString -> ByteString
684a677
> drop i::p Int64| i <=->0 ByteString= p        -> ByteString
684a678
> drop i pcs0 i <=drop' =ipcs0
684a679
> dropwhere cs0drop'= drop'0 cs i cs0     = cs
684a680
>   where drop' 0 csEmpty        = csEmpty
684a681
>         drop' _ Empty(Chunk c cs) = Empty
684a682
>         drop'if nn<(ChunkfromIntegral cs) =(S.length c)
684a683
>           ifthen < fromIntegralChunk (S.drop(S.length(fromIntegral)   n) c) cs
684a684
>             then Chunk (S.dropn - fromIntegralfromIntegral(S.length) c) csc)) cs
686d685
< 
688d686
< splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
689d686
< splitAt i cs0 | i <= 0 = (Empty, cs0)
690d686
< splitAt i cs0 = splitAt' i cs0
691d686
<   where splitAt' 0 cs           = (Empty, cs)
692d686
<         splitAt' _ Empty        = (Empty, Empty)
693d686
<         splitAt' n (Chunk c cs) =
694d686
<           if n < fromIntegral (S.length c)
695d686
<             then (Chunk (S.take (fromIntegral n) c) Empty
696d686
<                  ,Chunk (S.drop (fromIntegral n) c) cs)
697c687
<             else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
---
> splitAt-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.:: Int64 -> ByteString -> (ByteString, ByteString)
697a688
> splitAt ::i cs0| i-><=ByteString0 = (Empty->, cs0ByteString)        , ByteString)
697a689
> splitAt i cs0 | isplitAt' 0 = (Emptycs0 , cs0)
697a690
> splitAtwhere isplitAt' = splitAt'0 cs    i cs0  = (Empty, cs)
697a691
>   where splitAt' 0 csEmpty        = (Empty, csEmpty)  )
697a692
>         splitAt' _ Empty(Chunk c cs) = (Empty, Empty)
697a693
>         splitAt'if n < nfromIntegralChunk c cs)S.length=       c)
697a694
>           ifthen < fromIntegral(Chunk (S.takeS.length(fromIntegral)    n) c) Empty
697a695
>             then (Chunk (S.take (fromIntegral n) c) Emptycs)
697a696
>             else ,letChunk(cs'S.drop, cs'')(fromIntegral= splitAt' (nn) cfromIntegral) cs)       (S.length c)) cs
697a697
>             else letin(cs'(Chunk, cs''c )cs'=,splitAt'cs'')   (n - fromIntegral (S.length c)) cs
700d699
< 
702d700
< -- returns the longest prefix (possibly empty) of @xs@ of elements that
703d700
< -- satisfy @p@.
704d700
< takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
705d700
< takeWhile f cs0 = takeWhile' cs0
706d700
<   where takeWhile' Empty        = Empty
707d700
<         takeWhile' (Chunk c cs) =
708d700
<           case findIndexOrEnd (not . f) c of
709d700
<             0                  -> Empty
710c701
<             n | n < S.length c -> Chunk (S.take n c) Empty
---
> -- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,-- returns the longest prefix (possibly empty) of @xs@ of elements that
710a702
> -- satisfy @p@.-- returns the longest prefix (possibly empty) of @xs@ of elements that
710a703
> takeWhile-- satisfy @p@.:: (Word8 -> Bool) -> ByteString -> ByteString
710a704
> takeWhile ::f cs0Word8= takeWhile'-> Bool) ->cs0ByteString -> ByteString
710a705
> takeWhilewhere takeWhile' cs0 = takeWhile'Empty     cs0= Empty
710a706
>   where takeWhile' Empty(Chunk c cs) = Empty
710a707
>         takeWhile'case findIndexOrEndChunk c cs)not=  . f) c of
710a708
>           case0  findIndexOrEnd (not-> Empty f) c of
710a709
>             0 | n < S.length c -> Empty (S.take n c) Empty
710a710
>             n | notherwise S.length c -> Chunk (S.take(takeWhile' c) Emptycs)
712d711
< 
714d712
< dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
715d712
< dropWhile f cs0 = dropWhile' cs0
716d712
<   where dropWhile' Empty        = Empty
717d712
<         dropWhile' (Chunk c cs) =
718d712
<           case findIndexOrEnd (not . f) c of
719c713
<             n | n < S.length c -> Chunk (S.drop n c) cs
---
> dropWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.:: (Word8 -> Bool) -> ByteString -> ByteString
719a714
> dropWhile ::f cs0Word8= dropWhile'-> Bool) ->cs0ByteString -> ByteString
719a715
> dropWhilewhere dropWhile' cs0 = dropWhile'Empty     cs0= Empty
719a716
>   where dropWhile' Empty(Chunk c cs) = Empty
719a717
>         dropWhile'case findIndexOrEndChunk c cs)not=  . f) c of
719a718
>           casen |findIndexOrEndn < S.length c(not-> Chunk f) cS.dropof    n c) cs
719a719
>             n | notherwise S.length c -> ChunkdropWhile'S.dropcs n c) cs
721d720
< 
723d721
< break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
724d721
< break f cs0 = break' cs0
725d721
<   where break' Empty        = (Empty, Empty)
726d721
<         break' (Chunk c cs) =
727d721
<           case findIndexOrEnd f c of
728d721
<             0                  -> (Empty, Chunk c cs)
729d721
<             n | n < S.length c -> (Chunk (S.take n c) Empty
730d721
<                                   ,Chunk (S.drop n c) cs)
731c722
<               | otherwise      -> let (cs', cs'') = break' cs
---
> break-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
731a723
> break ::f cs0Word8= break'-> Boolcs0) -> ByteString -> (ByteString, ByteString)
731a724
> breakwhere cs0break'= break'Empty cs0    = (Empty, Empty)
731a725
>   where break' Empty(Chunk c cs) = (Empty, Empty)
731a726
>         break'case (findIndexOrEndChunk c cs) = f c of
731a727
>           case0  findIndexOrEnd f-> of(Empty, Chunk c cs)
731a728
>             0 | n < S.length c -> (Empty,(ChunkS.takecncsc) Empty
731a729
>             n | n < S.length c -> (Chunk (S.take n c) Emptycs)
731a730
>               | otherwise      -> ,letChunk(cs'S.drop, cs'')n=c)break')  cs
731a731
>               | otherwise      -> letin (cs'Chunk, cs''c cs') = break'cs'')  cs
733d732
< 
735d733
< -- TODO
736d733
< --
737c734
< -- Add rules
---
> ---- TODO
737a735
> ---- TODO
737a736
> ---- Add rules
737a737
> ---- Add rules
739d738
< 
773d771
< 
775d772
< -- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
776c773
< span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
---
> -- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@-- | 'span' @p xs@ breaks the ByteString into two segments. It is
776a774
> span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
776a775
> span ::p =(Word8 ->(not. ))-> ByteString -> (ByteString, ByteString)
778d776
< 
779a778
> -- | /O(n)/ Splits a 'ByteString' into components delimited by-- separators, where the predicate returns True for a separator element.
781d779
< -- The resulting components do not contain the separators.  Two adjacent
782d779
< -- separators result in an empty component in the output.  eg.
783d779
< --
784d779
< -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
785d779
< -- > splitWith (=='a') []        == []
786d779
< --
787d779
< splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
788c780
< splitWith _ Empty          = []
---
> -- separators result in an empty component in the output.  eg.-- The resulting components do not contain the separators.  Two adjacent
788a781
> ---- separators result in an empty component in the output.  eg.
788a782
> ---- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
788a783
> -- > splitWith (=='a') []        == []-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
788a784
> ---- > splitWith (=='a') []        == []
788a785
> --splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
788a786
> splitWith ::_ EmptyWord8 -> Bool) ->[] ByteString -> [ByteString]
788a787
> splitWith _ Empty(Chunk c0 cs0) = [comb]   [] (S.splitWith p c0) cs0
790d788
< 
792d789
<         comb acc (s:[]) Empty        = revChunks (s:acc) : []
793c790
<         comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
---
>   where comb ::acc[P.ByteString(s:[]) Empty] -> [P.ByteString= revChunks] ->(s:ByteStringacc) : []  -> [ByteString]
793a791
>         comb acc (s:[]) Empty(Chunk c cs) = revChunkscomb (s:accs:acc(S.splitWith) : []    p c) cs
793a792
>         comb acc (s:[ss]) (csChunk c cs) = combrevChunkss:acc():(accS.splitWith) : comb [p css) cs
795d793
< 
797c795
< 
---
> {-# INLINE splitWith #-}
799d796
< -- argument, consuming the delimiter. I.e.
800d796
< --
801d796
< -- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
802d796
< -- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
803d796
< -- > split 'x'  "x"          == ["",""]
804d796
< --
805d796
< -- and
806d796
< --
807d796
< -- > intercalate [c] . split c == id
808d796
< -- > split == splitWith . (==)
809c797
< --
---
> -- argument, consuming the delimiter. I.e.-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
809a798
> ---- argument, consuming the delimiter. I.e.
809a799
> ---- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
809a800
> -- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
809a801
> -- > split 'x'  "x"          == ["",""]-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
809a802
> ---- > split 'x'  "x"          == ["",""]
809a803
> ---- and
809a804
> ---- and
809a805
> ---- > intercalate [c] . split c == id
809a806
> -- > split == splitWith . (==)-- > intercalate [c] . split c == id
809a807
> ---- > split == splitWith . (==)
809a808
> ---- As for all splitting functions in this library, this function does
811d809
< -- not copy the substrings, it just constructs new 'ByteStrings' that
812d809
< -- are slices of the original.
813d809
< --
814d809
< split :: Word8 -> ByteString -> [ByteString]
815c810
< split _ Empty     = []
---
> -- are slices of the original.-- not copy the substrings, it just constructs new 'ByteStrings' that
815a811
> ---- are slices of the original.
815a812
> --split :: Word8 -> ByteString -> [ByteString]
815a813
> split ::_ Empty -> ByteString= []       -> [ByteString]
815a814
> split _ Empty(Chunk c0 =cs0] = comb [] (S.split w c0) cs0
817d815
< 
819d816
<         comb acc (s:[]) Empty        = revChunks (s:acc) : []
820d816
<         comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
821c817
<         comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
---
>   where comb ::acc[P.ByteString(s:[]) Empty] -> [P.ByteString= revChunks] ->(s:ByteStringacc) : []  -> [ByteString]
821a818
>         comb acc (s:[]) Empty(Chunk c cs) = revChunkscomb (s:accs:acc(S.split) : []w c) cs
821a819
>         comb acc (s:[ss]) (csChunk c cs) = combrevChunkss:acc():(accS.split) : comb c)]csss cs
821a820
> {-# INLINEsplit (#-}s:ss) cs           = revChunks (s:acc) : comb [] ss cs
823d821
< 
833d830
< 
835d831
< -- ByteStrings such that the concatenation of the result is equal to the
836d831
< -- argument.  Moreover, each sublist in the result contains only equal
837d831
< -- elements.  For example,
838d831
< --
839d831
< -- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
840d831
< --
841d831
< -- It is a special case of 'groupBy', which allows the programmer to
842d831
< -- supply their own equality test.
843d831
< group :: ByteString -> [ByteString]
844d831
< group Empty          = []
845d831
< group (Chunk c0 cs0) = group' [] (S.group c0) cs0
846d831
<   where
847d831
<     group' :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
848d831
<     group' acc@(s':_) ss@(s:_) cs
849d831
<       | S.unsafeHead s'
850d831
<      /= S.unsafeHead s             = revNonEmptyChunks    acc  : group' [] ss cs
851d831
<     group' acc (s:[]) Empty        = revNonEmptyChunks (s:acc) : []
852c832
<     group' acc (s:[]) (Chunk c cs) = group' (s:acc) (S.group c) cs
---
> -- | The 'group' function takes a ByteString and returns a list of-- ByteStrings such that the concatenation of the result is equal to the
852a833
> -- argument.  Moreover, each sublist in the result contains only equal-- ByteStrings such that the concatenation of the result is equal to the
852a834
> -- elements.  For example,-- argument.  Moreover, each sublist in the result contains only equal
852a835
> ---- elements.  For example,
852a836
> ---- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
852a837
> ---- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
852a838
> ---- It is a special case of 'groupBy', which allows the programmer to
852a839
> -- supply their own equality test.-- It is a special case of 'groupBy', which allows the programmer to
852a840
> group-- supply their own equality test.:: ByteString -> [ByteString]
852a841
> group ::Empty ->= [ByteString]         ]
852a842
> group Empty(Chunk c0 cs0) = [group']     [] (S.group c0) cs0
852a843
> groupwhereChunk c0 cs0) = group' [] (S.group c0) cs0
852a844
>   wheregroup' :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
852a845
>     group' ::acc[P.ByteString(s':_) ss@(s]_->) csP.ByteString] -> ByteString -> [ByteString]
852a846
>     group'| S.unsafeHead@(s':_)s'@(s:_) cs
852a847
>      /= S.unsafeHead s's             = revNonEmptyChunks    acc  : group' [] ss cs
852a848
>     group' S.unsafeHeadacc (s:[])sEmpty        = revNonEmptyChunks (s:acc) : group'[]     [] ss cs
852a849
>     group' acc (s:[]) Empty(Chunk c cs) = revNonEmptyChunksgroup' (s:acc) (S.groups:acc)):cs]
852a850
>     group' acc (s:[ss]) (csChunk c cs) = group'revNonEmptyChunkss:acc) (S.group(s:accc):csgroup' [] ss cs
854d851
< 
865d861
< 
867d862
< --
868d862
< groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
869d862
< groupBy _ Empty          = []
870d862
< groupBy k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
871d862
<   where
872d862
<     groupBy' :: [P.ByteString] -> Word8 -> [P.ByteString] -> ByteString -> [ByteString]
873d862
<     groupBy' acc@(_:_) c ss@(s:_) cs
874d862
<       | not (c `k` S.unsafeHead s)     = revNonEmptyChunks acc : groupBy' [] 0 ss cs
875d862
<     groupBy' acc _ (s:[]) Empty        = revNonEmptyChunks (s : acc) : []
876d862
<     groupBy' acc w (s:[]) (Chunk c cs) = groupBy' (s:acc) w' (S.groupBy k c) cs
877d862
<                                            where w' | L.null acc = S.unsafeHead s
878c863
<                                                     | otherwise  = w
---
> ---- | The 'groupBy' function is the non-overloaded version of 'group'.
878a864
> --groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
878a865
> groupBy ::_ EmptyWord8 -> Word8= ->[] Bool) -> ByteString -> [ByteString]
878a866
> groupBy _ Empty(Chunk c0 cs0) = [groupBy']       [] 0 (S.groupBy k c0) cs0
878a867
> groupBywhere k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
878a868
>   wheregroupBy' :: [P.ByteString] -> Word8 -> [P.ByteString] -> ByteString -> [ByteString]
878a869
>     groupBy' ::acc[P.ByteString(_:_) c ss@(]:->_) Word8cs    -> [P.ByteString] -> ByteString -> [ByteString]
878a870
>     groupBy'| not (accc `@(_:S.unsafeHead_) c ss@(s:_))cs   = revNonEmptyChunks acc : groupBy' [] 0 ss cs
878a871
>     groupBy' not (cacck` S.unsafeHead(s:[]) Empty s)     = revNonEmptyChunks acc(s ::acc) : [] [] 0 ss cs
878a872
>     groupBy' acc _ (s:[]) Empty(Chunk c cs) = revNonEmptyChunksgroupBy' (s:acc) w's(:S.groupBy) : [] c) cs
878a873
>     groupBy' acc w (s:[]) (Chunk c cs) = groupBy'where w's:accL.null) w' (accS.groupBy= S.unsafeHead c) cs s
878a874
>                                            where w' | L.nullotherwise = S.unsafeHeadw            s
878a875
>     groupBy' acc _ (s:ss) cs           = revNonEmptyChunks otherwise(s : acc= w : groupBy' [] 0 ss cs
880d876
< 
891d886
< 
893d887
< -- 'ByteString's and concatenates the list after interspersing the first
894d887
< -- argument between each element of the list.
895c888
< intercalate :: ByteString -> [ByteString] -> ByteString
---
> -- 'ByteString's and concatenates the list after interspersing the first-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
895a889
> -- argument between each element of the list.-- 'ByteString's and concatenates the list after interspersing the first
895a890
> intercalate-- argument between each element of the list.:: ByteString -> [ByteString] -> ByteString
895a891
> intercalate ::s =ByteStringconcat . (->L.intersperseByteString])-> ByteString
897d892
< 
898a894
> -- Indexing ByteStrings-- ---------------------------------------------------------------------
900d895
< 
902d896
< index :: ByteString -> Int64 -> Word8
903d896
< index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
904d896
< index cs0 i         = index' cs0 i
905d896
<   where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
906d896
<         index' (Chunk c cs) n
907d896
<           | n >= fromIntegral (S.length c) =
908c897
<               index' cs (n - fromIntegral (S.length c))
---
> index-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.:: ByteString -> Int64 -> Word8
908a898
> index ::_  ByteStringi | i < 0  ->= moduleError -> Word8"index" ("negative index: " ++ show i)
908a899
> index _cs0ii| i < 0  = moduleErrorindex' cs0 i"index" ("negative index: " ++ show i)
908a900
> indexwhereindex'    Empty= index'n = cs0moduleError       "index" ("index too large: " ++ show n)
908a901
>   where index' Empty(Chunk c cs)=nmoduleError "index" ("index too large: " ++ show n)
908a902
>         index'| n >=ChunkfromIntegral cs) n (S.length c) =
908a903
>           | n >=index'cs (n - fromIntegralS.length c)(=S.length c))
908a904
>           | otherwise cs (n -=fromIntegralS.unsafeIndexS.lengthc (fromIntegral))     n)
910d905
< 
912d906
< -- element in the given 'ByteString' which is equal to the query
913d906
< -- element, or 'Nothing' if there is no such element.
914d906
< -- This implementation uses memchr(3).
915d906
< elemIndex :: Word8 -> ByteString -> Maybe Int64
916d906
< elemIndex w cs0 = elemIndex' 0 cs0
917d906
<   where elemIndex' _ Empty        = Nothing
918d906
<         elemIndex' n (Chunk c cs) =
919d906
<           case S.elemIndex w c of
920c907
<             Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
---
> -- element in the given 'ByteString' which is equal to the query-- | /O(n)/ The 'elemIndex' function returns the index of the first
920a908
> -- element, or 'Nothing' if there is no such element.-- element in the given 'ByteString' which is equal to the query
920a909
> -- This implementation uses memchr(3).-- element, or 'Nothing' if there is no such element.
920a910
> elemIndex-- This implementation uses memchr(3).:: Word8 -> ByteString -> Maybe Int64
920a911
> elemIndex ::w cs0= elemIndex'-> ByteString0 cs0-> Maybe Int64
920a912
> elemIndexwhere elemIndex' cs0 = elemIndex'_ Empty   0 cs0= Nothing
920a913
>   where elemIndex' _ Empty(Chunk c cs) = Nothing
920a914
>         elemIndex'case S.elemIndex (Chunkwcccsof) =
920a915
>           caseNothing-> elemIndex' c of (n + fromIntegral (S.length c)) cs
920a916
>             NothingJust i  -> elemIndex'Just (n + fromIntegraln + fromIntegrali)    (S.length c)) cs
922d917
< 
941d935
< -}
942d935
< -- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
943d935
< -- the indices of all elements equal to the query element, in ascending order.
944d935
< -- This implementation uses memchr(3).
945d935
< elemIndices :: Word8 -> ByteString -> [Int64]
946d935
< elemIndices w cs0 = elemIndices' 0 cs0
947d935
<   where elemIndices' _ Empty        = []
948c936
<         elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
---
> -}-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
948a937
> -- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning-- the indices of all elements equal to the query element, in ascending order.
948a938
> -- This implementation uses memchr(3).-- the indices of all elements equal to the query element, in ascending order.
948a939
> elemIndices-- This implementation uses memchr(3).:: Word8 -> ByteString -> [Int64]
948a940
> elemIndices ::w cs0= elemIndices'-> ByteString0 ->cs0[Int64]
948a941
> elemIndiceswhere elemIndices' cs0 = elemIndices'_ Empty     0 cs0= []
948a942
>   where elemIndices' _ Empty(Chunk c cs) = [L.map]    ((+n).fromIntegral) (S.elemIndices w c)
948a943
>         elemIndices' n (Chunk++ cselemIndices') = L.map ((+n).fromIntegral)((S.lengthS.elemIndicesc)) csw c)
950d944
< 
952d945
< --
953d945
< -- > count = length . elemIndices
954d945
< --
955d945
< -- But more efficiently than using length on the intermediate list.
956c946
< count :: Word8 -> ByteString -> Int64
---
> ---- | count returns the number of times its argument appears in the ByteString
956a947
> ---- > count = length . elemIndices
956a948
> ---- > count = length . elemIndices
956a949
> ---- But more efficiently than using length on the intermediate list.
956a950
> count-- But more efficiently than using length on the intermediate list.:: Word8 -> ByteString -> Int64
956a951
> count ::w cs= foldlChunks-> ByteString(\n ->c ->n + fromIntegral (S.count w c)) 0 cs
958d952
< 
960d953
< -- returns the index of the first element in the ByteString
961d953
< -- satisfying the predicate.
962d953
< findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
963d953
< findIndex k cs0 = findIndex' 0 cs0
964d953
<   where findIndex' _ Empty        = Nothing
965d953
<         findIndex' n (Chunk c cs) =
966d953
<           case S.findIndex k c of
967d953
<             Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
968c954
<             Just i  -> Just (n + fromIntegral i)
---
> -- returns the index of the first element in the ByteString-- | The 'findIndex' function takes a predicate and a 'ByteString' and
968a955
> -- satisfying the predicate.-- returns the index of the first element in the ByteString
968a956
> findIndex-- satisfying the predicate.:: (Word8 -> Bool) -> ByteString -> Maybe Int64
968a957
> findIndex ::k cs0Word8= findIndex'-> Bool) ->0 cs0 -> Maybe Int64
968a958
> findIndexwhere findIndex' cs0 = findIndex'_ Empty   0 cs0= Nothing
968a959
>   where findIndex' _ Empty(Chunk c cs) = Nothing
968a960
>         findIndex'case S.findIndex (Chunkkcccsof) =
968a961
>           caseNothing-> findIndex' c of (n + fromIntegral (S.length c)) cs
968a962
>             NothingJust i  -> findIndex'Just (n + fromIntegraln + fromIntegrali)    (S.length c)) cs
968a963
> {-# INLINE findIndex i  ->#-} (n + fromIntegral i)
970d964
< 
972d965
< -- and returns the first element in matching the predicate, or 'Nothing'
973d965
< -- if there is no such element.
974d965
< --
975d965
< -- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
976d965
< --
977d965
< find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
978d965
< find f cs0 = find' cs0
979d965
<   where find' Empty        = Nothing
980d965
<         find' (Chunk c cs) = case S.find f c of
981d965
<             Nothing -> find' cs
982c966
<             Just w  -> Just w
---
> -- | /O(n)/ The 'find' function takes a predicate and a ByteString,-- and returns the first element in matching the predicate, or 'Nothing'
982a967
> -- if there is no such element.-- and returns the first element in matching the predicate, or 'Nothing'
982a968
> ---- if there is no such element.
982a969
> ---- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
982a970
> ---- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
982a971
> --find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
982a972
> find ::f cs0Word8= find'-> Boolcs0) -> ByteString -> Maybe Word8
982a973
> findwhere cs0find'= find'Emptycs0     = Nothing
982a974
>   where find' Empty(Chunk c cs) = Nothingcase S.find f c of
982a975
>         find'NothingChunk-> csfind') = casecs   S.find f c of
982a976
>             NothingJust w  -> find'Just wcs
982a977
> {-# INLINE find#-}  -> Just w
984d978
< 
986d979
< -- indices of all elements satisfying the predicate, in ascending order.
987d979
< findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
988d979
< findIndices k cs0 = findIndices' 0 cs0
989d979
<   where findIndices' _ Empty        = []
990c980
<         findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
---
> -- | The 'findIndices' function extends 'findIndex', by returning the-- indices of all elements satisfying the predicate, in ascending order.
990a981
> findIndices-- indices of all elements satisfying the predicate, in ascending order.:: (Word8 -> Bool) -> ByteString -> [Int64]
990a982
> findIndices ::k cs0Word8= findIndices'-> Bool) ->0ByteStringcs0       -> [Int64]
990a983
> findIndiceswhere findIndices' cs0 = findIndices'_ Empty     0 cs0= []
990a984
>   where findIndices' _ Empty(Chunk c cs) = [L.map]    ((+n).fromIntegral) (S.findIndices k c)
990a985
>         findIndices' n (Chunk++ csfindIndices') = L.map ((+n).fromIntegral)((S.lengthS.findIndicesc)) csk c)
992d986
< 
993a988
> -- Searching ByteStrings-- ---------------------------------------------------------------------
995d989
< 
997c991
< elem :: Word8 -> ByteString -> Bool
---
> elem-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.:: Word8 -> ByteString -> Bool
997a992
> elem ::w cs= case-> ByteStringelemIndex w->csBoolof Nothing -> False ; _ -> True
999d993
< 
1001c995
< notElem :: Word8 -> ByteString -> Bool
---
> notElem-- | /O(n)/ 'notElem' is the inverse of 'elem':: Word8 -> ByteString -> Bool
1001a996
> notElem ::w cs= not->(ByteStringelem w cs) -> Bool
1003d997
< 
1005d998
< -- returns a ByteString containing those characters that satisfy the
1006d998
< -- predicate.
1007d998
< filter :: (Word8 -> Bool) -> ByteString -> ByteString
1008d998
< filter p s = go s
1009d998
<     where
1010d998
<         go Empty        = Empty
1011c999
<         go (Chunk x xs) = chunk (S.filter p x) (go xs)
---
> -- | /O(n)/ 'filter', applied to a predicate and a ByteString,-- returns a ByteString containing those characters that satisfy the
1011a1000
> -- predicate.-- returns a ByteString containing those characters that satisfy the
1011a1001
> filter-- predicate.:: (Word8 -> Bool) -> ByteString -> ByteString
1011a1002
> filter ::p s(Word8= go s-> Bool) -> ByteString -> ByteString
1011a1003
> filterwhere s = go s
1011a1004
>     wherego Empty        = Empty
1011a1005
>         go Empty(Chunk x xs) = Empty (S.filter p x) (go xs)
1011a1006
> {-# INLINE (filterChunk x#-}) = chunk (S.filter p x) (go xs)
1013d1007
< 
1034d1027
< -}
1035d1027
< 
1036c1028
< {-
---
> -}{-
1046d1037
< -}
1047d1037
< 
1048c1038
< -- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
---
> -}-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1050d1039
< -- predicate, respectively; i.e.,
1051d1039
< --
1052c1040
< -- > partition p bs == (filter p xs, filter (not . p) xs)
---
> -- predicate, respectively; i.e.,-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1052a1041
> ---- the pair of ByteStrings with elements which do and do not satisfy the
1052a1042
> -- predicate, respectively; i.e.,-- > partition p bs == (filter p xs, filter (not . p) xs)
1054c1044
< partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
---
> partition-- > partition p bs == (filter p xs, filter (not . p) xs):: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1054a1045
> --partition f p = (filter f p, filter (not . f) p)
1054a1046
> partition--TODO: use a better implementation:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1056d1047
< --TODO: use a better implementation
1057d1047
< 
1058c1048
< -- ---------------------------------------------------------------------
---
> --TODO: use a better implementation-- ---------------------------------------------------------------------
1060d1049
< 
1061c1050
< -- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
---
> -- ---------------------------------------------------------------------
1061a1051
> -- Searching for substrings-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
1063d1052
< isPrefixOf :: ByteString -> ByteString -> Bool
1064d1052
< isPrefixOf Empty _  = True
1065d1052
< isPrefixOf _ Empty  = False
1066d1052
< isPrefixOf (Chunk x xs) (Chunk y ys)
1067d1052
<     | S.length x == S.length y = x == y  && isPrefixOf xs ys
1068d1052
<     | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
1069c1053
<     | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
---
> isPrefixOf-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True':: ByteString -> ByteString -> Bool
1069a1054
> isPrefixOf-- iff the first is a prefix of the second.Empty _  = True
1069a1055
> isPrefixOf ::_ Empty= False-> ByteString -> Bool
1069a1056
> isPrefixOf Empty(Chunk_x =xsTrue) (Chunk y ys)
1069a1057
> isPrefixOf| S.length Emptyx == =S.length  y = x == y  && isPrefixOf xs ys
1069a1058
> isPrefixOf| S.lengthChunkx <x xsS.length) (Chunky y ysx )== yh && isPrefixOf xs (Chunk yt ys)
1069a1059
>     | S.lengthotherwisex == S.length y = xxh====yy && isPrefixOf xs(Chunk  xt xs) ys
1069a1060
>   where S.length(xh,xt)x=<S.splitAt(yS.length= x == yhy) &&x  isPrefixOf xs (Chunk yt ys)
1069a1061
>     | otherwise(yh,yt) = S.splitAt (S.length= xh ==xy &&y  isPrefixOf (Chunk xt xs) ys
1071d1062
<         (yh,yt) = S.splitAt (S.length x) y
1072d1062
< 
1073c1063
< -- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
---
> -- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'yh,yt) = S.splitAt (S.length x) y
1075d1064
< --
1076c1065
< -- The following holds:
---
> ---- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
1076a1066
> -- The following holds:-- iff the first is a suffix of the second.
1078c1068
< -- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
---
> -- The following holds:-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
1080c1070
< isSuffixOf :: ByteString -> ByteString -> Bool
---
> isSuffixOf-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y:: ByteString -> ByteString -> Bool
1080a1071
> --isSuffixOf x y = reverse x `isPrefixOf` reverse y
1080a1072
> isSuffixOf--TODO: a better implementation:: ByteString -> ByteString -> Bool
1082d1073
< --TODO: a better implementation
1083d1073
< 
1084c1074
< -- ---------------------------------------------------------------------
---
> --TODO: a better implementation-- ---------------------------------------------------------------------
1086d1075
< 
1087c1076
< -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
---
> -- ---------------------------------------------------------------------
1087a1077
> -- Zipping-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
1089d1078
< -- excess elements of the longer ByteString are discarded. This is
1090c1079
< -- equivalent to a pair of 'unpack' operations.
---
> -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- excess elements of the longer ByteString are discarded. This is
1090a1080
> -- equivalent to a pair of 'unpack' operations.-- corresponding pairs of bytes. If one input ByteString is short,
1090a1081
> zip-- excess elements of the longer ByteString are discarded. This is:: ByteString -> ByteString -> [(Word8,Word8)]
1090a1082
> zip-- equivalent to a pair of 'unpack' operations.= zipWith (,)
1092d1083
< zip = zipWith (,)
1093d1083
< 
1094c1084
< -- | 'zipWith' generalises 'zip' by zipping with the function given as
---
> zip-- | 'zipWith' generalises 'zip' by zipping with the function given as= zipWith (,)
1096d1085
< -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1097d1085
< -- corresponding sums.
1098d1085
< zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
1099d1085
< zipWith _ Empty     _  = []
1100d1085
< zipWith _ _      Empty = []
1101d1085
< zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
1102c1086
<   where
---
> -- | 'zipWith' generalises 'zip' by zipping with the function given as-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1102a1087
> -- corresponding sums.-- the first argument, instead of a tupling function.  For example,
1102a1088
> zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of:: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
1102a1089
> zipWith-- corresponding sums._ Empty     _  = []
1102a1090
> zipWith ::_ _(Word8Empty-> Word8= []-> a) -> ByteString -> ByteString -> [a]
1102a1091
> zipWith _ Empty(Chunk a as) =Chunk]   b bs) = go a as b bs
1102a1092
> zipWithwhere _ _      Empty = []
1102a1093
> zipWithgo xfxsChunky ys a asf )S.unsafeHeadChunk b bs)x= go(S.unsafeHead as b bs  y)
1102a1094
>   where          : to (S.unsafeTail x) xs (S.unsafeTail y) ys
1104d1095
<                  : to (S.unsafeTail x) xs (S.unsafeTail y) ys
1105d1095
< 
1106c1096
<     to x Empty         _ _             | S.null x       = []
---
>     to x Empty   : to (S.unsafeTail_ _          x) xs| S.nullS.unsafeTailx       y)[ys]
1108d1097
<     to x xs            y ys            | not (S.null x)
1109d1097
<                                       && not (S.null y) = go x  xs y  ys
1110c1098
<     to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
---
>     to x Emptyxs            _ _ys            | S.nullnot (S.null    x) = []
1110a1099
>     to _ _             y Empty        && S.nullnot (S.null    y) = [go] x  xs y  ys
1110a1100
>     to x xs            y ys(Chunk y' ys) | not (S.null x) = go x  xs y' ys
1110a1101
>     to _ (Chunk x' xs) y ys           &&| not (S.null y) = go xx' xs y  ys
1110a1102
>     to x xs(Chunk x' xs) _ (Chunk y' ys) | not (S.null x) = go xx' xs y' ys
1112d1103
<     to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
1113d1103
< 
1114c1104
< -- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
---
> -- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
1116c1106
< unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
---
> unzip-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of:: [(Word8,Word8)] -> (ByteString,ByteString)
1116a1107
> unzip-- ByteStrings. Note that this performs two 'pack' operations.ls = (pack (L.map fst ls), pack (L.map snd ls))
1116a1108
> unzip{-# INLINE:: [(Word8,Word8#-}  )] -> (ByteString,ByteString)
1118d1109
< {-# INLINE unzip #-}
1119d1109
< 
1120c1110
< -- ---------------------------------------------------------------------
---
> {-# INLINE-- --------------------------------------------------------------------- #-}
1122d1111
< 
1123c1112
< -- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
---
> -- ---------------------------------------------------------------------
1123a1113
> -- Special lists-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
1125d1114
< inits = (Empty :) . inits'
1126c1115
<   where inits' Empty        = []
---
> inits-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.= (Empty :) . inits'
1126a1116
> initswhere::inits'Empty-> [ByteString= []  ]
1126a1117
> inits = (inits'Empty :)Chunk inits'c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
1126a1118
>   where inits' Empty       ++= [L.map]    (Chunk c) (inits' cs)
1128d1119
<                            ++ L.map (Chunk c) (inits' cs)
1129d1119
< 
1130c1120
< -- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
---
> -- | /O(n)/ Return all final segments of the given 'ByteString', longest first. L.map (Chunk c) (inits' cs)
1132d1121
< tails Empty         = Empty : []
1133c1122
< tails cs@(Chunk c cs')
---
> tails-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.Empty         = Empty : []
1133a1123
> tails ::@ByteString(Chunk c cs'->) [ByteString]
1133a1124
> tails| S.length  c == 1 = Emptycs : tails [] cs'
1133a1125
> tails| otherwise@(Chunk c cs'=)cs : tails (Chunk (S.unsafeTail c) cs')
1135d1126
<   | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
1136d1126
< 
1137c1127
< -- ---------------------------------------------------------------------
---
> -- --------------------------------------------------------------------- otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
1139d1128
< 
1140c1129
< -- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
---
> -- ---------------------------------------------------------------------
1140a1130
> -- Low level constructors-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
1142d1131
< --   to by the 'ByteString' to be garbage collected, for example
1143d1131
< --   if a large string has been read in, and only a small part of it
1144d1131
< --   is needed in the rest of the program.
1145d1131
< copy :: ByteString -> ByteString
1146d1131
< copy cs = foldrChunks (Chunk . S.copy) Empty cs
1147c1132
< --TODO, we could coalese small blocks here
---
> --   to by the 'ByteString' to be garbage collected, for example-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
1147a1133
> --   This is mainly useful to allow the rest of the data pointed--   if a large string has been read in, and only a small part of it
1147a1134
> --   is needed in the rest of the program.--   to by the 'ByteString' to be garbage collected, for example
1147a1135
> copy--   if a large string has been read in, and only a small part of it:: ByteString -> ByteString
1147a1136
> copy--   is needed in the rest of the program.cs = foldrChunks (Chunk . S.copy) Empty cs
1147a1137
> copy--TODO, we could coalese small blocks here:: ByteString -> ByteString
1147a1138
> copy--FIXME: probably not strict enough, if we're doing this to avoid retaining = foldrChunks (Chunk . S.copy) Empty cs
1147a1139
> --TODO, we could coalese small blocks here-- the parent blocks then we'd better copy strictly.
1149d1140
< -- the parent blocks then we'd better copy strictly.
1150d1140
< 
1151c1141
< -- ---------------------------------------------------------------------
---
> -- the parent blocks then we'd better copy strictly.-- ---------------------------------------------------------------------
1153c1143
< -- TODO defrag func that concatenates block together that are below a threshold
---
> -- ----------------------------------------------------------------------- TODO defrag func that concatenates block together that are below a threshold
1155d1144
< 
1156c1145
< -- ---------------------------------------------------------------------
---
> -- TODO defrag func that concatenates block together that are below a threshold
1156a1146
> -- defrag :: ByteString -> ByteString-- ---------------------------------------------------------------------
1158d1147
< --
1159c1148
< -- Rule for when to close: is it expected to read the whole file?
---
> ---- ---------------------------------------------------------------------
1159a1149
> -- Lazy ByteString IO-- Rule for when to close: is it expected to read the whole file?
1159a1150
> ---- If so, close when done.
1159a1151
> ---- Rule for when to close: is it expected to read the whole file?
1161d1152
< --
1162d1152
< 
1163c1153
< -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
---
> ---- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
1165d1154
< -- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
1166d1154
< -- available then they will be returned immediately as a smaller chunk.
1167d1154
< --
1168d1154
< -- The handle is closed on EOF.
1169d1154
< --
1170d1154
< -- Note: the 'Handle' should be placed in binary mode with
1171d1154
< -- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
1172c1155
< -- work correctly.
---
> -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
1172a1156
> -- are read on demand, in at most @k@-sized chunks. It does not block-- available then they will be returned immediately as a smaller chunk.
1172a1157
> ---- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
1172a1158
> -- The handle is closed on EOF.-- available then they will be returned immediately as a smaller chunk.
1174d1159
< hGetContentsN :: Int -> Handle -> IO ByteString
1175c1160
< hGetContentsN k h = lazyRead -- TODO close on exceptions
---
> -- The handle is closed on EOF.-- Note: the 'Handle' should be placed in binary mode with
1175a1161
> ---- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
1175a1162
> -- work correctly.-- Note: the 'Handle' should be placed in binary mode with
1175a1163
> ---- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
1175a1164
> hGetContentsN-- work correctly.:: Int -> Handle -> IO ByteString
1175a1165
> --hGetContentsN k h = lazyRead -- TODO close on exceptions
1175a1166
> hGetContentsNwhere       :: Int -> Handle -> IO ByteString
1175a1167
> hGetContentsNlazyRead =kunsafeInterleaveIO = lazyRead -- TODO close on exceptionsloop
1177d1168
<     lazyRead = unsafeInterleaveIO loop
1178d1168
< 
1179c1169
<     loop = do
---
>     lazyReadloop = do= unsafeInterleaveIO loop
1181d1170
<         if S.null c
1182c1171
<           then do hClose h >> return Empty
---
>     loopif= doS.null c
1182a1172
>         c <-thendo hClosehhk>>-- only blocks if there is no data availablereturn Empty
1182a1173
>         ifelsedo ccs <- lazyRead
1182a1174
>           then do hClose hChunk returnc cs)Empty
1184d1175
<                   return (Chunk c cs)
1185d1175
< 
1186c1176
< -- | Read @n@ bytes into a 'ByteString', directly from the
---
> -- | Read @n@ bytes into a 'ByteString', directly from the (Chunk c cs)
1188d1177
< --
1189d1177
< hGetN :: Int -> Handle -> Int -> IO ByteString
1190d1177
< hGetN k h n | n > 0 = readChunks n
1191d1177
<   where
1192d1177
<     readChunks !i = do
1193d1177
<         c <- S.hGet h (min k i)
1194d1177
<         case S.length c of
1195c1178
<             0 -> return Empty
---
> ---- | Read @n@ bytes into a 'ByteString', directly from the
1195a1179
> hGetN-- specified 'Handle', in chunks of size @k@.:: Int -> Handle -> Int -> IO ByteString
1195a1180
> --hGetN k h n | n > 0 = readChunks n
1195a1181
> hGetNwhere:: Int -> Handle -> Int -> IO ByteString
1195a1182
> hGetNreadChunks h n | n!> 0 =doreadChunks n
1195a1183
>   where c <- S.hGet h (min k i)
1195a1184
>     readChunkscase S.length!i = doc of
1195a1185
>         c <-0S.hGet-> return (minEmpty i)
1195a1186
>         casemS.length-> do csc<-ofreadChunks (i - m)
1195a1187
>             0 -> returnreturn(Chunk c cs)
1197d1188
<                     return (Chunk c cs)
1198d1188
< 
1199c1189
< hGetN _ _ 0 = return Empty
---
> hGetN _ _ 0 = returnreturnEmpty (Chunk c cs)
1201d1190
< 
1202c1191
< -- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
---
> hGetN _ _ 0 = return Empty
1202a1192
> hGetN-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block h n = illegalBufferSize h "hGet" n
1204d1193
< -- is available. Chunks are read on demand, in @k@-sized chunks.
1205d1193
< --
1206d1193
< hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
1207d1193
< hGetNonBlockingN k h n | n > 0= readChunks n
1208d1193
<   where
1209d1193
<     readChunks !i = do
1210d1193
<         c <- S.hGetNonBlocking h (min k i)
1211d1193
<         case S.length c of
1212c1194
<             0 -> return Empty
---
> -- is available. Chunks are read on demand, in @k@-sized chunks.-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
1212a1195
> ---- waiting for data to become available, instead it returns only whatever data
1212a1196
> hGetNonBlockingN-- is available. Chunks are read on demand, in @k@-sized chunks.:: Int -> Handle -> Int -> IO ByteString
1212a1197
> --hGetNonBlockingN k h n | n > 0= readChunks n
1212a1198
> hGetNonBlockingNwhere          :: Int -> Handle -> Int -> IO ByteString
1212a1199
> hGetNonBlockingNreadChunks !ik=hdo | n > 0= readChunks n
1212a1200
>   where c <- S.hGetNonBlocking h (min k i)
1212a1201
>     readChunkscase S.length!i = doc of
1212a1202
>         c <-0S.hGetNonBlocking-> return Empty  h (min k i)
1212a1203
>         casemS.length-> do csc<-ofreadChunks (i - m)
1212a1204
>             0 -> returnreturn(Chunk c cs)
1214d1205
<                     return (Chunk c cs)
1215d1205
< 
1216c1206
< hGetNonBlockingN _ _ 0 = return Empty
---
> hGetNonBlockingN _ _return0 = returnChunkEmpty cs)
1218d1207
< 
1219c1208
< illegalBufferSize :: Handle -> String -> Int -> IO a
---
> hGetNonBlockingN _ _ 0 = return Empty
1219a1209
> hGetNonBlockingNillegalBufferSize_:: nHandle= illegalBufferSize-> String -> Int "hGetNonBlocking"-> IO a           n
1221d1210
<     ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1222c1211
<     --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
---
> illegalBufferSizeioError (mkIOError:: HandleillegalOperationErrorType-> String -> Int -> IOmsg (Just handle) Nothing)
1222a1212
> illegalBufferSize--TODO: System.IO uses InvalidArgument here, but it's not exported :-( fn sz =
1222a1213
>     ioErrorwhere   (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1222a1214
>     --TODO: System.IO uses InvalidArgument here, but it's not exported :-(msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1224d1215
<       msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1225d1215
< 
1226c1216
< -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
---
> -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1228d1217
< --
1229d1217
< -- Once EOF is encountered, the Handle is closed.
1230d1217
< --
1231d1217
< -- Note: the 'Handle' should be placed in binary mode with
1232d1217
< -- 'System.IO.hSetBinaryMode' for 'hGetContents' to
1233c1218
< -- work correctly.
---
> ---- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
1233a1219
> -- Once EOF is encountered, the Handle is closed.-- are read on demand, using the default chunk size.
1234a1221
> -- Once EOF is encountered, the Handle is closed.-- Note: the 'Handle' should be placed in binary mode with
1234a1222
> ---- 'System.IO.hSetBinaryMode' for 'hGetContents' to
1234a1223
> -- work correctly.-- Note: the 'Handle' should be placed in binary mode with
1234a1224
> ---- 'System.IO.hSetBinaryMode' for 'hGetContents' to
1234a1225
> hGetContents-- work correctly.:: Handle -> IO ByteString
1234a1226
> --hGetContents = hGetContentsN defaultChunkSize
1236d1227
< hGetContents = hGetContentsN defaultChunkSize
1237d1227
< 
1238c1228
< -- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
---
> hGetContents-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.= hGetContentsN defaultChunkSize
1239a1230
> hGet-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.:: Handle -> Int -> IO ByteString
1239a1231
> --hGet = hGetN defaultChunkSize
1241d1232
< hGet = hGetN defaultChunkSize
1242d1232
< 
1243c1233
< -- | hGetNonBlocking is similar to 'hGet', except that it will never block
---
> hGet-- | hGetNonBlocking is similar to 'hGet', except that it will never block= hGetN defaultChunkSize
1245d1234
< -- is available.  If there is no data available to be read, 'hGetNonBlocking'
1246d1234
< -- returns 'empty'.
1247d1234
< --
1248d1234
< -- Note: on Windows and with Haskell implementation other than GHC, this
1249d1234
< -- function does not work correctly; it behaves identically to 'hGet'.
1250c1235
< --
---
> -- | hGetNonBlocking is similar to 'hGet', except that it will never block-- is available.  If there is no data available to be read, 'hGetNonBlocking'
1250a1236
> -- returns 'empty'.-- waiting for data to become available, instead it returns only whatever data
1250a1237
> ---- is available.  If there is no data available to be read, 'hGetNonBlocking'
1250a1238
> -- returns 'empty'.-- Note: on Windows and with Haskell implementation other than GHC, this
1250a1239
> ---- function does not work correctly; it behaves identically to 'hGet'.
1250a1240
> ---- Note: on Windows and with Haskell implementation other than GHC, this
1250a1241
> hGetNonBlocking-- function does not work correctly; it behaves identically to 'hGet'.:: Handle -> Int -> IO ByteString
1250a1242
> --hGetNonBlocking = hGetNonBlockingN defaultChunkSize
1252d1243
< hGetNonBlocking = hGetNonBlockingN defaultChunkSize
1253d1243
< 
1254c1244
< -- | Read an entire file /lazily/ into a 'ByteString'.
---
> hGetNonBlocking-- | Read an entire file /lazily/ into a 'ByteString'.= hGetNonBlockingN defaultChunkSize
1256c1246
< --
---
> ---- | Read an entire file /lazily/ into a 'ByteString'.
1256a1247
> readFile-- The Handle will be held open until EOF is encountered.:: FilePath -> IO ByteString
1256a1248
> --readFile f = openBinaryFile f ReadMode >>= hGetContents
1258d1249
< readFile f = openBinaryFile f ReadMode >>= hGetContents
1259d1249
< 
1260c1250
< -- | Write a 'ByteString' to a file.
---
> readFile-- | Write a 'ByteString' to a file. = openBinaryFile f ReadMode >>= hGetContents
1262c1252
< writeFile :: FilePath -> ByteString -> IO ()
---
> writeFile-- | Write a 'ByteString' to a file.:: FilePath -> ByteString -> IO ()
1262a1253
> --writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
1262a1254
> writeFile(\hdl :: FilePathhPut hdl ->txtByteString)          -> IO ()
1264d1255
<     (\hdl -> hPut hdl txt)
1265d1255
< 
1266c1256
< -- | Append a 'ByteString' to a file.
---
> -- | Append a 'ByteString' to a file.\hdl -> hPut hdl txt)
1268c1258
< appendFile :: FilePath -> ByteString -> IO ()
---
> appendFile-- | Append a 'ByteString' to a file.:: FilePath -> ByteString -> IO ()
1268a1259
> --appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
1268a1260
> appendFile(\hdl ->::hPuthdl txt->)ByteString -> IO ()
1270d1261
<     (\hdl -> hPut hdl txt)
1271d1261
< 
1272c1262
< -- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
---
> -- | getContents. Equivalent to hGetContents stdin. Will read /lazily/\hdl -> hPut hdl txt)
1273a1264
> getContents-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/:: IO ByteString
1273a1265
> --getContents = hGetContents stdin
1275d1266
< getContents = hGetContents stdin
1276d1266
< 
1277c1267
< -- | Outputs a 'ByteString' to the specified 'Handle'.
---
> getContents-- | Outputs a 'ByteString' to the specified 'Handle'.= hGetContents stdin
1278a1269
> hPut-- | Outputs a 'ByteString' to the specified 'Handle'.:: Handle -> ByteString -> IO ()
1278a1270
> --hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
1280d1271
< hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
1281d1271
< 
1282c1272
< -- | Similar to 'hPut' except that it will never block. Instead it returns
---
> hPut-- | Similar to 'hPut' except that it will never block. Instead it returns cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
1284d1273
< -- the whole string was written, or the whole original string if nothing was
1285d1273
< -- written. Partial writes are also possible.
1286d1273
< --
1287d1273
< -- Note: on Windows and with Haskell implementation other than GHC, this
1288d1273
< -- function does not work correctly; it behaves identically to 'hPut'.
1289d1273
< --
1290d1273
< hPutNonBlocking :: Handle -> ByteString -> IO ByteString
1291d1273
< hPutNonBlocking _ Empty           = return Empty
1292d1273
< hPutNonBlocking h bs@(Chunk c cs) = do
1293d1273
<   c' <- S.hPutNonBlocking h c
1294d1273
<   case S.length c' of
1295c1274
<     l' | l' == S.length c -> hPutNonBlocking h cs
---
> -- | Similar to 'hPut' except that it will never block. Instead it returns-- the whole string was written, or the whole original string if nothing was
1295a1275
> -- written. Partial writes are also possible.-- any tail that did not get written. This tail may be 'empty' in the case that
1295a1276
> ---- the whole string was written, or the whole original string if nothing was
1295a1277
> -- written. Partial writes are also possible.-- Note: on Windows and with Haskell implementation other than GHC, this
1295a1278
> ---- function does not work correctly; it behaves identically to 'hPut'.
1295a1279
> ---- Note: on Windows and with Haskell implementation other than GHC, this
1295a1280
> hPutNonBlocking-- function does not work correctly; it behaves identically to 'hPut'.:: Handle -> ByteString -> IO ByteString
1295a1281
> --hPutNonBlocking _ Empty           = return Empty
1295a1282
> hPutNonBlocking ::h bs@(Chunk->cByteStringcs) = do  -> IO ByteString
1295a1283
> hPutNonBlockingc' <- S.hPutNonBlocking Empty   h c     = return Empty
1295a1284
> hPutNonBlockingcase S.length hc'bsof@(Chunk c cs) = do
1295a1285
>   c'l'<-|S.hPutNonBlockingl' == S.length c h->chPutNonBlocking h cs
1295a1286
>   case0  S.length c' of     -> return bs
1295a1287
>     l'_  | l' == S.length c -> hPutNonBlockingreturn (Chunk c'hcs)
1297d1288
<     _                     -> return (Chunk c' cs)
1298d1288
< 
1299c1289
< -- | A synonym for @hPut@, for compatibility
---
> -- | A synonym for @hPut@, for compatibility                     -> return (Chunk c' cs)
1300a1291
> hPutStr-- | A synonym for @hPut@, for compatibility:: Handle -> ByteString -> IO ()
1300a1292
> --hPutStr = hPut
1302d1293
< hPutStr = hPut
1303d1293
< 
1304c1294
< -- | Write a ByteString to stdout
---
> hPutStr-- | Write a ByteString to stdout= hPut
1306d1295
< putStr = hPut stdout
1307d1295
< 
1308c1296
< -- | Write a ByteString to stdout, appending a newline byte
---
> putStr-- | Write a ByteString to stdout= hPut stdout
1308a1297
> putStr :: ByteString -> IO ()
1308a1298
> putStr-- | Write a ByteString to stdout, appending a newline byte= hPut stdout
1309a1300
> putStrLn-- | Write a ByteString to stdout, appending a newline byte:: ByteString -> IO ()
1309a1301
> --putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
1311d1302
< putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
1312d1302
< 
1313c1303
< {-# DEPRECATED putStrLn
---
> putStrLn{-# DEPRECATED = hPutputStrLn ps >> hPut stdout (singleton 0x0a)
1315d1304
<   #-}
1316d1304
< 
1317c1305
< -- | The interact function takes a function of type @ByteString -> ByteString@
---
> {-# DEPRECATED#-}          putStrLn
1317a1306
>     "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
1317a1307
> -- | The interact function takes a function of type @ByteString -> ByteString@#-}
1320c1310
< -- standard output device.
---
> -- standard output device.-- | The interact function takes a function of type @ByteString -> ByteString@
1320a1311
> ---- as its argument. The entire input from the standard input device is passed
1320a1312
> interact-- to this function as its argument, and the resulting string is output on the:: (ByteString -> ByteString) -> IO ()
1320a1313
> interact-- standard output device.transformer = putStr . transformer =<< getContents
1322d1314
< interact :: (ByteString -> ByteString) -> IO ()
1323d1314
< interact transformer = putStr . transformer =<< getContents
1324d1314
< 
1325d1314
< -- ---------------------------------------------------------------------
1326c1315
< -- Internal utilities
---
> interact-- ---------------------------------------------------------------------:: (ByteString -> ByteString) -> IO ()
1326a1316
> interact-- Internal utilities = putStr . transformer =<< getContents
1328d1317
< -- Common up near identical calls to `error' to reduce the number
1329c1318
< -- constant strings created when compiled:
---
> -- Common up near identical calls to `error' to reduce the number-- ---------------------------------------------------------------------
1329a1319
> -- Internal utilities-- constant strings created when compiled:
1331c1321
< errorEmptyList fun = moduleError fun "empty ByteString"
---
> errorEmptyList-- Common up near identical calls to `error' to reduce the numberfun = moduleError fun "empty ByteString"
1331a1322
> -- constant strings created when compiled:
1331a1323
> errorEmptyListmoduleError :: ::String-> ->String   -> a
1331a1324
> errorEmptyListmoduleError funfunmsg==moduleErrorerror ("Data.Vector.Storable.ByteString.Lazy." "empty ByteString"              ++ fun ++ ':':' ':msg)
1334d1326
< moduleError fun msg = error ("Data.Vector.Storable.ByteString.Lazy." ++ fun ++ ':':' ':msg)
1335d1326
< 
1336d1326
< 
1337c1327
< -- reverse a list of non-empty chunks into a lazy ByteString
---
> moduleError-- reverse a list of non-empty chunks into a lazy ByteString msg = error ("Data.Vector.Storable.ByteString.Lazy." ++ fun ++ ':':' ':msg)
1340d1329
< 
1341d1329
< -- reverse a list of possibly-empty chunks into a lazy ByteString
1342c1330
< revChunks :: [P.ByteString] -> ByteString
---
> -- reverse a list of non-empty chunks into a lazy ByteString
1342a1331
> revNonEmptyChunks-- reverse a list of possibly-empty chunks into a lazy ByteString:: [P.ByteString] -> ByteString
1342a1332
> revNonEmptyChunksrevChunks :: [P.ByteString = L.foldl'] -> ByteStringflip Chunk) Empty cs
1344d1333
< 
1345d1333
< -- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
1346c1334
< -- of the string if no element is found, rather than Nothing.
---
> -- reverse a list of possibly-empty chunks into a lazy ByteString
1346a1335
> revChunks-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length:: [P.ByteString] -> ByteString
1346a1336
> revChunks-- of the string if no element is found, rather than Nothing. = L.foldl' (flip chunk) Empty cs
1347a1338
> findIndexOrEnd-- | 'findIndexOrEnd' is a variant of findIndex, that returns the lengthk v = S.inlinePerformIO $ withForeignPtr fp $ \f -> go f 0
1347a1339
> -- of the string if no element is found, rather than Nothing.where
1347a1340
> findIndexOrEnd(fp, l) = VS.unsafeToForeignPtr0:: (Word8 -> Bool) -> P.ByteStringv            -> Int
1349d1341
<   where
1350d1341
<     (fp, l) = VS.unsafeToForeignPtr0 v
1351d1341
< 
1352d1341
<     go !ptr !n | n >= l    = return l
1353c1342
<                | otherwise = do w <- peek ptr
---
>   wherego !ptr !n | n >= l    = return l
1353a1343
>     (fp, l) = VS.unsafeToForeignPtr0| otherwise = do w <- vpeek ptr
1354a1345
>     go !ptr !n | n >= l    = returnthen  return n
1354a1346
>                | otherwise = do w <-elsego ptr(ptr `plusPtr` 1) (n+1)
1354a1347
> {-# INLINE findIndexOrEnd #-}   if k w
1357a1351
> 
1357a1352
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-incomplete-patterns
                -fno-warn-orphans
  #-}

-- |
-- Module      : Data.Vector.Storable.ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006
--               (c) Duncan Coutts 2006
--               (c) Bas van Dijk 2011
-- License     : BSD-style
--
-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental
-- Portability : portable
--
-- A time and space-efficient implementation of lazy byte vectors
-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed
-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
-- arrays of bytes. They provide a means to manipulate large byte vectors
-- without requiring the entire vector be resident in memory.
--
-- Some operations, such as concat, append, reverse and cons, have
-- better complexity than their "Data.ByteString" equivalents, due to
-- optimisations resulting from the list spine structure. And for other
-- operations lazy ByteStrings are usually within a few percent of
-- strict ones, but with better heap usage. For data larger than the
-- available memory, or if you have tight memory constraints, this
-- module will be the only option. The default chunk size is 64k, which
-- should be good in most circumstances. For people with large L2
-- caches, you may want to increase this to fit your cache.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.Vector.Storable.ByteString.Lazy as B
--
-- Original GHC implementation by Bryan O\'Sullivan.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
-- by David Roundy.
-- Polished and extended by Don Stewart.
-- Lazy variant by Duncan Coutts and Don Stewart.
--

module Data.Vector.Storable.ByteString.Lazy (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        cons',                  -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)
        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transforming ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Infinite ByteStrings
        repeat,                 -- :: Word8 -> ByteString
        replicate,              -- :: Int64 -> Word8 -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Word8 -> Word8) -> Word8 -> ByteString

        -- ** Unfolding ByteStrings
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
--        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
--        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
--        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int64
        elemIndices,            -- :: Word8 -> ByteString -> [Int64]
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Word8 -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString
--        defrag,                -- :: ByteString -> ByteString

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()

  ) where

import Prelude hiding
    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)

import qualified Data.List              as L  -- L for list/lazy
import qualified Data.Vector.Storable.ByteString        as P  (ByteString) -- type name only
import qualified Data.Vector.Storable.ByteString        as S  -- S for strict (hmm...)
import qualified Data.Vector.Storable.ByteString.Internal as S
import qualified Data.Vector.Storable.ByteString.Unsafe as S
import Data.Vector.Storable.ByteString.Lazy.Internal

import Data.Monoid              (Monoid(..))

import Data.Word                (Word8)
import Data.Int                 (Int64)
import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
                                ,hClose)
import System.IO.Error          (mkIOError, illegalOperationErrorType)
import System.IO.Unsafe
import Control.Exception        (bracket)

import Foreign.ForeignPtr       (withForeignPtr)
import Foreign.Ptr
import Foreign.Storable

-- from vector:
import qualified Data.Vector.Storable as VS
    ( unsafeToForeignPtr0, unsafeToForeignPtr0 )


-- -----------------------------------------------------------------------------

instance Eq  ByteString
    where (==)    = eq

instance Ord ByteString
    where compare = cmp

instance Monoid ByteString where
    mempty  = empty
    mappend = append
    mconcat = concat

eq :: ByteString -> ByteString -> Bool
eq Empty Empty = True
eq Empty _     = False
eq _     Empty = False
eq (Chunk a as) (Chunk b bs) =
  case compare (S.length a) (S.length b) of
    LT -> a == (S.take (S.length a) b) && eq as (Chunk (S.drop (S.length a) b) bs)
    EQ -> a == b                       && eq as bs
    GT -> (S.take (S.length b) a) == b && eq (Chunk (S.drop (S.length b) a) as) bs

cmp :: ByteString -> ByteString -> Ordering
cmp Empty Empty = EQ
cmp Empty _     = LT
cmp _     Empty = GT
cmp (Chunk a as) (Chunk b bs) =
  case compare (S.length a) (S.length b) of
    LT -> case compare a (S.take (S.length a) b) of
            EQ     -> cmp as (Chunk (S.drop (S.length a) b) bs)
            result -> result
    EQ -> case compare a b of
            EQ     -> cmp as bs
            result -> result
    GT -> case compare (S.take (S.length b) a) b of
            EQ     -> cmp (Chunk (S.drop (S.length b) a) as) bs
            result -> result

-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = Empty
{-# INLINE empty #-}

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton w = Chunk (S.singleton w) Empty
{-# INLINE singleton #-}

-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.
pack :: [Word8] -> ByteString
pack ws = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
  where
    chunks :: Int -> [a] -> [[a]]
    chunks _    [] = []
    chunks size xs = case L.splitAt size xs of
                      (xs', xs'') -> xs' : chunks size xs''

-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack :: ByteString -> [Word8]
unpack cs = L.concatMap S.unpack (toChunks cs)
--TODO: we can do better here by integrating the concat with the unpack

-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString'
fromChunks :: [P.ByteString] -> ByteString
fromChunks cs = L.foldr chunk Empty cs

-- | /O(n)/ Convert a lazy 'ByteString' into a list of strict 'ByteString'
toChunks :: ByteString -> [P.ByteString]
toChunks cs = foldrChunks (:) [] cs

------------------------------------------------------------------------

{-
-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}
-}

-- ---------------------------------------------------------------------
-- Basic interface

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null Empty = True
null _     = False
{-# INLINE null #-}

-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64'
length :: ByteString -> Int64
length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
{-# INLINE length #-}

-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
--
cons :: Word8 -> ByteString -> ByteString
cons c cs = Chunk (S.singleton c) cs
{-# INLINE cons #-}

-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons\' c xs in xs
--
-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.
--
cons' :: Word8 -> ByteString -> ByteString
cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
cons' w cs                             = Chunk (S.singleton w) cs
{-# INLINE cons' #-}

-- | /O(n\/c)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc cs w = foldrChunks Chunk (singleton w) cs
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Word8
head Empty       = errorEmptyList "head"
head (Chunk c _) = S.unsafeHead c
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)
uncons Empty = Nothing
uncons (Chunk c cs)
    = Just (S.unsafeHead c,
            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
{-# INLINE uncons #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
-- non-empty.
tail :: ByteString -> ByteString
tail Empty          = errorEmptyList "tail"
tail (Chunk c cs)
  | S.length c == 1 = cs
  | otherwise       = Chunk (S.unsafeTail c) cs
{-# INLINE tail #-}

-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
-- and non-empty.
last :: ByteString -> Word8
last Empty          = errorEmptyList "last"
last (Chunk c0 cs0) = go c0 cs0
  where go c Empty        = S.last c
        go _ (Chunk c cs) = go c cs
-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)

-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.
init :: ByteString -> ByteString
init Empty          = errorEmptyList "init"
init (Chunk c0 cs0) = go c0 cs0
  where go c Empty | S.length c == 1 = Empty
                   | otherwise       = Chunk (S.init c) Empty
        go c (Chunk c' cs)           = Chunk c (go c' cs)

-- | /O(n\/c)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append xs ys = foldrChunks Chunk ys xs
{-# INLINE append #-}

-- ---------------------------------------------------------------------
-- Transformations

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@.
map :: (Word8 -> Word8) -> ByteString -> ByteString
map f s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = Chunk y ys
            where
                y  = S.map f x
                ys = go xs
{-# INLINE map #-}

-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse cs0 = rev Empty cs0
  where rev a Empty        = a
        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
{-# INLINE reverse #-}

-- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and
-- \`intersperses\' that byte between the elements of the 'ByteString'.
-- It is analogous to the intersperse function on Lists.
intersperse :: Word8 -> ByteString -> ByteString
intersperse _ Empty        = Empty
intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
                                   (foldrChunks (Chunk . intersperse') Empty cs)
  where intersperse' :: P.ByteString -> P.ByteString
        intersperse' v =
          S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
            poke p' w
            S.c_intersperse (p' `plusPtr` 1) p (fromIntegral l) w
              where
                 (fp, l) = VS.unsafeToForeignPtr0 v

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
                      (L.transpose (L.map unpack css))
--TODO: make this fast

-- ---------------------------------------------------------------------
-- Reducing 'ByteString's

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl f z = go z
  where go a Empty        = a
        go a (Chunk c cs) = go (S.foldl f a c) cs
{-# INLINE foldl #-}

-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' f z = go z
  where go a _ | a `seq` False = undefined
        go a Empty        = a
        go a (Chunk c cs) = go (S.foldl f a c) cs
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a ByteString,
-- reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
-- This function is subject to array fusion.
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 _ Empty        = errorEmptyList "foldl1"
foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' _ Empty        = errorEmptyList "foldl1'"
foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 _ Empty          = errorEmptyList "foldr1"
foldr1 f (Chunk c0 cs0) = go c0 cs0
  where go c Empty         = S.foldr1 f c
        go c (Chunk c' cs) = S.foldr  f (go c' cs) c

-- ---------------------------------------------------------------------
-- Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat css0 = to css0
  where
    go Empty        css = to css
    go (Chunk c cs) css = Chunk c (go cs css)
    to []               = Empty
    to (cs:css)         = go cs css

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap _ Empty        = Empty
concatMap f (Chunk c0 cs0) = to c0 cs0
  where
    go :: ByteString -> P.ByteString -> ByteString -> ByteString
    go Empty        c' cs' = to c' cs'
    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')

    to :: P.ByteString -> ByteString -> ByteString
    to c cs | S.null c  = case cs of
        Empty          -> Empty
        (Chunk c' cs') -> to c' cs'
            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
{-# INLINE any #-}
-- todo fuse

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
{-# INLINE all #-}
-- todo fuse

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Word8
maximum Empty        = errorEmptyList "maximum"
maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
                                   (S.maximum c) cs
{-# INLINE maximum #-}

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Word8
minimum Empty        = errorEmptyList "minimum"
minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
                                     (S.minimum c) cs
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s',  c')  = S.mapAccumL f s c
              (s'', cs') = go s' cs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s'', c') = S.mapAccumR f s' c
              (s', cs') = go s cs

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl f z = snd . foldl k (z,singleton z)
 where
    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
{-# INLINE scanl #-}

-- ---------------------------------------------------------------------
-- Unfolds and replicates

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Word8 -> Word8) -> Word8 -> ByteString
iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Word8 -> ByteString
repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Word8 -> ByteString
replicate n w
    | n <= 0             = Empty
    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
    | r == 0             = cs -- preserve invariant
    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
 where
    c      = S.replicate smallChunkSize w
    cs     = nChunks q
    (q, r) = quotRem n (fromIntegral smallChunkSize)
    nChunks 0 = Empty
    nChunks m = Chunk c (nChunks (m-1))

-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
-- the infinite repetition of the original ByteString.
--
cycle :: ByteString -> ByteString
cycle Empty = errorEmptyList "cycle"
cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr f s0 = unfoldChunk 32 s0
  where unfoldChunk n s =
          case S.unfoldrN n f s of
            (c, Nothing)
              | S.null c  -> Empty
              | otherwise -> Chunk c Empty
            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')

-- ---------------------------------------------------------------------
-- Substrings

-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int64 -> ByteString -> ByteString
take i _ | i <= 0 = Empty
take i cs0         = take' i cs0
  where take' 0 _            = Empty
        take' _ Empty        = Empty
        take' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.take (fromIntegral n) c) Empty
            else Chunk c (take' (n - fromIntegral (S.length c)) cs)

-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int64 -> ByteString -> ByteString
drop i p | i <= 0 = p
drop i cs0 = drop' i cs0
  where drop' 0 cs           = cs
        drop' _ Empty        = Empty
        drop' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.drop (fromIntegral n) c) cs
            else drop' (n - fromIntegral (S.length c)) cs

-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
splitAt i cs0 | i <= 0 = (Empty, cs0)
splitAt i cs0 = splitAt' i cs0
  where splitAt' 0 cs           = (Empty, cs)
        splitAt' _ Empty        = (Empty, Empty)
        splitAt' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then (Chunk (S.take (fromIntegral n) c) Empty
                 ,Chunk (S.drop (fromIntegral n) c) cs)
            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
                   in (Chunk c cs', cs'')


-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f cs0 = takeWhile' cs0
  where takeWhile' Empty        = Empty
        takeWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            0                  -> Empty
            n | n < S.length c -> Chunk (S.take n c) Empty
              | otherwise      -> Chunk c (takeWhile' cs)

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f cs0 = dropWhile' cs0
  where dropWhile' Empty        = Empty
        dropWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            n | n < S.length c -> Chunk (S.drop n c) cs
              | otherwise      -> dropWhile' cs

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break f cs0 = break' cs0
  where break' Empty        = (Empty, Empty)
        break' (Chunk c cs) =
          case findIndexOrEnd f c of
            0                  -> (Empty, Chunk c cs)
            n | n < S.length c -> (Chunk (S.take n c) Empty
                                  ,Chunk (S.drop n c) cs)
              | otherwise      -> let (cs', cs'') = break' cs
                                   in (Chunk c cs', cs'')

--
-- TODO
--
-- Add rules
--

{-
-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
  where breakByte' []     = ([], [])
        breakByte' (x:xs) =
          case P.elemIndex c x of
            Just 0  -> ([], x : xs)
            Just n  -> (P.take n x : [], P.drop n x : xs)
            Nothing -> let (xs', xs'') = breakByte' xs
                        in (x : xs', xs'')

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
  where spanByte' []     = ([], [])
        spanByte' (x:xs) =
          case P.spanByte c x of
            (x', x'') | P.null x'  -> ([], x : xs)
                      | P.null x'' -> let (xs', xs'') = spanByte' xs
                                       in (x : xs', xs'')
                      | otherwise  -> (x' : [], x'' : xs)
-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span p = break (not . p)

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith _ Empty          = []
splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs

{-# INLINE splitWith #-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split _ Empty     = []
split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
{-# INLINE split #-}

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = L.filter (not.null) . splitWith f
-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test.
group :: ByteString -> [ByteString]
group Empty          = []
group (Chunk c0 cs0) = group' [] (S.group c0) cs0
  where
    group' :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
    group' acc@(s':_) ss@(s:_) cs
      | S.unsafeHead s'
     /= S.unsafeHead s             = revNonEmptyChunks    acc  : group' [] ss cs
    group' acc (s:[]) Empty        = revNonEmptyChunks (s:acc) : []
    group' acc (s:[]) (Chunk c cs) = group' (s:acc) (S.group c) cs
    group' acc (s:ss) cs           = revNonEmptyChunks (s:acc) : group' [] ss cs

{-
TODO: check if something like this might be faster

group :: ByteString -> [ByteString]
group xs
    | null xs   = []
    | otherwise = ys : group zs
    where
        (ys, zs) = spanByte (unsafeHead xs) xs
-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
--
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy _ Empty          = []
groupBy k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
  where
    groupBy' :: [P.ByteString] -> Word8 -> [P.ByteString] -> ByteString -> [ByteString]
    groupBy' acc@(_:_) c ss@(s:_) cs
      | not (c `k` S.unsafeHead s)     = revNonEmptyChunks acc : groupBy' [] 0 ss cs
    groupBy' acc _ (s:[]) Empty        = revNonEmptyChunks (s : acc) : []
    groupBy' acc w (s:[]) (Chunk c cs) = groupBy' (s:acc) w' (S.groupBy k c) cs
                                           where w' | L.null acc = S.unsafeHead s
                                                    | otherwise  = w
    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks (s : acc) : groupBy' [] 0 ss cs

{-
TODO: check if something like this might be faster

groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k xs
    | null xs   = []
    | otherwise = take n xs : groupBy k (drop n xs)
    where
        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
-}

-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString
intercalate s = concat . (L.intersperse s)

-- ---------------------------------------------------------------------
-- Indexing ByteStrings

-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Word8
index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
index cs0 i         = index' cs0 i
  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
        index' (Chunk c cs) n
          | n >= fromIntegral (S.length c) =
              index' cs (n - fromIntegral (S.length c))
          | otherwise       = S.unsafeIndex c (fromIntegral n)

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element.
-- This implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int64
elemIndex w cs0 = elemIndex' 0 cs0
  where elemIndex' _ Empty        = Nothing
        elemIndex' n (Chunk c cs) =
          case S.elemIndex w c of
            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)

{-
-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    go !p !i | i < 0     = return Nothing
             | otherwise = do ch' <- peekByteOff p i
                              if ch == ch'
                                then return $ Just i
                                else go p (i-1)
-}
-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int64]
elemIndices w cs0 = elemIndices' 0 cs0
  where elemIndices' _ Empty        = []
        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
                             ++ elemIndices' (n + fromIntegral (S.length c)) cs

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int64
count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndex k cs0 = findIndex' 0 cs0
  where findIndex' _ Empty        = Nothing
        findIndex' n (Chunk c cs) =
          case S.findIndex k c of
            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)
{-# INLINE findIndex #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find f cs0 = find' cs0
  where find' Empty        = Nothing
        find' (Chunk c cs) = case S.find f c of
            Nothing -> find' cs
            Just w  -> Just w
{-# INLINE find #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
findIndices k cs0 = findIndices' 0 cs0
  where findIndices' _ Empty        = []
        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
                             ++ findIndices' (n + fromIntegral (S.length c)) cs

-- ---------------------------------------------------------------------
-- Searching ByteStrings

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem w cs = not (elem w cs)

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString
filter p s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = chunk (S.filter p x) (go xs)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single byte. It is more
-- efficient to use /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
{-# INLINE filterByte #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
  filter ((==) x) = filterByte x

"ByteString specialise filter (== x)" forall x.
 filter (== x) = filterByte x
  #-}
-}

{-
-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
-}

-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- the pair of ByteStrings with elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p bs == (filter p xs, filter (not . p) xs)
--
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition f p = (filter f p, filter (not . f) p)
--TODO: use a better implementation

-- ---------------------------------------------------------------------
-- Searching for substrings

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool
isPrefixOf Empty _  = True
isPrefixOf _ Empty  = False
isPrefixOf (Chunk x xs) (Chunk y ys)
    | S.length x == S.length y = x == y  && isPrefixOf xs ys
    | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
    | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
  where (xh,xt) = S.splitAt (S.length y) x
        (yh,yt) = S.splitAt (S.length x) y

-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.
--
-- The following holds:
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf x y = reverse x `isPrefixOf` reverse y
--TODO: a better implementation

-- ---------------------------------------------------------------------
-- Zipping

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip = zipWith (,)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith _ Empty     _  = []
zipWith _ _      Empty = []
zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
  where
    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys

    to x Empty         _ _             | S.null x       = []
    to _ _             y Empty         | S.null y       = []
    to x xs            y ys            | not (S.null x)
                                      && not (S.null y) = go x  xs y  ys
    to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys

-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
{-# INLINE unzip #-}

-- ---------------------------------------------------------------------
-- Special lists

-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits = (Empty :) . inits'
  where inits' Empty        = []
        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
                           ++ L.map (Chunk c) (inits' cs)

-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails :: ByteString -> [ByteString]
tails Empty         = Empty : []
tails cs@(Chunk c cs')
  | S.length c == 1 = cs : tails cs'
  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')

-- ---------------------------------------------------------------------
-- Low level constructors

-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example
--   if a large string has been read in, and only a small part of it
--   is needed in the rest of the program.
copy :: ByteString -> ByteString
copy cs = foldrChunks (Chunk . S.copy) Empty cs
--TODO, we could coalese small blocks here
--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.

-- ---------------------------------------------------------------------

-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString

-- ---------------------------------------------------------------------
-- Lazy ByteString IO
--
-- Rule for when to close: is it expected to read the whole file?
-- If so, close when done.
--

-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block
-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
-- available then they will be returned immediately as a smaller chunk.
--
-- The handle is closed on EOF.
--
-- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
-- work correctly.
--
hGetContentsN :: Int -> Handle -> IO ByteString
hGetContentsN k h = lazyRead -- TODO close on exceptions
  where
    lazyRead = unsafeInterleaveIO loop

    loop = do
        c <- S.hGetSome h k -- only blocks if there is no data available
        if S.null c
          then do hClose h >> return Empty
          else do cs <- lazyRead
                  return (Chunk c cs)

-- | Read @n@ bytes into a 'ByteString', directly from the
-- specified 'Handle', in chunks of size @k@.
--
hGetN :: Int -> Handle -> Int -> IO ByteString
hGetN k h n | n > 0 = readChunks n
  where
    readChunks !i = do
        c <- S.hGet h (min k i)
        case S.length c of
            0 -> return Empty
            m -> do cs <- readChunks (i - m)
                    return (Chunk c cs)

hGetN _ _ 0 = return Empty
hGetN _ h n = illegalBufferSize h "hGet" n

-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available. Chunks are read on demand, in @k@-sized chunks.
--
hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
hGetNonBlockingN k h n | n > 0= readChunks n
  where
    readChunks !i = do
        c <- S.hGetNonBlocking h (min k i)
        case S.length c of
            0 -> return Empty
            m -> do cs <- readChunks (i - m)
                    return (Chunk c cs)

hGetNonBlockingN _ _ 0 = return Empty
hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n

illegalBufferSize :: Handle -> String -> Int -> IO a
illegalBufferSize handle fn sz =
    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
    where
      msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []

-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, using the default chunk size.
--
-- Once EOF is encountered, the Handle is closed.
--
-- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContents' to
-- work correctly.
--
hGetContents :: Handle -> IO ByteString
hGetContents = hGetContentsN defaultChunkSize

-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
--
hGet :: Handle -> Int -> IO ByteString
hGet = hGetN defaultChunkSize

-- | hGetNonBlocking is similar to 'hGet', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available.  If there is no data available to be read, 'hGetNonBlocking'
-- returns 'empty'.
--
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hGet'.
--
hGetNonBlocking :: Handle -> Int -> IO ByteString
hGetNonBlocking = hGetNonBlockingN defaultChunkSize

-- | Read an entire file /lazily/ into a 'ByteString'.
-- The Handle will be held open until EOF is encountered.
--
readFile :: FilePath -> IO ByteString
readFile f = openBinaryFile f ReadMode >>= hGetContents

-- | Write a 'ByteString' to a file.
--
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)

-- | Append a 'ByteString' to a file.
--
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)

-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
--
getContents :: IO ByteString
getContents = hGetContents stdin

-- | Outputs a 'ByteString' to the specified 'Handle'.
--
hPut :: Handle -> ByteString -> IO ()
hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs

-- | Similar to 'hPut' except that it will never block. Instead it returns
-- any tail that did not get written. This tail may be 'empty' in the case that
-- the whole string was written, or the whole original string if nothing was
-- written. Partial writes are also possible.
--
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hPut'.
--
hPutNonBlocking :: Handle -> ByteString -> IO ByteString
hPutNonBlocking _ Empty           = return Empty
hPutNonBlocking h bs@(Chunk c cs) = do
  c' <- S.hPutNonBlocking h c
  case S.length c' of
    l' | l' == S.length c -> hPutNonBlocking h cs
    0                     -> return bs
    _                     -> return (Chunk c' cs)

-- | A synonym for @hPut@, for compatibility
--
hPutStr :: Handle -> ByteString -> IO ()
hPutStr = hPut

-- | Write a ByteString to stdout
putStr :: ByteString -> IO ()
putStr = hPut stdout

-- | Write a ByteString to stdout, appending a newline byte
--
putStrLn :: ByteString -> IO ()
putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)

{-# DEPRECATED putStrLn
    "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
  #-}

-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device.
--
interact :: (ByteString -> ByteString) -> IO ()
interact transformer = putStr . transformer =<< getContents

-- ---------------------------------------------------------------------
-- Internal utilities

-- Common up near identical calls to `error' to reduce the number
-- constant strings created when compiled:
errorEmptyList :: String -> a
errorEmptyList fun = moduleError fun "empty ByteString"

moduleError :: String -> String -> a
moduleError fun msg = error ("Data.Vector.Storable.ByteString.Lazy." ++ fun ++ ':':' ':msg)


-- reverse a list of non-empty chunks into a lazy ByteString
revNonEmptyChunks :: [P.ByteString] -> ByteString
revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs

-- reverse a list of possibly-empty chunks into a lazy ByteString
revChunks :: [P.ByteString] -> ByteString
revChunks cs = L.foldl' (flip chunk) Empty cs

-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd :: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEnd k v = S.inlinePerformIO $ withForeignPtr fp $ \f -> go f 0
  where
    (fp, l) = VS.unsafeToForeignPtr0 v

    go !ptr !n | n >= l    = return l
               | otherwise = do w <- peek ptr
                                if k w
                                  then return n
                                  else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-incomplete-patterns
                -fno-warn-orphans
  #-}

-- |
-- |-- Module      : Data.Vector.Storable.ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006-- Module      : Data.Vector.Storable.ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006--               (c) Duncan Coutts 2006
--               (c) Bas van Dijk 2011--               (c) Duncan Coutts 2006
-- License     : BSD-style--               (c) Bas van Dijk 2011
---- License     : BSD-style
---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Portability : portable-- Stability   : experimental
---- Portability : portable
---- A time and space-efficient implementation of lazy byte vectors
-- A time and space-efficient implementation of lazy byte vectors-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
-- requirements. Byte vectors are encoded as lazy lists of strict 'Word8'
-- without requiring the entire vector be resident in memory.-- arrays of bytes. They provide a means to manipulate large byte vectors
---- without requiring the entire vector be resident in memory.
---- Some operations, such as concat, append, reverse and cons, have
-- Some operations, such as concat, append, reverse and cons, have-- better complexity than their "Data.ByteString" equivalents, due to
-- better complexity than their "Data.ByteString" equivalents, due to-- optimisations resulting from the list spine structure. And for other
-- operations lazy ByteStrings are usually within a few percent of-- optimisations resulting from the list spine structure. And for other
-- operations lazy ByteStrings are usually within a few percent of-- strict ones, but with better heap usage. For data larger than the
-- available memory, or if you have tight memory constraints, this-- strict ones, but with better heap usage. For data larger than the
-- available memory, or if you have tight memory constraints, this-- module will be the only option. The default chunk size is 64k, which
-- should be good in most circumstances. For people with large L2-- module will be the only option. The default chunk size is 64k, which
-- caches, you may want to increase this to fit your cache.-- should be good in most circumstances. For people with large L2
---- caches, you may want to increase this to fit your cache.
---- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
---- clashes with "Prelude" functions.  eg.
---- > import qualified Data.Vector.Storable.ByteString.Lazy as B
---- > import qualified Data.Vector.Storable.ByteString.Lazy as B
---- Original GHC implementation by Bryan O\'Sullivan.
-- Original GHC implementation by Bryan O\'Sullivan.-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
-- by David Roundy.-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
-- by David Roundy.-- Polished and extended by Don Stewart.
-- Polished and extended by Don Stewart.-- Lazy variant by Duncan Coutts and Don Stewart.
---- Lazy variant by Duncan Coutts and Don Stewart.
--
module Data.Vector.Storable.ByteString.Lazy (
module Data.Vector.Storable.ByteString.Lazy (
        -- * The @ByteString@ type
        ByteString-- * The @ByteString@ type,             -- instances: Eq, Ord, Show, Read, Data, Typeable
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable
        -- * Introducing and eliminating 'ByteString's
        empty-- * Introducing and eliminating 'ByteString's,                  -- :: ByteString
        emptysingleton,   ,              -- :: ByteString-- :: Word8   -> ByteString
        singletonpack,    ,              -- :: Word8   -> ByteString
        packunpack, ,                 -- :: [Word8] -> ByteString
        unpackfromChunks,   ,             -- :: ByteString -> [Word8]-- :: [Strict.ByteString] -> ByteString
        fromChunkstoChunks, ,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]
        -- * Basic interface
        cons-- * Basic interface,                   -- :: Word8 -> ByteString -> ByteString
        conscons',,                  -- :: Word8 -> ByteString -> ByteString
        cons'snoc,,                  -- :: Word8 -> ByteString -> ByteString
        snocappend, ,                 -- :: ByteString -> Word8 -> ByteString-- :: ByteString -> ByteString -> ByteString
        appendhead, ,                 -- :: ByteString -> Word8-- :: ByteString -> ByteString -> ByteString
        headuncons, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
        unconslast, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
        last,                   -- :: ByteString -> Word8-- :: ByteString -> ByteString
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> Bool-- :: ByteString -> ByteString
        nulllength, ,                 -- :: ByteString -> Bool-- :: ByteString -> Int64
        length,                 -- :: ByteString -> Int64
        -- * Transforming ByteStrings
        map-- * Transforming ByteStrings,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        mapreverse,   ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverseintersperse,   ,            -- :: ByteString -> ByteString-- :: Word8 -> ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString-- :: ByteString -> [ByteString] -> ByteString
        intercalatetranspose, ,            -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]
        -- * Reducing 'ByteString's (folds)
        foldl-- * Reducing 'ByteString's (folds),                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldlfoldl',,                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1foldl1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1'foldr, ,                -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldrfoldr1,,                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        -- ** Special folds
        concat-- ** Special folds,                 -- :: [ByteString] -> ByteString
        concatconcatMap,  ,              -- :: [ByteString] -> ByteString-- :: (Word8 -> ByteString) -> ByteString -> ByteString
        concatMapany,     ,              -- :: (Word8 -> Bool) -> ByteString -> Bool-- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        allmaximum,   ,                -- :: ByteString -> Word8-- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8
        -- * Building ByteStrings
        -- ** Scans-- * Building ByteStrings
        scanl-- ** Scans,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
        -- ** Accumulating maps
        mapAccumL-- ** Accumulating maps,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        -- ** Infinite ByteStrings
        repeat-- ** Infinite ByteStrings,                 -- :: Word8 -> ByteString
        repeatreplicate,  ,              -- :: Word8 -> ByteString-- :: Int64 -> Word8 -> ByteString
        replicatecycle,   ,              -- :: ByteString -> ByteString-- :: Int64 -> Word8 -> ByteString
        cycleiterate, ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> Word8 -> ByteString
        iterate,                -- :: (Word8 -> Word8) -> Word8 -> ByteString
        -- ** Unfolding ByteStrings
        unfoldr-- ** Unfolding ByteStrings,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
        -- * Substrings
        -- * Substrings
        -- ** Breaking strings
        take-- ** Breaking strings,                   -- :: Int64 -> ByteString -> ByteString
        take,                   -- :: Int64 -> ByteString -> ByteString
        dropsplitAt,  ,                -- :: Int64 -> ByteString -> ByteString-- :: Int64 -> ByteString -> (ByteString, ByteString)
        splitAttakeWhile, ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhilespan,    ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        spanbreak,,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        groupgroupBy, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        groupByinits, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]
        -- ** Breaking into many substrings
        split-- ** Breaking into many substrings,                  -- :: Word8 -> ByteString -> [ByteString]
        splitsplitWith,   ,              -- :: Word8 -> ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]
        -- * Predicates
        isPrefixOf-- * Predicates,             -- :: ByteString -> ByteString -> Bool
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
--        isInfixOf,              -- :: ByteString -> ByteString -> Bool,             -- :: ByteString -> ByteString -> Bool
--        isInfixOf,              -- :: ByteString -> ByteString -> Bool
        -- ** Search for arbitrary substrings
--        isSubstringOf,          -- :: ByteString -> ByteString -> Bool-- ** Search for arbitrary substrings
--        isSubstringOf,          -- :: ByteString -> ByteString -> Bool--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
--        findSubstrings,         -- :: ByteString -> ByteString -> [Int]--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
--        findSubstrings,         -- :: ByteString -> ByteString -> [Int]
        -- * Searching ByteStrings
        -- * Searching ByteStrings
        -- ** Searching by equality
        elem-- ** Searching by equality,                   -- :: Word8 -> ByteString -> Bool
        elemnotElem,  ,                -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool
        -- ** Searching with a predicate
        find-- ** Searching with a predicate,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        findfilter, ,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filterpartition,  ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        -- * Indexing ByteStrings
        index-- * Indexing ByteStrings,                  -- :: ByteString -> Int64 -> Word8
        indexelemIndex,   ,              -- :: ByteString -> Int64 -> Word8-- :: Word8 -> ByteString -> Maybe Int64
        elemIndexelemIndices, ,            -- :: Word8 -> ByteString -> [Int64]-- :: Word8 -> ByteString -> Maybe Int64
        elemIndicesfindIndex, ,            -- :: Word8 -> ByteString -> [Int64]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndexfindIndices, ,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndicescount,     ,            -- :: Word8 -> ByteString -> Int64-- :: (Word8 -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Word8 -> ByteString -> Int64
        -- * Zipping and unzipping ByteStrings
        zip-- * Zipping and unzipping ByteStrings,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipzipWith,   ,                -- :: ByteString -> ByteString -> [(Word8,Word8)]-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        zipWithunzip, ,                -- :: [(Word8,Word8)] -> (ByteString,ByteString)-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)
        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString-- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString
        -- * Low level conversions
        -- ** Copying ByteStrings-- * Low level conversions
        copy-- ** Copying ByteStrings,                   -- :: ByteString -> ByteString
--        defrag,                -- :: ByteString -> ByteString,                   -- :: ByteString -> ByteString
--        defrag,                -- :: ByteString -> ByteString
        -- * I\/O with 'ByteString's
        -- * I\/O with 'ByteString's
        -- ** Standard input and output
        getContents-- ** Standard input and output,            -- :: IO ByteString
        getContentsputStr,    ,            -- :: IO ByteString-- :: ByteString -> IO ()
        putStrputStrLn, ,               -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()
        -- ** Files
        readFile-- ** Files,               -- :: FilePath -> IO ByteString
        readFilewriteFile,,              -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
        writeFileappendFile,,             -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
        -- ** I\/O with Handles
        hGetContents-- ** I\/O with Handles,           -- :: Handle -> IO ByteString
        hGetContentshGet,       ,           -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
        hGethGetNonBlocking,          ,        -- :: Handle -> Int -> IO ByteString
        hGetNonBlockinghPut,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
        hPuthPutNonBlocking,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        hPutNonBlockinghPutStr,       ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
  ) where
  ) where
import Prelude hiding
import(reversePrelude,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
    (reverseconcat,,anyhead,take,tail,drop,last,splitAt,init,null,takeWhile,length,,dropWhilemap,lines,,spanfoldl,break,foldr,elem,unlines,filter,maximum
    ,concatminimum,any,all,take,concatMap,drop,splitAt,foldl1,takeWhilefoldr1,scanl,dropWhile, scanl1,span, scanr,break, scanr1,elem,filter,maximum
    ,minimumrepeat,,allcycle,concatMap, interact,foldl1, iterate,foldr1,readFile,scanl,writeFile, scanr,appendFile, scanr1,replicate
    ,repeatgetContents, cycle,getLine, interact,putStr, iterate,putStrLn,readFile,zip,,zipWithwriteFile,unzip,appendFile,notElem,replicate
    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)
import qualified Data.List              as L  -- L for list/lazy
import qualified Data.ListData.Vector.Storable.ByteStringas L  -- L for list/lazyas P  (ByteString) -- type name only
import qualified Data.Vector.Storable.ByteString        as P  (-- S for strict (hmm...)ByteString) -- type name only
import qualified Data.Vector.Storable.ByteStringData.Vector.Storable.ByteString.InternalasasS S-- S for strict (hmm...)
import qualified Data.Vector.Storable.ByteString.InternalData.Vector.Storable.ByteString.Unsafe asasS S
import qualifiedData.Vector.Storable.ByteString.Lazy.InternalData.Vector.Storable.ByteString.Unsafe as S
import Data.Vector.Storable.ByteString.Lazy.Internal
import Data.Monoid              (Monoid(..))
import Data.Monoid              (Monoid(..))
import Data.Word                (Word8)
import Data.WordData.Int                 (Word8)
import Data.IntSystem.IO                (Int64Handle),stdin,stdout,openBinaryFile,IOMode(..)
import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
import System.IO.Error          ,hClosemkIOError)  , illegalOperationErrorType)
import System.IO.ErrorSystem.IO.Unsafe         (mkIOError, illegalOperationErrorType)
import System.IO.UnsafeControl.Exception        (bracket)
import Control.Exception        (bracket)
import Foreign.ForeignPtr       (withForeignPtr)
import Foreign.ForeignPtrForeign.Ptr              (withForeignPtr)
import Foreign.PtrForeign.Storable
import Foreign.Storable
-- from vector:
import-- from vector:qualified Data.Vector.Storable as VS
import( unsafeToForeignPtr0qualified Data.Vector.Storable, unsafeToForeignPtr0as VS    )
    ( unsafeToForeignPtr0, unsafeToForeignPtr0 )

-- -----------------------------------------------------------------------------
-- -----------------------------------------------------------------------------
instance Eq  ByteString
instancewhereEq(==ByteString)    = eq
    where (==)    = eq
instance Ord ByteString
instancewhereOrdcompare= cmp
    where compare = cmp
instance Monoid ByteString where
instancemempty= empty where
    memptymappend = emptyappend
    mappend = append
    mconcat = concat
eq :: ByteString -> ByteString -> Bool
eq ::EmptyEmpty = ->True -> Bool
eq Empty Empty_     = TrueFalse
eq Empty_     _Empty = False
eq _ChunkEmptya as)=(False b bs) =
eqcaseChunkcompare as)((S.lengthChunk b bsa))(=S.length b) of
  caseLT compare-> a == (S.lengthS.take (S.length) (S.lengtha) b)b)&&ofeq as (Chunk (S.drop (S.length a) b) bs)
    LT -> a == (S.take (S.length a) b) && eq as (bsChunk (S.drop (S.length a) b) bs)
    EQ -> aS.take b  (S.length b) a) == b && eq as(Chunk  (S.drop (S.length b) a) as) bs
    GT -> (S.take (S.length b) a) == b && eq (Chunk (S.drop (S.length b) a) as) bs
cmp :: ByteString -> ByteString -> Ordering
cmp ::EmptyEmpty = -> ByteString -> Ordering
cmp Empty Empty_     = EQ
cmp Empty_     _Empty = LT
cmp _ChunkEmptya as)=(GTChunk b bs) =
cmpcaseChunkcompare as)S.lengthChunk babs) )S.length=       b) of
  caseLT compare-> case (compareS.lengtha a)S.takeS.length(S.length) ofa) b) of
    LT -> caseEQ compare-> cmp (S.takeas (ChunkS.length(S.dropa)S.length) of   a) b) bs)
            EQresult -> cmpresult (Chunk (S.drop (S.length a) b) bs)
    EQ -> casecompare resulta b of
    EQ -> caseEQ compare-> cmp basofbs
            EQresult -> cmpresult bs
    GT -> casecompare result(S.take (S.length b) a) b of
    GT -> caseEQ compare-> cmpS.take(ChunkS.length(S.drop b)S.length) b ofb) a) as) bs
            EQresult -> cmpresultChunk (S.drop (S.length b) a) as) bs
            result -> result
-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's
-- | /O(1)/ The empty 'ByteString'
empty-- | /O(1)/ The empty 'ByteString':: ByteString
empty ::= Empty
empty{-# INLINE= Emptyempty #-}
{-# INLINE empty #-}
-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton-- | /O(1)/ Convert a 'Word8' into a 'ByteString':: Word8 -> ByteString
singleton ::w =Word8Chunk->(S.singleton w) Empty
singleton{-# INLINEwsingleton= Chunk (S.singleton#-}         w) Empty
{-# INLINE singleton #-}
-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.
pack-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.:: [Word8] -> ByteString
pack :: [Word8L.foldr] ->(ByteStringChunk . S.pack) Empty (chunks defaultChunkSize ws)
packwhere = L.foldr (Chunk . S.pack) Empty (chunks defaultChunkSize ws)
  wherechunks :: Int -> [a] -> [[a]]
    chunks ::_  Int[]->= [a] -> [[a]]
    chunks _size [xs] = [case]   L.splitAt size xs of
    chunks size xs = case(xs'L.splitAt, xs'') ->sizexs' xs: chunksof    size xs''
                      (xs', xs'') -> xs' : chunks size xs''
-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.:: ByteString -> [Word8]
unpack :: ByteString= L.concatMap-> [S.unpackWord8]  (toChunks cs)
unpack--TODO: we can do better here by integrating the concat with the unpack = L.concatMap S.unpack (toChunks cs)
--TODO: we can do better here by integrating the concat with the unpack
-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString'
fromChunks-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString':: [P.ByteString] -> ByteString
fromChunks :: [P.ByteStringL.foldr chunk] ->Emptycs
fromChunks cs = L.foldr chunk Empty cs
-- | /O(n)/ Convert a lazy 'ByteString' into a list of strict 'ByteString'
toChunks-- | /O(n)/ Convert a lazy 'ByteString' into a list of strict 'ByteString':: ByteString -> [P.ByteString]
toChunks :: ByteString= foldrChunks-> [P.ByteString:) [] cs    ]
toChunks cs = foldrChunks (:) [] cs
------------------------------------------------------------------------
------------------------------------------------------------------------
{-
-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}
-}
-- ---------------------------------------------------------------------
-- Basic interface-- ---------------------------------------------------------------------
-- Basic interface
-- | /O(1)/ Test whether a ByteString is empty.
null-- | /O(1)/ Test whether a ByteString is empty.:: ByteString -> Bool
null ::Empty= True  -> Bool
null Empty_     = TrueFalse
null{-# INLINE     =null#-}
{-# INLINE null #-}
-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64'
length-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64':: ByteString -> Int64
length :: ByteString= foldlChunks-> Int64(\n c -> n + fromIntegral (S.length c)) 0 cs
length{-# INLINE =length#-}   (\n c -> n + fromIntegral (S.length c)) 0 cs
{-# INLINE length #-}
-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
---- | /O(1)/ 'cons' is analogous to '(:)' for lists.
--cons :: Word8 -> ByteString -> ByteString
cons ::c cs= Chunk-> ByteString(S.singleton-> ByteStringc) cs
cons{-# INLINE cs =cons#-}S.singleton c) cs
{-# INLINE cons #-}
-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- | /O(1)/ Unlike 'cons', 'cons\'' is-- strict in the ByteString that we are consing onto. More precisely, it forces
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- may coalesce the new byte onto the first \'chunk\' rather than starting a-- the head and the first chunk. It does this because, for space efficiency, it
-- new \'chunk\'.-- may coalesce the new byte onto the first \'chunk\' rather than starting a
---- new \'chunk\'.
---- So that means you can't use a lazy recursive contruction like this:
---- So that means you can't use a lazy recursive contruction like this:
---- > let xs = cons\' c xs in xs
---- > let xs = cons\' c xs in xs
---- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
---- infinite lazy ByteStrings.
--cons' :: Word8 -> ByteString -> ByteString
cons' ::w (Word8 ->c cs) | S.length-> ByteStringc < 16 = Chunk (S.cons w c) cs
cons' w (csChunk c cs) | S.length c < 16 = Chunk (S.consS.singleton c) csw) cs
cons'{-# INLINE cs cons' #-}                   = Chunk (S.singleton w) cs
{-# INLINE cons' #-}
-- | /O(n\/c)/ Append a byte to the end of a 'ByteString'
snoc-- | /O(n\/c)/ Append a byte to the end of a 'ByteString':: ByteString -> Word8 -> ByteString
snoc :: ByteStringw = foldrChunks-> Word8Chunk->(ByteStringsingleton w) cs
snoc{-# INLINE w =snoc#-}     Chunk (singleton w) cs
{-# INLINE snoc #-}
-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.:: ByteString -> Word8
head ::Empty= ->errorEmptyList       "head"
head Empty(Chunk c _) = errorEmptyListS.unsafeHead c "head"
head{-# INLINEChunkhead _)#-}= S.unsafeHead c
{-# INLINE head #-}
-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
uncons-- if it is empty.:: ByteString -> Maybe (Word8, ByteString)
uncons ::Empty= Nothing-> Maybe (Word8, ByteString)
uncons Empty(Chunk=cNothingcs)
uncons= JustChunk(S.unsafeHead cs)      c,
    = Just (S.unsafeHeadif S.length cc,== 1 then cs else Chunk (S.unsafeTail c) cs)
{-# INLINE uncons S.length#-}   c == 1 then cs else Chunk (S.unsafeTail c) cs)
{-# INLINE uncons #-}
-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
-- non-empty.-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
tail-- non-empty.:: ByteString -> ByteString
tail ::Empty ->= ByteStringerrorEmptyList "tail"
tail Empty(Chunk c cs)   = errorEmptyList "tail"
tail| S.lengthChunk cccs==) 1 = cs
  | S.lengthotherwisec == 1 = csChunk (S.unsafeTail c) cs
{-# INLINE otherwisetail #-} = Chunk (S.unsafeTail c) cs
{-# INLINE tail #-}
-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
-- and non-empty.-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
last-- and non-empty.:: ByteString -> Word8
last ::Empty ->= Word8errorEmptyList "last"
last Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "last"
lastwhereChunkgo cc0Empty) = go c0= cs0S.last c
  where go c Empty(Chunk c cs) = S.lastgo c csc
-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet) _ (Chunk c cs) = go c cs
-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)
-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.
init-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.:: ByteString -> ByteString
init ::Empty ->= ByteStringerrorEmptyList "init"
init Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "init"
initwhereChunkgo cc0Empty)|=S.length c0 cs0c == 1 = Empty
  where go c Empty | S.lengthotherwisec == 1 = Empty (S.init c) Empty
        go c (Chunk|c'cs)           = Chunk (S.init(go c'c)csEmpty)
        go c (Chunk c' cs)           = Chunk c (go c' cs)
-- | /O(n\/c)/ Append two ByteStrings
append-- | /O(n\/c)/ Append two ByteStrings:: ByteString -> ByteString -> ByteString
append :: ByteStringys = foldrChunks-> ByteStringChunk ys->xsByteString
append{-# INLINE ysappend= foldrChunks#-}      Chunk ys xs
{-# INLINE append #-}
-- ---------------------------------------------------------------------
-- Transformations-- ---------------------------------------------------------------------
-- Transformations
-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@.-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
map-- element of @xs@.:: (Word8 -> Word8) -> ByteString -> ByteString
map ::f s(Word8= go s-> Word8) -> ByteString -> ByteString
map fwhere = go s
    wherego Empty        = Empty
        go Empty(Chunk x xs) = Empty y ys
        go (Chunk x xs) = Chunk y ys
            wherey  = S.map f x
                yys = S.mapgo xs f x
{-# INLINE map #-} = go xs
{-# INLINE map #-}
-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
reverse-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.:: ByteString -> ByteString
reverse ::cs0ByteString= rev Empty->cs0
reversewhere cs0    = revEmpty cs0= a
  where rev a Empty(Chunk c cs) = arev (Chunk (S.reverse c) a) cs
{-# INLINEreverse (Chunk#-} cs) = rev (Chunk (S.reverse c) a) cs
{-# INLINE reverse #-}
-- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and
-- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and-- \`intersperses\' that byte between the elements of the 'ByteString'.
-- It is analogous to the intersperse function on Lists.-- \`intersperses\' that byte between the elements of the 'ByteString'.
intersperse-- It is analogous to the intersperse function on Lists.:: Word8 -> ByteString -> ByteString
intersperse ::_ Empty -> ByteString= Empty -> ByteString
intersperse _ Empty(Chunk c cs) = Empty (S.intersperse w c)
intersperse w (Chunk c cs) = Chunk (S.interspersefoldrChunks (Chunk c) . intersperse') Empty cs)
  where intersperse' :: P.ByteStringfoldrChunks-> P.ByteStringChunk . intersperse') Empty cs)
  where intersperse' ::v =P.ByteString -> P.ByteString
        intersperse'S.unsafeCreate = (2*l) $ \p' -> withForeignPtr fp $ \p -> do
          S.unsafeCreatepoke p' w    (2*l) $ \p' -> withForeignPtr fp $ \p -> do
            pokeS.c_intersperse w       (p' `plusPtr` 1) p (fromIntegral l) w
            S.c_interspersewhere         (p' `plusPtr` 1) p (fromIntegral l) w
              where(fp, l) = VS.unsafeToForeignPtr0 v
                 (fp, l) = VS.unsafeToForeignPtr0 v
-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.-- | The 'transpose' function transposes the rows and columns of its
transpose-- 'ByteString' argument.:: [ByteString] -> [ByteString]
transpose ::css[ByteString= L.map (\]ss->->[ByteStringChunk (S.pack]   ss) Empty)
transpose css = L.map (\L.transposess -> Chunk((L.mapS.packunpack) Emptycss))
--TODO: make this fast(L.transpose (L.map unpack css))
--TODO: make this fast
-- ---------------------------------------------------------------------
-- Reducing 'ByteString's-- ---------------------------------------------------------------------
-- Reducing 'ByteString's
-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the-- | 'foldl', applied to a binary operator, a starting value (typically
-- ByteString using the binary operator, from left to right.-- the left-identity of the operator), and a ByteString, reduces the
foldl-- ByteString using the binary operator, from left to right.:: (a -> Word8 -> a) -> a -> ByteString -> a
foldl ::f z(a -> Word8z     -> a) -> a -> ByteString -> a
foldlwhere zgo=agoEmpty          = a
  where go a Empty(Chunk c cs) = ago (S.foldl f a c) cs
{-# INLINE afoldlChunk#-}c cs) = go (S.foldl f a c) cs
{-# INLINE foldl #-}
-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
foldl'-- | 'foldl\'' is like 'foldl', but strict in the accumulator.:: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' ::f z(a -> Word8z     -> a) -> a -> ByteString -> a
foldl'wherefgo = go_ |za `seq` False = undefined
  where go a _Empty a `seq` False= a  = undefined
        go a Empty(Chunk c cs) = ago (S.foldl f a c) cs
{-# INLINE afoldl'Chunk#-} cs) = go (S.foldl f a c) cs
{-# INLINE foldl' #-}
-- | 'foldr', applied to a binary operator, a starting value
-- | 'foldr', applied to a binary operator, a starting value-- (typically the right-identity of the operator), and a ByteString,
-- (typically the right-identity of the operator), and a ByteString,-- reduces the ByteString using the binary operator, from right to left.
foldr-- reduces the ByteString using the binary operator, from right to left.:: (Word8 -> a -> a) -> a -> ByteString -> a
foldr ::k z(Word8cs = foldrChunks-> a -> a) ->(flip ->(S.foldrk)) ->z cs
foldr{-# INLINE z csfoldr= foldrChunks#-}       (flip (S.foldr k)) z cs
{-# INLINE foldr #-}
-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- | 'foldl1' is a variant of 'foldl' that has no starting value-- argument, and thus must be applied to non-empty 'ByteStrings'.
-- This function is subject to array fusion.-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1-- This function is subject to array fusion.:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 ::_ EmptyWord8 -> Word8= errorEmptyList-> Word8) -> ByteString"foldl1"   -> Word8
foldl1 _ Empty(Chunk c cs) = errorEmptyListfoldl f (S.unsafeHeadc) (Chunk (S.unsafeTail c) cs)
foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1'-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' ::_ EmptyWord8 -> Word8= errorEmptyList-> Word8) -> ByteString"foldl1'"  -> Word8
foldl1' _ Empty(Chunk c cs) = errorEmptyListfoldl' f (S.unsafeHeadc) (Chunk (S.unsafeTail c) cs)
foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)
-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
foldr1-- and thus must be applied to non-empty 'ByteString's:: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 ::_ EmptyWord8 -> Word8= ->errorEmptyList) -> ByteString"foldr1" -> Word8
foldr1 _ Empty(Chunk c0 cs0) = errorEmptyListgo c0 cs0      "foldr1"
foldr1wherefgoChunkc Empty cs0) = go= c0S.foldr1   f c
  where go c Empty(Chunk c' cs) = S.foldr1S.foldr  f cgo c' cs) c
        go c (Chunk c' cs) = S.foldr  f (go c' cs) c
-- ---------------------------------------------------------------------
-- Special folds-- ---------------------------------------------------------------------
-- Special folds
-- | /O(n)/ Concatenate a list of ByteStrings.
concat-- | /O(n)/ Concatenate a list of ByteStrings.:: [ByteString] -> ByteString
concat ::css0ByteString= to css0] -> ByteString
concatwherecss0 = to css0
  wherego Empty        css = to css
    go Empty(Chunk c cs) css = toChunkc (go cs css)
    go (Chunk]     c cs) css = Chunk c (go cs css)
    to []cs:css)         = Emptygo cs css
    to (cs:css)         = go cs css
-- | Map a function over a 'ByteString' and concatenate the results
concatMap-- | Map a function over a 'ByteString' and concatenate the results:: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap ::_ EmptyWord8 -> ByteString= Empty ) -> ByteString -> ByteString
concatMap _ Empty(Chunk c0 cs0= Empty= to c0 cs0
concatMapwhere   f (Chunk c0 cs0) = to c0 cs0
  wherego :: ByteString -> P.ByteString -> ByteString -> ByteString
    go ::Emptyc'->cs'= to c' cs'-> ByteString -> ByteString
    go Empty(Chunk c cs) c' cs' = toChunk cs'c (go cs c' cs')
    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')
    to :: P.ByteString -> ByteString -> ByteString
    to ::c cs| S.null c ->= ByteStringcase cs of -> ByteString
    to cEmpty | S.null c ->= caseEmptycs of
        Empty(Chunk c' cs') -> Emptyto c' cs'
        (Chunk| otherwise cs') ->= to c'(f cs'(S.unsafeHead c)) (S.unsafeTail c) cs
            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs
-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
any-- any element of the 'ByteString' satisfies the predicate.:: (Word8 -> Bool) -> ByteString -> Bool
any ::f csWord8= foldrChunks-> Bool) ->(\cByteStringrest -> S.any-> Boolf c || rest) False cs
any{-# INLINE cs = foldrChunksany #-}     (\c rest -> S.any f c || rest) False cs
{-# INLINE-- todo fuse #-}
-- todo fuse
-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
all-- if all elements of the 'ByteString' satisfy the predicate.:: (Word8 -> Bool) -> ByteString -> Bool
all ::f csWord8= foldrChunks-> Bool) ->(\cByteStringrest -> S.all-> Boolf c && rest) True cs
all{-# INLINE cs = foldrChunksall #-}     (\c rest -> S.all f c && rest) True cs
{-# INLINE-- todo fuse #-}
-- todo fuse
-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString':: ByteString -> Word8
maximum ::Empty=->errorEmptyList        "maximum"
maximum Empty(Chunk c cs) = errorEmptyListfoldlChunks (\n"maximum"c' -> n `max` S.maximum c')
maximum (Chunk c cs) = foldlChunks (\S.maximumn c' -> nc`maxcs` S.maximum c')
{-# INLINE maximum #-}             (S.maximum c) cs
{-# INLINE maximum #-}
-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString':: ByteString -> Word8
minimum ::Empty=->errorEmptyList        "minimum"
minimum Empty(Chunk c cs) = errorEmptyListfoldlChunks (\n"minimum"c' -> n `min` S.minimum c')
minimum (Chunk c cs) = foldlChunks (\nS.minimum -> n `minc) `csS.minimum c')
{-# INLINE minimum #-}               (S.minimum c) cs
{-# INLINE minimum #-}
-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.-- passing an accumulating parameter from left to right, and returning a
mapAccumL-- final value of this accumulator together with the new ByteString.:: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL ::f s0acccs0->= Word8go s0 ->cs0(acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumLwhere   f s0 cs0 = go s0 cs0
  wherego s Empty        = (s, Empty)
    go s Empty(Chunk c cs) = (ss'', Empty, Chunk)  c' cs')
    go swhereChunk(s',cs)c'= (s''= S.mapAccumL, Chunk c' cs'f s)c
        where (s's'',, c'cs')) = S.mapAccumLgo s' cs    f s c
              (s'', cs') = go s' cs
-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.-- passing an accumulating parameter from right to left, and returning a
mapAccumR-- final value of this accumulator together with the new ByteString.:: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR ::f s0acccs0->= Word8go s0 ->cs0(acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumRwhere   f s0 cs0 = go s0 cs0
  wherego s Empty        = (s, Empty)
    go s Empty(Chunk c cs) = (ss'', Empty, Chunk)  c' cs')
    go swhereChunk(s'' cs, )c'= (s''S.mapAccumR, Chunk c'fcs's')c
        where (s''s',,cs') = S.mapAccumRgo s cs     f s' c
              (s', cs') = go s cs
-- ---------------------------------------------------------------------
-- Building ByteStrings-- ---------------------------------------------------------------------
-- Building ByteStrings
-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.-- | 'scanl' is similar to 'foldl', but returns a list of successive
---- reduced values from the left. This function will fuse.
---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---- Note that
---- Note that
---- > last (scanl f z xs) == foldl f z xs.
scanl-- > last (scanl f z xs) == foldl f z xs.:: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl ::f z(Word8= snd ->. foldlk->(zWord8,singleton) -> Word8z)   -> ByteString -> ByteString
scanlwheref z = snd . foldl k (z,singleton z)
 wherek (c,acc) a = let n = f c a in (n, acc `snoc` n)
{-# INLINE (c,accscanl) a =#-} n = f c a in (n, acc `snoc` n)
{-# INLINE scanl #-}
-- ---------------------------------------------------------------------
-- Unfolds and replicates-- ---------------------------------------------------------------------
-- Unfolds and replicates
-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
---- of @f@ to @x@:
---- > iterate f x == [x, f x, f (f x), ...]
---- > iterate f x == [x, f x, f (f x), ...]
--iterate :: (Word8 -> Word8) -> Word8 -> ByteString
iterate ::f =(Word8unfoldr->(Word8\x ->)case-> Word8f x of->x'-> x' `seq` Just (x', x'))
iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))
-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
---- element.
--repeat :: Word8 -> ByteString
repeat ::w =Word8cs where-> ByteStringcs = Chunk (S.replicate smallChunkSize w) cs
repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs
-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
---- the value of every element.
--replicate :: Int64 -> Word8 -> ByteString
replicate ::n wInt64 -> Word8 -> ByteString
replicate| n <=n0w            = Empty
    | n <=< fromIntegral           smallChunkSize= Empty      = Chunk (S.replicate (fromIntegral n) w) Empty
    | n <==fromIntegral0           smallChunkSize= cs -- preserve invariant= Chunk (S.replicate (fromIntegral n) w) Empty
    | rotherwise 0             = csChunk-- preserve invariant(S.unsafeTake (fromIntegral r) c) cs
 where otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
 wherec      = S.replicate smallChunkSize w
    ccs     = S.replicatenChunks q   smallChunkSize w
    cs(q, r) = nChunks q (fromIntegral smallChunkSize)
    (nChunksq, r) =0quotRem= Emptyn (fromIntegral smallChunkSize)
    nChunks 0 = Empty c (nChunks (m-1))
    nChunks m = Chunk c (nChunks (m-1))
-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
-- the infinite repetition of the original ByteString.-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
---- the infinite repetition of the original ByteString.
--cycle :: ByteString -> ByteString
cycle ::Empty= errorEmptyList-> ByteString"cycle"
cycle Emptycs    = errorEmptyListcs' where cs' ="cycle"foldrChunks Chunk cs' cs
cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs
-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- the element and returns 'Nothing' if it is done producing the-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.-- prepending to the ByteString and @b@ is used as the next element in a
unfoldr-- recursive call.:: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr ::f s0a=->unfoldChunk (Word832,s0)) -> a -> ByteString
unfoldrwhere funfoldChunk = unfoldChunkn s =  32 s0
  where unfoldChunkcase S.unfoldrN s = n f s of
          case(c,S.unfoldrNNothing)  n f s of
            (c, NothingS.null )  -> Empty
              | S.nullotherwise  -> Empty c Empty
            (c| otherwiseJust s')  -> Chunk c Empty(unfoldChunk (n*2) s')
            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')
-- ---------------------------------------------------------------------
-- Substrings-- ---------------------------------------------------------------------
-- Substrings
-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
take-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.:: Int64 -> ByteString -> ByteString
take ::i _Int64| i <=->0ByteString= Empty   -> ByteString
take i _cs0 i <= 0 ==Emptytake' i cs0
takewhere cs0take' 0 _  = take' i cs0= Empty
  where take' 0 _Empty        = Empty
        take' _ Empty(Chunk c cs) = Empty
        take'if nn<(ChunkfromIntegral cs) =(S.length c)
          ifthen < fromIntegralChunk (S.take(S.length(fromIntegral)   n) c) Empty
            then Chunk (S.take(take'(fromIntegral(n - fromIntegral) c)(EmptyS.length c)) cs)
            else Chunk c (take' (n - fromIntegral (S.length c)) cs)
-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
drop-- elements, or @[]@ if @n > 'length' xs@.:: Int64 -> ByteString -> ByteString
drop i::p Int64| i <=->0 ByteString= p        -> ByteString
drop i pcs0 i <=drop' =ipcs0
dropwhere cs0drop'= drop'0 cs i cs0     = cs
  where drop' 0 csEmpty        = csEmpty
        drop' _ Empty(Chunk c cs) = Empty
        drop'if nn<(ChunkfromIntegral cs) =(S.length c)
          ifthen < fromIntegralChunk (S.drop(S.length(fromIntegral)   n) c) cs
            then Chunk (S.dropn - fromIntegralfromIntegral(S.length) c) csc)) cs
            else drop' (n - fromIntegral (S.length c)) cs
-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.:: Int64 -> ByteString -> (ByteString, ByteString)
splitAt ::i cs0| i-><=ByteString0 = (Empty->, cs0ByteString)        , ByteString)
splitAt i cs0 | isplitAt' 0 = (Emptycs0 , cs0)
splitAtwhere isplitAt' = splitAt'0 cs    i cs0  = (Empty, cs)
  where splitAt' 0 csEmpty        = (Empty, csEmpty)  )
        splitAt' _ Empty(Chunk c cs) = (Empty, Empty)
        splitAt'if n < nfromIntegralChunk c cs)S.length=       c)
          ifthen < fromIntegral(Chunk (S.takeS.length(fromIntegral)    n) c) Empty
            then (Chunk (S.take (fromIntegral n) c) Emptycs)
            else ,letChunk(cs'S.drop, cs'')(fromIntegral= splitAt' (nn) cfromIntegral) cs)       (S.length c)) cs
            else letin(cs'(Chunk, cs''c )cs'=,splitAt'cs'')   (n - fromIntegral (S.length c)) cs
                   in (Chunk c cs', cs'')

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.-- returns the longest prefix (possibly empty) of @xs@ of elements that
takeWhile-- satisfy @p@.:: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile ::f cs0Word8= takeWhile'-> Bool) ->cs0ByteString -> ByteString
takeWhilewhere takeWhile' cs0 = takeWhile'Empty     cs0= Empty
  where takeWhile' Empty(Chunk c cs) = Empty
        takeWhile'case findIndexOrEndChunk c cs)not=  . f) c of
          case0  findIndexOrEnd (not-> Empty f) c of
            0 | n < S.length c -> Empty (S.take n c) Empty
            n | notherwise S.length c -> Chunk (S.take(takeWhile' c) Emptycs)
              | otherwise      -> Chunk c (takeWhile' cs)
-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.:: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile ::f cs0Word8= dropWhile'-> Bool) ->cs0ByteString -> ByteString
dropWhilewhere dropWhile' cs0 = dropWhile'Empty     cs0= Empty
  where dropWhile' Empty(Chunk c cs) = Empty
        dropWhile'case findIndexOrEndChunk c cs)not=  . f) c of
          casen |findIndexOrEndn < S.length c(not-> Chunk f) cS.dropof    n c) cs
            n | notherwise S.length c -> ChunkdropWhile'S.dropcs n c) cs
              | otherwise      -> dropWhile' cs
-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break ::f cs0Word8= break'-> Boolcs0) -> ByteString -> (ByteString, ByteString)
breakwhere cs0break'= break'Empty cs0    = (Empty, Empty)
  where break' Empty(Chunk c cs) = (Empty, Empty)
        break'case (findIndexOrEndChunk c cs) = f c of
          case0  findIndexOrEnd f-> of(Empty, Chunk c cs)
            0 | n < S.length c -> (Empty,(ChunkS.takecncsc) Empty
            n | n < S.length c -> (Chunk (S.take n c) Emptycs)
              | otherwise      -> ,letChunk(cs'S.drop, cs'')n=c)break')  cs
              | otherwise      -> letin (cs'Chunk, cs''c cs') = break'cs'')  cs
                                   in (Chunk c cs', cs'')
--
---- TODO
---- TODO
---- Add rules
---- Add rules
--
{-
-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
  where breakByte' []     = ([], [])
        breakByte' (x:xs) =
          case P.elemIndex c x of
            Just 0  -> ([], x : xs)
            Just n  -> (P.take n x : [], P.drop n x : xs)
            Nothing -> let (xs', xs'') = breakByte' xs
                        in (x : xs', xs'')

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
  where spanByte' []     = ([], [])
        spanByte' (x:xs) =
          case P.spanByte c x of
            (x', x'') | P.null x'  -> ([], x : xs)
                      | P.null x'' -> let (xs', xs'') = spanByte' xs
                                       in (x : xs', xs'')
                      | otherwise  -> (x' : [], x'' : xs)
-}
-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@-- | 'span' @p xs@ breaks the ByteString into two segments. It is
span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span ::p =(Word8 ->(not. ))-> ByteString -> (ByteString, ByteString)
span p = break (not . p)
-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- | /O(n)/ Splits a 'ByteString' into components delimited by-- separators, where the predicate returns True for a separator element.
-- separators, where the predicate returns True for a separator element.
-- separators result in an empty component in the output.  eg.-- The resulting components do not contain the separators.  Two adjacent
---- separators result in an empty component in the output.  eg.
---- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
---- > splitWith (=='a') []        == []
--splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith ::_ EmptyWord8 -> Bool) ->[] ByteString -> [ByteString]
splitWith _ Empty(Chunk c0 cs0) = [comb]   [] (S.splitWith p c0) cs0
splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0
  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
  where comb ::acc[P.ByteString(s:[]) Empty] -> [P.ByteString= revChunks] ->(s:ByteStringacc) : []  -> [ByteString]
        comb acc (s:[]) Empty(Chunk c cs) = revChunkscomb (s:accs:acc(S.splitWith) : []    p c) cs
        comb acc (s:[ss]) (csChunk c cs) = combrevChunkss:acc():(accS.splitWith) : comb [p css) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
{-# INLINE splitWith #-}
{-# INLINE splitWith #-}
-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
---- argument, consuming the delimiter. I.e.
---- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
---- > split 'x'  "x"          == ["",""]
---- and
---- and
---- > intercalate [c] . split c == id
-- > split == splitWith . (==)-- > intercalate [c] . split c == id
---- > split == splitWith . (==)
---- As for all splitting functions in this library, this function does
-- As for all splitting functions in this library, this function does
-- are slices of the original.-- not copy the substrings, it just constructs new 'ByteStrings' that
---- are slices of the original.
--split :: Word8 -> ByteString -> [ByteString]
split ::_ Empty -> ByteString= []       -> [ByteString]
split _ Empty(Chunk c0 =cs0] = comb [] (S.split w c0) cs0
split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0
  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
  where comb ::acc[P.ByteString(s:[]) Empty] -> [P.ByteString= revChunks] ->(s:ByteStringacc) : []  -> [ByteString]
        comb acc (s:[]) Empty(Chunk c cs) = revChunkscomb (s:accs:acc(S.split) : []w c) cs
        comb acc (s:[ss]) (csChunk c cs) = combrevChunkss:acc():(accS.split) : comb c)]csss cs
{-# INLINEsplit (#-}s:ss) cs           = revChunks (s:acc) : comb [] ss cs
{-# INLINE split #-}
{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = L.filter (not.null) . splitWith f
-}
-- | The 'group' function takes a ByteString and returns a list of
-- | The 'group' function takes a ByteString and returns a list of-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal-- ByteStrings such that the concatenation of the result is equal to the
-- elements.  For example,-- argument.  Moreover, each sublist in the result contains only equal
---- elements.  For example,
---- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
---- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
---- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test.-- It is a special case of 'groupBy', which allows the programmer to
group-- supply their own equality test.:: ByteString -> [ByteString]
group ::Empty ->= [ByteString]         ]
group Empty(Chunk c0 cs0) = [group']     [] (S.group c0) cs0
groupwhereChunk c0 cs0) = group' [] (S.group c0) cs0
  wheregroup' :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
    group' ::acc[P.ByteString(s':_) ss@(s]_->) csP.ByteString] -> ByteString -> [ByteString]
    group'| S.unsafeHead@(s':_)s'@(s:_) cs
     /= S.unsafeHead s's             = revNonEmptyChunks    acc  : group' [] ss cs
    group' S.unsafeHeadacc (s:[])sEmpty        = revNonEmptyChunks (s:acc) : group'[]     [] ss cs
    group' acc (s:[]) Empty(Chunk c cs) = revNonEmptyChunksgroup' (s:acc) (S.groups:acc)):cs]
    group' acc (s:[ss]) (csChunk c cs) = group'revNonEmptyChunkss:acc) (S.group(s:accc):csgroup' [] ss cs
    group' acc (s:ss) cs           = revNonEmptyChunks (s:acc) : group' [] ss cs
{-
TODO: check if something like this might be faster

group :: ByteString -> [ByteString]
group xs
    | null xs   = []
    | otherwise = ys : group zs
    where
        (ys, zs) = spanByte (unsafeHead xs) xs
-}
-- | The 'groupBy' function is the non-overloaded version of 'group'.
---- | The 'groupBy' function is the non-overloaded version of 'group'.
--groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy ::_ EmptyWord8 -> Word8= ->[] Bool) -> ByteString -> [ByteString]
groupBy _ Empty(Chunk c0 cs0) = [groupBy']       [] 0 (S.groupBy k c0) cs0
groupBywhere k (Chunk c0 cs0) = groupBy' [] 0 (S.groupBy k c0) cs0
  wheregroupBy' :: [P.ByteString] -> Word8 -> [P.ByteString] -> ByteString -> [ByteString]
    groupBy' ::acc[P.ByteString(_:_) c ss@(]:->_) Word8cs    -> [P.ByteString] -> ByteString -> [ByteString]
    groupBy'| not (accc `@(_:S.unsafeHead_) c ss@(s:_))cs   = revNonEmptyChunks acc : groupBy' [] 0 ss cs
    groupBy' not (cacck` S.unsafeHead(s:[]) Empty s)     = revNonEmptyChunks acc(s ::acc) : [] [] 0 ss cs
    groupBy' acc _ (s:[]) Empty(Chunk c cs) = revNonEmptyChunksgroupBy' (s:acc) w's(:S.groupBy) : [] c) cs
    groupBy' acc w (s:[]) (Chunk c cs) = groupBy'where w's:accL.null) w' (accS.groupBy= S.unsafeHead c) cs s
                                           where w' | L.nullotherwise = S.unsafeHeadw            s
    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks otherwise(s : acc= w : groupBy' [] 0 ss cs
    groupBy' acc _ (s:ss) cs           = revNonEmptyChunks (s : acc) : groupBy' [] 0 ss cs
{-
TODO: check if something like this might be faster

groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k xs
    | null xs   = []
    | otherwise = take n xs : groupBy k (drop n xs)
    where
        n = 1 + findIndexOrEnd (not . k (head xs)) (tail xs)
-}
-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- argument between each element of the list.-- 'ByteString's and concatenates the list after interspersing the first
intercalate-- argument between each element of the list.:: ByteString -> [ByteString] -> ByteString
intercalate ::s =ByteStringconcat . (->L.intersperseByteString])-> ByteString
intercalate s = concat . (L.intersperse s)
-- ---------------------------------------------------------------------
-- Indexing ByteStrings-- ---------------------------------------------------------------------
-- Indexing ByteStrings
-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
index-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.:: ByteString -> Int64 -> Word8
index ::_  ByteStringi | i < 0  ->= moduleError -> Word8"index" ("negative index: " ++ show i)
index _cs0ii| i < 0  = moduleErrorindex' cs0 i"index" ("negative index: " ++ show i)
indexwhereindex'    Empty= index'n = cs0moduleError       "index" ("index too large: " ++ show n)
  where index' Empty(Chunk c cs)=nmoduleError "index" ("index too large: " ++ show n)
        index'| n >=ChunkfromIntegral cs) n (S.length c) =
          | n >=index'cs (n - fromIntegralS.length c)(=S.length c))
          | otherwise cs (n -=fromIntegralS.unsafeIndexS.lengthc (fromIntegral))     n)
          | otherwise       = S.unsafeIndex c (fromIntegral n)
-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element, or 'Nothing' if there is no such element.-- element in the given 'ByteString' which is equal to the query
-- This implementation uses memchr(3).-- element, or 'Nothing' if there is no such element.
elemIndex-- This implementation uses memchr(3).:: Word8 -> ByteString -> Maybe Int64
elemIndex ::w cs0= elemIndex'-> ByteString0 cs0-> Maybe Int64
elemIndexwhere elemIndex' cs0 = elemIndex'_ Empty   0 cs0= Nothing
  where elemIndex' _ Empty(Chunk c cs) = Nothing
        elemIndex'case S.elemIndex (Chunkwcccsof) =
          caseNothing-> elemIndex' c of (n + fromIntegral (S.length c)) cs
            NothingJust i  -> elemIndex'Just (n + fromIntegraln + fromIntegrali)    (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)
{-
-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    go !p !i | i < 0     = return Nothing
             | otherwise = do ch' <- peekByteOff p i
                              if ch == ch'
                                then return $ Just i
                                else go p (i-1)
-}-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).-- the indices of all elements equal to the query element, in ascending order.
elemIndices-- This implementation uses memchr(3).:: Word8 -> ByteString -> [Int64]
elemIndices ::w cs0= elemIndices'-> ByteString0 ->cs0[Int64]
elemIndiceswhere elemIndices' cs0 = elemIndices'_ Empty     0 cs0= []
  where elemIndices' _ Empty(Chunk c cs) = [L.map]    ((+n).fromIntegral) (S.elemIndices w c)
        elemIndices' n (Chunk++ cselemIndices') = L.map ((+n).fromIntegral)((S.lengthS.elemIndicesc)) csw c)
                             ++ elemIndices' (n + fromIntegral (S.length c)) cs
-- | count returns the number of times its argument appears in the ByteString
---- | count returns the number of times its argument appears in the ByteString
---- > count = length . elemIndices
---- > count = length . elemIndices
---- But more efficiently than using length on the intermediate list.
count-- But more efficiently than using length on the intermediate list.:: Word8 -> ByteString -> Int64
count ::w cs= foldlChunks-> ByteString(\n ->c ->n + fromIntegral (S.count w c)) 0 cs
count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs
-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- satisfying the predicate.-- returns the index of the first element in the ByteString
findIndex-- satisfying the predicate.:: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndex ::k cs0Word8= findIndex'-> Bool) ->0 cs0 -> Maybe Int64
findIndexwhere findIndex' cs0 = findIndex'_ Empty   0 cs0= Nothing
  where findIndex' _ Empty(Chunk c cs) = Nothing
        findIndex'case S.findIndex (Chunkkcccsof) =
          caseNothing-> findIndex' c of (n + fromIntegral (S.length c)) cs
            NothingJust i  -> findIndex'Just (n + fromIntegraln + fromIntegrali)    (S.length c)) cs
{-# INLINE findIndex i  ->#-} (n + fromIntegral i)
{-# INLINE findIndex #-}
-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- | /O(n)/ The 'find' function takes a predicate and a ByteString,-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.-- and returns the first element in matching the predicate, or 'Nothing'
---- if there is no such element.
---- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
---- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find ::f cs0Word8= find'-> Boolcs0) -> ByteString -> Maybe Word8
findwhere cs0find'= find'Emptycs0     = Nothing
  where find' Empty(Chunk c cs) = Nothingcase S.find f c of
        find'NothingChunk-> csfind') = casecs   S.find f c of
            NothingJust w  -> find'Just wcs
{-# INLINE find#-}  -> Just w
{-# INLINE find #-}
-- | The 'findIndices' function extends 'findIndex', by returning the
-- | The 'findIndices' function extends 'findIndex', by returning the-- indices of all elements satisfying the predicate, in ascending order.
findIndices-- indices of all elements satisfying the predicate, in ascending order.:: (Word8 -> Bool) -> ByteString -> [Int64]
findIndices ::k cs0Word8= findIndices'-> Bool) ->0ByteStringcs0       -> [Int64]
findIndiceswhere findIndices' cs0 = findIndices'_ Empty     0 cs0= []
  where findIndices' _ Empty(Chunk c cs) = [L.map]    ((+n).fromIntegral) (S.findIndices k c)
        findIndices' n (Chunk++ csfindIndices') = L.map ((+n).fromIntegral)((S.lengthS.findIndicesc)) csk c)
                             ++ findIndices' (n + fromIntegral (S.length c)) cs
-- ---------------------------------------------------------------------
-- Searching ByteStrings-- ---------------------------------------------------------------------
-- Searching ByteStrings
-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.:: Word8 -> ByteString -> Bool
elem ::w cs= case-> ByteStringelemIndex w->csBoolof Nothing -> False ; _ -> True
elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True
-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem-- | /O(n)/ 'notElem' is the inverse of 'elem':: Word8 -> ByteString -> Bool
notElem ::w cs= not->(ByteStringelem w cs) -> Bool
notElem w cs = not (elem w cs)
-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- | /O(n)/ 'filter', applied to a predicate and a ByteString,-- returns a ByteString containing those characters that satisfy the
-- predicate.-- returns a ByteString containing those characters that satisfy the
filter-- predicate.:: (Word8 -> Bool) -> ByteString -> ByteString
filter ::p s(Word8= go s-> Bool) -> ByteString -> ByteString
filterwhere s = go s
    wherego Empty        = Empty
        go Empty(Chunk x xs) = Empty (S.filter p x) (go xs)
{-# INLINE (filterChunk x#-}) = chunk (S.filter p x) (go xs)
{-# INLINE filter #-}
{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single byte. It is more
-- efficient to use /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
{-# INLINE filterByte #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
  filter ((==) x) = filterByte x

"ByteString specialise filter (== x)" forall x.
 filter (== x) = filterByte x
  #-}
-}{-
-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
-}-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- the pair of ByteStrings with elements which do and do not satisfy the
-- predicate, respectively; i.e.,-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
---- the pair of ByteStrings with elements which do and do not satisfy the
-- predicate, respectively; i.e.,-- > partition p bs == (filter p xs, filter (not . p) xs)
--
partition-- > partition p bs == (filter p xs, filter (not . p) xs):: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
--partition f p = (filter f p, filter (not . f) p)
partition--TODO: use a better implementation:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition f p = (filter f p, filter (not . f) p)
--TODO: use a better implementation-- ---------------------------------------------------------------------
-- Searching for substrings
-- ---------------------------------------------------------------------
-- Searching for substrings-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True':: ByteString -> ByteString -> Bool
isPrefixOf-- iff the first is a prefix of the second.Empty _  = True
isPrefixOf ::_ Empty= False-> ByteString -> Bool
isPrefixOf Empty(Chunk_x =xsTrue) (Chunk y ys)
isPrefixOf| S.length Emptyx == =S.length  y = x == y  && isPrefixOf xs ys
isPrefixOf| S.lengthChunkx <x xsS.length) (Chunky y ysx )== yh && isPrefixOf xs (Chunk yt ys)
    | S.lengthotherwisex == S.length y = xxh====yy && isPrefixOf xs(Chunk  xt xs) ys
  where S.length(xh,xt)x=<S.splitAt(yS.length= x == yhy) &&x  isPrefixOf xs (Chunk yt ys)
    | otherwise(yh,yt) = S.splitAt (S.length= xh ==xy &&y  isPrefixOf (Chunk xt xs) ys
  where (xh,xt) = S.splitAt (S.length y) x
-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'yh,yt) = S.splitAt (S.length x) y
-- iff the first is a suffix of the second.
---- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- The following holds:-- iff the first is a suffix of the second.
--
-- The following holds:-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
isSuffixOf-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y:: ByteString -> ByteString -> Bool
--isSuffixOf x y = reverse x `isPrefixOf` reverse y
isSuffixOf--TODO: a better implementation:: ByteString -> ByteString -> Bool
isSuffixOf x y = reverse x `isPrefixOf` reverse y
--TODO: a better implementation-- ---------------------------------------------------------------------
-- Zipping
-- ---------------------------------------------------------------------
-- Zipping-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.-- corresponding pairs of bytes. If one input ByteString is short,
zip-- excess elements of the longer ByteString are discarded. This is:: ByteString -> ByteString -> [(Word8,Word8)]
zip-- equivalent to a pair of 'unpack' operations.= zipWith (,)
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip-- | 'zipWith' generalises 'zip' by zipping with the function given as= zipWith (,)
-- the first argument, instead of a tupling function.  For example,
-- | 'zipWith' generalises 'zip' by zipping with the function given as-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.-- the first argument, instead of a tupling function.  For example,
zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of:: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith-- corresponding sums._ Empty     _  = []
zipWith ::_ _(Word8Empty-> Word8= []-> a) -> ByteString -> ByteString -> [a]
zipWith _ Empty(Chunk a as) =Chunk]   b bs) = go a as b bs
zipWithwhere _ _      Empty = []
zipWithgo xfxsChunky ys a asf )S.unsafeHeadChunk b bs)x= go(S.unsafeHead as b bs  y)
  where          : to (S.unsafeTail x) xs (S.unsafeTail y) ys
    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
    to x Empty   : to (S.unsafeTail_ _          x) xs| S.nullS.unsafeTailx       y)[ys]
    to _ _             y Empty         | S.null y       = []
    to x Emptyxs            _ _ys            | S.nullnot (S.null    x) = []
    to _ _             y Empty        && S.nullnot (S.null    y) = [go] x  xs y  ys
    to x xs            y ys(Chunk y' ys) | not (S.null x) = go x  xs y' ys
    to _ (Chunk x' xs) y ys           &&| not (S.null y) = go xx' xs y  ys
    to x xs(Chunk x' xs) _ (Chunk y' ys) | not (S.null x) = go xx' xs y' ys
    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
-- ByteStrings. Note that this performs two 'pack' operations.
unzip-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of:: [(Word8,Word8)] -> (ByteString,ByteString)
unzip-- ByteStrings. Note that this performs two 'pack' operations.ls = (pack (L.map fst ls), pack (L.map snd ls))
unzip{-# INLINE:: [(Word8,Word8#-}  )] -> (ByteString,ByteString)
unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
{-# INLINE-- --------------------------------------------------------------------- #-}
-- Special lists
-- ---------------------------------------------------------------------
-- Special lists-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.= (Empty :) . inits'
initswhere::inits'Empty-> [ByteString= []  ]
inits = (inits'Empty :)Chunk inits'c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
  where inits' Empty       ++= [L.map]    (Chunk c) (inits' cs)
        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
-- | /O(n)/ Return all final segments of the given 'ByteString', longest first. L.map (Chunk c) (inits' cs)
tails :: ByteString -> [ByteString]
tails-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.Empty         = Empty : []
tails ::@ByteString(Chunk c cs'->) [ByteString]
tails| S.length  c == 1 = Emptycs : tails [] cs'
tails| otherwise@(Chunk c cs'=)cs : tails (Chunk (S.unsafeTail c) cs')
  | S.length c == 1 = cs : tails cs'
-- --------------------------------------------------------------------- otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
-- Low level constructors
-- ---------------------------------------------------------------------
-- Low level constructors-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed--   if a large string has been read in, and only a small part of it
--   is needed in the rest of the program.--   to by the 'ByteString' to be garbage collected, for example
copy--   if a large string has been read in, and only a small part of it:: ByteString -> ByteString
copy--   is needed in the rest of the program.cs = foldrChunks (Chunk . S.copy) Empty cs
copy--TODO, we could coalese small blocks here:: ByteString -> ByteString
copy--FIXME: probably not strict enough, if we're doing this to avoid retaining = foldrChunks (Chunk . S.copy) Empty cs
--TODO, we could coalese small blocks here-- the parent blocks then we'd better copy strictly.
--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.-- ---------------------------------------------------------------------

-- ----------------------------------------------------------------------- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString
-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString-- ---------------------------------------------------------------------
-- Lazy ByteString IO
---- ---------------------------------------------------------------------
-- Lazy ByteString IO-- Rule for when to close: is it expected to read the whole file?
---- If so, close when done.
---- Rule for when to close: is it expected to read the whole file?
-- If so, close when done.
---- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block
-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block-- available then they will be returned immediately as a smaller chunk.
---- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
-- The handle is closed on EOF.-- available then they will be returned immediately as a smaller chunk.
--
-- The handle is closed on EOF.-- Note: the 'Handle' should be placed in binary mode with
---- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
-- work correctly.-- Note: the 'Handle' should be placed in binary mode with
---- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
hGetContentsN-- work correctly.:: Int -> Handle -> IO ByteString
--hGetContentsN k h = lazyRead -- TODO close on exceptions
hGetContentsNwhere       :: Int -> Handle -> IO ByteString
hGetContentsNlazyRead =kunsafeInterleaveIO = lazyRead -- TODO close on exceptionsloop
  where
    lazyReadloop = do= unsafeInterleaveIO loop
        c <- S.hGetSome h k -- only blocks if there is no data available
    loopif= doS.null c
        c <-thendo hClosehhk>>-- only blocks if there is no data availablereturn Empty
        ifelsedo ccs <- lazyRead
          then do hClose hChunk returnc cs)Empty
          else do cs <- lazyRead
-- | Read @n@ bytes into a 'ByteString', directly from the (Chunk c cs)
-- specified 'Handle', in chunks of size @k@.
---- | Read @n@ bytes into a 'ByteString', directly from the
hGetN-- specified 'Handle', in chunks of size @k@.:: Int -> Handle -> Int -> IO ByteString
--hGetN k h n | n > 0 = readChunks n
hGetNwhere:: Int -> Handle -> Int -> IO ByteString
hGetNreadChunks h n | n!> 0 =doreadChunks n
  where c <- S.hGet h (min k i)
    readChunkscase S.length!i = doc of
        c <-0S.hGet-> return (minEmpty i)
        casemS.length-> do csc<-ofreadChunks (i - m)
            0 -> returnreturn(Chunk c cs)
            m -> do cs <- readChunks (i - m)
hGetN _ _ 0 = returnreturnEmpty (Chunk c cs)
hGetN _ h n = illegalBufferSize h "hGet" n
hGetN _ _ 0 = return Empty
hGetN-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block h n = illegalBufferSize h "hGet" n
-- waiting for data to become available, instead it returns only whatever data
-- is available. Chunks are read on demand, in @k@-sized chunks.-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
---- waiting for data to become available, instead it returns only whatever data
hGetNonBlockingN-- is available. Chunks are read on demand, in @k@-sized chunks.:: Int -> Handle -> Int -> IO ByteString
--hGetNonBlockingN k h n | n > 0= readChunks n
hGetNonBlockingNwhere          :: Int -> Handle -> Int -> IO ByteString
hGetNonBlockingNreadChunks !ik=hdo | n > 0= readChunks n
  where c <- S.hGetNonBlocking h (min k i)
    readChunkscase S.length!i = doc of
        c <-0S.hGetNonBlocking-> return Empty  h (min k i)
        casemS.length-> do csc<-ofreadChunks (i - m)
            0 -> returnreturn(Chunk c cs)
            m -> do cs <- readChunks (i - m)
hGetNonBlockingN _ _return0 = returnChunkEmpty cs)
hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
hGetNonBlockingN _ _ 0 = return Empty
hGetNonBlockingNillegalBufferSize_:: nHandle= illegalBufferSize-> String -> Int "hGetNonBlocking"-> IO a           n
illegalBufferSize handle fn sz =
illegalBufferSizeioError (mkIOError:: HandleillegalOperationErrorType-> String -> Int -> IOmsg (Just handle) Nothing)
illegalBufferSize--TODO: System.IO uses InvalidArgument here, but it's not exported :-( fn sz =
    ioErrorwhere   (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
    where
-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
-- are read on demand, using the default chunk size.
---- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- Once EOF is encountered, the Handle is closed.-- are read on demand, using the default chunk size.
--
-- Once EOF is encountered, the Handle is closed.-- Note: the 'Handle' should be placed in binary mode with
---- 'System.IO.hSetBinaryMode' for 'hGetContents' to
-- work correctly.-- Note: the 'Handle' should be placed in binary mode with
---- 'System.IO.hSetBinaryMode' for 'hGetContents' to
hGetContents-- work correctly.:: Handle -> IO ByteString
--hGetContents = hGetContentsN defaultChunkSize
hGetContents :: Handle -> IO ByteString
hGetContents-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.= hGetContentsN defaultChunkSize
--
hGet-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.:: Handle -> Int -> IO ByteString
--hGet = hGetN defaultChunkSize
hGet :: Handle -> Int -> IO ByteString
hGet-- | hGetNonBlocking is similar to 'hGet', except that it will never block= hGetN defaultChunkSize
-- waiting for data to become available, instead it returns only whatever data
-- | hGetNonBlocking is similar to 'hGet', except that it will never block-- is available.  If there is no data available to be read, 'hGetNonBlocking'
-- returns 'empty'.-- waiting for data to become available, instead it returns only whatever data
---- is available.  If there is no data available to be read, 'hGetNonBlocking'
-- returns 'empty'.-- Note: on Windows and with Haskell implementation other than GHC, this
---- function does not work correctly; it behaves identically to 'hGet'.
---- Note: on Windows and with Haskell implementation other than GHC, this
hGetNonBlocking-- function does not work correctly; it behaves identically to 'hGet'.:: Handle -> Int -> IO ByteString
--hGetNonBlocking = hGetNonBlockingN defaultChunkSize
hGetNonBlocking :: Handle -> Int -> IO ByteString
hGetNonBlocking-- | Read an entire file /lazily/ into a 'ByteString'.= hGetNonBlockingN defaultChunkSize
-- The Handle will be held open until EOF is encountered.
---- | Read an entire file /lazily/ into a 'ByteString'.
readFile-- The Handle will be held open until EOF is encountered.:: FilePath -> IO ByteString
--readFile f = openBinaryFile f ReadMode >>= hGetContents
readFile :: FilePath -> IO ByteString
readFile-- | Write a 'ByteString' to a file. = openBinaryFile f ReadMode >>= hGetContents
--
writeFile-- | Write a 'ByteString' to a file.:: FilePath -> ByteString -> IO ()
--writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
writeFile(\hdl :: FilePathhPut hdl ->txtByteString)          -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
-- | Append a 'ByteString' to a file.\hdl -> hPut hdl txt)
--
appendFile-- | Append a 'ByteString' to a file.:: FilePath -> ByteString -> IO ()
--appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
appendFile(\hdl ->::hPuthdl txt->)ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/\hdl -> hPut hdl txt)
--
getContents-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/:: IO ByteString
--getContents = hGetContents stdin
getContents :: IO ByteString
getContents-- | Outputs a 'ByteString' to the specified 'Handle'.= hGetContents stdin
--
hPut-- | Outputs a 'ByteString' to the specified 'Handle'.:: Handle -> ByteString -> IO ()
--hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
hPut :: Handle -> ByteString -> IO ()
hPut-- | Similar to 'hPut' except that it will never block. Instead it returns cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
-- any tail that did not get written. This tail may be 'empty' in the case that
-- | Similar to 'hPut' except that it will never block. Instead it returns-- the whole string was written, or the whole original string if nothing was
-- written. Partial writes are also possible.-- any tail that did not get written. This tail may be 'empty' in the case that
---- the whole string was written, or the whole original string if nothing was
-- written. Partial writes are also possible.-- Note: on Windows and with Haskell implementation other than GHC, this
---- function does not work correctly; it behaves identically to 'hPut'.
---- Note: on Windows and with Haskell implementation other than GHC, this
hPutNonBlocking-- function does not work correctly; it behaves identically to 'hPut'.:: Handle -> ByteString -> IO ByteString
--hPutNonBlocking _ Empty           = return Empty
hPutNonBlocking ::h bs@(Chunk->cByteStringcs) = do  -> IO ByteString
hPutNonBlockingc' <- S.hPutNonBlocking Empty   h c     = return Empty
hPutNonBlockingcase S.length hc'bsof@(Chunk c cs) = do
  c'l'<-|S.hPutNonBlockingl' == S.length c h->chPutNonBlocking h cs
  case0  S.length c' of     -> return bs
    l'_  | l' == S.length c -> hPutNonBlockingreturn (Chunk c'hcs)
    0                     -> return bs
-- | A synonym for @hPut@, for compatibility                     -> return (Chunk c' cs)
--
hPutStr-- | A synonym for @hPut@, for compatibility:: Handle -> ByteString -> IO ()
--hPutStr = hPut
hPutStr :: Handle -> ByteString -> IO ()
hPutStr-- | Write a ByteString to stdout= hPut
putStr :: ByteString -> IO ()
putStr-- | Write a ByteString to stdout= hPut stdout
putStr :: ByteString -> IO ()
putStr-- | Write a ByteString to stdout, appending a newline byte= hPut stdout
--
putStrLn-- | Write a ByteString to stdout, appending a newline byte:: ByteString -> IO ()
--putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
putStrLn :: ByteString -> IO ()
putStrLn{-# DEPRECATED = hPutputStrLn ps >> hPut stdout (singleton 0x0a)
    "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
{-# DEPRECATED#-}          putStrLn
    "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
-- | The interact function takes a function of type @ByteString -> ByteString@#-}
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device.-- | The interact function takes a function of type @ByteString -> ByteString@
---- as its argument. The entire input from the standard input device is passed
interact-- to this function as its argument, and the resulting string is output on the:: (ByteString -> ByteString) -> IO ()
interact-- standard output device.transformer = putStr . transformer =<< getContents
--
interact-- ---------------------------------------------------------------------:: (ByteString -> ByteString) -> IO ()
interact-- Internal utilities = putStr . transformer =<< getContents

-- Common up near identical calls to `error' to reduce the number-- ---------------------------------------------------------------------
-- Internal utilities-- constant strings created when compiled:
errorEmptyList :: String -> a
errorEmptyList-- Common up near identical calls to `error' to reduce the numberfun = moduleError fun "empty ByteString"
-- constant strings created when compiled:
errorEmptyListmoduleError :: ::String-> ->String   -> a
errorEmptyListmoduleError funfunmsg==moduleErrorerror ("Data.Vector.Storable.ByteString.Lazy." "empty ByteString"              ++ fun ++ ':':' ':msg)

moduleError :: String -> String -> a
moduleError-- reverse a list of non-empty chunks into a lazy ByteString msg = error ("Data.Vector.Storable.ByteString.Lazy." ++ fun ++ ':':' ':msg)
revNonEmptyChunks :: [P.ByteString] -> ByteString
revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs
-- reverse a list of non-empty chunks into a lazy ByteString
revNonEmptyChunks-- reverse a list of possibly-empty chunks into a lazy ByteString:: [P.ByteString] -> ByteString
revNonEmptyChunksrevChunks :: [P.ByteString = L.foldl'] -> ByteStringflip Chunk) Empty cs
revChunks cs = L.foldl' (flip chunk) Empty cs
-- reverse a list of possibly-empty chunks into a lazy ByteString
revChunks-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length:: [P.ByteString] -> ByteString
revChunks-- of the string if no element is found, rather than Nothing. = L.foldl' (flip chunk) Empty cs
findIndexOrEnd :: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEnd-- | 'findIndexOrEnd' is a variant of findIndex, that returns the lengthk v = S.inlinePerformIO $ withForeignPtr fp $ \f -> go f 0
-- of the string if no element is found, rather than Nothing.where
findIndexOrEnd(fp, l) = VS.unsafeToForeignPtr0:: (Word8 -> Bool) -> P.ByteStringv            -> Int
findIndexOrEnd k v = S.inlinePerformIO $ withForeignPtr fp $ \f -> go f 0
  wherego !ptr !n | n >= l    = return l
    (fp, l) = VS.unsafeToForeignPtr0| otherwise = do w <- vpeek ptr
                                if k w
    go !ptr !n | n >= l    = returnthen  return n
               | otherwise = do w <-elsego ptr(ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}   if k w
                                  then return n
                                  else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}


</pre>