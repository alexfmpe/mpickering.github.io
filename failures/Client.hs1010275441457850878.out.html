<a href="CLI.hs388471006681910962.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Client.hs1144108930470211272.out.html">next</a></br></br><pre>5d4
< import "monads-tf" Control.Monad.State
6c5
< import "monads-tf" Control.Monad.Error
---
> import  Control.Monad.State
6a6
> import  Control.Monad.Error
34a35
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings, FlexibleContexts, PackageImports #-}

module Network.Sasl.Plain.Client (sasl) where

import "monads-tf" Control.Monad.State
import "monads-tf" Control.Monad.Error
import Data.Maybe
import Data.Pipe

import qualified Data.ByteString as BS

import Network.Sasl

sasl :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => (
    BS.ByteString,
    (Bool, Pipe (Either Success BS.ByteString) BS.ByteString m ()) )
sasl = ("PLAIN", client script)

script :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => Client m
script = Client (Just clientMessage) [] Nothing

clientMessage :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => Send m
clientMessage = do
    st <- gets getSaslState
    let az = fromMaybe "" $ lookup "authzid" st
        Just ac = lookup "authcid" st
        Just ps = lookup "password" st
    return $ BS.concat [az, "\0", ac, "\0", ps]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings, FlexibleContexts, PackageImports #-}

module Network.Sasl.Plain.Client (sasl) where

import  Control.Monad.State
import  Control.Monad.Error
import Data.Maybe
import Data.Pipe

import qualified Data.ByteString as BS

import Network.Sasl

sasl :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => (
    BS.ByteString,
    (Bool, Pipe (Either Success BS.ByteString) BS.ByteString m ()) )
sasl = ("PLAIN", client script)

script :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => Client m
script = Client (Just clientMessage) [] Nothing

clientMessage :: (
    MonadState m, SaslState (StateType m),
    MonadError m, Error (ErrorType m) ) => Send m
clientMessage = do
    st <- gets getSaslState
    let az = fromMaybe "" $ lookup "authzid" st
        Just ac = lookup "authcid" st
        Just ps = lookup "password" st
    return $ BS.concat [az, "\0", ac, "\0", ps]

</pre>