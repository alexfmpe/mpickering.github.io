<a href="CompileUnit.hs10120281441086531968.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Completion.hs12384895531882410547.out.html">next</a></br></br><pre>20c20
<     sinkTr   = (sink, map (,sink) (alphabet auto))
---
>     sinkTr   = (sink, map ( sink) (alphabet auto))
29c29
<     nTr = map (,sink) (alphabet auto \\ map fst tr)
---
>     nTr = map ( sink) (alphabet auto \\ map fst tr)
29a30
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TupleSections #-}

{- |
Function for making an automaton complete (transition on every symbol at every state)
-}
module FST.Complete (
  complete
  ) where

import FST.Automaton
import Data.List ( (\\) )

-- | Make a automaton complete (transition on every symbol at every state)
complete :: Eq a => Automaton a -> Automaton a
complete auto =
  construct (firstState auto, sink) newTrans
            (alphabet auto) (initials auto)
            (finals auto) where
    sink     = lastState auto + 1
    sinkTr   = (sink, map (,sink) (alphabet auto))
    newTrans = sinkTr:completeStates auto sink (states auto) []

completeStates :: Eq a => Automaton a -> StateTy -> [StateTy] -> [(StateTy,Transitions a)] -> [(StateTy,Transitions a)]
completeStates _    _    []      trans = trans
completeStates auto sink (state:states) trans
 = completeStates auto sink states ((state, tr ++ nTr):trans)
  where
    tr  = transitionList auto state
    nTr = map (,sink) (alphabet auto \\ map fst tr)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TupleSections #-}

{- |
Function for making an automaton complete (transition on every symbol at every state)
-}
module FST.Complete (
  complete
  ) where

import FST.Automaton
import Data.List ( (\\) )

-- | Make a automaton complete (transition on every symbol at every state)
complete :: Eq a => Automaton a -> Automaton a
complete auto =
  construct (firstState auto, sink) newTrans
            (alphabet auto) (initials auto)
            (finals auto) where
    sink     = lastState auto + 1
    sinkTr   = (sink, map ( sink) (alphabet auto))
    newTrans = sinkTr:completeStates auto sink (states auto) []

completeStates :: Eq a => Automaton a -> StateTy -> [StateTy] -> [(StateTy,Transitions a)] -> [(StateTy,Transitions a)]
completeStates _    _    []      trans = trans
completeStates auto sink (state:states) trans
 = completeStates auto sink states ((state, tr ++ nTr):trans)
  where
    tr  = transitionList auto state
    nTr = map ( sink) (alphabet auto \\ map fst tr)

</pre>