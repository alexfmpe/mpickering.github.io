<a href="Authorisation.hs197941363348318738.out.html">prev</a></br><a href="failures.html">home</a></br><a href="AutoForm.hs11036699551564674546.out.html">next</a></br></br><pre>53c53
< authCredentialP ∷ Parser AuthCredential
---
> authCredentialP :: Parser AuthCredential
56d55
<       do _   ← string "Basic"
57d55
<          _   ← many1 lws
58d55
<          b64 ← many1
59c56
<                $ satisfy (\c → (c ≥ 'a' ∧ c ≤ 'z') ∨
---
>       do _   <- string "Basic"
59a57
>          _   <- many1 lws
59a58
>          b64 <- many1
59a59
>                $ satisfy (\c -> (c ≥ 'a' ∧ c ≤ 'z') ∨
67d66
<                → return (BasicAuthCredential uid password)
68c67
<            _   → failP
---
>                -> return (BasicAuthCredential uid password)
68a68
>            _   -> failP
70c70
<       decode ∷ String → String
---
>       decode :: String -> String
71a72
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    UnicodeSyntax
  #-}
{-# OPTIONS_HADDOCK prune #-}

-- |Manipulation of WWW authorization.
module Network.HTTP.Lucu.Authorization
    ( AuthChallenge(..)
    , AuthCredential(..)
    , Realm
    , UserID
    , Password

    , authCredentialP -- private
    )
    where
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as C8
import Network.HTTP.Lucu.Parser
import Network.HTTP.Lucu.Parser.Http
import Network.HTTP.Lucu.Utils
import Prelude.Unicode

-- |Authorization challenge to be sent to client with
-- \"WWW-Authenticate\" header. See
-- 'Network.HTTP.Lucu.Resource.setWWWAuthenticate'.
data AuthChallenge
    = BasicAuthChallenge Realm
      deriving (Eq)

-- |'Realm' is just a string which must not contain any non-ASCII letters.
type Realm = String

-- |Authorization credential to be sent by client with
-- \"Authorization\" header. See
-- 'Network.HTTP.Lucu.Resource.getAuthorization'.
data AuthCredential
    = BasicAuthCredential UserID Password
      deriving (Show, Eq)

-- |'UserID' is just a string which must not contain colon and any
-- non-ASCII letters.
type UserID   = String

-- |'Password' is just a string which must not contain any non-ASCII
-- letters.
type Password = String

instance Show AuthChallenge where
    show (BasicAuthChallenge realm)
        = "Basic realm=" ⧺ quoteStr realm

authCredentialP ∷ Parser AuthCredential
authCredentialP
    = allowEOF $!
      do _   ← string "Basic"
         _   ← many1 lws
         b64 ← many1
               $ satisfy (\c → (c ≥ 'a' ∧ c ≤ 'z') ∨
                               (c ≥ 'A' ∧ c ≤ 'Z') ∨
                               (c ≥ '0' ∧ c ≤ '9') ∨
                                c ≡ '+' ∨
                                c ≡ '/' ∨
                                c ≡ '=')
         case break (≡ ':') (decode b64) of
           (uid, ':' : password)
               → return (BasicAuthCredential uid password)
           _   → failP
    where
      decode ∷ String → String
      decode = C8.unpack ∘ B64.decodeLenient ∘ C8.pack
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    UnicodeSyntax
  #-}
{-# OPTIONS_HADDOCK prune #-}

-- |Manipulation of WWW authorization.
module Network.HTTP.Lucu.Authorization
    ( AuthChallenge(..)
    , AuthCredential(..)
    , Realm
    , UserID
    , Password

    , authCredentialP -- private
    )
    where
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as C8
import Network.HTTP.Lucu.Parser
import Network.HTTP.Lucu.Parser.Http
import Network.HTTP.Lucu.Utils
import Prelude.Unicode

-- |Authorization challenge to be sent to client with
-- \"WWW-Authenticate\" header. See
-- 'Network.HTTP.Lucu.Resource.setWWWAuthenticate'.
data AuthChallenge
    = BasicAuthChallenge Realm
      deriving (Eq)

-- |'Realm' is just a string which must not contain any non-ASCII letters.
type Realm = String

-- |Authorization credential to be sent by client with
-- \"Authorization\" header. See
-- 'Network.HTTP.Lucu.Resource.getAuthorization'.
data AuthCredential
    = BasicAuthCredential UserID Password
      deriving (Show, Eq)

-- |'UserID' is just a string which must not contain colon and any
-- non-ASCII letters.
type UserID   = String

-- |'Password' is just a string which must not contain any non-ASCII
-- letters.
type Password = String

instance Show AuthChallenge where
    show (BasicAuthChallenge realm)
        = "Basic realm=" ⧺ quoteStr realm

authCredentialP :: Parser AuthCredential
authCredentialP
    = allowEOF $!
      do _   <- string "Basic"
         _   <- many1 lws
         b64 <- many1
               $ satisfy (\c -> (c ≥ 'a' ∧ c ≤ 'z') ∨
                               (c ≥ 'A' ∧ c ≤ 'Z') ∨
                               (c ≥ '0' ∧ c ≤ '9') ∨
                                c ≡ '+' ∨
                                c ≡ '/' ∨
                                c ≡ '=')
         case break (≡ ':') (decode b64) of
           (uid, ':' : password)
               -> return (BasicAuthCredential uid password)
           _   -> failP
    where
      decode :: String -> String
      decode = C8.unpack ∘ B64.decodeLenient ∘ C8.pack

</pre>