<a href="Test.hs8965443031474833169.out.html">prev</a></br><a href="failures.html">home</a></br><a href="test.hs9964979722063936098.out.html">next</a></br></br><pre>34c34
< pattern a :&: b = And a b
---
> pattern   :&:     b = And a b
48d47
<         [ ([p| Just _ |]  , [e| Just "a" |] , True)
49d47
<         , ([p| [_,_,_] |] , [e| [1,2,3] |] , True)
50d47
<         , ([p| [_,_] |] , [e| [1,2,3] |] , False)
51c48
<         , ([p| Left{} |] , [e| Left 3 |] , True)
---
>         [ ([p| Just _ |]  , [| Just "a" |] , True)
51a49
>         , ([p| [_,_,_] |] , [| [1,2,3] |] , True)
51a50
>         , ([p| [_,_] |] , [| [1,2,3] |] , False)
51a51
>         , ([p| Left{} |] , [| Left 3 |] , True)
57d56
<         [ ('Just , [e| Just 'b' |] , True)
58d56
<         , ('(:) , [e| [] |] , False)
59d56
<         , ('[]  , [e| [] |] , True)
60d56
<         , ('(:) , [e| [1,2,3] |] , True)
61d56
<         , ('(,,,) , [e| (1,2,3,4) |] , True)
62d56
<         , ('(:*:) , [e| Lit 3 :*: Lit 4 |] , True)
63d56
<         , ('(:&:) , [e| Lit True :&: Lit False |] , True)
64c57
<         , ('(:*:) , [e| Lit True :&: Lit False |] , False)
---
>         [ ('Just , [| Just 'b' |] , True)
64a58
>         , (': , [| [] |] , False)
64a59
>         , ('[]  , [| [] |] , True)
64a60
>         , (': , [| [1,2,3] |] , True)
64a61
>         , ('(,,,) , [| (1,2,3,4) |] , True)
64a62
>         , (':*: , [| Lit 3 :*: Lit 4 |] , True)
64a63
>         , (':&: , [| Lit True :&: Lit False |] , True)
64a64
>         , (':*: , [| Lit True :&: Lit False |] , False)
69d68
<         [ ('isA, [e| A |], True)
70d68
<         , ('isD, [e| D 1 "a" |], True)
71d68
<         , ('isC, [e| D 1 "a" |], False)
72d68
<         , ('isNotF, [e| F "a" |], False)
73d68
<         , ('isLit, [e| Lit 3 |], True)
74d68
<         , ('isAnd, [e| Lit "Foo" |], False)
75c69
<         , ('isNotShowable, [e| Showable () |], False)
---
>         [ ('isA, [| A |], True)
75a70
>         , ('isD, [| D 1 "a" |], True)
75a71
>         , ('isC, [| D 1 "a" |], False)
75a72
>         , ('isNotF, [| F "a" |], False)
75a73
>         , ('isLit, [| Lit 3 |], True)
75a74
>         , ('isAnd, [| Lit "Foo" |], False)
75a75
>         , ('isNotShowable, [| Showable () |], False)
86c86
<     x `andThen` y = AppE (AppE (VarE '(>>)) x) y
---
>     x `andThen` y = AppE (AppE (VarE '>>) x) y
104a105
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE PatternSynonyms #-}
module Main where

import Data.Generics.Is
import Language.Haskell.TH
import Control.Applicative
import Control.Monad
import System.Exit

data TheType a b = A
                 | B String Double ()
                 | Int :+: Int
                 | (:-:) Double
                 | () `C` ()
                 | D { field1 :: a, field2 :: b }
                 | forall g. F g

$(makePredicates ''TheType) ; $(makePredicatesNot ''TheType)

newtype OtherType a = E Int
$(makePredicatesAll ''OtherType)

data E a where
  Plus :: E Int -> E Int -> E Int
  And  :: E Bool -> E Bool -> E Bool
  Lit  :: a -> E a
  Showable :: (Show a) => a -> E String
  (:*:) :: (Num a) => E a -> E a -> E a
$(makePredicatesAll ''E)

pattern a :&: b = And a b

assertEq :: String -> Bool -> Bool -> IO ()
assertEq _ a b | a == b = return ()
assertEq a_str a b = do
  putStrLn $ a_str ++ " /= " ++ show b
  exitFailure

main :: IO ()
main = $(
  let
    -- Test cases: pattern, expression, pattern matches expression
    testCasesPat :: [(Q Pat, Q Exp, Bool)]
    testCasesPat =
        [ ([p| Just _ |]  , [e| Just "a" |] , True)
        , ([p| [_,_,_] |] , [e| [1,2,3] |] , True)
        , ([p| [_,_] |] , [e| [1,2,3] |] , False)
        , ([p| Left{} |] , [e| Left 3 |] , True)
        ]

    -- Test cases: pattern, expression, constructor matches expression
    testCasesName :: [(Name, Q Exp, Bool)]
    testCasesName =
        [ ('Just , [e| Just 'b' |] , True)
        , ('(:) , [e| [] |] , False)
        , ('[]  , [e| [] |] , True)
        , ('(:) , [e| [1,2,3] |] , True)
        , ('(,,,) , [e| (1,2,3,4) |] , True)
        , ('(:*:) , [e| Lit 3 :*: Lit 4 |] , True)
        , ('(:&:) , [e| Lit True :&: Lit False |] , True)
        , ('(:*:) , [e| Lit True :&: Lit False |] , False)
        ]

    testCasesFun :: [(Name, Q Exp, Bool)]
    testCasesFun =
        [ ('isA, [e| A |], True)
        , ('isD, [e| D 1 "a" |], True)
        , ('isC, [e| D 1 "a" |], False)
        , ('isNotF, [e| F "a" |], False)
        , ('isLit, [e| Lit 3 |], True)
        , ('isAnd, [e| Lit "Foo" |], False)
        , ('isNotShowable, [e| Showable () |], False)
        ]

    -- Utility functions
    assertEqTH :: Bool -> Exp -> Exp -> Exp
    assertEqTH b f e = assertEqExpr (AppE f e) b

    boolExp :: Bool -> Exp
    boolExp b = if b then ConE 'True else ConE 'False

    andThen :: Exp -> Exp -> Exp
    x `andThen` y = AppE (AppE (VarE '(>>)) x) y

    assertEqExpr :: Exp -> Bool -> Exp
    assertEqExpr e b = AppE (AppE (AppE (VarE 'assertEq) (LitE (StringL (pprint e)))) e) (boolExp b)
  in do
    es1 <- forM testCasesPat $ \(p, e, b) ->
      andThen <$> (assertEqTH b <$> isP p <*> e)
              <*> (assertEqTH (not b) <$> isNotP p <*> e)

    es2 <- forM testCasesName $ \(n, e, b) ->
      andThen <$> (assertEqTH b <$> is n <*> e)
              <*> (assertEqTH (not b) <$> isNot n <*> e)

    es3 <- forM testCasesFun $ \(f, e, b) ->
      assertEqTH b (VarE f) <$> e

    return $ foldl1 andThen $ es1 ++ es2 ++ es3

  )
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE PatternSynonyms #-}
module Main where

import Data.Generics.Is
import Language.Haskell.TH
import Control.Applicative
import Control.Monad
import System.Exit

data TheType a b = A
                 | B String Double ()
                 | Int :+: Int
                 | (:-:) Double
                 | () `C` ()
                 | D { field1 :: a, field2 :: b }
                 | forall g. F g

$(makePredicates ''TheType) ; $(makePredicatesNot ''TheType)

newtype OtherType a = E Int
$(makePredicatesAll ''OtherType)

data E a where
  Plus :: E Int -> E Int -> E Int
  And  :: E Bool -> E Bool -> E Bool
  Lit  :: a -> E a
  Showable :: (Show a) => a -> E String
  (:*:) :: (Num a) => E a -> E a -> E a
$(makePredicatesAll ''E)

pattern   :&:     b = And a b

assertEq :: String -> Bool -> Bool -> IO ()
assertEq _ a b | a == b = return ()
assertEq a_str a b = do
  putStrLn $ a_str ++ " /= " ++ show b
  exitFailure

main :: IO ()
main = $(
  let
    -- Test cases: pattern, expression, pattern matches expression
    testCasesPat :: [(Q Pat, Q Exp, Bool)]
    testCasesPat =
        [ ([p| Just _ |]  , [| Just "a" |] , True)
        , ([p| [_,_,_] |] , [| [1,2,3] |] , True)
        , ([p| [_,_] |] , [| [1,2,3] |] , False)
        , ([p| Left{} |] , [| Left 3 |] , True)
        ]

    -- Test cases: pattern, expression, constructor matches expression
    testCasesName :: [(Name, Q Exp, Bool)]
    testCasesName =
        [ ('Just , [| Just 'b' |] , True)
        , (': , [| [] |] , False)
        , ('[]  , [| [] |] , True)
        , (': , [| [1,2,3] |] , True)
        , ('(,,,) , [| (1,2,3,4) |] , True)
        , (':*: , [| Lit 3 :*: Lit 4 |] , True)
        , (':&: , [| Lit True :&: Lit False |] , True)
        , (':*: , [| Lit True :&: Lit False |] , False)
        ]

    testCasesFun :: [(Name, Q Exp, Bool)]
    testCasesFun =
        [ ('isA, [| A |], True)
        , ('isD, [| D 1 "a" |], True)
        , ('isC, [| D 1 "a" |], False)
        , ('isNotF, [| F "a" |], False)
        , ('isLit, [| Lit 3 |], True)
        , ('isAnd, [| Lit "Foo" |], False)
        , ('isNotShowable, [| Showable () |], False)
        ]

    -- Utility functions
    assertEqTH :: Bool -> Exp -> Exp -> Exp
    assertEqTH b f e = assertEqExpr (AppE f e) b

    boolExp :: Bool -> Exp
    boolExp b = if b then ConE 'True else ConE 'False

    andThen :: Exp -> Exp -> Exp
    x `andThen` y = AppE (AppE (VarE '>>) x) y

    assertEqExpr :: Exp -> Bool -> Exp
    assertEqExpr e b = AppE (AppE (AppE (VarE 'assertEq) (LitE (StringL (pprint e)))) e) (boolExp b)
  in do
    es1 <- forM testCasesPat $ \(p, e, b) ->
      andThen <$> (assertEqTH b <$> isP p <*> e)
              <*> (assertEqTH (not b) <$> isNotP p <*> e)

    es2 <- forM testCasesName $ \(n, e, b) ->
      andThen <$> (assertEqTH b <$> is n <*> e)
              <*> (assertEqTH (not b) <$> isNot n <*> e)

    es3 <- forM testCasesFun $ \(f, e, b) ->
      assertEqTH b (VarE f) <$> e

    return $ foldl1 andThen $ es1 ++ es2 ++ es3

  )

</pre>