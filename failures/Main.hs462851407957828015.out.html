<a href="Main.hs388471006681910962.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs510616708590357944.out.html">next</a></br></br><pre>26d25
< main ∷ IO ()
27d25
< main = getArgs >>= \case
28d25
<   [] → putStr help
29d25
<   "-d":d:ts → downloadTo d ts
30c26
<   xs → fetchImageLinks xs >>= \x → mapM_ putStrLn [ y | Right y ← x ]
---
> main :: IO ()
30a27
> main = getArgs >>= 
30a28
>   [] -> putStr help
30a29
>   "-d":d:ts -> downloadTo d ts
30a30
>   xs -> fetchImageLinks xs >>= \x -> mapM_ putStrLn [ y | Right y <- x ]
34d33
< downloadTo ∷ FilePath → [Tag] → IO ()
35d33
< downloadTo fp xs = doesDirectoryExist fp >>= \case
36d33
<   False → print (fp <> " doesn't exist.") >> exitFailure
37c34
<   True → do
---
> downloadTo :: FilePath -> [Tag] -> IO ()
37a35
> downloadTo fp xs = doesDirectoryExist fp >>= 
37a36
>   False -> print (fp <> " doesn't exist.") >> exitFailure
37a37
>   True -> do
41d40
<               fromList [ (md5 `rGet` r, file_url `rGet` r) | Right r ← s ]
42d40
<     g ← f Gelbooru
43d40
<     i ← f Ichijou
44d40
<     k ← f Konachan
45d40
<     s ← f Safebooru
46c41
<     y ← f Yandere
---
>               fromList [ (md5 `rGet` r, file_url `rGet` r) | Right r <- s ]
46a42
>     g <- f Gelbooru
46a43
>     i <- f Ichijou
46a44
>     k <- f Konachan
46a45
>     s <- f Safebooru
46a46
>     y <- f Yandere
50c50
<     dcs ← Prelude.map (fp </>) <$> getDirectoryContents fp
---
>     dcs <- Prelude.map (fp </>) <$> getDirectoryContents fp
52c52
<         fs = Prelude.filter notInFiles [ (snd x, mkFp x) | x ← assocs ls ]
---
>         fs = Prelude.filter notInFiles [ (snd x, mkFp x) | x <- assocs ls ]
54d53
<     ds ← atomically newTChan
55d53
<     got ← newTVarIO 0
56d53
<     let loop = atomically (readTChan ds) >>= \case
57d53
<           EndOfQueue → putStrLn "Done."
58d53
<           x → do
59c54
<             v ← atomically $ modifyTVar got succ >> readTVar got
---
>     ds <- atomically newTChan
59a55
>     got <- newTVarIO 0
59a56
>     let loop = atomically (readTChan ds) >>= 
59a57
>           EndOfQueue -> putStrLn "Done."
59a58
>           x -> do
59a59
>             v <- atomically $ modifyTVar got succ >> readTVar got
68c68
< fetchImageLinks ∷ [Tag] → IO [Parse String]
---
> fetchImageLinks :: [Tag] -> IO [Parse String]
74d73
<   g ← f Gelbooru
75d73
<   i ← f Ichijou
76d73
<   k ← f Konachan
77d73
<   s ← f Safebooru
78c74
<   y ← f Yandere
---
>   g <- f Gelbooru
78a75
>   i <- f Ichijou
78a76
>   k <- f Konachan
78a77
>   s <- f Safebooru
78a78
>   y <- f Yandere
82c82
< help ∷ String
---
> help :: String
93a94
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE DataKinds #-}
module Main where

import Control.Applicative ((<$>))
import Control.Concurrent (forkIO)
import Control.Concurrent.STM
import Control.Monad (void, filterM)
import Data.Map
import Data.Monoid
import Data.Vinyl (rGet)
import HBooru.Network
import HBooru.Parsers.Gelbooru
import HBooru.Parsers.Ichijou
import HBooru.Parsers.Konachan
import HBooru.Parsers.Safebooru
import HBooru.Parsers.Yandere
import HBooru.Types
import System.Directory
import System.Environment (getArgs)
import System.Exit
import System.FilePath

main ∷ IO ()
main = getArgs >>= \case
  [] → putStr help
  "-d":d:ts → downloadTo d ts
  xs → fetchImageLinks xs >>= \x → mapM_ putStrLn [ y | Right y ← x ]

-- | Downloads all the images with the given tag to the given
-- directory.
downloadTo ∷ FilePath → [Tag] → IO ()
downloadTo fp xs = doesDirectoryExist fp >>= \case
  False → print (fp <> " doesn't exist.") >> exitFailure
  True → do
    let f p = run <$> fetchAllTaggedPosts p XML xs
          where
            run s =
              fromList [ (md5 `rGet` r, file_url `rGet` r) | Right r ← s ]
    g ← f Gelbooru
    i ← f Ichijou
    k ← f Konachan
    s ← f Safebooru
    y ← f Yandere
    let ls = g <> i <> k <> s <> y
        mkFp (m, u) = let e = snd $ splitExtension u
                      in fp </> m <.> e
    dcs ← Prelude.map (fp </>) <$> getDirectoryContents fp
    let notInFiles = (`notElem` dcs) . snd
        fs = Prelude.filter notInFiles [ (snd x, mkFp x) | x ← assocs ls ]
        lfs = show $ length fs
    ds ← atomically newTChan
    got ← newTVarIO 0
    let loop = atomically (readTChan ds) >>= \case
          EndOfQueue → putStrLn "Done."
          x → do
            v ← atomically $ modifyTVar got succ >> readTVar got
            putStrLn (concat ["(", show v, "/", lfs, "): ", show x]) >> loop

    void . forkIO $ downloadFiles fs ds 5
    loop


-- | Fetches a map of images, with keys being the md5 and values being
-- URLs.
fetchImageLinks ∷ [Tag] → IO [Parse String]
fetchImageLinks xs = do
  let f p = Prelude.map getInfo <$> fetchAllTaggedPosts p XML xs
        where
          getInfo (Left (PF m)) = Left . PF $ unwords [show p, m]
          getInfo (Right r) = return $ file_url `rGet` r
  g ← f Gelbooru
  i ← f Ichijou
  k ← f Konachan
  s ← f Safebooru
  y ← f Yandere
  let ls = g <> i <> k <> s <> y
  return $ length ls `seq` ls

help ∷ String
help = unlines $
  [ "Usage: h-booru tag1 [tag2] … [tagN]"
  , ""
  , "Prints a list of links matching the tags"
  , ""
  , "h-booru -d DIRECTORY tag1 [tag2] … [tagN]"
  , ""
  , "Downloads the files with the given tags to the given directory."
  , "Naming scheme is md5.originalextension"
  , "The dowloader will skip files it already sees downloaded, by filename."
  ]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE DataKinds #-}
module Main where

import Control.Applicative ((<$>))
import Control.Concurrent (forkIO)
import Control.Concurrent.STM
import Control.Monad (void, filterM)
import Data.Map
import Data.Monoid
import Data.Vinyl (rGet)
import HBooru.Network
import HBooru.Parsers.Gelbooru
import HBooru.Parsers.Ichijou
import HBooru.Parsers.Konachan
import HBooru.Parsers.Safebooru
import HBooru.Parsers.Yandere
import HBooru.Types
import System.Directory
import System.Environment (getArgs)
import System.Exit
import System.FilePath

main :: IO ()
main = getArgs >>= 
  [] -> putStr help
  "-d":d:ts -> downloadTo d ts
  xs -> fetchImageLinks xs >>= \x -> mapM_ putStrLn [ y | Right y <- x ]

-- | Downloads all the images with the given tag to the given
-- directory.
downloadTo :: FilePath -> [Tag] -> IO ()
downloadTo fp xs = doesDirectoryExist fp >>= 
  False -> print (fp <> " doesn't exist.") >> exitFailure
  True -> do
    let f p = run <$> fetchAllTaggedPosts p XML xs
          where
            run s =
              fromList [ (md5 `rGet` r, file_url `rGet` r) | Right r <- s ]
    g <- f Gelbooru
    i <- f Ichijou
    k <- f Konachan
    s <- f Safebooru
    y <- f Yandere
    let ls = g <> i <> k <> s <> y
        mkFp (m, u) = let e = snd $ splitExtension u
                      in fp </> m <.> e
    dcs <- Prelude.map (fp </>) <$> getDirectoryContents fp
    let notInFiles = (`notElem` dcs) . snd
        fs = Prelude.filter notInFiles [ (snd x, mkFp x) | x <- assocs ls ]
        lfs = show $ length fs
    ds <- atomically newTChan
    got <- newTVarIO 0
    let loop = atomically (readTChan ds) >>= 
          EndOfQueue -> putStrLn "Done."
          x -> do
            v <- atomically $ modifyTVar got succ >> readTVar got
            putStrLn (concat ["(", show v, "/", lfs, "): ", show x]) >> loop

    void . forkIO $ downloadFiles fs ds 5
    loop


-- | Fetches a map of images, with keys being the md5 and values being
-- URLs.
fetchImageLinks :: [Tag] -> IO [Parse String]
fetchImageLinks xs = do
  let f p = Prelude.map getInfo <$> fetchAllTaggedPosts p XML xs
        where
          getInfo (Left (PF m)) = Left . PF $ unwords [show p, m]
          getInfo (Right r) = return $ file_url `rGet` r
  g <- f Gelbooru
  i <- f Ichijou
  k <- f Konachan
  s <- f Safebooru
  y <- f Yandere
  let ls = g <> i <> k <> s <> y
  return $ length ls `seq` ls

help :: String
help = unlines $
  [ "Usage: h-booru tag1 [tag2] … [tagN]"
  , ""
  , "Prints a list of links matching the tags"
  , ""
  , "h-booru -d DIRECTORY tag1 [tag2] … [tagN]"
  , ""
  , "Downloads the files with the given tags to the given directory."
  , "Naming scheme is md5.originalextension"
  , "The dowloader will skip files it already sees downloaded, by filename."
  ]

</pre>