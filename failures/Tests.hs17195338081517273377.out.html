<a href="Tests.hs15519013931617819336.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Tests.hs1777724115269220094.out.html">next</a></br></br><pre>27c27
<   [ testProperty "nonNegative Binary Int" $ \i →
---
>   [ testProperty "nonNegative Binary Int" $ \i ->
29d28
<         parse (nonNegative Binary) (TP.binary i) == Parsed (i ∷ Int)
30d28
<   , testProperty "nonNegative Binary Word" $ \w →
31d28
<       parse (nonNegative Binary) (TP.binary w) == Parsed (w ∷ Word)
32c29
<   , testProperty "nonNegative Decimal Int" $ \i →
---
>         parse (nonNegative Binary) (TP.binary i) == Parsed (i :: Int)
32a30
>   , testProperty "nonNegative Binary Word" $ \w ->
32a31
>       parse (nonNegative Binary) (TP.binary w) == Parsed (w :: Word)
32a32
>   , testProperty "nonNegative Decimal Int" $ \i ->
34d33
<         parse (nonNegative Decimal) (TP.decimal i) == Parsed (i ∷ Int)
35d33
<   , testProperty "nonNegative Decimal Word" $ \w →
36d33
<       parse (nonNegative Decimal) (TP.decimal w) == Parsed (w ∷ Word)
37c34
<   , testProperty "nonNegative Hexadecimal Int" $ \i →
---
>         parse (nonNegative Decimal) (TP.decimal i) == Parsed (i :: Int)
37a35
>   , testProperty "nonNegative Decimal Word" $ \w ->
37a36
>       parse (nonNegative Decimal) (TP.decimal w) == Parsed (w :: Word)
37a37
>   , testProperty "nonNegative Hexadecimal Int" $ \i ->
39d38
<         parse (nonNegative Hexadecimal) (TP.upHex i) == Parsed (i ∷ Int)
40d38
<   , testProperty "nonNegative Hexadecimal Word" $ \w →
41d38
<       parse (nonNegative Hexadecimal) (TP.lowHex w) == Parsed (w ∷ Word)
42d38
<   , testProperty "nnCompact Decimal" $ \w →
43c39
<       parse (nnCompact Decimal) (TP.nnDecimal w) == Parsed (w ∷ Word)
---
>         parse (nonNegative Hexadecimal) (TP.upHex i) == Parsed (i :: Int)
43a40
>   , testProperty "nonNegative Hexadecimal Word" $ \w ->
43a41
>       parse (nonNegative Hexadecimal) (TP.lowHex w) == Parsed (w :: Word)
43a42
>   , testProperty "nnCompact Decimal" $ \w ->
43a43
>       parse (nnCompact Decimal) (TP.nnDecimal w) == Parsed (w :: Word)
48c48
<   , testProperty "nnUpTo Decimal 3" $ \w →
---
>   , testProperty "nnUpTo Decimal 3" $ \w ->
50d49
<         Malformed _ _ | w >= 1000        → True
51d49
<         Parsed w'     | w' == (w ∷ Word) → True
52d49
<         _                                → False
53c50
<   , testProperty "nncUpTo Decimal 3" $ \w →
---
>         Malformed _ _ | w >= 1000        -> True
53a51
>         Parsed w'     | w' == (w :: Word) -> True
53a52
>         _                                -> False
53a53
>   , testProperty "nncUpTo Decimal 3" $ \w ->
55d54
<         Malformed _ _ | w >= 1000        → True
56d54
<         Parsed w'     | w' == (w ∷ Word) → True
57c55
<         _                                → False
---
>         Malformed _ _ | w >= 1000        -> True
57a56
>         Parsed w'     | w' == (w :: Word) -> True
57a57
>         _                                -> False
62d61
<   , testProperty "nnBounded Hexadecimal Word" $ \w →
63d61
<       parse (nnBounded Hexadecimal) (TP.nnUpHex w) == Parsed (w ∷ Word)
64c62
<   , testProperty "nnBounded Hexadecimal Int" $ \i →
---
>   , testProperty "nnBounded Hexadecimal Word" $ \w ->
64a63
>       parse (nnBounded Hexadecimal) (TP.nnUpHex w) == Parsed (w :: Word)
64a64
>   , testProperty "nnBounded Hexadecimal Int" $ \i ->
66c66
<         parse (nnBounded Hexadecimal) (TP.nnUpHex i) == Parsed (i ∷ Int)
---
>         parse (nnBounded Hexadecimal) (TP.nnUpHex i) == Parsed (i :: Int)
69c69
<                             (TP.nnUpHex $ toInteger (maxBound ∷ Word) + 1)
---
>                             (TP.nnUpHex $ toInteger (maxBound :: Word) + 1)
72c72
<                             (TP.nnUpHex $ toInteger (maxBound ∷ Int) + 1)
---
>                             (TP.nnUpHex $ toInteger (maxBound :: Int) + 1)
77c77
<   , testProperty "nnBits Binary Int" $ \i →
---
>   , testProperty "nnBits Binary Int" $ \i ->
79d78
<         parse (nnBits Binary) (TP.binaryBits i) == Parsed (i ∷ Int)
80d78
<   , testProperty "nnBits Binary Word" $ \w →
81d78
<       parse (nnBits Binary) (TP.nnBinaryBits w) == Parsed (w ∷ Word)
82c79
<   , testProperty "nnBits Hexadecimal Int" $ \i →
---
>         parse (nnBits Binary) (TP.binaryBits i) == Parsed (i :: Int)
82a80
>   , testProperty "nnBits Binary Word" $ \w ->
82a81
>       parse (nnBits Binary) (TP.nnBinaryBits w) == Parsed (w :: Word)
82a82
>   , testProperty "nnBits Hexadecimal Int" $ \i ->
84d83
<         parse (nnBits Hexadecimal) (TP.upHex i) == Parsed (i ∷ Int)
85d83
<   , testProperty "nnBits Hexadecimal Word" $ \w →
86d83
<       parse (nnBits Hexadecimal) (TP.nnLowHex w) == Parsed (w ∷ Word)
87d83
<   , testProperty "nncBits Octal" $ \w →
88c84
<       parse (nncBits Octal) (TP.nnOctal w) == Parsed (w ∷ Word)
---
>         parse (nnBits Hexadecimal) (TP.upHex i) == Parsed (i :: Int)
88a85
>   , testProperty "nnBits Hexadecimal Word" $ \w ->
88a86
>       parse (nnBits Hexadecimal) (TP.nnLowHex w) == Parsed (w :: Word)
88a87
>   , testProperty "nncBits Octal" $ \w ->
88a88
>       parse (nncBits Octal) (TP.nnOctal w) == Parsed (w :: Word)
93c93
<   , testProperty "nnBitsUpTo Hexadecimal 3" $ \w →
---
>   , testProperty "nnBitsUpTo Hexadecimal 3" $ \w ->
95d94
<         Malformed _ _ | w >= 0x1000      → True
96d94
<         Parsed w'     | w' == (w ∷ Word) → True
97d94
<         _                                → False
98c95
<   , testProperty "nncBitsUpTo Octal 3" $ \w →
---
>         Malformed _ _ | w >= 0x1000      -> True
98a96
>         Parsed w'     | w' == (w :: Word) -> True
98a97
>         _                                -> False
98a98
>   , testProperty "nncBitsUpTo Octal 3" $ \w ->
100d99
<         Malformed _ _ | w >= 0o1000      → True
101d99
<         Parsed w'     | w' == (w ∷ Word) → True
102c100
<         _                                → False
---
>         Malformed _ _ | w >= 0o1000      -> True
102a101
>         Parsed w'     | w' == (w :: Word) -> True
102a102
>         _                                -> False
107d106
<   , testProperty "nnbBits Hexadecimal Word" $ \w →
108d106
<       parse (nnbBits Hexadecimal) (TP.nnUpHex w) == Parsed (w ∷ Word)
109c107
<   , testProperty "nnbBits Hexadecimal Int" $ \i →
---
>   , testProperty "nnbBits Hexadecimal Word" $ \w ->
109a108
>       parse (nnbBits Hexadecimal) (TP.nnUpHex w) == Parsed (w :: Word)
109a109
>   , testProperty "nnbBits Hexadecimal Int" $ \i ->
111c111
<         parse (nnbBits Hexadecimal) (TP.nnLowHexBits i) == Parsed (i ∷ Int)
---
>         parse (nnbBits Hexadecimal) (TP.nnLowHexBits i) == Parsed (i :: Int)
114c114
<                             (TP.nnUpHexBits $ toInteger (maxBound ∷ Word) + 1)
---
>                             (TP.nnUpHexBits $ toInteger (maxBound :: Word) + 1)
117c117
<                             (TP.nnUpHexBits $ toInteger (maxBound ∷ Int) + 1)
---
>                             (TP.nnUpHexBits $ toInteger (maxBound :: Int) + 1)
122c122
<   , testProperty "nonPositive Binary" $ \i →
---
>   , testProperty "nonPositive Binary" $ \i ->
124d123
<         parse (nonPositive Binary) (TP.npBinary i) == Parsed (i ∷ Int)
125c124
<   , testProperty "nonPositive Decimal" $ \i →
---
>         parse (nonPositive Binary) (TP.npBinary i) == Parsed (i :: Int)
125a125
>   , testProperty "nonPositive Decimal" $ \i ->
127d126
<         parse (nonPositive Decimal) (TP.npDecimal i) == Parsed (i ∷ Int)
128c127
<   , testProperty "nonPositive Hexadecimal" $ \i →
---
>         parse (nonPositive Decimal) (TP.npDecimal i) == Parsed (i :: Int)
128a128
>   , testProperty "nonPositive Hexadecimal" $ \i ->
130d129
<         parse (nonPositive Hexadecimal) (TP.npLowHex i) == Parsed (i ∷ Int)
131c130
<   , testProperty "npCompact Decimal" $ \i →
---
>         parse (nonPositive Hexadecimal) (TP.npLowHex i) == Parsed (i :: Int)
131a131
>   , testProperty "npCompact Decimal" $ \i ->
133c133
<         parse (npCompact Decimal) (TP.npDecimal i) == Parsed (i ∷ Int)
---
>         parse (npCompact Decimal) (TP.npDecimal i) == Parsed (i :: Int)
138c138
<   , testProperty "npUpTo Decimal 3" $ \i →
---
>   , testProperty "npUpTo Decimal 3" $ \i ->
140d139
<         Malformed _ _ | i <= -1000      → True
141d139
<         Parsed i'     | i' == (i ∷ Int) → True
142d139
<         _                               → False
143c140
<   , testProperty "npcUpTo Decimal 3" $ \i →
---
>         Malformed _ _ | i <= -1000      -> True
143a141
>         Parsed i'     | i' == (i :: Int) -> True
143a142
>         _                               -> False
143a143
>   , testProperty "npcUpTo Decimal 3" $ \i ->
145d144
<         Malformed _ _ | i <= -1000      → True
146d144
<         Parsed i'     | i' == (i ∷ Int) → True
147c145
<         _                               → False
---
>         Malformed _ _ | i <= -1000      -> True
147a146
>         Parsed i'     | i' == (i :: Int) -> True
147a147
>         _                               -> False
152c152
<   , testProperty "npBounded Hexadecimal" $ \i →
---
>   , testProperty "npBounded Hexadecimal" $ \i ->
154c154
<         parse (npBounded Hexadecimal) (TP.npLowHex i) == Parsed (i ∷ Int)
---
>         parse (npBounded Hexadecimal) (TP.npLowHex i) == Parsed (i :: Int)
157c157
<                             (TP.npLowHex $ toInteger (minBound ∷ Int) - 1)
---
>                             (TP.npLowHex $ toInteger (minBound :: Int) - 1)
162c162
<   , testProperty "npBits Binary" $ \i →
---
>   , testProperty "npBits Binary" $ \i ->
164d163
<         parse (npBits Binary) (TP.npBinaryBits i) == Parsed (i ∷ Int)
165c164
<   , testProperty "npBits Hexadecimal" $ \i →
---
>         parse (npBits Binary) (TP.npBinaryBits i) == Parsed (i :: Int)
165a165
>   , testProperty "npBits Hexadecimal" $ \i ->
167d166
<         parse (npBits Hexadecimal) (TP.npUpHex i) == Parsed (i ∷ Int)
168c167
<   , testProperty "npcBits Octal" $ \i →
---
>         parse (npBits Hexadecimal) (TP.npUpHex i) == Parsed (i :: Int)
168a168
>   , testProperty "npcBits Octal" $ \i ->
170c170
<         parse (npcBits Octal) (TP.npOctal i) == Parsed (i ∷ Int)
---
>         parse (npcBits Octal) (TP.npOctal i) == Parsed (i :: Int)
175c175
<   , testProperty "npBitsUpTo Hexadecimal 3" $ \i →
---
>   , testProperty "npBitsUpTo Hexadecimal 3" $ \i ->
177d176
<         Malformed _ _ | i <= -0x1000    → True
178d176
<         Parsed i'     | i' == (i ∷ Int) → True
179d176
<         _                               → False
180c177
<   , testProperty "npcBitsUpTo Octal 3" $ \i →
---
>         Malformed _ _ | i <= -0x1000    -> True
180a178
>         Parsed i'     | i' == (i :: Int) -> True
180a179
>         _                               -> False
180a180
>   , testProperty "npcBitsUpTo Octal 3" $ \i ->
182d181
<         Malformed _ _ | i <= -0o1000    → True
183d181
<         Parsed i'     | i' == (i ∷ Int) → True
184c182
<         _                               → False
---
>         Malformed _ _ | i <= -0o1000    -> True
184a183
>         Parsed i'     | i' == (i :: Int) -> True
184a184
>         _                               -> False
189c189
<   , testProperty "npbBits Hexadecimal" $ \i →
---
>   , testProperty "npbBits Hexadecimal" $ \i ->
191c191
<         parse (npbBits Hexadecimal) (TP.npUpHexBits i) == Parsed (i ∷ Int)
---
>         parse (npbBits Hexadecimal) (TP.npUpHexBits i) == Parsed (i :: Int)
194c194
<                             (TP.npUpHexBits $ toInteger (minBound ∷ Int) - 1)
---
>                             (TP.npUpHexBits $ toInteger (minBound :: Int) - 1)
199d198
<   , testProperty "number Decimal" $ \i →
200d198
<       parse (number Decimal) (TP.decimal i) == Parsed (i ∷ Int)
201d198
<   , testProperty "compact Decimal" $ \i →
202c199
<       parse (number Decimal) (TP.decimal i) == Parsed (i ∷ Int)
---
>   , testProperty "number Decimal" $ \i ->
202a200
>       parse (number Decimal) (TP.decimal i) == Parsed (i :: Int)
202a201
>   , testProperty "compact Decimal" $ \i ->
202a202
>       parse (number Decimal) (TP.decimal i) == Parsed (i :: Int)
209c209
<   , testProperty "numberUpTo Decimal 3" $ \i →
---
>   , testProperty "numberUpTo Decimal 3" $ \i ->
211d210
<         Malformed _ _ | i >= 1000 || i <= -1000 → True
212d210
<         Parsed i'     | i' == i                 → True
213d210
<         _                                       → False
214c211
<   , testProperty "compactUpTo Decimal 3" $ \i →
---
>         Malformed _ _ | i >= 1000 || i <= -1000 -> True
214a212
>         Parsed i'     | i' == i                 -> True
214a213
>         _                                       -> False
214a214
>   , testProperty "compactUpTo Decimal 3" $ \i ->
216d215
<         Malformed _ _ | i >= 1000 || i <= -1000 → True
217d215
<         Parsed i'     | i' == i                 → True
218c216
<         _                                       → False
---
>         Malformed _ _ | i >= 1000 || i <= -1000 -> True
218a217
>         Parsed i'     | i' == i                 -> True
218a218
>         _                                       -> False
225d224
<   , testProperty "bounded Decimal" $ \i →
226c225
<       parse (bounded Decimal) (TP.decimal i) == Parsed (i ∷ Int)
---
>   , testProperty "bounded Decimal" $ \i ->
226a226
>       parse (bounded Decimal) (TP.decimal i) == Parsed (i :: Int)
229c229
<                             (TP.decimal $ toInteger (maxBound ∷ Int) + 1)
---
>                             (TP.decimal $ toInteger (maxBound :: Int) + 1)
232d231
<                             (TP.decimal $ toInteger (minBound ∷ Int) - 1)
233d231
<   , testProperty "cBounded Decimal" $ \i →
234c232
<       parse (cBounded Decimal) (TP.decimal i) == Parsed (i ∷ Int)
---
>                             (TP.decimal $ toInteger (minBound :: Int) - 1)
234a233
>   , testProperty "cBounded Decimal" $ \i ->
234a234
>       parse (cBounded Decimal) (TP.decimal i) == Parsed (i :: Int)
241d240
<   , testProperty "bits Binary" $ \i →
242d240
<       parse (bits Binary) (TP.binaryBits i) == Parsed (i ∷ Int)
243d240
<   , testProperty "bits Hexadecimal" $ \i →
244d240
<       parse (bits Hexadecimal) (TP.lowHexBits i) == Parsed (i ∷ Int)
245d240
<   , testProperty "cBits Octal" $ \i →
246c241
<       parse (cBits Octal) (TP.octalBits i) == Parsed (i ∷ Int)
---
>   , testProperty "bits Binary" $ \i ->
246a242
>       parse (bits Binary) (TP.binaryBits i) == Parsed (i :: Int)
246a243
>   , testProperty "bits Hexadecimal" $ \i ->
246a244
>       parse (bits Hexadecimal) (TP.lowHexBits i) == Parsed (i :: Int)
246a245
>   , testProperty "cBits Octal" $ \i ->
246a246
>       parse (cBits Octal) (TP.octalBits i) == Parsed (i :: Int)
253c253
<   , testProperty "bitsUpTo LowHex 3" $ \i →
---
>   , testProperty "bitsUpTo LowHex 3" $ \i ->
255d254
<         Malformed _ _ | i >= 0x1000 || i <= -0x1000 → True
256d254
<         Parsed i'     | i' == i                     → True
257d254
<         _                                           → False
258c255
<   , testProperty "cBitsUpTo UpHex 3" $ \i →
---
>         Malformed _ _ | i >= 0x1000 || i <= -0x1000 -> True
258a256
>         Parsed i'     | i' == i                     -> True
258a257
>         _                                           -> False
258a258
>   , testProperty "cBitsUpTo UpHex 3" $ \i ->
260d259
<         Malformed _ _ | i >= 0x1000 || i <= -0x1000 → True
261d259
<         Parsed i'     | i' == i                     → True
262c260
<         _                                           → False
---
>         Malformed _ _ | i >= 0x1000 || i <= -0x1000 -> True
262a261
>         Parsed i'     | i' == i                     -> True
262a262
>         _                                           -> False
269d268
<   , testProperty "bBits LowHex" $ \i →
270c269
<       parse (bBits LowHex) (TP.lowHexBits i) == Parsed (i ∷ Int)
---
>   , testProperty "bBits LowHex" $ \i ->
270a270
>       parse (bBits LowHex) (TP.lowHexBits i) == Parsed (i :: Int)
273c273
<                             (TP.lowHexBits $ toInteger (maxBound ∷ Int) + 1)
---
>                             (TP.lowHexBits $ toInteger (maxBound :: Int) + 1)
276d275
<                             (TP.upHexBits $ toInteger (minBound ∷ Int) - 1)
277d275
<   , testProperty "cbBits Octal" $ \i →
278c276
<       parse (cbBits Octal) (TP.octal i) == Parsed (i ∷ Int)
---
>                             (TP.upHexBits $ toInteger (minBound :: Int) - 1)
278a277
>   , testProperty "cbBits Octal" $ \i ->
278a278
>       parse (cbBits Octal) (TP.octal i) == Parsed (i :: Int)
285d284
<   , testProperty "fraction" $ \i →
286d284
<       parse fraction (TP.fraction i) == Parsed (i ∷ Rational)
287d284
<   , testProperty "fractional (Pico)" $ \i →
288d284
<       parse fractional (print i) == Parsed (i ∷ Pico)
289c285
<   , testProperty "fractional (Float)" $ \i →
---
>   , testProperty "fraction" $ \i ->
289a286
>       parse fraction (TP.fraction i) == Parsed (i :: Rational)
289a287
>   , testProperty "fractional (Pico)" $ \i ->
289a288
>       parse fractional (print i) == Parsed (i :: Pico)
289a289
>   , testProperty "fractional (Float)" $ \i ->
291d290
<         parse fractional (print i) == Parsed (i ∷ Float)
292c291
<   , testProperty "fractional (Double)" $ \i →
---
>         parse fractional (print i) == Parsed (i :: Float)
292a292
>   , testProperty "fractional (Double)" $ \i ->
294c294
<         parse fractional (print i) == Parsed (i ∷ Double)
---
>         parse fractional (print i) == Parsed (i :: Double)
297c297
< parse ∷ (∀ μ . (Monad μ, CharParsing μ) ⇒ μ α) → StringBuilder → Parsed α
---
> parse :: (forall μ . (Monad μ, CharParsing μ) => μ α) -> StringBuilder -> Parsed α
300d299
< parseAs ∷ p α → (∀ μ . (Monad μ, CharParsing μ) ⇒ μ α) → StringBuilder
301c300
<         → Parsed α
---
> parseAs :: p α -> (forall μ . (Monad μ, CharParsing μ) => μ α) -> StringBuilder
301a301
>         -> Parsed α
303a304
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Rank2Types #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

import Test.Framework (defaultMain)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.QuickCheck ((==>))

import Prelude hiding (print)
import Data.Word (Word)
import Data.Fixed (Pico)
import Type.Hint
import Control.Applicative
import Text.Printer (StringBuilder)
import qualified Text.Printer as TP
import qualified Text.Printer.Integral as TP
import qualified Text.Printer.Fractional as TP
import Text.Parser.Combinators as PC
import Text.Parser.Char (CharParsing)

import Data.Textual
import Data.Textual.Integral
import Data.Textual.Fractional

main = defaultMain
  [ testProperty "nonNegative Binary Int" $ \i →
      (i >= 0) ==>
        parse (nonNegative Binary) (TP.binary i) == Parsed (i ∷ Int)
  , testProperty "nonNegative Binary Word" $ \w →
      parse (nonNegative Binary) (TP.binary w) == Parsed (w ∷ Word)
  , testProperty "nonNegative Decimal Int" $ \i →
      (i >= 0) ==>
        parse (nonNegative Decimal) (TP.decimal i) == Parsed (i ∷ Int)
  , testProperty "nonNegative Decimal Word" $ \w →
      parse (nonNegative Decimal) (TP.decimal w) == Parsed (w ∷ Word)
  , testProperty "nonNegative Hexadecimal Int" $ \i →
      (i >= 0) ==>
        parse (nonNegative Hexadecimal) (TP.upHex i) == Parsed (i ∷ Int)
  , testProperty "nonNegative Hexadecimal Word" $ \w →
      parse (nonNegative Hexadecimal) (TP.lowHex w) == Parsed (w ∷ Word)
  , testProperty "nnCompact Decimal" $ \w →
      parse (nnCompact Decimal) (TP.nnDecimal w) == Parsed (w ∷ Word)
  , testProperty "nnCompact Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nnCompact Decimal) "00"
  , testProperty "nnCompact Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nnCompact Decimal) "01"
  , testProperty "nnUpTo Decimal 3" $ \w →
      case parse (nnUpTo Decimal 3) (TP.nnDecimal w) of
        Malformed _ _ | w >= 1000        → True
        Parsed w'     | w' == (w ∷ Word) → True
        _                                → False
  , testProperty "nncUpTo Decimal 3" $ \w →
      case parse (nncUpTo Decimal 3) (TP.nnDecimal w) of
        Malformed _ _ | w >= 1000        → True
        Parsed w'     | w' == (w ∷ Word) → True
        _                                → False
  , testProperty "nncUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "00"
  , testProperty "nncUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "01"
  , testProperty "nnBounded Hexadecimal Word" $ \w →
      parse (nnBounded Hexadecimal) (TP.nnUpHex w) == Parsed (w ∷ Word)
  , testProperty "nnBounded Hexadecimal Int" $ \i →
      (i >= 0) ==>
        parse (nnBounded Hexadecimal) (TP.nnUpHex i) == Parsed (i ∷ Int)
  , testProperty "nnBounded Hexadecimal Word fails on overflow" $
      isMalformed $ parseAs aWord (nnBounded Hexadecimal)
                            (TP.nnUpHex $ toInteger (maxBound ∷ Word) + 1)
  , testProperty "nnBounded Hexadecimal Int fails on overflow" $
      isMalformed $ parseAs anInt (nnBounded Hexadecimal)
                            (TP.nnUpHex $ toInteger (maxBound ∷ Int) + 1)
  , testProperty "nncBounded Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBounded Decimal) "00"
  , testProperty "nncBounded Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBounded Decimal) "01"
  , testProperty "nnBits Binary Int" $ \i →
      (i >= 0) ==>
        parse (nnBits Binary) (TP.binaryBits i) == Parsed (i ∷ Int)
  , testProperty "nnBits Binary Word" $ \w →
      parse (nnBits Binary) (TP.nnBinaryBits w) == Parsed (w ∷ Word)
  , testProperty "nnBits Hexadecimal Int" $ \i →
      (i >= 0) ==>
        parse (nnBits Hexadecimal) (TP.upHex i) == Parsed (i ∷ Int)
  , testProperty "nnBits Hexadecimal Word" $ \w →
      parse (nnBits Hexadecimal) (TP.nnLowHex w) == Parsed (w ∷ Word)
  , testProperty "nncBits Octal" $ \w →
      parse (nncBits Octal) (TP.nnOctal w) == Parsed (w ∷ Word)
  , testProperty "nncBits Octal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBits Octal) "00"
  , testProperty "nncBits Octal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBits Octal) "01"
  , testProperty "nnBitsUpTo Hexadecimal 3" $ \w →
      case parse (nnBitsUpTo Hexadecimal 3) (TP.nnLowHex w) of
        Malformed _ _ | w >= 0x1000      → True
        Parsed w'     | w' == (w ∷ Word) → True
        _                                → False
  , testProperty "nncBitsUpTo Octal 3" $ \w →
      case parse (nncBitsUpTo Octal 3) (TP.nnOctal w) of
        Malformed _ _ | w >= 0o1000      → True
        Parsed w'     | w' == (w ∷ Word) → True
        _                                → False
  , testProperty "nncBitsUpTo LowHex fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBitsUpTo LowHex 3) "00"
  , testProperty "nncBitsUpTo LowHex fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBitsUpTo LowHex 3) "01"
  , testProperty "nnbBits Hexadecimal Word" $ \w →
      parse (nnbBits Hexadecimal) (TP.nnUpHex w) == Parsed (w ∷ Word)
  , testProperty "nnbBits Hexadecimal Int" $ \i →
      (i >= 0) ==>
        parse (nnbBits Hexadecimal) (TP.nnLowHexBits i) == Parsed (i ∷ Int)
  , testProperty "nnbBits Hexadecimal Word fails on overflow" $
      isMalformed $ parseAs aWord (nnbBits Hexadecimal)
                            (TP.nnUpHexBits $ toInteger (maxBound ∷ Word) + 1)
  , testProperty "nnbBits Hexadecimal Int fails on overflow" $
      isMalformed $ parseAs anInt (nnbBits Hexadecimal)
                            (TP.nnUpHexBits $ toInteger (maxBound ∷ Int) + 1)
  , testProperty "nncbBits Octal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncbBits Octal) "00"
  , testProperty "nncbBits Octal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncbBits Octal) "01"
  , testProperty "nonPositive Binary" $ \i →
      (i <= 0) ==>
        parse (nonPositive Binary) (TP.npBinary i) == Parsed (i ∷ Int)
  , testProperty "nonPositive Decimal" $ \i →
      (i <= 0) ==>
        parse (nonPositive Decimal) (TP.npDecimal i) == Parsed (i ∷ Int)
  , testProperty "nonPositive Hexadecimal" $ \i →
      (i <= 0) ==>
        parse (nonPositive Hexadecimal) (TP.npLowHex i) == Parsed (i ∷ Int)
  , testProperty "npCompact Decimal" $ \i →
      (i <= 0) ==>
        parse (npCompact Decimal) (TP.npDecimal i) == Parsed (i ∷ Int)
  , testProperty "npCompact Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (npCompact Decimal) "00"
  , testProperty "npCompact Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (npCompact Decimal) "01"
  , testProperty "npUpTo Decimal 3" $ \i →
      (i <= 0) ==> case parse (npUpTo Decimal 3) (TP.npDecimal i) of
        Malformed _ _ | i <= -1000      → True
        Parsed i'     | i' == (i ∷ Int) → True
        _                               → False
  , testProperty "npcUpTo Decimal 3" $ \i →
      (i <= 0) ==> case parse (npcUpTo Decimal 3) (TP.npDecimal i) of
        Malformed _ _ | i <= -1000      → True
        Parsed i'     | i' == (i ∷ Int) → True
        _                               → False
  , testProperty "nncUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "00"
  , testProperty "nncUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "01"
  , testProperty "npBounded Hexadecimal" $ \i →
      (i <= 0) ==>
        parse (npBounded Hexadecimal) (TP.npLowHex i) == Parsed (i ∷ Int)
  , testProperty "npBounded Hexadecimal fails on overflow" $
      isMalformed $ parseAs anInt (npBounded Hexadecimal)
                            (TP.npLowHex $ toInteger (minBound ∷ Int) - 1)
  , testProperty "npcBounded Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBounded Decimal) "00"
  , testProperty "npcBounded Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBounded Decimal) "01"
  , testProperty "npBits Binary" $ \i →
      (i <= 0) ==>
        parse (npBits Binary) (TP.npBinaryBits i) == Parsed (i ∷ Int)
  , testProperty "npBits Hexadecimal" $ \i →
      (i <= 0) ==>
        parse (npBits Hexadecimal) (TP.npUpHex i) == Parsed (i ∷ Int)
  , testProperty "npcBits Octal" $ \i →
      (i <= 0) ==>
        parse (npcBits Octal) (TP.npOctal i) == Parsed (i ∷ Int)
  , testProperty "npcBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBits Octal) "00"
  , testProperty "npcBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBits Octal) "01"
  , testProperty "npBitsUpTo Hexadecimal 3" $ \i →
      (i <= 0) ==> case parse (npBitsUpTo Hexadecimal 3) (TP.npUpHex i) of
        Malformed _ _ | i <= -0x1000    → True
        Parsed i'     | i' == (i ∷ Int) → True
        _                               → False
  , testProperty "npcBitsUpTo Octal 3" $ \i →
      (i <= 0) ==> case parse (npcBitsUpTo Octal 3) (TP.npOctal i) of
        Malformed _ _ | i <= -0o1000    → True
        Parsed i'     | i' == (i ∷ Int) → True
        _                               → False
  , testProperty "npcBitsUpTo UpHex fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBitsUpTo UpHex 3) "00"
  , testProperty "npcBitsUpTo UpHex fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBitsUpTo UpHex 3) "01"
  , testProperty "npbBits Hexadecimal" $ \i →
      (i <= 0) ==>
        parse (npbBits Hexadecimal) (TP.npUpHexBits i) == Parsed (i ∷ Int)
  , testProperty "npbBits Hexadecimal fails on overflow" $
      isMalformed $ parseAs anInt (npbBits Hexadecimal)
                            (TP.npUpHexBits $ toInteger (minBound ∷ Int) - 1)
  , testProperty "npcbBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcbBits Octal) "00"
  , testProperty "npcbBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcbBits Octal) "01"
  , testProperty "number Decimal" $ \i →
      parse (number Decimal) (TP.decimal i) == Parsed (i ∷ Int)
  , testProperty "compact Decimal" $ \i →
      parse (number Decimal) (TP.decimal i) == Parsed (i ∷ Int)
  , testProperty "compact Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (compact Decimal) "00"
  , testProperty "compact Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (compact Decimal) "01"
  , testProperty "compact Decimal fails on \"-01\"" $
      isMalformed $ parseAs anInt (compact Decimal) "-01"
  , testProperty "numberUpTo Decimal 3" $ \i →
      case parseAs anInt (numberUpTo Decimal 3) (TP.decimal i) of
        Malformed _ _ | i >= 1000 || i <= -1000 → True
        Parsed i'     | i' == i                 → True
        _                                       → False
  , testProperty "compactUpTo Decimal 3" $ \i →
      case parseAs anInt (compactUpTo Decimal 3) (TP.decimal i) of
        Malformed _ _ | i >= 1000 || i <= -1000 → True
        Parsed i'     | i' == i                 → True
        _                                       → False
  , testProperty "compactUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "00"
  , testProperty "compactUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "01"
  , testProperty "compactUpTo Decimal fails on \"-01\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "-01"
  , testProperty "bounded Decimal" $ \i →
      parse (bounded Decimal) (TP.decimal i) == Parsed (i ∷ Int)
  , testProperty "bounded Decimal fails on overflow (vs maxBound)" $
      isMalformed $ parseAs anInt (bounded Decimal)
                            (TP.decimal $ toInteger (maxBound ∷ Int) + 1)
  , testProperty "bounded Decimal fails on overflow (vs minBound)" $
      isMalformed $ parseAs anInt (bounded Decimal)
                            (TP.decimal $ toInteger (minBound ∷ Int) - 1)
  , testProperty "cBounded Decimal" $ \i →
      parse (cBounded Decimal) (TP.decimal i) == Parsed (i ∷ Int)
  , testProperty "cBounded Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "00"
  , testProperty "cBounded Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "01"
  , testProperty "cBounded Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "-01"
  , testProperty "bits Binary" $ \i →
      parse (bits Binary) (TP.binaryBits i) == Parsed (i ∷ Int)
  , testProperty "bits Hexadecimal" $ \i →
      parse (bits Hexadecimal) (TP.lowHexBits i) == Parsed (i ∷ Int)
  , testProperty "cBits Octal" $ \i →
      parse (cBits Octal) (TP.octalBits i) == Parsed (i ∷ Int)
  , testProperty "cBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBits Octal) "00"
  , testProperty "cBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBits Octal) "01"
  , testProperty "cBits Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBits Octal) "-01"
  , testProperty "bitsUpTo LowHex 3" $ \i →
      case parseAs anInt (bitsUpTo LowHex 3) (TP.lowHex i) of
        Malformed _ _ | i >= 0x1000 || i <= -0x1000 → True
        Parsed i'     | i' == i                     → True
        _                                           → False
  , testProperty "cBitsUpTo UpHex 3" $ \i →
      case parseAs anInt (cBitsUpTo UpHex 3) (TP.upHex i) of
        Malformed _ _ | i >= 0x1000 || i <= -0x1000 → True
        Parsed i'     | i' == i                     → True
        _                                           → False
  , testProperty "cBitsUpTo Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "00"
  , testProperty "cBitsUpTo Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "01"
  , testProperty "cBitsUpTo Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "-01"
  , testProperty "bBits LowHex" $ \i →
      parse (bBits LowHex) (TP.lowHexBits i) == Parsed (i ∷ Int)
  , testProperty "bBits LowHex fails on overflow (vs maxBound)" $
      isMalformed $ parseAs anInt (bBits LowHex)
                            (TP.lowHexBits $ toInteger (maxBound ∷ Int) + 1)
  , testProperty "bBits UpHex fails on overflow (vs minBound)" $
      isMalformed $ parseAs anInt (bBits UpHex)
                            (TP.upHexBits $ toInteger (minBound ∷ Int) - 1)
  , testProperty "cbBits Octal" $ \i →
      parse (cbBits Octal) (TP.octal i) == Parsed (i ∷ Int)
  , testProperty "cbBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "00"
  , testProperty "cbBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "01"
  , testProperty "cbBits Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "-01"
  , testProperty "fraction" $ \i →
      parse fraction (TP.fraction i) == Parsed (i ∷ Rational)
  , testProperty "fractional (Pico)" $ \i →
      parse fractional (print i) == Parsed (i ∷ Pico)
  , testProperty "fractional (Float)" $ \i →
      (not (isInfinite i) && not (isNaN i)) ==>
        parse fractional (print i) == Parsed (i ∷ Float)
  , testProperty "fractional (Double)" $ \i →
      (not (isInfinite i) && not (isNaN i)) ==>
        parse fractional (print i) == Parsed (i ∷ Double)
  ]

parse ∷ (∀ μ . (Monad μ, CharParsing μ) ⇒ μ α) → StringBuilder → Parsed α
parse p b = builtInParser (p <* PC.eof) (TP.buildString b)

parseAs ∷ p α → (∀ μ . (Monad μ, CharParsing μ) ⇒ μ α) → StringBuilder
        → Parsed α
parseAs _ = parse

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE Rank2Types #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}

import Test.Framework (defaultMain)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.QuickCheck ((==>))

import Prelude hiding (print)
import Data.Word (Word)
import Data.Fixed (Pico)
import Type.Hint
import Control.Applicative
import Text.Printer (StringBuilder)
import qualified Text.Printer as TP
import qualified Text.Printer.Integral as TP
import qualified Text.Printer.Fractional as TP
import Text.Parser.Combinators as PC
import Text.Parser.Char (CharParsing)

import Data.Textual
import Data.Textual.Integral
import Data.Textual.Fractional

main = defaultMain
  [ testProperty "nonNegative Binary Int" $ \i ->
      (i >= 0) ==>
        parse (nonNegative Binary) (TP.binary i) == Parsed (i :: Int)
  , testProperty "nonNegative Binary Word" $ \w ->
      parse (nonNegative Binary) (TP.binary w) == Parsed (w :: Word)
  , testProperty "nonNegative Decimal Int" $ \i ->
      (i >= 0) ==>
        parse (nonNegative Decimal) (TP.decimal i) == Parsed (i :: Int)
  , testProperty "nonNegative Decimal Word" $ \w ->
      parse (nonNegative Decimal) (TP.decimal w) == Parsed (w :: Word)
  , testProperty "nonNegative Hexadecimal Int" $ \i ->
      (i >= 0) ==>
        parse (nonNegative Hexadecimal) (TP.upHex i) == Parsed (i :: Int)
  , testProperty "nonNegative Hexadecimal Word" $ \w ->
      parse (nonNegative Hexadecimal) (TP.lowHex w) == Parsed (w :: Word)
  , testProperty "nnCompact Decimal" $ \w ->
      parse (nnCompact Decimal) (TP.nnDecimal w) == Parsed (w :: Word)
  , testProperty "nnCompact Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nnCompact Decimal) "00"
  , testProperty "nnCompact Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nnCompact Decimal) "01"
  , testProperty "nnUpTo Decimal 3" $ \w ->
      case parse (nnUpTo Decimal 3) (TP.nnDecimal w) of
        Malformed _ _ | w >= 1000        -> True
        Parsed w'     | w' == (w :: Word) -> True
        _                                -> False
  , testProperty "nncUpTo Decimal 3" $ \w ->
      case parse (nncUpTo Decimal 3) (TP.nnDecimal w) of
        Malformed _ _ | w >= 1000        -> True
        Parsed w'     | w' == (w :: Word) -> True
        _                                -> False
  , testProperty "nncUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "00"
  , testProperty "nncUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "01"
  , testProperty "nnBounded Hexadecimal Word" $ \w ->
      parse (nnBounded Hexadecimal) (TP.nnUpHex w) == Parsed (w :: Word)
  , testProperty "nnBounded Hexadecimal Int" $ \i ->
      (i >= 0) ==>
        parse (nnBounded Hexadecimal) (TP.nnUpHex i) == Parsed (i :: Int)
  , testProperty "nnBounded Hexadecimal Word fails on overflow" $
      isMalformed $ parseAs aWord (nnBounded Hexadecimal)
                            (TP.nnUpHex $ toInteger (maxBound :: Word) + 1)
  , testProperty "nnBounded Hexadecimal Int fails on overflow" $
      isMalformed $ parseAs anInt (nnBounded Hexadecimal)
                            (TP.nnUpHex $ toInteger (maxBound :: Int) + 1)
  , testProperty "nncBounded Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBounded Decimal) "00"
  , testProperty "nncBounded Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBounded Decimal) "01"
  , testProperty "nnBits Binary Int" $ \i ->
      (i >= 0) ==>
        parse (nnBits Binary) (TP.binaryBits i) == Parsed (i :: Int)
  , testProperty "nnBits Binary Word" $ \w ->
      parse (nnBits Binary) (TP.nnBinaryBits w) == Parsed (w :: Word)
  , testProperty "nnBits Hexadecimal Int" $ \i ->
      (i >= 0) ==>
        parse (nnBits Hexadecimal) (TP.upHex i) == Parsed (i :: Int)
  , testProperty "nnBits Hexadecimal Word" $ \w ->
      parse (nnBits Hexadecimal) (TP.nnLowHex w) == Parsed (w :: Word)
  , testProperty "nncBits Octal" $ \w ->
      parse (nncBits Octal) (TP.nnOctal w) == Parsed (w :: Word)
  , testProperty "nncBits Octal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBits Octal) "00"
  , testProperty "nncBits Octal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBits Octal) "01"
  , testProperty "nnBitsUpTo Hexadecimal 3" $ \w ->
      case parse (nnBitsUpTo Hexadecimal 3) (TP.nnLowHex w) of
        Malformed _ _ | w >= 0x1000      -> True
        Parsed w'     | w' == (w :: Word) -> True
        _                                -> False
  , testProperty "nncBitsUpTo Octal 3" $ \w ->
      case parse (nncBitsUpTo Octal 3) (TP.nnOctal w) of
        Malformed _ _ | w >= 0o1000      -> True
        Parsed w'     | w' == (w :: Word) -> True
        _                                -> False
  , testProperty "nncBitsUpTo LowHex fails on \"00\"" $
      isMalformed $ parseAs aWord (nncBitsUpTo LowHex 3) "00"
  , testProperty "nncBitsUpTo LowHex fails on \"01\"" $
      isMalformed $ parseAs aWord (nncBitsUpTo LowHex 3) "01"
  , testProperty "nnbBits Hexadecimal Word" $ \w ->
      parse (nnbBits Hexadecimal) (TP.nnUpHex w) == Parsed (w :: Word)
  , testProperty "nnbBits Hexadecimal Int" $ \i ->
      (i >= 0) ==>
        parse (nnbBits Hexadecimal) (TP.nnLowHexBits i) == Parsed (i :: Int)
  , testProperty "nnbBits Hexadecimal Word fails on overflow" $
      isMalformed $ parseAs aWord (nnbBits Hexadecimal)
                            (TP.nnUpHexBits $ toInteger (maxBound :: Word) + 1)
  , testProperty "nnbBits Hexadecimal Int fails on overflow" $
      isMalformed $ parseAs anInt (nnbBits Hexadecimal)
                            (TP.nnUpHexBits $ toInteger (maxBound :: Int) + 1)
  , testProperty "nncbBits Octal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncbBits Octal) "00"
  , testProperty "nncbBits Octal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncbBits Octal) "01"
  , testProperty "nonPositive Binary" $ \i ->
      (i <= 0) ==>
        parse (nonPositive Binary) (TP.npBinary i) == Parsed (i :: Int)
  , testProperty "nonPositive Decimal" $ \i ->
      (i <= 0) ==>
        parse (nonPositive Decimal) (TP.npDecimal i) == Parsed (i :: Int)
  , testProperty "nonPositive Hexadecimal" $ \i ->
      (i <= 0) ==>
        parse (nonPositive Hexadecimal) (TP.npLowHex i) == Parsed (i :: Int)
  , testProperty "npCompact Decimal" $ \i ->
      (i <= 0) ==>
        parse (npCompact Decimal) (TP.npDecimal i) == Parsed (i :: Int)
  , testProperty "npCompact Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (npCompact Decimal) "00"
  , testProperty "npCompact Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (npCompact Decimal) "01"
  , testProperty "npUpTo Decimal 3" $ \i ->
      (i <= 0) ==> case parse (npUpTo Decimal 3) (TP.npDecimal i) of
        Malformed _ _ | i <= -1000      -> True
        Parsed i'     | i' == (i :: Int) -> True
        _                               -> False
  , testProperty "npcUpTo Decimal 3" $ \i ->
      (i <= 0) ==> case parse (npcUpTo Decimal 3) (TP.npDecimal i) of
        Malformed _ _ | i <= -1000      -> True
        Parsed i'     | i' == (i :: Int) -> True
        _                               -> False
  , testProperty "nncUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "00"
  , testProperty "nncUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs aWord (nncUpTo Decimal 3) "01"
  , testProperty "npBounded Hexadecimal" $ \i ->
      (i <= 0) ==>
        parse (npBounded Hexadecimal) (TP.npLowHex i) == Parsed (i :: Int)
  , testProperty "npBounded Hexadecimal fails on overflow" $
      isMalformed $ parseAs anInt (npBounded Hexadecimal)
                            (TP.npLowHex $ toInteger (minBound :: Int) - 1)
  , testProperty "npcBounded Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBounded Decimal) "00"
  , testProperty "npcBounded Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBounded Decimal) "01"
  , testProperty "npBits Binary" $ \i ->
      (i <= 0) ==>
        parse (npBits Binary) (TP.npBinaryBits i) == Parsed (i :: Int)
  , testProperty "npBits Hexadecimal" $ \i ->
      (i <= 0) ==>
        parse (npBits Hexadecimal) (TP.npUpHex i) == Parsed (i :: Int)
  , testProperty "npcBits Octal" $ \i ->
      (i <= 0) ==>
        parse (npcBits Octal) (TP.npOctal i) == Parsed (i :: Int)
  , testProperty "npcBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBits Octal) "00"
  , testProperty "npcBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBits Octal) "01"
  , testProperty "npBitsUpTo Hexadecimal 3" $ \i ->
      (i <= 0) ==> case parse (npBitsUpTo Hexadecimal 3) (TP.npUpHex i) of
        Malformed _ _ | i <= -0x1000    -> True
        Parsed i'     | i' == (i :: Int) -> True
        _                               -> False
  , testProperty "npcBitsUpTo Octal 3" $ \i ->
      (i <= 0) ==> case parse (npcBitsUpTo Octal 3) (TP.npOctal i) of
        Malformed _ _ | i <= -0o1000    -> True
        Parsed i'     | i' == (i :: Int) -> True
        _                               -> False
  , testProperty "npcBitsUpTo UpHex fails on \"00\"" $
      isMalformed $ parseAs anInt (npcBitsUpTo UpHex 3) "00"
  , testProperty "npcBitsUpTo UpHex fails on \"01\"" $
      isMalformed $ parseAs anInt (npcBitsUpTo UpHex 3) "01"
  , testProperty "npbBits Hexadecimal" $ \i ->
      (i <= 0) ==>
        parse (npbBits Hexadecimal) (TP.npUpHexBits i) == Parsed (i :: Int)
  , testProperty "npbBits Hexadecimal fails on overflow" $
      isMalformed $ parseAs anInt (npbBits Hexadecimal)
                            (TP.npUpHexBits $ toInteger (minBound :: Int) - 1)
  , testProperty "npcbBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (npcbBits Octal) "00"
  , testProperty "npcbBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (npcbBits Octal) "01"
  , testProperty "number Decimal" $ \i ->
      parse (number Decimal) (TP.decimal i) == Parsed (i :: Int)
  , testProperty "compact Decimal" $ \i ->
      parse (number Decimal) (TP.decimal i) == Parsed (i :: Int)
  , testProperty "compact Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (compact Decimal) "00"
  , testProperty "compact Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (compact Decimal) "01"
  , testProperty "compact Decimal fails on \"-01\"" $
      isMalformed $ parseAs anInt (compact Decimal) "-01"
  , testProperty "numberUpTo Decimal 3" $ \i ->
      case parseAs anInt (numberUpTo Decimal 3) (TP.decimal i) of
        Malformed _ _ | i >= 1000 || i <= -1000 -> True
        Parsed i'     | i' == i                 -> True
        _                                       -> False
  , testProperty "compactUpTo Decimal 3" $ \i ->
      case parseAs anInt (compactUpTo Decimal 3) (TP.decimal i) of
        Malformed _ _ | i >= 1000 || i <= -1000 -> True
        Parsed i'     | i' == i                 -> True
        _                                       -> False
  , testProperty "compactUpTo Decimal fails on \"00\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "00"
  , testProperty "compactUpTo Decimal fails on \"01\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "01"
  , testProperty "compactUpTo Decimal fails on \"-01\"" $
      isMalformed $ parseAs anInt (compactUpTo Decimal 3) "-01"
  , testProperty "bounded Decimal" $ \i ->
      parse (bounded Decimal) (TP.decimal i) == Parsed (i :: Int)
  , testProperty "bounded Decimal fails on overflow (vs maxBound)" $
      isMalformed $ parseAs anInt (bounded Decimal)
                            (TP.decimal $ toInteger (maxBound :: Int) + 1)
  , testProperty "bounded Decimal fails on overflow (vs minBound)" $
      isMalformed $ parseAs anInt (bounded Decimal)
                            (TP.decimal $ toInteger (minBound :: Int) - 1)
  , testProperty "cBounded Decimal" $ \i ->
      parse (cBounded Decimal) (TP.decimal i) == Parsed (i :: Int)
  , testProperty "cBounded Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "00"
  , testProperty "cBounded Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "01"
  , testProperty "cBounded Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBounded Octal) "-01"
  , testProperty "bits Binary" $ \i ->
      parse (bits Binary) (TP.binaryBits i) == Parsed (i :: Int)
  , testProperty "bits Hexadecimal" $ \i ->
      parse (bits Hexadecimal) (TP.lowHexBits i) == Parsed (i :: Int)
  , testProperty "cBits Octal" $ \i ->
      parse (cBits Octal) (TP.octalBits i) == Parsed (i :: Int)
  , testProperty "cBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBits Octal) "00"
  , testProperty "cBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBits Octal) "01"
  , testProperty "cBits Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBits Octal) "-01"
  , testProperty "bitsUpTo LowHex 3" $ \i ->
      case parseAs anInt (bitsUpTo LowHex 3) (TP.lowHex i) of
        Malformed _ _ | i >= 0x1000 || i <= -0x1000 -> True
        Parsed i'     | i' == i                     -> True
        _                                           -> False
  , testProperty "cBitsUpTo UpHex 3" $ \i ->
      case parseAs anInt (cBitsUpTo UpHex 3) (TP.upHex i) of
        Malformed _ _ | i >= 0x1000 || i <= -0x1000 -> True
        Parsed i'     | i' == i                     -> True
        _                                           -> False
  , testProperty "cBitsUpTo Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "00"
  , testProperty "cBitsUpTo Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "01"
  , testProperty "cBitsUpTo Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cBitsUpTo Octal 3) "-01"
  , testProperty "bBits LowHex" $ \i ->
      parse (bBits LowHex) (TP.lowHexBits i) == Parsed (i :: Int)
  , testProperty "bBits LowHex fails on overflow (vs maxBound)" $
      isMalformed $ parseAs anInt (bBits LowHex)
                            (TP.lowHexBits $ toInteger (maxBound :: Int) + 1)
  , testProperty "bBits UpHex fails on overflow (vs minBound)" $
      isMalformed $ parseAs anInt (bBits UpHex)
                            (TP.upHexBits $ toInteger (minBound :: Int) - 1)
  , testProperty "cbBits Octal" $ \i ->
      parse (cbBits Octal) (TP.octal i) == Parsed (i :: Int)
  , testProperty "cbBits Octal fails on \"00\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "00"
  , testProperty "cbBits Octal fails on \"01\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "01"
  , testProperty "cbBits Octal fails on \"-01\"" $
      isMalformed $ parseAs anInt (cbBits Octal) "-01"
  , testProperty "fraction" $ \i ->
      parse fraction (TP.fraction i) == Parsed (i :: Rational)
  , testProperty "fractional (Pico)" $ \i ->
      parse fractional (print i) == Parsed (i :: Pico)
  , testProperty "fractional (Float)" $ \i ->
      (not (isInfinite i) && not (isNaN i)) ==>
        parse fractional (print i) == Parsed (i :: Float)
  , testProperty "fractional (Double)" $ \i ->
      (not (isInfinite i) && not (isNaN i)) ==>
        parse fractional (print i) == Parsed (i :: Double)
  ]

parse :: (forall μ . (Monad μ, CharParsing μ) => μ α) -> StringBuilder -> Parsed α
parse p b = builtInParser (p <* PC.eof) (TP.buildString b)

parseAs :: p α -> (forall μ . (Monad μ, CharParsing μ) => μ α) -> StringBuilder
        -> Parsed α
parseAs _ = parse


</pre>