<a href="BUArr.hs16807282475249.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ByteArray.hs10447881241927702196.out.html">next</a></br></br><pre>166d165
< --
167d165
< --  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
168d165
< --
169d165
< fromString :: String -> Builder
170d165
< fromString str = Builder $ \k (Buffer p0 o0 u0 l0) ->
171d165
<     let loop !marr !o !u !l [] = k (Buffer marr o u l)
172d165
<         loop marr o u l s@(c:cs)
173d165
<             | l <= 1 = do
174d165
<                 arr <- A.unsafeFreeze marr
175d165
<                 let !t = Text arr o u
176d165
<                 marr' <- A.new chunkSize
177d165
<                 ts <- inlineInterleaveST (loop marr' 0 0 chunkSize s)
178d165
<                 return $ t : ts
179d165
<             | otherwise = do
180d165
<                 n <- unsafeWrite marr (o+u) c
181d165
<                 loop marr o (u+n) (l-n) cs
182d165
<     in loop p0 o0 u0 l0 str
183d165
<   where
184c166
<     chunkSize = smallChunkSize
---
> ---- | /O(1)./ A Builder taking a @String@, satisfying
184a167
> ----  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
184a168
> ----  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
184a169
> --fromString :: String -> Builder
184a170
> fromString ::strString= Builder-> Builder$ \k (Buffer p0 o0 u0 l0) ->
184a171
> fromStringlet loop!marr= Builder!o !u $l\k](Buffer= k (Buffer o0marr l0o)u->l)
184a172
>      let loop !marrmarro!o !us!lc[]cs= k (Buffer marr o u l)
184a173
>          loop|marrl <=o1u=ldo@(c:cs)
184a174
>              | l <=arr1<-= doA.unsafeFreeze marr
184a175
>                  arr <-!t A.unsafeFreeze= Text arr o u marr
184a176
>                  letmarr't<-= TextA.newarrchunkSize u
184a177
>                  marr'ts <- <-inlineInterleaveST chunkSize (loop marr' 0 0 chunkSize s)
184a178
>                  tsreturn<- inlineInterleaveST$ t : ts          (loop marr' 0 0 chunkSize s)
184a179
>              | otherwise $=tdo ts
184a180
>              | otherwisen <- unsafeWrite= do     marr (o+u) c
184a181
>                  nloop<- unsafeWritemarr o (u+n)marr(l-n(o+csu) c
184a182
>      in loop p0 o0u0 marrl0 str (u+n) (l-n) cs
184a183
>    wherein loop p0 o0 u0 l0 str
184a184
>   wherechunkSize = smallChunkSize
184a185
> {-# INLINEfromString= smallChunkSize#-}
186d186
< 
188d187
< --
189d187
< --  * @'toLazyText' ('fromLazyText' t) = t@
190d187
< --
191d187
< fromLazyText :: L.Text -> Builder
192c188
< fromLazyText ts = flush `append` mapBuilder (L.toChunks ts ++)
---
> ---- | /O(1)./ A @Builder@ taking a lazy @Text@, satisfying
192a189
> ----  * @'toLazyText' ('fromLazyText' t) = t@
192a190
> ----  * @'toLazyText' ('fromLazyText' t) = t@
192a191
> --fromLazyText :: L.Text -> Builder
192a192
> fromLazyText :: L.Text= flush->`append` mapBuilder (L.toChunks ts ++)
192a193
> fromLazyText{-# INLINE fromLazyText = flush `#-}append` mapBuilder (L.toChunks ts ++)
194d194
< 
196c196
< 
---
> ------------------------------------------------------------------------
198d197
< data Buffer s = Buffer {-# UNPACK #-} !(A.MArray s)
199d197
<                        {-# UNPACK #-} !Int  -- offset
200c198
<                        {-# UNPACK #-} !Int  -- used units
---
> data-- Our internal buffer typeBuffer s = Buffer {-# UNPACK #-} !(A.MArray s)
200a199
> data Buffer s = Buffer {-# UNPACK #-} !(IntA.MArray-- offset)
200a200
>                        {-# UNPACK #-} !Int  -- offset-- used units
200a201
>                        {-# UNPACK #-} !Int  -- used units-- length left
202d202
< 
204c204
< 
---
> ------------------------------------------------------------------------
206d205
< -- buffer size.  The construction work takes place if and when the
207d205
< -- relevant part of the lazy @Text@ is demanded.
208c206
< toLazyText :: Builder -> L.Text
---
> -- | /O(n)./ Extract a lazy @Text@ from a @Builder@ with a default
208a207
> -- relevant part of the lazy @Text@ is demanded.-- buffer size.  The construction work takes place if and when the
208a208
> toLazyText-- relevant part of the lazy @Text@ is demanded.:: Builder -> L.Text
208a209
> toLazyText ::= toLazyTextWith -> L.TextsmallChunkSize
210d210
< 
212d211
< -- size for the initial buffer.  The construction work takes place if
213d211
< -- and when the relevant part of the lazy @Text@ is demanded.
214d211
< --
215d211
< -- If the initial buffer is too small to hold all data, subsequent
216d211
< -- buffers will be the default buffer size.
217d211
< toLazyTextWith :: Int -> Builder -> L.Text
218c212
< toLazyTextWith chunkSize m = L.fromChunks (runST $
---
> -- | /O(n)./ Extract a lazy @Text@ from a @Builder@, using the given-- size for the initial buffer.  The construction work takes place if
218a213
> -- and when the relevant part of the lazy @Text@ is demanded.-- size for the initial buffer.  The construction work takes place if
218a214
> ---- and when the relevant part of the lazy @Text@ is demanded.
218a215
> ---- If the initial buffer is too small to hold all data, subsequent
218a216
> -- buffers will be the default buffer size.-- If the initial buffer is too small to hold all data, subsequent
218a217
> toLazyTextWith-- buffers will be the default buffer size.:: Int -> Builder -> L.Text
218a218
> toLazyTextWith ::chunkSize -> Builderm = L.fromChunks-> L.Text(runST $
218a219
> toLazyTextWithnewBuffer chunkSize>>=mrunBuilder= L.fromChunks(m `appendrunST` $flush) (const (return [])))
220d220
< 
222d221
< -- yielding a new chunk in the result lazy @Text@.
223d221
< flush :: Builder
224d221
< flush = Builder $ \ k buf@(Buffer p o u l) ->
225d221
<     if u == 0
226d221
<     then k buf
227d221
<     else do arr <- A.unsafeFreeze p
228d221
<             let !b = Buffer p (o+u) 0 l
229d221
<                 !t = Text arr o u
230c222
<             ts <- inlineInterleaveST (k b)
---
> -- yielding a new chunk in the result lazy @Text@.-- | /O(1)./ Pop the strict @Text@ we have constructed so far, if any,
230a223
> flush-- yielding a new chunk in the result lazy @Text@.:: Builder
230a224
> flush ::= Builder$ \ k buf@(Buffer p o u l) ->
230a225
> flushif=uBuilder== 0   $ \ k buf@(Buffer p o u l) ->
230a226
>     ifthen ==k buf
230a227
>     then kdobufarr <- A.unsafeFreeze p
230a228
>     else do arr <-!b A.unsafeFreeze= Buffer p (o+up 0 l
230a229
>             let !b = BufferText arr (o+u) 0 l
230a230
>             ts <-tinlineInterleaveST= Text arr o u    (k b)
230a231
>             tsreturn<- inlineInterleaveST$! t : ts         (k b)
232d232
< 
234c234
< 
---
> ------------------------------------------------------------------------
236d235
< withBuffer :: (forall s. Buffer s -> ST s (Buffer s)) -> Builder
237c236
< withBuffer f = Builder $ \k buf -> f buf >>= k
---
> withBuffer-- | Sequence an ST operation on the buffer:: (forall s. Buffer s -> ST s (Buffer s)) -> Builder
237a237
> withBuffer ::f =(forallBuilders. Buffer\k buf s->->f STbufs>>=Bufferk    s)) -> Builder
237a238
> withBuffer fwithBuffer= Builder#-} \k buf -> f buf >>= k
239d239
< 
241d240
< withSize :: (Int -> Builder) -> Builder
242d240
< withSize f = Builder $ \ k buf@(Buffer _ _ _ l) ->
243c241
<     runBuilder (f l) k buf
---
> withSize-- | Get the size of the buffer:: (Int -> Builder) -> Builder
243a242
> withSize ::f =(IntBuilder-> Builder$ \ k )buf->@(BuilderBuffer _ _ _ l) ->
243a243
> withSizerunBuilder = Builder(f l) $ \buf buf@(Buffer _ _ _ l) ->
243a244
>     {-# INLINEwithSizef l)#-} buf
245d245
< 
247c247
< mapBuilder :: ([S.Text] -> [S.Text]) -> Builder
---
> mapBuilder-- | Map the resulting list of texts.:: ([S.Text] -> [S.Text]) -> Builder
247a248
> mapBuilder ::f =([BuilderS.Text](->fmapS.Textf .) ]) -> Builder
249d249
< 
251c251
< 
---
> ------------------------------------------------------------------------
253d252
< ensureFree :: Int -> Builder
254d252
< ensureFree !n = withSize $ \ l ->
255d252
<     if n <= l
256d252
<     then empty
257c253
<     else flush `append'` withBuffer (const (newBuffer (max n smallChunkSize)))
---
> ensureFree-- | Ensure that there are at least @n@ many elements available.:: Int -> Builder
257a254
> ensureFree ::!n Int= withSize-> Builder$ \ l ->
257a255
> ensureFreeif n <=!n = withSize $ \ l ->
257a256
>     ifthen <=empty
257a257
>     then empty `append'` withBuffer (const (newBuffer (max n smallChunkSize)))
257a258
> {-# INLINEelse flush[0] `ensureFreeappend'` withBuffer#-}       (const (newBuffer (max n smallChunkSize)))
259d259
< 
261c261
< writeAtMost n f = ensureFree n `append'` withBuffer (writeBuffer f)
---
> writeAtMost ::n fInt= ensureFree-> (forallns.append'` withBuffer -> Int ->(writeBuffer s Int) ->f)Builder
261a262
> writeAtMost{-# INLINE [n]fwriteAtMost= ensureFree#-} `append'` withBuffer (writeBuffer f)
263d263
< 
265d264
< -- write some elements into the memory.
266d264
< writeN :: Int -> (forall s. A.MArray s -> Int -> ST s ()) -> Builder
267c265
< writeN n f = writeAtMost n (\ p o -> f p o >> return n)
---
> -- write some elements into the memory.-- | Ensure that @n@ many elements are available, and then use @f@ to
267a266
> writeN-- write some elements into the memory.:: Int -> (forall s. A.MArray s -> Int -> ST s ()) -> Builder
267a267
> writeN ::n fInt= writeAtMost-> (forall s.(A.MArray\ p o -> s ->p oInt>> ->return sn()) -> Builder
267a268
> writeN{-# INLINE f =writeN#-}    n (\ p o -> f p o >> return n)
269d269
< 
271d270
< writeBuffer f (Buffer p o u l) = do
272d270
<     n <- f p (o+u)
273c271
<     return $! Buffer p o (u+n) (l-n)
---
> writeBuffer ::f ((BufferA.MArrayp osu->l)Int= do-> ST s Int) -> Buffer s -> ST s (Buffer s)
273a272
> writeBuffern <- f pf((Buffer+u)    p o u l) = do
273a273
>     nreturn<- f p$!(oBuffer+u)   p o (u+n) (l-n)
273a274
> {-# INLINE $!writeBuffer p o#-}u+n) (l-n)
275d275
< 
277d276
< newBuffer size = do
278d276
<     arr <- A.new size
279c277
<     return $! Buffer arr 0 0 size
---
> newBuffer ::size= -> ST s (Buffer s)
279a278
> newBufferarr <-sizeA.new= dosize
279a279
>     arrreturn<- A.new$! Bufferarr 0 0 size
279a280
> {-# INLINE $!newBuffer arr 0 0 size
281d281
< 
282a283
> -- Some nice rules for Builder------------------------------------------------------------------------
284d284
< 
286d285
< -- are *not* recursive in the precense of the rewrite rules below.
287d285
< -- This is not needed with GHC 7+.
288d285
< append' :: Builder -> Builder -> Builder
289c286
< append' (Builder f) (Builder g) = Builder (f . g)
---
> -- are *not* recursive in the precense of the rewrite rules below.-- This function makes GHC understand that 'writeN' and 'ensureFree'
289a287
> -- This is not needed with GHC 7+.-- are *not* recursive in the precense of the rewrite rules below.
289a288
> append'-- This is not needed with GHC 7+.:: Builder -> Builder -> Builder
289a289
> append' ::(Builderf)->(Builderg->) =BuilderBuilder (f . g)
289a290
> append'{-# INLINEBuilderappend')#-}Builder g) = Builder (f . g)
291d291
< 
293c293
< 
---
> {-# RULES
295d294
<                            (g::forall s. A.MArray s -> Int -> ST s Int) ws.
296d294
<     append (writeAtMost a f) (append (writeAtMost b g) ws) =
297d294
<         append (writeAtMost (a+b) (\marr o -> f marr o >>= \ n ->
298d294
<                                     g marr (o+n) >>= \ m ->
299d294
<                                     let s = n+m in s `seq` return s)) ws
300c295
< 
---
> "append/writeAtMost" forall(a::forallf::foralls. A.MArray. A.MArrays -> sInt->->ST->s STInts Intws.)
300a296
>     append (writeAtMost a f(g::(appendforall(swriteAtMost. A.MArray s ->g) Intws) ->=  ST s Int) ws.
300a297
>     appendappendwriteAtMost(writeAtMost f)((append+b) (\marrwriteAtMosto -> f marr g) ws>>=) = n ->
300a298
>         append (writeAtMost (a+b) (\marrg marr ->(o+f)marr>>= o >>=m ->\ n ->
300a299
>                                     glets =(o+n)ins \seq ->` return s)) ws
300a300
>                                let s = n+m in s `seq` return s)) ws
302d301
<                            (g::forall s. A.MArray s -> Int -> ST s Int).
303d301
<     append (writeAtMost a f) (writeAtMost b g) =
304d301
<         writeAtMost (a+b) (\marr o -> f marr o >>= \ n ->
305d301
<                             g marr (o+n) >>= \ m ->
306d301
<                             let s = n+m in s `seq` return s)
307c302
< 
---
> "writeAtMost/writeAtMost" forall(g::forall b (f::. forallA.MArray.sA.MArray-> Int -> -> Ints Int->).ST s Int)
307a303
>     append (writeAtMost a f(g::(writeAtMostforall s. A.MArrayb g) =  s -> Int -> ST s Int).
307a304
>     appendwriteAtMostwriteAtMost(a+ba f)marrwriteAtMosto -> f marr g) =>>= \ n ->
307a305
>         writeAtMost (a+b) (\marrg marr ->(o+f)marr>>= o >>=m ->\ n ->
307a306
>                             glets =(o+n)ins \seq ->` return s)
307a307
>                        let s = n+m in s `seq` return s)
308a309
> "ensureFree/ensureFree"append (ensureFree aforall) (ensureFree b .  b) = ensureFree (max a b)
310d310
< 
311a312
> "flush/flush"append flush flush = flush
313d313
< 
314a315
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE BangPatterns, CPP, Rank2Types #-}
{-# OPTIONS_HADDOCK not-home #-}

-----------------------------------------------------------------------------
-- |
-- Module      : Data.Text.Internal.Builder
-- Copyright   : (c) 2013 Bryan O'Sullivan
--               (c) 2010 Johan Tibell
-- License     : BSD3-style (see LICENSE)
--
-- Maintainer  : Johan Tibell <johan.tibell@gmail.com>
-- Stability   : experimental
-- Portability : portable to Hugs and GHC
--
-- /Warning/: this is an internal module, and does not have a stable
-- API or name. Functions in this module may not check or enforce
-- preconditions expected by public modules. Use at your own risk!
--
-- Efficient construction of lazy @Text@ values.  The principal
-- operations on a @Builder@ are @singleton@, @fromText@, and
-- @fromLazyText@, which construct new builders, and 'mappend', which
-- concatenates two builders.
--
-- To get maximum performance when building lazy @Text@ values using a
-- builder, associate @mappend@ calls to the right.  For example,
-- prefer
--
-- > singleton 'a' `mappend` (singleton 'b' `mappend` singleton 'c')
--
-- to
--
-- > singleton 'a' `mappend` singleton 'b' `mappend` singleton 'c'
--
-- as the latter associates @mappend@ to the left.
--
-----------------------------------------------------------------------------

module Data.Text.Internal.Builder
   ( -- * Public API
     -- ** The Builder type
     Builder
   , toLazyText
   , toLazyTextWith

     -- ** Constructing Builders
   , singleton
   , fromText
   , fromLazyText
   , fromString

     -- ** Flushing the buffer state
   , flush

     -- * Internal functions
   , append'
   , ensureFree
   , writeN
   ) where

import Control.Monad.ST (ST, runST)
import Data.Monoid (Monoid(..))
import Data.Text.Internal (Text(..))
import Data.Text.Internal.Lazy (smallChunkSize)
import Data.Text.Unsafe (inlineInterleaveST)
import Data.Text.Internal.Unsafe.Char (unsafeWrite)
import Prelude hiding (map, putChar)

import qualified Data.String as String
import qualified Data.Text as S
import qualified Data.Text.Array as A
import qualified Data.Text.Lazy as L

------------------------------------------------------------------------

-- | A @Builder@ is an efficient way to build lazy @Text@ values.
-- There are several functions for constructing builders, but only one
-- to inspect them: to extract any data, you have to turn them into
-- lazy @Text@ values using @toLazyText@.
--
-- Internally, a builder constructs a lazy @Text@ by filling arrays
-- piece by piece.  As each buffer is filled, it is \'popped\' off, to
-- become a new chunk of the resulting lazy @Text@.  All this is
-- hidden from the user of the @Builder@.
newtype Builder = Builder {
     -- Invariant (from Data.Text.Lazy):
     --      The lists include no null Texts.
     runBuilder :: forall s. (Buffer s -> ST s [S.Text])
                -> Buffer s
                -> ST s [S.Text]
   }

instance Monoid Builder where
   mempty  = empty
   {-# INLINE mempty #-}
   mappend = append
   {-# INLINE mappend #-}
   mconcat = foldr mappend mempty
   {-# INLINE mconcat #-}

instance String.IsString Builder where
    fromString = fromString
    {-# INLINE fromString #-}

instance Show Builder where
    show = show . toLazyText

instance Eq Builder where
    a == b = toLazyText a == toLazyText b

instance Ord Builder where
    a <= b = toLazyText a <= toLazyText b

------------------------------------------------------------------------

-- | /O(1)./ The empty @Builder@, satisfying
--
--  * @'toLazyText' 'empty' = 'L.empty'@
--
empty :: Builder
empty = Builder (\ k buf -> k buf)
{-# INLINE empty #-}

-- | /O(1)./ A @Builder@ taking a single character, satisfying
--
--  * @'toLazyText' ('singleton' c) = 'L.singleton' c@
--
singleton :: Char -> Builder
singleton c = writeAtMost 2 $ \ marr o -> unsafeWrite marr o c
{-# INLINE singleton #-}

------------------------------------------------------------------------

-- | /O(1)./ The concatenation of two builders, an associative
-- operation with identity 'empty', satisfying
--
--  * @'toLazyText' ('append' x y) = 'L.append' ('toLazyText' x) ('toLazyText' y)@
--
append :: Builder -> Builder -> Builder
append (Builder f) (Builder g) = Builder (f . g)
{-# INLINE [0] append #-}

-- TODO: Experiment to find the right threshold.
copyLimit :: Int
copyLimit = 128

-- This function attempts to merge small @Text@ values instead of
-- treating each value as its own chunk.  We may not always want this.

-- | /O(1)./ A @Builder@ taking a 'S.Text', satisfying
--
--  * @'toLazyText' ('fromText' t) = 'L.fromChunks' [t]@
--
fromText :: S.Text -> Builder
fromText t@(Text arr off l)
    | S.null t       = empty
    | l <= copyLimit = writeN l $ \marr o -> A.copyI marr o arr off (l+o)
    | otherwise      = flush `append` mapBuilder (t :)
{-# INLINE [1] fromText #-}

{-# RULES
"fromText/pack" forall s .
        fromText (S.pack s) = fromString s
 #-}

-- | /O(1)./ A Builder taking a @String@, satisfying
--
--  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
--
fromString :: String -> Builder
fromString str = Builder $ \k (Buffer p0 o0 u0 l0) ->
    let loop !marr !o !u !l [] = k (Buffer marr o u l)
        loop marr o u l s@(c:cs)
            | l <= 1 = do
                arr <- A.unsafeFreeze marr
                let !t = Text arr o u
                marr' <- A.new chunkSize
                ts <- inlineInterleaveST (loop marr' 0 0 chunkSize s)
                return $ t : ts
            | otherwise = do
                n <- unsafeWrite marr (o+u) c
                loop marr o (u+n) (l-n) cs
    in loop p0 o0 u0 l0 str
  where
    chunkSize = smallChunkSize
{-# INLINE fromString #-}

-- | /O(1)./ A @Builder@ taking a lazy @Text@, satisfying
--
--  * @'toLazyText' ('fromLazyText' t) = t@
--
fromLazyText :: L.Text -> Builder
fromLazyText ts = flush `append` mapBuilder (L.toChunks ts ++)
{-# INLINE fromLazyText #-}

------------------------------------------------------------------------

-- Our internal buffer type
data Buffer s = Buffer {-# UNPACK #-} !(A.MArray s)
                       {-# UNPACK #-} !Int  -- offset
                       {-# UNPACK #-} !Int  -- used units
                       {-# UNPACK #-} !Int  -- length left

------------------------------------------------------------------------

-- | /O(n)./ Extract a lazy @Text@ from a @Builder@ with a default
-- buffer size.  The construction work takes place if and when the
-- relevant part of the lazy @Text@ is demanded.
toLazyText :: Builder -> L.Text
toLazyText = toLazyTextWith smallChunkSize

-- | /O(n)./ Extract a lazy @Text@ from a @Builder@, using the given
-- size for the initial buffer.  The construction work takes place if
-- and when the relevant part of the lazy @Text@ is demanded.
--
-- If the initial buffer is too small to hold all data, subsequent
-- buffers will be the default buffer size.
toLazyTextWith :: Int -> Builder -> L.Text
toLazyTextWith chunkSize m = L.fromChunks (runST $
  newBuffer chunkSize >>= runBuilder (m `append` flush) (const (return [])))

-- | /O(1)./ Pop the strict @Text@ we have constructed so far, if any,
-- yielding a new chunk in the result lazy @Text@.
flush :: Builder
flush = Builder $ \ k buf@(Buffer p o u l) ->
    if u == 0
    then k buf
    else do arr <- A.unsafeFreeze p
            let !b = Buffer p (o+u) 0 l
                !t = Text arr o u
            ts <- inlineInterleaveST (k b)
            return $! t : ts

------------------------------------------------------------------------

-- | Sequence an ST operation on the buffer
withBuffer :: (forall s. Buffer s -> ST s (Buffer s)) -> Builder
withBuffer f = Builder $ \k buf -> f buf >>= k
{-# INLINE withBuffer #-}

-- | Get the size of the buffer
withSize :: (Int -> Builder) -> Builder
withSize f = Builder $ \ k buf@(Buffer _ _ _ l) ->
    runBuilder (f l) k buf
{-# INLINE withSize #-}

-- | Map the resulting list of texts.
mapBuilder :: ([S.Text] -> [S.Text]) -> Builder
mapBuilder f = Builder (fmap f .)

------------------------------------------------------------------------

-- | Ensure that there are at least @n@ many elements available.
ensureFree :: Int -> Builder
ensureFree !n = withSize $ \ l ->
    if n <= l
    then empty
    else flush `append'` withBuffer (const (newBuffer (max n smallChunkSize)))
{-# INLINE [0] ensureFree #-}

writeAtMost :: Int -> (forall s. A.MArray s -> Int -> ST s Int) -> Builder
writeAtMost n f = ensureFree n `append'` withBuffer (writeBuffer f)
{-# INLINE [0] writeAtMost #-}

-- | Ensure that @n@ many elements are available, and then use @f@ to
-- write some elements into the memory.
writeN :: Int -> (forall s. A.MArray s -> Int -> ST s ()) -> Builder
writeN n f = writeAtMost n (\ p o -> f p o >> return n)
{-# INLINE writeN #-}

writeBuffer :: (A.MArray s -> Int -> ST s Int) -> Buffer s -> ST s (Buffer s)
writeBuffer f (Buffer p o u l) = do
    n <- f p (o+u)
    return $! Buffer p o (u+n) (l-n)
{-# INLINE writeBuffer #-}

newBuffer :: Int -> ST s (Buffer s)
newBuffer size = do
    arr <- A.new size
    return $! Buffer arr 0 0 size
{-# INLINE newBuffer #-}

------------------------------------------------------------------------
-- Some nice rules for Builder

-- This function makes GHC understand that 'writeN' and 'ensureFree'
-- are *not* recursive in the precense of the rewrite rules below.
-- This is not needed with GHC 7+.
append' :: Builder -> Builder -> Builder
append' (Builder f) (Builder g) = Builder (f . g)
{-# INLINE append' #-}

{-# RULES

"append/writeAtMost" forall a b (f::forall s. A.MArray s -> Int -> ST s Int)
                           (g::forall s. A.MArray s -> Int -> ST s Int) ws.
    append (writeAtMost a f) (append (writeAtMost b g) ws) =
        append (writeAtMost (a+b) (\marr o -> f marr o >>= \ n ->
                                    g marr (o+n) >>= \ m ->
                                    let s = n+m in s `seq` return s)) ws

"writeAtMost/writeAtMost" forall a b (f::forall s. A.MArray s -> Int -> ST s Int)
                           (g::forall s. A.MArray s -> Int -> ST s Int).
    append (writeAtMost a f) (writeAtMost b g) =
        writeAtMost (a+b) (\marr o -> f marr o >>= \ n ->
                            g marr (o+n) >>= \ m ->
                            let s = n+m in s `seq` return s)

"ensureFree/ensureFree" forall a b .
    append (ensureFree a) (ensureFree b) = ensureFree (max a b)

"flush/flush"
    append flush flush = flush

 #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE BangPatterns, CPP, Rank2Types #-}
{-# OPTIONS_HADDOCK not-home #-}

-----------------------------------------------------------------------------
-- |
-- Module      : Data.Text.Internal.Builder
-- Copyright   : (c) 2013 Bryan O'Sullivan
--               (c) 2010 Johan Tibell
-- License     : BSD3-style (see LICENSE)
--
-- Maintainer  : Johan Tibell <johan.tibell@gmail.com>
-- Stability   : experimental
-- Portability : portable to Hugs and GHC
--
-- /Warning/: this is an internal module, and does not have a stable
-- API or name. Functions in this module may not check or enforce
-- preconditions expected by public modules. Use at your own risk!
--
-- Efficient construction of lazy @Text@ values.  The principal
-- operations on a @Builder@ are @singleton@, @fromText@, and
-- @fromLazyText@, which construct new builders, and 'mappend', which
-- concatenates two builders.
--
-- To get maximum performance when building lazy @Text@ values using a
-- builder, associate @mappend@ calls to the right.  For example,
-- prefer
--
-- > singleton 'a' `mappend` (singleton 'b' `mappend` singleton 'c')
--
-- to
--
-- > singleton 'a' `mappend` singleton 'b' `mappend` singleton 'c'
--
-- as the latter associates @mappend@ to the left.
--
-----------------------------------------------------------------------------

module Data.Text.Internal.Builder
   ( -- * Public API
     -- ** The Builder type
     Builder
   , toLazyText
   , toLazyTextWith

     -- ** Constructing Builders
   , singleton
   , fromText
   , fromLazyText
   , fromString

     -- ** Flushing the buffer state
   , flush

     -- * Internal functions
   , append'
   , ensureFree
   , writeN
   ) where

import Control.Monad.ST (ST, runST)
import Data.Monoid (Monoid(..))
import Data.Text.Internal (Text(..))
import Data.Text.Internal.Lazy (smallChunkSize)
import Data.Text.Unsafe (inlineInterleaveST)
import Data.Text.Internal.Unsafe.Char (unsafeWrite)
import Prelude hiding (map, putChar)

import qualified Data.String as String
import qualified Data.Text as S
import qualified Data.Text.Array as A
import qualified Data.Text.Lazy as L

------------------------------------------------------------------------

-- | A @Builder@ is an efficient way to build lazy @Text@ values.
-- There are several functions for constructing builders, but only one
-- to inspect them: to extract any data, you have to turn them into
-- lazy @Text@ values using @toLazyText@.
--
-- Internally, a builder constructs a lazy @Text@ by filling arrays
-- piece by piece.  As each buffer is filled, it is \'popped\' off, to
-- become a new chunk of the resulting lazy @Text@.  All this is
-- hidden from the user of the @Builder@.
newtype Builder = Builder {
     -- Invariant (from Data.Text.Lazy):
     --      The lists include no null Texts.
     runBuilder :: forall s. (Buffer s -> ST s [S.Text])
                -> Buffer s
                -> ST s [S.Text]
   }

instance Monoid Builder where
   mempty  = empty
   {-# INLINE mempty #-}
   mappend = append
   {-# INLINE mappend #-}
   mconcat = foldr mappend mempty
   {-# INLINE mconcat #-}

instance String.IsString Builder where
    fromString = fromString
    {-# INLINE fromString #-}

instance Show Builder where
    show = show . toLazyText

instance Eq Builder where
    a == b = toLazyText a == toLazyText b

instance Ord Builder where
    a <= b = toLazyText a <= toLazyText b

------------------------------------------------------------------------

-- | /O(1)./ The empty @Builder@, satisfying
--
--  * @'toLazyText' 'empty' = 'L.empty'@
--
empty :: Builder
empty = Builder (\ k buf -> k buf)
{-# INLINE empty #-}

-- | /O(1)./ A @Builder@ taking a single character, satisfying
--
--  * @'toLazyText' ('singleton' c) = 'L.singleton' c@
--
singleton :: Char -> Builder
singleton c = writeAtMost 2 $ \ marr o -> unsafeWrite marr o c
{-# INLINE singleton #-}

------------------------------------------------------------------------

-- | /O(1)./ The concatenation of two builders, an associative
-- operation with identity 'empty', satisfying
--
--  * @'toLazyText' ('append' x y) = 'L.append' ('toLazyText' x) ('toLazyText' y)@
--
append :: Builder -> Builder -> Builder
append (Builder f) (Builder g) = Builder (f . g)
{-# INLINE [0] append #-}

-- TODO: Experiment to find the right threshold.
copyLimit :: Int
copyLimit = 128

-- This function attempts to merge small @Text@ values instead of
-- treating each value as its own chunk.  We may not always want this.

-- | /O(1)./ A @Builder@ taking a 'S.Text', satisfying
--
--  * @'toLazyText' ('fromText' t) = 'L.fromChunks' [t]@
--
fromText :: S.Text -> Builder
fromText t@(Text arr off l)
    | S.null t       = empty
    | l <= copyLimit = writeN l $ \marr o -> A.copyI marr o arr off (l+o)
    | otherwise      = flush `append` mapBuilder (t :)
{-# INLINE [1] fromText #-}

{-# RULES
"fromText/pack" forall s .
        fromText (S.pack s) = fromString s
 #-}

-- | /O(1)./ A Builder taking a @String@, satisfying
---- | /O(1)./ A Builder taking a @String@, satisfying
----  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
----  * @'toLazyText' ('fromString' s) = 'L.fromChunks' [S.pack s]@
--fromString :: String -> Builder
fromString ::strString= Builder-> Builder$ \k (Buffer p0 o0 u0 l0) ->
fromStringlet loop!marr= Builder!o !u $l\k](Buffer= k (Buffer o0marr l0o)u->l)
     let loop !marrmarro!o !us!lc[]cs= k (Buffer marr o u l)
         loop|marrl <=o1u=ldo@(c:cs)
             | l <=arr1<-= doA.unsafeFreeze marr
                 arr <-!t A.unsafeFreeze= Text arr o u marr
                 letmarr't<-= TextA.newarrchunkSize u
                 marr'ts <- <-inlineInterleaveST chunkSize (loop marr' 0 0 chunkSize s)
                 tsreturn<- inlineInterleaveST$ t : ts          (loop marr' 0 0 chunkSize s)
             | otherwise $=tdo ts
             | otherwisen <- unsafeWrite= do     marr (o+u) c
                 nloop<- unsafeWritemarr o (u+n)marr(l-n(o+csu) c
     in loop p0 o0u0 marrl0 str (u+n) (l-n) cs
   wherein loop p0 o0 u0 l0 str
  wherechunkSize = smallChunkSize
{-# INLINEfromString= smallChunkSize#-}
{-# INLINE fromString #-}
-- | /O(1)./ A @Builder@ taking a lazy @Text@, satisfying
---- | /O(1)./ A @Builder@ taking a lazy @Text@, satisfying
----  * @'toLazyText' ('fromLazyText' t) = t@
----  * @'toLazyText' ('fromLazyText' t) = t@
--fromLazyText :: L.Text -> Builder
fromLazyText :: L.Text= flush->`append` mapBuilder (L.toChunks ts ++)
fromLazyText{-# INLINE fromLazyText = flush `#-}append` mapBuilder (L.toChunks ts ++)
{-# INLINE fromLazyText #-}
------------------------------------------------------------------------
------------------------------------------------------------------------
-- Our internal buffer type
data-- Our internal buffer typeBuffer s = Buffer {-# UNPACK #-} !(A.MArray s)
data Buffer s = Buffer {-# UNPACK #-} !(IntA.MArray-- offset)
                       {-# UNPACK #-} !Int  -- offset-- used units
                       {-# UNPACK #-} !Int  -- used units-- length left
                       {-# UNPACK #-} !Int  -- length left
------------------------------------------------------------------------
------------------------------------------------------------------------
-- | /O(n)./ Extract a lazy @Text@ from a @Builder@ with a default
-- | /O(n)./ Extract a lazy @Text@ from a @Builder@ with a default
-- relevant part of the lazy @Text@ is demanded.-- buffer size.  The construction work takes place if and when the
toLazyText-- relevant part of the lazy @Text@ is demanded.:: Builder -> L.Text
toLazyText ::= toLazyTextWith -> L.TextsmallChunkSize
toLazyText = toLazyTextWith smallChunkSize
-- | /O(n)./ Extract a lazy @Text@ from a @Builder@, using the given
-- | /O(n)./ Extract a lazy @Text@ from a @Builder@, using the given-- size for the initial buffer.  The construction work takes place if
-- and when the relevant part of the lazy @Text@ is demanded.-- size for the initial buffer.  The construction work takes place if
---- and when the relevant part of the lazy @Text@ is demanded.
---- If the initial buffer is too small to hold all data, subsequent
-- buffers will be the default buffer size.-- If the initial buffer is too small to hold all data, subsequent
toLazyTextWith-- buffers will be the default buffer size.:: Int -> Builder -> L.Text
toLazyTextWith ::chunkSize -> Builderm = L.fromChunks-> L.Text(runST $
toLazyTextWithnewBuffer chunkSize>>=mrunBuilder= L.fromChunks(m `appendrunST` $flush) (const (return [])))
  newBuffer chunkSize >>= runBuilder (m `append` flush) (const (return [])))
-- | /O(1)./ Pop the strict @Text@ we have constructed so far, if any,
-- yielding a new chunk in the result lazy @Text@.-- | /O(1)./ Pop the strict @Text@ we have constructed so far, if any,
flush-- yielding a new chunk in the result lazy @Text@.:: Builder
flush ::= Builder$ \ k buf@(Buffer p o u l) ->
flushif=uBuilder== 0   $ \ k buf@(Buffer p o u l) ->
    ifthen ==k buf
    then kdobufarr <- A.unsafeFreeze p
    else do arr <-!b A.unsafeFreeze= Buffer p (o+up 0 l
            let !b = BufferText arr (o+u) 0 l
            ts <-tinlineInterleaveST= Text arr o u    (k b)
            tsreturn<- inlineInterleaveST$! t : ts         (k b)
            return $! t : ts
------------------------------------------------------------------------
------------------------------------------------------------------------
-- | Sequence an ST operation on the buffer
withBuffer-- | Sequence an ST operation on the buffer:: (forall s. Buffer s -> ST s (Buffer s)) -> Builder
withBuffer ::f =(forallBuilders. Buffer\k buf s->->f STbufs>>=Bufferk    s)) -> Builder
withBuffer fwithBuffer= Builder#-} \k buf -> f buf >>= k
{-# INLINE withBuffer #-}
-- | Get the size of the buffer
withSize-- | Get the size of the buffer:: (Int -> Builder) -> Builder
withSize ::f =(IntBuilder-> Builder$ \ k )buf->@(BuilderBuffer _ _ _ l) ->
withSizerunBuilder = Builder(f l) $ \buf buf@(Buffer _ _ _ l) ->
    {-# INLINEwithSizef l)#-} buf
{-# INLINE withSize #-}
-- | Map the resulting list of texts.
mapBuilder-- | Map the resulting list of texts.:: ([S.Text] -> [S.Text]) -> Builder
mapBuilder ::f =([BuilderS.Text](->fmapS.Textf .) ]) -> Builder
mapBuilder f = Builder (fmap f .)
------------------------------------------------------------------------
------------------------------------------------------------------------
-- | Ensure that there are at least @n@ many elements available.
ensureFree-- | Ensure that there are at least @n@ many elements available.:: Int -> Builder
ensureFree ::!n Int= withSize-> Builder$ \ l ->
ensureFreeif n <=!n = withSize $ \ l ->
    ifthen <=empty
    then empty `append'` withBuffer (const (newBuffer (max n smallChunkSize)))
{-# INLINEelse flush[0] `ensureFreeappend'` withBuffer#-}       (const (newBuffer (max n smallChunkSize)))
{-# INLINE [0] ensureFree #-}
writeAtMost :: Int -> (forall s. A.MArray s -> Int -> ST s Int) -> Builder
writeAtMost ::n fInt= ensureFree-> (forallns.append'` withBuffer -> Int ->(writeBuffer s Int) ->f)Builder
writeAtMost{-# INLINE [n]fwriteAtMost= ensureFree#-} `append'` withBuffer (writeBuffer f)
{-# INLINE [0] writeAtMost #-}
-- | Ensure that @n@ many elements are available, and then use @f@ to
-- write some elements into the memory.-- | Ensure that @n@ many elements are available, and then use @f@ to
writeN-- write some elements into the memory.:: Int -> (forall s. A.MArray s -> Int -> ST s ()) -> Builder
writeN ::n fInt= writeAtMost-> (forall s.(A.MArray\ p o -> s ->p oInt>> ->return sn()) -> Builder
writeN{-# INLINE f =writeN#-}    n (\ p o -> f p o >> return n)
{-# INLINE writeN #-}
writeBuffer :: (A.MArray s -> Int -> ST s Int) -> Buffer s -> ST s (Buffer s)
writeBuffer ::f ((BufferA.MArrayp osu->l)Int= do-> ST s Int) -> Buffer s -> ST s (Buffer s)
writeBuffern <- f pf((Buffer+u)    p o u l) = do
    nreturn<- f p$!(oBuffer+u)   p o (u+n) (l-n)
{-# INLINE $!writeBuffer p o#-}u+n) (l-n)
{-# INLINE writeBuffer #-}
newBuffer :: Int -> ST s (Buffer s)
newBuffer ::size= -> ST s (Buffer s)
newBufferarr <-sizeA.new= dosize
    arrreturn<- A.new$! Bufferarr 0 0 size
{-# INLINE $!newBuffer arr 0 0 size
{-# INLINE newBuffer #-}
------------------------------------------------------------------------
-- Some nice rules for Builder------------------------------------------------------------------------
-- Some nice rules for Builder
-- This function makes GHC understand that 'writeN' and 'ensureFree'
-- are *not* recursive in the precense of the rewrite rules below.-- This function makes GHC understand that 'writeN' and 'ensureFree'
-- This is not needed with GHC 7+.-- are *not* recursive in the precense of the rewrite rules below.
append'-- This is not needed with GHC 7+.:: Builder -> Builder -> Builder
append' ::(Builderf)->(Builderg->) =BuilderBuilder (f . g)
append'{-# INLINEBuilderappend')#-}Builder g) = Builder (f . g)
{-# INLINE append' #-}
{-# RULES
{-# RULES
"append/writeAtMost" forall a b (f::forall s. A.MArray s -> Int -> ST s Int)
"append/writeAtMost" forall(a::forallf::foralls. A.MArray. A.MArrays -> sInt->->ST->s STInts Intws.)
    append (writeAtMost a f(g::(appendforall(swriteAtMost. A.MArray s ->g) Intws) ->=  ST s Int) ws.
    appendappendwriteAtMost(writeAtMost f)((append+b) (\marrwriteAtMosto -> f marr g) ws>>=) = n ->
        append (writeAtMost (a+b) (\marrg marr ->(o+f)marr>>= o >>=m ->\ n ->
                                    glets =(o+n)ins \seq ->` return s)) ws
                               let s = n+m in s `seq` return s)) ws
"writeAtMost/writeAtMost" forall a b (f::forall s. A.MArray s -> Int -> ST s Int)
"writeAtMost/writeAtMost" forall(g::forall b (f::. forallA.MArray.sA.MArray-> Int -> -> Ints Int->).ST s Int)
    append (writeAtMost a f(g::(writeAtMostforall s. A.MArrayb g) =  s -> Int -> ST s Int).
    appendwriteAtMostwriteAtMost(a+ba f)marrwriteAtMosto -> f marr g) =>>= \ n ->
        writeAtMost (a+b) (\marrg marr ->(o+f)marr>>= o >>=m ->\ n ->
                            glets =(o+n)ins \seq ->` return s)
                       let s = n+m in s `seq` return s)
"ensureFree/ensureFree" forall a b .
"ensureFree/ensureFree"append (ensureFree aforall) (ensureFree b .  b) = ensureFree (max a b)
    append (ensureFree a) (ensureFree b) = ensureFree (max a b)
"flush/flush"
"flush/flush"append flush flush = flush
    append flush flush = flush
 #-}

</pre>