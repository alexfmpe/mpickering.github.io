<a href="PowerShell.hs15478371072028841238.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Pragma.hs5950286351962408013.out.html">next</a></br></br><pre>9d8
< {-# OPTIONS_GHC -cpp #-} -- {-# LANGUAGE CPP #-}
10d8
< {-# OPTIONS     -cpp #-} -- {-# LANGUAGE CPP #-}
11d8
< {-# OPTIONS_YHC -cpp #-}
12d8
< {-# OPTIONS_GHC -XFoo #-} -- {-# LANGUAGE Foo #-}
13d8
< {-# OPTIONS_GHC -fglasgow-exts #-} -- ???
14d8
< {-# LANGUAGE A, B, C, A #-} -- {-# LANGUAGE A, B, C #-}
15d8
< {-# LANGUAGE A #-}
16d8
< {-# OPTIONS_GHC -cpp -foo #-} -- {-# LANGUAGE CPP #-} {-# OPTIONS_GHC -foo #-}
17d8
< {-# OPTIONS_GHC -cpp #-} \
18d8
< {-# LANGUAGE CPP, Text #-} --
19d8
< {-# LANGUAGE A #-} \
20d8
< {-# LANGUAGE B #-}
21d8
< {-# LANGUAGE A #-} \
22c9
< {-# LANGUAGE B, A #-} -- {-# LANGUAGE A, B #-}
---
> {-# OPTIONS_GHC -cpp # -- {-# LANGUAGE CPP #
22a10
> {-# OPTIONS     -cpp # -- {-# LANGUAGE CPP #
22a11
> {-# OPTIONS_YHC -cpp #
22a12
> {-# OPTIONS_GHC -XFoo # -- {-# LANGUAGE Foo #
22a13
> {-# OPTIONS_GHC -fglasgow-exts # -- ???
22a14
> {-# LANGUAGE A, B, C, A # -- {-# LANGUAGE A, B, C #
22a15
> {-# LANGUAGE A #
22a16
> {-# OPTIONS_GHC -cpp -foo # -- {-# LANGUAGE CPP # {-# OPTIONS_GHC -foo #
22a17
> {-# OPTIONS_GHC -cpp # \
22a18
> {-# LANGUAGE CPP, Text # --
22a19
> {-# LANGUAGE A # \
22a20
> {-# LANGUAGE B #
22a21
> {-# LANGUAGE A # \
22a22
> {-# LANGUAGE B, A # -- {-# LANGUAGE A, B #
70c70
<         keep = concat $ zipWith (\v s -> [s | isNothing v]) vs strs
---
>         keep = concat $ zipWith (\v s ->    |s | isNothing v]) vs strs
72a73
> 
</pre></br><h2>original</h2></br><pre>{-
    Suggest better pragmas
    OPTIONS_GHC -cpp => LANGUAGE CPP
    OPTIONS_GHC -fglasgow-exts => LANGUAGE ... (in HSE)
    OPTIONS_GHC -XFoo => LANGUAGE Foo
    LANGUAGE A, A => LANGUAGE A
    -- do not do LANGUAGE A, LANGUAGE B to combine
<TEST>
{-# OPTIONS_GHC -cpp #-} -- {-# LANGUAGE CPP #-}
{-# OPTIONS     -cpp #-} -- {-# LANGUAGE CPP #-}
{-# OPTIONS_YHC -cpp #-}
{-# OPTIONS_GHC -XFoo #-} -- {-# LANGUAGE Foo #-}
{-# OPTIONS_GHC -fglasgow-exts #-} -- ???
{-# LANGUAGE A, B, C, A #-} -- {-# LANGUAGE A, B, C #-}
{-# LANGUAGE A #-}
{-# OPTIONS_GHC -cpp -foo #-} -- {-# LANGUAGE CPP #-} {-# OPTIONS_GHC -foo #-}
{-# OPTIONS_GHC -cpp #-} \
{-# LANGUAGE CPP, Text #-} --
{-# LANGUAGE A #-} \
{-# LANGUAGE B #-}
{-# LANGUAGE A #-} \
{-# LANGUAGE B, A #-} -- {-# LANGUAGE A, B #-}
</TEST>
-}


module Hint.Pragma(pragmaHint) where

import Hint.Type
import Data.List
import Data.Maybe


pragmaHint :: ModuHint
pragmaHint _ x = languageDupes lang ++ [pragmaIdea old $ [LanguagePragma an (map toNamed ns2) | ns2 /= []] ++ catMaybes new | old /= []]
    where
        lang = [x | x@LanguagePragma{} <- modulePragmas x]
        (old,new,ns) = unzip3 [(old,new,ns) | old <- modulePragmas x, Just (new,ns) <- [optToLanguage old]]
        ns2 = nub (concat ns) \\ concat [map fromNamed n | LanguagePragma _ n <- lang]


pragmaIdea :: [ModulePragma S] -> [ModulePragma S] -> Idea
pragmaIdea xs ys = rawIdea Error "Use better pragmas" (toSrcSpan $ ann $ head xs) (f xs) (Just $ f ys) []
    where f = unlines . map prettyPrint


languageDupes :: [ModulePragma S] -> [Idea]
languageDupes (a@(LanguagePragma _ x):xs) =
    (if nub_ x `neqList` x
        then [pragmaIdea [a] [LanguagePragma an $ nub_ x]]
        else [pragmaIdea [a,b] [LanguagePragma an (nub_ $ x ++ y)] | b@(LanguagePragma _ y) <- xs, not $ null $ intersect_ x y]) ++
    languageDupes xs
languageDupes _ = []


-- Given a pragma, can you extract some language features out
strToLanguage :: String -> Maybe [String]
strToLanguage "-cpp" = Just ["CPP"]
strToLanguage x | "-X" `isPrefixOf` x = Just [drop 2 x]
strToLanguage "-fglasgow-exts" = Just $ map show glasgowExts
strToLanguage _ = Nothing


optToLanguage :: ModulePragma S -> Maybe (Maybe (ModulePragma S), [String])
optToLanguage (OptionsPragma sl tool val)
    | maybe True (== GHC) tool && any isJust vs = Just (res, concat $ catMaybes vs)
    where
        strs = words val
        vs = map strToLanguage strs
        keep = concat $ zipWith (\v s -> [s | isNothing v]) vs strs
        res = if null keep then Nothing else Just $ OptionsPragma sl tool (unwords keep)
optToLanguage _ = Nothing
</pre></br><h2>printed</h2></br><pre>{-
    Suggest better pragmas
    OPTIONS_GHC -cpp => LANGUAGE CPP
    OPTIONS_GHC -fglasgow-exts => LANGUAGE ... (in HSE)
    OPTIONS_GHC -XFoo => LANGUAGE Foo
    LANGUAGE A, A => LANGUAGE A
    -- do not do LANGUAGE A, LANGUAGE B to combine
<TEST>
{-# OPTIONS_GHC -cpp # -- {-# LANGUAGE CPP #
{-# OPTIONS     -cpp # -- {-# LANGUAGE CPP #
{-# OPTIONS_YHC -cpp #
{-# OPTIONS_GHC -XFoo # -- {-# LANGUAGE Foo #
{-# OPTIONS_GHC -fglasgow-exts # -- ???
{-# LANGUAGE A, B, C, A # -- {-# LANGUAGE A, B, C #
{-# LANGUAGE A #
{-# OPTIONS_GHC -cpp -foo # -- {-# LANGUAGE CPP # {-# OPTIONS_GHC -foo #
{-# OPTIONS_GHC -cpp # \
{-# LANGUAGE CPP, Text # --
{-# LANGUAGE A # \
{-# LANGUAGE B #
{-# LANGUAGE A # \
{-# LANGUAGE B, A # -- {-# LANGUAGE A, B #
</TEST>
-}


module Hint.Pragma(pragmaHint) where

import Hint.Type
import Data.List
import Data.Maybe


pragmaHint :: ModuHint
pragmaHint _ x = languageDupes lang ++ [pragmaIdea old $ [LanguagePragma an (map toNamed ns2) | ns2 /= []] ++ catMaybes new | old /= []]
    where
        lang = [x | x@LanguagePragma{} <- modulePragmas x]
        (old,new,ns) = unzip3 [(old,new,ns) | old <- modulePragmas x, Just (new,ns) <- [optToLanguage old]]
        ns2 = nub (concat ns) \\ concat [map fromNamed n | LanguagePragma _ n <- lang]


pragmaIdea :: [ModulePragma S] -> [ModulePragma S] -> Idea
pragmaIdea xs ys = rawIdea Error "Use better pragmas" (toSrcSpan $ ann $ head xs) (f xs) (Just $ f ys) []
    where f = unlines . map prettyPrint


languageDupes :: [ModulePragma S] -> [Idea]
languageDupes (a@(LanguagePragma _ x):xs) =
    (if nub_ x `neqList` x
        then [pragmaIdea [a] [LanguagePragma an $ nub_ x]]
        else [pragmaIdea [a,b] [LanguagePragma an (nub_ $ x ++ y)] | b@(LanguagePragma _ y) <- xs, not $ null $ intersect_ x y]) ++
    languageDupes xs
languageDupes _ = []


-- Given a pragma, can you extract some language features out
strToLanguage :: String -> Maybe [String]
strToLanguage "-cpp" = Just ["CPP"]
strToLanguage x | "-X" `isPrefixOf` x = Just [drop 2 x]
strToLanguage "-fglasgow-exts" = Just $ map show glasgowExts
strToLanguage _ = Nothing


optToLanguage :: ModulePragma S -> Maybe (Maybe (ModulePragma S), [String])
optToLanguage (OptionsPragma sl tool val)
    | maybe True (== GHC) tool && any isJust vs = Just (res, concat $ catMaybes vs)
    where
        strs = words val
        vs = map strToLanguage strs
        keep = concat $ zipWith (\v s ->    |s | isNothing v]) vs strs
        res = if null keep then Nothing else Just $ OptionsPragma sl tool (unwords keep)
optToLanguage _ = Nothing

</pre>