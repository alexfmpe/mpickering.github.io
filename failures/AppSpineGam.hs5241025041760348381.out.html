<a href="AppSpineGam.hs11541129911104740033.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Apt.hs172315317770982397.out.html">next</a></br></br><pre>21c21
< {-# LINE 48 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
21a22
> 
21a23
> 
21a24
> 
21a25
> 
21a26
> 
21a27
> 
21a28
> 
21a29
> 
21a30
> 
21a31
> 
21a32
> 
21a33
> 
21a34
> 
21a35
> 
21a36
> 
21a37
> 
21a38
> 
21a39
> 
21a40
> 
21a41
> 
21a42
> 
21a43
> 
21a44
> 
21a45
> 
21a46
> 
21a47
> 
46c72
< {-# LINE 98 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
46a73
> 
46a74
> 
46a75
> 
46a76
> 
46a77
> 
46a78
> 
46a79
> 
46a80
> 
46a81
> 
46a82
> 
46a83
> 
46a84
> 
46a85
> 
46a86
> 
46a87
> 
46a88
> 
46a89
> 
46a90
> 
46a91
> 
46a92
> 
46a93
> 
46a94
> 
46a95
> 
46a96
> 
46a97
> 
53c104
< {-# LINE 106 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
53a105
> 
57c109
< {-# LINE 111 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
57a110
> 
61c114
< {-# LINE 120 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
61a115
> 
61a116
> 
61a117
> 
61a118
> 
61a119
> 
72c130
< {-# LINE 137 "src/ehc/Ty/AppSpineGam.chs" #-}
---
> 
72a131
> 
72a132
> 
72a133
> 
72a134
> 
72a135
> 
72a136
> 
79a144
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Ty.AppSpineGam
( module UHC.Light.Compiler.Gam.AppSpineGam
, asGamLookup
, mkAppSpineGam
, asFOUpdCoe )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Gam.AppSpineGam
import UHC.Light.Compiler.Gam.AppSpineGam
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty.FIEnv
import UHC.Util.Utils
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Core.Subst


{-# LINE 48 "src/ehc/Ty/AppSpineGam.chs" #-}
arrowAppSpineVertebraeInfoL :: FIEnv -> [AppSpineVertebraeInfo]
arrowAppSpineVertebraeInfoL env
  = [ AppSpineVertebraeInfo polContravariant fioMkStrong
          asFODflt
          (Just dfltFOUpdCoe)
    , AppSpineVertebraeInfo polCovariant id
          asFOArrow
          (Just (\opts [ffo,afo]
                  -> let (u',u1) = mkNewUID (foUniq afo)
                         -- c = lrcoeForLamTyApp opts u1 (foCSubst afo) (foLRCoe ffo) (foLRCoe afo)
                         (c,s) = lrcoeForLamTyAppAsSubst opts u1 (foLRCoe ffo) (foLRCoe afo)
                     in  afo { foUniq = u'
                             , foLRCoe = c
                             , foCSubst = foCSubst afo `cSubstApp` s
                             }
          )     )
    ]

prodAppSpineVertebraeInfoL :: [AppSpineVertebraeInfo]
prodAppSpineVertebraeInfoL
  = repeat
    $ AppSpineVertebraeInfo polCovariant id asFODflt
          (Just dfltFOUpdCoe)

{-# LINE 98 "src/ehc/Ty/AppSpineGam.chs" #-}
dfltFOUpdCoe :: AppSpineFOUpdCoe
dfltFOUpdCoe _ x = last' (panic "Ty.AppSpineGam.dfltFOUpdCoe") x

asFOUpdCoe :: AppSpineVertebraeInfo -> AppSpineFOUpdCoe
asFOUpdCoe = maybe dfltFOUpdCoe id . asMbFOUpdCoe

{-# LINE 106 "src/ehc/Ty/AppSpineGam.chs" #-}
asFODflt :: FIOut -> FIOut -> FIOut
asFODflt _ afo = afo

{-# LINE 111 "src/ehc/Ty/AppSpineGam.chs" #-}
asFOArrow :: FIOut -> FIOut -> FIOut
asFOArrow _ afo = afo {foLInstToL = InstTo_Plain : foLInstToL afo, foRInstToL = InstTo_Plain : foRInstToL afo}

{-# LINE 120 "src/ehc/Ty/AppSpineGam.chs" #-}
asGamLookup :: HsName -> AppSpineGam -> Maybe AppSpineInfo
asGamLookup nm g
  = case gamLookup nm g of
      j@(Just _)
        -> j
      Nothing | hsnIsProd nm
        -> Just $ emptyAppSpineInfo {asgiVertebraeL = take (hsnProdArity nm) prodAppSpineVertebraeInfoL}
      _ -> Nothing


{-# LINE 137 "src/ehc/Ty/AppSpineGam.chs" #-}
mkAppSpineGam ::  FIEnv -> AppSpineGam
mkAppSpineGam env
  = assocLToGam
      [ (hsnArrow       , emptyAppSpineInfo {asgiVertebraeL = arrowAppSpineVertebraeInfoL env})
      , (hsnRec         , emptyAppSpineInfo {asgiVertebraeL = take 1 prodAppSpineVertebraeInfoL})
      ]

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Ty.AppSpineGam
( module UHC.Light.Compiler.Gam.AppSpineGam
, asGamLookup
, mkAppSpineGam
, asFOUpdCoe )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Gam.AppSpineGam
import UHC.Light.Compiler.Gam.AppSpineGam
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty.FIEnv
import UHC.Util.Utils
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Core.Subst





























arrowAppSpineVertebraeInfoL :: FIEnv -> [AppSpineVertebraeInfo]
arrowAppSpineVertebraeInfoL env
  = [ AppSpineVertebraeInfo polContravariant fioMkStrong
          asFODflt
          (Just dfltFOUpdCoe)
    , AppSpineVertebraeInfo polCovariant id
          asFOArrow
          (Just (\opts [ffo,afo]
                  -> let (u',u1) = mkNewUID (foUniq afo)
                         -- c = lrcoeForLamTyApp opts u1 (foCSubst afo) (foLRCoe ffo) (foLRCoe afo)
                         (c,s) = lrcoeForLamTyAppAsSubst opts u1 (foLRCoe ffo) (foLRCoe afo)
                     in  afo { foUniq = u'
                             , foLRCoe = c
                             , foCSubst = foCSubst afo `cSubstApp` s
                             }
          )     )
    ]

prodAppSpineVertebraeInfoL :: [AppSpineVertebraeInfo]
prodAppSpineVertebraeInfoL
  = repeat
    $ AppSpineVertebraeInfo polCovariant id asFODflt
          (Just dfltFOUpdCoe)



























dfltFOUpdCoe :: AppSpineFOUpdCoe
dfltFOUpdCoe _ x = last' (panic "Ty.AppSpineGam.dfltFOUpdCoe") x

asFOUpdCoe :: AppSpineVertebraeInfo -> AppSpineFOUpdCoe
asFOUpdCoe = maybe dfltFOUpdCoe id . asMbFOUpdCoe



asFODflt :: FIOut -> FIOut -> FIOut
asFODflt _ afo = afo



asFOArrow :: FIOut -> FIOut -> FIOut
asFOArrow _ afo = afo {foLInstToL = InstTo_Plain : foLInstToL afo, foRInstToL = InstTo_Plain : foRInstToL afo}







asGamLookup :: HsName -> AppSpineGam -> Maybe AppSpineInfo
asGamLookup nm g
  = case gamLookup nm g of
      j@(Just _)
        -> j
      Nothing | hsnIsProd nm
        -> Just $ emptyAppSpineInfo {asgiVertebraeL = take (hsnProdArity nm) prodAppSpineVertebraeInfoL}
      _ -> Nothing









mkAppSpineGam ::  FIEnv -> AppSpineGam
mkAppSpineGam env
  = assocLToGam
      [ (hsnArrow       , emptyAppSpineInfo {asgiVertebraeL = arrowAppSpineVertebraeInfoL env})
      , (hsnRec         , emptyAppSpineInfo {asgiVertebraeL = take 1 prodAppSpineVertebraeInfoL})
      ]


</pre>