<a href="Val.hs1137446057156454405.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ValGam.hs16351793081110398897.out.html">next</a></br></br><pre>23c23
< {-# LINE 126 "src/ehc/CodeGen/ValAccess.chs" #-}
---
> 
23a24
> 
23a25
> 
23a26
> 
23a27
> 
23a28
> 
23a29
> 
23a30
> 
23a31
> 
23a32
> 
23a33
> 
23a34
> 
23a35
> 
23a36
> 
23a37
> 
23a38
> 
23a39
> 
23a40
> 
23a41
> 
23a42
> 
23a43
> 
23a44
> 
23a45
> 
23a46
> 
23a47
> 
23a48
> 
23a49
> 
23a50
> 
23a51
> 
23a52
> 
23a53
> 
23a54
> 
23a55
> 
23a56
> 
23a57
> 
23a58
> 
23a59
> 
23a60
> 
23a61
> 
23a62
> 
23a63
> 
23a64
> 
23a65
> 
23a66
> 
23a67
> 
23a68
> 
23a69
> 
23a70
> 
23a71
> 
23a72
> 
23a73
> 
23a74
> 
23a75
> 
23a76
> 
23a77
> 
23a78
> 
23a79
> 
23a80
> 
23a81
> 
23a82
> 
23a83
> 
23a84
> 
23a85
> 
23a86
> 
23a87
> 
23a88
> 
23a89
> 
23a90
> 
23a91
> 
23a92
> 
23a93
> 
23a94
> 
23a95
> 
23a96
> 
23a97
> 
23a98
> 
23a99
> 
23a100
> 
23a101
> 
23a102
> 
23a103
> 
23a104
> 
23a105
> 
23a106
> 
23a107
> 
23a108
> 
23a109
> 
23a110
> 
23a111
> 
23a112
> 
23a113
> 
23a114
> 
23a115
> 
23a116
> 
23a117
> 
23a118
> 
23a119
> 
23a120
> 
23a121
> 
23a122
> 
23a123
> 
23a124
> 
23a125
> 
28c130
< {-# LINE 136 "src/ehc/CodeGen/ValAccess.chs" #-}
---
> 
28a131
> 
28a132
> 
28a133
> 
28a134
> 
28a135
> 
32c139
< {-# LINE 141 "src/ehc/CodeGen/ValAccess.chs" #-}
---
> 
32a140
> 
36c144
< {-# LINE 146 "src/ehc/CodeGen/ValAccess.chs" #-}
---
> 
36a145
> 
44c153
< {-# LINE 159 "src/ehc/CodeGen/ValAccess.chs" #-}
---
> 
44a154
> 
44a155
> 
44a156
> 
44a157
> 
44a158
> 
50a165
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.CodeGen.ValAccess
( module UHC.Light.Compiler.CodeGen.BasicAnnot
, patNmL2DepL
, AltFetch (..)
, HsName2RefMp, HsName2RefMpMp
, HsName2FldMpMp, HsName2FldMp
, offMpKeysSorted, offMpMpKeysSet )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Util.Utils
import UHC.Util.Pretty as Pretty
import Data.Bits
import Data.Maybe
import qualified UHC.Util.FastSeq as Seq
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import Control.Monad.State
import UHC.Light.Compiler.CodeGen.BasicAnnot

{-# LINE 126 "src/ehc/CodeGen/ValAccess.chs" #-}
-- | Generate references starting at offset 0 with additional direction tweaking
patNmL2DepL :: RefGenerator r => (Int -> Int) -> ([HsName] -> [HsName]) -> [HsName] -> AssocL HsName r
patNmL2DepL fd fl nmL = refGen 0 (fd 1) (fl nmL)

{-# LINE 136 "src/ehc/CodeGen/ValAccess.chs" #-}
type HsName2RefMp meref = Map.Map HsName meref
type HsName2RefMpMp mref meref = Map.Map HsName (mref, HsName2RefMp meref)

{-# LINE 141 "src/ehc/CodeGen/ValAccess.chs" #-}
type HsName2FldMp   = HsName2RefMp   Fld
type HsName2FldMpMp = HsName2RefMpMp Fld Fld

{-# LINE 146 "src/ehc/CodeGen/ValAccess.chs" #-}
-- | Module names, sorted on import order, which is included as 0-based offset (used as index in import entry table)
offMpKeysSorted :: (Ord mref, RefOfFld Fld mref) => HsName2FldMpMp -> AssocL HsName mref
offMpKeysSorted m = sortOn snd [ (n, refOfFld o) | (n,(o,_)) <- Map.toList m ]

offMpMpKeysSet :: HsName2RefMpMp mref meref -> HsNameS
offMpMpKeysSet m = Set.unions [ Map.keysSet m' | (_,m') <- Map.elems m ]

{-# LINE 159 "src/ehc/CodeGen/ValAccess.chs" #-}
data AltFetch lref
  = AltFetch_Many   [HsName]                -- multiple introduced names
  | AltFetch_One    HsName lref             -- single introduced name, field ref in node (excluding header)
  | AltFetch_Zero
  deriving Eq

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.CodeGen.ValAccess
( module UHC.Light.Compiler.CodeGen.BasicAnnot
, patNmL2DepL
, AltFetch (..)
, HsName2RefMp, HsName2RefMpMp
, HsName2FldMpMp, HsName2FldMp
, offMpKeysSorted, offMpMpKeysSet )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Util.Utils
import UHC.Util.Pretty as Pretty
import Data.Bits
import Data.Maybe
import qualified UHC.Util.FastSeq as Seq
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import Control.Monad.State
import UHC.Light.Compiler.CodeGen.BasicAnnot








































































































-- | Generate references starting at offset 0 with additional direction tweaking
patNmL2DepL :: RefGenerator r => (Int -> Int) -> ([HsName] -> [HsName]) -> [HsName] -> AssocL HsName r
patNmL2DepL fd fl nmL = refGen 0 (fd 1) (fl nmL)







type HsName2RefMp meref = Map.Map HsName meref
type HsName2RefMpMp mref meref = Map.Map HsName (mref, HsName2RefMp meref)



type HsName2FldMp   = HsName2RefMp   Fld
type HsName2FldMpMp = HsName2RefMpMp Fld Fld



-- | Module names, sorted on import order, which is included as 0-based offset (used as index in import entry table)
offMpKeysSorted :: (Ord mref, RefOfFld Fld mref) => HsName2FldMpMp -> AssocL HsName mref
offMpKeysSorted m = sortOn snd [ (n, refOfFld o) | (n,(o,_)) <- Map.toList m ]

offMpMpKeysSet :: HsName2RefMpMp mref meref -> HsNameS
offMpMpKeysSet m = Set.unions [ Map.keysSet m' | (_,m') <- Map.elems m ]







data AltFetch lref
  = AltFetch_Many   [HsName]                -- multiple introduced names
  | AltFetch_One    HsName lref             -- single introduced name, field ref in node (excluding header)
  | AltFetch_Zero
  deriving Eq


</pre>