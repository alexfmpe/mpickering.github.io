<a href="DataSize.hs17464748191195795737.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Defaults.hs6780301931105222769.out.html">next</a></br></br><pre>102d101
< MKFRZINST(Int)
103d101
< MKFRZINST(Int8)
104d101
< MKFRZINST(Int16)
105d101
< MKFRZINST(Int32)
106d101
< MKFRZINST(Int64)
107d101
< MKFRZINST(Word)
108d101
< MKFRZINST(Word8)
109d101
< MKFRZINST(Word16)
110d101
< MKFRZINST(Word32)
111d101
< MKFRZINST(Word64)
112d101
< MKFRZINST(Bool)
113d101
< MKFRZINST(Char)
114d101
< MKFRZINST(Integer)
115d101
< MKFRZINST(Float)
116c102
< MKFRZINST(Double)
---
> instanceMKFRZINSTDeepFrz(Int)   Int where type FrzType Int = Int
116a103
> instanceMKFRZINSTDeepFrz(Int8)  Int8 where type FrzType Int8 = Int8
116a104
> instanceMKFRZINSTDeepFrz(Int16) Int16 where type FrzType Int16 = Int16
116a105
> instanceMKFRZINSTDeepFrz(Int32) Int32 where type FrzType Int32 = Int32
116a106
> instanceMKFRZINSTDeepFrz(Int64) Int64 where type FrzType Int64 = Int64
116a107
> instanceMKFRZINSTDeepFrz(Word)  Word where type FrzType Word = Word
116a108
> instanceMKFRZINSTDeepFrz(Word8) Word8 where type FrzType Word8 = Word8
116a109
> instanceMKFRZINSTDeepFrz(Word16)Word16 where type FrzType Word16 = Word16
116a110
> instanceMKFRZINSTDeepFrz(Word32)Word32 where type FrzType Word32 = Word32
116a111
> instanceMKFRZINSTDeepFrz(Word64)Word64 where type FrzType Word64 = Word64
116a112
> instanceMKFRZINSTDeepFrz(Bool)  Bool where type FrzType Bool = Bool
116a113
> instanceMKFRZINSTDeepFrz(Char)  Char where type FrzType Char = Char
116a114
> instanceMKFRZINSTDeepFrz(IntegerInteger)       where type FrzType Integer = Integer
116a115
> instanceMKFRZINSTDeepFrz(Float) Float where type FrzType Float = Float
116a116
> instanceMKFRZINSTDeepFrz(Double)Double where type FrzType Double = Double
118d117
< MKFRZINST(())
119c118
< MKFRZINST(Ordering)
---
> instanceMKFRZINSTDeepFrz(())    () where type FrzType () = ()
119a119
> instanceMKFRZINSTDeepFrz(Ordering)       where type FrzType Ordering = Ordering
173a174
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE DataKinds #-}

{-|

The `DeepFrz` module provides a way to return arbitrarily complex data
structures containing LVars from `Par` computations.

The important thing to know is that to use `runParThenFreeze` to run a
`Par` computation, you must make sure that all types you return from
the `Par` computation have `DeepFrz` instances.  This means that, if
you wish to return a user-defined type, you will need to include a bit
of boilerplate to give it a `DeepFrz` instance.  Here is a complete
example:

> {-# LANGUAGE TypeFamilies #-}
> import Control.LVish.DeepFrz
>
> data MyData = MyData Int deriving Show
>
> instance DeepFrz MyData where
>   type FrzType MyData = MyData
>
> main = print (runParThenFreeze (return (MyData 3)))

-}

-- TODO: a more detailed (recursive?) DeepFrz instance example might
-- be really helpful here for people who want to implement their own
-- LVar types. -- LK

module Control.LVish.DeepFrz
       (
         -- * The functions you'll want to use
         runParThenFreeze,
         runParThenFreezeIO,

         -- * Some supporting types
         DeepFrz(), FrzType,
         NonFrzn, Frzn, Trvrsbl,

       ) where

import Data.Int
import Data.Word
import GHC.Prim (unsafeCoerce#)

-- import Control.LVish (LVarData1(..))
import Control.LVish.DeepFrz.Internal (DeepFrz(..), NonFrzn, Frzn, Trvrsbl)
import Control.LVish.Internal (Determinism(..), Par(WrapPar))
import Control.LVish.SchedIdempotent (runPar, runParIO)
--------------------------------------------------------------------------------

-- | Under normal conditions, calling a `freeze` operation inside a
-- `Par` computation makes the `Par` computation quasi-deterministic.
-- However, if we freeze only after all LVar operations are completed
-- (after the implicit global barrier of `runPar`), then we've avoided
-- all data races, and freezing is therefore safe.  Running a `Par`
-- computation with `runParThenFreeze` accomplishes this, without our
-- having to call `freeze` explicitly.
--
-- In order to use `runParThenFreeze`, the type returned from the
-- `Par` computation must be a member of the `DeepFrz` class.  All the
-- @Data.LVar.*@ libraries should provide instances of `DeepFrz`
-- already.  Further, you can create additional instances for custom,
-- pure datatypes.  The result of a `runParThenFreeze` depends on the
-- type-level function `FrzType`, whose only purpose is to toggle the
-- `s` parameters of all IVars to the `Frzn` state.
--
-- Significantly, the freeze at the end of `runParThenFreeze` has /no/ runtime cost, in
-- spite of the fact that it enables a /deep/ (recursive) freeze of the value returned
-- by the `Par` computation.
runParThenFreeze :: DeepFrz a => Par Det NonFrzn a -> FrzType a
runParThenFreeze (WrapPar p) = frz $ runPar p

-- | This version works for nondeterministic computations as well.
--
-- Of course, nondeterministic computations may also call `freeze`
-- internally, but this function has an advantage to doing your own
-- `freeze` at the end of a `runParIO`: there is an implicit barrier
-- before the final freeze.  Further, `DeepFrz` has no runtime
-- overhead, whereas regular freezing has a cost.
runParThenFreezeIO :: DeepFrz a => Par d NonFrzn a -> IO (FrzType a)
runParThenFreezeIO (WrapPar p) = do
  x <- runParIO p
  return $ frz x

{-
-- This won't work because it conflicts with other instances such as "Either":
instance (LVarData1 f, DeepFrz a) => DeepFrz (f s a) where
  type FrzType (f s a) = f Frzn (FrzType a)
  frz = unsafeCoerce#
-}

#define MKFRZINST(T) instance DeepFrz T where type FrzType T = T

MKFRZINST(Int)
MKFRZINST(Int8)
MKFRZINST(Int16)
MKFRZINST(Int32)
MKFRZINST(Int64)
MKFRZINST(Word)
MKFRZINST(Word8)
MKFRZINST(Word16)
MKFRZINST(Word32)
MKFRZINST(Word64)
MKFRZINST(Bool)
MKFRZINST(Char)
MKFRZINST(Integer)
MKFRZINST(Float)
MKFRZINST(Double)

MKFRZINST(())
MKFRZINST(Ordering)

instance DeepFrz a => DeepFrz [a] where
  type FrzType [a] = [FrzType a]
  frz = unsafeCoerce#

instance DeepFrz a => DeepFrz (Maybe a) where
  type FrzType (Maybe a) = Maybe (FrzType a)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b) => DeepFrz (Either a b) where
  type FrzType (Either a b) = Either (FrzType a) (FrzType b)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b) => DeepFrz (a,b) where
  type FrzType (a,b) = (FrzType a,FrzType b)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c) => DeepFrz (a,b,c) where
  type FrzType (a,b,c) = (FrzType a,FrzType b,FrzType c)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d) => DeepFrz (a,b,c,d) where
  type FrzType (a,b,c,d) = (FrzType a, FrzType b, FrzType c, FrzType d)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e) => DeepFrz (a,b,c,d,e) where
  type FrzType (a,b,c,d,e) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f) => DeepFrz (a,b,c,d,e,f) where
  type FrzType (a,b,c,d,e,f) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                FrzType f)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g) => DeepFrz (a,b,c,d,e,f,g) where
  type FrzType (a,b,c,d,e,f,g) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                  FrzType f, FrzType g)
  frz = unsafeCoerce#


instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g, DeepFrz h) => DeepFrz (a,b,c,d,e,f,g,h) where
  type FrzType (a,b,c,d,e,f,g,h) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                    FrzType f, FrzType g, FrzType h)
  frz = unsafeCoerce#


instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g, DeepFrz h, DeepFrz i) => DeepFrz (a,b,c,d,e,f,g,h,i) where
  type FrzType (a,b,c,d,e,f,g,h,i) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                      FrzType f, FrzType g, FrzType h, FrzType i)
  frz = unsafeCoerce#
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE DataKinds #-}

{-|

The `DeepFrz` module provides a way to return arbitrarily complex data
structures containing LVars from `Par` computations.

The important thing to know is that to use `runParThenFreeze` to run a
`Par` computation, you must make sure that all types you return from
the `Par` computation have `DeepFrz` instances.  This means that, if
you wish to return a user-defined type, you will need to include a bit
of boilerplate to give it a `DeepFrz` instance.  Here is a complete
example:

> {-# LANGUAGE TypeFamilies #-}
> import Control.LVish.DeepFrz
>
> data MyData = MyData Int deriving Show
>
> instance DeepFrz MyData where
>   type FrzType MyData = MyData
>
> main = print (runParThenFreeze (return (MyData 3)))

-}

-- TODO: a more detailed (recursive?) DeepFrz instance example might
-- be really helpful here for people who want to implement their own
-- LVar types. -- LK

module Control.LVish.DeepFrz
       (
         -- * The functions you'll want to use
         runParThenFreeze,
         runParThenFreezeIO,

         -- * Some supporting types
         DeepFrz(), FrzType,
         NonFrzn, Frzn, Trvrsbl,

       ) where

import Data.Int
import Data.Word
import GHC.Prim (unsafeCoerce#)

-- import Control.LVish (LVarData1(..))
import Control.LVish.DeepFrz.Internal (DeepFrz(..), NonFrzn, Frzn, Trvrsbl)
import Control.LVish.Internal (Determinism(..), Par(WrapPar))
import Control.LVish.SchedIdempotent (runPar, runParIO)
--------------------------------------------------------------------------------

-- | Under normal conditions, calling a `freeze` operation inside a
-- `Par` computation makes the `Par` computation quasi-deterministic.
-- However, if we freeze only after all LVar operations are completed
-- (after the implicit global barrier of `runPar`), then we've avoided
-- all data races, and freezing is therefore safe.  Running a `Par`
-- computation with `runParThenFreeze` accomplishes this, without our
-- having to call `freeze` explicitly.
--
-- In order to use `runParThenFreeze`, the type returned from the
-- `Par` computation must be a member of the `DeepFrz` class.  All the
-- @Data.LVar.*@ libraries should provide instances of `DeepFrz`
-- already.  Further, you can create additional instances for custom,
-- pure datatypes.  The result of a `runParThenFreeze` depends on the
-- type-level function `FrzType`, whose only purpose is to toggle the
-- `s` parameters of all IVars to the `Frzn` state.
--
-- Significantly, the freeze at the end of `runParThenFreeze` has /no/ runtime cost, in
-- spite of the fact that it enables a /deep/ (recursive) freeze of the value returned
-- by the `Par` computation.
runParThenFreeze :: DeepFrz a => Par Det NonFrzn a -> FrzType a
runParThenFreeze (WrapPar p) = frz $ runPar p

-- | This version works for nondeterministic computations as well.
--
-- Of course, nondeterministic computations may also call `freeze`
-- internally, but this function has an advantage to doing your own
-- `freeze` at the end of a `runParIO`: there is an implicit barrier
-- before the final freeze.  Further, `DeepFrz` has no runtime
-- overhead, whereas regular freezing has a cost.
runParThenFreezeIO :: DeepFrz a => Par d NonFrzn a -> IO (FrzType a)
runParThenFreezeIO (WrapPar p) = do
  x <- runParIO p
  return $ frz x

{-
-- This won't work because it conflicts with other instances such as "Either":
instance (LVarData1 f, DeepFrz a) => DeepFrz (f s a) where
  type FrzType (f s a) = f Frzn (FrzType a)
  frz = unsafeCoerce#
-}

#define MKFRZINST(T) instance DeepFrz T where type FrzType T = T

instanceMKFRZINSTDeepFrz(Int)   Int where type FrzType Int = Int
instanceMKFRZINSTDeepFrz(Int8)  Int8 where type FrzType Int8 = Int8
instanceMKFRZINSTDeepFrz(Int16) Int16 where type FrzType Int16 = Int16
instanceMKFRZINSTDeepFrz(Int32) Int32 where type FrzType Int32 = Int32
instanceMKFRZINSTDeepFrz(Int64) Int64 where type FrzType Int64 = Int64
instanceMKFRZINSTDeepFrz(Word)  Word where type FrzType Word = Word
instanceMKFRZINSTDeepFrz(Word8) Word8 where type FrzType Word8 = Word8
instanceMKFRZINSTDeepFrz(Word16)Word16 where type FrzType Word16 = Word16
instanceMKFRZINSTDeepFrz(Word32)Word32 where type FrzType Word32 = Word32
instanceMKFRZINSTDeepFrz(Word64)Word64 where type FrzType Word64 = Word64
instanceMKFRZINSTDeepFrz(Bool)  Bool where type FrzType Bool = Bool
instanceMKFRZINSTDeepFrz(Char)  Char where type FrzType Char = Char
instanceMKFRZINSTDeepFrz(IntegerInteger)       where type FrzType Integer = Integer
instanceMKFRZINSTDeepFrz(Float) Float where type FrzType Float = Float
instanceMKFRZINSTDeepFrz(Double)Double where type FrzType Double = Double

instanceMKFRZINSTDeepFrz(())    () where type FrzType () = ()
instanceMKFRZINSTDeepFrz(Ordering)       where type FrzType Ordering = Ordering

instance DeepFrz a => DeepFrz [a] where
  type FrzType [a] = [FrzType a]
  frz = unsafeCoerce#

instance DeepFrz a => DeepFrz (Maybe a) where
  type FrzType (Maybe a) = Maybe (FrzType a)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b) => DeepFrz (Either a b) where
  type FrzType (Either a b) = Either (FrzType a) (FrzType b)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b) => DeepFrz (a,b) where
  type FrzType (a,b) = (FrzType a,FrzType b)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c) => DeepFrz (a,b,c) where
  type FrzType (a,b,c) = (FrzType a,FrzType b,FrzType c)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d) => DeepFrz (a,b,c,d) where
  type FrzType (a,b,c,d) = (FrzType a, FrzType b, FrzType c, FrzType d)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e) => DeepFrz (a,b,c,d,e) where
  type FrzType (a,b,c,d,e) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f) => DeepFrz (a,b,c,d,e,f) where
  type FrzType (a,b,c,d,e,f) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                FrzType f)
  frz = unsafeCoerce#

instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g) => DeepFrz (a,b,c,d,e,f,g) where
  type FrzType (a,b,c,d,e,f,g) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                  FrzType f, FrzType g)
  frz = unsafeCoerce#


instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g, DeepFrz h) => DeepFrz (a,b,c,d,e,f,g,h) where
  type FrzType (a,b,c,d,e,f,g,h) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                    FrzType f, FrzType g, FrzType h)
  frz = unsafeCoerce#


instance (DeepFrz a, DeepFrz b, DeepFrz c, DeepFrz d, DeepFrz e,
          DeepFrz f, DeepFrz g, DeepFrz h, DeepFrz i) => DeepFrz (a,b,c,d,e,f,g,h,i) where
  type FrzType (a,b,c,d,e,f,g,h,i) = (FrzType a, FrzType b, FrzType c, FrzType d, FrzType e,
                                      FrzType f, FrzType g, FrzType h, FrzType i)
  frz = unsafeCoerce#

</pre>