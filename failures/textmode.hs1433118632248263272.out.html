<a href="TextInput.hs1887985652156485092.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TF.hs10736458981609005592.out.html">next</a></br></br><pre>4d3
< 
5d3
< {-# LINE 1 "textmode.chs" #-}{-
6d3
<    * withCString konvertiert von Haskell (d.h. Unicode) nach UTF-8 (je nach Locale)
7d3
<    * puts aus der C-Bibliothek fügt einen Zeilenumbruch am Ende ein.
8d3
< -}
9d3
< 
124a119
> 
</pre></br><h2>original</h2></br><pre>-- GENERATED by C->Haskell Compiler, version 0.16.2 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "textmode.chs" #-}{-
   * withCString konvertiert von Haskell (d.h. Unicode) nach UTF-8 (je nach Locale)
   * puts aus der C-Bibliothek fügt einen Zeilenumbruch am Ende ein.
-}

import HsShellScript
import System.IO
import System.Posix.Process
import System.Posix.Types
import Foreign.C
import Foreign.Ptr

main = mainwrapper $ do


   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   hSetBinaryMode h True
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im Binär-Modus: " ++ c)

   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   hSetBinaryMode h False
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im Text-Modus: " ++ c)

   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im voreingestellten Modus: " ++ c)



   let str = "-äöü-"
   putStrLn ("Haskell-Seite\n-------------");
   putStrLn ("str = \"" ++ str ++ "\"\nLänge = " ++ show (length str))


   putStrLn "\n1. withCString\n--------------"
   putStr ("Per withCString an die C-Seite übergeben = ")
   hFlush stdout
   print_utf8 str

   putStrLn "\n2. pipe_to zu einer IO-Aktion\n-----------------------------"
   pipe_to str lies_stdin

   putStrLn "\n2a. pipe_to zu einer IO-Aktion, im Binärmodus\n---------------------------------------------\n"
   pipe_to str lies_stdin_binary

   putStrLn "\n3. h_pipe_to' zu einer IO-Aktion\n-------------------------------"
   (h, pid) <- h_pipe_to' lies_stdin
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""


   putStrLn "\n4. h_pipe_to' zu /bin/cat\n------------------------\n"
   (h, pid) <- h_pipe_to'
                  (do exec "/bin/cat" [])
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""


   putStrLn "\n5. pipes zu tmp/z\n--------------------\n"
   (Just h, _, _, pid) <- pipes (do exec "./z" [])
                                True False False
   hSetBinaryMode h False
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""



h_pipe_to' :: IO a                       -- ^ Action to run as a separate process, and to pipe to
          -> IO (Handle, ProcessID)     -- ^ Returns handle connected to the standard input of the child process, and the child's process ID
h_pipe_to' io = do
   (Just h, _, _, pid) <- pipes io True False False
   return (h, pid)



lies_stdin = do
   hSetBinaryMode stdin False --XX
   daten <- hGetContents stdin
   putStrLn ("Angekommen: \"" ++ daten ++ "\", Länge = " ++ show (length daten))
   hFlush stdout

lies_stdin_binary = do
   hSetBinaryMode stdin True
   daten <- hGetContents stdin
   putStrLn ("Angekommen: \"" ++ daten ++ "\", Länge = " ++ show (length daten))
   hFlush stdout


puts_hs :: String -> IO ()
puts_hs str = do
   i <- withCString str $ \str -> puts str
   return ()

print_utf8 :: String -> IO ()
print_utf8 str = do
   i <- withCString str $ \str -> print_utf8_c str
   return ()




foreign import ccall safe "textmode.chs.h puts"
  puts :: ((Ptr CChar) -> (IO CInt))

foreign import ccall safe "textmode.chs.h print_utf8_c"
  print_utf8_c :: ((Ptr CChar) -> (IO ()))
</pre></br><h2>printed</h2></br><pre>-- GENERATED by C->Haskell Compiler, version 0.16.2 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!

import HsShellScript
import System.IO
import System.Posix.Process
import System.Posix.Types
import Foreign.C
import Foreign.Ptr

main = mainwrapper $ do


   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   hSetBinaryMode h True
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im Binär-Modus: " ++ c)

   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   hSetBinaryMode h False
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im Text-Modus: " ++ c)

   h <- openFile "/home/v/src/hsskripte/tmp/txt" ReadMode
   c <- hGetContents h
   seq (length c) (return ())
   hClose h
   putStr ("Datei im voreingestellten Modus: " ++ c)



   let str = "-äöü-"
   putStrLn ("Haskell-Seite\n-------------");
   putStrLn ("str = \"" ++ str ++ "\"\nLänge = " ++ show (length str))


   putStrLn "\n1. withCString\n--------------"
   putStr ("Per withCString an die C-Seite übergeben = ")
   hFlush stdout
   print_utf8 str

   putStrLn "\n2. pipe_to zu einer IO-Aktion\n-----------------------------"
   pipe_to str lies_stdin

   putStrLn "\n2a. pipe_to zu einer IO-Aktion, im Binärmodus\n---------------------------------------------\n"
   pipe_to str lies_stdin_binary

   putStrLn "\n3. h_pipe_to' zu einer IO-Aktion\n-------------------------------"
   (h, pid) <- h_pipe_to' lies_stdin
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""


   putStrLn "\n4. h_pipe_to' zu /bin/cat\n------------------------\n"
   (h, pid) <- h_pipe_to'
                  (do exec "/bin/cat" [])
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""


   putStrLn "\n5. pipes zu tmp/z\n--------------------\n"
   (Just h, _, _, pid) <- pipes (do exec "./z" [])
                                True False False
   hSetBinaryMode h False
   hPutStr h str
   hClose h
   getProcessStatus True False pid
   putStrLn ""



h_pipe_to' :: IO a                       -- ^ Action to run as a separate process, and to pipe to
          -> IO (Handle, ProcessID)     -- ^ Returns handle connected to the standard input of the child process, and the child's process ID
h_pipe_to' io = do
   (Just h, _, _, pid) <- pipes io True False False
   return (h, pid)



lies_stdin = do
   hSetBinaryMode stdin False --XX
   daten <- hGetContents stdin
   putStrLn ("Angekommen: \"" ++ daten ++ "\", Länge = " ++ show (length daten))
   hFlush stdout

lies_stdin_binary = do
   hSetBinaryMode stdin True
   daten <- hGetContents stdin
   putStrLn ("Angekommen: \"" ++ daten ++ "\", Länge = " ++ show (length daten))
   hFlush stdout


puts_hs :: String -> IO ()
puts_hs str = do
   i <- withCString str $ \str -> puts str
   return ()

print_utf8 :: String -> IO ()
print_utf8 str = do
   i <- withCString str $ \str -> print_utf8_c str
   return ()




foreign import ccall safe "textmode.chs.h puts"
  puts :: ((Ptr CChar) -> (IO CInt))

foreign import ccall safe "textmode.chs.h print_utf8_c"
  print_utf8_c :: ((Ptr CChar) -> (IO ()))

</pre>