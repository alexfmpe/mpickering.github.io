<a href="CounterForeign.hs8933518161505795335.out.html">prev</a></br><a href="failures.html">home</a></br><a href="cpp.hs174076737834991545.out.html">next</a></br></br><pre>13d12
< -- Defines two variants of @(,)@ with lifted instances for the standard type classes.
14d12
< --
15d12
< -- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The
16d12
< -- 'Monad' instances are not in base (but should argubly be there). All of these instances
17d12
< -- are equivalent to 'Writer' in transformers.
18d12
< --
19d12
< -- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
20d12
< --
21d12
< -- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':
22d12
< -- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
23d12
< -- an extra @Ord b@ constraint for all sub-classes of 'Ord'.
24c13
< --
---
> -- |-- Defines two variants of @(,)@ with lifted instances for the standard type classes.
24a14
> ---- Defines two variants of @(,)@ with lifted instances for the standard type classes.
24a15
> ---- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The
24a16
> -- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The-- 'Monad' instances are not in base (but should argubly be there). All of these instances
24a17
> -- are equivalent to 'Writer' in transformers.-- 'Monad' instances are not in base (but should argubly be there). All of these instances
24a18
> ---- are equivalent to 'Writer' in transformers.
24a19
> ---- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
24a20
> ---- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
24a21
> ---- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':
24a22
> -- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':-- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
24a23
> -- an extra @Ord b@ constraint for all sub-classes of 'Ord'.-- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
24a24
> ---- an extra @Ord b@ constraint for all sub-classes of 'Ord'.
24a25
> --module Data.Functor.Couple (Twain(..), Couple(..)) where
26d26
< 
28d27
< import Data.Functor.Product
29d27
< import Data.Functor.Identity
30d27
< import Data.Foldable
31d27
< import Data.Traversable
32d27
< import Data.Functor.Adjunction (unzipR)
33d27
< import Data.Semigroup
34d27
< import Data.Typeable
35d27
< import Control.Applicative
36d27
< import Control.Comonad
37c28
< import Data.PairMonad ()
---
> import Data.BifunctorData.Functor.Product
37a29
> import Data.Functor.ProductData.Functor.Identity
37a30
> import Data.Functor.IdentityData.Foldable
37a31
> import Data.FoldableData.Traversable
37a32
> import Data.TraversableData.Functor.Adjunction (unzipR)
37a33
> import Data.Functor.AdjunctionData.Semigroup          (unzipR)
37a34
> import Data.SemigroupData.Typeable
37a35
> import Data.TypeableControl.Applicative
37a36
> import Control.ApplicativeControl.Comonad
37a37
> import Control.ComonadData.PairMonad ()
37a38
> import Data.PairMonadControl.Lens (Wrapped)    (..), Rewrapped(..), iso)
39d39
< 
41d40
< -- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
42d40
< --
43c41
< newtype Twain b a = Twain { getTwain :: (b, a) }
---
> -- |-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
43a42
> ---- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
43a43
> --newtype Twain b a = Twain { getTwain :: (b, a) }
43a44
> newtypederiving(Show a =Functor,{Traversable ::, (Foldableb, a) }, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
45d45
< 
47c47
<   type Unwrapped (Twain b a) = (b, a)
---
> instancetype Unwrapped (Twain b a) where= (b, a)
47a48
>   type_Wrapped'= iso(TwaingetTwain a)Twain= (b, a)
49d49
< 
51c51
< 
---
> instance Rewrapped (Twain c a) (Twain c b)
52a53
> instance(+) = liftA2Monoid(+b, Num a) => Num (Twain b a) where
55d55
<   (-) = liftA2 (-)
56d55
<   abs = fmap abs
57c56
<   signum = fmap signum
---
>   (abs-) = liftA2fmap abs-)
57a57
>   abssignum= fmap= fmapsignum
57a58
>   signumfromInteger= fmap= signumpure . fromInteger
59d59
< 
61c61
<   recip        = fmap recip
---
> instancerecip  (Monoid= bfmap, Fractionalrecip    a) => Fractional (Twain b a) where
61a62
>   recipfromRational = fmap recip. fromRational
63d63
< 
65d64
<   pi    = pure pi
66c65
<   sqrt  = fmap sqrt
---
> instancepi    =(Monoidpure pib, Floating a) => Floating (Twain b a) where
66a66
>   pisqrt  = pure pisqrt
66a67
>   sqrtexp   = fmap sqrtexp
70c71
<   cos   = fmap cos
---
>   cosasin  = fmap cosasin
75c76
<   cosh  = fmap cosh
---
>   coshasinh = fmap coshasinh
77c78
<   atanh = fmap atanh
---
>   atanh = fmap atanhacos
79d79
< 
81c81
<   toEnum = pure . toEnum
---
> instancetoEnum (Monoidpure .b,toEnum a) => Enum (Twain b a) where
81a82
>   toEnumfromEnum= pure= fromEnum toEnum. extract
83d83
< 
84a85
> instanceminBoundMonoid= pureb,minBound a) => Bounded (Twain b a) where
87d87
< 
89d88
< -- Eq, Ord and their subclasses
90d88
< --
91d88
< -- If comparison takes both values into account, we must add and (Ord b)
92d88
< -- constraint to all of the following instances. Instead, follow the
93c89
< -- spirit of the Num et al instances to compare just the second argument.
---
> ---- Eq, Ord and their subclasses
93a90
> ---- Eq, Ord and their subclasses
93a91
> ---- If comparison takes both values into account, we must add and (Ord b)
93a92
> -- constraint to all of the following instances. Instead, follow the-- If comparison takes both values into account, we must add and (Ord b)
93a93
> -- constraint to all of the following instances. Instead, follow the-- spirit of the Num et al instances to compare just the second argument.
93a94
> ---- spirit of the Num et al instances to compare just the second argument.
95d95
< 
96a97
> instanceTwain (Eqb,aa => EqTwainTwain(b',ba'a) where=  a == a'
98d98
< 
99a100
> instanceTwain (Ordb,a)a<=>Twain (Twainb',a')b=a) where< a'
101d101
< 
103d102
<   quot = liftA2 quot
104d102
<   rem  = liftA2 rem
105c103
<   quotRem = fmap (fmap unzipR) (liftA2 quotRem)
---
> instancequot = (liftA2Monoidquot, Real a, Enum a, Integral a) => Integral (Twain b a) where
105a104
>   quotrem  = liftA2 quotrem
105a105
>   remquotRem= liftA2= fmaprem(fmap unzipR) (liftA2 quotRem)
105a106
>   quotRemtoInteger= fmap= toIntegerfmap unzipR. extract) (liftA2 quotRem)
107d107
< 
108a109
> instancetoRationalMonoid= toRational, Real a) =>extract (Twain b a) where
110d110
< 
111a112
> instanceproperFractionMonoid b,firstextract) =>. RealFracunzipR . (fmapTwainproperFraction a) where
114d114
< 
116d115
< -- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
117d115
< --
118c116
< newtype Couple b a = Couple { getCouple :: (b, a) }
---
> -- |-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
118a117
> ---- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
118a118
> --newtype Couple b a = Couple { getCouple :: (b, a) }
118a119
> newtypederiving(Show,aFunctor= Couple, Foldable getCouple, Traversable:: (b, a) }Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
120d120
< 
122c122
<   type Unwrapped (Couple b a) = (b, a)
---
> instancetype Unwrapped (Couple b a) where= (b, a)
122a123
>   type_Wrapped'= iso(CouplegetCouple a)Couple= (b, a)
124d124
< 
126c126
< 
---
> instance Rewrapped (Couple c a) (Couple c b)
127a128
> instance(+) = liftA2Monoid(+b, Num a) => Num (Couple b a) where
130d130
<   (-) = liftA2 (-)
131d130
<   abs = fmap abs
132c131
<   signum = fmap signum
---
>   (abs-) = liftA2fmap abs-)
132a132
>   abssignum= fmap= fmapsignum
132a133
>   signumfromInteger= fmap= signumpure . fromInteger
134d134
< 
136c136
<   recip        = fmap recip
---
> instancerecip  (Monoid= bfmap, Fractionalrecip    a) => Fractional (Couple b a) where
136a137
>   recipfromRational = fmap recip. fromRational
138d138
< 
140d139
<   pi    = pure pi
141c140
<   sqrt  = fmap sqrt
---
> instancepi    =(Monoidpure pib, Floating a) => Floating (Couple b a) where
141a141
>   pisqrt  = pure pisqrt
141a142
>   sqrtexp   = fmap sqrtexp
145c146
<   cos   = fmap cos
---
>   cosasin  = fmap cosasin
150c151
<   cosh  = fmap cosh
---
>   coshasinh = fmap coshasinh
152c153
<   atanh = fmap atanh
---
>   atanh = fmap atanhacos
154d154
< 
156c156
<   toEnum = pure . toEnum
---
> instancetoEnum (Monoidpure .b,toEnum a) => Enum (Couple b a) where
156a157
>   toEnumfromEnum= pure= fromEnum toEnum. extract
158d158
< 
159a160
> instanceminBoundMonoid= pureb,minBound a) => Bounded (Couple b a) where
162d162
< 
163a164
> instanceCouple (Eq(b,b,)Eq==a)Couple=> Eq((b'Couple,a')  b a)bwhere,a) == (b',a')
165d165
< 
166a167
> instanceCouple (Ordb,a)b, OrdCouple) =>(b'Ord,a')(Couple= (b,a)b<a)b'where,a')
168d168
< 
170d169
<   quot = liftA2 quot
171d169
<   rem  = liftA2 rem
172c170
<   quotRem = fmap (fmap unzipR) (liftA2 quotRem)
---
> instancequot = (liftA2Monoidquot, Ord b, Real a, Enum a, Integral a) => Integral (Couple b a) where
172a171
>   quotrem  = liftA2 quotrem
172a172
>   remquotRem= liftA2= fmaprem(fmap unzipR) (liftA2 quotRem)
172a173
>   quotRemtoInteger= fmap= toIntegerfmap unzipR. extract) (liftA2 quotRem)
174d174
< 
175a176
> instancetoRationalMonoid= toRational, Ord b,.Realextract) => Real (Couple b a) where
177d177
< 
178a179
> instanceproperFractionMonoid b,first b,extract. unzipR) => RealFrac. fmap properFractionCouple b a) where
</pre></br><h2>original</h2></br><pre>

{-# LANGUAGE CPP,
             GeneralizedNewtypeDeriving,
             DeriveDataTypeable,
             DeriveFunctor,
             DeriveTraversable,
             DeriveFoldable,
             MultiParamTypeClasses,
             TypeFamilies
             #-}
-- |
-- Defines two variants of @(,)@ with lifted instances for the standard type classes.
--
-- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The
-- 'Monad' instances are not in base (but should argubly be there). All of these instances
-- are equivalent to 'Writer' in transformers.
--
-- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
--
-- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':
-- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
-- an extra @Ord b@ constraint for all sub-classes of 'Ord'.
--
module Data.Functor.Couple (Twain(..), Couple(..)) where

import Data.Bifunctor
import Data.Functor.Product
import Data.Functor.Identity
import Data.Foldable
import Data.Traversable
import Data.Functor.Adjunction (unzipR)
import Data.Semigroup
import Data.Typeable
import Control.Applicative
import Control.Comonad
import Data.PairMonad ()
import Control.Lens (Wrapped(..), Rewrapped(..), iso)

-- |
-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
--
newtype Twain b a = Twain { getTwain :: (b, a) }
  deriving (Show, Functor, Traversable, Foldable, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)

instance Wrapped (Twain b a) where
  type Unwrapped (Twain b a) = (b, a)
  _Wrapped' = iso getTwain Twain

instance Rewrapped (Twain c a) (Twain c b)

instance (Monoid b, Num a) => Num (Twain b a) where
  (+) = liftA2 (+)
  (*) = liftA2 (*)
  (-) = liftA2 (-)
  abs = fmap abs
  signum = fmap signum
  fromInteger = pure . fromInteger

instance (Monoid b, Fractional a) => Fractional (Twain b a) where
  recip        = fmap recip
  fromRational = pure . fromRational

instance (Monoid b, Floating a) => Floating (Twain b a) where
  pi    = pure pi
  sqrt  = fmap sqrt
  exp   = fmap exp
  log   = fmap log
  sin   = fmap sin
  cos   = fmap cos
  asin  = fmap asin
  atan  = fmap atan
  acos  = fmap acos
  sinh  = fmap sinh
  cosh  = fmap cosh
  asinh = fmap asinh
  atanh = fmap atanh
  acosh = fmap acos

instance (Monoid b, Enum a) => Enum (Twain b a) where
  toEnum = pure . toEnum
  fromEnum = fromEnum . extract

instance (Monoid b, Bounded a) => Bounded (Twain b a) where
  minBound = pure minBound
  maxBound = pure maxBound

--
-- Eq, Ord and their subclasses
--
-- If comparison takes both values into account, we must add and (Ord b)
-- constraint to all of the following instances. Instead, follow the
-- spirit of the Num et al instances to compare just the second argument.
--

instance Eq a => Eq (Twain b a) where
  Twain (b,a) == Twain (b',a')  =  a == a'

instance Ord a => Ord (Twain b a) where
  Twain (b,a) < Twain (b',a') = a < a'

instance (Monoid b, Real a, Enum a, Integral a) => Integral (Twain b a) where
  quot = liftA2 quot
  rem  = liftA2 rem
  quotRem = fmap (fmap unzipR) (liftA2 quotRem)
  toInteger = toInteger . extract

instance (Monoid b, Real a) => Real (Twain b a) where
  toRational = toRational . extract

instance (Monoid b, RealFrac a) => RealFrac (Twain b a) where
  properFraction = first extract . unzipR . fmap properFraction


-- |
-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
--
newtype Couple b a = Couple { getCouple :: (b, a) }
  deriving (Show, Functor, Foldable, Traversable, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)

instance Wrapped (Couple b a) where
  type Unwrapped (Couple b a) = (b, a)
  _Wrapped' = iso getCouple Couple

instance Rewrapped (Couple c a) (Couple c b)

instance (Monoid b, Num a) => Num (Couple b a) where
  (+) = liftA2 (+)
  (*) = liftA2 (*)
  (-) = liftA2 (-)
  abs = fmap abs
  signum = fmap signum
  fromInteger = pure . fromInteger

instance (Monoid b, Fractional a) => Fractional (Couple b a) where
  recip        = fmap recip
  fromRational = pure . fromRational

instance (Monoid b, Floating a) => Floating (Couple b a) where
  pi    = pure pi
  sqrt  = fmap sqrt
  exp   = fmap exp
  log   = fmap log
  sin   = fmap sin
  cos   = fmap cos
  asin  = fmap asin
  atan  = fmap atan
  acos  = fmap acos
  sinh  = fmap sinh
  cosh  = fmap cosh
  asinh = fmap asinh
  atanh = fmap atanh
  acosh = fmap acos

instance (Monoid b, Enum a) => Enum (Couple b a) where
  toEnum = pure . toEnum
  fromEnum = fromEnum . extract

instance (Monoid b, Bounded a) => Bounded (Couple b a) where
  minBound = pure minBound
  maxBound = pure maxBound

instance (Eq b, Eq a) => Eq (Couple b a) where
  Couple ((b,a)) == Couple (b',a')  =  (b,a) == (b',a')

instance (Ord b, Ord a) => Ord (Couple b a) where
  Couple (b,a) < Couple (b',a') = (b,a) < (b',a')

instance (Monoid b, Ord b, Real a, Enum a, Integral a) => Integral (Couple b a) where
  quot = liftA2 quot
  rem  = liftA2 rem
  quotRem = fmap (fmap unzipR) (liftA2 quotRem)
  toInteger = toInteger . extract

instance (Monoid b, Ord b, Real a) => Real (Couple b a) where
  toRational = toRational . extract

instance (Monoid b, Ord b, RealFrac a) => RealFrac (Couple b a) where
  properFraction = first extract . unzipR . fmap properFraction

</pre></br><h2>printed</h2></br><pre>

{-# LANGUAGE CPP,
             GeneralizedNewtypeDeriving,
             DeriveDataTypeable,
             DeriveFunctor,
             DeriveTraversable,
             DeriveFoldable,
             MultiParamTypeClasses,
             TypeFamilies
             #-}
-- |
-- |-- Defines two variants of @(,)@ with lifted instances for the standard type classes.
---- Defines two variants of @(,)@ with lifted instances for the standard type classes.
---- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The
-- The 'Functor', 'Applicative' and 'Comonad' instances are the standard instances. The-- 'Monad' instances are not in base (but should argubly be there). All of these instances
-- are equivalent to 'Writer' in transformers.-- 'Monad' instances are not in base (but should argubly be there). All of these instances
---- are equivalent to 'Writer' in transformers.
---- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
---- 'Applicative' is used to lift 'Monoid' and the standard numeric classes.
---- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':
-- The only difference between 'Twain' and 'Couple' is the handling of 'Eq' and 'Ord':-- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
-- an extra @Ord b@ constraint for all sub-classes of 'Ord'.-- 'Twain' compares only the second value, while 'Couple' compares both. Thus 'Couple' needs
---- an extra @Ord b@ constraint for all sub-classes of 'Ord'.
--module Data.Functor.Couple (Twain(..), Couple(..)) where
module Data.Functor.Couple (Twain(..), Couple(..)) where
import Data.Bifunctor
import Data.BifunctorData.Functor.Product
import Data.Functor.ProductData.Functor.Identity
import Data.Functor.IdentityData.Foldable
import Data.FoldableData.Traversable
import Data.TraversableData.Functor.Adjunction (unzipR)
import Data.Functor.AdjunctionData.Semigroup          (unzipR)
import Data.SemigroupData.Typeable
import Data.TypeableControl.Applicative
import Control.ApplicativeControl.Comonad
import Control.ComonadData.PairMonad ()
import Data.PairMonadControl.Lens (Wrapped)    (..), Rewrapped(..), iso)
import Control.Lens (Wrapped(..), Rewrapped(..), iso)
-- |
-- |-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
---- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
--newtype Twain b a = Twain { getTwain :: (b, a) }
newtypederiving(Show a =Functor,{Traversable ::, (Foldableb, a) }, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
  deriving (Show, Functor, Traversable, Foldable, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
instance Wrapped (Twain b a) where
instancetype Unwrapped (Twain b a) where= (b, a)
  type_Wrapped'= iso(TwaingetTwain a)Twain= (b, a)
  _Wrapped' = iso getTwain Twain
instance Rewrapped (Twain c a) (Twain c b)
instance Rewrapped (Twain c a) (Twain c b)
instance (Monoid b, Num a) => Num (Twain b a) where
instance(+) = liftA2Monoid(+b, Num a) => Num (Twain b a) where
  (+) = liftA2 (+)
  (*) = liftA2 (*)
  (abs-) = liftA2fmap abs-)
  abssignum= fmap= fmapsignum
  signumfromInteger= fmap= signumpure . fromInteger
  fromInteger = pure . fromInteger
instance (Monoid b, Fractional a) => Fractional (Twain b a) where
instancerecip  (Monoid= bfmap, Fractionalrecip    a) => Fractional (Twain b a) where
  recipfromRational = fmap recip. fromRational
  fromRational = pure . fromRational
instance (Monoid b, Floating a) => Floating (Twain b a) where
instancepi    =(Monoidpure pib, Floating a) => Floating (Twain b a) where
  pisqrt  = pure pisqrt
  sqrtexp   = fmap sqrtexp
  exp   = fmap exp
  log   = fmap log
  sin   = fmap sin
  cosasin  = fmap cosasin
  asin  = fmap asin
  atan  = fmap atan
  acos  = fmap acos
  sinh  = fmap sinh
  coshasinh = fmap coshasinh
  asinh = fmap asinh
  atanh = fmap atanhacos
  acosh = fmap acos
instance (Monoid b, Enum a) => Enum (Twain b a) where
instancetoEnum (Monoidpure .b,toEnum a) => Enum (Twain b a) where
  toEnumfromEnum= pure= fromEnum toEnum. extract
  fromEnum = fromEnum . extract
instance (Monoid b, Bounded a) => Bounded (Twain b a) where
instanceminBoundMonoid= pureb,minBound a) => Bounded (Twain b a) where
  minBound = pure minBound
  maxBound = pure maxBound
--
---- Eq, Ord and their subclasses
---- Eq, Ord and their subclasses
---- If comparison takes both values into account, we must add and (Ord b)
-- constraint to all of the following instances. Instead, follow the-- If comparison takes both values into account, we must add and (Ord b)
-- constraint to all of the following instances. Instead, follow the-- spirit of the Num et al instances to compare just the second argument.
---- spirit of the Num et al instances to compare just the second argument.
--
instance Eq a => Eq (Twain b a) where
instanceTwain (Eqb,aa => EqTwainTwain(b',ba'a) where=  a == a'
  Twain (b,a) == Twain (b',a')  =  a == a'
instance Ord a => Ord (Twain b a) where
instanceTwain (Ordb,a)a<=>Twain (Twainb',a')b=a) where< a'
  Twain (b,a) < Twain (b',a') = a < a'
instance (Monoid b, Real a, Enum a, Integral a) => Integral (Twain b a) where
instancequot = (liftA2Monoidquot, Real a, Enum a, Integral a) => Integral (Twain b a) where
  quotrem  = liftA2 quotrem
  remquotRem= liftA2= fmaprem(fmap unzipR) (liftA2 quotRem)
  quotRemtoInteger= fmap= toIntegerfmap unzipR. extract) (liftA2 quotRem)
  toInteger = toInteger . extract
instance (Monoid b, Real a) => Real (Twain b a) where
instancetoRationalMonoid= toRational, Real a) =>extract (Twain b a) where
  toRational = toRational . extract
instance (Monoid b, RealFrac a) => RealFrac (Twain b a) where
instanceproperFractionMonoid b,firstextract) =>. RealFracunzipR . (fmapTwainproperFraction a) where
  properFraction = first extract . unzipR . fmap properFraction

-- |
-- |-- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
---- A variant of pair/writer with lifted instances for the numeric classes, using 'Applicative'.
--newtype Couple b a = Couple { getCouple :: (b, a) }
newtypederiving(Show,aFunctor= Couple, Foldable getCouple, Traversable:: (b, a) }Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
  deriving (Show, Functor, Foldable, Traversable, Typeable, Applicative, Monad, Comonad, Semigroup, Monoid)
instance Wrapped (Couple b a) where
instancetype Unwrapped (Couple b a) where= (b, a)
  type_Wrapped'= iso(CouplegetCouple a)Couple= (b, a)
  _Wrapped' = iso getCouple Couple
instance Rewrapped (Couple c a) (Couple c b)
instance Rewrapped (Couple c a) (Couple c b)
instance (Monoid b, Num a) => Num (Couple b a) where
instance(+) = liftA2Monoid(+b, Num a) => Num (Couple b a) where
  (+) = liftA2 (+)
  (*) = liftA2 (*)
  (abs-) = liftA2fmap abs-)
  abssignum= fmap= fmapsignum
  signumfromInteger= fmap= signumpure . fromInteger
  fromInteger = pure . fromInteger
instance (Monoid b, Fractional a) => Fractional (Couple b a) where
instancerecip  (Monoid= bfmap, Fractionalrecip    a) => Fractional (Couple b a) where
  recipfromRational = fmap recip. fromRational
  fromRational = pure . fromRational
instance (Monoid b, Floating a) => Floating (Couple b a) where
instancepi    =(Monoidpure pib, Floating a) => Floating (Couple b a) where
  pisqrt  = pure pisqrt
  sqrtexp   = fmap sqrtexp
  exp   = fmap exp
  log   = fmap log
  sin   = fmap sin
  cosasin  = fmap cosasin
  asin  = fmap asin
  atan  = fmap atan
  acos  = fmap acos
  sinh  = fmap sinh
  coshasinh = fmap coshasinh
  asinh = fmap asinh
  atanh = fmap atanhacos
  acosh = fmap acos
instance (Monoid b, Enum a) => Enum (Couple b a) where
instancetoEnum (Monoidpure .b,toEnum a) => Enum (Couple b a) where
  toEnumfromEnum= pure= fromEnum toEnum. extract
  fromEnum = fromEnum . extract
instance (Monoid b, Bounded a) => Bounded (Couple b a) where
instanceminBoundMonoid= pureb,minBound a) => Bounded (Couple b a) where
  minBound = pure minBound
  maxBound = pure maxBound
instance (Eq b, Eq a) => Eq (Couple b a) where
instanceCouple (Eq(b,b,)Eq==a)Couple=> Eq((b'Couple,a')  b a)bwhere,a) == (b',a')
  Couple ((b,a)) == Couple (b',a')  =  (b,a) == (b',a')
instance (Ord b, Ord a) => Ord (Couple b a) where
instanceCouple (Ordb,a)b, OrdCouple) =>(b'Ord,a')(Couple= (b,a)b<a)b'where,a')
  Couple (b,a) < Couple (b',a') = (b,a) < (b',a')
instance (Monoid b, Ord b, Real a, Enum a, Integral a) => Integral (Couple b a) where
instancequot = (liftA2Monoidquot, Ord b, Real a, Enum a, Integral a) => Integral (Couple b a) where
  quotrem  = liftA2 quotrem
  remquotRem= liftA2= fmaprem(fmap unzipR) (liftA2 quotRem)
  quotRemtoInteger= fmap= toIntegerfmap unzipR. extract) (liftA2 quotRem)
  toInteger = toInteger . extract
instance (Monoid b, Ord b, Real a) => Real (Couple b a) where
instancetoRationalMonoid= toRational, Ord b,.Realextract) => Real (Couple b a) where
  toRational = toRational . extract
instance (Monoid b, Ord b, RealFrac a) => RealFrac (Couple b a) where
instanceproperFractionMonoid b,first b,extract. unzipR) => RealFrac. fmap properFractionCouple b a) where
  properFraction = first extract . unzipR . fmap properFraction

</pre>