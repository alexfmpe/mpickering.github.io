<a href="Ord.hs1148079871137522503.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Ord.hs585640194937186357.out.html">next</a></br></br><pre>99d98
< type family x :<: y
100c99
< type instance x :<: y = IsLT (Compare x y)
---
> type family   :<:     y
100a100
> type instance   :<:     y = IsLT (Compare x y)
106d105
< type family x :<=: y
107c106
< type instance x :<=: y = Not (x :>: y)
---
> type family   :<=:      y
107a107
> type instance   :<=:      y = Not (x :>: y)
113d112
< type family x :==: y
114c113
< type instance x :==: y = IsEQ (Compare x y)
---
> type family   :==:      y
114a114
> type instance   :==:      y = IsEQ (Compare x y)
120d119
< type family x :/=: y
121c120
< type instance x :/=: y = Not (x :==: y)
---
> type family   :/=:      y
121a121
> type instance   :/=:      y = Not (x :==: y)
127d126
< type family x :>=: y
128c127
< type instance x :>=: y = Not (x :<: y)
---
> type family   :>=:      y
128a128
> type instance   :>=:      y = Not (x :<: y)
134d133
< type family x :>: y
135c134
< type instance x :>: y = IsGT (Compare x y)
---
> type family   :>:     y
135a135
> type instance   :>:     y = IsGT (Compare x y)
154a155
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Types.Data.Decimal.Digits
-- Copyright   :  (c) 2008 Peter Gavin
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  pgavin@gmail.com
-- Stability   :  experimental
-- Portability :  non-portable (type families, requires ghc >= 6.9)
--
-- Type-level numerical operations using type families.
--
----------------------------------------------------------------------------

module Types.Data.Ord
    ( Compare
    , compareT
    , LT
    , EQ
    , GT
    , IsLT
    , isLTT
    , IsEQ
    , isEQT
    , IsGT
    , isGTT
    , (:<:)
    , ltT
    , LTT
    , (:<=:)
    , leT
    , LET
    , (:==:)
    , eqT
    , EQT
    , (:/=:)
    , neT
    , NET
    , (:>=:)
    , geT
    , GET
    , (:>:)
    , gtT
    , GTT
    , Min
    , minT
    , Max
    , maxT
    ) where

import qualified Prelude

import Types.Data.Bool

type family Compare x y
data LT
data EQ
data GT
compareT :: x -> y -> Compare x y
compareT _ _ = Prelude.undefined

type family IsLT c
type instance IsLT LT = True
type instance IsLT EQ = False
type instance IsLT GT = False
isLTT :: c -> IsLT c
isLTT _ = Prelude.undefined

type family IsEQ c
type instance IsEQ LT = False
type instance IsEQ EQ = True
type instance IsEQ GT = False
isEQT :: c -> IsEQ c
isEQT _ = Prelude.undefined

type family IsGT c
type instance IsGT LT = False
type instance IsGT EQ = False
type instance IsGT GT = True
isGTT :: c -> IsGT c
isGTT _ = Prelude.undefined

type instance Compare LT LT = EQ
type instance Compare LT EQ = LT
type instance Compare LT GT = LT
type instance Compare EQ LT = GT
type instance Compare EQ EQ = EQ
type instance Compare EQ GT = LT
type instance Compare GT LT = GT
type instance Compare GT EQ = GT
type instance Compare GT GT = EQ

type family x :<: y
type instance x :<: y = IsLT (Compare x y)
ltT :: x -> y -> x :<: y
ltT _ _ = Prelude.undefined
class LTT x y
instance ((x :<: y) ~ True) => LTT x y

type family x :<=: y
type instance x :<=: y = Not (x :>: y)
leT :: x -> y -> x :<=: y
leT _ _ = Prelude.undefined
class LET x y
instance ((x :<=: y) ~ True) => LET x y

type family x :==: y
type instance x :==: y = IsEQ (Compare x y)
eqT :: x -> y -> x :==: y
eqT _ _ = Prelude.undefined
class EQT x y
instance ((x :==: y) ~ True) => EQT x y

type family x :/=: y
type instance x :/=: y = Not (x :==: y)
neT :: x -> y -> x :/=: y
neT _ _ = Prelude.undefined
class NET x y
instance ((x :/=: y) ~ True) => NET x y

type family x :>=: y
type instance x :>=: y = Not (x :<: y)
geT :: x -> y -> x :>=: y
geT _ _ = Prelude.undefined
class GET x y
instance ((x :>=: y) ~ True) => GET x y

type family x :>: y
type instance x :>: y = IsGT (Compare x y)
gtT :: x -> y -> x :>: y
gtT _ _ = Prelude.undefined
class GTT x y
instance ((x :>: y) ~ True) => GTT x y

type family Min x y
type instance Min x y = If (x :<=: y) x y
minT :: x -> y -> Min x y
minT _ _ = Prelude.undefined

type family Max x y
type instance Max x y = If (x :>=: y) x y
maxT :: x -> y -> Max x y
maxT _ _ = Prelude.undefined

type instance Compare False False = EQ
type instance Compare False True  = LT
type instance Compare True  False = GT
type instance Compare True  True  = EQ
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Types.Data.Decimal.Digits
-- Copyright   :  (c) 2008 Peter Gavin
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  pgavin@gmail.com
-- Stability   :  experimental
-- Portability :  non-portable (type families, requires ghc >= 6.9)
--
-- Type-level numerical operations using type families.
--
----------------------------------------------------------------------------

module Types.Data.Ord
    ( Compare
    , compareT
    , LT
    , EQ
    , GT
    , IsLT
    , isLTT
    , IsEQ
    , isEQT
    , IsGT
    , isGTT
    , (:<:)
    , ltT
    , LTT
    , (:<=:)
    , leT
    , LET
    , (:==:)
    , eqT
    , EQT
    , (:/=:)
    , neT
    , NET
    , (:>=:)
    , geT
    , GET
    , (:>:)
    , gtT
    , GTT
    , Min
    , minT
    , Max
    , maxT
    ) where

import qualified Prelude

import Types.Data.Bool

type family Compare x y
data LT
data EQ
data GT
compareT :: x -> y -> Compare x y
compareT _ _ = Prelude.undefined

type family IsLT c
type instance IsLT LT = True
type instance IsLT EQ = False
type instance IsLT GT = False
isLTT :: c -> IsLT c
isLTT _ = Prelude.undefined

type family IsEQ c
type instance IsEQ LT = False
type instance IsEQ EQ = True
type instance IsEQ GT = False
isEQT :: c -> IsEQ c
isEQT _ = Prelude.undefined

type family IsGT c
type instance IsGT LT = False
type instance IsGT EQ = False
type instance IsGT GT = True
isGTT :: c -> IsGT c
isGTT _ = Prelude.undefined

type instance Compare LT LT = EQ
type instance Compare LT EQ = LT
type instance Compare LT GT = LT
type instance Compare EQ LT = GT
type instance Compare EQ EQ = EQ
type instance Compare EQ GT = LT
type instance Compare GT LT = GT
type instance Compare GT EQ = GT
type instance Compare GT GT = EQ

type family   :<:     y
type instance   :<:     y = IsLT (Compare x y)
ltT :: x -> y -> x :<: y
ltT _ _ = Prelude.undefined
class LTT x y
instance ((x :<: y) ~ True) => LTT x y

type family   :<=:      y
type instance   :<=:      y = Not (x :>: y)
leT :: x -> y -> x :<=: y
leT _ _ = Prelude.undefined
class LET x y
instance ((x :<=: y) ~ True) => LET x y

type family   :==:      y
type instance   :==:      y = IsEQ (Compare x y)
eqT :: x -> y -> x :==: y
eqT _ _ = Prelude.undefined
class EQT x y
instance ((x :==: y) ~ True) => EQT x y

type family   :/=:      y
type instance   :/=:      y = Not (x :==: y)
neT :: x -> y -> x :/=: y
neT _ _ = Prelude.undefined
class NET x y
instance ((x :/=: y) ~ True) => NET x y

type family   :>=:      y
type instance   :>=:      y = Not (x :<: y)
geT :: x -> y -> x :>=: y
geT _ _ = Prelude.undefined
class GET x y
instance ((x :>=: y) ~ True) => GET x y

type family   :>:     y
type instance   :>:     y = IsGT (Compare x y)
gtT :: x -> y -> x :>: y
gtT _ _ = Prelude.undefined
class GTT x y
instance ((x :>: y) ~ True) => GTT x y

type family Min x y
type instance Min x y = If (x :<=: y) x y
minT :: x -> y -> Min x y
minT _ _ = Prelude.undefined

type family Max x y
type instance Max x y = If (x :>=: y) x y
maxT :: x -> y -> Max x y
maxT _ _ = Prelude.undefined

type instance Compare False False = EQ
type instance Compare False True  = LT
type instance Compare True  False = GT
type instance Compare True  True  = EQ

</pre>