<a href="Utils.hs126623352623929712.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Utils.hs16566775971654889424.out.html">next</a></br></br><pre>1d0
< -- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
2d0
< -- Edit the ORIGNAL .chs file instead!
4d1
< 
5d1
< {-# LINE 1 ".\\HGamer3D\\Bindings\\Bullet\\Utils.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}
32d27
< 
33c28
< module HGamer3D.Bindings.Bullet.Utils where
---
> -- Edit the ORIGNAL .chs file instead!module HGamer3D.Bindings.Bullet.Utils where
136a132
> 
</pre></br><h2>original</h2></br><pre>-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 ".\\HGamer3D\\Bindings\\Bullet\\Utils.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE TypeSynonymInstances #-}

-- This source file is part of HGamer3D
-- (A project to enable 3D game development in Haskell)
-- For the latest info, see http://www.althainz.de/HGamer3D.html
--

-- (c) 2011, 2012 Peter Althainz
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--


-- Utils.hs

-- Marshalling Utilities

module HGamer3D.Bindings.Bullet.Utils where

import Foreign
import Foreign.Ptr
import Foreign.C

import HGamer3D.Data.HG3DClass
import HGamer3D.Data.Vector
import HGamer3D.Data.Colour
import HGamer3D.Data.Angle



import Control.Monad (liftM)

-- Strings with explicit length
--
withCStringLenIntConv :: Num n => String -> ((CString, n) -> IO a) -> IO a
withCStringLenIntConv s f    = withCStringLen s $ \(p, n) -> f (p, fromIntegral n)

peekCStringLenIntConv :: Integral n => (CString, n) -> IO String
peekCStringLenIntConv (s, n) = peekCStringLen (s, fromIntegral n)

-- Marshalling of numerals
--

withIntConv   :: (Storable b, Integral a, Integral b)
              => a -> (Ptr b -> IO c) -> IO c
withIntConv    = with . fromIntegral

withFloatConv :: (Storable b, RealFloat a, RealFloat b)
              => a -> (Ptr b -> IO c) -> IO c
withFloatConv  = with . realToFrac

peekIntConv   :: (Storable a, Integral a, Integral b)
              => Ptr a -> IO b
peekIntConv    = liftM fromIntegral . peek

peekFloatConv :: (Storable a, RealFloat a, RealFloat b)
              => Ptr a -> IO b
peekFloatConv  = liftM realToFrac . peek


-- String Conversion functions
--

withCUString b f = withCWString b (f . castPtr)
peekCUString = peekCWString . castPtr
alloc64k = allocaBytes (1024 * 64)

-- c2hs replacements of utility functions, to get rid of annoying c2hs
-- deprecated messages

-- Passing Enums

cIntFromEnum :: Enum a => a -> CInt
cIntFromEnum = cIntConv . fromEnum

cIntToEnum :: Enum a => CInt -> a
cIntToEnum = toEnum . cIntConv


-- Passing Booleans by reference
--

withBoolUtil :: (Integral a, Storable a) => Bool -> (Ptr a -> IO b) -> IO b
withBoolUtil  = with . fromBool

peekBoolUtil :: (Integral a, Storable a) => Ptr a -> IO Bool
peekBoolUtil  = liftM toBool . peek


-- Passing enums by reference
--

withEnumUtil :: (Enum a, Integral b, Storable b) => a -> (Ptr b -> IO c) -> IO c
withEnumUtil  = with . cFromEnum

peekEnumUtil :: (Enum a, Integral b, Storable b) => Ptr b -> IO a
peekEnumUtil  = liftM cToEnum . peek

-- Conversion routines
-- -------------------

-- |Integral conversion
--
cIntConv :: (Integral a, Integral b) => a -> b
cIntConv  = fromIntegral

-- |Floating conversion
--
cFloatConv :: (RealFloat a, RealFloat b) => a -> b
cFloatConv  = realToFrac

-- |Convert a C enumeration to Haskell.
--
cToEnum :: (Integral i, Enum e) => i -> e
cToEnum  = toEnum . fromIntegral

-- |Convert a Haskell enumeration to C.
--
cFromEnum :: (Enum e, Integral i) => e -> i
cFromEnum  = fromIntegral . fromEnum

</pre></br><h2>printed</h2></br><pre>
{-# LANGUAGE TypeSynonymInstances #-}

-- This source file is part of HGamer3D
-- (A project to enable 3D game development in Haskell)
-- For the latest info, see http://www.althainz.de/HGamer3D.html
--

-- (c) 2011, 2012 Peter Althainz
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--


-- Utils.hs

-- Marshalling Utilities
-- Edit the ORIGNAL .chs file instead!module HGamer3D.Bindings.Bullet.Utils where

import Foreign
import Foreign.Ptr
import Foreign.C

import HGamer3D.Data.HG3DClass
import HGamer3D.Data.Vector
import HGamer3D.Data.Colour
import HGamer3D.Data.Angle



import Control.Monad (liftM)

-- Strings with explicit length
--
withCStringLenIntConv :: Num n => String -> ((CString, n) -> IO a) -> IO a
withCStringLenIntConv s f    = withCStringLen s $ \(p, n) -> f (p, fromIntegral n)

peekCStringLenIntConv :: Integral n => (CString, n) -> IO String
peekCStringLenIntConv (s, n) = peekCStringLen (s, fromIntegral n)

-- Marshalling of numerals
--

withIntConv   :: (Storable b, Integral a, Integral b)
              => a -> (Ptr b -> IO c) -> IO c
withIntConv    = with . fromIntegral

withFloatConv :: (Storable b, RealFloat a, RealFloat b)
              => a -> (Ptr b -> IO c) -> IO c
withFloatConv  = with . realToFrac

peekIntConv   :: (Storable a, Integral a, Integral b)
              => Ptr a -> IO b
peekIntConv    = liftM fromIntegral . peek

peekFloatConv :: (Storable a, RealFloat a, RealFloat b)
              => Ptr a -> IO b
peekFloatConv  = liftM realToFrac . peek


-- String Conversion functions
--

withCUString b f = withCWString b (f . castPtr)
peekCUString = peekCWString . castPtr
alloc64k = allocaBytes (1024 * 64)

-- c2hs replacements of utility functions, to get rid of annoying c2hs
-- deprecated messages

-- Passing Enums

cIntFromEnum :: Enum a => a -> CInt
cIntFromEnum = cIntConv . fromEnum

cIntToEnum :: Enum a => CInt -> a
cIntToEnum = toEnum . cIntConv


-- Passing Booleans by reference
--

withBoolUtil :: (Integral a, Storable a) => Bool -> (Ptr a -> IO b) -> IO b
withBoolUtil  = with . fromBool

peekBoolUtil :: (Integral a, Storable a) => Ptr a -> IO Bool
peekBoolUtil  = liftM toBool . peek


-- Passing enums by reference
--

withEnumUtil :: (Enum a, Integral b, Storable b) => a -> (Ptr b -> IO c) -> IO c
withEnumUtil  = with . cFromEnum

peekEnumUtil :: (Enum a, Integral b, Storable b) => Ptr b -> IO a
peekEnumUtil  = liftM cToEnum . peek

-- Conversion routines
-- -------------------

-- |Integral conversion
--
cIntConv :: (Integral a, Integral b) => a -> b
cIntConv  = fromIntegral

-- |Floating conversion
--
cFloatConv :: (RealFloat a, RealFloat b) => a -> b
cFloatConv  = realToFrac

-- |Convert a C enumeration to Haskell.
--
cToEnum :: (Integral i, Enum e) => i -> e
cToEnum  = toEnum . fromIntegral

-- |Convert a Haskell enumeration to C.
--
cFromEnum :: (Enum e, Integral i) => e -> i
cFromEnum  = fromIntegral . fromEnum


</pre>