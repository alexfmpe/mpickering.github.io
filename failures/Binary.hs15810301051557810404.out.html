<a href="bench.hs571540977194847408.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Binary.hs175471174847424385.out.html">next</a></br></br><pre>102c102
< conduitPutGeneric(conduitPut, (sourcePut x $$ CL.mapM_ yield))
---
> conduitPutconduitPutGeneric= conduit(conduitPutwhere conduit, (sourcePut= do {mxx $$<-CL.mapM_; caseyield))of; Nothing -> return (); Just x -> do {  (sourcePut x $$ CL.mapM_ yield) ; conduit}}
105d104
< conduitMsg :: MonadThrow m => Conduit Put m ByteString
106c105
< conduitPutGeneric(conduitMsg, (yield (LBS.toStrict $ runPut x)))
---
> conduitMsg           :: MonadThrow m => Conduit Put m ByteString
106a106
> conduitMsgconduitPutGeneric= conduit(conduitMsgwhere conduit, (yield= do(LBS.toStrict{mx <- await$;runPut mxx)of)); Nothing -> return (); Just x -> do {  (yield (LBS.toStrict $ runPut x)) ; conduit}}
112d111
< conduitPutLBS :: MonadThrow m => Conduit Put m LBS.ByteString
113c112
< conduitPutGeneric(conduitPutLBS, yield (runPut x))
---
> conduitPutLBS              :: MonadThrow m => Conduit Put m LBS.ByteString
113a113
> conduitPutLBSconduitPutGeneric= conduit(conduitPutLBSwhere conduit, yield=(dorunPut{mx <-x))await; case mx of; Nothing -> return (); Just x -> do {  yield (runPut x) ; conduit}}
117d116
< conduitPutList :: MonadThrow m => Conduit Put m [ByteString]
118c117
< conduitPutGeneric(conduitPutList, yield (LBS.toChunks (runPut x)))
---
> conduitPutList               :: MonadThrow m => Conduit Put m [ByteString]
118a118
> conduitPutListconduitPutGeneric= conduit(conduitPutListwhere conduit, yield=(doLBS.toChunks{mx <- await(runPut; casexmx)))of; Nothing -> return (); Just x -> do {  yield (LBS.toChunks (runPut x)) ; conduit}}
121d120
< conduitPutMany :: MonadThrow m => Conduit Put m (V.Vector ByteString)
122c121
< conduitPutGeneric(conduitPutMany, yield (V.fromList (LBS.toChunks (runPut x))))
---
> conduitPutMany               :: MonadThrow m => Conduit Put m (V.Vector ByteString)
122a122
> conduitPutManyconduitPutGeneric= conduit(conduitPutManywhere conduit, yield=(doV.fromList{mx <- await(LBS.toChunks; case mx of(runPut; Nothingx)))->)  return (); Just x -> do {  yield (V.fromList (LBS.toChunks (runPut x))) ; conduit}}
125d124
< sourcePut :: MonadThrow m => Put -> Producer m ByteString
126c125
< sourcePut = CL.sourceList . LBS.toChunks . runPut
---
> sourcePut          :: MonadThrow m => Put -> Producer m ByteString
126a126
> sourcePut          = CL.sourceList . LBS.toChunks . runPut
129d128
< sinkGet :: MonadThrow m => Get b -> Consumer ByteString m b
130c129
< sinkGet f = sink (runGetIncremental f)
---
> sinkGet        :: MonadThrow m => Get b -> Consumer ByteString m b
130a130
> sinkGet        f = sink (runGetIncremental f)
134a135
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE CPP #-}
module Data.Conduit.Serialization.Binary
  ( conduitDecode
  , conduitEncode
  , conduitMsgEncode
  , conduitGet
  , conduitPut
  , conduitPutList
  , conduitPutLBS
  , conduitPutMany
  , sourcePut
  , sinkGet
  , ParseError(..)
  )
  where

import           Control.Exception
import           Data.Binary
import           Data.Binary.Get
import           Data.Binary.Put
import           Data.ByteString      as BS
import qualified Data.ByteString.Lazy as LBS

import           Data.Conduit
import qualified Data.Conduit.List    as CL
import           Data.Typeable
import qualified Data.Vector          as V
import           Control.Monad.Trans.Resource
     (MonadThrow
     , monadThrow)


data ParseError = ParseError
      { unconsumed :: ByteString
        -- ^ Data left unconsumed in single stream input value.

      , offset     :: ByteOffset
        -- ^ Number of bytes consumed from single stream input value.

      , content    :: String      -- ^ Error content.
      } deriving (Show, Typeable)

instance Exception ParseError

-- | Runs default 'Decoder' repeatedly on a input stream.
conduitDecode :: (Binary b, MonadThrow m) => Conduit ByteString m b
conduitDecode = conduitGet get

-- | Runs default encoder on a input stream.
--
-- This function produces a stream of bytes where for each input
-- value you will have a number of 'ByteString's, and no boundary
-- between different values.
conduitEncode :: (Binary b, MonadThrow m) => Conduit b m ByteString
conduitEncode = CL.map put =$= conduitPut


-- | Runs default encoder on input stream.
--
-- This function produces a ByteString per each incomming packet,
-- it may be useful in datagram based protocols.
-- Function maintains following property
--
-- >   'conduitMsgEncode' xs == 'CL.map' 'Data.ByteString.encode' =$= 'CL.map' 'LBS.toStrict'
--
-- This invariant is maintaind by the cost of additional data copy,
-- so if you packets can be serialized to the large data chunks or
-- you interested in iterative packet serialization
-- concider using 'conduitPutList' or 'conduitPutMany'
--
conduitMsgEncode :: (Binary b, MonadThrow m) => Conduit b m ByteString
conduitMsgEncode = CL.map put =$= conduitMsg

-- | Runs getter repeatedly on a input stream.
conduitGet :: MonadThrow m => Get b -> Conduit ByteString m b
conduitGet g = start
  where
    start = do mx <- await
               case mx of
                  Nothing -> return ()
                  Just x -> go (runGetIncremental g `pushChunk` x)
    go (Done bs _ v) = do yield v
                          if BS.null bs
                            then start
                            else go (runGetIncremental g `pushChunk` bs)
    go (Fail u o e)  = monadThrow (ParseError u o e)
    go (Partial n)   = await >>= (go . n)

-- \o/
#define conduitPutGeneric(name,yi) \
name = conduit \
  where \
    conduit = do {mx <- await;\
                 case mx of;\
                    Nothing -> return ();\
                    Just x  -> do { yi ; conduit}}

-- | Runs putter repeatedly on a input stream, returns an output stream.
conduitPut :: MonadThrow m => Conduit Put m ByteString
conduitPutGeneric(conduitPut, (sourcePut x $$ CL.mapM_ yield))

-- | Runs a putter repeatedly on a input stream, returns a packets.
conduitMsg :: MonadThrow m => Conduit Put m ByteString
conduitPutGeneric(conduitMsg, (yield (LBS.toStrict $ runPut x)))

-- | Runs putter repeatedly on a input stream.
-- Returns a lazy butestring so it's possible to use vectorized
-- IO on the result either by calling' LBS.toChunks' or by
-- calling 'Network.Socket.ByteString.Lazy.send'.
conduitPutLBS :: MonadThrow m => Conduit Put m LBS.ByteString
conduitPutGeneric(conduitPutLBS, yield (runPut x))

-- | Vectorized variant of 'conduitPut' returning list contains
-- all chunks from one element representation
conduitPutList :: MonadThrow m => Conduit Put m [ByteString]
conduitPutGeneric(conduitPutList, yield (LBS.toChunks (runPut x)))

-- | Vectorized variant of 'conduitPut'.
conduitPutMany :: MonadThrow m => Conduit Put m (V.Vector ByteString)
conduitPutGeneric(conduitPutMany, yield (V.fromList (LBS.toChunks (runPut x))))

-- | Create stream of strict bytestrings from 'Put' value.
sourcePut :: MonadThrow m => Put -> Producer m ByteString
sourcePut = CL.sourceList . LBS.toChunks . runPut

-- | Decode message from input stream.
sinkGet :: MonadThrow m => Get b -> Consumer ByteString m b
sinkGet f = sink (runGetIncremental f)
  where
      sink (Done bs _ v)  = leftover bs >> return v
      sink (Fail u o e)   = monadThrow (ParseError u o e)
      sink (Partial next) = await >>= sink . next
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE CPP #-}
module Data.Conduit.Serialization.Binary
  ( conduitDecode
  , conduitEncode
  , conduitMsgEncode
  , conduitGet
  , conduitPut
  , conduitPutList
  , conduitPutLBS
  , conduitPutMany
  , sourcePut
  , sinkGet
  , ParseError(..)
  )
  where

import           Control.Exception
import           Data.Binary
import           Data.Binary.Get
import           Data.Binary.Put
import           Data.ByteString      as BS
import qualified Data.ByteString.Lazy as LBS

import           Data.Conduit
import qualified Data.Conduit.List    as CL
import           Data.Typeable
import qualified Data.Vector          as V
import           Control.Monad.Trans.Resource
     (MonadThrow
     , monadThrow)


data ParseError = ParseError
      { unconsumed :: ByteString
        -- ^ Data left unconsumed in single stream input value.

      , offset     :: ByteOffset
        -- ^ Number of bytes consumed from single stream input value.

      , content    :: String      -- ^ Error content.
      } deriving (Show, Typeable)

instance Exception ParseError

-- | Runs default 'Decoder' repeatedly on a input stream.
conduitDecode :: (Binary b, MonadThrow m) => Conduit ByteString m b
conduitDecode = conduitGet get

-- | Runs default encoder on a input stream.
--
-- This function produces a stream of bytes where for each input
-- value you will have a number of 'ByteString's, and no boundary
-- between different values.
conduitEncode :: (Binary b, MonadThrow m) => Conduit b m ByteString
conduitEncode = CL.map put =$= conduitPut


-- | Runs default encoder on input stream.
--
-- This function produces a ByteString per each incomming packet,
-- it may be useful in datagram based protocols.
-- Function maintains following property
--
-- >   'conduitMsgEncode' xs == 'CL.map' 'Data.ByteString.encode' =$= 'CL.map' 'LBS.toStrict'
--
-- This invariant is maintaind by the cost of additional data copy,
-- so if you packets can be serialized to the large data chunks or
-- you interested in iterative packet serialization
-- concider using 'conduitPutList' or 'conduitPutMany'
--
conduitMsgEncode :: (Binary b, MonadThrow m) => Conduit b m ByteString
conduitMsgEncode = CL.map put =$= conduitMsg

-- | Runs getter repeatedly on a input stream.
conduitGet :: MonadThrow m => Get b -> Conduit ByteString m b
conduitGet g = start
  where
    start = do mx <- await
               case mx of
                  Nothing -> return ()
                  Just x -> go (runGetIncremental g `pushChunk` x)
    go (Done bs _ v) = do yield v
                          if BS.null bs
                            then start
                            else go (runGetIncremental g `pushChunk` bs)
    go (Fail u o e)  = monadThrow (ParseError u o e)
    go (Partial n)   = await >>= (go . n)

-- \o/
#define conduitPutGeneric(name,yi) \
name = conduit \
  where \
    conduit = do {mx <- await;\
                 case mx of;\
                    Nothing -> return ();\
                    Just x  -> do { yi ; conduit}}

-- | Runs putter repeatedly on a input stream, returns an output stream.
conduitPut :: MonadThrow m => Conduit Put m ByteString
conduitPutconduitPutGeneric= conduit(conduitPutwhere conduit, (sourcePut= do {mxx $$<-CL.mapM_; caseyield))of; Nothing -> return (); Just x -> do {  (sourcePut x $$ CL.mapM_ yield) ; conduit}}

-- | Runs a putter repeatedly on a input stream, returns a packets.
conduitMsg           :: MonadThrow m => Conduit Put m ByteString
conduitMsgconduitPutGeneric= conduit(conduitMsgwhere conduit, (yield= do(LBS.toStrict{mx <- await$;runPut mxx)of)); Nothing -> return (); Just x -> do {  (yield (LBS.toStrict $ runPut x)) ; conduit}}

-- | Runs putter repeatedly on a input stream.
-- Returns a lazy butestring so it's possible to use vectorized
-- IO on the result either by calling' LBS.toChunks' or by
-- calling 'Network.Socket.ByteString.Lazy.send'.
conduitPutLBS              :: MonadThrow m => Conduit Put m LBS.ByteString
conduitPutLBSconduitPutGeneric= conduit(conduitPutLBSwhere conduit, yield=(dorunPut{mx <-x))await; case mx of; Nothing -> return (); Just x -> do {  yield (runPut x) ; conduit}}

-- | Vectorized variant of 'conduitPut' returning list contains
-- all chunks from one element representation
conduitPutList               :: MonadThrow m => Conduit Put m [ByteString]
conduitPutListconduitPutGeneric= conduit(conduitPutListwhere conduit, yield=(doLBS.toChunks{mx <- await(runPut; casexmx)))of; Nothing -> return (); Just x -> do {  yield (LBS.toChunks (runPut x)) ; conduit}}

-- | Vectorized variant of 'conduitPut'.
conduitPutMany               :: MonadThrow m => Conduit Put m (V.Vector ByteString)
conduitPutManyconduitPutGeneric= conduit(conduitPutManywhere conduit, yield=(doV.fromList{mx <- await(LBS.toChunks; case mx of(runPut; Nothingx)))->)  return (); Just x -> do {  yield (V.fromList (LBS.toChunks (runPut x))) ; conduit}}

-- | Create stream of strict bytestrings from 'Put' value.
sourcePut          :: MonadThrow m => Put -> Producer m ByteString
sourcePut          = CL.sourceList . LBS.toChunks . runPut

-- | Decode message from input stream.
sinkGet        :: MonadThrow m => Get b -> Consumer ByteString m b
sinkGet        f = sink (runGetIncremental f)
  where
      sink (Done bs _ v)  = leftover bs >> return v
      sink (Fail u o e)   = monadThrow (ParseError u o e)
      sink (Partial next) = await >>= sink . next

</pre>