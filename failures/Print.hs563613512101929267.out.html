<a href="Print.hs501650447218264607.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Pristine.hs1073185695316824712.out.html">next</a></br></br><pre>21c21
< sortBy' ∷ SortingType → [Todo] → [Todo]
---
> sortBy' :: SortingType -> [Todo] -> [Todo]
27d26
<           DoNotSort → error "Internal error: sortBy' should not be called when DoNotSort is specified!"
28d26
<           ByTitle → itemName
29d26
<           ByStatus → itemStatus
30d26
<           ByTags → unwords ∘ itemTags
31d26
<           ByStartDate → show ∘ startDate
32d26
<           ByEndDate → show ∘ endDate
33c27
<           ByDeadline → show ∘ deadline
---
>           DoNotSort -> error "Internal error: sortBy' should not be called when DoNotSort is specified!"
33a28
>           ByTitle -> itemName
33a29
>           ByStatus -> itemStatus
33a30
>           ByTags -> unwords ∘ itemTags
33a31
>           ByStartDate -> show ∘ startDate
33a32
>           ByEndDate -> show ∘ endDate
33a33
>           ByDeadline -> show ∘ deadline
35c35
< showT ∷ SortingType → Int → String → Todo → [Formatter DefaultConfig]
---
> showT :: SortingType -> Int -> String -> Todo -> [Formatter DefaultConfig]
40c40
<     sf ∷ Formatter DefaultConfig
---
>     sf :: Formatter DefaultConfig
45c45
<     item' ∷ Formatter DefaultConfig
---
>     item' :: Formatter DefaultConfig
48c48
<     showId :: TodoItem → Formatter DefaultConfig
---
>     showId :: TodoItem -> Formatter DefaultConfig
50d49
<       s ← askBase outIds
51c50
<       c ← askBase outColors
---
>       s <- askBase outIds
51a51
>       c <- askBase outColors
58c58
< unlines'' ∷ [Formatter c] → Formatter c
---
> unlines'' :: [Formatter c] -> Formatter c
61c61
< showTodo ∷ Todo → Formatter DefaultConfig
---
> showTodo :: Todo -> Formatter DefaultConfig
63d62
<   conf ← asks toBaseConfig
64c63
<   sep ← askBase indentString
---
>   conf <- asks toBaseConfig
64a64
>   sep <- askBase indentString
66d65
<             False → unlines''
67c66
<             True  → head
---
>             False -> unlines''
67a67
>             True  -> head
71c71
< showTodos ∷ [Todo] → Formatter DefaultConfig
---
> showTodos :: [Todo] -> Formatter DefaultConfig
73c73
<   conf ← asks toBaseConfig
---
>   conf <- asks toBaseConfig
75d74
<             False → unlines''
76c75
<             True  → head
---
>             False -> unlines''
76a76
>             True  -> head
80c80
< defaultPrintTodos ∷ PrintConfig DefaultConfig → [Todo] → IO ()
---
> defaultPrintTodos :: PrintConfig DefaultConfig -> [Todo] -> IO ()
84a85
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | This module implements printing TODOs tree to console. Here is default
-- function, but user can supply his own.
module Todos.Default.Print
  (defaultPrintTodos, showTodos)
  where

import Prelude.Unicode
import Control.Monad
import Control.Monad.Reader
import Data.List
import Data.Tree
import Data.Function (on)
import System.Console.ANSI

import Todos.Types
import Todos.Default.Config
import Todos.Default.Instances ()
import Todos.Formatters

sortBy' ∷ SortingType → [Todo] → [Todo]
sortBy' s | s == DoNotSort = id
          | otherwise = sortBy sorter
  where
    sorter = compare `on` (f ∘ rootLabel)
    f = case s of
          DoNotSort → error "Internal error: sortBy' should not be called when DoNotSort is specified!"
          ByTitle → itemName
          ByStatus → itemStatus
          ByTags → unwords ∘ itemTags
          ByStartDate → show ∘ startDate
          ByEndDate → show ∘ endDate
          ByDeadline → show ∘ deadline

showT ∷ SortingType → Int → String → Todo → [Formatter DefaultConfig]
showT s n sep (Node item todos) =
    (sf <++> showId item <++> seps <++> item') :
      (concatMap (showT s (n+1) sep) $ sortBy' s todos)
  where
    sf ∷ Formatter DefaultConfig
    sf = startFormat

    seps = concat (replicate n sep)

    item' ∷ Formatter DefaultConfig
    item' = configShow item

    showId :: TodoItem → Formatter DefaultConfig
    showId item = do
      s ← askBase outIds
      c ← askBase outColors
      if s
        then if c
               then return [OutSetColor Dull Yellow, OutString $ makeId item ++ " ", ResetAll]
               else return [OutString $ makeId item ++ " "]
        else return [OutString ""]

unlines'' ∷ [Formatter c] → Formatter c
unlines'' lst = concat `fmap` (sequence $ intersperse newLine lst)

showTodo ∷ Todo → Formatter DefaultConfig
showTodo t = do
  conf ← asks toBaseConfig
  sep ← askBase indentString
  let f = case outOnlyFirst conf of
            False → unlines''
            True  → head
  f $ showT (sorting conf) 0 sep t

-- | Prepare TODOs for console output
showTodos ∷ [Todo] → Formatter DefaultConfig
showTodos lst = do
  conf ← asks toBaseConfig
  let f = case outOnlyFirst conf of
            False → unlines''
            True  → head
  f $ map showTodo $ sortBy' (sorting conf) $ nub lst

-- | Default function to output TODOs to console
defaultPrintTodos ∷ PrintConfig DefaultConfig → [Todo] → IO ()
defaultPrintTodos cfg lst =
  let lst' = runReader (showTodos lst) cfg
  in  forM lst' outItem >> putStrLn ""

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | This module implements printing TODOs tree to console. Here is default
-- function, but user can supply his own.
module Todos.Default.Print
  (defaultPrintTodos, showTodos)
  where

import Prelude.Unicode
import Control.Monad
import Control.Monad.Reader
import Data.List
import Data.Tree
import Data.Function (on)
import System.Console.ANSI

import Todos.Types
import Todos.Default.Config
import Todos.Default.Instances ()
import Todos.Formatters

sortBy' :: SortingType -> [Todo] -> [Todo]
sortBy' s | s == DoNotSort = id
          | otherwise = sortBy sorter
  where
    sorter = compare `on` (f ∘ rootLabel)
    f = case s of
          DoNotSort -> error "Internal error: sortBy' should not be called when DoNotSort is specified!"
          ByTitle -> itemName
          ByStatus -> itemStatus
          ByTags -> unwords ∘ itemTags
          ByStartDate -> show ∘ startDate
          ByEndDate -> show ∘ endDate
          ByDeadline -> show ∘ deadline

showT :: SortingType -> Int -> String -> Todo -> [Formatter DefaultConfig]
showT s n sep (Node item todos) =
    (sf <++> showId item <++> seps <++> item') :
      (concatMap (showT s (n+1) sep) $ sortBy' s todos)
  where
    sf :: Formatter DefaultConfig
    sf = startFormat

    seps = concat (replicate n sep)

    item' :: Formatter DefaultConfig
    item' = configShow item

    showId :: TodoItem -> Formatter DefaultConfig
    showId item = do
      s <- askBase outIds
      c <- askBase outColors
      if s
        then if c
               then return [OutSetColor Dull Yellow, OutString $ makeId item ++ " ", ResetAll]
               else return [OutString $ makeId item ++ " "]
        else return [OutString ""]

unlines'' :: [Formatter c] -> Formatter c
unlines'' lst = concat `fmap` (sequence $ intersperse newLine lst)

showTodo :: Todo -> Formatter DefaultConfig
showTodo t = do
  conf <- asks toBaseConfig
  sep <- askBase indentString
  let f = case outOnlyFirst conf of
            False -> unlines''
            True  -> head
  f $ showT (sorting conf) 0 sep t

-- | Prepare TODOs for console output
showTodos :: [Todo] -> Formatter DefaultConfig
showTodos lst = do
  conf <- asks toBaseConfig
  let f = case outOnlyFirst conf of
            False -> unlines''
            True  -> head
  f $ map showTodo $ sortBy' (sorting conf) $ nub lst

-- | Default function to output TODOs to console
defaultPrintTodos :: PrintConfig DefaultConfig -> [Todo] -> IO ()
defaultPrintTodos cfg lst =
  let lst' = runReader (showTodos lst) cfg
  in  forM lst' outItem >> putStrLn ""


</pre>