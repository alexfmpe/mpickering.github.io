<a href="HUnit.hs18171295601131570933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Hunp.hs13585809791624379149.out.html">next</a></br></br><pre>230d229
< DocAssertion(assertBool, Fail if the 'Bool' value is 'False'.)
231c230
< CreateAssertions(assertBool, Bool)
---
> DocAssertion{- | Fail if the 'Bool' value is 'False'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertBool@ and @gassertBoolVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertBool_@, @assertBoolVerbose_@, @gassertBool_@, and @gassertBoolVerbose_@       functions directly, use the macros @assertBool@, @assertBoolVerbose@, @gassertBool@, and       @gassertBoolVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertBool, Fail if the 'Bool' value is 'False'.)
231a231
> gassertBoolVerbose_CreateAssertions(assertBool:: AssertM, Bool =>)  Location -> String -> Bool -> m (); gassertBoolVerbose_ = _assertBool_ ("assertBool" ++ "Verbose"); gassertBool_ :: AssertM m => Location -> Bool -> m (); gassertBool_ loc = _assertBool_ "assertBool" loc ""; assertBoolVerbose_ ::  Location -> String -> Bool -> IO (); assertBoolVerbose_ = _assertBool_ ("assertBool" ++ "Verbose"); assertBool_ ::  Location -> Bool -> IO (); assertBool_ loc = _assertBool_ "assertBool" loc ""
284c284
< DocAssertion(assertEqual, Fail if the two values of type @a@ are not equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are not equal.
285a286
>              of @a@ is an instance of 'Show' but not of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqual@ and @gassertEqualVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqual_@, @assertEqualVerbose_@, @gassertEqual_@, and @gassertEqualVerbose_@       functions directly, use the macros @assertEqual@, @assertEqualVerbose@, @gassertEqual@, and       @gassertEqualVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqual, Fail if the two values of type @a@ are not equal.
285a287
>              The first parameter denotes the expected value. Use these two functions
287c289
< CreateAssertionsCtx(assertEqual, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> a)
---
> gassertEqualVerbose_CreateAssertionsCtx(assertEqual:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->aa->)  m (); gassertEqualVerbose_ = _assertEqual_ ("assertEqual" ++ "Verbose"); gassertEqual_ :: (Eq a, Show a, AssertM m) => Location -> a -> a -> m (); gassertEqual_ loc = _assertEqual_ "assertEqual" loc ""; assertEqualVerbose_ :: (Eq a, Show a) => Location -> String -> a -> a -> IO (); assertEqualVerbose_ = _assertEqual_ ("assertEqual" ++ "Verbose"); assertEqual_ :: (Eq a, Show a) => Location -> a -> a -> IO (); assertEqual_ loc = _assertEqual_ "assertEqual" loc ""
297c299
< DocAssertion(assertNotEqual, Fail if the two values of type @a@ are equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are equal.
298a301
>              of @a@ is an instance of 'Show' but not of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqual@ and @gassertNotEqualVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqual_@, @assertNotEqualVerbose_@, @gassertNotEqual_@, and @gassertNotEqualVerbose_@       functions directly, use the macros @assertNotEqual@, @assertNotEqualVerbose@, @gassertNotEqual@, and       @gassertNotEqualVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqual, Fail if the two values of type @a@ are equal.
298a302
>              The first parameter denotes the expected value. Use these two functions
300c304
< CreateAssertionsCtx(assertNotEqual, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> a)
---
> gassertNotEqualVerbose_CreateAssertionsCtx(assertNotEqual:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->aa->)  m (); gassertNotEqualVerbose_ = _assertNotEqual_ ("assertNotEqual" ++ "Verbose"); gassertNotEqual_ :: (Eq a, Show a, AssertM m) => Location -> a -> a -> m (); gassertNotEqual_ loc = _assertNotEqual_ "assertNotEqual" loc ""; assertNotEqualVerbose_ :: (Eq a, Show a) => Location -> String -> a -> a -> IO (); assertNotEqualVerbose_ = _assertNotEqual_ ("assertNotEqual" ++ "Verbose"); assertNotEqual_ :: (Eq a, Show a) => Location -> a -> a -> IO (); assertNotEqual_ loc = _assertNotEqual_ "assertNotEqual" loc ""
311c315
< DocAssertion(assertEqualPretty, Fail if the two values of type @a@ are not equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are not equal.
312a317
>              of @a@ is an instance of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqualPretty@ and @gassertEqualPrettyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqualPretty_@, @assertEqualPrettyVerbose_@, @gassertEqualPretty_@, and @gassertEqualPrettyVerbose_@       functions directly, use the macros @assertEqualPretty@, @assertEqualPrettyVerbose@, @gassertEqualPretty@, and       @gassertEqualPrettyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqualPretty, Fail if the two values of type @a@ are not equal.
312a318
>              The first parameter denotes the expected value. Use these two functions
314c320
< CreateAssertionsCtx(assertEqualPretty, (Eq a, Pretty a), (Eq a, Pretty a, AssertM m), a -> a)
---
> gassertEqualPrettyVerbose_CreateAssertionsCtx(assertEqualPretty:: (Eq a, Pretty, (Eq aa,Prettya)m)(=> Locationa, Pretty->a,StringAssertM->ma,->a a->->a)m (); gassertEqualPrettyVerbose_ = _assertEqualPretty_ ("assertEqualPretty" ++ "Verbose"); gassertEqualPretty_ :: (Eq a, Pretty a, AssertM m) => Location -> a -> a -> m (); gassertEqualPretty_ loc = _assertEqualPretty_ "assertEqualPretty" loc ""; assertEqualPrettyVerbose_ :: (Eq a, Pretty a) => Location -> String -> a -> a -> IO (); assertEqualPrettyVerbose_ = _assertEqualPretty_ ("assertEqualPretty" ++ "Verbose"); assertEqualPretty_ :: (Eq a, Pretty a) => Location -> a -> a -> IO (); assertEqualPretty_ loc = _assertEqualPretty_ "assertEqualPretty" loc ""
323c329
< DocAssertion(assertNotEqualPretty, Fail if the two values of type @a@ are equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are equal.
324a331
>              of @a@ is an instance of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqualPretty@ and @gassertNotEqualPrettyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqualPretty_@, @assertNotEqualPrettyVerbose_@, @gassertNotEqualPretty_@, and @gassertNotEqualPrettyVerbose_@       functions directly, use the macros @assertNotEqualPretty@, @assertNotEqualPrettyVerbose@, @gassertNotEqualPretty@, and       @gassertNotEqualPrettyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqualPretty, Fail if the two values of type @a@ are equal.
324a332
>              The first parameter denotes the expected value. Use these two functions
326c334
< CreateAssertionsCtx(assertNotEqualPretty, (Eq a, Pretty a), (Eq a, Pretty a, AssertM m), a -> a)
---
> gassertNotEqualPrettyVerbose_CreateAssertionsCtx(assertNotEqualPretty:: (Eq a, Pretty, (Eq aa,Prettya)m)(=> Locationa, Pretty->a,StringAssertM->ma,->a a->->a)m (); gassertNotEqualPrettyVerbose_ = _assertNotEqualPretty_ ("assertNotEqualPretty" ++ "Verbose"); gassertNotEqualPretty_ :: (Eq a, Pretty a, AssertM m) => Location -> a -> a -> m (); gassertNotEqualPretty_ loc = _assertNotEqualPretty_ "assertNotEqualPretty" loc ""; assertNotEqualPrettyVerbose_ :: (Eq a, Pretty a) => Location -> String -> a -> a -> IO (); assertNotEqualPrettyVerbose_ = _assertNotEqualPretty_ ("assertNotEqualPretty" ++ "Verbose"); assertNotEqualPretty_ :: (Eq a, Pretty a) => Location -> a -> a -> IO (); assertNotEqualPretty_ loc = _assertNotEqualPretty_ "assertNotEqualPretty" loc ""
334c342
< DocAssertion(assertEqualNoShow, Fail if the two values of type @a@ are not equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are not equal.
336a345
>              case the generated error message might not be very helpful. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqualNoShow@ and @gassertEqualNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqualNoShow_@, @assertEqualNoShowVerbose_@, @gassertEqualNoShow_@, and @gassertEqualNoShowVerbose_@       functions directly, use the macros @assertEqualNoShow@, @assertEqualNoShowVerbose@, @gassertEqualNoShow@, and       @gassertEqualNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqualNoShow, Fail if the two values of type @a@ are not equal.
336a346
>              The first parameter denotes the expected value. Use these two functions
336a347
>              of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
338c349
< CreateAssertionsCtx(assertEqualNoShow, Eq a, (Eq a, AssertM m), a -> a)
---
> gassertEqualNoShowVerbose_CreateAssertionsCtx(assertEqualNoShow:: (Eq a, AssertM, Eq a, m)Eq=>a,LocationAssertM ->m),Stringa -> a->)  a -> a -> m (); gassertEqualNoShowVerbose_ = _assertEqualNoShow_ ("assertEqualNoShow" ++ "Verbose"); gassertEqualNoShow_ :: (Eq a, AssertM m) => Location -> a -> a -> m (); gassertEqualNoShow_ loc = _assertEqualNoShow_ "assertEqualNoShow" loc ""; assertEqualNoShowVerbose_ :: Eq a => Location -> String -> a -> a -> IO (); assertEqualNoShowVerbose_ = _assertEqualNoShow_ ("assertEqualNoShow" ++ "Verbose"); assertEqualNoShow_ :: Eq a => Location -> a -> a -> IO (); assertEqualNoShow_ loc = _assertEqualNoShow_ "assertEqualNoShow" loc ""
346c357
< DocAssertion(assertNotEqualNoShow, Fail if the two values of type @a@ are equal.
---
> DocAssertion{- | Fail if the two values of type @a@ are equal.
348a360
>              case the generated error message might not be very helpful. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqualNoShow@ and @gassertNotEqualNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqualNoShow_@, @assertNotEqualNoShowVerbose_@, @gassertNotEqualNoShow_@, and @gassertNotEqualNoShowVerbose_@       functions directly, use the macros @assertNotEqualNoShow@, @assertNotEqualNoShowVerbose@, @gassertNotEqualNoShow@, and       @gassertNotEqualNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqualNoShow, Fail if the two values of type @a@ are equal.
348a361
>              The first parameter denotes the expected value. Use these two functions
348a362
>              of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
350c364
< CreateAssertionsCtx(assertNotEqualNoShow, Eq a, (Eq a, AssertM m), a -> a)
---
> gassertNotEqualNoShowVerbose_CreateAssertionsCtx(assertNotEqualNoShow:: (Eq a, AssertM, Eq a, m)Eq=>a,LocationAssertM ->m),Stringa -> a->)  a -> a -> m (); gassertNotEqualNoShowVerbose_ = _assertNotEqualNoShow_ ("assertNotEqualNoShow" ++ "Verbose"); gassertNotEqualNoShow_ :: (Eq a, AssertM m) => Location -> a -> a -> m (); gassertNotEqualNoShow_ loc = _assertNotEqualNoShow_ "assertNotEqualNoShow" loc ""; assertNotEqualNoShowVerbose_ :: Eq a => Location -> String -> a -> a -> IO (); assertNotEqualNoShowVerbose_ = _assertNotEqualNoShow_ ("assertNotEqualNoShow" ++ "Verbose"); assertNotEqualNoShow_ :: Eq a => Location -> a -> a -> IO (); assertNotEqualNoShow_ loc = _assertNotEqualNoShow_ "assertNotEqualNoShow" loc ""
378c392
< DocAssertion(assertListsEqualAsSets, Fail if the two given lists are not equal
---
> DocAssertion{- | Fail if the two given lists are not equal
379a394
>                                      denotes the expected value. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertListsEqualAsSets@ and @gassertListsEqualAsSetsVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertListsEqualAsSets_@, @assertListsEqualAsSetsVerbose_@, @gassertListsEqualAsSets_@, and @gassertListsEqualAsSetsVerbose_@       functions directly, use the macros @assertListsEqualAsSets@, @assertListsEqualAsSetsVerbose@, @gassertListsEqualAsSets@, and       @gassertListsEqualAsSetsVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertListsEqualAsSets, Fail if the two given lists are not equal
379a395
>                                      when considered as sets. The first list parameter
381c397
< CreateAssertionsCtx(assertListsEqualAsSets, (Eq a, Show a), (Eq a, Show a, AssertM m), [a] -> [a])
---
> gassertListsEqualAsSetsVerbose_CreateAssertionsCtx(assertListsEqualAsSets:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),[a]]->->[a]]->)  m (); gassertListsEqualAsSetsVerbose_ = _assertListsEqualAsSets_ ("assertListsEqualAsSets" ++ "Verbose"); gassertListsEqualAsSets_ :: (Eq a, Show a, AssertM m) => Location -> [a] -> [a] -> m (); gassertListsEqualAsSets_ loc = _assertListsEqualAsSets_ "assertListsEqualAsSets" loc ""; assertListsEqualAsSetsVerbose_ :: (Eq a, Show a) => Location -> String -> [a] -> [a] -> IO (); assertListsEqualAsSetsVerbose_ = _assertListsEqualAsSets_ ("assertListsEqualAsSets" ++ "Verbose"); assertListsEqualAsSets_ :: (Eq a, Show a) => Location -> [a] -> [a] -> IO (); assertListsEqualAsSets_ loc = _assertListsEqualAsSets_ "assertListsEqualAsSets" loc ""
387d402
< DocAssertion(assertNotEmpty, Fail if the given list is empty.)
388c403
< CreateAssertions(assertNotEmpty, [a])
---
> DocAssertion{- | Fail if the given list is empty. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEmpty@ and @gassertNotEmptyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEmpty_@, @assertNotEmptyVerbose_@, @gassertNotEmpty_@, and @gassertNotEmptyVerbose_@       functions directly, use the macros @assertNotEmpty@, @assertNotEmptyVerbose@, @gassertNotEmpty@, and       @gassertNotEmptyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertNotEmpty, Fail if the given list is empty.)
388a404
> gassertNotEmptyVerbose_CreateAssertions(assertNotEmpty:: AssertM, [am)=> Location -> String -> [a] -> m (); gassertNotEmptyVerbose_ = _assertNotEmpty_ ("assertNotEmpty" ++ "Verbose"); gassertNotEmpty_ :: AssertM m => Location -> [a] -> m (); gassertNotEmpty_ loc = _assertNotEmpty_ "assertNotEmpty" loc ""; assertNotEmptyVerbose_ ::  Location -> String -> [a] -> IO (); assertNotEmptyVerbose_ = _assertNotEmpty_ ("assertNotEmpty" ++ "Verbose"); assertNotEmpty_ ::  Location -> [a] -> IO (); assertNotEmpty_ loc = _assertNotEmpty_ "assertNotEmpty" loc ""
394d409
< DocAssertion(assertEmpty, Fail if the given list is a non-empty list.)
395c410
< CreateAssertions(assertEmpty, [a])
---
> DocAssertion{- | Fail if the given list is a non-empty list. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEmpty@ and @gassertEmptyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEmpty_@, @assertEmptyVerbose_@, @gassertEmpty_@, and @gassertEmptyVerbose_@       functions directly, use the macros @assertEmpty@, @assertEmptyVerbose@, @gassertEmpty@, and       @gassertEmptyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertEmpty, Fail if the given list is a non-empty list.)
395a411
> gassertEmptyVerbose_CreateAssertions(assertEmpty:: AssertM, [am)=> Location -> String -> [a] -> m (); gassertEmptyVerbose_ = _assertEmpty_ ("assertEmpty" ++ "Verbose"); gassertEmpty_ :: AssertM m => Location -> [a] -> m (); gassertEmpty_ loc = _assertEmpty_ "assertEmpty" loc ""; assertEmptyVerbose_ ::  Location -> String -> [a] -> IO (); assertEmptyVerbose_ = _assertEmpty_ ("assertEmpty" ++ "Verbose"); assertEmpty_ ::  Location -> [a] -> IO (); assertEmpty_ loc = _assertEmpty_ "assertEmpty" loc ""
405d420
< DocAssertion(assertElem, Fail if the given element is not in the list.)
406c421
< CreateAssertionsCtx(assertElem, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> [a])
---
> DocAssertion{- | Fail if the given element is not in the list. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertElem@ and @gassertElemVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertElem_@, @assertElemVerbose_@, @gassertElem_@, and @gassertElemVerbose_@       functions directly, use the macros @assertElem@, @assertElemVerbose@, @gassertElem@, and       @gassertElemVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertElem, Fail if the given element is not in the list.)
406a422
> gassertElemVerbose_(::assertElemEq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->[a]]->)  m (); gassertElemVerbose_ = _assertElem_ ("assertElem" ++ "Verbose"); gassertElem_ :: (Eq a, Show a, AssertM m) => Location -> a -> [a] -> m (); gassertElem_ loc = _assertElem_ "assertElem" loc ""; assertElemVerbose_ :: (Eq a, Show a) => Location -> String -> a -> [a] -> IO (); assertElemVerbose_ = _assertElem_ ("assertElem" ++ "Verbose"); assertElem_ :: (Eq a, Show a) => Location -> a -> [a] -> IO (); assertElem_ loc = _assertElem_ "assertElem" loc ""
416c432
< DocAssertionNoGVariant(assertThrowsIO, Fail if executing the 'IO' action does not
---
> DocAssertionNoGVariant{- | Fail if executing the 'IO' action does not
416a433
>                        throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsIO_@ and @assertThrowsIOVerbose_@       functions directly, use the macros @assertThrowsIO@ and @assertThrowsIOVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsIO, Fail if executing the 'IO' action does not
418c435
< CreateAssertionsCtxNoGVariant(assertThrowsIO, Exception e, IO a -> (e -> Bool))
---
> assertThrowsIOVerbose_CreateAssertionsCtxNoGVariant:: Exception(assertThrowsIO => Location, Exception-> Stringe, IO->aIO->a(->e ->eBool-> Bool))  ) -> IO (); assertThrowsIOVerbose_ = _assertThrowsIO_ ("assertThrowsIO" ++ "Verbose"); assertThrowsIO_ :: Exception e => Location -> IO a -> (e -> Bool) -> IO (); assertThrowsIO_ loc = _assertThrowsIO_ "assertThrowsIO" loc ""
422c439
< DocAssertionNoGVariant(assertThrowsSomeIO, Fail if executing the 'IO' action does not
---
> DocAssertionNoGVariant{- | Fail if executing the 'IO' action does not
422a440
>                        throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSomeIO_@ and @assertThrowsSomeIOVerbose_@       functions directly, use the macros @assertThrowsSomeIO@ and @assertThrowsSomeIOVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsSomeIO, Fail if executing the 'IO' action does not
424c442
< CreateAssertionsNoGVariant(assertThrowsSomeIO, IO a)
---
> assertThrowsSomeIOVerbose_(::assertThrowsSomeIO -> String, IO ->a) IO a -> IO (); assertThrowsSomeIOVerbose_ = _assertThrowsSomeIO_ ("assertThrowsSomeIO" ++ "Verbose"); assertThrowsSomeIO_ ::  Location -> IO a -> IO (); assertThrowsSomeIO_ loc = _assertThrowsSomeIO_ "assertThrowsSomeIO" loc ""
442c460
< DocAssertionNoGVariant(assertThrowsM, Fail if executing the 'm' action does not
---
> DocAssertionNoGVariant{- | Fail if executing the 'm' action does not
442a461
>                        throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsM_@ and @assertThrowsMVerbose_@       functions directly, use the macros @assertThrowsM@ and @assertThrowsMVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsM, Fail if executing the 'm' action does not
444c463
< CreateAssertionsGenericNoGVariant(assertThrowsM, (MonadBaseControl IO m, MonadIO m, Exception e) =>,
---
> assertThrowsMVerbose_CreateAssertionsGenericNoGVariant:: (MonadBaseControl(assertThrowsM m, MonadIO(MonadBaseControl, ExceptionIO e) =>MonadIOm, Exception-> Stringe->) =>,a -> (e -> Bool) -> m (); assertThrowsMVerbose_ = _assertThrowsM_ ("assertThrowsM" ++ "Verbose"); assertThrowsM_ :: (MonadBaseControl IO m, MonadIO m, Exception e) => Location -> m a -> (e -> Bool) -> m (); assertThrowsM_ loc = _assertThrowsM_ "assertThrowsM" loc ""
446d464
< 
448d465
<                     => String -> Location -> String -> m a -> m ()
449c466
< _assertThrowsSomeM_ name loc s x = _assertThrowsM_ name loc s x (\ (_e::SomeException) -> True)
---
> _assertThrowsSomeM_ => String(MonadBaseControl-> LocationIO->mString, MonadIO-> m)a -> m ()
449a467
> _assertThrowsSomeM_ name=> String s-> =Location-> Stringname-> mloca -> x (\ (_e::SomeException) -> True)
449a468
> _assertThrowsSomeM_{- | Fail if executing the 'm' action does not
449a469
>                        throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSomeM_@ and @assertThrowsSomeMVerbose_@       functions directly, use the macros @assertThrowsSomeM@ and @assertThrowsSomeMVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} loc s x = _assertThrowsM_ name loc s x (\ (_e::SomeException) -> True)
451c471
<                        throw an exception.)
---
> assertThrowsSomeMVerbose_throw:: (anMonadBaseControlexception.)    IO m, MonadIO m) => Location -> String -> m a -> m (); assertThrowsSomeMVerbose_ = _assertThrowsSomeM_ ("assertThrowsSomeM" ++ "Verbose"); assertThrowsSomeM_ :: (MonadBaseControl IO m, MonadIO m) => Location -> m a -> m (); assertThrowsSomeM_ loc = _assertThrowsSomeM_ "assertThrowsSomeM" loc ""
453d472
< 
455d473
<                => String -> Location -> String -> a -> (e -> Bool) -> IO ()
456c474
< _assertThrows_ name loc s x f = _assertThrowsIO_ name loc s (evaluate x) f
---
> _assertThrows_ => StringException-> Locatione        -> String -> a -> (e -> Bool) -> IO ()
456a475
> _assertThrows_ name=> String s-> fLocation= _assertThrowsIO_-> String ->namea ->loc(e s->(evaluateBool) -> xIO) f)
456a476
> _assertThrows_{- | Fail if evaluating the expression of type @a@ does not
456a477
>                        throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrows_@ and @assertThrowsVerbose_@       functions directly, use the macros @assertThrows@ and @assertThrowsVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} loc s x f = _assertThrowsIO_ name loc s (evaluate x) f
458c479
<                        throw an exception satisfying the given predicate @(e -> Bool)@.)
---
> assertThrowsVerbose_ ::throwan exception => Locationsatisfying-> Stringthe given-> a ->predicatee -> Bool@(e)->->Bool ()@.;)assertThrowsVerbose_ = _assertThrows_ ("assertThrows" ++ "Verbose"); assertThrows_ :: Exception e => Location -> a -> (e -> Bool) -> IO (); assertThrows_ loc = _assertThrows_ "assertThrows" loc ""
460d480
< 
462d481
< _assertThrowsSome_ name loc s x =
463c482
<     _assertThrows_ name loc s x (\ (_e::SomeException) -> True)
---
> _assertThrowsSome_ name:: String s-> =Location -> String -> a -> IO ()
463a483
> _assertThrowsSome_ name loc s x (\ (_e::SomeException) -> True)
463a484
> {- | Fail if evaluating the expression of type @a@ does not
463a485
>                        throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSome_@ and @assertThrowsSomeVerbose_@       functions directly, use the macros @assertThrowsSome@ and @assertThrowsSomeVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} name loc s x (\ (_e::SomeException) -> True)
465c487
<                        throw an exception.)
---
> assertThrowsSomeVerbose_throw::  Locationan exception-> String.)     -> a -> IO (); assertThrowsSomeVerbose_ = _assertThrowsSome_ ("assertThrowsSome" ++ "Verbose"); assertThrowsSome_ ::  Location -> a -> IO (); assertThrowsSome_ loc = _assertThrowsSome_ "assertThrowsSome" loc ""
467d488
< 
469c490
< -- Assertions on Either
---
> ---- Assertions on Either
469a491
> ---- Assertions on Either
471d492
< 
473d493
<              => String -> Location -> String -> Either a b -> m a
474d493
< _assertLeft_ _ _ _ (Left x) = return x
475d493
< _assertLeft_ name loc s (Right x) =
476d493
<     genericAssertFailure__ loc (mkMsg name s
477d493
<                                 ("failed at " ++ showLoc loc ++
478d493
<                                  ": expected a Left value, given " ++
479c494
<                                  show (Right x :: Either b b)))
---
> _assertLeft_ => String ->a bLocationm . (AssertM-> Stringm, Show-> Eitherb)     a b -> m a
479a495
> _assertLeft_ _=>_String (Left->x)Location= return->xString -> Either a b -> m a
479a496
> _assertLeft_ name_ _ _loc(Left (Rightx) = return) =  x
479a497
> _assertLeft_name loc s (Right (mkMsg) =   name s
479a498
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
479a499
>                                 (": expected a Left value, given ""failed at " ++ showLoc loc ++    ++
479a500
>                                  show": expected a Left value, given "Right x :: Either b b)))    ++
479a501
> {- | Fail if the given @Either a b@ value is a 'Right'.
479a502
>              Use this function if @b@ is an instance of 'Show' The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertLeft@ and @gassertLeftVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertLeft_@, @assertLeftVerbose_@, @gassertLeft_@, and @gassertLeftVerbose_@       functions directly, use the macros @assertLeft@, @assertLeftVerbose@, @gassertLeft@, and       @gassertLeftVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} (Right x :: Either b b)))
481c504
<              Use this function if @b@ is an instance of 'Show')
---
> gassertLeftVerbose_Use this::functionShow b,if@b@ ism)an=>instanceof->'Show')  -> Either a b -> m a; gassertLeftVerbose_ = _assertLeft_ ("assertLeft" ++ "Verbose"); gassertLeft_ :: (Show b, AssertM m) => Location -> Either a b -> m a; gassertLeft_ loc = _assertLeft_ "assertLeft" loc ""; assertLeftVerbose_ :: Show b => Location -> String -> Either a b -> IO a; assertLeftVerbose_ = _assertLeft_ ("assertLeft" ++ "Verbose"); assertLeft_ :: Show b => Location -> Either a b -> IO a; assertLeft_ loc = _assertLeft_ "assertLeft" loc ""
483d505
< 
485d506
< _assertLeftNoShow_ _ _ _ (Left x) = return x
486d506
< _assertLeftNoShow_ name loc s (Right _) =
487d506
<     genericAssertFailure__ loc (mkMsg name s
488d506
<                                 ("failed at " ++ showLoc loc ++
489d506
<                                  ": expected a Left value, given a Right value"))
490c507
< DocAssertion(assertLeftNoShow, Fail if the given @Either a b@ value is a 'Right'.)
---
> _assertLeftNoShow_ _::_AssertM (Leftmx)=>=String-> Location -> String -> Either a b -> m a
490a508
> _assertLeftNoShow_ name_ _ _loc(Left (Rightx) = return) =  x
490a509
> _assertLeftNoShow_name loclocs ((RightmkMsg_name) =  s
490a510
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
490a511
>                                 (": expected a Left value, given a Right value""failed at " ++ showLoc loc ++                ))
490a512
> {- | Fail if the given @Either a b@ value is a 'Right'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertLeftNoShow@ and @gassertLeftNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertLeftNoShow_@, @assertLeftNoShowVerbose_@, @gassertLeftNoShow_@, and @gassertLeftNoShowVerbose_@       functions directly, use the macros @assertLeftNoShow@, @assertLeftNoShowVerbose@, @gassertLeftNoShow@, and       @gassertLeftNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Left value, given a Right value"))
490a513
> gassertLeftNoShowVerbose_DocAssertion(assertLeftNoShow:: AssertM, Fail if =>theLocationgiven @Either-> Stringa b@->valueis a bRight'-> m a; gassertLeftNoShowVerbose_ = _assertLeftNoShow_ ("assertLeftNoShow" ++ "Verbose"); gassertLeftNoShow_ :: AssertM m => Location -> Either a b -> m a; gassertLeftNoShow_ loc = _assertLeftNoShow_ "assertLeftNoShow" loc ""; assertLeftNoShowVerbose_ ::  Location -> String -> Either a b -> IO a; assertLeftNoShowVerbose_ = _assertLeftNoShow_ ("assertLeftNoShow" ++ "Verbose"); assertLeftNoShow_ ::  Location -> Either a b -> IO a; assertLeftNoShow_ loc = _assertLeftNoShow_ "assertLeftNoShow" loc ""
492d514
< 
494d515
<               => String -> Location -> String -> Either a b -> m b
495d515
< _assertRight_ _ _ _ (Right x) = return x
496d515
< _assertRight_ name loc s (Left x) =
497d515
<     genericAssertFailure__ loc (mkMsg name s
498d515
<                                 ("failed at " ++ showLoc loc ++
499d515
<                                  ": expected a Right value, given " ++
500c516
<                                  show (Left x :: Either a a)))
---
> _assertRight_ => String ->a bLocationm . (Show->aString, AssertM-> Eitherm)     a b -> m b
500a517
> _assertRight_ _=>_String (Right-> xLocation) = return-> xString -> Either a b -> m b
500a518
> _assertRight_ name_ _ _loc(Right (Leftx) =x)return=    x
500a519
> _assertRight_name loc s (Left (mkMsg) =   name s
500a520
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
500a521
>                                 (": expected a Right value, given ""failed at " ++ showLoc loc ++     ++
500a522
>                                  show": expected a Right value, given "Left x :: Either a a)))      ++
500a523
> {- | Fail if the given @Either a b@ value is a 'Left'.
500a524
>              Use this function if @a@ is an instance of 'Show' The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertRight@ and @gassertRightVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertRight_@, @assertRightVerbose_@, @gassertRight_@, and @gassertRightVerbose_@       functions directly, use the macros @assertRight@, @assertRightVerbose@, @gassertRight@, and       @gassertRightVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} (Left x :: Either a a)))
502c526
<              Use this function if @a@ is an instance of 'Show')
---
> gassertRightVerbose_Use this::functionShow a,ifAssertM@a@ is man) =>instanceof ->'Show')   -> Either a b -> m b; gassertRightVerbose_ = _assertRight_ ("assertRight" ++ "Verbose"); gassertRight_ :: (Show a, AssertM m) => Location -> Either a b -> m b; gassertRight_ loc = _assertRight_ "assertRight" loc ""; assertRightVerbose_ :: Show a => Location -> String -> Either a b -> IO b; assertRightVerbose_ = _assertRight_ ("assertRight" ++ "Verbose"); assertRight_ :: Show a => Location -> Either a b -> IO b; assertRight_ loc = _assertRight_ "assertRight" loc ""
504d527
< 
506d528
< _assertRightNoShow_ _ _ _ (Right x) = return x
507d528
< _assertRightNoShow_ name loc s (Left _) =
508d528
<     genericAssertFailure__ loc (mkMsg name s
509d528
<                                 ("failed at " ++ showLoc loc ++
510d528
<                                  ": expected a Right value, given a Left value"))
511c529
< DocAssertion(assertRightNoShow, Fail if the given @Either a b@ value is a 'Left'.)
---
> _assertRightNoShow_ _::_AssertM (Rightm x=>) =String->xLocation -> String -> Either a b -> m b
511a530
> _assertRightNoShow_ name_ _ _loc(Right (Leftx) =_)return=    x
511a531
> _assertRightNoShow_name locs (mkMsgLeft _name) =  s
511a532
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
511a533
>                                 (": expected a Right value, given a Left value""failed at " ++ showLoc loc ++                ))
511a534
> {- | Fail if the given @Either a b@ value is a 'Left'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertRightNoShow@ and @gassertRightNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertRightNoShow_@, @assertRightNoShowVerbose_@, @gassertRightNoShow_@, and @gassertRightNoShowVerbose_@       functions directly, use the macros @assertRightNoShow@, @assertRightNoShowVerbose@, @gassertRightNoShow@, and       @gassertRightNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Right value, given a Left value"))
511a535
> gassertRightNoShowVerbose_DocAssertion(assertRightNoShow:: AssertM, Fail if =>theLocationgiven @Either-> Stringa b@->valueis a bLeft'-> m.b; gassertRightNoShowVerbose_ = _assertRightNoShow_ ("assertRightNoShow" ++ "Verbose"); gassertRightNoShow_ :: AssertM m => Location -> Either a b -> m b; gassertRightNoShow_ loc = _assertRightNoShow_ "assertRightNoShow" loc ""; assertRightNoShowVerbose_ ::  Location -> String -> Either a b -> IO b; assertRightNoShowVerbose_ = _assertRightNoShow_ ("assertRightNoShow" ++ "Verbose"); assertRightNoShow_ ::  Location -> Either a b -> IO b; assertRightNoShow_ loc = _assertRightNoShow_ "assertRightNoShow" loc ""
513d536
< 
515c538
< -- Assertions on Maybe
---
> ---- Assertions on Maybe
515a539
> ---- Assertions on Maybe
517d540
< 
519d541
< _assertJust_ _ _ _ (Just x) = return x
520d541
< _assertJust_ name loc s Nothing =
521d541
<     genericAssertFailure__ loc (mkMsg name s
522d541
<                                 ("failed at " ++ showLoc loc ++
523d541
<                                  ": expected a Just value, given Nothing"))
524c542
< DocAssertion(assertJust, Fail is the given @Maybe a@ value is a 'Nothing'.)
---
> _assertJust_ _::_AssertM (Justmx)=>=String-> Location -> String -> Maybe a -> m a
524a543
> _assertJust_ name_ _ _loc(Just Nothingx) = return=    x
524a544
> _assertJust_name loc s Nothing (mkMsg=     name s
524a545
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
524a546
>                                 (": expected a Just value, given Nothing""failed at " ++ showLoc loc ++          ))
524a547
> {- | Fail is the given @Maybe a@ value is a 'Nothing'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertJust@ and @gassertJustVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertJust_@, @assertJustVerbose_@, @gassertJust_@, and @gassertJustVerbose_@       functions directly, use the macros @assertJust@, @assertJustVerbose@, @gassertJust@, and       @gassertJustVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Just value, given Nothing"))
524a548
> gassertJustVerbose_DocAssertion(assertJust:: AssertM, Fail is =>theLocationgiven @Maybe-> Stringa@ value-> Maybeis a aNothing'-> m a;.gassertJustVerbose_)                   = _assertJust_ ("assertJust" ++ "Verbose"); gassertJust_ :: AssertM m => Location -> Maybe a -> m a; gassertJust_ loc = _assertJust_ "assertJust" loc ""; assertJustVerbose_ ::  Location -> String -> Maybe a -> IO a; assertJustVerbose_ = _assertJust_ ("assertJust" ++ "Verbose"); assertJust_ ::  Location -> Maybe a -> IO a; assertJust_ loc = _assertJust_ "assertJust" loc ""
526d549
< 
528d550
<                 => String -> Location -> String -> Maybe a -> m ()
529d550
< _assertNothing_ _ _ _ Nothing = return ()
530d550
< _assertNothing_ name loc s jx =
531d550
<     genericAssertFailure__ loc (mkMsg name s
532d550
<                                 ("failed at " ++ showLoc loc ++
533c551
<                                  ": expected Nothing, given " ++ show jx))
---
> _assertNothing_ => String(Show a->, AssertMm)-> String -> Maybe a -> m ()
533a552
> _assertNothing_ _=>_String Nothing-> Location= return->)String -> Maybe a -> m ()
533a553
> _assertNothing_ name_ _ _locNothing jx = return ()
533a554
> _assertNothing_name loc s locjx =(mkMsg name s
533a555
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
533a556
>                                 (": expected Nothing, given ""failed at " ++ showLoc loc ++ show jx))
533a557
> {- | Fail is the given @Maybe a@ value is a 'Just'.
533a558
>              Use this function if @a@ is an instance of 'Show'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNothing@ and @gassertNothingVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNothing_@, @assertNothingVerbose_@, @gassertNothing_@, and @gassertNothingVerbose_@       functions directly, use the macros @assertNothing@, @assertNothingVerbose@, @gassertNothing@, and       @gassertNothingVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} ++ show jx))
535c560
<              Use this function if @a@ is an instance of 'Show'.)
---
> gassertNothingVerbose_Use this function:: (Showif,@AssertMa@ is anm)instance=> Locationof 'Show'-> String.)    -> Maybe a -> m (); gassertNothingVerbose_ = _assertNothing_ ("assertNothing" ++ "Verbose"); gassertNothing_ :: (Show a, AssertM m) => Location -> Maybe a -> m (); gassertNothing_ loc = _assertNothing_ "assertNothing" loc ""; assertNothingVerbose_ :: Show a => Location -> String -> Maybe a -> IO (); assertNothingVerbose_ = _assertNothing_ ("assertNothing" ++ "Verbose"); assertNothing_ :: Show a => Location -> Maybe a -> IO (); assertNothing_ loc = _assertNothing_ "assertNothing" loc ""
537d561
< 
539d562
< _assertNothingNoShow_ _ _ _ Nothing = return ()
540d562
< _assertNothingNoShow_ name loc s _ =
541d562
<     genericAssertFailure__ loc (mkMsg name s
542d562
<                                 ("failed at " ++ showLoc loc ++
543d562
<                                  ": expected Nothing, given a Just value"))
544c563
< DocAssertion(assertNothingNoShow, Fail is the given @Maybe a@ value is a 'Just'.)
---
> _assertNothingNoShow_ _::_AssertM Nothingm =>= return (->) Location -> String -> Maybe a -> m ()
544a564
> _assertNothingNoShow_ name_ _ _locNothing _ == return ()
544a565
> _assertNothingNoShow_name loc (mkMsg_ =  name s
544a566
>     genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
544a567
>                                 (": expected Nothing, given a Just value""failed at " ++ showLoc loc ++          ))
544a568
> {- | Fail is the given @Maybe a@ value is a 'Just'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNothingNoShow@ and @gassertNothingNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNothingNoShow_@, @assertNothingNoShowVerbose_@, @gassertNothingNoShow_@, and @gassertNothingNoShowVerbose_@       functions directly, use the macros @assertNothingNoShow@, @assertNothingNoShowVerbose@, @gassertNothingNoShow@, and       @gassertNothingNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected Nothing, given a Just value"))
544a569
> gassertNothingNoShowVerbose_DocAssertion(assertNothingNoShow:: AssertM, Fail is =>theLocationgiven @Maybe-> Stringa@ value-> Maybeis a aJust'-> m.(); gassertNothingNoShowVerbose_ = _assertNothingNoShow_ ("assertNothingNoShow" ++ "Verbose"); gassertNothingNoShow_ :: AssertM m => Location -> Maybe a -> m (); gassertNothingNoShow_ loc = _assertNothingNoShow_ "assertNothingNoShow" loc ""; assertNothingNoShowVerbose_ ::  Location -> String -> Maybe a -> IO (); assertNothingNoShowVerbose_ = _assertNothingNoShow_ ("assertNothingNoShow" ++ "Verbose"); assertNothingNoShow_ ::  Location -> Maybe a -> IO (); assertNothingNoShow_ loc = _assertNothingNoShow_ "assertNothingNoShow" loc ""
546d570
< 
548c572
< -- Sub assertions
---
> ---- Sub assertions
548a573
> ---- Sub assertions
550d574
< 
552d575
< -- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write
553d575
< --
554d575
< -- > assertIsPositive :: Int -> Assertion
555d575
< -- > assertIsPositive n = assertBool (n > 0)
556d575
< --
557d575
< -- You can now use @assertIsPositive i@ for some integer @i@ from your unit tests, but if you call it directly
558d575
< -- you will lose location information: if @assertIsPositive i@ fails you will only get the location where
559d575
< -- @assertIsPositive@ is defined but not from where it has been called.
560d575
< --
561d575
< -- To recover the location information you simply use @subAssert (assertIsPositive i)@.
562d575
< -- In this case, if @i@ is not positive, you will get the location of the caller.
563d575
< --
564d575
< -- /Note:/ Don't use subAssert_ directly but use the preprocessor macro @subAssert@.
565d575
< subAssert_ :: MonadBaseControl IO m => Location -> m a -> m a
566d575
< subAssert_ loc ass = subAssertHTF loc Nothing ass
567d575
< 
568d575
< -- | Generic variant of 'subAssert_'.
569d575
< gsubAssert_ :: AssertM m => Location -> m a -> m a
570d575
< gsubAssert_ loc ass = genericSubAssert loc Nothing ass
571d575
< 
572d575
< -- | Same as 'subAssert_' but with an additional error message.
573d575
< subAssertVerbose_ :: MonadBaseControl IO m => Location -> String -> m a -> m a
574c576
< subAssertVerbose_ loc msg ass = subAssertHTF loc (Just msg) ass
---
> -- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write-- | Sub assertions are a poor man's way of abstracting over assertions while still propagating location
574a577
> ---- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write
574a578
> ---- > assertIsPositive :: Int -> Assertion
576d579
< -- | Generic variant of 'subAssertVerbose_'.
577d579
< gsubAssertVerbose_ :: AssertM m => Location -> String -> m a -> m a
578d579
< gsubAssertVerbose_ loc msg ass = genericSubAssert loc (Just msg) ass
</pre></br><h2>original</h2></br><pre>{-# OPTIONS_GHC -cpp -pgmPcpphs -optP --layout -optP --hashes -optP --cpp #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}

--
-- Copyright (c) 2005, 2009, 2012  Stefan Wehr - http://www.stefanwehr.de
--
-- This library is free software; you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation; either
-- version 2.1 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
--

{-|

This module provides assert-like functions for writing unit tests.

/Hint:/ Do not use the @assertXXX_@ functions
directly. Instead, for each function @assertXXX_@,
there exist a preprocessor macro @assertXXX@, which provides
the "Location" parameter automatically. Use these macros, which
are available automatically if you add

@&#x7b;-&#x23; OPTIONS_GHC -F -pgmF htfpp &#x23;-&#x7d;@

at the top of your source file (see the 'Test.Framework.Tutorial').

-}

module Test.Framework.HUnitWrapper (

  -- * Assertions on Bool values
  assertBool_, assertBoolVerbose_,
  gassertBool_, gassertBoolVerbose_,

  -- * Equality assertions
  assertEqual_, assertEqualVerbose_,
  gassertEqual_, gassertEqualVerbose_,
  assertEqualPretty_, assertEqualPrettyVerbose_,
  gassertEqualPretty_, gassertEqualPrettyVerbose_,
  assertEqualNoShow_, assertEqualNoShowVerbose_,
  gassertEqualNoShow_, gassertEqualNoShowVerbose_,
  assertNotEqual_, assertNotEqualVerbose_,
  gassertNotEqual_, gassertNotEqualVerbose_,
  assertNotEqualPretty_, assertNotEqualPrettyVerbose_,
  gassertNotEqualPretty_, gassertNotEqualPrettyVerbose_,
  assertNotEqualNoShow_, assertNotEqualNoShowVerbose_,
  gassertNotEqualNoShow_, gassertNotEqualNoShowVerbose_,

  -- * Assertions on lists
  assertListsEqualAsSets_, assertListsEqualAsSetsVerbose_,
  gassertListsEqualAsSets_, gassertListsEqualAsSetsVerbose_,
  assertNotEmpty_, assertNotEmptyVerbose_,
  gassertNotEmpty_, gassertNotEmptyVerbose_,
  assertEmpty_, assertEmptyVerbose_,
  gassertEmpty_, gassertEmptyVerbose_,
  assertElem_, assertElemVerbose_,
  gassertElem_, gassertElemVerbose_,

  -- * Assertions for exceptions
  assertThrows_, assertThrowsVerbose_,
  assertThrowsSome_, assertThrowsSomeVerbose_,
  assertThrowsIO_, assertThrowsIOVerbose_,
  assertThrowsSomeIO_, assertThrowsSomeIOVerbose_,
  assertThrowsM_, assertThrowsMVerbose_,
  assertThrowsSomeM_, assertThrowsSomeMVerbose_,

  -- * Assertions on Either values
  assertLeft_, assertLeftVerbose_,
  gassertLeft_, gassertLeftVerbose_,
  assertLeftNoShow_, assertLeftNoShowVerbose_,
  gassertLeftNoShow_, gassertLeftNoShowVerbose_,
  assertRight_, assertRightVerbose_,
  gassertRight_, gassertRightVerbose_,
  assertRightNoShow_, assertRightNoShowVerbose_,
  gassertRightNoShow_, gassertRightNoShowVerbose_,

  -- * Assertions on Just values
  assertJust_, assertJustVerbose_,
  gassertJust_, gassertJustVerbose_,
  assertNothing_, assertNothingVerbose_,
  gassertNothing_, gassertNothingVerbose_,
  assertNothingNoShow_, assertNothingNoShowVerbose_,
  gassertNothingNoShow_, gassertNothingNoShowVerbose_,

  -- * General failure
  assertFailure_,
  gassertFailure_,

  -- * Pending unit tests
  unitTestPending, unitTestPending',

  -- * Sub assertions
  subAssert_, subAssertVerbose_,
  gsubAssert_, gsubAssertVerbose_,

  -- * HUnit re-exports
  HU.HUnitFailure

) where

import Control.Exception
import qualified Control.Exception.Lifted as ExL
import Control.Monad.Trans.Control
import Control.Monad.Trans
import qualified Test.HUnit.Lang as HU

import Data.List ( (\\) )
import System.IO.Unsafe (unsafePerformIO)

import Test.Framework.TestInterface
import Test.Framework.Location
import Test.Framework.Diff
import Test.Framework.Colors
import Test.Framework.Pretty
import Test.Framework.AssertM
import Test.Framework.PrettyHaskell

-- WARNING: do not forget to add a preprocessor macro for new assertions!!

{- |
Fail with the given reason, supplying the error location and the error message.
-}
gassertFailure_ :: AssertM m => Location -> String -> m a
gassertFailure_ loc s =
    genericAssertFailure__ loc (mkMsg "assertFailure" ""
                                ("failed at " ++ showLoc loc ++ ": " ++ s))

-- | Specialization of 'gassertFailure'.
assertFailure_ :: Location -> String -> IO a
assertFailure_ = gassertFailure_

{- |
Signals that the current unit test is pending.
-}
unitTestPending :: String -> IO a
unitTestPending s =
    failHTF (FullTestResult Nothing [] (Just $ noColor s) (Just Pending))

{- |
Use @unitTestPending' msg test@ to mark the given test as pending
without removing it from the test suite and without deleting or commenting out the test code.
-}
unitTestPending' :: String -> IO a -> IO a
unitTestPending' msg _ = unitTestPending msg

mkMsg :: String -> String -> String -> ColorString
mkMsg s1 s2 s3 = mkColorMsg s1 s2 (noColor s3)

mkColorMsg :: String -> String -> ColorString -> ColorString
mkColorMsg fun extraInfo s =
    let pref = if null extraInfo
               then fun ++ " "
               else fun ++ " (" ++ extraInfo ++ ") "
    in noColor pref +++ s

--
-- Dirty macro hackery (I'm too lazy ...)
--
#define CreateAssertionsGenericNoGVariant(__name__, __ctx__, __type__, __ret__) \
__name__##Verbose_ :: __ctx__ Location -> String -> __type__ -> __ret__; \
__name__##Verbose_ = _##__name__##_ (#__name__ ++ "Verbose"); \
__name__##_ :: __ctx__ Location -> __type__ -> __ret__; \
__name__##_ loc = _##__name__##_ #__name__ loc ""
#define CreateAssertionsGeneric(__name__, __ctx__, __ctx2__, __type__, __ret__) \
g##__name__##Verbose_ :: __ctx2__ Location -> String -> __type__ -> m __ret__; \
g##__name__##Verbose_ = _##__name__##_ (#__name__ ++ "Verbose"); \
g##__name__##_ :: __ctx2__ Location -> __type__ -> m __ret__; \
g##__name__##_ loc = _##__name__##_ #__name__ loc ""; \
CreateAssertionsGenericNoGVariant(__name__, __ctx__, __type__, IO __ret__)

#define CreateAssertionsCtx(__name__, __ctx__, __ctx2__, __type__) \
CreateAssertionsGeneric(__name__, __ctx__ =>, __ctx2__ =>, __type__, ())
#define CreateAssertionsCtxNoGVariant(__name__, __ctx__, __type__) \
CreateAssertionsGenericNoGVariant(__name__, __ctx__ =>, __type__, IO ())

#define CreateAssertions(__name__, __type__) \
CreateAssertionsGeneric(__name__, , AssertM m =>, __type__, ())
#define CreateAssertionsNoGVariant(__name__, __type__) \
CreateAssertionsGenericNoGVariant(__name__, , __type__, IO ())

#define CreateAssertionsCtxRet(__name__, __ctx__, __ctx2__, __type__, __ret__) \
CreateAssertionsGeneric(__name__, __ctx__ =>, __ctx2__ =>, __type__, __ret__)
#define CreateAssertionsCtxRetNoGVariant(__name__, __ctx__, __type__, __ret__) \
CreateAssertionsGenericNoGVariant(__name__, __ctx__ =>, __type__, IO __ret__)

#define CreateAssertionsRet(__name__, __type__, __ret__) \
CreateAssertionsGeneric(__name__, , AssertM m =>, __type__, __ret__)
#define CreateAssertionsRetNoGVariant(__name__, __type__, __ret__) \
CreateAssertionsGenericNoGVariant(__name__, , __type__, IO __ret__)

#define DocAssertion(__name__, __text__) \
  {- | __text__ The 'String' parameter in the @Verbose@ \
      variants can be used to provide extra information about the error. The \
      variants @g##__name__@ and @g##__name__##Verbose@ are generic assertions: \
      they run in the IO monad and can be evaluated to a 'Bool' value. \
      Do not use the \
      @__name__##_@, @__name__##Verbose_@, @g##__name__##_@, and @g##__name__##Verbose_@ \
      functions directly, use the macros @__name__@, @__name__##Verbose@, @g##__name__@, and \
      @g##__name__##Verbose@ instead. These macros, provided by the @htfpp@ preprocessor, \
      insert the 'Location' parameter automatically. -}
#define DocAssertionNoGVariant(__name__, __text__) \
  {- | __text__ The 'String' parameter in the @Verbose@ \
      variant can be used to provide extra information about the error. \
      Do not use the \
      @__name__##_@ and @__name__##Verbose_@ \
      functions directly, use the macros @__name__@ and @__name__##Verbose@ \
      instead. These macros, provided by the @htfpp@ preprocessor, \
      insert the 'Location' parameter automatically. -}
--
-- Boolean Assertions
--

_assertBool_ :: AssertM m => String -> Location -> String -> Bool -> m ()
_assertBool_ name loc s False =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertBool_ _ _ _   True = return ()

DocAssertion(assertBool, Fail if the 'Bool' value is 'False'.)
CreateAssertions(assertBool, Bool)

--
-- Equality Assertions
--

equalityFailedMessage :: String -> String -> ColorString
equalityFailedMessage exp act =
    let !diff = unsafePerformIO (diffWithSensibleConfig expP actP)
        expected_ = colorize firstDiffColor "* expected:"
        but_got_ = colorize secondDiffColor "* but got:"
        diff_ = colorize diffColor "* diff:"
    in ("\n" +++ expected_ +++ " " +++ noColor (withNewline expP) +++
        "\n" +++ but_got_ +++ "  " +++ noColor (withNewline actP) +++
        "\n" +++ diff_ +++ "     " +++ newlineBeforeDiff diff +++ diff +++
        (if stringEq
         then "\nWARNING: strings are equal but actual values differ!"
         else ""))
    where
      withNewline s =
          case lines s of
            [] -> s
            [_] -> s
            _ -> '\n':s
      newlineBeforeDiff d =
          let f b = case colorStringFind (\c -> c == '\n') d b of
                      Just _ -> "\n"
                      Nothing -> ""
          in noColor' (f True) (f False)
      (expP, actP, stringEq) =
          case (prettyHaskell' exp, prettyHaskell' act) of
            (Nothing, _) -> (exp, act, exp == act)
            (_, Nothing) -> (exp, act, exp == act)
            (Just expP, Just actP)
                | expP == actP ->
                    if exp /= act
                       then (exp, act, exp == act)
                       else (expP, actP, True)
                | otherwise -> (expP, actP, False)

notEqualityFailedMessage :: String -> String
notEqualityFailedMessage exp =
    (": Objects are equal\n" ++ prettyHaskell exp)

_assertEqual_ :: (Eq a, Show a, AssertM m)
                 => String -> Location -> String -> a -> a -> m ()
_assertEqual_ name loc s expected actual =
    if expected /= actual
       then do let x = equalityFailedMessage (show expected) (show actual)
               genericAssertFailure__ loc (mkColorMsg name s $
                                           noColor ("failed at " ++ showLoc loc) +++ x)
       else return ()

DocAssertion(assertEqual, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'.)
CreateAssertionsCtx(assertEqual, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> a)

_assertNotEqual_ :: (Eq a, Show a, AssertM m)
                 => String -> Location -> String -> a -> a -> m ()
_assertNotEqual_ name loc s expected actual =
    if expected == actual
       then do let x = notEqualityFailedMessage (show expected)
               genericAssertFailure__ loc (mkMsg name s $ "failed at " ++ showLoc loc ++ x)
       else return ()

DocAssertion(assertNotEqual, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'.)
CreateAssertionsCtx(assertNotEqual, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> a)

_assertEqualPretty_ :: (Eq a, Pretty a, AssertM m)
                       => String -> Location -> String -> a -> a -> m ()
_assertEqualPretty_ name loc s expected actual =
    if expected /= actual
       then do let x = equalityFailedMessage (showPretty expected) (showPretty actual)
               genericAssertFailure__ loc (mkColorMsg name s
                                           (noColor ("failed at " ++ showLoc loc) +++ x))
       else return ()

DocAssertion(assertEqualPretty, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'.)
CreateAssertionsCtx(assertEqualPretty, (Eq a, Pretty a), (Eq a, Pretty a, AssertM m), a -> a)

_assertNotEqualPretty_ :: (Eq a, Pretty a, AssertM m)
                       => String -> Location -> String -> a -> a -> m ()
_assertNotEqualPretty_ name loc s expected actual =
    if expected == actual
       then do let x = notEqualityFailedMessage (showPretty expected)
               genericAssertFailure__ loc (mkMsg name s $ "failed at " ++ showLoc loc ++ x)
       else return ()
DocAssertion(assertNotEqualPretty, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'.)
CreateAssertionsCtx(assertNotEqualPretty, (Eq a, Pretty a), (Eq a, Pretty a, AssertM m), a -> a)

_assertEqualNoShow_ :: (Eq a, AssertM m)
                    => String -> Location -> String -> a -> a -> m ()
_assertEqualNoShow_ name loc s expected actual =
    if expected /= actual
    then genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
    else return ()
DocAssertion(assertEqualNoShow, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful.)
CreateAssertionsCtx(assertEqualNoShow, Eq a, (Eq a, AssertM m), a -> a)

_assertNotEqualNoShow_ :: (Eq a, AssertM m)
                    => String -> Location -> String -> a -> a -> m ()
_assertNotEqualNoShow_ name loc s expected actual =
    if expected == actual
       then genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
       else return ()
DocAssertion(assertNotEqualNoShow, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful.)
CreateAssertionsCtx(assertNotEqualNoShow, Eq a, (Eq a, AssertM m), a -> a)

--
-- Assertions on Lists
--

_assertListsEqualAsSets_ :: (Eq a, Show a, AssertM m)
                   => String -> Location -> String -> [a] -> [a] -> m ()
_assertListsEqualAsSets_ name loc s expected actual =
    let ne = length expected
        na = length actual
        in case () of
            _| ne /= na ->
                 do let x = equalityFailedMessage (show expected) (show actual)
                    genericAssertFailure__ loc (mkColorMsg name s
                                                (noColor
                                                 ("failed at " ++ showLoc loc
                                                  ++ "\n expected length: " ++ show ne
                                                  ++ "\n actual length: " ++ show na) +++
                                                  (if maxLength x < 5000
                                                   then x else emptyColorString)))
             | not (unorderedEq expected actual) ->
                 do let x = equalityFailedMessage (show expected) (show actual)
                    genericAssertFailure__ loc (mkColorMsg "assertSetEqual" s
                                                (noColor ("failed at " ++ showLoc loc) +++ x))
             | otherwise -> return ()
    where unorderedEq l1 l2 =
              null (l1 \\ l2) && null (l2 \\ l1)
DocAssertion(assertListsEqualAsSets, Fail if the two given lists are not equal
                                     when considered as sets. The first list parameter
                                     denotes the expected value.)
CreateAssertionsCtx(assertListsEqualAsSets, (Eq a, Show a), (Eq a, Show a, AssertM m), [a] -> [a])

_assertNotEmpty_ :: AssertM m => String -> Location -> String -> [a] -> m ()
_assertNotEmpty_ name loc s [] =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertNotEmpty_ _ _ _ (_:_) = return ()
DocAssertion(assertNotEmpty, Fail if the given list is empty.)
CreateAssertions(assertNotEmpty, [a])

_assertEmpty_ :: AssertM m => String -> Location -> String -> [a] -> m ()
_assertEmpty_ name loc s (_:_) =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertEmpty_ _ _ _ [] = return ()
DocAssertion(assertEmpty, Fail if the given list is a non-empty list.)
CreateAssertions(assertEmpty, [a])

_assertElem_ :: (Eq a, Show a, AssertM m) => String -> Location -> String -> a -> [a] -> m ()
_assertElem_ name loc s x l =
    if x `elem` l
    then return ()
    else genericAssertFailure__ loc (mkMsg name s
                                     ("failed at " ++ showLoc loc ++
                                      "\n element: " ++ show x ++
                                      "\n list:   " ++ show l))
DocAssertion(assertElem, Fail if the given element is not in the list.)
CreateAssertionsCtx(assertElem, (Eq a, Show a), (Eq a, Show a, AssertM m), a -> [a])

--
-- Assertions for Exceptions
--

_assertThrowsIO_ :: Exception e
                 => String -> Location -> String -> IO a -> (e -> Bool) -> IO ()
_assertThrowsIO_ name loc s x f =
    _assertThrowsM_ name loc s x f
DocAssertionNoGVariant(assertThrowsIO, Fail if executing the 'IO' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@.)
CreateAssertionsCtxNoGVariant(assertThrowsIO, Exception e, IO a -> (e -> Bool))

_assertThrowsSomeIO_ :: String -> Location -> String -> IO a -> IO ()
_assertThrowsSomeIO_ name loc s x = _assertThrowsIO_ name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant(assertThrowsSomeIO, Fail if executing the 'IO' action does not
                       throw an exception.)
CreateAssertionsNoGVariant(assertThrowsSomeIO, IO a)

_assertThrowsM_ :: (MonadBaseControl IO m, MonadIO m, Exception e)
                => String -> Location -> String -> m a -> (e -> Bool) -> m ()
_assertThrowsM_ name loc s x f =
    do res <- ExL.try x
       case res of
         Right _ -> liftIO $
                    genericAssertFailure__ loc (mkMsg name s
                                                ("failed at " ++ showLoc loc ++
                                                 ": no exception was thrown"))
         Left e -> if f e then return ()
                   else liftIO $
                        genericAssertFailure__ loc (mkMsg name s
                                                    ("failed at " ++
                                                     showLoc loc ++
                                                     ": wrong exception was thrown: " ++
                                                     show e))
DocAssertionNoGVariant(assertThrowsM, Fail if executing the 'm' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@.)
CreateAssertionsGenericNoGVariant(assertThrowsM, (MonadBaseControl IO m, MonadIO m, Exception e) =>,
                                  m a -> (e -> Bool), m ())

_assertThrowsSomeM_ :: (MonadBaseControl IO m, MonadIO m)
                    => String -> Location -> String -> m a -> m ()
_assertThrowsSomeM_ name loc s x = _assertThrowsM_ name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant(assertThrowsSomeM, Fail if executing the 'm' action does not
                       throw an exception.)
CreateAssertionsGenericNoGVariant(assertThrowsSomeM, (MonadBaseControl IO m, MonadIO m) =>, m a, m ())

_assertThrows_ :: Exception e
               => String -> Location -> String -> a -> (e -> Bool) -> IO ()
_assertThrows_ name loc s x f = _assertThrowsIO_ name loc s (evaluate x) f
DocAssertionNoGVariant(assertThrows, Fail if evaluating the expression of type @a@ does not
                       throw an exception satisfying the given predicate @(e -> Bool)@.)
CreateAssertionsCtxNoGVariant(assertThrows, Exception e, a -> (e -> Bool))

_assertThrowsSome_ :: String -> Location -> String -> a -> IO ()
_assertThrowsSome_ name loc s x =
    _assertThrows_ name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant(assertThrowsSome, Fail if evaluating the expression of type @a@ does not
                       throw an exception.)
CreateAssertionsNoGVariant(assertThrowsSome, a)

--
-- Assertions on Either
--

_assertLeft_ :: forall a b m . (AssertM m, Show b)
             => String -> Location -> String -> Either a b -> m a
_assertLeft_ _ _ _ (Left x) = return x
_assertLeft_ name loc s (Right x) =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected a Left value, given " ++
                                 show (Right x :: Either b b)))
DocAssertion(assertLeft, Fail if the given @Either a b@ value is a 'Right'.
             Use this function if @b@ is an instance of 'Show')
CreateAssertionsCtxRet(assertLeft, Show b, (Show b, AssertM m), Either a b, a)

_assertLeftNoShow_ :: AssertM m => String -> Location -> String -> Either a b -> m a
_assertLeftNoShow_ _ _ _ (Left x) = return x
_assertLeftNoShow_ name loc s (Right _) =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected a Left value, given a Right value"))
DocAssertion(assertLeftNoShow, Fail if the given @Either a b@ value is a 'Right'.)
CreateAssertionsRet(assertLeftNoShow, Either a b, a)

_assertRight_ :: forall a b m . (Show a, AssertM m)
              => String -> Location -> String -> Either a b -> m b
_assertRight_ _ _ _ (Right x) = return x
_assertRight_ name loc s (Left x) =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected a Right value, given " ++
                                 show (Left x :: Either a a)))
DocAssertion(assertRight, Fail if the given @Either a b@ value is a 'Left'.
             Use this function if @a@ is an instance of 'Show')
CreateAssertionsCtxRet(assertRight, Show a, (Show a, AssertM m), Either a b, b)

_assertRightNoShow_ :: AssertM m => String -> Location -> String -> Either a b -> m b
_assertRightNoShow_ _ _ _ (Right x) = return x
_assertRightNoShow_ name loc s (Left _) =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected a Right value, given a Left value"))
DocAssertion(assertRightNoShow, Fail if the given @Either a b@ value is a 'Left'.)
CreateAssertionsRet(assertRightNoShow, Either a b, b)

--
-- Assertions on Maybe
--

_assertJust_ :: AssertM m => String -> Location -> String -> Maybe a -> m a
_assertJust_ _ _ _ (Just x) = return x
_assertJust_ name loc s Nothing =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected a Just value, given Nothing"))
DocAssertion(assertJust, Fail is the given @Maybe a@ value is a 'Nothing'.)
CreateAssertionsRet(assertJust, Maybe a, a)

_assertNothing_ :: (Show a, AssertM m)
                => String -> Location -> String -> Maybe a -> m ()
_assertNothing_ _ _ _ Nothing = return ()
_assertNothing_ name loc s jx =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected Nothing, given " ++ show jx))
DocAssertion(assertNothing, Fail is the given @Maybe a@ value is a 'Just'.
             Use this function if @a@ is an instance of 'Show'.)
CreateAssertionsCtx(assertNothing, Show a, (Show a, AssertM m), Maybe a)

_assertNothingNoShow_ :: AssertM m => String -> Location -> String -> Maybe a -> m ()
_assertNothingNoShow_ _ _ _ Nothing = return ()
_assertNothingNoShow_ name loc s _ =
    genericAssertFailure__ loc (mkMsg name s
                                ("failed at " ++ showLoc loc ++
                                 ": expected Nothing, given a Just value"))
DocAssertion(assertNothingNoShow, Fail is the given @Maybe a@ value is a 'Just'.)
CreateAssertions(assertNothingNoShow, Maybe a)

--
-- Sub assertions
--

-- | Sub assertions are a poor man's way of abstracting over assertions while still propagating location
-- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write
--
-- > assertIsPositive :: Int -> Assertion
-- > assertIsPositive n = assertBool (n > 0)
--
-- You can now use @assertIsPositive i@ for some integer @i@ from your unit tests, but if you call it directly
-- you will lose location information: if @assertIsPositive i@ fails you will only get the location where
-- @assertIsPositive@ is defined but not from where it has been called.
--
-- To recover the location information you simply use @subAssert (assertIsPositive i)@.
-- In this case, if @i@ is not positive, you will get the location of the caller.
--
-- /Note:/ Don't use subAssert_ directly but use the preprocessor macro @subAssert@.
subAssert_ :: MonadBaseControl IO m => Location -> m a -> m a
subAssert_ loc ass = subAssertHTF loc Nothing ass

-- | Generic variant of 'subAssert_'.
gsubAssert_ :: AssertM m => Location -> m a -> m a
gsubAssert_ loc ass = genericSubAssert loc Nothing ass

-- | Same as 'subAssert_' but with an additional error message.
subAssertVerbose_ :: MonadBaseControl IO m => Location -> String -> m a -> m a
subAssertVerbose_ loc msg ass = subAssertHTF loc (Just msg) ass

-- | Generic variant of 'subAssertVerbose_'.
gsubAssertVerbose_ :: AssertM m => Location -> String -> m a -> m a
gsubAssertVerbose_ loc msg ass = genericSubAssert loc (Just msg) ass
</pre></br><h2>printed</h2></br><pre>{-# OPTIONS_GHC -cpp -pgmPcpphs -optP --layout -optP --hashes -optP --cpp #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}

--
-- Copyright (c) 2005, 2009, 2012  Stefan Wehr - http://www.stefanwehr.de
--
-- This library is free software; you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation; either
-- version 2.1 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
--

{-|

This module provides assert-like functions for writing unit tests.

/Hint:/ Do not use the @assertXXX_@ functions
directly. Instead, for each function @assertXXX_@,
there exist a preprocessor macro @assertXXX@, which provides
the "Location" parameter automatically. Use these macros, which
are available automatically if you add

@&#x7b;-&#x23; OPTIONS_GHC -F -pgmF htfpp &#x23;-&#x7d;@

at the top of your source file (see the 'Test.Framework.Tutorial').

-}

module Test.Framework.HUnitWrapper (

  -- * Assertions on Bool values
  assertBool_, assertBoolVerbose_,
  gassertBool_, gassertBoolVerbose_,

  -- * Equality assertions
  assertEqual_, assertEqualVerbose_,
  gassertEqual_, gassertEqualVerbose_,
  assertEqualPretty_, assertEqualPrettyVerbose_,
  gassertEqualPretty_, gassertEqualPrettyVerbose_,
  assertEqualNoShow_, assertEqualNoShowVerbose_,
  gassertEqualNoShow_, gassertEqualNoShowVerbose_,
  assertNotEqual_, assertNotEqualVerbose_,
  gassertNotEqual_, gassertNotEqualVerbose_,
  assertNotEqualPretty_, assertNotEqualPrettyVerbose_,
  gassertNotEqualPretty_, gassertNotEqualPrettyVerbose_,
  assertNotEqualNoShow_, assertNotEqualNoShowVerbose_,
  gassertNotEqualNoShow_, gassertNotEqualNoShowVerbose_,

  -- * Assertions on lists
  assertListsEqualAsSets_, assertListsEqualAsSetsVerbose_,
  gassertListsEqualAsSets_, gassertListsEqualAsSetsVerbose_,
  assertNotEmpty_, assertNotEmptyVerbose_,
  gassertNotEmpty_, gassertNotEmptyVerbose_,
  assertEmpty_, assertEmptyVerbose_,
  gassertEmpty_, gassertEmptyVerbose_,
  assertElem_, assertElemVerbose_,
  gassertElem_, gassertElemVerbose_,

  -- * Assertions for exceptions
  assertThrows_, assertThrowsVerbose_,
  assertThrowsSome_, assertThrowsSomeVerbose_,
  assertThrowsIO_, assertThrowsIOVerbose_,
  assertThrowsSomeIO_, assertThrowsSomeIOVerbose_,
  assertThrowsM_, assertThrowsMVerbose_,
  assertThrowsSomeM_, assertThrowsSomeMVerbose_,

  -- * Assertions on Either values
  assertLeft_, assertLeftVerbose_,
  gassertLeft_, gassertLeftVerbose_,
  assertLeftNoShow_, assertLeftNoShowVerbose_,
  gassertLeftNoShow_, gassertLeftNoShowVerbose_,
  assertRight_, assertRightVerbose_,
  gassertRight_, gassertRightVerbose_,
  assertRightNoShow_, assertRightNoShowVerbose_,
  gassertRightNoShow_, gassertRightNoShowVerbose_,

  -- * Assertions on Just values
  assertJust_, assertJustVerbose_,
  gassertJust_, gassertJustVerbose_,
  assertNothing_, assertNothingVerbose_,
  gassertNothing_, gassertNothingVerbose_,
  assertNothingNoShow_, assertNothingNoShowVerbose_,
  gassertNothingNoShow_, gassertNothingNoShowVerbose_,

  -- * General failure
  assertFailure_,
  gassertFailure_,

  -- * Pending unit tests
  unitTestPending, unitTestPending',

  -- * Sub assertions
  subAssert_, subAssertVerbose_,
  gsubAssert_, gsubAssertVerbose_,

  -- * HUnit re-exports
  HU.HUnitFailure

) where

import Control.Exception
import qualified Control.Exception.Lifted as ExL
import Control.Monad.Trans.Control
import Control.Monad.Trans
import qualified Test.HUnit.Lang as HU

import Data.List ( (\\) )
import System.IO.Unsafe (unsafePerformIO)

import Test.Framework.TestInterface
import Test.Framework.Location
import Test.Framework.Diff
import Test.Framework.Colors
import Test.Framework.Pretty
import Test.Framework.AssertM
import Test.Framework.PrettyHaskell

-- WARNING: do not forget to add a preprocessor macro for new assertions!!

{- |
Fail with the given reason, supplying the error location and the error message.
-}
gassertFailure_ :: AssertM m => Location -> String -> m a
gassertFailure_ loc s =
    genericAssertFailure__ loc (mkMsg "assertFailure" ""
                                ("failed at " ++ showLoc loc ++ ": " ++ s))

-- | Specialization of 'gassertFailure'.
assertFailure_ :: Location -> String -> IO a
assertFailure_ = gassertFailure_

{- |
Signals that the current unit test is pending.
-}
unitTestPending :: String -> IO a
unitTestPending s =
    failHTF (FullTestResult Nothing [] (Just $ noColor s) (Just Pending))

{- |
Use @unitTestPending' msg test@ to mark the given test as pending
without removing it from the test suite and without deleting or commenting out the test code.
-}
unitTestPending' :: String -> IO a -> IO a
unitTestPending' msg _ = unitTestPending msg

mkMsg :: String -> String -> String -> ColorString
mkMsg s1 s2 s3 = mkColorMsg s1 s2 (noColor s3)

mkColorMsg :: String -> String -> ColorString -> ColorString
mkColorMsg fun extraInfo s =
    let pref = if null extraInfo
               then fun ++ " "
               else fun ++ " (" ++ extraInfo ++ ") "
    in noColor pref +++ s

--
-- Dirty macro hackery (I'm too lazy ...)
--
#define CreateAssertionsGenericNoGVariant(__name__, __ctx__, __type__, __ret__) \
__name__##Verbose_ :: __ctx__ Location -> String -> __type__ -> __ret__; \
__name__##Verbose_ = _##__name__##_ (#__name__ ++ "Verbose"); \
__name__##_ :: __ctx__ Location -> __type__ -> __ret__; \
__name__##_ loc = _##__name__##_ #__name__ loc ""
#define CreateAssertionsGeneric(__name__, __ctx__, __ctx2__, __type__, __ret__) \
g##__name__##Verbose_ :: __ctx2__ Location -> String -> __type__ -> m __ret__; \
g##__name__##Verbose_ = _##__name__##_ (#__name__ ++ "Verbose"); \
g##__name__##_ :: __ctx2__ Location -> __type__ -> m __ret__; \
g##__name__##_ loc = _##__name__##_ #__name__ loc ""; \
CreateAssertionsGenericNoGVariant(__name__, __ctx__, __type__, IO __ret__)

#define CreateAssertionsCtx(__name__, __ctx__, __ctx2__, __type__) \
CreateAssertionsGeneric(__name__, __ctx__ =>, __ctx2__ =>, __type__, ())
#define CreateAssertionsCtxNoGVariant(__name__, __ctx__, __type__) \
CreateAssertionsGenericNoGVariant(__name__, __ctx__ =>, __type__, IO ())

#define CreateAssertions(__name__, __type__) \
CreateAssertionsGeneric(__name__, , AssertM m =>, __type__, ())
#define CreateAssertionsNoGVariant(__name__, __type__) \
CreateAssertionsGenericNoGVariant(__name__, , __type__, IO ())

#define CreateAssertionsCtxRet(__name__, __ctx__, __ctx2__, __type__, __ret__) \
CreateAssertionsGeneric(__name__, __ctx__ =>, __ctx2__ =>, __type__, __ret__)
#define CreateAssertionsCtxRetNoGVariant(__name__, __ctx__, __type__, __ret__) \
CreateAssertionsGenericNoGVariant(__name__, __ctx__ =>, __type__, IO __ret__)

#define CreateAssertionsRet(__name__, __type__, __ret__) \
CreateAssertionsGeneric(__name__, , AssertM m =>, __type__, __ret__)
#define CreateAssertionsRetNoGVariant(__name__, __type__, __ret__) \
CreateAssertionsGenericNoGVariant(__name__, , __type__, IO __ret__)

#define DocAssertion(__name__, __text__) \
  {- | __text__ The 'String' parameter in the @Verbose@ \
      variants can be used to provide extra information about the error. The \
      variants @g##__name__@ and @g##__name__##Verbose@ are generic assertions: \
      they run in the IO monad and can be evaluated to a 'Bool' value. \
      Do not use the \
      @__name__##_@, @__name__##Verbose_@, @g##__name__##_@, and @g##__name__##Verbose_@ \
      functions directly, use the macros @__name__@, @__name__##Verbose@, @g##__name__@, and \
      @g##__name__##Verbose@ instead. These macros, provided by the @htfpp@ preprocessor, \
      insert the 'Location' parameter automatically. -}
#define DocAssertionNoGVariant(__name__, __text__) \
  {- | __text__ The 'String' parameter in the @Verbose@ \
      variant can be used to provide extra information about the error. \
      Do not use the \
      @__name__##_@ and @__name__##Verbose_@ \
      functions directly, use the macros @__name__@ and @__name__##Verbose@ \
      instead. These macros, provided by the @htfpp@ preprocessor, \
      insert the 'Location' parameter automatically. -}
--
-- Boolean Assertions
--

_assertBool_ :: AssertM m => String -> Location -> String -> Bool -> m ()
_assertBool_ name loc s False =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertBool_ _ _ _   True = return ()

DocAssertion{- | Fail if the 'Bool' value is 'False'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertBool@ and @gassertBoolVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertBool_@, @assertBoolVerbose_@, @gassertBool_@, and @gassertBoolVerbose_@       functions directly, use the macros @assertBool@, @assertBoolVerbose@, @gassertBool@, and       @gassertBoolVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertBool, Fail if the 'Bool' value is 'False'.)
gassertBoolVerbose_CreateAssertions(assertBool:: AssertM, Bool =>)  Location -> String -> Bool -> m (); gassertBoolVerbose_ = _assertBool_ ("assertBool" ++ "Verbose"); gassertBool_ :: AssertM m => Location -> Bool -> m (); gassertBool_ loc = _assertBool_ "assertBool" loc ""; assertBoolVerbose_ ::  Location -> String -> Bool -> IO (); assertBoolVerbose_ = _assertBool_ ("assertBool" ++ "Verbose"); assertBool_ ::  Location -> Bool -> IO (); assertBool_ loc = _assertBool_ "assertBool" loc ""

--
-- Equality Assertions
--

equalityFailedMessage :: String -> String -> ColorString
equalityFailedMessage exp act =
    let !diff = unsafePerformIO (diffWithSensibleConfig expP actP)
        expected_ = colorize firstDiffColor "* expected:"
        but_got_ = colorize secondDiffColor "* but got:"
        diff_ = colorize diffColor "* diff:"
    in ("\n" +++ expected_ +++ " " +++ noColor (withNewline expP) +++
        "\n" +++ but_got_ +++ "  " +++ noColor (withNewline actP) +++
        "\n" +++ diff_ +++ "     " +++ newlineBeforeDiff diff +++ diff +++
        (if stringEq
         then "\nWARNING: strings are equal but actual values differ!"
         else ""))
    where
      withNewline s =
          case lines s of
            [] -> s
            [_] -> s
            _ -> '\n':s
      newlineBeforeDiff d =
          let f b = case colorStringFind (\c -> c == '\n') d b of
                      Just _ -> "\n"
                      Nothing -> ""
          in noColor' (f True) (f False)
      (expP, actP, stringEq) =
          case (prettyHaskell' exp, prettyHaskell' act) of
            (Nothing, _) -> (exp, act, exp == act)
            (_, Nothing) -> (exp, act, exp == act)
            (Just expP, Just actP)
                | expP == actP ->
                    if exp /= act
                       then (exp, act, exp == act)
                       else (expP, actP, True)
                | otherwise -> (expP, actP, False)

notEqualityFailedMessage :: String -> String
notEqualityFailedMessage exp =
    (": Objects are equal\n" ++ prettyHaskell exp)

_assertEqual_ :: (Eq a, Show a, AssertM m)
                 => String -> Location -> String -> a -> a -> m ()
_assertEqual_ name loc s expected actual =
    if expected /= actual
       then do let x = equalityFailedMessage (show expected) (show actual)
               genericAssertFailure__ loc (mkColorMsg name s $
                                           noColor ("failed at " ++ showLoc loc) +++ x)
       else return ()

DocAssertion{- | Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqual@ and @gassertEqualVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqual_@, @assertEqualVerbose_@, @gassertEqual_@, and @gassertEqualVerbose_@       functions directly, use the macros @assertEqual@, @assertEqualVerbose@, @gassertEqual@, and       @gassertEqualVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqual, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'.)
gassertEqualVerbose_CreateAssertionsCtx(assertEqual:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->aa->)  m (); gassertEqualVerbose_ = _assertEqual_ ("assertEqual" ++ "Verbose"); gassertEqual_ :: (Eq a, Show a, AssertM m) => Location -> a -> a -> m (); gassertEqual_ loc = _assertEqual_ "assertEqual" loc ""; assertEqualVerbose_ :: (Eq a, Show a) => Location -> String -> a -> a -> IO (); assertEqualVerbose_ = _assertEqual_ ("assertEqual" ++ "Verbose"); assertEqual_ :: (Eq a, Show a) => Location -> a -> a -> IO (); assertEqual_ loc = _assertEqual_ "assertEqual" loc ""

_assertNotEqual_ :: (Eq a, Show a, AssertM m)
                 => String -> Location -> String -> a -> a -> m ()
_assertNotEqual_ name loc s expected actual =
    if expected == actual
       then do let x = notEqualityFailedMessage (show expected)
               genericAssertFailure__ loc (mkMsg name s $ "failed at " ++ showLoc loc ++ x)
       else return ()

DocAssertion{- | Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqual@ and @gassertNotEqualVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqual_@, @assertNotEqualVerbose_@, @gassertNotEqual_@, and @gassertNotEqualVerbose_@       functions directly, use the macros @assertNotEqual@, @assertNotEqualVerbose@, @gassertNotEqual@, and       @gassertNotEqualVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqual, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Show' but not of 'Pretty'.)
gassertNotEqualVerbose_CreateAssertionsCtx(assertNotEqual:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->aa->)  m (); gassertNotEqualVerbose_ = _assertNotEqual_ ("assertNotEqual" ++ "Verbose"); gassertNotEqual_ :: (Eq a, Show a, AssertM m) => Location -> a -> a -> m (); gassertNotEqual_ loc = _assertNotEqual_ "assertNotEqual" loc ""; assertNotEqualVerbose_ :: (Eq a, Show a) => Location -> String -> a -> a -> IO (); assertNotEqualVerbose_ = _assertNotEqual_ ("assertNotEqual" ++ "Verbose"); assertNotEqual_ :: (Eq a, Show a) => Location -> a -> a -> IO (); assertNotEqual_ loc = _assertNotEqual_ "assertNotEqual" loc ""

_assertEqualPretty_ :: (Eq a, Pretty a, AssertM m)
                       => String -> Location -> String -> a -> a -> m ()
_assertEqualPretty_ name loc s expected actual =
    if expected /= actual
       then do let x = equalityFailedMessage (showPretty expected) (showPretty actual)
               genericAssertFailure__ loc (mkColorMsg name s
                                           (noColor ("failed at " ++ showLoc loc) +++ x))
       else return ()

DocAssertion{- | Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqualPretty@ and @gassertEqualPrettyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqualPretty_@, @assertEqualPrettyVerbose_@, @gassertEqualPretty_@, and @gassertEqualPrettyVerbose_@       functions directly, use the macros @assertEqualPretty@, @assertEqualPrettyVerbose@, @gassertEqualPretty@, and       @gassertEqualPrettyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqualPretty, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'.)
gassertEqualPrettyVerbose_CreateAssertionsCtx(assertEqualPretty:: (Eq a, Pretty, (Eq aa,Prettya)m)(=> Locationa, Pretty->a,StringAssertM->ma,->a a->->a)m (); gassertEqualPrettyVerbose_ = _assertEqualPretty_ ("assertEqualPretty" ++ "Verbose"); gassertEqualPretty_ :: (Eq a, Pretty a, AssertM m) => Location -> a -> a -> m (); gassertEqualPretty_ loc = _assertEqualPretty_ "assertEqualPretty" loc ""; assertEqualPrettyVerbose_ :: (Eq a, Pretty a) => Location -> String -> a -> a -> IO (); assertEqualPrettyVerbose_ = _assertEqualPretty_ ("assertEqualPretty" ++ "Verbose"); assertEqualPretty_ :: (Eq a, Pretty a) => Location -> a -> a -> IO (); assertEqualPretty_ loc = _assertEqualPretty_ "assertEqualPretty" loc ""

_assertNotEqualPretty_ :: (Eq a, Pretty a, AssertM m)
                       => String -> Location -> String -> a -> a -> m ()
_assertNotEqualPretty_ name loc s expected actual =
    if expected == actual
       then do let x = notEqualityFailedMessage (showPretty expected)
               genericAssertFailure__ loc (mkMsg name s $ "failed at " ++ showLoc loc ++ x)
       else return ()
DocAssertion{- | Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqualPretty@ and @gassertNotEqualPrettyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqualPretty_@, @assertNotEqualPrettyVerbose_@, @gassertNotEqualPretty_@, and @gassertNotEqualPrettyVerbose_@       functions directly, use the macros @assertNotEqualPretty@, @assertNotEqualPrettyVerbose@, @gassertNotEqualPretty@, and       @gassertNotEqualPrettyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqualPretty, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is an instance of 'Pretty'.)
gassertNotEqualPrettyVerbose_CreateAssertionsCtx(assertNotEqualPretty:: (Eq a, Pretty, (Eq aa,Prettya)m)(=> Locationa, Pretty->a,StringAssertM->ma,->a a->->a)m (); gassertNotEqualPrettyVerbose_ = _assertNotEqualPretty_ ("assertNotEqualPretty" ++ "Verbose"); gassertNotEqualPretty_ :: (Eq a, Pretty a, AssertM m) => Location -> a -> a -> m (); gassertNotEqualPretty_ loc = _assertNotEqualPretty_ "assertNotEqualPretty" loc ""; assertNotEqualPrettyVerbose_ :: (Eq a, Pretty a) => Location -> String -> a -> a -> IO (); assertNotEqualPrettyVerbose_ = _assertNotEqualPretty_ ("assertNotEqualPretty" ++ "Verbose"); assertNotEqualPretty_ :: (Eq a, Pretty a) => Location -> a -> a -> IO (); assertNotEqualPretty_ loc = _assertNotEqualPretty_ "assertNotEqualPretty" loc ""

_assertEqualNoShow_ :: (Eq a, AssertM m)
                    => String -> Location -> String -> a -> a -> m ()
_assertEqualNoShow_ name loc s expected actual =
    if expected /= actual
    then genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
    else return ()
DocAssertion{- | Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEqualNoShow@ and @gassertEqualNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEqualNoShow_@, @assertEqualNoShowVerbose_@, @gassertEqualNoShow_@, and @gassertEqualNoShowVerbose_@       functions directly, use the macros @assertEqualNoShow@, @assertEqualNoShowVerbose@, @gassertEqualNoShow@, and       @gassertEqualNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertEqualNoShow, Fail if the two values of type @a@ are not equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful.)
gassertEqualNoShowVerbose_CreateAssertionsCtx(assertEqualNoShow:: (Eq a, AssertM, Eq a, m)Eq=>a,LocationAssertM ->m),Stringa -> a->)  a -> a -> m (); gassertEqualNoShowVerbose_ = _assertEqualNoShow_ ("assertEqualNoShow" ++ "Verbose"); gassertEqualNoShow_ :: (Eq a, AssertM m) => Location -> a -> a -> m (); gassertEqualNoShow_ loc = _assertEqualNoShow_ "assertEqualNoShow" loc ""; assertEqualNoShowVerbose_ :: Eq a => Location -> String -> a -> a -> IO (); assertEqualNoShowVerbose_ = _assertEqualNoShow_ ("assertEqualNoShow" ++ "Verbose"); assertEqualNoShow_ :: Eq a => Location -> a -> a -> IO (); assertEqualNoShow_ loc = _assertEqualNoShow_ "assertEqualNoShow" loc ""

_assertNotEqualNoShow_ :: (Eq a, AssertM m)
                    => String -> Location -> String -> a -> a -> m ()
_assertNotEqualNoShow_ name loc s expected actual =
    if expected == actual
       then genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
       else return ()
DocAssertion{- | Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEqualNoShow@ and @gassertNotEqualNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEqualNoShow_@, @assertNotEqualNoShowVerbose_@, @gassertNotEqualNoShow_@, and @gassertNotEqualNoShowVerbose_@       functions directly, use the macros @assertNotEqualNoShow@, @assertNotEqualNoShowVerbose@, @gassertNotEqualNoShow@, and       @gassertNotEqualNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertNotEqualNoShow, Fail if the two values of type @a@ are equal.
             The first parameter denotes the expected value. Use these two functions
             of @a@ is neither an instance of 'Show' nor 'Pretty'. Be aware that in this
             case the generated error message might not be very helpful.)
gassertNotEqualNoShowVerbose_CreateAssertionsCtx(assertNotEqualNoShow:: (Eq a, AssertM, Eq a, m)Eq=>a,LocationAssertM ->m),Stringa -> a->)  a -> a -> m (); gassertNotEqualNoShowVerbose_ = _assertNotEqualNoShow_ ("assertNotEqualNoShow" ++ "Verbose"); gassertNotEqualNoShow_ :: (Eq a, AssertM m) => Location -> a -> a -> m (); gassertNotEqualNoShow_ loc = _assertNotEqualNoShow_ "assertNotEqualNoShow" loc ""; assertNotEqualNoShowVerbose_ :: Eq a => Location -> String -> a -> a -> IO (); assertNotEqualNoShowVerbose_ = _assertNotEqualNoShow_ ("assertNotEqualNoShow" ++ "Verbose"); assertNotEqualNoShow_ :: Eq a => Location -> a -> a -> IO (); assertNotEqualNoShow_ loc = _assertNotEqualNoShow_ "assertNotEqualNoShow" loc ""

--
-- Assertions on Lists
--

_assertListsEqualAsSets_ :: (Eq a, Show a, AssertM m)
                   => String -> Location -> String -> [a] -> [a] -> m ()
_assertListsEqualAsSets_ name loc s expected actual =
    let ne = length expected
        na = length actual
        in case () of
            _| ne /= na ->
                 do let x = equalityFailedMessage (show expected) (show actual)
                    genericAssertFailure__ loc (mkColorMsg name s
                                                (noColor
                                                 ("failed at " ++ showLoc loc
                                                  ++ "\n expected length: " ++ show ne
                                                  ++ "\n actual length: " ++ show na) +++
                                                  (if maxLength x < 5000
                                                   then x else emptyColorString)))
             | not (unorderedEq expected actual) ->
                 do let x = equalityFailedMessage (show expected) (show actual)
                    genericAssertFailure__ loc (mkColorMsg "assertSetEqual" s
                                                (noColor ("failed at " ++ showLoc loc) +++ x))
             | otherwise -> return ()
    where unorderedEq l1 l2 =
              null (l1 \\ l2) && null (l2 \\ l1)
DocAssertion{- | Fail if the two given lists are not equal
                                     when considered as sets. The first list parameter
                                     denotes the expected value. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertListsEqualAsSets@ and @gassertListsEqualAsSetsVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertListsEqualAsSets_@, @assertListsEqualAsSetsVerbose_@, @gassertListsEqualAsSets_@, and @gassertListsEqualAsSetsVerbose_@       functions directly, use the macros @assertListsEqualAsSets@, @assertListsEqualAsSetsVerbose@, @gassertListsEqualAsSets@, and       @gassertListsEqualAsSetsVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertListsEqualAsSets, Fail if the two given lists are not equal
                                     when considered as sets. The first list parameter
                                     denotes the expected value.)
gassertListsEqualAsSetsVerbose_CreateAssertionsCtx(assertListsEqualAsSets:: (Eq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),[a]]->->[a]]->)  m (); gassertListsEqualAsSetsVerbose_ = _assertListsEqualAsSets_ ("assertListsEqualAsSets" ++ "Verbose"); gassertListsEqualAsSets_ :: (Eq a, Show a, AssertM m) => Location -> [a] -> [a] -> m (); gassertListsEqualAsSets_ loc = _assertListsEqualAsSets_ "assertListsEqualAsSets" loc ""; assertListsEqualAsSetsVerbose_ :: (Eq a, Show a) => Location -> String -> [a] -> [a] -> IO (); assertListsEqualAsSetsVerbose_ = _assertListsEqualAsSets_ ("assertListsEqualAsSets" ++ "Verbose"); assertListsEqualAsSets_ :: (Eq a, Show a) => Location -> [a] -> [a] -> IO (); assertListsEqualAsSets_ loc = _assertListsEqualAsSets_ "assertListsEqualAsSets" loc ""

_assertNotEmpty_ :: AssertM m => String -> Location -> String -> [a] -> m ()
_assertNotEmpty_ name loc s [] =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertNotEmpty_ _ _ _ (_:_) = return ()
DocAssertion{- | Fail if the given list is empty. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNotEmpty@ and @gassertNotEmptyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNotEmpty_@, @assertNotEmptyVerbose_@, @gassertNotEmpty_@, and @gassertNotEmptyVerbose_@       functions directly, use the macros @assertNotEmpty@, @assertNotEmptyVerbose@, @gassertNotEmpty@, and       @gassertNotEmptyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertNotEmpty, Fail if the given list is empty.)
gassertNotEmptyVerbose_CreateAssertions(assertNotEmpty:: AssertM, [am)=> Location -> String -> [a] -> m (); gassertNotEmptyVerbose_ = _assertNotEmpty_ ("assertNotEmpty" ++ "Verbose"); gassertNotEmpty_ :: AssertM m => Location -> [a] -> m (); gassertNotEmpty_ loc = _assertNotEmpty_ "assertNotEmpty" loc ""; assertNotEmptyVerbose_ ::  Location -> String -> [a] -> IO (); assertNotEmptyVerbose_ = _assertNotEmpty_ ("assertNotEmpty" ++ "Verbose"); assertNotEmpty_ ::  Location -> [a] -> IO (); assertNotEmpty_ loc = _assertNotEmpty_ "assertNotEmpty" loc ""

_assertEmpty_ :: AssertM m => String -> Location -> String -> [a] -> m ()
_assertEmpty_ name loc s (_:_) =
    genericAssertFailure__ loc (mkMsg name s ("failed at " ++ showLoc loc))
_assertEmpty_ _ _ _ [] = return ()
DocAssertion{- | Fail if the given list is a non-empty list. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertEmpty@ and @gassertEmptyVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertEmpty_@, @assertEmptyVerbose_@, @gassertEmpty_@, and @gassertEmptyVerbose_@       functions directly, use the macros @assertEmpty@, @assertEmptyVerbose@, @gassertEmpty@, and       @gassertEmptyVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertEmpty, Fail if the given list is a non-empty list.)
gassertEmptyVerbose_CreateAssertions(assertEmpty:: AssertM, [am)=> Location -> String -> [a] -> m (); gassertEmptyVerbose_ = _assertEmpty_ ("assertEmpty" ++ "Verbose"); gassertEmpty_ :: AssertM m => Location -> [a] -> m (); gassertEmpty_ loc = _assertEmpty_ "assertEmpty" loc ""; assertEmptyVerbose_ ::  Location -> String -> [a] -> IO (); assertEmptyVerbose_ = _assertEmpty_ ("assertEmpty" ++ "Verbose"); assertEmpty_ ::  Location -> [a] -> IO (); assertEmpty_ loc = _assertEmpty_ "assertEmpty" loc ""

_assertElem_ :: (Eq a, Show a, AssertM m) => String -> Location -> String -> a -> [a] -> m ()
_assertElem_ name loc s x l =
    if x `elem` l
    then return ()
    else genericAssertFailure__ loc (mkMsg name s
                                     ("failed at " ++ showLoc loc ++
                                      "\n element: " ++ show x ++
                                      "\n list:   " ++ show l))
DocAssertion{- | Fail if the given element is not in the list. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertElem@ and @gassertElemVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertElem_@, @assertElemVerbose_@, @gassertElem_@, and @gassertElemVerbose_@       functions directly, use the macros @assertElem@, @assertElemVerbose@, @gassertElem@, and       @gassertElemVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}(assertElem, Fail if the given element is not in the list.)
gassertElemVerbose_(::assertElemEq a, Show, (Eqa,,AssertMShow a)m)(=> Locationa, Show a->, AssertM ->m),aa->->[a]]->)  m (); gassertElemVerbose_ = _assertElem_ ("assertElem" ++ "Verbose"); gassertElem_ :: (Eq a, Show a, AssertM m) => Location -> a -> [a] -> m (); gassertElem_ loc = _assertElem_ "assertElem" loc ""; assertElemVerbose_ :: (Eq a, Show a) => Location -> String -> a -> [a] -> IO (); assertElemVerbose_ = _assertElem_ ("assertElem" ++ "Verbose"); assertElem_ :: (Eq a, Show a) => Location -> a -> [a] -> IO (); assertElem_ loc = _assertElem_ "assertElem" loc ""

--
-- Assertions for Exceptions
--

_assertThrowsIO_ :: Exception e
                 => String -> Location -> String -> IO a -> (e -> Bool) -> IO ()
_assertThrowsIO_ name loc s x f =
    _assertThrowsM_ name loc s x f
DocAssertionNoGVariant{- | Fail if executing the 'IO' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsIO_@ and @assertThrowsIOVerbose_@       functions directly, use the macros @assertThrowsIO@ and @assertThrowsIOVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsIO, Fail if executing the 'IO' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@.)
assertThrowsIOVerbose_CreateAssertionsCtxNoGVariant:: Exception(assertThrowsIO => Location, Exception-> Stringe, IO->aIO->a(->e ->eBool-> Bool))  ) -> IO (); assertThrowsIOVerbose_ = _assertThrowsIO_ ("assertThrowsIO" ++ "Verbose"); assertThrowsIO_ :: Exception e => Location -> IO a -> (e -> Bool) -> IO (); assertThrowsIO_ loc = _assertThrowsIO_ "assertThrowsIO" loc ""

_assertThrowsSomeIO_ :: String -> Location -> String -> IO a -> IO ()
_assertThrowsSomeIO_ name loc s x = _assertThrowsIO_ name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant{- | Fail if executing the 'IO' action does not
                       throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSomeIO_@ and @assertThrowsSomeIOVerbose_@       functions directly, use the macros @assertThrowsSomeIO@ and @assertThrowsSomeIOVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsSomeIO, Fail if executing the 'IO' action does not
                       throw an exception.)
assertThrowsSomeIOVerbose_(::assertThrowsSomeIO -> String, IO ->a) IO a -> IO (); assertThrowsSomeIOVerbose_ = _assertThrowsSomeIO_ ("assertThrowsSomeIO" ++ "Verbose"); assertThrowsSomeIO_ ::  Location -> IO a -> IO (); assertThrowsSomeIO_ loc = _assertThrowsSomeIO_ "assertThrowsSomeIO" loc ""

_assertThrowsM_ :: (MonadBaseControl IO m, MonadIO m, Exception e)
                => String -> Location -> String -> m a -> (e -> Bool) -> m ()
_assertThrowsM_ name loc s x f =
    do res <- ExL.try x
       case res of
         Right _ -> liftIO $
                    genericAssertFailure__ loc (mkMsg name s
                                                ("failed at " ++ showLoc loc ++
                                                 ": no exception was thrown"))
         Left e -> if f e then return ()
                   else liftIO $
                        genericAssertFailure__ loc (mkMsg name s
                                                    ("failed at " ++
                                                     showLoc loc ++
                                                     ": wrong exception was thrown: " ++
                                                     show e))
DocAssertionNoGVariant{- | Fail if executing the 'm' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsM_@ and @assertThrowsMVerbose_@       functions directly, use the macros @assertThrowsM@ and @assertThrowsMVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}assertThrowsM, Fail if executing the 'm' action does not
                       throw an exception satisfying the given predicate @(e -> Bool)@.)
assertThrowsMVerbose_CreateAssertionsGenericNoGVariant:: (MonadBaseControl(assertThrowsM m, MonadIO(MonadBaseControl, ExceptionIO e) =>MonadIOm, Exception-> Stringe->) =>,a -> (e -> Bool) -> m (); assertThrowsMVerbose_ = _assertThrowsM_ ("assertThrowsM" ++ "Verbose"); assertThrowsM_ :: (MonadBaseControl IO m, MonadIO m, Exception e) => Location -> m a -> (e -> Bool) -> m (); assertThrowsM_ loc = _assertThrowsM_ "assertThrowsM" loc ""
                                  m a -> (e -> Bool), m ())
_assertThrowsSomeM_ :: (MonadBaseControl IO m, MonadIO m)
_assertThrowsSomeM_ => String(MonadBaseControl-> LocationIO->mString, MonadIO-> m)a -> m ()
_assertThrowsSomeM_ name=> String s-> =Location-> Stringname-> mloca -> x (\ (_e::SomeException) -> True)
_assertThrowsSomeM_{- | Fail if executing the 'm' action does not
                       throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSomeM_@ and @assertThrowsSomeMVerbose_@       functions directly, use the macros @assertThrowsSomeM@ and @assertThrowsSomeMVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} loc s x = _assertThrowsM_ name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant(assertThrowsSomeM, Fail if executing the 'm' action does not
assertThrowsSomeMVerbose_throw:: (anMonadBaseControlexception.)    IO m, MonadIO m) => Location -> String -> m a -> m (); assertThrowsSomeMVerbose_ = _assertThrowsSomeM_ ("assertThrowsSomeM" ++ "Verbose"); assertThrowsSomeM_ :: (MonadBaseControl IO m, MonadIO m) => Location -> m a -> m (); assertThrowsSomeM_ loc = _assertThrowsSomeM_ "assertThrowsSomeM" loc ""
CreateAssertionsGenericNoGVariant(assertThrowsSomeM, (MonadBaseControl IO m, MonadIO m) =>, m a, m ())
_assertThrows_ :: Exception e
_assertThrows_ => StringException-> Locatione        -> String -> a -> (e -> Bool) -> IO ()
_assertThrows_ name=> String s-> fLocation= _assertThrowsIO_-> String ->namea ->loc(e s->(evaluateBool) -> xIO) f)
_assertThrows_{- | Fail if evaluating the expression of type @a@ does not
                       throw an exception satisfying the given predicate @(e -> Bool)@. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrows_@ and @assertThrowsVerbose_@       functions directly, use the macros @assertThrows@ and @assertThrowsVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} loc s x f = _assertThrowsIO_ name loc s (evaluate x) f
DocAssertionNoGVariant(assertThrows, Fail if evaluating the expression of type @a@ does not
assertThrowsVerbose_ ::throwan exception => Locationsatisfying-> Stringthe given-> a ->predicatee -> Bool@(e)->->Bool ()@.;)assertThrowsVerbose_ = _assertThrows_ ("assertThrows" ++ "Verbose"); assertThrows_ :: Exception e => Location -> a -> (e -> Bool) -> IO (); assertThrows_ loc = _assertThrows_ "assertThrows" loc ""
CreateAssertionsCtxNoGVariant(assertThrows, Exception e, a -> (e -> Bool))
_assertThrowsSome_ :: String -> Location -> String -> a -> IO ()
_assertThrowsSome_ name:: String s-> =Location -> String -> a -> IO ()
_assertThrowsSome_ name loc s x (\ (_e::SomeException) -> True)
{- | Fail if evaluating the expression of type @a@ does not
                       throw an exception. The 'String' parameter in the @Verbose@       variant can be used to provide extra information about the error.       Do not use the       @assertThrowsSome_@ and @assertThrowsSomeVerbose_@       functions directly, use the macros @assertThrowsSome@ and @assertThrowsSomeVerbose@       instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} name loc s x (\ (_e::SomeException) -> True)
DocAssertionNoGVariant(assertThrowsSome, Fail if evaluating the expression of type @a@ does not
assertThrowsSomeVerbose_throw::  Locationan exception-> String.)     -> a -> IO (); assertThrowsSomeVerbose_ = _assertThrowsSome_ ("assertThrowsSome" ++ "Verbose"); assertThrowsSome_ ::  Location -> a -> IO (); assertThrowsSome_ loc = _assertThrowsSome_ "assertThrowsSome" loc ""
CreateAssertionsNoGVariant(assertThrowsSome, a)
--
---- Assertions on Either
---- Assertions on Either
--
_assertLeft_ :: forall a b m . (AssertM m, Show b)
_assertLeft_ => String ->a bLocationm . (AssertM-> Stringm, Show-> Eitherb)     a b -> m a
_assertLeft_ _=>_String (Left->x)Location= return->xString -> Either a b -> m a
_assertLeft_ name_ _ _loc(Left (Rightx) = return) =  x
_assertLeft_name loc s (Right (mkMsg) =   name s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected a Left value, given ""failed at " ++ showLoc loc ++    ++
                                 show": expected a Left value, given "Right x :: Either b b)))    ++
{- | Fail if the given @Either a b@ value is a 'Right'.
             Use this function if @b@ is an instance of 'Show' The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertLeft@ and @gassertLeftVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertLeft_@, @assertLeftVerbose_@, @gassertLeft_@, and @gassertLeftVerbose_@       functions directly, use the macros @assertLeft@, @assertLeftVerbose@, @gassertLeft@, and       @gassertLeftVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} (Right x :: Either b b)))
DocAssertion(assertLeft, Fail if the given @Either a b@ value is a 'Right'.
gassertLeftVerbose_Use this::functionShow b,if@b@ ism)an=>instanceof->'Show')  -> Either a b -> m a; gassertLeftVerbose_ = _assertLeft_ ("assertLeft" ++ "Verbose"); gassertLeft_ :: (Show b, AssertM m) => Location -> Either a b -> m a; gassertLeft_ loc = _assertLeft_ "assertLeft" loc ""; assertLeftVerbose_ :: Show b => Location -> String -> Either a b -> IO a; assertLeftVerbose_ = _assertLeft_ ("assertLeft" ++ "Verbose"); assertLeft_ :: Show b => Location -> Either a b -> IO a; assertLeft_ loc = _assertLeft_ "assertLeft" loc ""
CreateAssertionsCtxRet(assertLeft, Show b, (Show b, AssertM m), Either a b, a)
_assertLeftNoShow_ :: AssertM m => String -> Location -> String -> Either a b -> m a
_assertLeftNoShow_ _::_AssertM (Leftmx)=>=String-> Location -> String -> Either a b -> m a
_assertLeftNoShow_ name_ _ _loc(Left (Rightx) = return) =  x
_assertLeftNoShow_name loclocs ((RightmkMsg_name) =  s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected a Left value, given a Right value""failed at " ++ showLoc loc ++                ))
{- | Fail if the given @Either a b@ value is a 'Right'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertLeftNoShow@ and @gassertLeftNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertLeftNoShow_@, @assertLeftNoShowVerbose_@, @gassertLeftNoShow_@, and @gassertLeftNoShowVerbose_@       functions directly, use the macros @assertLeftNoShow@, @assertLeftNoShowVerbose@, @gassertLeftNoShow@, and       @gassertLeftNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Left value, given a Right value"))
gassertLeftNoShowVerbose_DocAssertion(assertLeftNoShow:: AssertM, Fail if =>theLocationgiven @Either-> Stringa b@->valueis a bRight'-> m a; gassertLeftNoShowVerbose_ = _assertLeftNoShow_ ("assertLeftNoShow" ++ "Verbose"); gassertLeftNoShow_ :: AssertM m => Location -> Either a b -> m a; gassertLeftNoShow_ loc = _assertLeftNoShow_ "assertLeftNoShow" loc ""; assertLeftNoShowVerbose_ ::  Location -> String -> Either a b -> IO a; assertLeftNoShowVerbose_ = _assertLeftNoShow_ ("assertLeftNoShow" ++ "Verbose"); assertLeftNoShow_ ::  Location -> Either a b -> IO a; assertLeftNoShow_ loc = _assertLeftNoShow_ "assertLeftNoShow" loc ""
CreateAssertionsRet(assertLeftNoShow, Either a b, a)
_assertRight_ :: forall a b m . (Show a, AssertM m)
_assertRight_ => String ->a bLocationm . (Show->aString, AssertM-> Eitherm)     a b -> m b
_assertRight_ _=>_String (Right-> xLocation) = return-> xString -> Either a b -> m b
_assertRight_ name_ _ _loc(Right (Leftx) =x)return=    x
_assertRight_name loc s (Left (mkMsg) =   name s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected a Right value, given ""failed at " ++ showLoc loc ++     ++
                                 show": expected a Right value, given "Left x :: Either a a)))      ++
{- | Fail if the given @Either a b@ value is a 'Left'.
             Use this function if @a@ is an instance of 'Show' The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertRight@ and @gassertRightVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertRight_@, @assertRightVerbose_@, @gassertRight_@, and @gassertRightVerbose_@       functions directly, use the macros @assertRight@, @assertRightVerbose@, @gassertRight@, and       @gassertRightVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} (Left x :: Either a a)))
DocAssertion(assertRight, Fail if the given @Either a b@ value is a 'Left'.
gassertRightVerbose_Use this::functionShow a,ifAssertM@a@ is man) =>instanceof ->'Show')   -> Either a b -> m b; gassertRightVerbose_ = _assertRight_ ("assertRight" ++ "Verbose"); gassertRight_ :: (Show a, AssertM m) => Location -> Either a b -> m b; gassertRight_ loc = _assertRight_ "assertRight" loc ""; assertRightVerbose_ :: Show a => Location -> String -> Either a b -> IO b; assertRightVerbose_ = _assertRight_ ("assertRight" ++ "Verbose"); assertRight_ :: Show a => Location -> Either a b -> IO b; assertRight_ loc = _assertRight_ "assertRight" loc ""
CreateAssertionsCtxRet(assertRight, Show a, (Show a, AssertM m), Either a b, b)
_assertRightNoShow_ :: AssertM m => String -> Location -> String -> Either a b -> m b
_assertRightNoShow_ _::_AssertM (Rightm x=>) =String->xLocation -> String -> Either a b -> m b
_assertRightNoShow_ name_ _ _loc(Right (Leftx) =_)return=    x
_assertRightNoShow_name locs (mkMsgLeft _name) =  s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected a Right value, given a Left value""failed at " ++ showLoc loc ++                ))
{- | Fail if the given @Either a b@ value is a 'Left'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertRightNoShow@ and @gassertRightNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertRightNoShow_@, @assertRightNoShowVerbose_@, @gassertRightNoShow_@, and @gassertRightNoShowVerbose_@       functions directly, use the macros @assertRightNoShow@, @assertRightNoShowVerbose@, @gassertRightNoShow@, and       @gassertRightNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Right value, given a Left value"))
gassertRightNoShowVerbose_DocAssertion(assertRightNoShow:: AssertM, Fail if =>theLocationgiven @Either-> Stringa b@->valueis a bLeft'-> m.b; gassertRightNoShowVerbose_ = _assertRightNoShow_ ("assertRightNoShow" ++ "Verbose"); gassertRightNoShow_ :: AssertM m => Location -> Either a b -> m b; gassertRightNoShow_ loc = _assertRightNoShow_ "assertRightNoShow" loc ""; assertRightNoShowVerbose_ ::  Location -> String -> Either a b -> IO b; assertRightNoShowVerbose_ = _assertRightNoShow_ ("assertRightNoShow" ++ "Verbose"); assertRightNoShow_ ::  Location -> Either a b -> IO b; assertRightNoShow_ loc = _assertRightNoShow_ "assertRightNoShow" loc ""
CreateAssertionsRet(assertRightNoShow, Either a b, b)
--
---- Assertions on Maybe
---- Assertions on Maybe
--
_assertJust_ :: AssertM m => String -> Location -> String -> Maybe a -> m a
_assertJust_ _::_AssertM (Justmx)=>=String-> Location -> String -> Maybe a -> m a
_assertJust_ name_ _ _loc(Just Nothingx) = return=    x
_assertJust_name loc s Nothing (mkMsg=     name s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected a Just value, given Nothing""failed at " ++ showLoc loc ++          ))
{- | Fail is the given @Maybe a@ value is a 'Nothing'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertJust@ and @gassertJustVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertJust_@, @assertJustVerbose_@, @gassertJust_@, and @gassertJustVerbose_@       functions directly, use the macros @assertJust@, @assertJustVerbose@, @gassertJust@, and       @gassertJustVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected a Just value, given Nothing"))
gassertJustVerbose_DocAssertion(assertJust:: AssertM, Fail is =>theLocationgiven @Maybe-> Stringa@ value-> Maybeis a aNothing'-> m a;.gassertJustVerbose_)                   = _assertJust_ ("assertJust" ++ "Verbose"); gassertJust_ :: AssertM m => Location -> Maybe a -> m a; gassertJust_ loc = _assertJust_ "assertJust" loc ""; assertJustVerbose_ ::  Location -> String -> Maybe a -> IO a; assertJustVerbose_ = _assertJust_ ("assertJust" ++ "Verbose"); assertJust_ ::  Location -> Maybe a -> IO a; assertJust_ loc = _assertJust_ "assertJust" loc ""
CreateAssertionsRet(assertJust, Maybe a, a)
_assertNothing_ :: (Show a, AssertM m)
_assertNothing_ => String(Show a->, AssertMm)-> String -> Maybe a -> m ()
_assertNothing_ _=>_String Nothing-> Location= return->)String -> Maybe a -> m ()
_assertNothing_ name_ _ _locNothing jx = return ()
_assertNothing_name loc s locjx =(mkMsg name s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected Nothing, given ""failed at " ++ showLoc loc ++ show jx))
{- | Fail is the given @Maybe a@ value is a 'Just'.
             Use this function if @a@ is an instance of 'Show'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNothing@ and @gassertNothingVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNothing_@, @assertNothingVerbose_@, @gassertNothing_@, and @gassertNothingVerbose_@       functions directly, use the macros @assertNothing@, @assertNothingVerbose@, @gassertNothing@, and       @gassertNothingVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -} ++ show jx))
DocAssertion(assertNothing, Fail is the given @Maybe a@ value is a 'Just'.
gassertNothingVerbose_Use this function:: (Showif,@AssertMa@ is anm)instance=> Locationof 'Show'-> String.)    -> Maybe a -> m (); gassertNothingVerbose_ = _assertNothing_ ("assertNothing" ++ "Verbose"); gassertNothing_ :: (Show a, AssertM m) => Location -> Maybe a -> m (); gassertNothing_ loc = _assertNothing_ "assertNothing" loc ""; assertNothingVerbose_ :: Show a => Location -> String -> Maybe a -> IO (); assertNothingVerbose_ = _assertNothing_ ("assertNothing" ++ "Verbose"); assertNothing_ :: Show a => Location -> Maybe a -> IO (); assertNothing_ loc = _assertNothing_ "assertNothing" loc ""
CreateAssertionsCtx(assertNothing, Show a, (Show a, AssertM m), Maybe a)
_assertNothingNoShow_ :: AssertM m => String -> Location -> String -> Maybe a -> m ()
_assertNothingNoShow_ _::_AssertM Nothingm =>= return (->) Location -> String -> Maybe a -> m ()
_assertNothingNoShow_ name_ _ _locNothing _ == return ()
_assertNothingNoShow_name loc (mkMsg_ =  name s
    genericAssertFailure__ loc ((mkMsg"failed at "name s  ++ showLoc loc ++
                                (": expected Nothing, given a Just value""failed at " ++ showLoc loc ++          ))
{- | Fail is the given @Maybe a@ value is a 'Just'. The 'String' parameter in the @Verbose@       variants can be used to provide extra information about the error. The       variants @gassertNothingNoShow@ and @gassertNothingNoShowVerbose@ are generic assertions:       they run in the IO monad and can be evaluated to a 'Bool' value.       Do not use the       @assertNothingNoShow_@, @assertNothingNoShowVerbose_@, @gassertNothingNoShow_@, and @gassertNothingNoShowVerbose_@       functions directly, use the macros @assertNothingNoShow@, @assertNothingNoShowVerbose@, @gassertNothingNoShow@, and       @gassertNothingNoShowVerbose@ instead. These macros, provided by the @htfpp@ preprocessor,       insert the 'Location' parameter automatically. -}": expected Nothing, given a Just value"))
gassertNothingNoShowVerbose_DocAssertion(assertNothingNoShow:: AssertM, Fail is =>theLocationgiven @Maybe-> Stringa@ value-> Maybeis a aJust'-> m.(); gassertNothingNoShowVerbose_ = _assertNothingNoShow_ ("assertNothingNoShow" ++ "Verbose"); gassertNothingNoShow_ :: AssertM m => Location -> Maybe a -> m (); gassertNothingNoShow_ loc = _assertNothingNoShow_ "assertNothingNoShow" loc ""; assertNothingNoShowVerbose_ ::  Location -> String -> Maybe a -> IO (); assertNothingNoShowVerbose_ = _assertNothingNoShow_ ("assertNothingNoShow" ++ "Verbose"); assertNothingNoShow_ ::  Location -> Maybe a -> IO (); assertNothingNoShow_ loc = _assertNothingNoShow_ "assertNothingNoShow" loc ""
CreateAssertions(assertNothingNoShow, Maybe a)
--
---- Sub assertions
---- Sub assertions
--
-- | Sub assertions are a poor man's way of abstracting over assertions while still propagating location
-- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write-- | Sub assertions are a poor man's way of abstracting over assertions while still propagating location
---- information. Say you want to abstract over the assertion that an 'Int' is positive. You would write
---- > assertIsPositive :: Int -> Assertion

</pre>