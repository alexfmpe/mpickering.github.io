<a href="Set.hs8933518161505795335.out.html">prev</a></br><a href="failures.html">home</a></br><a href="SetupNoTH.hs12507398241614285132.out.html">next</a></br></br><pre>33d32
< class Member a b | b → a where member :: a → b → Bool
34d32
< class ProperSubsetOf a where isProperSubsetOf :: a → a → Bool
35d32
< class SubsetOf a where isSubsetOf :: a → a → Bool
36d32
< class Union a where union :: a → a → a
37c33
< class Intersection a where intersection :: a → a → a
---
> class Member a b | b -> a where member :: a -> b -> Bool
37a34
> class ProperSubsetOf a where isProperSubsetOf :: a -> a -> Bool
37a35
> class SubsetOf a where isSubsetOf :: a -> a -> Bool
37a36
> class Union a where union :: a -> a -> a
37a37
> class Intersection a where intersection :: a -> a -> a
39d38
< class Singleton a b | b → a where singleton :: a → b
40c39
< class Insert a b | b → a where insert :: a → b → b
---
> class Singleton a b | b -> a where singleton :: a -> b
40a40
> class Insert a b | b -> a where insert :: a -> b -> b
42c42
< (∈), (∉) :: Member a b ⇒ a → b → Bool
---
> (∈), (∉) :: Member a b => a -> b -> Bool
46c46
< (∋), (∌) :: Member a b ⇒ b → a → Bool
---
> (∋), (∌) :: Member a b => b -> a -> Bool
50c50
< (⊂), (⊄), (⊃), (⊅) :: ProperSubsetOf a ⇒ a → a → Bool
---
> (⊂), (⊄), (⊃), (⊅) :: ProperSubsetOf a => a -> a -> Bool
56c56
< (⊆), (⊈), (⊇), (⊉) :: SubsetOf a ⇒ a → a → Bool
---
> (⊆), (⊈), (⊇), (⊉) :: SubsetOf a => a -> a -> Bool
62c62
< (∪) :: Union a ⇒ a → a → a
---
> (∪) :: Union a => a -> a -> a
65c65
< (∩) :: Intersection a ⇒ a → a → a
---
> (∩) :: Intersection a => a -> a -> a
73c73
< (∅) :: Empty a ⇒ a
---
> (∅) :: Empty a => a
99d98
< instance Eq a ⇒ Member a [a] where member = List.elem
100d98
< instance Ord a ⇒ Member a (Set a) where member = Set.member
101c99
< instance Ord k ⇒ Member k (Map k v) where member = Map.member
---
> instance Eq a => Member a [a] where member = List.elem
101a100
> instance Ord a => Member a (Set a) where member = Set.member
101a101
> instance Ord k => Member k (Map k v) where member = Map.member
105d104
< instance Ord a ⇒ ProperSubsetOf (Set a) where isProperSubsetOf = Set.isProperSubsetOf
106c105
< instance (Ord k, Eq v) ⇒ ProperSubsetOf (Map k v) where isProperSubsetOf = Map.isProperSubmapOf
---
> instance Ord a => ProperSubsetOf (Set a) where isProperSubsetOf = Set.isProperSubsetOf
106a106
> instance (Ord k, Eq v) => ProperSubsetOf (Map k v) where isProperSubsetOf = Map.isProperSubmapOf
108c108
< instance Eq v ⇒ ProperSubsetOf (IntMap v) where isProperSubsetOf = IntMap.isProperSubmapOf
---
> instance Eq v => ProperSubsetOf (IntMap v) where isProperSubsetOf = IntMap.isProperSubmapOf
110d109
< instance Ord a ⇒ SubsetOf (Set a) where isSubsetOf = Set.isSubsetOf
111c110
< instance (Ord k, Eq v) ⇒ SubsetOf (Map k v) where isSubsetOf = Map.isSubmapOf
---
> instance Ord a => SubsetOf (Set a) where isSubsetOf = Set.isSubsetOf
111a111
> instance (Ord k, Eq v) => SubsetOf (Map k v) where isSubsetOf = Map.isSubmapOf
113c113
< instance Eq v ⇒ SubsetOf (IntMap v) where isSubsetOf = IntMap.isSubmapOf
---
> instance Eq v => SubsetOf (IntMap v) where isSubsetOf = IntMap.isSubmapOf
115d114
< instance Eq a ⇒ Union [a] where union = List.union
116d114
< instance Ord a ⇒ Union (Set a) where union = Set.union
117c115
< instance Ord k ⇒ Union (Map k v) where union = Map.union
---
> instance Eq a => Union [a] where union = List.union
117a116
> instance Ord a => Union (Set a) where union = Set.union
117a117
> instance Ord k => Union (Map k v) where union = Map.union
121d120
< instance Eq a ⇒ Intersection [a] where intersection = List.intersect
122d120
< instance Ord a ⇒ Intersection (Set a) where intersection = Set.intersection
123c121
< instance Ord k ⇒ Intersection (Map k v) where intersection = Map.intersection
---
> instance Eq a => Intersection [a] where intersection = List.intersect
123a122
> instance Ord a => Intersection (Set a) where intersection = Set.intersection
123a123
> instance Ord k => Intersection (Map k v) where intersection = Map.intersection
127d126
< instance Ord a ⇒ Insert a [a] where insert = List.insert
128d126
< instance Ord a ⇒ Insert a (Set a) where insert = Set.insert
129c127
< instance Ord k ⇒ Insert (k, v) (Map k v) where insert = uncurry Map.insert
---
> instance Ord a => Insert a [a] where insert = List.insert
129a128
> instance Ord a => Insert a (Set a) where insert = Set.insert
129a129
> instance Ord k => Insert (k, v) (Map k v) where insert = uncurry Map.insert
140d139
< instance Ord a ⇒ Singleton a (Set a) where singleton = Set.singleton
141c140
< instance Ord k ⇒ Singleton (k, v) (Map k v) where singleton = uncurry Map.singleton
---
> instance Ord a => Singleton a (Set a) where singleton = Set.singleton
141a141
> instance Ord k => Singleton (k, v) (Map k v) where singleton = uncurry Map.singleton
143a144
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
  UnicodeSyntax,
  MultiParamTypeClasses,
  FlexibleInstances,
  FunctionalDependencies,
  TypeSynonymInstances,
  NoImplicitPrelude
 #-}

module Data.SetOps (
  Member (member), (∈), (∉), (∋), (∌),
  ProperSubsetOf (isProperSubsetOf), (⊂), (⊄), (⊃), (⊅),
  SubsetOf (isSubsetOf), (⊆), (⊈), (⊇), (⊉),
  Union (union), (∪),
  Intersection (intersection), (∩),
  Empty (empty), (∅),
  Singleton(singleton),
  Insert(insert)
) where

import qualified Data.List as List
import qualified Data.Set as Set
import qualified Data.Map as Map
import qualified Data.IntSet as IntSet
import qualified Data.IntMap as IntMap
import Data.Set (Set)
import Data.Map (Map)
import Data.IntSet (IntSet)
import Data.IntMap (IntMap)

import Prelude (Eq, Ord, Bool, Int, flip, uncurry, not, (.))

class Member a b | b → a where member :: a → b → Bool
class ProperSubsetOf a where isProperSubsetOf :: a → a → Bool
class SubsetOf a where isSubsetOf :: a → a → Bool
class Union a where union :: a → a → a
class Intersection a where intersection :: a → a → a
class Empty a where empty :: a
class Singleton a b | b → a where singleton :: a → b
class Insert a b | b → a where insert :: a → b → b

(∈), (∉) :: Member a b ⇒ a → b → Bool
(∈) = member
(∉) x = not . (x ∈)

(∋), (∌) :: Member a b ⇒ b → a → Bool
(∋) = flip (∈)
(∌) = flip (∉)

(⊂), (⊄), (⊃), (⊅) :: ProperSubsetOf a ⇒ a → a → Bool
(⊂) = isProperSubsetOf
(⊄) x = not . (x ⊂)
(⊃) = flip (⊂)
(⊅) = flip (⊄)

(⊆), (⊈), (⊇), (⊉) :: SubsetOf a ⇒ a → a → Bool
(⊆) = isSubsetOf
(⊈) x = not . (x ⊆)
(⊇) = flip (⊆)
(⊉) = flip (⊈)

(∪) :: Union a ⇒ a → a → a
(∪) = union

(∩) :: Intersection a ⇒ a → a → a
(∩) = intersection

-- | .

-- The above is a workaround; without at least one Haddock-commented
-- function, Haddock does not generate a synopsis.

(∅) :: Empty a ⇒ a
(∅) = empty

{- We don't let ∉ be specialized independently, because it does not make sense to
 have a ∉ that is faster than ∈. After all, in that case, one should have defined ∈ as
 the negation of ∉ and have it be as fast. The same argument applies to ⊄ and ⊈. -}

-- Fixities:

infix 4 ∈
infix 4 ∉
infix 4 ∋
infix 4 ∌
infix 4 ⊆
infix 4 ⊈
infix 4 ⊇
infix 4 ⊉
infix 4 ⊂
infix 4 ⊄
infix 4 ⊃
infix 4 ⊅
infixl 6 ∪
infixr 6 ∩

-- Instances:

instance Eq a ⇒ Member a [a] where member = List.elem
instance Ord a ⇒ Member a (Set a) where member = Set.member
instance Ord k ⇒ Member k (Map k v) where member = Map.member
instance Member Int IntSet where member = IntSet.member
instance Member IntMap.Key (IntMap v) where member = IntMap.member

instance Ord a ⇒ ProperSubsetOf (Set a) where isProperSubsetOf = Set.isProperSubsetOf
instance (Ord k, Eq v) ⇒ ProperSubsetOf (Map k v) where isProperSubsetOf = Map.isProperSubmapOf
instance ProperSubsetOf IntSet where isProperSubsetOf = IntSet.isProperSubsetOf
instance Eq v ⇒ ProperSubsetOf (IntMap v) where isProperSubsetOf = IntMap.isProperSubmapOf

instance Ord a ⇒ SubsetOf (Set a) where isSubsetOf = Set.isSubsetOf
instance (Ord k, Eq v) ⇒ SubsetOf (Map k v) where isSubsetOf = Map.isSubmapOf
instance SubsetOf IntSet where isSubsetOf = IntSet.isSubsetOf
instance Eq v ⇒ SubsetOf (IntMap v) where isSubsetOf = IntMap.isSubmapOf

instance Eq a ⇒ Union [a] where union = List.union
instance Ord a ⇒ Union (Set a) where union = Set.union
instance Ord k ⇒ Union (Map k v) where union = Map.union
instance Union IntSet where union = IntSet.union
instance Union (IntMap v) where union = IntMap.union

instance Eq a ⇒ Intersection [a] where intersection = List.intersect
instance Ord a ⇒ Intersection (Set a) where intersection = Set.intersection
instance Ord k ⇒ Intersection (Map k v) where intersection = Map.intersection
instance Intersection IntSet where intersection = IntSet.intersection
instance Intersection (IntMap v) where intersection = IntMap.intersection

instance Ord a ⇒ Insert a [a] where insert = List.insert
instance Ord a ⇒ Insert a (Set a) where insert = Set.insert
instance Ord k ⇒ Insert (k, v) (Map k v) where insert = uncurry Map.insert
instance Insert Int IntSet where insert = IntSet.insert
instance Insert (IntMap.Key, v) (IntMap v) where insert = uncurry IntMap.insert

instance Empty [a] where empty = []
instance Empty (Set a) where empty = Set.empty
instance Empty (Map k v) where empty = Map.empty
instance Empty IntSet where empty = IntSet.empty
instance Empty (IntMap v) where empty = IntMap.empty

instance Singleton a [a] where singleton = (:[])
instance Ord a ⇒ Singleton a (Set a) where singleton = Set.singleton
instance Ord k ⇒ Singleton (k, v) (Map k v) where singleton = uncurry Map.singleton
instance Singleton Int IntSet where singleton = IntSet.singleton
instance Singleton (IntMap.Key, v) (IntMap v) where singleton = uncurry IntMap.singleton
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
  UnicodeSyntax,
  MultiParamTypeClasses,
  FlexibleInstances,
  FunctionalDependencies,
  TypeSynonymInstances,
  NoImplicitPrelude
 #-}

module Data.SetOps (
  Member (member), (∈), (∉), (∋), (∌),
  ProperSubsetOf (isProperSubsetOf), (⊂), (⊄), (⊃), (⊅),
  SubsetOf (isSubsetOf), (⊆), (⊈), (⊇), (⊉),
  Union (union), (∪),
  Intersection (intersection), (∩),
  Empty (empty), (∅),
  Singleton(singleton),
  Insert(insert)
) where

import qualified Data.List as List
import qualified Data.Set as Set
import qualified Data.Map as Map
import qualified Data.IntSet as IntSet
import qualified Data.IntMap as IntMap
import Data.Set (Set)
import Data.Map (Map)
import Data.IntSet (IntSet)
import Data.IntMap (IntMap)

import Prelude (Eq, Ord, Bool, Int, flip, uncurry, not, (.))

class Member a b | b -> a where member :: a -> b -> Bool
class ProperSubsetOf a where isProperSubsetOf :: a -> a -> Bool
class SubsetOf a where isSubsetOf :: a -> a -> Bool
class Union a where union :: a -> a -> a
class Intersection a where intersection :: a -> a -> a
class Empty a where empty :: a
class Singleton a b | b -> a where singleton :: a -> b
class Insert a b | b -> a where insert :: a -> b -> b

(∈), (∉) :: Member a b => a -> b -> Bool
(∈) = member
(∉) x = not . (x ∈)

(∋), (∌) :: Member a b => b -> a -> Bool
(∋) = flip (∈)
(∌) = flip (∉)

(⊂), (⊄), (⊃), (⊅) :: ProperSubsetOf a => a -> a -> Bool
(⊂) = isProperSubsetOf
(⊄) x = not . (x ⊂)
(⊃) = flip (⊂)
(⊅) = flip (⊄)

(⊆), (⊈), (⊇), (⊉) :: SubsetOf a => a -> a -> Bool
(⊆) = isSubsetOf
(⊈) x = not . (x ⊆)
(⊇) = flip (⊆)
(⊉) = flip (⊈)

(∪) :: Union a => a -> a -> a
(∪) = union

(∩) :: Intersection a => a -> a -> a
(∩) = intersection

-- | .

-- The above is a workaround; without at least one Haddock-commented
-- function, Haddock does not generate a synopsis.

(∅) :: Empty a => a
(∅) = empty

{- We don't let ∉ be specialized independently, because it does not make sense to
 have a ∉ that is faster than ∈. After all, in that case, one should have defined ∈ as
 the negation of ∉ and have it be as fast. The same argument applies to ⊄ and ⊈. -}

-- Fixities:

infix 4 ∈
infix 4 ∉
infix 4 ∋
infix 4 ∌
infix 4 ⊆
infix 4 ⊈
infix 4 ⊇
infix 4 ⊉
infix 4 ⊂
infix 4 ⊄
infix 4 ⊃
infix 4 ⊅
infixl 6 ∪
infixr 6 ∩

-- Instances:

instance Eq a => Member a [a] where member = List.elem
instance Ord a => Member a (Set a) where member = Set.member
instance Ord k => Member k (Map k v) where member = Map.member
instance Member Int IntSet where member = IntSet.member
instance Member IntMap.Key (IntMap v) where member = IntMap.member

instance Ord a => ProperSubsetOf (Set a) where isProperSubsetOf = Set.isProperSubsetOf
instance (Ord k, Eq v) => ProperSubsetOf (Map k v) where isProperSubsetOf = Map.isProperSubmapOf
instance ProperSubsetOf IntSet where isProperSubsetOf = IntSet.isProperSubsetOf
instance Eq v => ProperSubsetOf (IntMap v) where isProperSubsetOf = IntMap.isProperSubmapOf

instance Ord a => SubsetOf (Set a) where isSubsetOf = Set.isSubsetOf
instance (Ord k, Eq v) => SubsetOf (Map k v) where isSubsetOf = Map.isSubmapOf
instance SubsetOf IntSet where isSubsetOf = IntSet.isSubsetOf
instance Eq v => SubsetOf (IntMap v) where isSubsetOf = IntMap.isSubmapOf

instance Eq a => Union [a] where union = List.union
instance Ord a => Union (Set a) where union = Set.union
instance Ord k => Union (Map k v) where union = Map.union
instance Union IntSet where union = IntSet.union
instance Union (IntMap v) where union = IntMap.union

instance Eq a => Intersection [a] where intersection = List.intersect
instance Ord a => Intersection (Set a) where intersection = Set.intersection
instance Ord k => Intersection (Map k v) where intersection = Map.intersection
instance Intersection IntSet where intersection = IntSet.intersection
instance Intersection (IntMap v) where intersection = IntMap.intersection

instance Ord a => Insert a [a] where insert = List.insert
instance Ord a => Insert a (Set a) where insert = Set.insert
instance Ord k => Insert (k, v) (Map k v) where insert = uncurry Map.insert
instance Insert Int IntSet where insert = IntSet.insert
instance Insert (IntMap.Key, v) (IntMap v) where insert = uncurry IntMap.insert

instance Empty [a] where empty = []
instance Empty (Set a) where empty = Set.empty
instance Empty (Map k v) where empty = Map.empty
instance Empty IntSet where empty = IntSet.empty
instance Empty (IntMap v) where empty = IntMap.empty

instance Singleton a [a] where singleton = (:[])
instance Ord a => Singleton a (Set a) where singleton = Set.singleton
instance Ord k => Singleton (k, v) (Map k v) where singleton = uncurry Map.singleton
instance Singleton Int IntSet where singleton = IntSet.singleton
instance Singleton (IntMap.Key, v) (IntMap v) where singleton = uncurry IntMap.singleton

</pre>