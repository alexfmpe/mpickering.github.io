<a href="Reader.hs12648177091998097157.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Reader.hs16607608081561939997.out.html">next</a></br></br><pre>44c44
< readOPML :: {-URL-}String -> IO (Maybe OPML)
---
> readOPML :: {-URLString -> IO (Maybe OPML)
58c58
< readURL :: {-URL-}String
---
> readURL :: {-URLString
80a81
> 
</pre></br><h2>original</h2></br><pre>--------------------------------------------------------------------
-- |
-- Module    :
-- Copyright : (c) Galois, Inc. 2008
-- License   : All rights reserved
--
-- Maintainer: Don Stewart <dons@galois.com>
-- Stability : provisional
-- Portability:
--
--------------------------------------------------------------------

module Text.OPML.Reader
       ( {- readOPML, -}
         parseOPMLString
       ) where

import Text.OPML.Syntax
import Text.OPML.Import
import Text.XML.Light

{-
import Web.HTTP.Header
import Web.DAV.Utils ( splitURL )
import Web.DAV.Backend.CurlPkg as Curl
import Web.DAV.Backend.Interface
import Web.DAV.Types as WebClient
-}

-- import Data.Maybe ( fromMaybe )

-- | Parse a string into OPML.
parseOPMLString :: String -> Maybe OPML
parseOPMLString str =
  case parseXMLDoc str of
    Nothing -> Nothing
    Just e  -> elementToOPML e


{-

-- remove dependence on webdav

readOPML :: {-URL-}String -> IO (Maybe OPML)
readOPML opmlURL = do
  (st,_,body) <- readIn opmlURL
  case st of
    200 ->
     case parseOPMLString body of
      Nothing -> fail ("readOPML: failed to parse OPML from " ++ opmlURL)
      Just fd -> return (Just fd)
    _ -> return Nothing
 where
  readIn f = do
    catch (readFile f >>= \ ls -> return (200,[],ls))
          (\ _ -> readURL f [])

readURL :: {-URL-}String
        -> [HttpHeader]
        -> IO (Int,[HttpHeader], String)
readURL url hs = do
  let (base,path) = splitURL url
  webH <- primOpen (Curl.factory defaultConfig{cfgOptions=cOpts}) base hs
  st <- WebClient.webGet webH path [] Nothing
  case st of
    WebOK rhs v       -> return (200,rhs,v)
    WebFailed rhs m   -> return (404,rhs,fromMaybe "" m)
    WebStatus rhs v a -> return (v,rhs,a)
 where
  cOpts = cAuthOpts

  cAuthOpts =
        [ CurlHttpAuth [HttpAuthAny]
           -- ToDo: allow cookie file location to be passed in.
        , CurlCookieFile "cookies"
        , CurlCookieJar  "cookies"
        , CurlFollowLocation True
        ]

-}
</pre></br><h2>printed</h2></br><pre>--------------------------------------------------------------------
-- |
-- Module    :
-- Copyright : (c) Galois, Inc. 2008
-- License   : All rights reserved
--
-- Maintainer: Don Stewart <dons@galois.com>
-- Stability : provisional
-- Portability:
--
--------------------------------------------------------------------

module Text.OPML.Reader
       ( {- readOPML, -}
         parseOPMLString
       ) where

import Text.OPML.Syntax
import Text.OPML.Import
import Text.XML.Light

{-
import Web.HTTP.Header
import Web.DAV.Utils ( splitURL )
import Web.DAV.Backend.CurlPkg as Curl
import Web.DAV.Backend.Interface
import Web.DAV.Types as WebClient
-}

-- import Data.Maybe ( fromMaybe )

-- | Parse a string into OPML.
parseOPMLString :: String -> Maybe OPML
parseOPMLString str =
  case parseXMLDoc str of
    Nothing -> Nothing
    Just e  -> elementToOPML e


{-

-- remove dependence on webdav

readOPML :: {-URLString -> IO (Maybe OPML)
readOPML opmlURL = do
  (st,_,body) <- readIn opmlURL
  case st of
    200 ->
     case parseOPMLString body of
      Nothing -> fail ("readOPML: failed to parse OPML from " ++ opmlURL)
      Just fd -> return (Just fd)
    _ -> return Nothing
 where
  readIn f = do
    catch (readFile f >>= \ ls -> return (200,[],ls))
          (\ _ -> readURL f [])

readURL :: {-URLString
        -> [HttpHeader]
        -> IO (Int,[HttpHeader], String)
readURL url hs = do
  let (base,path) = splitURL url
  webH <- primOpen (Curl.factory defaultConfig{cfgOptions=cOpts}) base hs
  st <- WebClient.webGet webH path [] Nothing
  case st of
    WebOK rhs v       -> return (200,rhs,v)
    WebFailed rhs m   -> return (404,rhs,fromMaybe "" m)
    WebStatus rhs v a -> return (v,rhs,a)
 where
  cOpts = cAuthOpts

  cAuthOpts =
        [ CurlHttpAuth [HttpAuthAny]
           -- ToDo: allow cookie file location to be passed in.
        , CurlCookieFile "cookies"
        , CurlCookieJar  "cookies"
        , CurlFollowLocation True
        ]

-}

</pre>