<a href="Common.hs2108804114600633910.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Common.hs6468614591238320299.out.html">next</a></br></br><pre>35c35
< import UHC.Util.CompileRun2
---
> import-- dummy, so module is not empty for initial variants, and exports will take effectUHC.Util.CompileRun2
46d45
< import UHC.Util.Time
47d45
< import System.Directory
48d45
< 
49d45
< 
50d45
< 
51d45
< 
52d45
< {-# LINE 35 "src/ehc/EHC/Common.chs" #-}
53d45
< -- dummy, so module is not empty for initial variants, and exports will take effect
54d45
< 
55d45
< {-# LINE 45 "src/ehc/EHC/Common.chs" #-}
56d45
< data HSState
57c46
<   = HSStart                 -- starting from .hs
---
> import UHC.Util.Time        -- starting from .hs
57a47
> import System.Directory HSState
57a48
>   = HSStart
69c60
< {-# LINE 66 "src/ehc/EHC/Common.chs" #-}
---
> 
69a61
> 
69a62
> 
69a63
> 
69a64
> 
69a65
> 
69a66
> 
69a67
> 
75c73
< {-# LINE 75 "src/ehc/EHC/Common.chs" #-}
---
> 
75a74
> 
75a75
> 
75a76
> 
81c82
< {-# LINE 86 "src/ehc/EHC/Common.chs" #-}
---
> 
81a83
> 
81a84
> 
81a85
> 
81a86
> 
81a87
> 
89c95
< {-# LINE 99 "src/ehc/EHC/Common.chs" #-}
---
> 
89a96
> 
89a97
> 
89a98
> 
89a99
> 
89a100
> 
95c106
< {-# LINE 108 "src/ehc/EHC/Common.chs" #-}
---
> 
95a107
> 
95a108
> 
95a109
> 
108c122
< {-# LINE 124 "src/ehc/EHC/Common.chs" #-}
---
> 
108a123
> 
108a124
> 
108a125
> 
116c133
< {-# LINE 133 "src/ehc/EHC/Common.chs" #-}
---
> 
116a134
> 
124c142
< {-# LINE 144 "src/ehc/EHC/Common.chs" #-}
---
> 
124a143
> 
124a144
> 
124a145
> 
137c158
< {-# LINE 164 "src/ehc/EHC/Common.chs" #-}
---
> 
137a159
> 
137a160
> 
137a161
> 
137a162
> 
137a163
> 
137a164
> 
137a165
> 
150c178
< {-# LINE 184 "src/ehc/EHC/Common.chs" #-}
---
> 
150a179
> 
150a180
> 
150a181
> 
150a182
> 
150a183
> 
150a184
> 
150a185
> 
157c192
< {-# LINE 194 "src/ehc/EHC/Common.chs" #-}
---
> 
157a193
> 
157a194
> 
157a195
> 
164c202
< {-# LINE 208 "src/ehc/EHC/Common.chs" #-}
---
> 
164a203
> 
164a204
> 
164a205
> 
164a206
> 
164a207
> 
164a208
> 
164a209
> 
171c216
< {-# LINE 218 "src/ehc/EHC/Common.chs" #-}
---
> 
171a217
> 
171a218
> 
171a219
> 
179c227
< {-# LINE 233 "src/ehc/EHC/Common.chs" #-}
---
> 
179a228
> 
179a229
> 
179a230
> 
179a231
> 
179a232
> 
179a233
> 
179a234
> 
184c239
< {-# LINE 243 "src/ehc/EHC/Common.chs" #-}
---
> 
184a240
> 
184a241
> 
184a242
> 
184a243
> 
184a244
> 
194c254
< {-# LINE 258 "src/ehc/EHC/Common.chs" #-}
---
> 
194a255
> 
194a256
> 
194a257
> 
194a258
> 
194a259
> 
213c278
< {-# LINE 283 "src/ehc/EHC/Common.chs" #-}
---
> 
213a279
> 
213a280
> 
213a281
> 
213a282
> 
213a283
> 
213a284
> 
218c289
< {-# LINE 289 "src/ehc/EHC/Common.chs" #-}
---
> 
218a290
> 
222c294
< {-# LINE 298 "src/ehc/EHC/Common.chs" #-}
---
> 
222a295
> 
222a296
> 
222a297
> 
222a298
> 
222a299
> 
234c311
< {-# LINE 315 "src/ehc/EHC/Common.chs" #-}
---
> 
234a312
> 
234a313
> 
234a314
> 
234a315
> 
234a316
> 
241a324
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.Common
( module Data.Maybe, module Data.List, module Data.Char
, module System.IO
, module UHC.Util.CompileRun2, module UHC.Util.Pretty, module UHC.Util.FPath, module UHC.Util.Utils
, module UHC.Light.Compiler.Base.Common, module UHC.Light.Compiler.Base.HsName.Builtin, module UHC.Light.Compiler.Opts
, module UHC.Light.Compiler.Error, module UHC.Light.Compiler.Error.Pretty
, module UHC.Light.Compiler.Gam.Full
, HSState (..)
, EHState (..)
, CRState (..)
, CRRState (..)
, EHCompileUnitState (..)
, ecuStateFinalDestination
, ecuStateIsCore
, ecuStateIsCoreRun
, EHCompileUnitKind (..)
, ecuStateToKind
, FinalCompileHow (..)
, mkShellCmd, mkShellCmd', showShellCmd
, mkInOrOutputFPathDirFor
, mkInOrOutputFPathFor
, mkOutputFPath
, mkPerModuleOutputFPath
, mkPerExecOutputFPath
, hsstateIsLiteral
, hsstateShowLit
, hsstateNext
, CState (..), OState (..) )
where
import Data.List
import Data.Char
import Data.Maybe
import Control.Monad.State
import System.IO
import UHC.Util.CompileRun2
import UHC.Util.Pretty
import UHC.Util.FPath
import UHC.Util.Utils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Error
import UHC.Light.Compiler.Error.Pretty
import UHC.Light.Compiler.Gam.Full
import UHC.Light.Compiler.Opts.CommandLine
import UHC.Util.Time
import System.Directory




{-# LINE 35 "src/ehc/EHC/Common.chs" #-}
-- dummy, so module is not empty for initial variants, and exports will take effect

{-# LINE 45 "src/ehc/EHC/Common.chs" #-}
data HSState
  = HSStart                 -- starting from .hs
  | HSAllSem                -- done all semantics for .hs
  | HMOnlyMinimal           -- done minimal info only
  -- | HMStart                 -- starting from nothing, not using .hi info nor .hs file, just for linking etc
  | HSOnlyImports           -- done imports from .hs
  | HIStart                 -- starting from .hi
  | HIAllSem                -- done all semantics for .hi
  | HIOnlyImports           -- done imports from .hi
  | LHSStart                -- starting from .lhs
  | LHSOnlyImports          -- done imports from .lhs
  deriving (Show,Eq)

{-# LINE 66 "src/ehc/EHC/Common.chs" #-}
hsstateIsLiteral :: HSState -> Bool
hsstateIsLiteral LHSStart       = True
hsstateIsLiteral LHSOnlyImports = True
hsstateIsLiteral _              = False

{-# LINE 75 "src/ehc/EHC/Common.chs" #-}
hsstateShowLit :: HSState -> String
hsstateShowLit LHSStart       = "Literal"
hsstateShowLit LHSOnlyImports = "Literal"
hsstateShowLit _              = ""

{-# LINE 86 "src/ehc/EHC/Common.chs" #-}
hsstateNext :: HSState -> HSState
hsstateNext HSStart       = HSOnlyImports
hsstateNext HIStart       = HIOnlyImports
-- hsstateNext HMStart       = HMOnlyMinimal
hsstateNext LHSStart      = LHSOnlyImports
hsstateNext st            = st

{-# LINE 99 "src/ehc/EHC/Common.chs" #-}
data EHState
  = EHStart
  | EHAllSem
  deriving (Show,Eq)

{-# LINE 108 "src/ehc/EHC/Common.chs" #-}
-- | State for .c files
data CState
  = CStart
  | CAllSem
  deriving (Show,Eq)

-- | State for .o files
data OState
  = OStart
  | OAllSem
  deriving (Show,Eq)

{-# LINE 124 "src/ehc/EHC/Common.chs" #-}
data CRState
  = CRStartBinary
  | CRStartText
  | CROnlyImports
  | CRAllSem
  deriving (Show,Eq)

{-# LINE 133 "src/ehc/EHC/Common.chs" #-}
data CRRState
  = CRRStartBinary
  -- | CRRStartText
  | CRROnlyImports
  | CRRAllSem
  deriving (Show,Eq)

{-# LINE 144 "src/ehc/EHC/Common.chs" #-}
data EHCompileUnitState
  = ECUS_Unknown
  | ECUS_Haskell !HSState
  | ECUS_Eh      !EHState
  | ECUS_C       !CState
  | ECUS_O       !OState
  | ECUS_Core    !CRState
  | ECUS_CoreRun !CRRState
  | ECUS_Grin
  | ECUS_Fail
  deriving (Show,Eq)

{-# LINE 164 "src/ehc/EHC/Common.chs" #-}
-- | The final state
ecuStateFinalDestination :: (EHCompileUnitState -> EHCompileUnitState) -> EHCompileUnitState -> EHCompileUnitState
ecuStateFinalDestination postModf
  = postModf . n
  where n (ECUS_Haskell _) = ECUS_Haskell HSAllSem
        n (ECUS_Eh      _) = ECUS_Eh      EHAllSem
        n (ECUS_C       _) = ECUS_C       CAllSem
        n (ECUS_O       _) = ECUS_O       OAllSem
        n (ECUS_Core    _) = ECUS_Core    CRAllSem
        n (ECUS_CoreRun _) = ECUS_CoreRun CRRAllSem
        n _                = ECUS_Fail

{-# LINE 184 "src/ehc/EHC/Common.chs" #-}
-- | Is compilation from Core source
ecuStateIsCore :: EHCompileUnitState -> Bool
ecuStateIsCore st = case st of
  ECUS_Core _ -> True
  _           -> False

{-# LINE 194 "src/ehc/EHC/Common.chs" #-}
-- | Is compilation from CoreRun source
ecuStateIsCoreRun :: EHCompileUnitState -> Bool
ecuStateIsCoreRun st = case st of
  ECUS_CoreRun _ -> True
  _              -> False

{-# LINE 208 "src/ehc/EHC/Common.chs" #-}
data EHCompileUnitKind
  = EHCUKind_HS     -- Haskell: .hs .lhs .hi
  | EHCUKind_C      -- C: .c
  | EHCUKind_None   -- Nothing
  deriving Eq

{-# LINE 218 "src/ehc/EHC/Common.chs" #-}
ecuStateToKind :: EHCompileUnitState -> EHCompileUnitKind
ecuStateToKind s
  = case s of
      ECUS_Haskell _ -> EHCUKind_HS
      ECUS_C       _ -> EHCUKind_C
      _              -> EHCUKind_None

{-# LINE 233 "src/ehc/EHC/Common.chs" #-}
data FinalCompileHow
  = FinalCompile_Module
  | FinalCompile_Exec

{-# LINE 243 "src/ehc/EHC/Common.chs" #-}
mkShellCmd' :: [Cmd] -> FilePath -> CmdLineOpts -> (FilePath,[String])
mkShellCmd' forCmds cmdStr o = (cmdStr, showCmdLineOpts' forCmds o)

mkShellCmd :: [String] -> (FilePath,[String])
mkShellCmd (cmd:args) = (cmd,args)

showShellCmd :: (FilePath,[String]) -> String
showShellCmd (cmd,args) = concat $ intersperse " " $ [cmd] ++ args

{-# LINE 258 "src/ehc/EHC/Common.chs" #-}
mkInOrOutputFPathDirFor :: FPATH nm => InOrOutputFor -> EHCOpts -> nm -> FPath -> String -> (FPath,Maybe String)
mkInOrOutputFPathDirFor inoutputfor opts modNm fp suffix
  = (fpathSetSuff suffix fp', d)
  where (fp',d) = case inoutputfor of
                    OutputFor_Module   -> f ehcOptOutputDir
                    OutputFor_Pkg      -> f ehcOptOutputDir -- ehcOptOutputPkgLibDir
                    InputFrom_Loc l
                      | filelocIsPkg l -> f (const Nothing)
                      | otherwise      -> f ehcOptOutputDir
        f g     = case g opts of
                    Just d -> ( fpathPrependDir d'
                                $ fpathSetBase (fpathBase fp)   -- ensure possibly adapted name in filesys is used
                                $ mkFPath modNm                 -- includes module hierarchy into filename
                              , Just d'
                              )
                           where d' = filePathUnPrefix d
                    _      -> (fp,Nothing)

{-# LINE 283 "src/ehc/EHC/Common.chs" #-}
mkInOrOutputFPathFor :: FPATH nm => InOrOutputFor -> EHCOpts -> nm -> FPath -> String -> FPath
mkInOrOutputFPathFor inoutputfor opts modNm fp suffix
  = fst $ mkInOrOutputFPathDirFor inoutputfor opts modNm fp suffix

{-# LINE 289 "src/ehc/EHC/Common.chs" #-}
mkOutputFPath :: FPATH nm => EHCOpts -> nm -> FPath -> String -> FPath
mkOutputFPath = mkInOrOutputFPathFor OutputFor_Module

{-# LINE 298 "src/ehc/EHC/Common.chs" #-}
-- | FPath for per module output
mkPerModuleOutputFPath :: EHCOpts -> Bool -> HsName -> FPath -> String -> FPath
mkPerModuleOutputFPath opts doSepBy_ modNm fp suffix
  = fpO modNm fp
  where fpO m f= case ehcOptPkgOpt opts of
                   Just _        -> nm_
                   _ | doSepBy_  -> nm_
                     | otherwise -> mkOutputFPath opts m f suffix
               where nm_ = mkOutputFPath opts (hsnMapQualified (const base) m) (fpathSetBase base f) suffix
                         where base = hsnShow "_" "_" m

{-# LINE 315 "src/ehc/EHC/Common.chs" #-}
-- | FPath for final executable, with possible suffix (and forcing flag, even on given exec)
mkPerExecOutputFPath :: EHCOpts -> HsName -> FPath -> Maybe (String, Bool) -> FPath
mkPerExecOutputFPath opts modNm fp mbSuffix
  = maybe id (\(s,force) -> if force then fpathSetSuff s else id) mbSuffix fpExec
  where fpExecBasedOnSrc = maybe (mkOutputFPath opts modNm fp "") (\(s,_) -> mkOutputFPath opts modNm fp s) mbSuffix
        fpExec = maybe fpExecBasedOnSrc id (ehcOptMbOutputFile opts)

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.Common
( module Data.Maybe, module Data.List, module Data.Char
, module System.IO
, module UHC.Util.CompileRun2, module UHC.Util.Pretty, module UHC.Util.FPath, module UHC.Util.Utils
, module UHC.Light.Compiler.Base.Common, module UHC.Light.Compiler.Base.HsName.Builtin, module UHC.Light.Compiler.Opts
, module UHC.Light.Compiler.Error, module UHC.Light.Compiler.Error.Pretty
, module UHC.Light.Compiler.Gam.Full
, HSState (..)
, EHState (..)
, CRState (..)
, CRRState (..)
, EHCompileUnitState (..)
, ecuStateFinalDestination
, ecuStateIsCore
, ecuStateIsCoreRun
, EHCompileUnitKind (..)
, ecuStateToKind
, FinalCompileHow (..)
, mkShellCmd, mkShellCmd', showShellCmd
, mkInOrOutputFPathDirFor
, mkInOrOutputFPathFor
, mkOutputFPath
, mkPerModuleOutputFPath
, mkPerExecOutputFPath
, hsstateIsLiteral
, hsstateShowLit
, hsstateNext
, CState (..), OState (..) )
where
import Data.List
import Data.Char
import Data.Maybe
import Control.Monad.State
import System.IO
import-- dummy, so module is not empty for initial variants, and exports will take effectUHC.Util.CompileRun2
import UHC.Util.Pretty
import UHC.Util.FPath
import UHC.Util.Utils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Error
import UHC.Light.Compiler.Error.Pretty
import UHC.Light.Compiler.Gam.Full
import UHC.Light.Compiler.Opts.CommandLine
import UHC.Util.Time        -- starting from .hs
import System.Directory HSState
  = HSStart
  | HSAllSem                -- done all semantics for .hs
  | HMOnlyMinimal           -- done minimal info only
  -- | HMStart                 -- starting from nothing, not using .hi info nor .hs file, just for linking etc
  | HSOnlyImports           -- done imports from .hs
  | HIStart                 -- starting from .hi
  | HIAllSem                -- done all semantics for .hi
  | HIOnlyImports           -- done imports from .hi
  | LHSStart                -- starting from .lhs
  | LHSOnlyImports          -- done imports from .lhs
  deriving (Show,Eq)









hsstateIsLiteral :: HSState -> Bool
hsstateIsLiteral LHSStart       = True
hsstateIsLiteral LHSOnlyImports = True
hsstateIsLiteral _              = False





hsstateShowLit :: HSState -> String
hsstateShowLit LHSStart       = "Literal"
hsstateShowLit LHSOnlyImports = "Literal"
hsstateShowLit _              = ""







hsstateNext :: HSState -> HSState
hsstateNext HSStart       = HSOnlyImports
hsstateNext HIStart       = HIOnlyImports
-- hsstateNext HMStart       = HMOnlyMinimal
hsstateNext LHSStart      = LHSOnlyImports
hsstateNext st            = st







data EHState
  = EHStart
  | EHAllSem
  deriving (Show,Eq)





-- | State for .c files
data CState
  = CStart
  | CAllSem
  deriving (Show,Eq)

-- | State for .o files
data OState
  = OStart
  | OAllSem
  deriving (Show,Eq)





data CRState
  = CRStartBinary
  | CRStartText
  | CROnlyImports
  | CRAllSem
  deriving (Show,Eq)



data CRRState
  = CRRStartBinary
  -- | CRRStartText
  | CRROnlyImports
  | CRRAllSem
  deriving (Show,Eq)





data EHCompileUnitState
  = ECUS_Unknown
  | ECUS_Haskell !HSState
  | ECUS_Eh      !EHState
  | ECUS_C       !CState
  | ECUS_O       !OState
  | ECUS_Core    !CRState
  | ECUS_CoreRun !CRRState
  | ECUS_Grin
  | ECUS_Fail
  deriving (Show,Eq)









-- | The final state
ecuStateFinalDestination :: (EHCompileUnitState -> EHCompileUnitState) -> EHCompileUnitState -> EHCompileUnitState
ecuStateFinalDestination postModf
  = postModf . n
  where n (ECUS_Haskell _) = ECUS_Haskell HSAllSem
        n (ECUS_Eh      _) = ECUS_Eh      EHAllSem
        n (ECUS_C       _) = ECUS_C       CAllSem
        n (ECUS_O       _) = ECUS_O       OAllSem
        n (ECUS_Core    _) = ECUS_Core    CRAllSem
        n (ECUS_CoreRun _) = ECUS_CoreRun CRRAllSem
        n _                = ECUS_Fail









-- | Is compilation from Core source
ecuStateIsCore :: EHCompileUnitState -> Bool
ecuStateIsCore st = case st of
  ECUS_Core _ -> True
  _           -> False





-- | Is compilation from CoreRun source
ecuStateIsCoreRun :: EHCompileUnitState -> Bool
ecuStateIsCoreRun st = case st of
  ECUS_CoreRun _ -> True
  _              -> False









data EHCompileUnitKind
  = EHCUKind_HS     -- Haskell: .hs .lhs .hi
  | EHCUKind_C      -- C: .c
  | EHCUKind_None   -- Nothing
  deriving Eq





ecuStateToKind :: EHCompileUnitState -> EHCompileUnitKind
ecuStateToKind s
  = case s of
      ECUS_Haskell _ -> EHCUKind_HS
      ECUS_C       _ -> EHCUKind_C
      _              -> EHCUKind_None









data FinalCompileHow
  = FinalCompile_Module
  | FinalCompile_Exec







mkShellCmd' :: [Cmd] -> FilePath -> CmdLineOpts -> (FilePath,[String])
mkShellCmd' forCmds cmdStr o = (cmdStr, showCmdLineOpts' forCmds o)

mkShellCmd :: [String] -> (FilePath,[String])
mkShellCmd (cmd:args) = (cmd,args)

showShellCmd :: (FilePath,[String]) -> String
showShellCmd (cmd,args) = concat $ intersperse " " $ [cmd] ++ args







mkInOrOutputFPathDirFor :: FPATH nm => InOrOutputFor -> EHCOpts -> nm -> FPath -> String -> (FPath,Maybe String)
mkInOrOutputFPathDirFor inoutputfor opts modNm fp suffix
  = (fpathSetSuff suffix fp', d)
  where (fp',d) = case inoutputfor of
                    OutputFor_Module   -> f ehcOptOutputDir
                    OutputFor_Pkg      -> f ehcOptOutputDir -- ehcOptOutputPkgLibDir
                    InputFrom_Loc l
                      | filelocIsPkg l -> f (const Nothing)
                      | otherwise      -> f ehcOptOutputDir
        f g     = case g opts of
                    Just d -> ( fpathPrependDir d'
                                $ fpathSetBase (fpathBase fp)   -- ensure possibly adapted name in filesys is used
                                $ mkFPath modNm                 -- includes module hierarchy into filename
                              , Just d'
                              )
                           where d' = filePathUnPrefix d
                    _      -> (fp,Nothing)








mkInOrOutputFPathFor :: FPATH nm => InOrOutputFor -> EHCOpts -> nm -> FPath -> String -> FPath
mkInOrOutputFPathFor inoutputfor opts modNm fp suffix
  = fst $ mkInOrOutputFPathDirFor inoutputfor opts modNm fp suffix



mkOutputFPath :: FPATH nm => EHCOpts -> nm -> FPath -> String -> FPath
mkOutputFPath = mkInOrOutputFPathFor OutputFor_Module







-- | FPath for per module output
mkPerModuleOutputFPath :: EHCOpts -> Bool -> HsName -> FPath -> String -> FPath
mkPerModuleOutputFPath opts doSepBy_ modNm fp suffix
  = fpO modNm fp
  where fpO m f= case ehcOptPkgOpt opts of
                   Just _        -> nm_
                   _ | doSepBy_  -> nm_
                     | otherwise -> mkOutputFPath opts m f suffix
               where nm_ = mkOutputFPath opts (hsnMapQualified (const base) m) (fpathSetBase base f) suffix
                         where base = hsnShow "_" "_" m







-- | FPath for final executable, with possible suffix (and forcing flag, even on given exec)
mkPerExecOutputFPath :: EHCOpts -> HsName -> FPath -> Maybe (String, Bool) -> FPath
mkPerExecOutputFPath opts modNm fp mbSuffix
  = maybe id (\(s,force) -> if force then fpathSetSuff s else id) mbSuffix fpExec
  where fpExecBasedOnSrc = maybe (mkOutputFPath opts modNm fp "") (\(s,_) -> mkOutputFPath opts modNm fp s) mbSuffix
        fpExec = maybe fpExecBasedOnSrc id (ehcOptMbOutputFile opts)


</pre>