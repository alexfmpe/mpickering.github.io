<a href="Graph.hs794014915545293947.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Graphics.hs1492192799970343127.out.html">next</a></br></br><pre>13d12
<     = Applicator {inp, out1, out2 ∷ Port}
14d12
<     | Combinator {inp ∷ Port, combinator ∷ Combinator}
15d12
<     | Duplicator {inp1, inp2, out ∷ Port}
16d12
<     | Variable   {inp ∷ Port, variable ∷ String}
17d12
<     | Eraser     {out ∷ Port}
18c13
<     | Root       {out ∷ Port}
---
>     = Applicator {inp, out1, out2 :: Port}
18a14
>     | Combinator {inp :: Port, combinator :: Combinator}
18a15
>     | Duplicator {inp1, inp2, out :: Port}
18a16
>     | Variable   {inp :: Port, variable :: String}
18a17
>     | Eraser     {out :: Port}
18a18
>     | Root       {out :: Port}
22d21
<         Applicator {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
23d21
<         Combinator {inp = i}                       → [i]
24d21
<         Duplicator {inp1 = i1, inp2 = i2, out = o} → [i1,i2,o]
25d21
<         Variable   {inp = i}                       → [i]
26d21
<         Eraser     {out = o}                       → [o]
27c22
<         Root       {out = o}                       → [o]
---
>         Applicator {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
27a23
>         Combinator {inp = i}                       -> [i]
27a24
>         Duplicator {inp1 = i1, inp2 = i2, out = o} -> [i1,i2,o]
27a25
>         Variable   {inp = i}                       -> [i]
27a26
>         Eraser     {out = o}                       -> [o]
27a27
>         Root       {out = o}                       -> [o]
29d28
<         Applicator {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
30d28
<         Combinator {} → node {inp = i}                       where [i]       = ports
31d28
<         Duplicator {} → node {inp1 = i1, inp2 = i2, out = o} where [i1,i2,o] = ports
32d28
<         Variable   {} → node {inp = i}                       where [i]       = ports
33d28
<         Eraser     {} → node {out = o}                       where [o]       = ports
34c29
<         Root       {} → node {out = o}                       where [o]       = ports
---
>         Applicator {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
34a30
>         Combinator {} -> node {inp = i}                       where [i]       = ports
34a31
>         Duplicator {} -> node {inp1 = i1, inp2 = i2, out = o} where [i1,i2,o] = ports
34a32
>         Variable   {} -> node {inp = i}                       where [i]       = ports
34a33
>         Eraser     {} -> node {out = o}                       where [o]       = ports
34a34
>         Root       {} -> node {out = o}                       where [o]       = ports
36c36
< fromTerm ∷ Term.Expr → Graph Vertex
---
> fromTerm :: Term.Expr -> Graph Vertex
38c38
<     e ← compile term
---
>     e <- compile term
41c41
< compile ∷ Term.Expr → Rewrite Vertex Edge
---
> compile :: Term.Expr -> Rewrite Vertex Edge
43c43
<     e ← newEdge
---
>     e <- newEdge
45d44
<         Term.Application f x → do
46d44
<             ef ← compile f
47c45
<             ex ← compile x
---
>         Term.Application f x -> do
47a46
>             ef <- compile f
47a47
>             ex <- compile x
49d48
<         Term.Variable v → case maybeRead v of
50d48
<             Just c  → newNode Combinator {inp = e, combinator = c}
51c49
<             Nothing → newNode Variable   {inp = e, variable   = v}
---
>         Term.Variable v -> case maybeRead v of
51a50
>             Just c  -> newNode Combinator {inp = e, combinator = c}
51a51
>             Nothing -> newNode Variable   {inp = e, variable   = v}
55a56
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Data.View
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import qualified Term
import Data.Maybe (listToMaybe)

data Combinator = S | K | I | B | C | S' | B' | C' | W deriving (Show,Read,Eq)

data Vertex
    = Applicator {inp, out1, out2 ∷ Port}
    | Combinator {inp ∷ Port, combinator ∷ Combinator}
    | Duplicator {inp1, inp2, out ∷ Port}
    | Variable   {inp ∷ Port, variable ∷ String}
    | Eraser     {out ∷ Port}
    | Root       {out ∷ Port}

instance View [Port] Vertex where
    inspect node = case node of
        Applicator {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
        Combinator {inp = i}                       → [i]
        Duplicator {inp1 = i1, inp2 = i2, out = o} → [i1,i2,o]
        Variable   {inp = i}                       → [i]
        Eraser     {out = o}                       → [o]
        Root       {out = o}                       → [o]
    update ports node = case node of
        Applicator {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Combinator {} → node {inp = i}                       where [i]       = ports
        Duplicator {} → node {inp1 = i1, inp2 = i2, out = o} where [i1,i2,o] = ports
        Variable   {} → node {inp = i}                       where [i]       = ports
        Eraser     {} → node {out = o}                       where [o]       = ports
        Root       {} → node {out = o}                       where [o]       = ports

fromTerm ∷ Term.Expr → Graph Vertex
fromTerm term = flip execGraph emptyGraph $ do
    e ← compile term
    newNode Root {out = e}

compile ∷ Term.Expr → Rewrite Vertex Edge
compile term = do
    e ← newEdge
    case term of
        Term.Application f x → do
            ef ← compile f
            ex ← compile x
            newNode Applicator {inp = e, out1 = ef, out2 = ex}
        Term.Variable v → case maybeRead v of
            Just c  → newNode Combinator {inp = e, combinator = c}
            Nothing → newNode Variable   {inp = e, variable   = v}
    return e

maybeRead :: Read a => String -> Maybe a
maybeRead = fmap fst . listToMaybe . reads
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Data.View
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import qualified Term
import Data.Maybe (listToMaybe)

data Combinator = S | K | I | B | C | S' | B' | C' | W deriving (Show,Read,Eq)

data Vertex
    = Applicator {inp, out1, out2 :: Port}
    | Combinator {inp :: Port, combinator :: Combinator}
    | Duplicator {inp1, inp2, out :: Port}
    | Variable   {inp :: Port, variable :: String}
    | Eraser     {out :: Port}
    | Root       {out :: Port}

instance View [Port] Vertex where
    inspect node = case node of
        Applicator {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
        Combinator {inp = i}                       -> [i]
        Duplicator {inp1 = i1, inp2 = i2, out = o} -> [i1,i2,o]
        Variable   {inp = i}                       -> [i]
        Eraser     {out = o}                       -> [o]
        Root       {out = o}                       -> [o]
    update ports node = case node of
        Applicator {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Combinator {} -> node {inp = i}                       where [i]       = ports
        Duplicator {} -> node {inp1 = i1, inp2 = i2, out = o} where [i1,i2,o] = ports
        Variable   {} -> node {inp = i}                       where [i]       = ports
        Eraser     {} -> node {out = o}                       where [o]       = ports
        Root       {} -> node {out = o}                       where [o]       = ports

fromTerm :: Term.Expr -> Graph Vertex
fromTerm term = flip execGraph emptyGraph $ do
    e <- compile term
    newNode Root {out = e}

compile :: Term.Expr -> Rewrite Vertex Edge
compile term = do
    e <- newEdge
    case term of
        Term.Application f x -> do
            ef <- compile f
            ex <- compile x
            newNode Applicator {inp = e, out1 = ef, out2 = ex}
        Term.Variable v -> case maybeRead v of
            Just c  -> newNode Combinator {inp = e, combinator = c}
            Nothing -> newNode Variable   {inp = e, variable   = v}
    return e

maybeRead :: Read a => String -> Maybe a
maybeRead = fmap fst . listToMaybe . reads

</pre>