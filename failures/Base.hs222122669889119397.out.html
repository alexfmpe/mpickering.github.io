<a href="Base.hs1952509530130060903.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Base.hs3228420821463179852.out.html">next</a></br></br><pre>35c35
< {-# LINE 47 "src/ehc/Gam/Base.chs" #-}
---
> 
35a36
> 
35a37
> 
35a38
> 
35a39
> 
35a40
> 
35a41
> 
35a42
> 
35a43
> 
35a44
> 
35a45
> 
35a46
> 
38c49
< {-# LINE 51 "src/ehc/Gam/Base.chs" #-}
---
> 
38a50
> 
49c61
< {-# LINE 76 "src/ehc/Gam/Base.chs" #-}
---
> 
49a62
> 
49a63
> 
49a64
> 
49a65
> 
49a66
> 
49a67
> 
49a68
> 
49a69
> 
49a70
> 
49a71
> 
49a72
> 
49a73
> 
49a74
> 
49a75
> 
53c79
< {-# LINE 81 "src/ehc/Gam/Base.chs" #-}
---
> 
53a80
> 
61c88
< {-# LINE 90 "src/ehc/Gam/Base.chs" #-}
---
> 
61a89
> 
83c111
< {-# LINE 113 "src/ehc/Gam/Base.chs" #-}
---
> 
83a112
> 
87c116
< {-# LINE 123 "src/ehc/Gam/Base.chs" #-}
---
> 
87a117
> 
87a118
> 
87a119
> 
87a120
> 
87a121
> 
87a122
> 
91c126
< {-# LINE 128 "src/ehc/Gam/Base.chs" #-}
---
> 
91a127
> 
95c131
< {-# LINE 138 "src/ehc/Gam/Base.chs" #-}
---
> 
95a132
> 
95a133
> 
95a134
> 
95a135
> 
95a136
> 
95a137
> 
100c142
< {-# LINE 144 "src/ehc/Gam/Base.chs" #-}
---
> 
100a143
> 
105c148
< {-# LINE 156 "src/ehc/Gam/Base.chs" #-}
---
> 
105a149
> 
105a150
> 
105a151
> 
105a152
> 
105a153
> 
105a154
> 
105a155
> 
110c160
< {-# LINE 162 "src/ehc/Gam/Base.chs" #-}
---
> 
110a161
> 
114c165
< {-# LINE 172 "src/ehc/Gam/Base.chs" #-}
---
> 
114a166
> 
114a167
> 
114a168
> 
114a169
> 
114a170
> 
114a171
> 
119c176
< {-# LINE 183 "src/ehc/Gam/Base.chs" #-}
---
> 
119a177
> 
119a178
> 
119a179
> 
119a180
> 
119a181
> 
119a182
> 
124c187
< {-# LINE 189 "src/ehc/Gam/Base.chs" #-}
---
> 
124a188
> 
129c193
< {-# LINE 203 "src/ehc/Gam/Base.chs" #-}
---
> 
129a194
> 
129a195
> 
129a196
> 
129a197
> 
129a198
> 
129a199
> 
129a200
> 
129a201
> 
129a202
> 
134c207
< {-# LINE 224 "src/ehc/Gam/Base.chs" #-}
---
> 
134a208
> 
134a209
> 
134a210
> 
134a211
> 
134a212
> 
134a213
> 
134a214
> 
134a215
> 
134a216
> 
134a217
> 
134a218
> 
134a219
> 
134a220
> 
134a221
> 
134a222
> 
134a223
> 
139c228
< {-# LINE 230 "src/ehc/Gam/Base.chs" #-}
---
> 
139a229
> 
144c234
< {-# LINE 236 "src/ehc/Gam/Base.chs" #-}
---
> 
144a235
> 
149c240
< {-# LINE 247 "src/ehc/Gam/Base.chs" #-}
---
> 
149a241
> 
149a242
> 
149a243
> 
149a244
> 
149a245
> 
149a246
> 
158c255
< {-# LINE 264 "src/ehc/Gam/Base.chs" #-}
---
> 
158a256
> 
158a257
> 
158a258
> 
158a259
> 
158a260
> 
158a261
> 
158a262
> 
158a263
> 
163c268
< {-# LINE 274 "src/ehc/Gam/Base.chs" #-}
---
> 
163a269
> 
163a270
> 
163a271
> 
163a272
> 
163a273
> 
176c286
< {-# LINE 288 "src/ehc/Gam/Base.chs" #-}
---
> 
176a287
> 
181c292
< {-# LINE 294 "src/ehc/Gam/Base.chs" #-}
---
> 
181a293
> 
185a298
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Gam.Base
( emptyGam, gamMap, gamLookup, gamLookupDup, gamPushNew, gamPop, gamTop, gamAddGam, gamAdd, gamPushGam, gamToAssocL, gamToAssocDupL, assocLToGam, assocDupLToGam, gamKeys
, gamSingleton, gamInsert, gamUnion, gamUnions, gamFromAssocL
, assocLToGamWithDups
, gamToOnlyDups
, gamPartition
, gamMapElts
, gamMapThr
, gamUnzip
, gamElts
, gamNoDups
, Gam
, gamLookupMetaLev
, gamMetaLevSingleton
, gamUnionWith )
where
import Data.List
import UHC.Util.Utils
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.NameAspect
import qualified Data.Set as Set
import UHC.Light.Compiler.Opts.Base
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Util.ScopeMapGam







{-# LINE 47 "src/ehc/Gam/Base.chs" #-}
type Gam k v        =   SGam k v

{-# LINE 51 "src/ehc/Gam/Base.chs" #-}
emptyGam            ::            Gam k v
gamSingleton        ::            k -> v        -> Gam k v
gamLookup           ::  Ord k =>  k -> Gam k v  -> Maybe v
gamToAssocL         ::  Ord k =>  Gam k v       -> AssocL k v
gamPushNew          ::            Gam k v       -> Gam k v
gamPushGam          ::  Ord k =>  Gam k v       -> Gam k v -> Gam k v
gamPop              ::  Ord k =>  Gam k v       -> (Gam k v,Gam k v)
gamAddGam           ::  Ord k =>  Gam k v       -> Gam k v -> Gam k v
gamAdd              ::  Ord k =>  k -> v        -> Gam k v -> Gam k v

{-# LINE 76 "src/ehc/Gam/Base.chs" #-}
gamLookupMetaLev :: Ord k => MetaLev -> k -> Gam k v -> Maybe v
gamLookupMetaLev mlev k g = fmap head $ gamLookupMetaLevDup mlev k g

{-# LINE 81 "src/ehc/Gam/Base.chs" #-}
gamToAssocL     g                   = [ (k,v) | (k,(v:_)) <- gamToAssocDupL g ]

gamLookup       k g                 = fmap head $ gamLookupDup k g
{-# INLINE gamLookup #-}

assocLToGam                         = gamUnions . map (uncurry gamSingleton)

{-# LINE 90 "src/ehc/Gam/Base.chs" #-}
emptyGam                            = emptySGam
{-# INLINE emptyGam #-}

gamSingleton                        = sgamSingleton
{-# INLINE gamSingleton #-}

gamPushNew                          = sgamPushNew
{-# INLINE gamPushNew #-}

gamPushGam                          = sgamPushGam
{-# INLINE gamPushGam #-}

gamPop                              = sgamPop
{-# INLINE gamPop #-}

gamAddGam                           = sgamUnion
{-# INLINE gamAddGam #-}

gamAdd          k v g               = sgamUnion (sgamSingleton k v) g
{-# INLINE gamAdd #-}

{-# LINE 113 "src/ehc/Gam/Base.chs" #-}
gamTop              ::  Ord k =>  Gam k v     -> Gam k v
assocLToGam         ::  Ord k =>  AssocL k v  -> Gam k v

{-# LINE 123 "src/ehc/Gam/Base.chs" #-}
gamTop                              = sgamTop
{-# INLINE gamTop #-}

{-# LINE 128 "src/ehc/Gam/Base.chs" #-}
gamMetaLevSingleton                        = sgamMetaLevSingleton
{-# INLINE gamMetaLevSingleton #-}

{-# LINE 138 "src/ehc/Gam/Base.chs" #-}
assocDupLToGam :: Ord k => AssocL k [v] -> Gam k v
assocDupLToGam = sgamFromAssocDupL
{-# INLINE assocDupLToGam #-}

{-# LINE 144 "src/ehc/Gam/Base.chs" #-}
assocLToGamWithDups :: Ord k => AssocL k v -> Gam k v
assocLToGamWithDups = assocDupLToGam . assocLGroupSort
{-# INLINE assocLToGamWithDups #-}

{-# LINE 156 "src/ehc/Gam/Base.chs" #-}
gamToAssocDupL :: Ord k => Gam k v -> AssocL k [v]
gamToAssocDupL = sgamToAssocDupL
{-# INLINE gamToAssocDupL #-}

{-# LINE 162 "src/ehc/Gam/Base.chs" #-}
gamToOnlyDups :: Ord k => Gam k v -> AssocL k [v]
gamToOnlyDups g = [ x | x@(n,(_:_:_)) <- gamToAssocDupL g ]

{-# LINE 172 "src/ehc/Gam/Base.chs" #-}
gamNoDups :: Ord k => Gam k v -> Gam k v
gamNoDups = sgamNoDups
{-# INLINE gamNoDups #-}

{-# LINE 183 "src/ehc/Gam/Base.chs" #-}
gamMap :: (Ord k,Ord k') => ((k,v) -> (k',v')) -> Gam k v -> Gam k' v'
gamMap = sgamMap
{-# INLINE gamMap #-}

{-# LINE 189 "src/ehc/Gam/Base.chs" #-}
gamMapElts :: Ord k => (v -> v') -> Gam k v -> Gam k v'
gamMapElts f = gamMap (\(n,v) -> (n,f v))
{-# INLINE gamMapElts #-}

{-# LINE 203 "src/ehc/Gam/Base.chs" #-}
gamPartition :: Ord k => (k -> v -> Bool) -> Gam k v -> (Gam k v,Gam k v)
gamPartition = sgamPartitionWithKey
{-# INLINE gamPartition #-}

{-# LINE 224 "src/ehc/Gam/Base.chs" #-}
gamMapThr :: (Ord k,Ord k') => ((k,v) -> t -> ((k',v'),t)) -> t -> Gam k v -> (Gam k' v',t)
gamMapThr = sgamMapThr
{-# INLINE gamMapThr #-}

{-# LINE 230 "src/ehc/Gam/Base.chs" #-}
gamKeys :: Ord k => Gam k v -> [k]
gamKeys = assocLKeys . gamToAssocL
{-# INLINE gamKeys #-}

{-# LINE 236 "src/ehc/Gam/Base.chs" #-}
gamElts :: Ord k => Gam k v -> [v]
gamElts = assocLElts . gamToAssocL
{-# INLINE gamElts #-}

{-# LINE 247 "src/ehc/Gam/Base.chs" #-}
gamLookupMetaLevDup :: Ord k => MetaLev -> k -> Gam k v -> Maybe [v]
gamLookupMetaLevDup = sgamLookupMetaLevDup
{-# INLINE gamLookupMetaLevDup #-}

gamLookupDup :: Ord k => k -> Gam k v -> Maybe [v]
gamLookupDup = gamLookupMetaLevDup metaLevVal
{-# INLINE gamLookupDup #-}

{-# LINE 264 "src/ehc/Gam/Base.chs" #-}
gamUnzip :: Ord k => Gam k (v1,v2) -> (Gam k v1,Gam k v2)
gamUnzip g = sgamUnzip g
{-# INLINE gamUnzip #-}

{-# LINE 274 "src/ehc/Gam/Base.chs" #-}
gamInsert :: Ord k => k -> v -> Gam k v -> Gam k v
gamInsert = gamAdd
{-# INLINE gamInsert #-}

gamUnion :: Ord k => Gam k v -> Gam k v -> Gam k v
gamUnion = gamAddGam
{-# INLINE gamUnion #-}

gamFromAssocL ::  Ord k =>  AssocL k v  -> Gam k v
gamFromAssocL = assocLToGam
{-# INLINE gamFromAssocL #-}

{-# LINE 288 "src/ehc/Gam/Base.chs" #-}
gamUnionWith :: Ord k => (v -> [v] -> [v]) -> Gam k v -> Gam k v -> Gam k v
gamUnionWith cmb = sgamUnionWith (Just cmb)
{-# INLINE gamUnionWith #-}

{-# LINE 294 "src/ehc/Gam/Base.chs" #-}
gamUnions :: Ord k => [Gam k v] -> Gam k v
gamUnions [] = emptyGam
gamUnions gs = foldr1 gamUnion gs

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Gam.Base
( emptyGam, gamMap, gamLookup, gamLookupDup, gamPushNew, gamPop, gamTop, gamAddGam, gamAdd, gamPushGam, gamToAssocL, gamToAssocDupL, assocLToGam, assocDupLToGam, gamKeys
, gamSingleton, gamInsert, gamUnion, gamUnions, gamFromAssocL
, assocLToGamWithDups
, gamToOnlyDups
, gamPartition
, gamMapElts
, gamMapThr
, gamUnzip
, gamElts
, gamNoDups
, Gam
, gamLookupMetaLev
, gamMetaLevSingleton
, gamUnionWith )
where
import Data.List
import UHC.Util.Utils
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.NameAspect
import qualified Data.Set as Set
import UHC.Light.Compiler.Opts.Base
import Data.Maybe
import qualified Data.Set as Set
import qualified Data.Map as Map
import UHC.Util.ScopeMapGam



















type Gam k v        =   SGam k v



emptyGam            ::            Gam k v
gamSingleton        ::            k -> v        -> Gam k v
gamLookup           ::  Ord k =>  k -> Gam k v  -> Maybe v
gamToAssocL         ::  Ord k =>  Gam k v       -> AssocL k v
gamPushNew          ::            Gam k v       -> Gam k v
gamPushGam          ::  Ord k =>  Gam k v       -> Gam k v -> Gam k v
gamPop              ::  Ord k =>  Gam k v       -> (Gam k v,Gam k v)
gamAddGam           ::  Ord k =>  Gam k v       -> Gam k v -> Gam k v
gamAdd              ::  Ord k =>  k -> v        -> Gam k v -> Gam k v
















gamLookupMetaLev :: Ord k => MetaLev -> k -> Gam k v -> Maybe v
gamLookupMetaLev mlev k g = fmap head $ gamLookupMetaLevDup mlev k g



gamToAssocL     g                   = [ (k,v) | (k,(v:_)) <- gamToAssocDupL g ]

gamLookup       k g                 = fmap head $ gamLookupDup k g
{-# INLINE gamLookup #-}

assocLToGam                         = gamUnions . map (uncurry gamSingleton)



emptyGam                            = emptySGam
{-# INLINE emptyGam #-}

gamSingleton                        = sgamSingleton
{-# INLINE gamSingleton #-}

gamPushNew                          = sgamPushNew
{-# INLINE gamPushNew #-}

gamPushGam                          = sgamPushGam
{-# INLINE gamPushGam #-}

gamPop                              = sgamPop
{-# INLINE gamPop #-}

gamAddGam                           = sgamUnion
{-# INLINE gamAddGam #-}

gamAdd          k v g               = sgamUnion (sgamSingleton k v) g
{-# INLINE gamAdd #-}



gamTop              ::  Ord k =>  Gam k v     -> Gam k v
assocLToGam         ::  Ord k =>  AssocL k v  -> Gam k v








gamTop                              = sgamTop
{-# INLINE gamTop #-}



gamMetaLevSingleton                        = sgamMetaLevSingleton
{-# INLINE gamMetaLevSingleton #-}








assocDupLToGam :: Ord k => AssocL k [v] -> Gam k v
assocDupLToGam = sgamFromAssocDupL
{-# INLINE assocDupLToGam #-}



assocLToGamWithDups :: Ord k => AssocL k v -> Gam k v
assocLToGamWithDups = assocDupLToGam . assocLGroupSort
{-# INLINE assocLToGamWithDups #-}









gamToAssocDupL :: Ord k => Gam k v -> AssocL k [v]
gamToAssocDupL = sgamToAssocDupL
{-# INLINE gamToAssocDupL #-}



gamToOnlyDups :: Ord k => Gam k v -> AssocL k [v]
gamToOnlyDups g = [ x | x@(n,(_:_:_)) <- gamToAssocDupL g ]








gamNoDups :: Ord k => Gam k v -> Gam k v
gamNoDups = sgamNoDups
{-# INLINE gamNoDups #-}








gamMap :: (Ord k,Ord k') => ((k,v) -> (k',v')) -> Gam k v -> Gam k' v'
gamMap = sgamMap
{-# INLINE gamMap #-}



gamMapElts :: Ord k => (v -> v') -> Gam k v -> Gam k v'
gamMapElts f = gamMap (\(n,v) -> (n,f v))
{-# INLINE gamMapElts #-}











gamPartition :: Ord k => (k -> v -> Bool) -> Gam k v -> (Gam k v,Gam k v)
gamPartition = sgamPartitionWithKey
{-# INLINE gamPartition #-}


















gamMapThr :: (Ord k,Ord k') => ((k,v) -> t -> ((k',v'),t)) -> t -> Gam k v -> (Gam k' v',t)
gamMapThr = sgamMapThr
{-# INLINE gamMapThr #-}



gamKeys :: Ord k => Gam k v -> [k]
gamKeys = assocLKeys . gamToAssocL
{-# INLINE gamKeys #-}



gamElts :: Ord k => Gam k v -> [v]
gamElts = assocLElts . gamToAssocL
{-# INLINE gamElts #-}








gamLookupMetaLevDup :: Ord k => MetaLev -> k -> Gam k v -> Maybe [v]
gamLookupMetaLevDup = sgamLookupMetaLevDup
{-# INLINE gamLookupMetaLevDup #-}

gamLookupDup :: Ord k => k -> Gam k v -> Maybe [v]
gamLookupDup = gamLookupMetaLevDup metaLevVal
{-# INLINE gamLookupDup #-}










gamUnzip :: Ord k => Gam k (v1,v2) -> (Gam k v1,Gam k v2)
gamUnzip g = sgamUnzip g
{-# INLINE gamUnzip #-}







gamInsert :: Ord k => k -> v -> Gam k v -> Gam k v
gamInsert = gamAdd
{-# INLINE gamInsert #-}

gamUnion :: Ord k => Gam k v -> Gam k v -> Gam k v
gamUnion = gamAddGam
{-# INLINE gamUnion #-}

gamFromAssocL ::  Ord k =>  AssocL k v  -> Gam k v
gamFromAssocL = assocLToGam
{-# INLINE gamFromAssocL #-}



gamUnionWith :: Ord k => (v -> [v] -> [v]) -> Gam k v -> Gam k v -> Gam k v
gamUnionWith cmb = sgamUnionWith (Just cmb)
{-# INLINE gamUnionWith #-}



gamUnions :: Ord k => [Gam k v] -> Gam k v
gamUnions [] = emptyGam
gamUnions gs = foldr1 gamUnion gs


</pre>