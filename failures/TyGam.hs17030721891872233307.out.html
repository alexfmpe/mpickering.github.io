<a href="TupleTH.hs1686378441473284781.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TyKiGam.hs1694794905194874527.out.html">next</a></br></br><pre>34c34
< {-# LINE 40 "src/ehc/Gam/TyGam.chs" #-}
---
> 
34a35
> 
34a36
> 
34a37
> 
34a38
> 
34a39
> 
42c47
< {-# LINE 51 "src/ehc/Gam/TyGam.chs" #-}
---
> 
42a48
> 
42a49
> 
42a50
> 
46c54
< {-# LINE 56 "src/ehc/Gam/TyGam.chs" #-}
---
> 
46a55
> 
50c59
< {-# LINE 61 "src/ehc/Gam/TyGam.chs" #-}
---
> 
50a60
> 
54c64
< {-# LINE 66 "src/ehc/Gam/TyGam.chs" #-}
---
> 
54a65
> 
60c71
< {-# LINE 75 "src/ehc/Gam/TyGam.chs" #-}
---
> 
60a72
> 
60a73
> 
60a74
> 
63c77
< {-# LINE 93 "src/ehc/Gam/TyGam.chs" #-}
---
> 
63a78
> 
63a79
> 
63a80
> 
63a81
> 
63a82
> 
63a83
> 
63a84
> 
63a85
> 
63a86
> 
63a87
> 
63a88
> 
63a89
> 
63a90
> 
63a91
> 
63a92
> 
70c99
< {-# LINE 116 "src/ehc/Gam/TyGam.chs" #-}
---
> 
70a100
> 
70a101
> 
70a102
> 
70a103
> 
70a104
> 
70a105
> 
70a106
> 
70a107
> 
70a108
> 
70a109
> 
70a110
> 
70a111
> 
70a112
> 
70a113
> 
70a114
> 
70a115
> 
74c119
< {-# LINE 142 "src/ehc/Gam/TyGam.chs" #-}
---
> 
74a120
> 
74a121
> 
74a122
> 
74a123
> 
74a124
> 
74a125
> 
74a126
> 
74a127
> 
74a128
> 
74a129
> 
74a130
> 
74a131
> 
74a132
> 
74a133
> 
74a134
> 
74a135
> 
74a136
> 
74a137
> 
74a138
> 
74a139
> 
74a140
> 
74a141
> 
90c157
< {-# LINE 218 "src/ehc/Gam/TyGam.chs" #-}
---
> 
90a158
> 
90a159
> 
90a160
> 
90a161
> 
90a162
> 
90a163
> 
90a164
> 
90a165
> 
90a166
> 
90a167
> 
90a168
> 
90a169
> 
90a170
> 
90a171
> 
90a172
> 
90a173
> 
90a174
> 
90a175
> 
90a176
> 
90a177
> 
90a178
> 
90a179
> 
90a180
> 
90a181
> 
90a182
> 
90a183
> 
90a184
> 
90a185
> 
90a186
> 
90a187
> 
90a188
> 
90a189
> 
90a190
> 
90a191
> 
90a192
> 
90a193
> 
90a194
> 
90a195
> 
90a196
> 
90a197
> 
90a198
> 
90a199
> 
90a200
> 
90a201
> 
90a202
> 
90a203
> 
90a204
> 
90a205
> 
90a206
> 
90a207
> 
90a208
> 
90a209
> 
90a210
> 
90a211
> 
90a212
> 
90a213
> 
90a214
> 
90a215
> 
90a216
> 
90a217
> 
98c225
< {-# LINE 229 "src/ehc/Gam/TyGam.chs" #-}
---
> 
98a226
> 
98a227
> 
98a228
> 
102c232
< {-# LINE 242 "src/ehc/Gam/TyGam.chs" #-}
---
> 
102a233
> 
102a234
> 
102a235
> 
102a236
> 
102a237
> 
102a238
> 
102a239
> 
102a240
> 
102a241
> 
105a245
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Gam.TyGam
( TyGamInfo (..)
, emptyTGI
, TyGam
, tyGamLookupErr
, mkTGIData
, mkTGI
, initTyGam
, tyGamLookup )
where
import UHC.Util.Pretty
import UHC.Util.Utils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Pretty
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Error
import qualified Data.Set as Set
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Ty.Trf.Quantify
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize







{-# LINE 40 "src/ehc/Gam/TyGam.chs" #-}
-- If this changes, also change {%{EH}ConfigInternalVersions}
data TyGamInfo
  = TyGamInfo
      { tgiTy :: !Ty
      }
      deriving Show

{-# LINE 51 "src/ehc/Gam/TyGam.chs" #-}
deriving instance Typeable TyGamInfo
deriving instance Data TyGamInfo

{-# LINE 56 "src/ehc/Gam/TyGam.chs" #-}
mkTGIData :: Ty -> Ty -> TyGamInfo
mkTGIData t _ = TyGamInfo t

{-# LINE 61 "src/ehc/Gam/TyGam.chs" #-}
mkTGI :: Ty -> TyGamInfo
mkTGI t = mkTGIData t Ty_Any

{-# LINE 66 "src/ehc/Gam/TyGam.chs" #-}
emptyTGI :: TyGamInfo
emptyTGI
  = TyGamInfo
      Ty_Any

{-# LINE 75 "src/ehc/Gam/TyGam.chs" #-}
type TyGam = Gam HsName TyGamInfo

{-# LINE 93 "src/ehc/Gam/TyGam.chs" #-}
tyGamLookupErr :: HsName -> TyGam -> (TyGamInfo,ErrL)
tyGamLookupErr n g
  = case tyGamLookup n g of
      Nothing  -> (emptyTGI,[rngLift emptyRange mkErr_NamesNotIntrod "type" [n]])
      Just tgi -> (tgi,[])

{-# LINE 116 "src/ehc/Gam/TyGam.chs" #-}
tyGamLookup :: HsName -> TyGam -> Maybe TyGamInfo
tyGamLookup = gamLookup

{-# LINE 142 "src/ehc/Gam/TyGam.chs" #-}
initTyGam :: TyGam
initTyGam
  = assocLToGam
      [ (hsnArrow           , mkTGI (appCon hsnArrow))
      , (hsnInt             , mkTGI tyInt)
      , (hsnChar            , mkTGI tyChar)
      , (hsnRow             , mkTGI (appCon hsnUnknown))
      , (hsnRec             , mkTGI (appCon hsnRec))
      , (hsnSum             , mkTGI (appCon hsnSum))
      , (hsnPrArrow         , mkTGI (appCon hsnPrArrow))
      , (hsnEqTilde         , mkTGI (appCon hsnEqTilde))
      , (hsnInteger         , mkTGI tyInteger       )
      , (hsnAddrUnboxed     , mkTGI (appCon hsnAddrUnboxed  )   )
      ]

{-# LINE 218 "src/ehc/Gam/TyGam.chs" #-}
instance VarUpdatable TyGamInfo VarMp where
  s `varUpd`  tgi         =   tgi { tgiTy = s `varUpd` tgiTy tgi }
  s `varUpdCyc` tgi         =   substLift tgiTy (\i x -> i {tgiTy = x}) varUpdCyc s tgi

instance VarExtractable TyGamInfo TyVarId where
  varFreeSet tgi         =   varFreeSet (tgiTy tgi)

{-# LINE 229 "src/ehc/Gam/TyGam.chs" #-}
instance PP TyGamInfo where
  pp tgi = ppTy (tgiTy tgi)

{-# LINE 242 "src/ehc/Gam/TyGam.chs" #-}
instance Serialize TyGamInfo where
  sput (TyGamInfo a) = sput a
  sget = liftM TyGamInfo sget
</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Gam.TyGam
( TyGamInfo (..)
, emptyTGI
, TyGam
, tyGamLookupErr
, mkTGIData
, mkTGI
, initTyGam
, tyGamLookup )
where
import UHC.Util.Pretty
import UHC.Util.Utils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Pretty
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Error
import qualified Data.Set as Set
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Ty.Trf.Quantify
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize













-- If this changes, also change {%{EH}ConfigInternalVersions}
data TyGamInfo
  = TyGamInfo
      { tgiTy :: !Ty
      }
      deriving Show





deriving instance Typeable TyGamInfo
deriving instance Data TyGamInfo



mkTGIData :: Ty -> Ty -> TyGamInfo
mkTGIData t _ = TyGamInfo t



mkTGI :: Ty -> TyGamInfo
mkTGI t = mkTGIData t Ty_Any



emptyTGI :: TyGamInfo
emptyTGI
  = TyGamInfo
      Ty_Any





type TyGam = Gam HsName TyGamInfo

















tyGamLookupErr :: HsName -> TyGam -> (TyGamInfo,ErrL)
tyGamLookupErr n g
  = case tyGamLookup n g of
      Nothing  -> (emptyTGI,[rngLift emptyRange mkErr_NamesNotIntrod "type" [n]])
      Just tgi -> (tgi,[])


















tyGamLookup :: HsName -> TyGam -> Maybe TyGamInfo
tyGamLookup = gamLookup
























initTyGam :: TyGam
initTyGam
  = assocLToGam
      [ (hsnArrow           , mkTGI (appCon hsnArrow))
      , (hsnInt             , mkTGI tyInt)
      , (hsnChar            , mkTGI tyChar)
      , (hsnRow             , mkTGI (appCon hsnUnknown))
      , (hsnRec             , mkTGI (appCon hsnRec))
      , (hsnSum             , mkTGI (appCon hsnSum))
      , (hsnPrArrow         , mkTGI (appCon hsnPrArrow))
      , (hsnEqTilde         , mkTGI (appCon hsnEqTilde))
      , (hsnInteger         , mkTGI tyInteger       )
      , (hsnAddrUnboxed     , mkTGI (appCon hsnAddrUnboxed  )   )
      ]






























































instance VarUpdatable TyGamInfo VarMp where
  s `varUpd`  tgi         =   tgi { tgiTy = s `varUpd` tgiTy tgi }
  s `varUpdCyc` tgi         =   substLift tgiTy (\i x -> i {tgiTy = x}) varUpdCyc s tgi

instance VarExtractable TyGamInfo TyVarId where
  varFreeSet tgi         =   varFreeSet (tgiTy tgi)





instance PP TyGamInfo where
  pp tgi = ppTy (tgiTy tgi)











instance Serialize TyGamInfo where
  sput (TyGamInfo a) = sput a
  sget = liftM TyGamInfo sget

</pre>