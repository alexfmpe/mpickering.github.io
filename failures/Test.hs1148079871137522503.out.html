<a href="test.hs1144108930470211272.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Test.hs11633137291122721015.out.html">next</a></br></br><pre>102d101
< -}
103a103
> 
110d109
< -}
111a111
> 
148d147
< -}
149a149
> 
157d156
< -}
158a158
> 
813a814
> 
</pre></br><h2>original</h2></br><pre>{-# OPTIONS_GHC -fglasgow-exts #-}
{-# LANGUAGE BangPatterns  #-}
{-# LANGUAGE TypeOperators #-}

--
-- Must have rules off, otherwise the fusion rules will replace the rhs
-- with the lhs, and we only end up testing lhs == lhs
--

import System.IO
import System.Environment
import Properties.Utils
import Debug.Trace

import qualified Data.Array.Vector as Test
import qualified Properties.Monomorphic.UVector     as Test         -- stream functions
import qualified Properties.Monomorphic.Base        as Spec         -- Data.List

import Data.Array.Vector.Stream
import Data.Array.Vector.Prim.Hyperstrict
import Data.Array.Vector

import Properties.Specific

import Data.Word
import Data.Int
import Data.Complex
import Data.Ratio

--
-- Data.Stream <=> Data.List
--

------------------------------------------------------------------------
-- * Basic interface

prop_cons       = Test.cons      `eq2`           (Spec.cons)
prop_snoc       = Test.snoc      `eq2`           (\xs x -> xs Spec.++ [x])
prop_empty      = Test.empty     `eq0`           (Spec.empty)
prop_singleton  = Test.singleton `eq1`           (\x -> Spec.cons x [])
prop_head       = Test.head     `eqnotnull1`    Spec.head
prop_append     = Test.append   `eq2`           (Spec.++)
prop_tail       = Test.tail     `eqnotnull1`    Spec.tail
prop_null       = Test.null     `eq1`           Spec.null
prop_init       = Test.init     `eqnotnull1`    Spec.init
prop_last       = Test.last     `eqnotnull1`    Spec.last
prop_length     = Test.length   `eq1`           Spec.length

------------------------------------------------------------------------
-- * List transformations

prop_map    = Test.map `eq2` Spec.map

{-
-- prop_reverse            = Test.reverse          `eq1`   Spec.reverse
prop_intersperse        = Test.intersperse      `eq2`   Spec.intersperse
prop_intercalate        = Test.intercalate      `eq2`   Spec.intercalate
-- prop_transpose          = Test.transpose        `eq1`   Spec.transpose
-}

------------------------------------------------------------------------
-- * Reducing lists (folds)

prop_foldl      = Test.foldl            `eq3`   Spec.foldl

prop_foldl1     = Test.foldl1   `eqnotnull2`    Spec.foldl1 -- n.b.

{-
prop_foldl'     = Test.foldl'           `eq3`   Spec.foldl'
prop_foldl1'    = Test.foldl1'  `eqnotnull2`    Spec.foldl1' -- n.b.

prop_foldr      = Test.foldr            `eq3`   Spec.foldr
prop_foldr1     = Test.foldr1   `eqnotnull2`    Spec.foldr1

------------------------------------------------------------------------
-- ** Special folds

-- prop_concat     = Test.concat           `eq1`   Spec.concat
prop_concatMap  = Test.concatMap        `eq2`   Spec.concatMap
-}
prop_and        = Test.and              `eq1`   Spec.and
prop_or         = Test.or               `eq1`   Spec.or
prop_any        = Test.any              `eq2`   Spec.any
prop_all        = Test.all              `eq2`   Spec.all
prop_sum        = Test.sum              `eq1`   Spec.sum
prop_product    = Test.product          `eq1`   Spec.product
prop_maximum    = Test.maximum  `eqnotnull1`    Spec.maximum
prop_minimum    = Test.minimum  `eqnotnull1`    Spec.minimum

------------------------------------------------------------------------
-- * Building lists
-- ** Scans

prop_scanl      = Test.scanl `eq3` (\f x xs -> Spec.init $ Spec.scanl f x xs)
prop_scanl1     = Test.scanl1 `eqnotnull2` Spec.scanl1

{-
-- prop_scanr      = Test.scanr            `eq3`   Spec.scanr

{-
prop_scanr1     = Test.scanr1           `eq2`   Spec.scanr1
-}

------------------------------------------------------------------------
-- ** Accumulating maps

{-
prop_mapAccumL  = Test.mapAccumL        `eq3`   Spec.mapAccumL
prop_mapAccumR  = Test.mapAccumR        `eq3`   Spec.mapAccumR
-}

------------------------------------------------------------------------
-- ** Infinite lists

prop_iterate    = Test.iterate          `eqfinite2`     Spec.iterate
prop_repeat     = Test.repeat           `eqfinite1`     Spec.repeat
-}
prop_iterate    = \x -> x >= 0 ==> Test.iterate x `eq2` ((Spec.take x .) . Spec.iterate)
prop_replicate  = \x -> x >= 0 ==> Test.replicate x      `eq1` Spec.replicate x

{-
prop_cycle      = \x -> not (null x) ==>
                  (Test.cycle           `eqfinite1`     Spec.cycle) x
-}
------------------------------------------------------------------------

-- ** Unfolding

prop_unfoldr    = \x -> x >= 0 ==> Test.unfoldr x `eq2` ((Spec.take x .) . Spec.unfoldr)

------------------------------------------------------------------------
-- * Sublists
-- ** Extracting sublists

prop_take       = Test.take             `eq2`   Spec.take
prop_drop       = Test.drop             `eq2`   Spec.drop
prop_splitAt    = Test.splitAt          `eq2`   Spec.splitAt
prop_takeWhile  = Test.takeWhile        `eq2`   Spec.takeWhile
prop_dropWhile  = Test.dropWhile        `eq2`   Spec.dropWhile

{-
{-
prop_span       = Test.span             `eq2`   Spec.span
prop_break      = Test.break            `eq2`   Spec.break
prop_group      = Test.group            `eq1`   Spec.group
prop_inits      = Test.inits            `eq1`   Spec.inits
prop_tails      = Test.tails            `eq1`   Spec.tails
-}

------------------------------------------------------------------------
-- * Predicates

prop_isPrefixOf  = Test.isPrefixOf       `eq2`   Spec.isPrefixOf
{-
prop_isSuffixOf  = Test.isSuffixOf       `eq2`   Spec.isSuffixOf
prop_isInfixOf   = Test.isInfixOf        `eq2`   Spec.isInfixOf
-}

------------------------------------------------------------------------
-- * Searching lists
-- ** Searching by equality
-}

prop_elem       = Test.elem             `eq2`   Spec.elem
prop_notElem    = Test.notElem          `eq2`   Spec.notElem -- no specific implementation

prop_lookup a xs= Test.lookup a xs == Spec.lookup a (map unpairS . fromU $ xs)

------------------------------------------------------------------------
-- ** Searching with a predicate


prop_find       = Test.find             `eq2`   Spec.find
prop_filter     = Test.filter           `eq2`   Spec.filter

{-
-- prop_partition  = Test.partition        `eq2`   Spec.partition
-}

------------------------------------------------------------------------
-- * Indexing lists

prop_index              = \xs n -> n >= 0 && n < Test.length xs ==>
        (Test.index `eq2` Spec.index) xs n

prop_findIndex          = Test.findIndex        `eq2`   Spec.findIndex
{-
prop_elemIndex          = Test.elemIndex        `eq2`   Spec.elemIndex
prop_elemIndices        = Test.elemIndices      `eq2`   Spec.elemIndices
prop_findIndices        = Test.findIndices      `eq2`   Spec.findIndices
-}

------------------------------------------------------------------------
-- * Zipping and unzipping lists

-- To not be this ugly, we would need to define a NatTrans instance for UArr to [],
-- which requires a Functor instance on UArr, which seems currently impossible
-- due to the UA restriction on the UArr elements. RFunctor could work, but we'd
-- need to rewire quickcheck to use that, so this is probably easier.
--
prop_zip (ELUArrs a b) = (map unpairS . fromU $ Test.zip a b) == Spec.zip (fromU a) (fromU b)
prop_zip3 (ELUArrs3 a b c) = (map (\(x :*: y :*: z) -> (x, y, z)) . fromU $ Test.zip3 a b c) == Spec.zip3 (fromU a) (fromU b) (fromU c)

prop_zipWith f (ELUArrs a b) = (fromU $ Test.zipWith f a b) == Spec.zipWith f (fromU a) (fromU b)
prop_zipWith3 f (ELUArrs3 a b c) = (fromU $ Test.zipWith3 f a b c) == Spec.zipWith3 f (fromU a) (fromU b) (fromU c)

{-
prop_zip4       = Test.zip4             `eq4`   Spec.zip4
prop_zip5       = Test.zip5             `eq5`   Spec.zip5
prop_zip6       = Test.zip6             `eq6`   Spec.zip6
prop_zip7       = Test.zip7             `eq7`   Spec.zip7
prop_zipWith4   = Test.zipWith4         `eq5`   Spec.zipWith4
prop_zipWith5   = Test.zipWith5         `eq6`   Spec.zipWith5
prop_zipWith6   = Test.zipWith6         `eq7`   Spec.zipWith6
prop_zipWith7   = Test.zipWith7         `eq8`   Spec.zipWith7
-}

------------------------------------------------------------------------

prop_unzip  xs  = ((\(x :*: y) -> (fromU x, fromU y)) . Test.unzip $ (toU . map pairS $ xs)) == Spec.unzip xs
prop_unzip3 xs  = ((\(x :*: y :*: z) -> (fromU x, fromU y, fromU z)) . Test.unzip3 $ (toU . map (\(x, y, z) -> (x :*: y :*: z)) $ xs)) == Spec.unzip3 xs

{-
prop_unzip4     = Test.unzip4           `eq1`   Spec.unzip4
prop_unzip5     = Test.unzip5           `eq1`   Spec.unzip5
prop_unzip6     = Test.unzip6           `eq1`   Spec.unzip6
prop_unzip7     = Test.unzip7           `eq1`   Spec.unzip7
-}

------------------------------------------------------------------------
-- * Special lists
-- ** Functions on strings
-- prop_unlines    = Test.unlines          `eq1`   Spec.unlines
-- prop_lines      = Test.lines            `eq1`   Spec.lines

{-
prop_words      = Test.words            `eq1`   Spec.words
prop_unwords    = Test.unwords          `eq1`   Spec.unwords
-}

------------------------------------------------------------------------
-- ** \"Set\" operations

{-
prop_nub        = Test.nub              `eq1`   Spec.nub
prop_delete     = Test.delete           `eq2`   Spec.delete
prop_difference = (Test.\)             `eq2`   (Spec.\)
prop_union      = Test.union            `eq2`   Spec.union
prop_intersect  = Test.intersect        `eq2`   Spec.intersect
-}

------------------------------------------------------------------------
-- ** Ordered lists

{-
prop_sort       = Test.sort             `eq1`   Spec.sort
prop_insert     = Test.insert           `eq2`   Spec.insert
-}

------------------------------------------------------------------------
-- * Generalized functions
-- ** The \"By\" operations
-- *** User-supplied equality (replacing an Eq context)

{-
prop_nubBy              = Test.nubBy            `eq2`   Spec.nubBy
prop_deleteBy           = Test.deleteBy         `eq3`   Spec.deleteBy
prop_deleteFirstsBy     = Test.deleteFirstsBy   `eq3`   Spec.deleteFirstsBy
prop_unionBy            = Test.unionBy          `eq3`   Spec.unionBy
prop_intersectBy        = Test.intersectBy      `eq3`   Spec.intersectBy
prop_groupBy            = Test.groupBy          `eq2`   Spec.groupBy
-}

------------------------------------------------------------------------
-- *** User-supplied comparison (replacing an Ord context)

{-
prop_sortBy             = Test.sortBy           `eq2`           Spec.sortBy
-}
{-
prop_insertBy           = Test.insertBy         `eq3`           Spec.insertBy
-}


prop_maximumBy          = Test.maximumBy        `eqnotnull2`    Spec.maximumBy
prop_minimumBy          = Test.minimumBy        `eqnotnull2`    Spec.minimumBy

{-
------------------------------------------------------------------------
-- * The \"generic\" operations

prop_genericLength      = Test.genericLength    `eq1`   Spec.genericLength
prop_genericTake        = \i -> i >= I 0 ==>
                          (Test.genericTake     `eq2`   Spec.genericTake) i
prop_genericDrop        = \i -> i >= I 0 ==>
                          (Test.genericDrop     `eq2`   Spec.genericDrop) i
prop_genericIndex       = \xs i -> i >= I 0 && i < Spec.genericLength xs ==>
                          (Test.genericIndex    `eq2`   Spec.genericIndex) xs i
prop_genericSplitAt     = \i -> i >= I 0 ==>
                          (Test.genericSplitAt  `eq2`   Spec.genericSplitAt) i
prop_genericReplicate   = \i -> i >= I 0 ==>
                          (Test.genericReplicate        `eq2`   Spec.genericReplicate) i
-}

------------------------------------------------------------------------


main = do
  x <- getArgs
  let opts' = case x of
                    [n] -> opts { no_of_tests = read n }
                    _   -> opts

  hSetBuffering stdout NoBuffering
  putStrLn "Testing: Data.Array.Vector <=> Data.List"
  putStrLn "==================================\n"

  runTests "Extras" opts'
    [-- run prop_repeatU_model
    ]

  runTests "Basic interface" opts'
    [run prop_cons
    ,run prop_snoc
    ,run prop_empty
    ,run prop_singleton
    ,run prop_head
    ,run prop_append
    ,run prop_tail
    ,run prop_null
    ,run prop_init
    ,run prop_last
    ,run prop_length
    ]

  runTests "Array transformations" opts'
    [run prop_map
    {-
--  ,run prop_reverse
    ,run prop_intersperse
    ,run prop_intercalate
--  ,run prop_transpose
-}
    ]

  runTests "Reducing arrays (folds)" opts'
    [run prop_foldl
--  ,run prop_foldr

    ,run prop_foldl1
--  ,run prop_foldl'
--  ,run prop_foldl1'
--  ,run prop_foldr1
    ,run prop_foldl1MaybeU
    ,run prop_fold1MaybeU
    ,run prop_mapAccumLU
    ]

  runTests "Special folds" opts'
    [
--   run prop_concat,
--   run prop_concatMap
     run prop_and
    ,run prop_or
    ,run prop_any
    ,run prop_all
    ,run prop_sum
    ,run prop_product
    ,run prop_maximum
    ,run prop_minimum
    ]

  runTests "Scans" opts'
    [run prop_scanl
    ,run prop_scanl1
    ,run prop_scanResU
    ,run prop_scanU
    ,run prop_scan1U
--  ,run prop_scanr
--  ,run prop_scanr1
    ]

{-
  runTests "Accumulating maps" opts'
    [run prop_mapAccumL
    ,run prop_mapAccumR
    ]
-}

  runTests "Generating arrays" opts'
    [run prop_iterate
    ,run prop_repeatU
    ,run prop_replicate
    ,run prop_replicateEachU
    ,run prop_unitsU
    ,run prop_packU
    ,run prop_combineU
    -- ,run prop_cycle
    ]


  runTests "Unfolding" opts'
    [run prop_unfoldr
    ]


  runTests "Extracting subarrays" opts'
    [run prop_take
    ,run prop_drop
    ,run prop_splitAt
    ,run prop_takeWhile
    ,run prop_dropWhile
--  ,run prop_span
--  ,run prop_break
--  ,run prop_group
--  ,run prop_inits
--  ,run prop_tails
    ]

{-
  runTests "Predicates" opts'
    [run prop_isPrefixOf
    ,run prop_isSuffixOf
    ,run prop_isInfixOf
    ]
-}

  runTests "Searching by equality" opts'
    [run prop_elem
    ,run prop_notElem-- no specific implementation
    ,run prop_lookup
    ]

  runTests "Searching by a predicate" opts'
    [run prop_filter
    ,run prop_find
--  ,run prop_partition
    ]

  runTests "Indexing arrays" opts'
    [run prop_index
    ,run prop_indexedU
    ,run prop_findIndex
--  ,run prop_elemIndex
--  ,run prop_elemIndices
--  ,run prop_findIndices
    ]

  runTests "Zipping" opts'
    [run prop_zip
    ,run prop_zip3
--  ,run prop_zip4
--  ,run prop_zip5
--  ,run prop_zip6
--  ,run prop_zip7
    ,run prop_zipWith
    ,run prop_zipWith3
--  ,run prop_zipWith4
--  ,run prop_zipWith5
--  ,run prop_zipWith6
--  ,run prop_zipWith7
    ]

  runTests "Unzipping" opts'
    [run prop_fstU
    ,run prop_sndU
    ,run prop_unzip
    ,run prop_unzip3
--  ,run prop_unzip4
--  ,run prop_unzip5
--  ,run prop_unzip6
--  ,run prop_unzip7
    ]

{-
  runTests "Functions on strings" opts'
    [run prop_unlines
    ,run prop_lines
    ,run prop_words
    ,run prop_unwords
    ]
-}

{-
  runTests "\"Set\" operations" opts'
    [run prop_nub
    ,run prop_delete
    ,run prop_difference
    ,run prop_union
    ,run prop_intersect
    ]
-}

{-
  runTests "Ordered lists" opts'
    [run prop_sort
    ,run prop_insert
    ]
-}

{-
  runTests "Eq style \"By\" operations" opts'
    [run prop_nubBy
    ,run prop_deleteBy
    ,run prop_deleteFirstsBy
    ,run prop_unionBy
    ,run prop_intersectBy
    ,run prop_groupBy
    ]
-}

  runTests "Ord style \"By\" operations" opts'
    [
--  ,run prop_insertBy
--  ,run prop_sortBy        -- note issue here.
     run prop_maximumBy
    ,run prop_minimumBy
    ]

  runTests "Enumerated arrays" opts'
    [run prop_enumFromToU
    ,run prop_enumFromToFracU
    ,run prop_enumFromThenToU
    ,run prop_enumFromStepLenU
    ,run prop_enumFromToEachU
    ]

  runTests "Mutable arrays" opts'
    [run prop_unsafeFreezeAllMU
    ,run prop_newU
    ,run prop_unsafeZipMU
    ,run prop_unsafeUnzipMU
    ]

  runTests "Hyperstrict" opts'
    [run prop_fstS
    ,run prop_sndS
    ,run prop_pairS
    ,run prop_unpairS
    ,run prop_curryS
    ,run prop_uncurryS
    ,run prop_unsafePairS
    ,run prop_unsafeUnpairS
    ,run prop_maybeS
    ,run prop_fromMaybeS
    ,run prop_functorMaybeS
    ]

  runTests "Text output" opts'
    [run prop_show_read
    ]

  -- These are a little overkillish (and should be generated by TH, probably)

  runTests "()-specific" opts'
    [run (prop_lengthU :: UArr () -> Bool)
    ,run (prop_indexU :: UArr () -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex () -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr () -> Bool)
    ,run (prop_readMU :: UArr () -> Int -> Property)
    ,run (prop_writeMU :: UArr () -> Int -> () -> Property)
    ,run (prop_unsafeFreezeMU :: UArr () -> Int -> Property)
    ,run (prop_memcpyMU :: UArr () -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr () -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr () -> Property)
    ]

  runTests "(a :*: b)-specific" opts'
    [run (prop_lengthU :: UArr (A :*: B) -> Bool)
    ,run (prop_indexU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (A :*: B) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (A :*: B) -> Bool)
    ,run (prop_readMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_writeMU :: UArr (A :*: B) -> Int -> (A :*: B) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (A :*: B) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (A :*: B) -> Property)
    ]

  runTests "Bool-specific" opts'
    [run (prop_lengthU :: UArr Bool -> Bool)
    ,run (prop_indexU :: UArr Bool -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Bool -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Bool -> Bool)
    ,run (prop_readMU :: UArr Bool -> Int -> Property)
    ,run (prop_writeMU :: UArr Bool -> Int -> Bool -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Bool -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Bool -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Bool -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Bool -> Property)
    ,run (prop_hPutU_hGetU :: UArr Bool -> Bool)
    ]

  runTests "Char-specific" opts'
    [run (prop_lengthU :: UArr Char -> Bool)
    ,run (prop_indexU :: UArr Char -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Char -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Char -> Bool)
    ,run (prop_readMU :: UArr Char -> Int -> Property)
    ,run (prop_writeMU :: UArr Char -> Int -> Char -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Char -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Char -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Char -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Char -> Property)
    ,run (prop_hPutU_hGetU :: UArr Char -> Bool)
    ]

  runTests "Int-specific" opts'
    [run (prop_lengthU :: UArr Int -> Bool)
    ,run (prop_indexU :: UArr Int -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int -> Bool)
    ,run (prop_readMU :: UArr Int -> Int -> Property)
    ,run (prop_writeMU :: UArr Int -> Int -> Int -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int -> Bool)
    ]

  runTests "Word-specific" opts'
    [run (prop_lengthU :: UArr Word -> Bool)
    ,run (prop_indexU :: UArr Word -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word -> Bool)
    ,run (prop_readMU :: UArr Word -> Int -> Property)
    ,run (prop_writeMU :: UArr Word -> Int -> Word -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word -> Bool)
    ]

  runTests "Float-specific" opts'
    [run (prop_lengthU :: UArr Float -> Bool)
    ,run (prop_indexU :: UArr Float -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Float -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Float -> Bool)
    ,run (prop_readMU :: UArr Float -> Int -> Property)
    ,run (prop_writeMU :: UArr Float -> Int -> Float -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Float -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Float -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Float -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Float -> Property)
    ,run (prop_hPutU_hGetU :: UArr Float -> Bool)
    ]

  runTests "Double-specific" opts'
    [run (prop_lengthU :: UArr Double -> Bool)
    ,run (prop_indexU :: UArr Double -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Double -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Double -> Bool)
    ,run (prop_readMU :: UArr Double -> Int -> Property)
    ,run (prop_writeMU :: UArr Double -> Int -> Double -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Double -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Double -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Double -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Double -> Property)
    ,run (prop_hPutU_hGetU :: UArr Double -> Bool)
    ]

  runTests "Word8-specific" opts'
    [run (prop_lengthU :: UArr Word8 -> Bool)
    ,run (prop_indexU :: UArr Word8 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word8 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word8 -> Bool)
    ,run (prop_readMU :: UArr Word8 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word8 -> Int -> Word8 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word8 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word8 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word8 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word8 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word8 -> Bool)
    ]

  runTests "Word16-specific" opts'
    [run (prop_lengthU :: UArr Word16 -> Bool)
    ,run (prop_indexU :: UArr Word16 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word16 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word16 -> Bool)
    ,run (prop_readMU :: UArr Word16 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word16 -> Int -> Word16 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word16 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word16 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word16 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word16 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word16 -> Bool)
    ]

  runTests "Word32-specific" opts'
    [run (prop_lengthU :: UArr Word32 -> Bool)
    ,run (prop_indexU :: UArr Word32 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word32 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word32 -> Bool)
    ,run (prop_readMU :: UArr Word32 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word32 -> Int -> Word32 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word32 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word32 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word32 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word32 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word32 -> Bool)
    ]

  runTests "Word64-specific" opts'
    [run (prop_lengthU :: UArr Word64 -> Bool)
    ,run (prop_indexU :: UArr Word64 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word64 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word64 -> Bool)
    ,run (prop_readMU :: UArr Word64 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word64 -> Int -> Word64 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word64 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word64 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word64 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word64 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word64 -> Bool)
    ]

  runTests "Int8-specific" opts'
    [run (prop_lengthU :: UArr Int8 -> Bool)
    ,run (prop_indexU :: UArr Int8 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int8 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int8 -> Bool)
    ,run (prop_readMU :: UArr Int8 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int8 -> Int -> Int8 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int8 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int8 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int8 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int8 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int8 -> Bool)
    ]

  runTests "Int16-specific" opts'
    [run (prop_lengthU :: UArr Int16 -> Bool)
    ,run (prop_indexU :: UArr Int16 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int16 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int16 -> Bool)
    ,run (prop_readMU :: UArr Int16 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int16 -> Int -> Int16 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int16 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int16 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int16 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int16 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int16 -> Bool)
    ]

  runTests "Int32-specific" opts'
    [run (prop_lengthU :: UArr Int32 -> Bool)
    ,run (prop_indexU :: UArr Int32 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int32 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int32 -> Bool)
    ,run (prop_readMU :: UArr Int32 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int32 -> Int -> Int32 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int32 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int32 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int32 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int32 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int32 -> Bool)
    ]

  runTests "Int64-specific" opts'
    [run (prop_lengthU :: UArr Int64 -> Bool)
    ,run (prop_indexU :: UArr Int64 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int64 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int64 -> Bool)
    ,run (prop_readMU :: UArr Int64 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int64 -> Int -> Int64 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int64 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int64 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int64 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int64 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int64 -> Bool)
    ]

  runTests "Complex-specific" opts'
    [run (prop_lengthU :: UArr (Complex Double) -> Bool)
    ,run (prop_indexU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (Complex Double) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (Complex Double) -> Bool)
    ,run (prop_readMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_writeMU :: UArr (Complex Double) -> Int -> (Complex Double) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (Complex Double) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (Complex Double) -> Property)
    --,run (prop_hPutU_hGetU :: UArr (Complex Float) -> Bool)
    ]

  runTests "Ratio-specific" opts'
    [run (prop_lengthU :: UArr (Ratio Int) -> Bool)
    ,run (prop_indexU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (Ratio Int) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (Ratio Int) -> Bool)
    ,run (prop_readMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_writeMU :: UArr (Ratio Int) -> Int -> (Ratio Int) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (Ratio Int) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (Ratio Int) -> Property)
    --,run (prop_hPutU_hGetU :: UArr (Ratio Int) -> Bool)
    ]
{-
  runTests "The \"generic\" operations" opts'
    [run prop_genericLength
    ,run prop_genericTake
    ,run prop_genericDrop
    ,run prop_genericIndex
    ,run prop_genericSplitAt
    ,run prop_genericReplicate
    ]
-}
</pre></br><h2>printed</h2></br><pre>{-# OPTIONS_GHC -fglasgow-exts #-}
{-# LANGUAGE BangPatterns  #-}
{-# LANGUAGE TypeOperators #-}

--
-- Must have rules off, otherwise the fusion rules will replace the rhs
-- with the lhs, and we only end up testing lhs == lhs
--

import System.IO
import System.Environment
import Properties.Utils
import Debug.Trace

import qualified Data.Array.Vector as Test
import qualified Properties.Monomorphic.UVector     as Test         -- stream functions
import qualified Properties.Monomorphic.Base        as Spec         -- Data.List

import Data.Array.Vector.Stream
import Data.Array.Vector.Prim.Hyperstrict
import Data.Array.Vector

import Properties.Specific

import Data.Word
import Data.Int
import Data.Complex
import Data.Ratio

--
-- Data.Stream <=> Data.List
--

------------------------------------------------------------------------
-- * Basic interface

prop_cons       = Test.cons      `eq2`           (Spec.cons)
prop_snoc       = Test.snoc      `eq2`           (\xs x -> xs Spec.++ [x])
prop_empty      = Test.empty     `eq0`           (Spec.empty)
prop_singleton  = Test.singleton `eq1`           (\x -> Spec.cons x [])
prop_head       = Test.head     `eqnotnull1`    Spec.head
prop_append     = Test.append   `eq2`           (Spec.++)
prop_tail       = Test.tail     `eqnotnull1`    Spec.tail
prop_null       = Test.null     `eq1`           Spec.null
prop_init       = Test.init     `eqnotnull1`    Spec.init
prop_last       = Test.last     `eqnotnull1`    Spec.last
prop_length     = Test.length   `eq1`           Spec.length

------------------------------------------------------------------------
-- * List transformations

prop_map    = Test.map `eq2` Spec.map

{-
-- prop_reverse            = Test.reverse          `eq1`   Spec.reverse
prop_intersperse        = Test.intersperse      `eq2`   Spec.intersperse
prop_intercalate        = Test.intercalate      `eq2`   Spec.intercalate
-- prop_transpose          = Test.transpose        `eq1`   Spec.transpose
-}

------------------------------------------------------------------------
-- * Reducing lists (folds)

prop_foldl      = Test.foldl            `eq3`   Spec.foldl

prop_foldl1     = Test.foldl1   `eqnotnull2`    Spec.foldl1 -- n.b.

{-
prop_foldl'     = Test.foldl'           `eq3`   Spec.foldl'
prop_foldl1'    = Test.foldl1'  `eqnotnull2`    Spec.foldl1' -- n.b.

prop_foldr      = Test.foldr            `eq3`   Spec.foldr
prop_foldr1     = Test.foldr1   `eqnotnull2`    Spec.foldr1

------------------------------------------------------------------------
-- ** Special folds

-- prop_concat     = Test.concat           `eq1`   Spec.concat
prop_concatMap  = Test.concatMap        `eq2`   Spec.concatMap
-}
prop_and        = Test.and              `eq1`   Spec.and
prop_or         = Test.or               `eq1`   Spec.or
prop_any        = Test.any              `eq2`   Spec.any
prop_all        = Test.all              `eq2`   Spec.all
prop_sum        = Test.sum              `eq1`   Spec.sum
prop_product    = Test.product          `eq1`   Spec.product
prop_maximum    = Test.maximum  `eqnotnull1`    Spec.maximum
prop_minimum    = Test.minimum  `eqnotnull1`    Spec.minimum

------------------------------------------------------------------------
-- * Building lists
-- ** Scans

prop_scanl      = Test.scanl `eq3` (\f x xs -> Spec.init $ Spec.scanl f x xs)
prop_scanl1     = Test.scanl1 `eqnotnull2` Spec.scanl1

{-
-- prop_scanr      = Test.scanr            `eq3`   Spec.scanr

{-
prop_scanr1     = Test.scanr1           `eq2`   Spec.scanr1


------------------------------------------------------------------------
-- ** Accumulating maps

{-
prop_mapAccumL  = Test.mapAccumL        `eq3`   Spec.mapAccumL
prop_mapAccumR  = Test.mapAccumR        `eq3`   Spec.mapAccumR


------------------------------------------------------------------------
-- ** Infinite lists

prop_iterate    = Test.iterate          `eqfinite2`     Spec.iterate
prop_repeat     = Test.repeat           `eqfinite1`     Spec.repeat
-}
prop_iterate    = \x -> x >= 0 ==> Test.iterate x `eq2` ((Spec.take x .) . Spec.iterate)
prop_replicate  = \x -> x >= 0 ==> Test.replicate x      `eq1` Spec.replicate x

{-
prop_cycle      = \x -> not (null x) ==>
                  (Test.cycle           `eqfinite1`     Spec.cycle) x
-}
------------------------------------------------------------------------

-- ** Unfolding

prop_unfoldr    = \x -> x >= 0 ==> Test.unfoldr x `eq2` ((Spec.take x .) . Spec.unfoldr)

------------------------------------------------------------------------
-- * Sublists
-- ** Extracting sublists

prop_take       = Test.take             `eq2`   Spec.take
prop_drop       = Test.drop             `eq2`   Spec.drop
prop_splitAt    = Test.splitAt          `eq2`   Spec.splitAt
prop_takeWhile  = Test.takeWhile        `eq2`   Spec.takeWhile
prop_dropWhile  = Test.dropWhile        `eq2`   Spec.dropWhile

{-
{-
prop_span       = Test.span             `eq2`   Spec.span
prop_break      = Test.break            `eq2`   Spec.break
prop_group      = Test.group            `eq1`   Spec.group
prop_inits      = Test.inits            `eq1`   Spec.inits
prop_tails      = Test.tails            `eq1`   Spec.tails


------------------------------------------------------------------------
-- * Predicates

prop_isPrefixOf  = Test.isPrefixOf       `eq2`   Spec.isPrefixOf
{-
prop_isSuffixOf  = Test.isSuffixOf       `eq2`   Spec.isSuffixOf
prop_isInfixOf   = Test.isInfixOf        `eq2`   Spec.isInfixOf


------------------------------------------------------------------------
-- * Searching lists
-- ** Searching by equality
-}

prop_elem       = Test.elem             `eq2`   Spec.elem
prop_notElem    = Test.notElem          `eq2`   Spec.notElem -- no specific implementation

prop_lookup a xs= Test.lookup a xs == Spec.lookup a (map unpairS . fromU $ xs)

------------------------------------------------------------------------
-- ** Searching with a predicate


prop_find       = Test.find             `eq2`   Spec.find
prop_filter     = Test.filter           `eq2`   Spec.filter

{-
-- prop_partition  = Test.partition        `eq2`   Spec.partition
-}

------------------------------------------------------------------------
-- * Indexing lists

prop_index              = \xs n -> n >= 0 && n < Test.length xs ==>
        (Test.index `eq2` Spec.index) xs n

prop_findIndex          = Test.findIndex        `eq2`   Spec.findIndex
{-
prop_elemIndex          = Test.elemIndex        `eq2`   Spec.elemIndex
prop_elemIndices        = Test.elemIndices      `eq2`   Spec.elemIndices
prop_findIndices        = Test.findIndices      `eq2`   Spec.findIndices
-}

------------------------------------------------------------------------
-- * Zipping and unzipping lists

-- To not be this ugly, we would need to define a NatTrans instance for UArr to [],
-- which requires a Functor instance on UArr, which seems currently impossible
-- due to the UA restriction on the UArr elements. RFunctor could work, but we'd
-- need to rewire quickcheck to use that, so this is probably easier.
--
prop_zip (ELUArrs a b) = (map unpairS . fromU $ Test.zip a b) == Spec.zip (fromU a) (fromU b)
prop_zip3 (ELUArrs3 a b c) = (map (\(x :*: y :*: z) -> (x, y, z)) . fromU $ Test.zip3 a b c) == Spec.zip3 (fromU a) (fromU b) (fromU c)

prop_zipWith f (ELUArrs a b) = (fromU $ Test.zipWith f a b) == Spec.zipWith f (fromU a) (fromU b)
prop_zipWith3 f (ELUArrs3 a b c) = (fromU $ Test.zipWith3 f a b c) == Spec.zipWith3 f (fromU a) (fromU b) (fromU c)

{-
prop_zip4       = Test.zip4             `eq4`   Spec.zip4
prop_zip5       = Test.zip5             `eq5`   Spec.zip5
prop_zip6       = Test.zip6             `eq6`   Spec.zip6
prop_zip7       = Test.zip7             `eq7`   Spec.zip7
prop_zipWith4   = Test.zipWith4         `eq5`   Spec.zipWith4
prop_zipWith5   = Test.zipWith5         `eq6`   Spec.zipWith5
prop_zipWith6   = Test.zipWith6         `eq7`   Spec.zipWith6
prop_zipWith7   = Test.zipWith7         `eq8`   Spec.zipWith7
-}

------------------------------------------------------------------------

prop_unzip  xs  = ((\(x :*: y) -> (fromU x, fromU y)) . Test.unzip $ (toU . map pairS $ xs)) == Spec.unzip xs
prop_unzip3 xs  = ((\(x :*: y :*: z) -> (fromU x, fromU y, fromU z)) . Test.unzip3 $ (toU . map (\(x, y, z) -> (x :*: y :*: z)) $ xs)) == Spec.unzip3 xs

{-
prop_unzip4     = Test.unzip4           `eq1`   Spec.unzip4
prop_unzip5     = Test.unzip5           `eq1`   Spec.unzip5
prop_unzip6     = Test.unzip6           `eq1`   Spec.unzip6
prop_unzip7     = Test.unzip7           `eq1`   Spec.unzip7
-}

------------------------------------------------------------------------
-- * Special lists
-- ** Functions on strings
-- prop_unlines    = Test.unlines          `eq1`   Spec.unlines
-- prop_lines      = Test.lines            `eq1`   Spec.lines

{-
prop_words      = Test.words            `eq1`   Spec.words
prop_unwords    = Test.unwords          `eq1`   Spec.unwords
-}

------------------------------------------------------------------------
-- ** \"Set\" operations

{-
prop_nub        = Test.nub              `eq1`   Spec.nub
prop_delete     = Test.delete           `eq2`   Spec.delete
prop_difference = (Test.\)             `eq2`   (Spec.\)
prop_union      = Test.union            `eq2`   Spec.union
prop_intersect  = Test.intersect        `eq2`   Spec.intersect
-}

------------------------------------------------------------------------
-- ** Ordered lists

{-
prop_sort       = Test.sort             `eq1`   Spec.sort
prop_insert     = Test.insert           `eq2`   Spec.insert
-}

------------------------------------------------------------------------
-- * Generalized functions
-- ** The \"By\" operations
-- *** User-supplied equality (replacing an Eq context)

{-
prop_nubBy              = Test.nubBy            `eq2`   Spec.nubBy
prop_deleteBy           = Test.deleteBy         `eq3`   Spec.deleteBy
prop_deleteFirstsBy     = Test.deleteFirstsBy   `eq3`   Spec.deleteFirstsBy
prop_unionBy            = Test.unionBy          `eq3`   Spec.unionBy
prop_intersectBy        = Test.intersectBy      `eq3`   Spec.intersectBy
prop_groupBy            = Test.groupBy          `eq2`   Spec.groupBy
-}

------------------------------------------------------------------------
-- *** User-supplied comparison (replacing an Ord context)

{-
prop_sortBy             = Test.sortBy           `eq2`           Spec.sortBy
-}
{-
prop_insertBy           = Test.insertBy         `eq3`           Spec.insertBy
-}


prop_maximumBy          = Test.maximumBy        `eqnotnull2`    Spec.maximumBy
prop_minimumBy          = Test.minimumBy        `eqnotnull2`    Spec.minimumBy

{-
------------------------------------------------------------------------
-- * The \"generic\" operations

prop_genericLength      = Test.genericLength    `eq1`   Spec.genericLength
prop_genericTake        = \i -> i >= I 0 ==>
                          (Test.genericTake     `eq2`   Spec.genericTake) i
prop_genericDrop        = \i -> i >= I 0 ==>
                          (Test.genericDrop     `eq2`   Spec.genericDrop) i
prop_genericIndex       = \xs i -> i >= I 0 && i < Spec.genericLength xs ==>
                          (Test.genericIndex    `eq2`   Spec.genericIndex) xs i
prop_genericSplitAt     = \i -> i >= I 0 ==>
                          (Test.genericSplitAt  `eq2`   Spec.genericSplitAt) i
prop_genericReplicate   = \i -> i >= I 0 ==>
                          (Test.genericReplicate        `eq2`   Spec.genericReplicate) i
-}

------------------------------------------------------------------------


main = do
  x <- getArgs
  let opts' = case x of
                    [n] -> opts { no_of_tests = read n }
                    _   -> opts

  hSetBuffering stdout NoBuffering
  putStrLn "Testing: Data.Array.Vector <=> Data.List"
  putStrLn "==================================\n"

  runTests "Extras" opts'
    [-- run prop_repeatU_model
    ]

  runTests "Basic interface" opts'
    [run prop_cons
    ,run prop_snoc
    ,run prop_empty
    ,run prop_singleton
    ,run prop_head
    ,run prop_append
    ,run prop_tail
    ,run prop_null
    ,run prop_init
    ,run prop_last
    ,run prop_length
    ]

  runTests "Array transformations" opts'
    [run prop_map
    {-
--  ,run prop_reverse
    ,run prop_intersperse
    ,run prop_intercalate
--  ,run prop_transpose
-}
    ]

  runTests "Reducing arrays (folds)" opts'
    [run prop_foldl
--  ,run prop_foldr

    ,run prop_foldl1
--  ,run prop_foldl'
--  ,run prop_foldl1'
--  ,run prop_foldr1
    ,run prop_foldl1MaybeU
    ,run prop_fold1MaybeU
    ,run prop_mapAccumLU
    ]

  runTests "Special folds" opts'
    [
--   run prop_concat,
--   run prop_concatMap
     run prop_and
    ,run prop_or
    ,run prop_any
    ,run prop_all
    ,run prop_sum
    ,run prop_product
    ,run prop_maximum
    ,run prop_minimum
    ]

  runTests "Scans" opts'
    [run prop_scanl
    ,run prop_scanl1
    ,run prop_scanResU
    ,run prop_scanU
    ,run prop_scan1U
--  ,run prop_scanr
--  ,run prop_scanr1
    ]

{-
  runTests "Accumulating maps" opts'
    [run prop_mapAccumL
    ,run prop_mapAccumR
    ]
-}

  runTests "Generating arrays" opts'
    [run prop_iterate
    ,run prop_repeatU
    ,run prop_replicate
    ,run prop_replicateEachU
    ,run prop_unitsU
    ,run prop_packU
    ,run prop_combineU
    -- ,run prop_cycle
    ]


  runTests "Unfolding" opts'
    [run prop_unfoldr
    ]


  runTests "Extracting subarrays" opts'
    [run prop_take
    ,run prop_drop
    ,run prop_splitAt
    ,run prop_takeWhile
    ,run prop_dropWhile
--  ,run prop_span
--  ,run prop_break
--  ,run prop_group
--  ,run prop_inits
--  ,run prop_tails
    ]

{-
  runTests "Predicates" opts'
    [run prop_isPrefixOf
    ,run prop_isSuffixOf
    ,run prop_isInfixOf
    ]
-}

  runTests "Searching by equality" opts'
    [run prop_elem
    ,run prop_notElem-- no specific implementation
    ,run prop_lookup
    ]

  runTests "Searching by a predicate" opts'
    [run prop_filter
    ,run prop_find
--  ,run prop_partition
    ]

  runTests "Indexing arrays" opts'
    [run prop_index
    ,run prop_indexedU
    ,run prop_findIndex
--  ,run prop_elemIndex
--  ,run prop_elemIndices
--  ,run prop_findIndices
    ]

  runTests "Zipping" opts'
    [run prop_zip
    ,run prop_zip3
--  ,run prop_zip4
--  ,run prop_zip5
--  ,run prop_zip6
--  ,run prop_zip7
    ,run prop_zipWith
    ,run prop_zipWith3
--  ,run prop_zipWith4
--  ,run prop_zipWith5
--  ,run prop_zipWith6
--  ,run prop_zipWith7
    ]

  runTests "Unzipping" opts'
    [run prop_fstU
    ,run prop_sndU
    ,run prop_unzip
    ,run prop_unzip3
--  ,run prop_unzip4
--  ,run prop_unzip5
--  ,run prop_unzip6
--  ,run prop_unzip7
    ]

{-
  runTests "Functions on strings" opts'
    [run prop_unlines
    ,run prop_lines
    ,run prop_words
    ,run prop_unwords
    ]
-}

{-
  runTests "\"Set\" operations" opts'
    [run prop_nub
    ,run prop_delete
    ,run prop_difference
    ,run prop_union
    ,run prop_intersect
    ]
-}

{-
  runTests "Ordered lists" opts'
    [run prop_sort
    ,run prop_insert
    ]
-}

{-
  runTests "Eq style \"By\" operations" opts'
    [run prop_nubBy
    ,run prop_deleteBy
    ,run prop_deleteFirstsBy
    ,run prop_unionBy
    ,run prop_intersectBy
    ,run prop_groupBy
    ]
-}

  runTests "Ord style \"By\" operations" opts'
    [
--  ,run prop_insertBy
--  ,run prop_sortBy        -- note issue here.
     run prop_maximumBy
    ,run prop_minimumBy
    ]

  runTests "Enumerated arrays" opts'
    [run prop_enumFromToU
    ,run prop_enumFromToFracU
    ,run prop_enumFromThenToU
    ,run prop_enumFromStepLenU
    ,run prop_enumFromToEachU
    ]

  runTests "Mutable arrays" opts'
    [run prop_unsafeFreezeAllMU
    ,run prop_newU
    ,run prop_unsafeZipMU
    ,run prop_unsafeUnzipMU
    ]

  runTests "Hyperstrict" opts'
    [run prop_fstS
    ,run prop_sndS
    ,run prop_pairS
    ,run prop_unpairS
    ,run prop_curryS
    ,run prop_uncurryS
    ,run prop_unsafePairS
    ,run prop_unsafeUnpairS
    ,run prop_maybeS
    ,run prop_fromMaybeS
    ,run prop_functorMaybeS
    ]

  runTests "Text output" opts'
    [run prop_show_read
    ]

  -- These are a little overkillish (and should be generated by TH, probably)

  runTests "()-specific" opts'
    [run (prop_lengthU :: UArr () -> Bool)
    ,run (prop_indexU :: UArr () -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex () -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr () -> Bool)
    ,run (prop_readMU :: UArr () -> Int -> Property)
    ,run (prop_writeMU :: UArr () -> Int -> () -> Property)
    ,run (prop_unsafeFreezeMU :: UArr () -> Int -> Property)
    ,run (prop_memcpyMU :: UArr () -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr () -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr () -> Property)
    ]

  runTests "(a :*: b)-specific" opts'
    [run (prop_lengthU :: UArr (A :*: B) -> Bool)
    ,run (prop_indexU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (A :*: B) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (A :*: B) -> Bool)
    ,run (prop_readMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_writeMU :: UArr (A :*: B) -> Int -> (A :*: B) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (A :*: B) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (A :*: B) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (A :*: B) -> Property)
    ]

  runTests "Bool-specific" opts'
    [run (prop_lengthU :: UArr Bool -> Bool)
    ,run (prop_indexU :: UArr Bool -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Bool -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Bool -> Bool)
    ,run (prop_readMU :: UArr Bool -> Int -> Property)
    ,run (prop_writeMU :: UArr Bool -> Int -> Bool -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Bool -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Bool -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Bool -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Bool -> Property)
    ,run (prop_hPutU_hGetU :: UArr Bool -> Bool)
    ]

  runTests "Char-specific" opts'
    [run (prop_lengthU :: UArr Char -> Bool)
    ,run (prop_indexU :: UArr Char -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Char -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Char -> Bool)
    ,run (prop_readMU :: UArr Char -> Int -> Property)
    ,run (prop_writeMU :: UArr Char -> Int -> Char -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Char -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Char -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Char -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Char -> Property)
    ,run (prop_hPutU_hGetU :: UArr Char -> Bool)
    ]

  runTests "Int-specific" opts'
    [run (prop_lengthU :: UArr Int -> Bool)
    ,run (prop_indexU :: UArr Int -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int -> Bool)
    ,run (prop_readMU :: UArr Int -> Int -> Property)
    ,run (prop_writeMU :: UArr Int -> Int -> Int -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int -> Bool)
    ]

  runTests "Word-specific" opts'
    [run (prop_lengthU :: UArr Word -> Bool)
    ,run (prop_indexU :: UArr Word -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word -> Bool)
    ,run (prop_readMU :: UArr Word -> Int -> Property)
    ,run (prop_writeMU :: UArr Word -> Int -> Word -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word -> Bool)
    ]

  runTests "Float-specific" opts'
    [run (prop_lengthU :: UArr Float -> Bool)
    ,run (prop_indexU :: UArr Float -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Float -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Float -> Bool)
    ,run (prop_readMU :: UArr Float -> Int -> Property)
    ,run (prop_writeMU :: UArr Float -> Int -> Float -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Float -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Float -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Float -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Float -> Property)
    ,run (prop_hPutU_hGetU :: UArr Float -> Bool)
    ]

  runTests "Double-specific" opts'
    [run (prop_lengthU :: UArr Double -> Bool)
    ,run (prop_indexU :: UArr Double -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Double -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Double -> Bool)
    ,run (prop_readMU :: UArr Double -> Int -> Property)
    ,run (prop_writeMU :: UArr Double -> Int -> Double -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Double -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Double -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Double -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Double -> Property)
    ,run (prop_hPutU_hGetU :: UArr Double -> Bool)
    ]

  runTests "Word8-specific" opts'
    [run (prop_lengthU :: UArr Word8 -> Bool)
    ,run (prop_indexU :: UArr Word8 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word8 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word8 -> Bool)
    ,run (prop_readMU :: UArr Word8 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word8 -> Int -> Word8 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word8 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word8 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word8 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word8 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word8 -> Bool)
    ]

  runTests "Word16-specific" opts'
    [run (prop_lengthU :: UArr Word16 -> Bool)
    ,run (prop_indexU :: UArr Word16 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word16 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word16 -> Bool)
    ,run (prop_readMU :: UArr Word16 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word16 -> Int -> Word16 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word16 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word16 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word16 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word16 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word16 -> Bool)
    ]

  runTests "Word32-specific" opts'
    [run (prop_lengthU :: UArr Word32 -> Bool)
    ,run (prop_indexU :: UArr Word32 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word32 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word32 -> Bool)
    ,run (prop_readMU :: UArr Word32 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word32 -> Int -> Word32 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word32 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word32 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word32 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word32 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word32 -> Bool)
    ]

  runTests "Word64-specific" opts'
    [run (prop_lengthU :: UArr Word64 -> Bool)
    ,run (prop_indexU :: UArr Word64 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Word64 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Word64 -> Bool)
    ,run (prop_readMU :: UArr Word64 -> Int -> Property)
    ,run (prop_writeMU :: UArr Word64 -> Int -> Word64 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Word64 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Word64 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Word64 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Word64 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Word64 -> Bool)
    ]

  runTests "Int8-specific" opts'
    [run (prop_lengthU :: UArr Int8 -> Bool)
    ,run (prop_indexU :: UArr Int8 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int8 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int8 -> Bool)
    ,run (prop_readMU :: UArr Int8 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int8 -> Int -> Int8 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int8 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int8 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int8 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int8 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int8 -> Bool)
    ]

  runTests "Int16-specific" opts'
    [run (prop_lengthU :: UArr Int16 -> Bool)
    ,run (prop_indexU :: UArr Int16 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int16 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int16 -> Bool)
    ,run (prop_readMU :: UArr Int16 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int16 -> Int -> Int16 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int16 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int16 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int16 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int16 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int16 -> Bool)
    ]

  runTests "Int32-specific" opts'
    [run (prop_lengthU :: UArr Int32 -> Bool)
    ,run (prop_indexU :: UArr Int32 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int32 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int32 -> Bool)
    ,run (prop_readMU :: UArr Int32 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int32 -> Int -> Int32 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int32 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int32 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int32 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int32 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int32 -> Bool)
    ]

  runTests "Int64-specific" opts'
    [run (prop_lengthU :: UArr Int64 -> Bool)
    ,run (prop_indexU :: UArr Int64 -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex Int64 -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr Int64 -> Bool)
    ,run (prop_readMU :: UArr Int64 -> Int -> Property)
    ,run (prop_writeMU :: UArr Int64 -> Int -> Int64 -> Property)
    ,run (prop_unsafeFreezeMU :: UArr Int64 -> Int -> Property)
    ,run (prop_memcpyMU :: UArr Int64 -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr Int64 -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr Int64 -> Property)
    ,run (prop_hPutU_hGetU :: UArr Int64 -> Bool)
    ]

  runTests "Complex-specific" opts'
    [run (prop_lengthU :: UArr (Complex Double) -> Bool)
    ,run (prop_indexU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (Complex Double) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (Complex Double) -> Bool)
    ,run (prop_readMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_writeMU :: UArr (Complex Double) -> Int -> (Complex Double) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (Complex Double) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (Complex Double) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (Complex Double) -> Property)
    --,run (prop_hPutU_hGetU :: UArr (Complex Float) -> Bool)
    ]

  runTests "Ratio-specific" opts'
    [run (prop_lengthU :: UArr (Ratio Int) -> Bool)
    ,run (prop_indexU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_sliceU :: BoundedIndex (Ratio Int) -> Int -> Property)
    ,run (prop_newMU_copyMU_lengthMU :: UArr (Ratio Int) -> Bool)
    ,run (prop_readMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_writeMU :: UArr (Ratio Int) -> Int -> (Ratio Int) -> Property)
    ,run (prop_unsafeFreezeMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_memcpyMU :: UArr (Ratio Int) -> Int -> Property)
    ,run (prop_memcpyOffMU :: Ind2LenUArr (Ratio Int) -> Property)
    ,run (prop_memmoveOffMU :: Ind2LenUArr (Ratio Int) -> Property)
    --,run (prop_hPutU_hGetU :: UArr (Ratio Int) -> Bool)
    ]
{-
  runTests "The \"generic\" operations" opts'
    [run prop_genericLength
    ,run prop_genericTake
    ,run prop_genericDrop
    ,run prop_genericIndex
    ,run prop_genericSplitAt
    ,run prop_genericReplicate
    ]
-}

</pre>