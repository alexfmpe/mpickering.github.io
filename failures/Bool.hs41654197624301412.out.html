<a href="Bool.hs16807282475249.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BoolExpr.hs340756291478446501.out.html">next</a></br></br><pre>56d55
< type family x :&&: y
57d55
< type instance False :&&: x = False
58c56
< type instance True  :&&: x = x
---
> type family   :&&:      y
58a57
> type instance       :&&:      x = False
58a58
> type instance       :&&:       x = x
62d61
< type family x :||: y
63d61
< type instance True  :||: x = True
64c62
< type instance False :||: x = x
---
> type family   :||:      y
64a63
> type instance       :||:       x = True
64a64
> type instance       :||:      x = x
76a77
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Types.Data.Bool
-- Copyright   :  (c) 2008 Peter Gavin
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  pgavin@gmail.com
-- Stability   :  experimental
-- Portability :  non-portable (type families, requires ghc >= 6.9)
--
-- Type-level numerical operations using type families.
--
----------------------------------------------------------------------------

module Types.Data.Bool
    ( True
    , trueT
    , False
    , falseT
    , Not
    , notT
    , (:&&:)
    , andT
    , (:||:)
    , orT
    , IfT(..)
    ) where

import Data.Typeable

import qualified Prelude

data True deriving (Typeable)
trueT :: True
trueT = Prelude.undefined
instance Prelude.Show True where
    show _ = "True"
data False deriving (Typeable)
falseT :: False
falseT = Prelude.undefined
instance Prelude.Show False where
    show _ = "False"

type family Not x
type instance Not False = True
type instance Not True  = False
notT :: x -> Not x
notT _ = Prelude.undefined

type family x :&&: y
type instance False :&&: x = False
type instance True  :&&: x = x
andT :: x -> y -> x :&&: y
andT _ _ = Prelude.undefined

type family x :||: y
type instance True  :||: x = True
type instance False :||: x = x
orT :: x -> y -> x :||: y
orT _ _ = Prelude.undefined

class IfT x y z where
    type If x y z
    ifT :: x -> y -> z -> If x y z
instance IfT True y z where
    type If True y z = y
    ifT _ y _ = y
instance IfT False y z where
    type If False y z = z
    ifT _ _ z = z
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveDataTypeable #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Types.Data.Bool
-- Copyright   :  (c) 2008 Peter Gavin
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  pgavin@gmail.com
-- Stability   :  experimental
-- Portability :  non-portable (type families, requires ghc >= 6.9)
--
-- Type-level numerical operations using type families.
--
----------------------------------------------------------------------------

module Types.Data.Bool
    ( True
    , trueT
    , False
    , falseT
    , Not
    , notT
    , (:&&:)
    , andT
    , (:||:)
    , orT
    , IfT(..)
    ) where

import Data.Typeable

import qualified Prelude

data True deriving (Typeable)
trueT :: True
trueT = Prelude.undefined
instance Prelude.Show True where
    show _ = "True"
data False deriving (Typeable)
falseT :: False
falseT = Prelude.undefined
instance Prelude.Show False where
    show _ = "False"

type family Not x
type instance Not False = True
type instance Not True  = False
notT :: x -> Not x
notT _ = Prelude.undefined

type family   :&&:      y
type instance       :&&:      x = False
type instance       :&&:       x = x
andT :: x -> y -> x :&&: y
andT _ _ = Prelude.undefined

type family   :||:      y
type instance       :||:       x = True
type instance       :||:      x = x
orT :: x -> y -> x :||: y
orT _ _ = Prelude.undefined

class IfT x y z where
    type If x y z
    ifT :: x -> y -> z -> If x y z
instance IfT True y z where
    type If True y z = y
    ifT _ y _ = y
instance IfT False y z where
    type If False y z = z
    ifT _ _ z = z

</pre>