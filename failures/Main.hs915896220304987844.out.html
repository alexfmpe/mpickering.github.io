<a href="main.hs907225550605925150.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs958829064322791560.out.html">next</a></br></br><pre>24c24
< main ∷ IO ()
---
> main :: IO ()
26d25
<     (prog,args) ← UI.initialise
27d25
<     file ← case args of
28d25
<         [f] → return f
29d25
<         ___ → error "usage: vle [GLUT-options] <file>"
30c26
<     term ← parseFile file
---
>     (prog,args) <- UI.initialise
30a27
>     file <- case args of
30a28
>         [f] -> return f
30a29
>         ___ -> error "usage: vle [GLUT-options] <file>"
30a30
>     term <- parseFile file
36d35
<     (cgf, cf, sf, rot) ← readOnly $ do
37d35
<         cgf ← centralGravitation n
38d35
<         cf ← coulombForce n
39d35
<         sf ← springForce 1.5 n
40c36
<         rot ← angularMomentum n
---
>     (cgf, cf, sf, rot) <- readOnly $ do
40a37
>         cgf <- centralGravitation n
40a38
>         cf <- coulombForce n
40a39
>         sf <- springForce 1.5 n
40a40
>         rot <- angularMomentum n
42c42
<     Unsafe.adjustNode n $ Position . sf (\x → min 10 (x*0.9)) . cgf (\x → min 10 (x*0.01)) . cf (\x → min 10 (100/(x^2+0.1))) . position
---
>     Unsafe.adjustNode n $ Position . sf (\x -> min 10 (x*0.9)) . cgf (\x -> min 10 (x*0.01)) . cf (\x -> min 10 (100/(x^2+0.1))) . position
45c45
< unshare ∷ (View [Port] n, View NodeWW n) ⇒ Rule n
---
> unshare :: (View [Port] n, View NodeWW n) => Rule n
65a66
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, FlexibleContexts #-}
module Main where

import GraphRewriting.Graph
import GraphRewriting.GL.Render
import GraphRewriting.GL.UI as UI
import Term (parseFile)
import Resolver (resolve)
import Graph
import GL ()
import Rules
import GraphRewriting.Rule hiding (erase)
import GraphRewriting.Pattern
import GraphRewriting.Graph.Read
import GraphRewriting.Graph.Write.Unsafe as Unsafe
import GraphRewriting.Layout.Coulomb
import GraphRewriting.Layout.SpringEmbedder
import GraphRewriting.Layout.Gravitation
import GraphRewriting.Layout.Wrapper


instance Render (Wrapper NodeWW) where render = render . wrappee

main ∷ IO ()
main = do
    (prog,args) ← UI.initialise
    file ← case args of
        [f] → return f
        ___ → error "usage: vle [GLUT-options] <file>"
    term ← parseFile file
    let hypergraph = resolve term
    let graph = execGraph (apply $ exhaustive compileShare) (wrapGraph hypergraph)
    UI.run 50 id layoutStep graph ruleTree

layoutStep n = do
    (cgf, cf, sf, rot) ← readOnly $ do
        cgf ← centralGravitation n
        cf ← coulombForce n
        sf ← springForce 1.5 n
        rot ← angularMomentum n
        return (cgf, cf, sf, rot)
    Unsafe.adjustNode n $ Position . sf (\x → min 10 (x*0.9)) . cgf (\x → min 10 (x*0.01)) . cf (\x → min 10 (100/(x^2+0.1))) . position
    Unsafe.adjustNode n $ rot (*0.9)

unshare ∷ (View [Port] n, View NodeWW n) ⇒ Rule n
unshare = duplicatePrimitive <|> duplicateFunction where
    duplicateFunction = initDuplication >>> exhaustive (everywhere duplicate) >>> exhaustive (everywhere deactivate)
    duplicate = anyOf [duplicateAbstractor, duplicateApplicator, duplicateDuplicator, duplicateEraser, annihilate]

ruleTree = Branch "All"
    [Branch "Safe"
        [Leaf "Beta Reduction" beta,
         Leaf "Apply Primitive" applyPrimitive,
         Leaf "Unshare MFE" unshare,
         Leaf "Eliminate" eliminate,
         Leaf "Erase" erase],
     Branch "Unshare MFE (unsafe)"
        [Leaf "Initiate" initDuplication,
         Branch "Intermediate"
             [Leaf "DuplicateAbstractor" duplicateAbstractor,
              Leaf "DuplicateApplicator" duplicateApplicator,
              Leaf "DuplicateDuplicator" duplicateDuplicator,
              Leaf "DuplicateEraser" duplicateEraser,
              Leaf "Annihilate" annihilate],
         Leaf "Finalise" deactivate]]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, FlexibleContexts #-}
module Main where

import GraphRewriting.Graph
import GraphRewriting.GL.Render
import GraphRewriting.GL.UI as UI
import Term (parseFile)
import Resolver (resolve)
import Graph
import GL ()
import Rules
import GraphRewriting.Rule hiding (erase)
import GraphRewriting.Pattern
import GraphRewriting.Graph.Read
import GraphRewriting.Graph.Write.Unsafe as Unsafe
import GraphRewriting.Layout.Coulomb
import GraphRewriting.Layout.SpringEmbedder
import GraphRewriting.Layout.Gravitation
import GraphRewriting.Layout.Wrapper


instance Render (Wrapper NodeWW) where render = render . wrappee

main :: IO ()
main = do
    (prog,args) <- UI.initialise
    file <- case args of
        [f] -> return f
        ___ -> error "usage: vle [GLUT-options] <file>"
    term <- parseFile file
    let hypergraph = resolve term
    let graph = execGraph (apply $ exhaustive compileShare) (wrapGraph hypergraph)
    UI.run 50 id layoutStep graph ruleTree

layoutStep n = do
    (cgf, cf, sf, rot) <- readOnly $ do
        cgf <- centralGravitation n
        cf <- coulombForce n
        sf <- springForce 1.5 n
        rot <- angularMomentum n
        return (cgf, cf, sf, rot)
    Unsafe.adjustNode n $ Position . sf (\x -> min 10 (x*0.9)) . cgf (\x -> min 10 (x*0.01)) . cf (\x -> min 10 (100/(x^2+0.1))) . position
    Unsafe.adjustNode n $ rot (*0.9)

unshare :: (View [Port] n, View NodeWW n) => Rule n
unshare = duplicatePrimitive <|> duplicateFunction where
    duplicateFunction = initDuplication >>> exhaustive (everywhere duplicate) >>> exhaustive (everywhere deactivate)
    duplicate = anyOf [duplicateAbstractor, duplicateApplicator, duplicateDuplicator, duplicateEraser, annihilate]

ruleTree = Branch "All"
    [Branch "Safe"
        [Leaf "Beta Reduction" beta,
         Leaf "Apply Primitive" applyPrimitive,
         Leaf "Unshare MFE" unshare,
         Leaf "Eliminate" eliminate,
         Leaf "Erase" erase],
     Branch "Unshare MFE (unsafe)"
        [Leaf "Initiate" initDuplication,
         Branch "Intermediate"
             [Leaf "DuplicateAbstractor" duplicateAbstractor,
              Leaf "DuplicateApplicator" duplicateApplicator,
              Leaf "DuplicateDuplicator" duplicateDuplicator,
              Leaf "DuplicateEraser" duplicateEraser,
              Leaf "Annihilate" annihilate],
         Leaf "Finalise" deactivate]]

</pre>