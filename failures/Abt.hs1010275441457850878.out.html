<a href="Abeson.hs1622650073984943658.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Action.hs9671137552124639789.out.html">next</a></br></br><pre>28c28
< class (Show1 o, Show v) ⇒ Abt (v ∷ *) (o ∷ [Nat] → *) (t ∷ Nat → *) | t → v o where
---
> class (Show1 o, Show v) => Abt (v :: *) (o :: [Nat] -> *) (t :: Nat -> *) | t -> v o where
32d31
<     ∷ View v o n t
33c32
<     → t n
---
>     :: View v o n t
33a33
>     -> t n
38d37
<     ∷ MonadVar v m
39d37
<     ⇒ t n
40c38
<     → m (View v o n t)
---
>     :: MonadVar v m
40a39
>     => t n
40a40
>     -> m (View v o n t)
45d44
<     ∷ v
46c45
<     → t Z
---
>     :: v
46a46
>     -> t Z
52d51
<     ∷ v
53d51
<     → t n
54c52
<     → t (S n)
---
>     :: v
54a53
>     -> t n
54a54
>     -> t (S n)
60d59
<     ∷ o ns
61d59
<     → Rec t ns
62c60
<     → t Z
---
>     :: o ns
62a61
>     -> Rec t ns
62a62
>     -> t Z
69d68
<     ∷ MonadVar v m
70d68
<     ⇒ t Z
71d68
<     → v
72d68
<     → t n
73c69
<     → m (t n)
---
>     :: MonadVar v m
73a70
>     => t Z
73a71
>     -> v
73a72
>     -> t n
73a73
>     -> m (t n)
75c75
<     oe' ← out e'
---
>     oe' <- out e'
77d76
<       V v' → return $ if v == v' then e else e'
78d76
<       v' :\ e'' → (v' \\) <$> subst e v e''
79c77
<       o :$ es → (o $$) <$> subst e v `rtraverse` es
---
>       V v' -> return $ if v == v' then e else e'
79a78
>       v' :\ e'' -> (v' \\) <$> subst e v e''
79a79
>       o :$ es -> (o $$) <$> subst e v `rtraverse` es
84d83
<     ∷ MonadVar v m
85d83
<     ⇒ t (S n)
86d83
<     → t Z
87c84
<     → m (t n)
---
>     :: MonadVar v m
87a85
>     => t (S n)
87a86
>     -> t Z
87a87
>     -> m (t n)
89c89
<     v :\ e ← out xe
---
>     v :\ e <- out xe
95d94
<     ∷ MonadVar v m
96d94
<     ⇒ t n
97c95
<     → m [v]
---
>     :: MonadVar v m
97a96
>     => t n
97a97
>     -> m [v]
99c99
<     oe ← out e
---
>     oe <- out e
101d100
<       V v → return [v]
102c101
<       v :\ e' →
---
>       V v -> return [v]
102a102
>       v :\ e' ->
105c105
<       _ :$ es →
---
>       _ :$ es ->
112d111
<     ∷ MonadVar v m
113d111
<     ⇒ t n
114c112
<     → m String
---
>     :: MonadVar v m
114a113
>     => t n
114a114
>     -> m String
116c116
<     vu ← out e
---
>     vu <- out e
118d117
<       V v → return $ show v
119d117
<       v :\ e' → do
120c118
<         estr ← toString e'
---
>       V v -> return $ show v
120a119
>       v :\ e' -> do
120a120
>         estr <- toString e'
122d121
<       o :$ RNil → return $ show1 o
123d121
<       o :$ es → do
124c122
<         es' ← sequence . recordToList $ Const . toString <<$>> es
---
>       o :$ RNil -> return $ show1 o
124a123
>       o :$ es -> do
124a124
>         es' <- sequence . recordToList $ Const . toString <<$>> es
126a127
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UnicodeSyntax #-}

module Abt.Class.Abt
( Abt(..)
) where

import Abt.Types.Nat
import Abt.Types.View
import Abt.Class.Monad
import Abt.Class.Show1

import Control.Applicative hiding (Const)
import Data.Vinyl
import Data.Vinyl.Functor
import qualified Data.List as L

-- | The 'Abt' signature represents mediation between an arbitrary (possibly
-- nameless) term representaion, and a simple one (the 'View'). Based on
-- the (effectful) ismorphism @'into' / 'out'@ between representations, many
-- operations can be defined generically for arbitrary operator sets, including
-- substitution and aggregation of free variables.
--
class (Show1 o, Show v) ⇒ Abt (v ∷ *) (o ∷ [Nat] → *) (t ∷ Nat → *) | t → v o where
  -- | Convert a 'View' into a term.
  --
  into
    ∷ View v o n t
    → t n

  -- | Convert a term into a simple 'View'.
  --
  out
    ∷ MonadVar v m
    ⇒ t n
    → m (View v o n t)

  -- | The injection from variables to terms.
  --
  var
    ∷ v
    → t Z
  var = into . V

  -- | Construct an abstraction.
  --
  (\\)
    ∷ v
    → t n
    → t (S n)
  v \\ e = into $ v :\ e

  -- | Construct an operator term.
  --
  ($$)
    ∷ o ns
    → Rec t ns
    → t Z
  o $$ es = into $ o :$ es
  infixl 1 $$

  -- | Substitute a term for a variable.
  --
  subst
    ∷ MonadVar v m
    ⇒ t Z
    → v
    → t n
    → m (t n)
  subst e v e' = do
    oe' ← out e'
    case oe' of
      V v' → return $ if v == v' then e else e'
      v' :\ e'' → (v' \\) <$> subst e v e''
      o :$ es → (o $$) <$> subst e v `rtraverse` es

  -- | Instantiate the bound variable of an abstraction.
  --
  (//)
    ∷ MonadVar v m
    ⇒ t (S n)
    → t Z
    → m (t n)
  xe // e' = do
    v :\ e ← out xe
    subst e' v e

  -- | Compute the free variables of a term.
  --
  freeVars
    ∷ MonadVar v m
    ⇒ t n
    → m [v]
  freeVars e = do
    oe ← out e
    case oe of
      V v → return [v]
      v :\ e' →
        L.delete v <$>
          freeVars e'
      _ :$ es →
        fmap concat . sequence . recordToList $
          Const . freeVars <<$>> es

  -- | Render a term into a human-readable string.
  --
  toString
    ∷ MonadVar v m
    ⇒ t n
    → m String
  toString e = do
    vu ← out e
    case vu of
      V v → return $ show v
      v :\ e' → do
        estr ← toString e'
        return $ show v ++ "." ++ estr
      o :$ RNil → return $ show1 o
      o :$ es → do
        es' ← sequence . recordToList $ Const . toString <<$>> es
        return $ show1 o ++ "[" ++ L.intercalate ";" es' ++ "]"

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UnicodeSyntax #-}

module Abt.Class.Abt
( Abt(..)
) where

import Abt.Types.Nat
import Abt.Types.View
import Abt.Class.Monad
import Abt.Class.Show1

import Control.Applicative hiding (Const)
import Data.Vinyl
import Data.Vinyl.Functor
import qualified Data.List as L

-- | The 'Abt' signature represents mediation between an arbitrary (possibly
-- nameless) term representaion, and a simple one (the 'View'). Based on
-- the (effectful) ismorphism @'into' / 'out'@ between representations, many
-- operations can be defined generically for arbitrary operator sets, including
-- substitution and aggregation of free variables.
--
class (Show1 o, Show v) => Abt (v :: *) (o :: [Nat] -> *) (t :: Nat -> *) | t -> v o where
  -- | Convert a 'View' into a term.
  --
  into
    :: View v o n t
    -> t n

  -- | Convert a term into a simple 'View'.
  --
  out
    :: MonadVar v m
    => t n
    -> m (View v o n t)

  -- | The injection from variables to terms.
  --
  var
    :: v
    -> t Z
  var = into . V

  -- | Construct an abstraction.
  --
  (\\)
    :: v
    -> t n
    -> t (S n)
  v \\ e = into $ v :\ e

  -- | Construct an operator term.
  --
  ($$)
    :: o ns
    -> Rec t ns
    -> t Z
  o $$ es = into $ o :$ es
  infixl 1 $$

  -- | Substitute a term for a variable.
  --
  subst
    :: MonadVar v m
    => t Z
    -> v
    -> t n
    -> m (t n)
  subst e v e' = do
    oe' <- out e'
    case oe' of
      V v' -> return $ if v == v' then e else e'
      v' :\ e'' -> (v' \\) <$> subst e v e''
      o :$ es -> (o $$) <$> subst e v `rtraverse` es

  -- | Instantiate the bound variable of an abstraction.
  --
  (//)
    :: MonadVar v m
    => t (S n)
    -> t Z
    -> m (t n)
  xe // e' = do
    v :\ e <- out xe
    subst e' v e

  -- | Compute the free variables of a term.
  --
  freeVars
    :: MonadVar v m
    => t n
    -> m [v]
  freeVars e = do
    oe <- out e
    case oe of
      V v -> return [v]
      v :\ e' ->
        L.delete v <$>
          freeVars e'
      _ :$ es ->
        fmap concat . sequence . recordToList $
          Const . freeVars <<$>> es

  -- | Render a term into a human-readable string.
  --
  toString
    :: MonadVar v m
    => t n
    -> m String
  toString e = do
    vu <- out e
    case vu of
      V v -> return $ show v
      v :\ e' -> do
        estr <- toString e'
        return $ show v ++ "." ++ estr
      o :$ RNil -> return $ show1 o
      o :$ es -> do
        es' <- sequence . recordToList $ Const . toString <<$>> es
        return $ show1 o ++ "[" ++ L.intercalate ";" es' ++ "]"


</pre>