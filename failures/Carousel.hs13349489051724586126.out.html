<a href="Cardinal.hs4285405561968456301.out.html">prev</a></br><a href="failures.html">home</a></br><a href="CartesianClosed.hs5322361231023129506.out.html">next</a></br></br><pre>33c33
<   { _clSequence ∷ S.Seq α
---
>   { _clSequence :: S.Seq α
45c45
< clSequence ∷ Iso (Carousel α) (Carousel β) (S.Seq α) (S.Seq β)
---
> clSequence :: Iso (Carousel α) (Carousel β) (S.Seq α) (S.Seq β)
48c48
< clList ∷ Iso (Carousel α) (Carousel β) [α] [β]
---
> clList :: Iso (Carousel α) (Carousel β) [α] [β]
53c53
< cursor ∷ Traversal' (Carousel α) α
---
> cursor :: Traversal' (Carousel α) α
59d58
<   ∷ Carousel α
60c59
<   → Carousel α
---
>   :: Carousel α
60a60
>   -> Carousel α
66d65
<   ∷ Carousel α
67c66
<   → Carousel α
---
>   :: Carousel α
67a67
>   -> Carousel α
71d70
<       ∷ S.ViewL α
72c71
<       → S.Seq α
---
>       :: S.ViewL α
72a72
>       -> S.Seq α
79d78
<   ∷ Carousel α
80c79
<   → Carousel α
---
>   :: Carousel α
80a80
>   -> Carousel α
84d83
<       ∷ S.ViewR α
85c84
<       → S.Seq α
---
>       :: S.ViewR α
85a85
>       -> S.Seq α
91c91
<   ∷ Carousel α
---
>   :: Carousel α
96d95
<   ∷ [α]
97d95
<   → Carousel α
98c96
<   → Carousel α
---
>   :: [α]
98a97
>   -> Carousel α
98a98
>   -> Carousel α
103d102
<   ∷ Eq α
104d102
<   ⇒ Carousel α
105c103
<   → Carousel α
---
>   :: Eq α
105a104
>   => Carousel α
105a105
>   -> Carousel α
106a107
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE UnicodeSyntax #-}

-- |
-- Module: Data.Carousel
-- Copyright: Copyright © 2014 AlephCloud Systems, Inc.
-- License: MIT
-- Maintainer: Jon Sterling <jsterling@alephcloud.com>
-- Stability: experimental
--
module Data.Carousel
( Carousel
, empty
, cursor
, moveLeft
, moveRight
, dropCursor
, nub
, append
, clSequence
, clList
) where

import Control.Lens
import qualified Data.Foldable as F
import qualified Data.List as L
import qualified Data.Sequence as S

newtype Carousel α
  = Carousel
  { _clSequence ∷ S.Seq α
  } deriving (Show, Eq)

instance Functor Carousel where
  fmap f (Carousel sq) = Carousel $ fmap f sq

instance F.Foldable Carousel where
  foldMap f (Carousel sq) = F.foldMap f sq

instance Traversable Carousel where
  traverse f (Carousel sq) = fmap Carousel (traverse f sq)

clSequence ∷ Iso (Carousel α) (Carousel β) (S.Seq α) (S.Seq β)
clSequence = iso _clSequence Carousel

clList ∷ Iso (Carousel α) (Carousel β) [α] [β]
clList = clSequence . iso F.toList S.fromList


-- | There is guaranteed to be a cursor so long as the carousel is non-empty.
cursor ∷ Traversal' (Carousel α) α
cursor = clSequence . _head

-- | You can delete the cursor from the carousel; the items to its right will
-- move one over to the left.
dropCursor
  ∷ Carousel α
  → Carousel α
dropCursor = clSequence %~ (^. _tail)

-- | The carousel may be rotated to the right; this operation is written so as
-- to always guarantee the presence of a cursor in a non-empty carousel.
moveRight
  ∷ Carousel α
  → Carousel α
moveRight = clSequence %~ rotate . S.viewl
  where
    rotate
      ∷ S.ViewL α
      → S.Seq α
    rotate S.EmptyL = S.empty
    rotate (x S.:< xs) = xs S.|> x

-- | The carousel may be rotated to the left; this operation is written so as
-- to always guarantee the presence of a cursor in a non-empty carousel.
moveLeft
  ∷ Carousel α
  → Carousel α
moveLeft = clSequence %~ rotate . S.viewr
  where
    rotate
      ∷ S.ViewR α
      → S.Seq α
    rotate S.EmptyR = S.empty
    rotate (xs S.:> x) = x S.<| xs

-- | The empty carousel.
empty
  ∷ Carousel α
empty = Carousel S.empty

-- | Append a list of elements to the right side of the carousel.
append
  ∷ [α]
  → Carousel α
  → Carousel α
append xs = clSequence %~ (S.>< S.fromList xs)

-- | Remove all duplicate elements from the carousel. (TODO: this is inefficient)
nub
  ∷ Eq α
  ⇒ Carousel α
  → Carousel α
nub = clList %~ L.nub
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE UnicodeSyntax #-}

-- |
-- Module: Data.Carousel
-- Copyright: Copyright © 2014 AlephCloud Systems, Inc.
-- License: MIT
-- Maintainer: Jon Sterling <jsterling@alephcloud.com>
-- Stability: experimental
--
module Data.Carousel
( Carousel
, empty
, cursor
, moveLeft
, moveRight
, dropCursor
, nub
, append
, clSequence
, clList
) where

import Control.Lens
import qualified Data.Foldable as F
import qualified Data.List as L
import qualified Data.Sequence as S

newtype Carousel α
  = Carousel
  { _clSequence :: S.Seq α
  } deriving (Show, Eq)

instance Functor Carousel where
  fmap f (Carousel sq) = Carousel $ fmap f sq

instance F.Foldable Carousel where
  foldMap f (Carousel sq) = F.foldMap f sq

instance Traversable Carousel where
  traverse f (Carousel sq) = fmap Carousel (traverse f sq)

clSequence :: Iso (Carousel α) (Carousel β) (S.Seq α) (S.Seq β)
clSequence = iso _clSequence Carousel

clList :: Iso (Carousel α) (Carousel β) [α] [β]
clList = clSequence . iso F.toList S.fromList


-- | There is guaranteed to be a cursor so long as the carousel is non-empty.
cursor :: Traversal' (Carousel α) α
cursor = clSequence . _head

-- | You can delete the cursor from the carousel; the items to its right will
-- move one over to the left.
dropCursor
  :: Carousel α
  -> Carousel α
dropCursor = clSequence %~ (^. _tail)

-- | The carousel may be rotated to the right; this operation is written so as
-- to always guarantee the presence of a cursor in a non-empty carousel.
moveRight
  :: Carousel α
  -> Carousel α
moveRight = clSequence %~ rotate . S.viewl
  where
    rotate
      :: S.ViewL α
      -> S.Seq α
    rotate S.EmptyL = S.empty
    rotate (x S.:< xs) = xs S.|> x

-- | The carousel may be rotated to the left; this operation is written so as
-- to always guarantee the presence of a cursor in a non-empty carousel.
moveLeft
  :: Carousel α
  -> Carousel α
moveLeft = clSequence %~ rotate . S.viewr
  where
    rotate
      :: S.ViewR α
      -> S.Seq α
    rotate S.EmptyR = S.empty
    rotate (xs S.:> x) = x S.<| xs

-- | The empty carousel.
empty
  :: Carousel α
empty = Carousel S.empty

-- | Append a list of elements to the right side of the carousel.
append
  :: [α]
  -> Carousel α
  -> Carousel α
append xs = clSequence %~ (S.>< S.fromList xs)

-- | Remove all duplicate elements from the carousel. (TODO: this is inefficient)
nub
  :: Eq α
  => Carousel α
  -> Carousel α
nub = clList %~ L.nub

</pre>