<a href="QQ.hs500782188657821123.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Qu.hs11633137291122721015.out.html">next</a></br></br><pre>39c39
< toExp (JsonObject objs) = [|object $jsList|]
---
> toExp (JsonObject objs) = [|object jsList|]
52a53
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
-- | Have a look at the <https://github.com/zalora/aeson-qq#readme README> for
-- documentation.
module Data.Aeson.QQ (aesonQQ) where

import Language.Haskell.TH
import Language.Haskell.TH.Quote

import Control.Applicative
import qualified Data.Vector as V
import qualified Data.Text as T
import Data.Aeson

import Data.JSON.QQ as QQ

aesonQQ :: QuasiQuoter
aesonQQ = QuasiQuoter {
  quoteExp = jsonExp,
  quotePat = const $ error "No quotePat defined for jsonQQ",
  quoteType = const $ error "No quoteType defined for jsonQQ",
  quoteDec = const $ error "No quoteDec defined for jsonQQ"
}


jsonExp :: String -> ExpQ
jsonExp txt =
  case parsed' of
    Left err -> error $ "Error in aesonExp: " ++ show err
    Right val -> toExp val
  where
    parsed' = QQ.parsedJson txt

----
-- JSValue etc to ExpQ
---------
toExp :: QQ.JsonValue -> ExpQ
toExp (JsonString str) = [|String (T.pack str)|]
toExp (JsonNull) = [|Null|]
toExp (JsonObject objs) = [|object $jsList|]
    where
      jsList :: ExpQ
      jsList = ListE <$> mapM objs2list (objs)

      objs2list :: (HashKey, JsonValue) -> ExpQ
      objs2list (key, value) = do
        case key of
          HashStringKey k -> [|(T.pack k, $(toExp value))|]
          HashVarKey k -> [|(T.pack $(dyn k), $(toExp value))|]
toExp (JsonArray arr) = [|Array $ V.fromList $(ListE <$> mapM toExp arr)|]
toExp (JsonNumber _ rat) = [|Number (fromRational $(return $ LitE $ RationalL rat))|]
toExp (JsonBool b) = [|Bool b|]
toExp (JsonCode e) = [|toJSON $(return e)|]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
-- | Have a look at the <https://github.com/zalora/aeson-qq#readme README> for
-- documentation.
module Data.Aeson.QQ (aesonQQ) where

import Language.Haskell.TH
import Language.Haskell.TH.Quote

import Control.Applicative
import qualified Data.Vector as V
import qualified Data.Text as T
import Data.Aeson

import Data.JSON.QQ as QQ

aesonQQ :: QuasiQuoter
aesonQQ = QuasiQuoter {
  quoteExp = jsonExp,
  quotePat = const $ error "No quotePat defined for jsonQQ",
  quoteType = const $ error "No quoteType defined for jsonQQ",
  quoteDec = const $ error "No quoteDec defined for jsonQQ"
}


jsonExp :: String -> ExpQ
jsonExp txt =
  case parsed' of
    Left err -> error $ "Error in aesonExp: " ++ show err
    Right val -> toExp val
  where
    parsed' = QQ.parsedJson txt

----
-- JSValue etc to ExpQ
---------
toExp :: QQ.JsonValue -> ExpQ
toExp (JsonString str) = [|String (T.pack str)|]
toExp (JsonNull) = [|Null|]
toExp (JsonObject objs) = [|object jsList|]
    where
      jsList :: ExpQ
      jsList = ListE <$> mapM objs2list (objs)

      objs2list :: (HashKey, JsonValue) -> ExpQ
      objs2list (key, value) = do
        case key of
          HashStringKey k -> [|(T.pack k, $(toExp value))|]
          HashVarKey k -> [|(T.pack $(dyn k), $(toExp value))|]
toExp (JsonArray arr) = [|Array $ V.fromList $(ListE <$> mapM toExp arr)|]
toExp (JsonNumber _ rat) = [|Number (fromRational $(return $ LitE $ RationalL rat))|]
toExp (JsonBool b) = [|Bool b|]
toExp (JsonCode e) = [|toJSON $(return e)|]

</pre>