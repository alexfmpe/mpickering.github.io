<a href="File.hs1112576031925238588.out.html">prev</a></br><a href="failures.html">home</a></br><a href="FinalEnv.hs843998877959637304.out.html">next</a></br></br><pre>32c32
< {-# LINE 38 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
32a33
> 
32a34
> 
32a35
> 
32a36
> 
32a37
> 
45c50
< {-# LINE 66 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
45a51
> 
45a52
> 
45a53
> 
45a54
> 
45a55
> 
45a56
> 
45a57
> 
45a58
> 
45a59
> 
45a60
> 
45a61
> 
45a62
> 
45a63
> 
45a64
> 
45a65
> 
62c82
< {-# LINE 84 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
62a83
> 
66c87
< {-# LINE 93 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
66a88
> 
66a89
> 
66a90
> 
66a91
> 
66a92
> 
70c96
< {-# LINE 98 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
70a97
> 
76c103
< {-# LINE 105 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
76a104
> 
80c108
< {-# LINE 114 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
80a109
> 
80a110
> 
80a111
> 
80a112
> 
80a113
> 
83c116
< {-# LINE 122 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
83a117
> 
83a118
> 
83a119
> 
83a120
> 
83a121
> 
92c130
< {-# LINE 136 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
92a131
> 
92a132
> 
92a133
> 
92a134
> 
92a135
> 
96c139
< {-# LINE 145 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
96a140
> 
96a141
> 
96a142
> 
96a143
> 
96a144
> 
106c154
< {-# LINE 156 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
106a155
> 
112c161
< {-# LINE 167 "src/ehc/Base/FileSearchLocation.chs" #-}
---
> 
112a162
> 
112a163
> 
112a164
> 
112a165
> 
112a166
> 
149d202
< {-# LINE 209 "src/ehc/Base/FileSearchLocation.chs" #-}
150a204
> 
150a205
> 
150a206
> 
150a207
> 
150a208
> 
150a209
> 
154a214
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.FileSearchLocation
( mkDirFileLoc
, StringPath, FileLocPath
, FileLocKind (..)
, FileLoc (..), emptyFileLoc, fileLocPkgDb
, mkPkgFileLoc
, filelocIsPkg
, FileSearchLoc
, PkgKey, PkgKey1, PkgKey2
, showPkgKey
, PackageSearchFilter (..)
, pkgSearchFilter
, PackageCfgKeyVals, PackageInfo (..), PackageMp, Module2PackageMp, PackageDatabase (..), emptyPackageMp, emptyPackageDatabase
, mkInternalPkgFileBase )
where
import UHC.Light.Compiler.Base.Common
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import Data.Version
import Data.List
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.HsName
import UHC.Light.Compiler.Base.Target
import qualified UHC.Light.Compiler.ConfigInstall as Cfg




{-# LINE 38 "src/ehc/Base/FileSearchLocation.chs" #-}
data FileLocKind
  = FileLocKind_Dir                                 -- plain directory
  | FileLocKind_Pkg PkgKey                          -- specific package
                    String                          -- with the dir inside package it was found
  | FileLocKind_PkgDb                               -- yet unknown package in the package database
  deriving Eq

instance Show FileLocKind where
  show  FileLocKind_Dir         = "directory"
  show (FileLocKind_Pkg p d)    = "package: " ++ showPkgKey p ++ "(in: " ++ d ++ ")"
  show  FileLocKind_PkgDb       = "package database"

{-# LINE 66 "src/ehc/Base/FileSearchLocation.chs" #-}
data FileLoc
  = FileLoc
      { filelocKind     :: FileLocKind
      , filelocDir      :: String
      }
  deriving Eq

instance Show FileLoc where
  show (FileLoc k d) = d ++ " (" ++ show k ++ ")"

emptyFileLoc :: FileLoc
emptyFileLoc = FileLoc FileLocKind_Dir ""

fileLocPkgDb :: FileLoc
fileLocPkgDb = FileLoc FileLocKind_PkgDb ""

{-# LINE 84 "src/ehc/Base/FileSearchLocation.chs" #-}
mkDirFileLoc
  = FileLoc FileLocKind_Dir

{-# LINE 93 "src/ehc/Base/FileSearchLocation.chs" #-}
mkPkgFileLoc :: PkgKey -> String -> FileLoc
mkPkgFileLoc p d = FileLoc (FileLocKind_Pkg p d) d

{-# LINE 98 "src/ehc/Base/FileSearchLocation.chs" #-}
filelocIsPkg :: FileLoc -> Bool
filelocIsPkg (FileLoc (FileLocKind_Pkg _ _) _) = True
filelocIsPkg (FileLoc  FileLocKind_PkgDb    _) = True
filelocIsPkg _                                 = False

{-# LINE 105 "src/ehc/Base/FileSearchLocation.chs" #-}
type StringPath  = [String]
type FileLocPath = [FileLoc]

{-# LINE 114 "src/ehc/Base/FileSearchLocation.chs" #-}
type FileSearchLoc = FileLoc

{-# LINE 122 "src/ehc/Base/FileSearchLocation.chs" #-}
type PkgKey1 = PkgName
type PkgKey2 = Maybe Version
type PkgKey  = (PkgKey1,PkgKey2)

instance HSNM PkgKey where
  mkHNm (n,Just v) =   mkHNmBase (n ++ "-" ++ (concat $ intersperse "." $ map show $ versionBranch v))
  mkHNm (n,_     ) =   mkHNm      n

{-# LINE 136 "src/ehc/Base/FileSearchLocation.chs" #-}
showPkgKey :: PkgKey -> String
showPkgKey = show . mkHNm

{-# LINE 145 "src/ehc/Base/FileSearchLocation.chs" #-}
-- | Description of hiding/exposing pkgs, determining the used packages for looking up modules.
data PackageSearchFilter
  -- Note: the below order is important, it is used for sorting just before having its effect on searchable packages.
  -- The current order means that in its filtering hiding is done first, thereby starting out with all available pkgs, then hide (all), then expose selectively
  = PackageSearchFilter_HideAll
  | PackageSearchFilter_HidePkg         [PkgKey]
  | PackageSearchFilter_ExposePkg       [PkgKey]
  deriving (Show, Eq, Ord)

{-# LINE 156 "src/ehc/Base/FileSearchLocation.chs" #-}
pkgSearchFilter :: (x -> Maybe PkgKey) -> ([PkgKey] -> PackageSearchFilter) -> [x] -> [PackageSearchFilter]
pkgSearchFilter mkKey mk ss
  = if null ps then [] else [mk ps]
  where ps = catMaybes $ map mkKey ss

{-# LINE 167 "src/ehc/Base/FileSearchLocation.chs" #-}
type PackageCfgKeyVals = Map.Map String String

-- | Per package info
data PackageInfo
  = PackageInfo
      { pkginfoLoc                  :: !FileLoc                     -- ^ directory location
      , pkginfoOrder                :: !Int                         -- ^ for multiple packages the relative order
      -- , pkginfoKeyVals               :: PackageCfgKeyVals            -- key/value pairs of pkg config info
      , pkginfoExposedModules       :: !HsNameS                     -- ^ exposed modules
      , pkginfoBuildDepends         :: !(Set.Set PkgKey)            -- ^ pkgs dependend on
      , pkginfoIsExposed            :: !Bool                        -- ^ pkg is exposed?
      }
      deriving Show

-- | content of a package (keys are name, then version)
type PackageMp = Map.Map PkgKey1 (Map.Map PkgKey2 [PackageInfo])

emptyPackageMp :: PackageMp
emptyPackageMp = Map.empty

-- | reverse map from module name to package key
type Module2PackageMp = Map.Map HsName [PkgKey]

-- | A package database contains an actual package map, plus a function
-- that maps modules to associated package maps. The latter is computed
-- by "freezing" the package database using "pkgDbFreeze".
data PackageDatabase
  = PackageDatabase
      { pkgDbPkgMp      :: PackageMp
      , pkgDbMod2PkgMp  :: Module2PackageMp
      }
      deriving Show

emptyPackageDatabase :: PackageDatabase
emptyPackageDatabase = PackageDatabase emptyPackageMp Map.empty

{-# LINE 209 "src/ehc/Base/FileSearchLocation.chs" #-}

mkInternalPkgFileBase :: PkgKey -> String {- compiler name/version -} -> Target -> TargetFlavor -> FilePath
mkInternalPkgFileBase pkgKey compversion tgt tgtv =
  Cfg.mkInternalPkgFileBase (showPkgKey pkgKey) compversion (show tgt) (show tgtv)

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.FileSearchLocation
( mkDirFileLoc
, StringPath, FileLocPath
, FileLocKind (..)
, FileLoc (..), emptyFileLoc, fileLocPkgDb
, mkPkgFileLoc
, filelocIsPkg
, FileSearchLoc
, PkgKey, PkgKey1, PkgKey2
, showPkgKey
, PackageSearchFilter (..)
, pkgSearchFilter
, PackageCfgKeyVals, PackageInfo (..), PackageMp, Module2PackageMp, PackageDatabase (..), emptyPackageMp, emptyPackageDatabase
, mkInternalPkgFileBase )
where
import UHC.Light.Compiler.Base.Common
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe
import Data.Version
import Data.List
import UU.Parsing
import UHC.Util.ParseUtils
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.HsName
import UHC.Light.Compiler.Base.Target
import qualified UHC.Light.Compiler.ConfigInstall as Cfg










data FileLocKind
  = FileLocKind_Dir                                 -- plain directory
  | FileLocKind_Pkg PkgKey                          -- specific package
                    String                          -- with the dir inside package it was found
  | FileLocKind_PkgDb                               -- yet unknown package in the package database
  deriving Eq

instance Show FileLocKind where
  show  FileLocKind_Dir         = "directory"
  show (FileLocKind_Pkg p d)    = "package: " ++ showPkgKey p ++ "(in: " ++ d ++ ")"
  show  FileLocKind_PkgDb       = "package database"

















data FileLoc
  = FileLoc
      { filelocKind     :: FileLocKind
      , filelocDir      :: String
      }
  deriving Eq

instance Show FileLoc where
  show (FileLoc k d) = d ++ " (" ++ show k ++ ")"

emptyFileLoc :: FileLoc
emptyFileLoc = FileLoc FileLocKind_Dir ""

fileLocPkgDb :: FileLoc
fileLocPkgDb = FileLoc FileLocKind_PkgDb ""



mkDirFileLoc
  = FileLoc FileLocKind_Dir







mkPkgFileLoc :: PkgKey -> String -> FileLoc
mkPkgFileLoc p d = FileLoc (FileLocKind_Pkg p d) d



filelocIsPkg :: FileLoc -> Bool
filelocIsPkg (FileLoc (FileLocKind_Pkg _ _) _) = True
filelocIsPkg (FileLoc  FileLocKind_PkgDb    _) = True
filelocIsPkg _                                 = False



type StringPath  = [String]
type FileLocPath = [FileLoc]







type FileSearchLoc = FileLoc







type PkgKey1 = PkgName
type PkgKey2 = Maybe Version
type PkgKey  = (PkgKey1,PkgKey2)

instance HSNM PkgKey where
  mkHNm (n,Just v) =   mkHNmBase (n ++ "-" ++ (concat $ intersperse "." $ map show $ versionBranch v))
  mkHNm (n,_     ) =   mkHNm      n







showPkgKey :: PkgKey -> String
showPkgKey = show . mkHNm







-- | Description of hiding/exposing pkgs, determining the used packages for looking up modules.
data PackageSearchFilter
  -- Note: the below order is important, it is used for sorting just before having its effect on searchable packages.
  -- The current order means that in its filtering hiding is done first, thereby starting out with all available pkgs, then hide (all), then expose selectively
  = PackageSearchFilter_HideAll
  | PackageSearchFilter_HidePkg         [PkgKey]
  | PackageSearchFilter_ExposePkg       [PkgKey]
  deriving (Show, Eq, Ord)



pkgSearchFilter :: (x -> Maybe PkgKey) -> ([PkgKey] -> PackageSearchFilter) -> [x] -> [PackageSearchFilter]
pkgSearchFilter mkKey mk ss
  = if null ps then [] else [mk ps]
  where ps = catMaybes $ map mkKey ss







type PackageCfgKeyVals = Map.Map String String

-- | Per package info
data PackageInfo
  = PackageInfo
      { pkginfoLoc                  :: !FileLoc                     -- ^ directory location
      , pkginfoOrder                :: !Int                         -- ^ for multiple packages the relative order
      -- , pkginfoKeyVals               :: PackageCfgKeyVals            -- key/value pairs of pkg config info
      , pkginfoExposedModules       :: !HsNameS                     -- ^ exposed modules
      , pkginfoBuildDepends         :: !(Set.Set PkgKey)            -- ^ pkgs dependend on
      , pkginfoIsExposed            :: !Bool                        -- ^ pkg is exposed?
      }
      deriving Show

-- | content of a package (keys are name, then version)
type PackageMp = Map.Map PkgKey1 (Map.Map PkgKey2 [PackageInfo])

emptyPackageMp :: PackageMp
emptyPackageMp = Map.empty

-- | reverse map from module name to package key
type Module2PackageMp = Map.Map HsName [PkgKey]

-- | A package database contains an actual package map, plus a function
-- that maps modules to associated package maps. The latter is computed
-- by "freezing" the package database using "pkgDbFreeze".
data PackageDatabase
  = PackageDatabase
      { pkgDbPkgMp      :: PackageMp
      , pkgDbMod2PkgMp  :: Module2PackageMp
      }
      deriving Show

emptyPackageDatabase :: PackageDatabase
emptyPackageDatabase = PackageDatabase emptyPackageMp Map.empty








mkInternalPkgFileBase :: PkgKey -> String {- compiler name/version -} -> Target -> TargetFlavor -> FilePath
mkInternalPkgFileBase pkgKey compversion tgt tgtv =
  Cfg.mkInternalPkgFileBase (showPkgKey pkgKey) compversion (show tgt) (show tgtv)


</pre>