<a href="Render.hs1828087692621301815.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Render.hs2020739063107554536.out.html">next</a></br></br><pre>26d25
< import "base" Data.Bool     ( Bool(False, True), otherwise )
27d25
< import "base" Data.Eq       ( Eq )
28d25
< import "base" Data.Function ( ($) )
29d25
< import "base" Data.Functor  ( (<$>) )
30d25
< import "base" Data.Maybe    ( Maybe(Nothing, Just) )
31d25
< import "base" Prelude       ( (+) )
32d25
< import "base" Text.Show     ( Show )
33d25
< import "base-unicode-symbols" Data.Eq.Unicode     ( (≡) )
34d25
< import "base-unicode-symbols" Data.Monoid.Unicode ( (⊕) )
35d25
< import "base-unicode-symbols" Prelude.Unicode     ( ℤ )
36d25
< import "text"                 Data.Text ( Text )
37c26
< import "this"                 Text.Numeral.Exp.Reified ( Exp(..), Side(L, R) )
---
> import  Data.Bool     ( Bool(False, True), otherwise )
37a27
> import  Data.Eq       ( Eq )
37a28
> import  Data.Function ( ($) )
37a29
> import  Data.Functor  ( (<$>) )
37a30
> import  Data.Maybe    ( Maybe(Nothing, Just) )
37a31
> import  Prelude       ( (+) )
37a32
> import  Text.Show     ( Show )
37a33
> import  Data.Eq.Unicode     ( (≡) )
37a34
> import  Data.Monoid.Unicode ( (⊕) )
37a35
> import  Prelude.Unicode     ( ℤ )
37a36
> import                  Data.Text ( Text )
37a37
> import                  Text.Numeral.Exp.Reified ( Exp(..), Side(L, R) )
46d45
< render ∷ Repr i -- ^ Representation.
47d45
<        → i      -- ^ Initial inflection.
48d45
<        → Exp i  -- ^ The expression to render.
49c46
<        → Maybe Text
---
> render :: Repr i -- ^ Representation.
49a47
>        -> i      -- ^ Initial inflection.
49a48
>        -> Exp i  -- ^ The expression to render.
49a49
>        -> Maybe Text
54d53
<       go ctx inf (Neg x) = do x' ← go (CtxNeg ctx) inf x
55d53
<                               rn ← reprNeg
56c54
<                               rnc ← reprNegCombine
---
>       go ctx inf (Neg x) = do x' <- go (CtxNeg ctx) inf x
56a55
>                               rn <- reprNeg
56a56
>                               rnc <- reprNegCombine
58d57
<       go ctx inf (Add x y) = do x' ← go (CtxAdd L y ctx) inf x
59d57
<                                 y' ← go (CtxAdd R x ctx) inf y
60d57
<                                 ra ← reprAdd
61c58
<                                 rac ← reprAddCombine
---
>       go ctx inf (Add x y) = do x' <- go (CtxAdd L y ctx) inf x
61a59
>                                 y' <- go (CtxAdd R x ctx) inf y
61a60
>                                 ra <- reprAdd
61a61
>                                 rac <- reprAddCombine
63d62
<       go ctx inf (Mul x y) = do x' ← go (CtxMul L y ctx) inf x
64d62
<                                 y' ← go (CtxMul R x ctx) inf y
65d62
<                                 rm ← reprMul
66c63
<                                 rmc ← reprMulCombine
---
>       go ctx inf (Mul x y) = do x' <- go (CtxMul L y ctx) inf x
66a64
>                                 y' <- go (CtxMul R x ctx) inf y
66a65
>                                 rm <- reprMul
66a66
>                                 rmc <- reprMulCombine
68d67
<       go ctx inf (Sub x y) = do x' ← go (CtxSub L y ctx) inf x
69d67
<                                 y' ← go (CtxSub R x ctx) inf y
70d67
<                                 rs ← reprSub
71c68
<                                 rsc ← reprSubCombine
---
>       go ctx inf (Sub x y) = do x' <- go (CtxSub L y ctx) inf x
71a69
>                                 y' <- go (CtxSub R x ctx) inf y
71a70
>                                 rs <- reprSub
71a71
>                                 rsc <- reprSubCombine
73d72
<       go ctx inf (Frac x y) = do x' ← go (CtxFrac L y ctx) inf x
74d72
<                                  y' ← go (CtxFrac R x ctx) inf y
75d72
<                                  rf ← reprFrac
76c73
<                                  rfc ← reprFracCombine
---
>       go ctx inf (Frac x y) = do x' <- go (CtxFrac L y ctx) inf x
76a74
>                                  y' <- go (CtxFrac R x ctx) inf y
76a75
>                                  rf <- reprFrac
76a76
>                                  rfc <- reprFracCombine
95c95
<       reprUnknown ∷ Maybe Text
---
>       reprUnknown :: Maybe Text
98c98
<     , reprValue ∷ i → ℤ → Maybe (Ctx (Exp i) → Text)
---
>     , reprValue :: i -> ℤ -> Maybe (Ctx (Exp i) -> Text)
101c101
<     , reprNeg ∷ Maybe (Exp i → Ctx (Exp i) → Text)
---
>     , reprNeg :: Maybe (Exp i -> Ctx (Exp i) -> Text)
106c106
<     , reprAdd ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
---
>     , reprAdd :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
109c109
<     , reprMul ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
---
>     , reprMul :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
112c112
<     , reprSub ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
---
>     , reprSub :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
115c115
<     , reprFrac ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
---
>     , reprFrac :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
117c117
<     , reprScale ∷ ScaleRepr i
---
>     , reprScale :: ScaleRepr i
121c121
<     , reprNegCombine ∷ Maybe (Text → Text → Exp i → Text)
---
>     , reprNegCombine :: Maybe (Text -> Text -> Exp i -> Text)
123c123
<     , reprAddCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
---
>     , reprAddCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
125c125
<     , reprMulCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
---
>     , reprMulCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
127c127
<     , reprSubCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
---
>     , reprSubCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
129c129
<     , reprFracCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
---
>     , reprFracCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
136d135
<                  → ℤ -- ^ Base.
137d135
<                  → ℤ -- ^ Offset.
138d135
<                  → Exp i -- ^ Rank.
139d135
<                  → Ctx (Exp i) -- ^ Rank context.
140c136
<                  → Maybe Text
---
>                  -> ℤ -- ^ Base.
140a137
>                  -> ℤ -- ^ Offset.
140a138
>                  -> Exp i -- ^ Rank.
140a139
>                  -> Ctx (Exp i) -- ^ Rank context.
140a140
>                  -> Maybe Text
146c146
< defaultRepr ∷ Repr inf
---
> defaultRepr :: Repr inf
149c149
<          , reprValue   = \_ _ → Nothing
---
>          , reprValue   = \_ _ -> Nothing
155d154
<          , reprScale   = \_ _ _ _ _ → Nothing
156d154
<          , reprNegCombine  = Just $ \n x _     → n ⊕ x
157d154
<          , reprAddCombine  = Just $ \a x _ y _ → x ⊕ a ⊕ y
158d154
<          , reprMulCombine  = Just $ \m x _ y _ → x ⊕ m ⊕ y
159d154
<          , reprSubCombine  = Just $ \s x _ y _ → x ⊕ s ⊕ y
160c155
<          , reprFracCombine = Just $ \f n _ d _ → n ⊕ f ⊕ d
---
>          , reprScale   = \_ _ _ _ _ -> Nothing
160a156
>          , reprNegCombine  = Just $ \n x _     -> n ⊕ x
160a157
>          , reprAddCombine  = Just $ \a x _ y _ -> x ⊕ a ⊕ y
160a158
>          , reprMulCombine  = Just $ \m x _ y _ -> x ⊕ m ⊕ y
160a159
>          , reprSubCombine  = Just $ \s x _ y _ -> x ⊕ s ⊕ y
160a160
>          , reprFracCombine = Just $ \f n _ d _ -> n ⊕ f ⊕ d
190c190
< posIndex ∷ Ctx α → ℤ
---
> posIndex :: Ctx α -> ℤ
193c193
<       go ∷ ℤ → Ctx α → ℤ
---
>       go :: ℤ -> Ctx α -> ℤ
214c214
< isOutside ∷ Side → Ctx α → Bool
---
> isOutside :: Side -> Ctx α -> Bool
217c217
<       go ∷ Ctx α → Bool
---
>       go :: Ctx α -> Bool
230a231
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , UnicodeSyntax
           , PackageImports
           , RecordWildCards
  #-}

module Text.Numeral.Render
    ( -- * Rendering numerals
      render
      -- * Representation of numerals
    , Repr(..)
    , ScaleRepr
    , defaultRepr
      -- * Context of expressions
    , Ctx(..)
    , posIndex
    , isOutside
    )
    where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import "base" Data.Bool     ( Bool(False, True), otherwise )
import "base" Data.Eq       ( Eq )
import "base" Data.Function ( ($) )
import "base" Data.Functor  ( (<$>) )
import "base" Data.Maybe    ( Maybe(Nothing, Just) )
import "base" Prelude       ( (+) )
import "base" Text.Show     ( Show )
import "base-unicode-symbols" Data.Eq.Unicode     ( (≡) )
import "base-unicode-symbols" Data.Monoid.Unicode ( (⊕) )
import "base-unicode-symbols" Prelude.Unicode     ( ℤ )
import "text"                 Data.Text ( Text )
import "this"                 Text.Numeral.Exp.Reified ( Exp(..), Side(L, R) )


-------------------------------------------------------------------------------
-- Rendering numerals
-------------------------------------------------------------------------------

-- | Renders an expression to a 'Text' value according to a certain
-- representation and inflection.
render ∷ Repr i -- ^ Representation.
       → i      -- ^ Initial inflection.
       → Exp i  -- ^ The expression to render.
       → Maybe Text
render (Repr {..}) = go CtxEmpty
    where
      go _   _   Unknown = reprUnknown
      go ctx inf (Lit n) = ($ ctx) <$> reprValue inf n
      go ctx inf (Neg x) = do x' ← go (CtxNeg ctx) inf x
                              rn ← reprNeg
                              rnc ← reprNegCombine
                              Just $ rnc (rn x ctx) x' x
      go ctx inf (Add x y) = do x' ← go (CtxAdd L y ctx) inf x
                                y' ← go (CtxAdd R x ctx) inf y
                                ra ← reprAdd
                                rac ← reprAddCombine
                                Just $ rac (ra x y ctx) x' x y' y
      go ctx inf (Mul x y) = do x' ← go (CtxMul L y ctx) inf x
                                y' ← go (CtxMul R x ctx) inf y
                                rm ← reprMul
                                rmc ← reprMulCombine
                                Just $ rmc (rm x y ctx) x' x y' y
      go ctx inf (Sub x y) = do x' ← go (CtxSub L y ctx) inf x
                                y' ← go (CtxSub R x ctx) inf y
                                rs ← reprSub
                                rsc ← reprSubCombine
                                Just $ rsc (rs x y ctx) x' x y' y
      go ctx inf (Frac x y) = do x' ← go (CtxFrac L y ctx) inf x
                                 y' ← go (CtxFrac R x ctx) inf y
                                 rf ← reprFrac
                                 rfc ← reprFracCombine
                                 Just $ rfc (rf x y ctx) x' x y' y
      go ctx inf (Scale b o r) = reprScale inf b o r ctx
      go ctx inf (Dual   x) = go (CtxDual   ctx) inf x
      go ctx inf (Plural x) = go (CtxPlural ctx) inf x
      go ctx inf (Inflection f x) = go ctx (f inf) x


--------------------------------------------------------------------------------
-- Representation of numerals
--------------------------------------------------------------------------------

-- | A representation for numerals.
--
-- A 'Repr' contains all the information on how to render an
-- 'Exp'ression to a 'Text' value.
data Repr i =
    Repr
    { -- | Representation for unknown values.
      reprUnknown ∷ Maybe Text
      -- | Renders a literal value. Not necessarily defined for every
      -- value.
    , reprValue ∷ i → ℤ → Maybe (Ctx (Exp i) → Text)
      -- | Renders a negation. This concerns the negation itself, not
      -- the thing being negated.
    , reprNeg ∷ Maybe (Exp i → Ctx (Exp i) → Text)
      -- | Renders an addition. This concerns the addition itself, not
      -- the things being added. For example: In \"one hundred and
      -- eighty\" this function would be responsible for rendering the
      -- \"and\".
    , reprAdd ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
      -- | Renders a multiplication. This concerns the multiplication
      -- itself, not the things being multiplied.
    , reprMul ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
      -- | Renders a subtraction. This concerns the subtraction
      -- itself, not the things being subtracted.
    , reprSub ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
      -- | Renders a fraction. This concerns the fraction itself, not
      -- the numerator or the denominator.
    , reprFrac ∷ Maybe (Exp i → Exp i → Ctx (Exp i) → Text)
      -- | Renders a step in a scale of large values.
    , reprScale ∷ ScaleRepr i
      -- | Combines a negation and the thing being negated. For
      -- example: this would combine \"minus\" and \"three\" into
      -- \"minus three\".
    , reprNegCombine ∷ Maybe (Text → Text → Exp i → Text)
      -- | Combines an addition and the things being added.
    , reprAddCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
      -- | Combines a multiplication and the things being multiplied.
    , reprMulCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
      -- | Combines a subtraction and the things being subtracted.
    , reprSubCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
      -- | Combines a fraction and the numerator and denominator.
    , reprFracCombine ∷ Maybe (Text → Text → Exp i → Text → Exp i → Text)
    }

-- | Function that renders the representation of a step in a scale of
-- large values. The value represented by the step is 10 ^ (rank *
-- base + offset).
type ScaleRepr i = i
                 → ℤ -- ^ Base.
                 → ℤ -- ^ Offset.
                 → Exp i -- ^ Rank.
                 → Ctx (Exp i) -- ^ Rank context.
                 → Maybe Text

-- | The default representation.
--
-- Only the combining functions are defined. The rest are either
-- 'Nothing' or always produce 'Nothing'.
defaultRepr ∷ Repr inf
defaultRepr =
    Repr { reprUnknown = Nothing
         , reprValue   = \_ _ → Nothing
         , reprNeg     = Nothing
         , reprAdd     = Nothing
         , reprMul     = Nothing
         , reprSub     = Nothing
         , reprFrac    = Nothing
         , reprScale   = \_ _ _ _ _ → Nothing
         , reprNegCombine  = Just $ \n x _     → n ⊕ x
         , reprAddCombine  = Just $ \a x _ y _ → x ⊕ a ⊕ y
         , reprMulCombine  = Just $ \m x _ y _ → x ⊕ m ⊕ y
         , reprSubCombine  = Just $ \s x _ y _ → x ⊕ s ⊕ y
         , reprFracCombine = Just $ \f n _ d _ → n ⊕ f ⊕ d
         }


--------------------------------------------------------------------------------
-- Context of expressions
--------------------------------------------------------------------------------

-- | A context in which an 'Exp'ression appears.
data Ctx α   -- | The empty context. Used for top level expressions.
           = CtxEmpty
             -- | Negation context.
           | CtxNeg (Ctx α)
             -- | Addition context.
           | CtxAdd Side α (Ctx α)
             -- | Multiplication context.
           | CtxMul Side α (Ctx α)
             -- | Subtraction context.
           | CtxSub Side α (Ctx α)
             -- | Fraction context.
           | CtxFrac Side α (Ctx α)
             -- | Scale context.
           | CtxScale (Ctx α)
             -- | Dual context.
           | CtxDual (Ctx α)
             -- | Plural context.
           | CtxPlural (Ctx α)
             deriving (Eq, Show)


posIndex ∷ Ctx α → ℤ
posIndex c = go 0 c
    where
      go ∷ ℤ → Ctx α → ℤ
      go acc CtxEmpty = acc
      go acc (CtxNeg nc) = go acc nc
      go acc (CtxAdd  as _ ac) = go (acc + if as ≡ L then -1 else 1) ac
      go acc (CtxMul  ms _ mc) = go (acc + if ms ≡ L then -1 else 1) mc
      go acc (CtxSub  ss _ sc) = go (acc + if ss ≡ L then -1 else 1) sc
      go acc (CtxFrac fs _ fc) = go (acc + if fs ≡ L then -1 else 1) fc
      go acc (CtxScale  sc) = go acc sc
      go acc (CtxDual   dc) = go acc dc
      go acc (CtxPlural pc) = go acc pc

-- | Checks whether a context is completely on the outside of an
-- expression, either left or right.
--
-- Given the following expression:
--
-- @
-- 'Add' ('Lit' 1000) ('Add' ('Mul' ('Lit' 2) ('Lit' 100)) ('Add' ('Lit' 4) ('Mul' ('Lit' 3) ('Lit' 10))))
-- @
--
-- On the left we have @'Lit' 1000@ and on the right @'Lit' 10@.
isOutside ∷ Side → Ctx α → Bool
isOutside s c = go c
    where
      go ∷ Ctx α → Bool
      go CtxEmpty = True
      go (CtxNeg nc) = go nc
      go (CtxAdd  as _ ac) | as ≡ s    = go ac
                           | otherwise = False
      go (CtxMul  ms _ mc) | ms ≡ s    = go mc
                           | otherwise = False
      go (CtxSub  ss _ sc) | ss ≡ s    = go sc
                           | otherwise = False
      go (CtxFrac fs _ fc) | fs ≡ s    = go fc
                           | otherwise = False
      go (CtxScale  sc) = go sc
      go (CtxDual   dc) = go dc
      go (CtxPlural pc) = go pc
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , UnicodeSyntax
           , PackageImports
           , RecordWildCards
  #-}

module Text.Numeral.Render
    ( -- * Rendering numerals
      render
      -- * Representation of numerals
    , Repr(..)
    , ScaleRepr
    , defaultRepr
      -- * Context of expressions
    , Ctx(..)
    , posIndex
    , isOutside
    )
    where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import  Data.Bool     ( Bool(False, True), otherwise )
import  Data.Eq       ( Eq )
import  Data.Function ( ($) )
import  Data.Functor  ( (<$>) )
import  Data.Maybe    ( Maybe(Nothing, Just) )
import  Prelude       ( (+) )
import  Text.Show     ( Show )
import  Data.Eq.Unicode     ( (≡) )
import  Data.Monoid.Unicode ( (⊕) )
import  Prelude.Unicode     ( ℤ )
import                  Data.Text ( Text )
import                  Text.Numeral.Exp.Reified ( Exp(..), Side(L, R) )


-------------------------------------------------------------------------------
-- Rendering numerals
-------------------------------------------------------------------------------

-- | Renders an expression to a 'Text' value according to a certain
-- representation and inflection.
render :: Repr i -- ^ Representation.
       -> i      -- ^ Initial inflection.
       -> Exp i  -- ^ The expression to render.
       -> Maybe Text
render (Repr {..}) = go CtxEmpty
    where
      go _   _   Unknown = reprUnknown
      go ctx inf (Lit n) = ($ ctx) <$> reprValue inf n
      go ctx inf (Neg x) = do x' <- go (CtxNeg ctx) inf x
                              rn <- reprNeg
                              rnc <- reprNegCombine
                              Just $ rnc (rn x ctx) x' x
      go ctx inf (Add x y) = do x' <- go (CtxAdd L y ctx) inf x
                                y' <- go (CtxAdd R x ctx) inf y
                                ra <- reprAdd
                                rac <- reprAddCombine
                                Just $ rac (ra x y ctx) x' x y' y
      go ctx inf (Mul x y) = do x' <- go (CtxMul L y ctx) inf x
                                y' <- go (CtxMul R x ctx) inf y
                                rm <- reprMul
                                rmc <- reprMulCombine
                                Just $ rmc (rm x y ctx) x' x y' y
      go ctx inf (Sub x y) = do x' <- go (CtxSub L y ctx) inf x
                                y' <- go (CtxSub R x ctx) inf y
                                rs <- reprSub
                                rsc <- reprSubCombine
                                Just $ rsc (rs x y ctx) x' x y' y
      go ctx inf (Frac x y) = do x' <- go (CtxFrac L y ctx) inf x
                                 y' <- go (CtxFrac R x ctx) inf y
                                 rf <- reprFrac
                                 rfc <- reprFracCombine
                                 Just $ rfc (rf x y ctx) x' x y' y
      go ctx inf (Scale b o r) = reprScale inf b o r ctx
      go ctx inf (Dual   x) = go (CtxDual   ctx) inf x
      go ctx inf (Plural x) = go (CtxPlural ctx) inf x
      go ctx inf (Inflection f x) = go ctx (f inf) x


--------------------------------------------------------------------------------
-- Representation of numerals
--------------------------------------------------------------------------------

-- | A representation for numerals.
--
-- A 'Repr' contains all the information on how to render an
-- 'Exp'ression to a 'Text' value.
data Repr i =
    Repr
    { -- | Representation for unknown values.
      reprUnknown :: Maybe Text
      -- | Renders a literal value. Not necessarily defined for every
      -- value.
    , reprValue :: i -> ℤ -> Maybe (Ctx (Exp i) -> Text)
      -- | Renders a negation. This concerns the negation itself, not
      -- the thing being negated.
    , reprNeg :: Maybe (Exp i -> Ctx (Exp i) -> Text)
      -- | Renders an addition. This concerns the addition itself, not
      -- the things being added. For example: In \"one hundred and
      -- eighty\" this function would be responsible for rendering the
      -- \"and\".
    , reprAdd :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
      -- | Renders a multiplication. This concerns the multiplication
      -- itself, not the things being multiplied.
    , reprMul :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
      -- | Renders a subtraction. This concerns the subtraction
      -- itself, not the things being subtracted.
    , reprSub :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
      -- | Renders a fraction. This concerns the fraction itself, not
      -- the numerator or the denominator.
    , reprFrac :: Maybe (Exp i -> Exp i -> Ctx (Exp i) -> Text)
      -- | Renders a step in a scale of large values.
    , reprScale :: ScaleRepr i
      -- | Combines a negation and the thing being negated. For
      -- example: this would combine \"minus\" and \"three\" into
      -- \"minus three\".
    , reprNegCombine :: Maybe (Text -> Text -> Exp i -> Text)
      -- | Combines an addition and the things being added.
    , reprAddCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
      -- | Combines a multiplication and the things being multiplied.
    , reprMulCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
      -- | Combines a subtraction and the things being subtracted.
    , reprSubCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
      -- | Combines a fraction and the numerator and denominator.
    , reprFracCombine :: Maybe (Text -> Text -> Exp i -> Text -> Exp i -> Text)
    }

-- | Function that renders the representation of a step in a scale of
-- large values. The value represented by the step is 10 ^ (rank *
-- base + offset).
type ScaleRepr i = i
                 -> ℤ -- ^ Base.
                 -> ℤ -- ^ Offset.
                 -> Exp i -- ^ Rank.
                 -> Ctx (Exp i) -- ^ Rank context.
                 -> Maybe Text

-- | The default representation.
--
-- Only the combining functions are defined. The rest are either
-- 'Nothing' or always produce 'Nothing'.
defaultRepr :: Repr inf
defaultRepr =
    Repr { reprUnknown = Nothing
         , reprValue   = \_ _ -> Nothing
         , reprNeg     = Nothing
         , reprAdd     = Nothing
         , reprMul     = Nothing
         , reprSub     = Nothing
         , reprFrac    = Nothing
         , reprScale   = \_ _ _ _ _ -> Nothing
         , reprNegCombine  = Just $ \n x _     -> n ⊕ x
         , reprAddCombine  = Just $ \a x _ y _ -> x ⊕ a ⊕ y
         , reprMulCombine  = Just $ \m x _ y _ -> x ⊕ m ⊕ y
         , reprSubCombine  = Just $ \s x _ y _ -> x ⊕ s ⊕ y
         , reprFracCombine = Just $ \f n _ d _ -> n ⊕ f ⊕ d
         }


--------------------------------------------------------------------------------
-- Context of expressions
--------------------------------------------------------------------------------

-- | A context in which an 'Exp'ression appears.
data Ctx α   -- | The empty context. Used for top level expressions.
           = CtxEmpty
             -- | Negation context.
           | CtxNeg (Ctx α)
             -- | Addition context.
           | CtxAdd Side α (Ctx α)
             -- | Multiplication context.
           | CtxMul Side α (Ctx α)
             -- | Subtraction context.
           | CtxSub Side α (Ctx α)
             -- | Fraction context.
           | CtxFrac Side α (Ctx α)
             -- | Scale context.
           | CtxScale (Ctx α)
             -- | Dual context.
           | CtxDual (Ctx α)
             -- | Plural context.
           | CtxPlural (Ctx α)
             deriving (Eq, Show)


posIndex :: Ctx α -> ℤ
posIndex c = go 0 c
    where
      go :: ℤ -> Ctx α -> ℤ
      go acc CtxEmpty = acc
      go acc (CtxNeg nc) = go acc nc
      go acc (CtxAdd  as _ ac) = go (acc + if as ≡ L then -1 else 1) ac
      go acc (CtxMul  ms _ mc) = go (acc + if ms ≡ L then -1 else 1) mc
      go acc (CtxSub  ss _ sc) = go (acc + if ss ≡ L then -1 else 1) sc
      go acc (CtxFrac fs _ fc) = go (acc + if fs ≡ L then -1 else 1) fc
      go acc (CtxScale  sc) = go acc sc
      go acc (CtxDual   dc) = go acc dc
      go acc (CtxPlural pc) = go acc pc

-- | Checks whether a context is completely on the outside of an
-- expression, either left or right.
--
-- Given the following expression:
--
-- @
-- 'Add' ('Lit' 1000) ('Add' ('Mul' ('Lit' 2) ('Lit' 100)) ('Add' ('Lit' 4) ('Mul' ('Lit' 3) ('Lit' 10))))
-- @
--
-- On the left we have @'Lit' 1000@ and on the right @'Lit' 10@.
isOutside :: Side -> Ctx α -> Bool
isOutside s c = go c
    where
      go :: Ctx α -> Bool
      go CtxEmpty = True
      go (CtxNeg nc) = go nc
      go (CtxAdd  as _ ac) | as ≡ s    = go ac
                           | otherwise = False
      go (CtxMul  ms _ mc) | ms ≡ s    = go mc
                           | otherwise = False
      go (CtxSub  ss _ sc) | ss ≡ s    = go sc
                           | otherwise = False
      go (CtxFrac fs _ fc) | fs ≡ s    = go fc
                           | otherwise = False
      go (CtxScale  sc) = go sc
      go (CtxDual   dc) = go dc
      go (CtxPlural pc) = go pc

</pre>