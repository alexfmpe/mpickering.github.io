<a href="Parallel.hs14362807671854658689.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Parser.hs17090870112031615252.out.html">next</a></br></br><pre>22c22
< {-# LINE 30 "src/ehc/EH/Parser.chs" #-}
---
> 
22a23
> 
22a24
> 
22a25
> 
22a26
> 
22a27
> 
22a28
> 
22a29
> 
43c50
< {-# LINE 52 "src/ehc/EH/Parser.chs" #-}
---
> 
43a51
> 
46c54
< {-# LINE 56 "src/ehc/EH/Parser.chs" #-}
---
> 
46a55
> 
49c58
< {-# LINE 60 "src/ehc/EH/Parser.chs" #-}
---
> 
49a59
> 
59c69
< {-# LINE 71 "src/ehc/EH/Parser.chs" #-}
---
> 
59a70
> 
65c76
< {-# LINE 82 "src/ehc/EH/Parser.chs" #-}
---
> 
65a77
> 
65a78
> 
65a79
> 
65a80
> 
65a81
> 
69c85
< {-# LINE 99 "src/ehc/EH/Parser.chs" #-}
---
> 
69a86
> 
69a87
> 
69a88
> 
69a89
> 
69a90
> 
69a91
> 
69a92
> 
69a93
> 
69a94
> 
69a95
> 
69a96
> 
69a97
> 
69a98
> 
75c104
< {-# LINE 110 "src/ehc/EH/Parser.chs" #-}
---
> 
75a105
> 
75a106
> 
75a107
> 
75a108
> 
75a109
> 
78c112
< {-# LINE 118 "src/ehc/EH/Parser.chs" #-}
---
> 
78a113
> 
78a114
> 
78a115
> 
78a116
> 
78a117
> 
82c121
< {-# LINE 123 "src/ehc/EH/Parser.chs" #-}
---
> 
82a122
> 
86c126
< {-# LINE 132 "src/ehc/EH/Parser.chs" #-}
---
> 
86a127
> 
86a128
> 
86a129
> 
86a130
> 
86a131
> 
88c133
< {-# LINE 135 "src/ehc/EH/Parser.chs" #-}
---
> 
88a134
> 
103c149
< {-# LINE 155 "src/ehc/EH/Parser.chs" #-}
---
> 
103a150
> 
103a151
> 
103a152
> 
103a153
> 
103a154
> 
106c157
< {-# LINE 159 "src/ehc/EH/Parser.chs" #-}
---
> 
106a158
> 
109c161
< {-# LINE 172 "src/ehc/EH/Parser.chs" #-}
---
> 
109a162
> 
109a163
> 
109a164
> 
109a165
> 
109a166
> 
109a167
> 
109a168
> 
109a169
> 
109a170
> 
109a171
> 
116c178
< {-# LINE 183 "src/ehc/EH/Parser.chs" #-}
---
> 
116a179
> 
116a180
> 
116a181
> 
116a182
> 
121c187
< {-# LINE 189 "src/ehc/EH/Parser.chs" #-}
---
> 
121a188
> 
123c190
< {-# LINE 192 "src/ehc/EH/Parser.chs" #-}
---
> 
123a191
> 
126c194
< {-# LINE 200 "src/ehc/EH/Parser.chs" #-}
---
> 
126a195
> 
126a196
> 
126a197
> 
126a198
> 
126a199
> 
134c207
< {-# LINE 213 "src/ehc/EH/Parser.chs" #-}
---
> 
134a208
> 
134a209
> 
134a210
> 
134a211
> 
134a212
> 
136c214
< {-# LINE 216 "src/ehc/EH/Parser.chs" #-}
---
> 
136a215
> 
138c217
< {-# LINE 219 "src/ehc/EH/Parser.chs" #-}
---
> 
138a218
> 
141c221
< {-# LINE 226 "src/ehc/EH/Parser.chs" #-}
---
> 
141a222
> 
141a223
> 
141a224
> 
141a225
> 
155c239
< {-# LINE 244 "src/ehc/EH/Parser.chs" #-}
---
> 
155a240
> 
155a241
> 
155a242
> 
155a243
> 
158c246
< {-# LINE 253 "src/ehc/EH/Parser.chs" #-}
---
> 
158a247
> 
158a248
> 
158a249
> 
158a250
> 
158a251
> 
158a252
> 
162c256
< {-# LINE 258 "src/ehc/EH/Parser.chs" #-}
---
> 
162a257
> 
166c261
< {-# LINE 263 "src/ehc/EH/Parser.chs" #-}
---
> 
166a262
> 
170c266
< {-# LINE 268 "src/ehc/EH/Parser.chs" #-}
---
> 
170a267
> 
172c269
< {-# LINE 271 "src/ehc/EH/Parser.chs" #-}
---
> 
172a270
> 
175c273
< {-# LINE 275 "src/ehc/EH/Parser.chs" #-}
---
> 
175a274
> 
195c294
< {-# LINE 299 "src/ehc/EH/Parser.chs" #-}
---
> 
195a295
> 
195a296
> 
195a297
> 
195a298
> 
198c301
< {-# LINE 303 "src/ehc/EH/Parser.chs" #-}
---
> 
198a302
> 
202c306
< {-# LINE 313 "src/ehc/EH/Parser.chs" #-}
---
> 
202a307
> 
202a308
> 
202a309
> 
202a310
> 
202a311
> 
202a312
> 
207c317
< {-# LINE 322 "src/ehc/EH/Parser.chs" #-}
---
> 
207a318
> 
207a319
> 
207a320
> 
207a321
> 
210c324
< {-# LINE 330 "src/ehc/EH/Parser.chs" #-}
---
> 
210a325
> 
210a326
> 
210a327
> 
210a328
> 
210a329
> 
214c333
< {-# LINE 335 "src/ehc/EH/Parser.chs" #-}
---
> 
214a334
> 
216c336
< {-# LINE 338 "src/ehc/EH/Parser.chs" #-}
---
> 
216a337
> 
219c340
< {-# LINE 343 "src/ehc/EH/Parser.chs" #-}
---
> 
219a341
> 
219a342
> 
224c347
< {-# LINE 352 "src/ehc/EH/Parser.chs" #-}
---
> 
224a348
> 
224a349
> 
224a350
> 
224a351
> 
226c353
< {-# LINE 358 "src/ehc/EH/Parser.chs" #-}
---
> 
226a354
> 
226a355
> 
226a356
> 
226a357
> 
228c359
< {-# LINE 364 "src/ehc/EH/Parser.chs" #-}
---
> 
228a360
> 
228a361
> 
228a362
> 
228a363
> 
230c365
< {-# LINE 367 "src/ehc/EH/Parser.chs" #-}
---
> 
230a366
> 
232c368
< {-# LINE 370 "src/ehc/EH/Parser.chs" #-}
---
> 
232a369
> 
235c372
< {-# LINE 374 "src/ehc/EH/Parser.chs" #-}
---
> 
235a373
> 
239c377
< {-# LINE 381 "src/ehc/EH/Parser.chs" #-}
---
> 
239a378
> 
239a379
> 
239a380
> 
247c388
< {-# LINE 400 "src/ehc/EH/Parser.chs" #-}
---
> 
247a389
> 
247a390
> 
247a391
> 
247a392
> 
247a393
> 
247a394
> 
247a395
> 
247a396
> 
247a397
> 
247a398
> 
247a399
> 
255c407
< {-# LINE 420 "src/ehc/EH/Parser.chs" #-}
---
> 
255a408
> 
255a409
> 
255a410
> 
255a411
> 
255a412
> 
255a413
> 
255a414
> 
255a415
> 
255a416
> 
255a417
> 
255a418
> 
255a419
> 
259c423
< {-# LINE 437 "src/ehc/EH/Parser.chs" #-}
---
> 
259a424
> 
259a425
> 
259a426
> 
259a427
> 
259a428
> 
259a429
> 
259a430
> 
259a431
> 
259a432
> 
259a433
> 
259a434
> 
259a435
> 
259a436
> 
262c439
< {-# LINE 441 "src/ehc/EH/Parser.chs" #-}
---
> 
262a440
> 
268c446
< {-# LINE 450 "src/ehc/EH/Parser.chs" #-}
---
> 
268a447
> 
268a448
> 
268a449
> 
276c457
< {-# LINE 459 "src/ehc/EH/Parser.chs" #-}
---
> 
276a458
> 
280c462
< {-# LINE 468 "src/ehc/EH/Parser.chs" #-}
---
> 
280a463
> 
280a464
> 
280a465
> 
280a466
> 
280a467
> 
311c498
< {-# LINE 500 "src/ehc/EH/Parser.chs" #-}
---
> 
311a499
> 
319c507
< {-# LINE 513 "src/ehc/EH/Parser.chs" #-}
---
> 
319a508
> 
319a509
> 
319a510
> 
319a511
> 
319a512
> 
323c516
< {-# LINE 518 "src/ehc/EH/Parser.chs" #-}
---
> 
323a517
> 
328c522
< {-# LINE 524 "src/ehc/EH/Parser.chs" #-}
---
> 
328a523
> 
333c528
< {-# LINE 530 "src/ehc/EH/Parser.chs" #-}
---
> 
333a529
> 
338c534
< {-# LINE 536 "src/ehc/EH/Parser.chs" #-}
---
> 
338a535
> 
342c539
< {-# LINE 541 "src/ehc/EH/Parser.chs" #-}
---
> 
342a540
> 
346c544
< {-# LINE 550 "src/ehc/EH/Parser.chs" #-}
---
> 
346a545
> 
346a546
> 
346a547
> 
346a548
> 
346a549
> 
349c552
< {-# LINE 558 "src/ehc/EH/Parser.chs" #-}
---
> 
349a553
> 
349a554
> 
349a555
> 
349a556
> 
349a557
> 
372c580
< {-# LINE 594 "src/ehc/EH/Parser.chs" #-}
---
> 
372a581
> 
372a582
> 
372a583
> 
372a584
> 
372a585
> 
372a586
> 
372a587
> 
372a588
> 
372a589
> 
372a590
> 
372a591
> 
372a592
> 
372a593
> 
375a597
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EH.Parser
( pAGItf )
where
import System.IO
import UU.Parsing
import UU.Parsing.Offside
import UHC.Util.ParseUtils
import UU.Scanner.GenToken
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.EH
import UHC.Light.Compiler.Ty
import qualified Data.Set as Set
import UHC.Light.Compiler.Foreign.Parser
import UHC.Light.Compiler.Foreign




{-# LINE 30 "src/ehc/EH/Parser.chs" #-}
type EHCParser        ep    =    LayoutParser Token ep

pAGItf                      ::   EHCParser AGItf

pExpr, pExprApp, pExprBase  ::   EHCParser Expr
pExprPrefix                 ::   EHCParser (Expr -> Expr)

pDecls                      ::   EHCParser Decls
pDecl                       ::   EHCParser Decl

pPatExpr, pPatExprBase      ::   EHCParser PatExpr

pTyExpr, pTyExprBase        ::   EHCParser TyExpr

pInt                        ::   EHCParser Int
pChr                        ::   EHCParser Char

pCon                        ::   EHCParser HsName
pVar                        ::   EHCParser HsName

{-# LINE 52 "src/ehc/EH/Parser.chs" #-}
pTyExprPrefix               ::   EHCParser (TyExpr -> TyExpr)

{-# LINE 56 "src/ehc/EH/Parser.chs" #-}
pTyExprApp                  ::   EHCParser TyExpr

{-# LINE 60 "src/ehc/EH/Parser.chs" #-}
pCaseAlts                   ::   EHCParser CaseAlts
pCaseAlt                    ::   EHCParser CaseAlt

pDataConstr                 ::   EHCParser DataConstr
pDataConstrs                ::   EHCParser DataConstrs

pTyVars                     ::   EHCParser TyVars
pTyVar                      ::   EHCParser TyVar

{-# LINE 71 "src/ehc/EH/Parser.chs" #-}
pDataLabFields              ::   EHCParser DataFields
pDataFields                 ::   EHCParser DataFields
pDataLabField               ::   EHCParser DataField
pDataField                  ::   EHCParser DataField

{-# LINE 82 "src/ehc/EH/Parser.chs" #-}
pApp            ::   AppLike a boundmeta => EHCParser a -> EHCParser a
pApp p          =    appTopApp <$> pList1 p

{-# LINE 99 "src/ehc/EH/Parser.chs" #-}
pChr            =    head <$> pChar
pInt            =    read <$> pInteger
pCon            =    hsnFromString <$> pConid
pVar            =    hsnFromString <$> pVarid

{-# LINE 110 "src/ehc/EH/Parser.chs" #-}
pAGItf          =    AGItf_AGItf <$> pExpr

{-# LINE 118 "src/ehc/EH/Parser.chs" #-}
pDecls          =    foldr (:) []         <$>  pBlock pOCurly pSemi pCCurly pDecl
pDecl           =    mkEH Decl_Val        <$>  pPatExprBase  <*   pEQUAL   <*> pExpr
                <|>  mkEH Decl_TySig      <$>  pVar          <*   pDCOLON  <*> pTyExpr
{-# LINE 123 "src/ehc/EH/Parser.chs" #-}
                <|>  (\c tvs cons -> mkEH Decl_Data False c tvs cons Nothing)
                                          <$   pDATA         <*>  pCon       <*> pTyVars
                                                             <*   pEQUAL     <*> pDataConstrs
{-# LINE 132 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH Decl_KiSig      <$>  pCon          <*   pDCOLON    <*> pKiExpr
{-# LINE 135 "src/ehc/EH/Parser.chs" #-}
                <|>  (\(conv,_) saf imp nm sig
                        -> mkEH Decl_FFI conv saf
                             (
                               (\i -> fst $ parseForeignEnt ForeignDirection_Import conv Nothing i)
                               (if null imp then show nm else imp))
                             nm sig
                     )
                     <$   pFOREIGN <* pIMPORT <*> pFFIWay
                     <*>  (pV (   pSAFE
                              <|> pUNSAFE
                              ) `opt` "safe")
                     <*>  (pString `opt` "")
                     <*>  pVar
                     <*   pDCOLON <*> pTyExpr
{-# LINE 155 "src/ehc/EH/Parser.chs" #-}
                <|>  pDeclClass
                <|>  pDeclInstance
{-# LINE 159 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH Decl_Type       <$   pTYPE         <*>  pCon
                                                             <*   pEQUAL     <*> pTyExpr
{-# LINE 172 "src/ehc/EH/Parser.chs" #-}
pPatExprBase    =    pVar <**>  (    flip (mkEH PatExpr_VarAs) <$ pAT <*> pPatExprBase
                                <|>  pSucceed (mkEH PatExpr_Var)
                                )
                <|>  mkEH PatExpr_Con     <$>  pCon
                <|>  mkEH PatExpr_IConst  <$>  pInt
                <|>  mkEH PatExpr_CConst  <$>  pChr
{-# LINE 183 "src/ehc/EH/Parser.chs" #-}
                <|>  pParenRow True (show hsnORec) (show hsnCRec) "=" Nothing
                        (mkEH RecPatExpr_Empty,mkEH RecPatExpr_Expr . mkEH PatExpr_Var,mkEH RecPatExpr_Ext,mkEH PatExpr_Rec,mkEH PatExpr_Parens)
                        pSel pPatExpr

{-# LINE 189 "src/ehc/EH/Parser.chs" #-}
pPatExpr        =    pApp pPatExprBase
{-# LINE 192 "src/ehc/EH/Parser.chs" #-}
                     <??> (mkEH PatExpr_TypeAs <$ pDCOLON <*> pTyExpr)

{-# LINE 200 "src/ehc/EH/Parser.chs" #-}
pKiExpr, pKiExprBase        ::   EHCParser KiExpr

pKiExprBase     =    mkEH KiExpr_Con <$> (pCon <|> pHNm pSTAR)
                <|>  mkEH KiExpr_Var <$> pVar
                <|>  pParens pKiExpr
pKiExpr         =    pChainr (app1Arr <$ pKeyw hsnArrow) pKiExprBase

{-# LINE 213 "src/ehc/EH/Parser.chs" #-}
pTyExprBase     =    mkEH TyExpr_Con       <$>  pCon
{-# LINE 216 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH TyExpr_Wild      <$   pTDOT
{-# LINE 219 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH TyExpr_Var       <$>  pVar
                <|>  mkEH TyExpr_VarWild   <$   pPERCENT <*> pVar
{-# LINE 226 "src/ehc/EH/Parser.chs" #-}
                <|>  pParenRow False (show hsnORow) (show hsnCRow) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext,mkEH TyExpr_Row,id)
                        pVar pTyExpr
                <|>  pParenRow True (show hsnORec) (show hsnCRec) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext
                            ,\r -> appConApp hsnRec [mkEH TyExpr_Row r]
                            ,mkEH TyExpr_Parens)
                        pVar pTyExpr
                <|>  pParenRow False (show hsnOSum) (show hsnCSum) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext
                            ,\r -> appConApp hsnSum [mkEH TyExpr_Row r]
                            ,id)
                        pVar pTyExpr
{-# LINE 244 "src/ehc/EH/Parser.chs" #-}
                where  semVar = (mkEH RowTyExpr_Var)

{-# LINE 253 "src/ehc/EH/Parser.chs" #-}
pTyExpr         =    pTyExprPrefix <*> pTyExpr
                <|>  pTyExprApp <??> (flip app1Arr <$ pKeyw hsnArrow <*> pTyExpr)

{-# LINE 258 "src/ehc/EH/Parser.chs" #-}
pTyExprs        ::   EHCParser TyExprs
pTyExprs        =    pList pTyExprBase

{-# LINE 263 "src/ehc/EH/Parser.chs" #-}
pTyExprPrefix   =    mkEH TyExpr_Quant
                     <$>  (tyQu_Forall <$ pKey "forall" <|> tyQu_Exists <$ pKey "exists")
                     <*>  pVar <* pKey "."
{-# LINE 268 "src/ehc/EH/Parser.chs" #-}
                <|>  pTyPrExprPrefix
{-# LINE 271 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH TyExpr_Lam <$ pLAM <*> pVar <* pRARROW

{-# LINE 275 "src/ehc/EH/Parser.chs" #-}
pTyPrExprPrefix ::   EHCParser (TyExpr -> TyExpr)
pTyPrExprPrefix =    app1Arr
                     <$>  pPackImpl
                            (    pPr <|> pIm
                            <|>  pSucceed  (mkEH TyExpr_NoImpls)
                            )
                     <*   pKeyw hsnArrow
                <|>  (    app1Arr <$> (pPrB <|> pIm)
                     <|>  flip (foldr app1Arr)
                          <$> pParens ((:) <$> pPr <*> (pImO <|> (++) <$> pList1 (pComma *> pPr) <*> pImO))
                     )
                     <*   pKeyw hsnPrArrow
                where  pPrB  =   mkEH TyExpr_Pred   <$>  pPrExprBase
                       pPr   ::  EHCParser TyExpr
                       pPr   =   mkEH TyExpr_Pred   <$>  pPrExpr
                       pIm   ::  EHCParser TyExpr
                       pIm   =   mkEH TyExpr_Impls  <$   pKey "..."
                       pImO  =   (:[]) <$ pComma <*> pIm `opt` []

{-# LINE 299 "src/ehc/EH/Parser.chs" #-}
pTyExprApp      =    pApp pTyExprBase

{-# LINE 303 "src/ehc/EH/Parser.chs" #-}
pPackImpl       ::   IsParser p Token => p v -> p v
pPackImpl       =    pPacked pOIMPL pCIMPL

{-# LINE 313 "src/ehc/EH/Parser.chs" #-}
pExprBase       =    mkEH Expr_IConst     <$>  pInt
                <|>  mkEH Expr_CConst     <$>  pChr
                <|>  mkEH Expr_Var        <$>  pVar
                <|>  mkEH Expr_Con        <$>  pCon
{-# LINE 322 "src/ehc/EH/Parser.chs" #-}
                <|>  (\e a -> mkEH Expr_Case e a Nothing Set.empty False)
                     <$   pKey "case" <*> pExpr <* pKey "of" <*> pCaseAlts
{-# LINE 330 "src/ehc/EH/Parser.chs" #-}
                <|>  pParenRow True (show hsnORec) (show hsnCRec) "=" (Just (":=",mkEH RecExpr_Upd))
                        (mkEH RecExpr_Empty,mkEH RecExpr_Expr . mkEH Expr_Var,mkEH RecExpr_Ext,mkEH Expr_Rec,appPar)
                        pVar pExpr
{-# LINE 335 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH Expr_Undefined  <$   pKey "..."
{-# LINE 338 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH Expr_DynVar     <$>  pDynVar

{-# LINE 343 "src/ehc/EH/Parser.chs" #-}
pExpr           =    pE <??> (mkEH Expr_TypeAs False <$ pKey "::" <*> pTyExpr)
                where pE  =    pExprPrefix <*> pE
                          <|>  pExprApp

{-# LINE 352 "src/ehc/EH/Parser.chs" #-}
pExprApp        =    pE <??> ((\l e -> appTop (foldl (flip ($)) e l)) <$> pList1 pA)
{-# LINE 358 "src/ehc/EH/Parser.chs" #-}
                where  pA = flip app1App <$> pE <|> pImpred <|> pImpl
{-# LINE 364 "src/ehc/EH/Parser.chs" #-}
                       pImpred = (flip (mkEH Expr_AppImpred)) <$ pKey "~" <*> pE
{-# LINE 367 "src/ehc/EH/Parser.chs" #-}
                       pE = pExprBase <**> pExprSelSuffix
{-# LINE 370 "src/ehc/EH/Parser.chs" #-}
                       pImpl = pPackImpl ((\a p e -> mkEH Expr_AppImpl e p a) <$> pExpr <* pKey "<:" <*> pPrExpr)

{-# LINE 374 "src/ehc/EH/Parser.chs" #-}
pExprPrefix     =    mkEH Expr_Let <$ pLET
                     <*> pMaybe False (const True) pBANG
                     <*> pDecls    <* pIN
{-# LINE 381 "src/ehc/EH/Parser.chs" #-}
                <|>  (\c t e ->  mkEH Expr_Case c
                                   [ mkEH CaseAlt_Pat (mkEH PatExpr_Con hsnTrue) t
                                   , mkEH CaseAlt_Pat (mkEH PatExpr_Con hsnFalse) e
                                   ]
                                   Nothing Set.empty False
                     )
                     <$ pIF <*> pExpr <* pTHEN <*> pExpr <* pELSE
{-# LINE 400 "src/ehc/EH/Parser.chs" #-}
                <|>  (flip (foldr ($)))
                     <$   pKey "\\"
                     <*>  pList1  (    mkEH Expr_Lam <$> pPatExprBase
                                  <|>  pPackImpl (flip (mkEH Expr_LamImpl) <$> pPatExpr <* pKey "<:" <*> pPrExpr)
                                  )
                     <*   pKey "->"

{-# LINE 420 "src/ehc/EH/Parser.chs" #-}
pDataConstr     =    (\c -> mkEH DataConstr_Constr c Nothing)
                     <$> pCon <*> (pDataFields <|> pCurly pDataLabFields)
                     <*> pSucceed Nothing
{-# LINE 437 "src/ehc/EH/Parser.chs" #-}
pDataConstrs    =    pListSep (pKey "|") pDataConstr

{-# LINE 441 "src/ehc/EH/Parser.chs" #-}
pDataField      =    mkEH DataField_Field Nothing <$> pTyExprBase
pDataLabField   =    mkEH DataField_Field <$> (Just <$> pList1Sep pComma pVar) <* pKey "::" <*> pTyExpr
pDataFields     =    pList pDataField
pDataLabFields  =    pList1Sep pComma pDataLabField

{-# LINE 450 "src/ehc/EH/Parser.chs" #-}
pCaseAlts       =    foldr (:) []
                     <$> pBlock1 pOCurly pSemi pCCurly pCaseAlt
pCaseAlt        =    mkEH CaseAlt_Pat  <$>  pPatExpr <* pKey "->" <*> pExpr

pTyVars         =    pList pTyVar
pTyVar          =    mkEH TyVar_Var <$> pVar

{-# LINE 459 "src/ehc/EH/Parser.chs" #-}
pTyVars1        ::   EHCParser TyVars
pTyVars1        =    pList1 pTyVar

{-# LINE 468 "src/ehc/EH/Parser.chs" #-}
data RowFld a = FldSel HsName a | FldNoSel a | FldUpd HsName a

pParenRow       ::   Bool -> String -> String -> String -> Maybe (String,r -> HsName -> e -> r)
                     -> (r,HsName -> r,r -> Maybe HsName -> e -> r,r -> e,e -> e)
                     -> EHCParser HsName -> EHCParser e -> EHCParser e

pParenRow singleAsIs o c sep mbUpd (semEmpty,semVar,semExt,semRow,semParens) pSel pE
                =    pKey o *> pRowFlds <* pKey c
                where  pFld          =    ((pSel <**> pSep) <|> pSucceed FldNoSel) <*> pE
                       pFlds         =    pListSep pComma pFld
                       pExtFlds      =    mkE <$> (pRowNested <|> semVar <$> pVar) <* pKey "|" <*> pFlds
                       pFldsOrExt    =    mkE semEmpty <$> pFlds <|> pExtFlds
                       pRowNested    =    pKey o *> pFldsOrExt <* pKey c
                       pRowFlds      =    if singleAsIs
                                          then       pFld <**>  (    (\fs f -> mkR (f:fs)) <$ pComma <*> pFlds
                                                                <|>  pSucceed (\le -> case le of {FldNoSel e -> semParens e; _ -> mkR [le]})
                                                                )
                                                <|>  semRow <$> pExtFlds
                                                <|>  pSucceed (mkR [])
                                          else  semRow <$> pFldsOrExt
                       mkR fs        =    semRow (mkE semEmpty fs )
                       mkE ext fs    =    foldl (\r f -> case f of
                                                            FldSel l e -> semExt r (Just l) e
                                                            FldNoSel e -> semExt r Nothing e
                                                            FldUpd l e -> semUpd r l e
                                                ) ext fs
                       (pSep,semUpd) =    case mbUpd of
                                            Just (sepUpd,sem) -> (FldSel <$ pKey sep <|> FldUpd <$ pKey sepUpd,sem)
                                            Nothing           -> (FldSel <$ pKey sep,\r _ _ -> r)

{-# LINE 500 "src/ehc/EH/Parser.chs" #-}
pExprSelSuffix  ::   EHCParser (Expr -> Expr)
pExprSelSuffix  =    (\lbls e -> foldl (mkEH Expr_Sel) e lbls)
                     <$> pList (pHASH *> pSel)

pSel            ::   EHCParser HsName
pSel            =    pVar <|> pCon <|> mkHNmPos <$> pInt

{-# LINE 513 "src/ehc/EH/Parser.chs" #-}
pPrExprClass    ::   EHCParser PrExpr
pPrExprClass    =    mkEH PrExpr_Class  <$> pCon <*> pTyExprs

{-# LINE 518 "src/ehc/EH/Parser.chs" #-}
pPrExprPrefix   ::   EHCParser (PrExpr -> PrExpr)
pPrExprPrefix   =    mkEH PrExpr_Arrow  <$> pPrExprBase <* pKeyw hsnPrArrow
                <|>  mkEH PrExpr_Forall <$  pKey "forall" <*> pVar <* pKey "."

{-# LINE 524 "src/ehc/EH/Parser.chs" #-}
pPrExpr         ::   EHCParser PrExpr
pPrExpr         =    pPrExprPrefix <*> pPrExpr
                <|>  pPrExprBase

{-# LINE 530 "src/ehc/EH/Parser.chs" #-}
pTyPrExpr       ::   EHCParser TyExpr
pTyPrExpr       =    pTyPrExprPrefix <*> pTyPrExpr
                <|>  mkEH TyExpr_Pred <$> pPrExprBase

{-# LINE 536 "src/ehc/EH/Parser.chs" #-}
pPrExprBase     ::   EHCParser PrExpr
pPrExprBase     =    pPrExprClass
                <|>  pParens pPrExpr
{-# LINE 541 "src/ehc/EH/Parser.chs" #-}
                <|>  mkEH PrExpr_DynVar <$> pDynVar <* pKey "::" <*> pTyExpr
                <|>  pVar <**>  (    (\s v -> mkEH PrExpr_Lacks (mkEH RowTyExpr_Var v) s)
                                     <$ pKey "\\" <*> pSel
{-# LINE 550 "src/ehc/EH/Parser.chs" #-}
                                )

{-# LINE 558 "src/ehc/EH/Parser.chs" #-}
pClassHead      ::   EHCParser TyExpr
pClassHead      =    pTyPrExprPrefix <*> pHd <|> pHd
                where pHd = mkEH TyExpr_Pred <$> pPrExprClass

pDeclClass      ::   EHCParser Decl
pDeclClass      =    (\h deps d -> mkEH Decl_Class h deps Nothing d [])
                     <$   pKey "class"
                     <*>  pClassHead
                     <*>  (pKey "|" *> pListSep pComma (mkEH FuncDep_Dep <$> pTyVars1 <* pKey "->" <*> pTyVars1)
                          `opt` []
                          )
                     <*   pKey "where" <*> pDecls

pDeclInstance   ::   EHCParser Decl
pDeclInstance   =    pKey "instance"
                     *>   (    (\n h d -> mkEH Decl_Instance n InstNormal h d)
                               <$>  ((\n e -> Just (n,e)) <$> pVar <*> (True <$ pKey "<:" <|> False <$ pKey "::") `opt` Nothing)
                               <*>  pClassHead
                               <*   pKey "where" <*> pDecls
                          <|>  mkEH Decl_InstanceIntro Nothing <$> pExpr <* pKey "<:" <*> pPrExprClass
                          )

{-# LINE 594 "src/ehc/EH/Parser.chs" #-}
pDynVar         ::   EHCParser HsName
pDynVar         =    pKeyw hsnDynVar *> pVar

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EH.Parser
( pAGItf )
where
import System.IO
import UU.Parsing
import UU.Parsing.Offside
import UHC.Util.ParseUtils
import UU.Scanner.GenToken
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.EH
import UHC.Light.Compiler.Ty
import qualified Data.Set as Set
import UHC.Light.Compiler.Foreign.Parser
import UHC.Light.Compiler.Foreign












type EHCParser        ep    =    LayoutParser Token ep

pAGItf                      ::   EHCParser AGItf

pExpr, pExprApp, pExprBase  ::   EHCParser Expr
pExprPrefix                 ::   EHCParser (Expr -> Expr)

pDecls                      ::   EHCParser Decls
pDecl                       ::   EHCParser Decl

pPatExpr, pPatExprBase      ::   EHCParser PatExpr

pTyExpr, pTyExprBase        ::   EHCParser TyExpr

pInt                        ::   EHCParser Int
pChr                        ::   EHCParser Char

pCon                        ::   EHCParser HsName
pVar                        ::   EHCParser HsName



pTyExprPrefix               ::   EHCParser (TyExpr -> TyExpr)



pTyExprApp                  ::   EHCParser TyExpr



pCaseAlts                   ::   EHCParser CaseAlts
pCaseAlt                    ::   EHCParser CaseAlt

pDataConstr                 ::   EHCParser DataConstr
pDataConstrs                ::   EHCParser DataConstrs

pTyVars                     ::   EHCParser TyVars
pTyVar                      ::   EHCParser TyVar



pDataLabFields              ::   EHCParser DataFields
pDataFields                 ::   EHCParser DataFields
pDataLabField               ::   EHCParser DataField
pDataField                  ::   EHCParser DataField







pApp            ::   AppLike a boundmeta => EHCParser a -> EHCParser a
pApp p          =    appTopApp <$> pList1 p















pChr            =    head <$> pChar
pInt            =    read <$> pInteger
pCon            =    hsnFromString <$> pConid
pVar            =    hsnFromString <$> pVarid







pAGItf          =    AGItf_AGItf <$> pExpr







pDecls          =    foldr (:) []         <$>  pBlock pOCurly pSemi pCCurly pDecl
pDecl           =    mkEH Decl_Val        <$>  pPatExprBase  <*   pEQUAL   <*> pExpr
                <|>  mkEH Decl_TySig      <$>  pVar          <*   pDCOLON  <*> pTyExpr


                <|>  (\c tvs cons -> mkEH Decl_Data False c tvs cons Nothing)
                                          <$   pDATA         <*>  pCon       <*> pTyVars
                                                             <*   pEQUAL     <*> pDataConstrs






                <|>  mkEH Decl_KiSig      <$>  pCon          <*   pDCOLON    <*> pKiExpr


                <|>  (\(conv,_) saf imp nm sig
                        -> mkEH Decl_FFI conv saf
                             (
                               (\i -> fst $ parseForeignEnt ForeignDirection_Import conv Nothing i)
                               (if null imp then show nm else imp))
                             nm sig
                     )
                     <$   pFOREIGN <* pIMPORT <*> pFFIWay
                     <*>  (pV (   pSAFE
                              <|> pUNSAFE
                              ) `opt` "safe")
                     <*>  (pString `opt` "")
                     <*>  pVar
                     <*   pDCOLON <*> pTyExpr






                <|>  pDeclClass
                <|>  pDeclInstance


                <|>  mkEH Decl_Type       <$   pTYPE         <*>  pCon
                                                             <*   pEQUAL     <*> pTyExpr











pPatExprBase    =    pVar <**>  (    flip (mkEH PatExpr_VarAs) <$ pAT <*> pPatExprBase
                                <|>  pSucceed (mkEH PatExpr_Var)
                                )
                <|>  mkEH PatExpr_Con     <$>  pCon
                <|>  mkEH PatExpr_IConst  <$>  pInt
                <|>  mkEH PatExpr_CConst  <$>  pChr





                <|>  pParenRow True (show hsnORec) (show hsnCRec) "=" Nothing
                        (mkEH RecPatExpr_Empty,mkEH RecPatExpr_Expr . mkEH PatExpr_Var,mkEH RecPatExpr_Ext,mkEH PatExpr_Rec,mkEH PatExpr_Parens)
                        pSel pPatExpr



pPatExpr        =    pApp pPatExprBase


                     <??> (mkEH PatExpr_TypeAs <$ pDCOLON <*> pTyExpr)







pKiExpr, pKiExprBase        ::   EHCParser KiExpr

pKiExprBase     =    mkEH KiExpr_Con <$> (pCon <|> pHNm pSTAR)
                <|>  mkEH KiExpr_Var <$> pVar
                <|>  pParens pKiExpr
pKiExpr         =    pChainr (app1Arr <$ pKeyw hsnArrow) pKiExprBase







pTyExprBase     =    mkEH TyExpr_Con       <$>  pCon


                <|>  mkEH TyExpr_Wild      <$   pTDOT


                <|>  mkEH TyExpr_Var       <$>  pVar
                <|>  mkEH TyExpr_VarWild   <$   pPERCENT <*> pVar





                <|>  pParenRow False (show hsnORow) (show hsnCRow) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext,mkEH TyExpr_Row,id)
                        pVar pTyExpr
                <|>  pParenRow True (show hsnORec) (show hsnCRec) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext
                            ,\r -> appConApp hsnRec [mkEH TyExpr_Row r]
                            ,mkEH TyExpr_Parens)
                        pVar pTyExpr
                <|>  pParenRow False (show hsnOSum) (show hsnCSum) "::" Nothing
                        (mkEH RowTyExpr_Empty,semVar,mkEH RowTyExpr_Ext
                            ,\r -> appConApp hsnSum [mkEH TyExpr_Row r]
                            ,id)
                        pVar pTyExpr





                where  semVar = (mkEH RowTyExpr_Var)








pTyExpr         =    pTyExprPrefix <*> pTyExpr
                <|>  pTyExprApp <??> (flip app1Arr <$ pKeyw hsnArrow <*> pTyExpr)



pTyExprs        ::   EHCParser TyExprs
pTyExprs        =    pList pTyExprBase



pTyExprPrefix   =    mkEH TyExpr_Quant
                     <$>  (tyQu_Forall <$ pKey "forall" <|> tyQu_Exists <$ pKey "exists")
                     <*>  pVar <* pKey "."


                <|>  pTyPrExprPrefix


                <|>  mkEH TyExpr_Lam <$ pLAM <*> pVar <* pRARROW



pTyPrExprPrefix ::   EHCParser (TyExpr -> TyExpr)
pTyPrExprPrefix =    app1Arr
                     <$>  pPackImpl
                            (    pPr <|> pIm
                            <|>  pSucceed  (mkEH TyExpr_NoImpls)
                            )
                     <*   pKeyw hsnArrow
                <|>  (    app1Arr <$> (pPrB <|> pIm)
                     <|>  flip (foldr app1Arr)
                          <$> pParens ((:) <$> pPr <*> (pImO <|> (++) <$> pList1 (pComma *> pPr) <*> pImO))
                     )
                     <*   pKeyw hsnPrArrow
                where  pPrB  =   mkEH TyExpr_Pred   <$>  pPrExprBase
                       pPr   ::  EHCParser TyExpr
                       pPr   =   mkEH TyExpr_Pred   <$>  pPrExpr
                       pIm   ::  EHCParser TyExpr
                       pIm   =   mkEH TyExpr_Impls  <$   pKey "..."
                       pImO  =   (:[]) <$ pComma <*> pIm `opt` []






pTyExprApp      =    pApp pTyExprBase



pPackImpl       ::   IsParser p Token => p v -> p v
pPackImpl       =    pPacked pOIMPL pCIMPL








pExprBase       =    mkEH Expr_IConst     <$>  pInt
                <|>  mkEH Expr_CConst     <$>  pChr
                <|>  mkEH Expr_Var        <$>  pVar
                <|>  mkEH Expr_Con        <$>  pCon





                <|>  (\e a -> mkEH Expr_Case e a Nothing Set.empty False)
                     <$   pKey "case" <*> pExpr <* pKey "of" <*> pCaseAlts






                <|>  pParenRow True (show hsnORec) (show hsnCRec) "=" (Just (":=",mkEH RecExpr_Upd))
                        (mkEH RecExpr_Empty,mkEH RecExpr_Expr . mkEH Expr_Var,mkEH RecExpr_Ext,mkEH Expr_Rec,appPar)
                        pVar pExpr


                <|>  mkEH Expr_Undefined  <$   pKey "..."


                <|>  mkEH Expr_DynVar     <$>  pDynVar




pExpr           =    pE <??> (mkEH Expr_TypeAs False <$ pKey "::" <*> pTyExpr)
                where pE  =    pExprPrefix <*> pE
                          <|>  pExprApp






pExprApp        =    pE <??> ((\l e -> appTop (foldl (flip ($)) e l)) <$> pList1 pA)





                where  pA = flip app1App <$> pE <|> pImpred <|> pImpl





                       pImpred = (flip (mkEH Expr_AppImpred)) <$ pKey "~" <*> pE


                       pE = pExprBase <**> pExprSelSuffix


                       pImpl = pPackImpl ((\a p e -> mkEH Expr_AppImpl e p a) <$> pExpr <* pKey "<:" <*> pPrExpr)



pExprPrefix     =    mkEH Expr_Let <$ pLET
                     <*> pMaybe False (const True) pBANG
                     <*> pDecls    <* pIN




                <|>  (\c t e ->  mkEH Expr_Case c
                                   [ mkEH CaseAlt_Pat (mkEH PatExpr_Con hsnTrue) t
                                   , mkEH CaseAlt_Pat (mkEH PatExpr_Con hsnFalse) e
                                   ]
                                   Nothing Set.empty False
                     )
                     <$ pIF <*> pExpr <* pTHEN <*> pExpr <* pELSE












                <|>  (flip (foldr ($)))
                     <$   pKey "\\"
                     <*>  pList1  (    mkEH Expr_Lam <$> pPatExprBase
                                  <|>  pPackImpl (flip (mkEH Expr_LamImpl) <$> pPatExpr <* pKey "<:" <*> pPrExpr)
                                  )
                     <*   pKey "->"














pDataConstr     =    (\c -> mkEH DataConstr_Constr c Nothing)
                     <$> pCon <*> (pDataFields <|> pCurly pDataLabFields)
                     <*> pSucceed Nothing














pDataConstrs    =    pListSep (pKey "|") pDataConstr



pDataField      =    mkEH DataField_Field Nothing <$> pTyExprBase
pDataLabField   =    mkEH DataField_Field <$> (Just <$> pList1Sep pComma pVar) <* pKey "::" <*> pTyExpr
pDataFields     =    pList pDataField
pDataLabFields  =    pList1Sep pComma pDataLabField





pCaseAlts       =    foldr (:) []
                     <$> pBlock1 pOCurly pSemi pCCurly pCaseAlt
pCaseAlt        =    mkEH CaseAlt_Pat  <$>  pPatExpr <* pKey "->" <*> pExpr

pTyVars         =    pList pTyVar
pTyVar          =    mkEH TyVar_Var <$> pVar



pTyVars1        ::   EHCParser TyVars
pTyVars1        =    pList1 pTyVar







data RowFld a = FldSel HsName a | FldNoSel a | FldUpd HsName a

pParenRow       ::   Bool -> String -> String -> String -> Maybe (String,r -> HsName -> e -> r)
                     -> (r,HsName -> r,r -> Maybe HsName -> e -> r,r -> e,e -> e)
                     -> EHCParser HsName -> EHCParser e -> EHCParser e

pParenRow singleAsIs o c sep mbUpd (semEmpty,semVar,semExt,semRow,semParens) pSel pE
                =    pKey o *> pRowFlds <* pKey c
                where  pFld          =    ((pSel <**> pSep) <|> pSucceed FldNoSel) <*> pE
                       pFlds         =    pListSep pComma pFld
                       pExtFlds      =    mkE <$> (pRowNested <|> semVar <$> pVar) <* pKey "|" <*> pFlds
                       pFldsOrExt    =    mkE semEmpty <$> pFlds <|> pExtFlds
                       pRowNested    =    pKey o *> pFldsOrExt <* pKey c
                       pRowFlds      =    if singleAsIs
                                          then       pFld <**>  (    (\fs f -> mkR (f:fs)) <$ pComma <*> pFlds
                                                                <|>  pSucceed (\le -> case le of {FldNoSel e -> semParens e; _ -> mkR [le]})
                                                                )
                                                <|>  semRow <$> pExtFlds
                                                <|>  pSucceed (mkR [])
                                          else  semRow <$> pFldsOrExt
                       mkR fs        =    semRow (mkE semEmpty fs )
                       mkE ext fs    =    foldl (\r f -> case f of
                                                            FldSel l e -> semExt r (Just l) e
                                                            FldNoSel e -> semExt r Nothing e
                                                            FldUpd l e -> semUpd r l e
                                                ) ext fs
                       (pSep,semUpd) =    case mbUpd of
                                            Just (sepUpd,sem) -> (FldSel <$ pKey sep <|> FldUpd <$ pKey sepUpd,sem)
                                            Nothing           -> (FldSel <$ pKey sep,\r _ _ -> r)



pExprSelSuffix  ::   EHCParser (Expr -> Expr)
pExprSelSuffix  =    (\lbls e -> foldl (mkEH Expr_Sel) e lbls)
                     <$> pList (pHASH *> pSel)

pSel            ::   EHCParser HsName
pSel            =    pVar <|> pCon <|> mkHNmPos <$> pInt







pPrExprClass    ::   EHCParser PrExpr
pPrExprClass    =    mkEH PrExpr_Class  <$> pCon <*> pTyExprs



pPrExprPrefix   ::   EHCParser (PrExpr -> PrExpr)
pPrExprPrefix   =    mkEH PrExpr_Arrow  <$> pPrExprBase <* pKeyw hsnPrArrow
                <|>  mkEH PrExpr_Forall <$  pKey "forall" <*> pVar <* pKey "."



pPrExpr         ::   EHCParser PrExpr
pPrExpr         =    pPrExprPrefix <*> pPrExpr
                <|>  pPrExprBase



pTyPrExpr       ::   EHCParser TyExpr
pTyPrExpr       =    pTyPrExprPrefix <*> pTyPrExpr
                <|>  mkEH TyExpr_Pred <$> pPrExprBase



pPrExprBase     ::   EHCParser PrExpr
pPrExprBase     =    pPrExprClass
                <|>  pParens pPrExpr


                <|>  mkEH PrExpr_DynVar <$> pDynVar <* pKey "::" <*> pTyExpr
                <|>  pVar <**>  (    (\s v -> mkEH PrExpr_Lacks (mkEH RowTyExpr_Var v) s)
                                     <$ pKey "\\" <*> pSel






                                )







pClassHead      ::   EHCParser TyExpr
pClassHead      =    pTyPrExprPrefix <*> pHd <|> pHd
                where pHd = mkEH TyExpr_Pred <$> pPrExprClass

pDeclClass      ::   EHCParser Decl
pDeclClass      =    (\h deps d -> mkEH Decl_Class h deps Nothing d [])
                     <$   pKey "class"
                     <*>  pClassHead
                     <*>  (pKey "|" *> pListSep pComma (mkEH FuncDep_Dep <$> pTyVars1 <* pKey "->" <*> pTyVars1)
                          `opt` []
                          )
                     <*   pKey "where" <*> pDecls

pDeclInstance   ::   EHCParser Decl
pDeclInstance   =    pKey "instance"
                     *>   (    (\n h d -> mkEH Decl_Instance n InstNormal h d)
                               <$>  ((\n e -> Just (n,e)) <$> pVar <*> (True <$ pKey "<:" <|> False <$ pKey "::") `opt` Nothing)
                               <*>  pClassHead
                               <*   pKey "where" <*> pDecls
                          <|>  mkEH Decl_InstanceIntro Nothing <$> pExpr <* pKey "<:" <*> pPrExprClass
                          )















pDynVar         ::   EHCParser HsName
pDynVar         =    pKeyw hsnDynVar *> pVar


</pre>