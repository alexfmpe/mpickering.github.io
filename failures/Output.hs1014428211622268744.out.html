<a href="Out.hs178425210905333258.out.html">prev</a></br><a href="failures.html">home</a></br><a href="PackageDatabase.hs225419518464685718.out.html">next</a></br></br><pre>45c45
< {-# LINE 93 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
45a46
> 
45a47
> 
45a48
> 
45a49
> 
45a50
> 
45a51
> 
45a52
> 
45a53
> 
45a54
> 
45a55
> 
45a56
> 
45a57
> 
45a58
> 
45a59
> 
45a60
> 
45a61
> 
45a62
> 
45a63
> 
45a64
> 
45a65
> 
45a66
> 
45a67
> 
45a68
> 
45a69
> 
45a70
> 
45a71
> 
45a72
> 
45a73
> 
45a74
> 
45a75
> 
45a76
> 
45a77
> 
45a78
> 
45a79
> 
45a80
> 
45a81
> 
45a82
> 
45a83
> 
45a84
> 
45a85
> 
45a86
> 
45a87
> 
45a88
> 
45a89
> 
45a90
> 
45a91
> 
45a92
> 
67c114
< {-# LINE 152 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
67a115
> 
67a116
> 
67a117
> 
67a118
> 
67a119
> 
67a120
> 
67a121
> 
67a122
> 
67a123
> 
67a124
> 
67a125
> 
67a126
> 
67a127
> 
67a128
> 
67a129
> 
67a130
> 
67a131
> 
67a132
> 
67a133
> 
67a134
> 
67a135
> 
67a136
> 
67a137
> 
67a138
> 
67a139
> 
67a140
> 
67a141
> 
67a142
> 
67a143
> 
67a144
> 
67a145
> 
67a146
> 
67a147
> 
67a148
> 
67a149
> 
67a150
> 
67a151
> 
99c183
< {-# LINE 197 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
99a184
> 
99a185
> 
99a186
> 
99a187
> 
99a188
> 
99a189
> 
99a190
> 
99a191
> 
99a192
> 
99a193
> 
99a194
> 
99a195
> 
99a196
> 
110c207
< {-# LINE 209 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
110a208
> 
134c232
< {-# LINE 238 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
134a233
> 
134a234
> 
134a235
> 
134a236
> 
134a237
> 
145c248
< {-# LINE 381 "src/ehc/EHC/CompilePhase/Output.chs" #-}
---
> 
145a249
> 
145a250
> 
145a251
> 
145a252
> 
145a253
> 
145a254
> 
145a255
> 
145a256
> 
145a257
> 
145a258
> 
145a259
> 
145a260
> 
145a261
> 
145a262
> 
145a263
> 
145a264
> 
145a265
> 
145a266
> 
145a267
> 
145a268
> 
145a269
> 
145a270
> 
145a271
> 
145a272
> 
145a273
> 
145a274
> 
145a275
> 
145a276
> 
145a277
> 
145a278
> 
145a279
> 
145a280
> 
145a281
> 
145a282
> 
145a283
> 
145a284
> 
145a285
> 
145a286
> 
145a287
> 
145a288
> 
145a289
> 
145a290
> 
145a291
> 
145a292
> 
145a293
> 
145a294
> 
145a295
> 
145a296
> 
145a297
> 
145a298
> 
145a299
> 
145a300
> 
145a301
> 
145a302
> 
145a303
> 
145a304
> 
145a305
> 
145a306
> 
145a307
> 
145a308
> 
145a309
> 
145a310
> 
145a311
> 
145a312
> 
145a313
> 
145a314
> 
145a315
> 
145a316
> 
145a317
> 
145a318
> 
145a319
> 
145a320
> 
145a321
> 
145a322
> 
145a323
> 
145a324
> 
145a325
> 
145a326
> 
145a327
> 
145a328
> 
145a329
> 
145a330
> 
145a331
> 
145a332
> 
145a333
> 
145a334
> 
145a335
> 
145a336
> 
145a337
> 
145a338
> 
145a339
> 
145a340
> 
145a341
> 
145a342
> 
145a343
> 
145a344
> 
145a345
> 
145a346
> 
145a347
> 
145a348
> 
145a349
> 
145a350
> 
145a351
> 
145a352
> 
145a353
> 
145a354
> 
145a355
> 
145a356
> 
145a357
> 
145a358
> 
145a359
> 
145a360
> 
145a361
> 
145a362
> 
145a363
> 
145a364
> 
145a365
> 
145a366
> 
145a367
> 
145a368
> 
145a369
> 
145a370
> 
145a371
> 
145a372
> 
145a373
> 
145a374
> 
145a375
> 
145a376
> 
145a377
> 
145a378
> 
145a379
> 
145a380
> 
197a433
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Output
( CPOutputCoreHow (..), cpOutputCoreModules
, cpOutputCore
, CPOutputCoreRunHow (..), cpOutputCoreRunModules
, cpOutputCoreRun
, cpOutputHI )
where
import qualified UHC.Util.FastSeq as Seq
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import qualified UHC.Light.Compiler.Config as Cfg
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.Core.Trf.EraseExtractTysigCore
import UHC.Light.Compiler.CoreRun as CoreRun
import UHC.Light.Compiler.Core.ToCoreRun
import UHC.Light.Compiler.CoreRun.Pretty
import UHC.Light.Compiler.Core as Core
import UHC.Light.Compiler.Core.Pretty
import UHC.Util.Time
import System.Directory
import qualified UHC.Light.Compiler.SourceCodeSig as Sig
import qualified UHC.Light.Compiler.HI as HI
import qualified UHC.Util.Binary as Bin
import UHC.Util.Serialize
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import UHC.Light.Compiler.Gam.Utils












{-# LINE 93 "src/ehc/EHC/CompilePhase/Output.chs" #-}
-- | Abstraction for writing a module to output with variation in suffices
cpOutputSomeModules
  ::    EHCCompileRunner m =>
        (EHCOpts -> EHCompileUnit -> FPath -> FilePath -> mod -> IO ())
     -> (EHCOpts -> HsName -> FPath -> String -> FPath)
     -> (Int -> String -> String)
     -> String
     -> HsName
     -> [(String,mod)]
     -> EHCompilePhaseT m [FPath]
cpOutputSomeModules write mkfp mknmsuff suff modNm mods = do
    cr <- get
    let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
    forM (zip [1..] mods) $ \(nr,(nmsuff,mod)) -> do
      let fpC     = mkfp opts modNm fp (suff ++ mknmsuff nr nmsuff) -- for now nmsuff after suff, but should be inside name
          fnC     = fpathToStr fpC
      liftIO $ unless (ecuSrcHasSuffix suff ecu) $ do
        fpathEnsureExists fpC
        write opts ecu fpC fnC mod
      return fpC

{-# LINE 152 "src/ehc/EHC/CompilePhase/Output.chs" #-}
data CPOutputCoreHow
  = CPOutputCoreHow_Text
  | CPOutputCoreHow_Binary
  | CPOutputCoreHow_CoreRun_Text
  | CPOutputCoreHow_CoreRun_Binary

cpOutputCoreModules
  :: EHCCompileRunner m =>
        CPOutputCoreHow -> [CoreOpt]
     -> (Int -> String -> String)
     -> String -> HsName
     -> [(String,CModule)]
     -> EHCompilePhaseT m [FPath]
cpOutputCoreModules how coreOpts mknmsuff suff modNm cMods
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; cpOutputSomeModules write mkOutputFPath mknmsuff suff modNm cMods
       }
  where write opts _ fpC fnC cMod = case how of
          CPOutputCoreHow_Text -> do
            let cMod' = cmodTrfEraseTyCore opts cMod
            putPPFPath fpC (ppCModule (opts {ehcOptCoreOpts = coreOpts ++ ehcOptCoreOpts opts}) cMod') 100
          CPOutputCoreHow_Binary ->
            putSerializeFile fnC cMod
          CPOutputCoreHow_CoreRun_Text -> do
            let cMod' = cmod2CoreRun cMod
            putPPFPath fpC (ppMod' opts cMod') 100
          CPOutputCoreHow_CoreRun_Binary -> do
            let cMod' = cmod2CoreRun cMod
            putSerializeFile fnC cMod'

{-# LINE 197 "src/ehc/EHC/CompilePhase/Output.chs" #-}
cpOutputCore :: EHCCompileRunner m => CPOutputCoreHow -> [CoreOpt] -> String -> String -> HsName -> EHCompilePhaseT m FPath
cpOutputCore how coreOpts nmsuff suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,_,_) = crBaseInfo modNm cr
                 mbCore = ecuMbCore ecu
                 cMod   = panicJust "cpOutputCore" mbCore
         ;  cpMsg modNm VerboseALot "Emit Core"
         ;  fmap head $ cpOutputCoreModules how coreOpts (\_ nm -> nm) suff modNm [(nmsuff,cMod)]
         }

{-# LINE 209 "src/ehc/EHC/CompilePhase/Output.chs" #-}
data CPOutputCoreRunHow
  = CPOutputCoreRunHow_Text
  | CPOutputCoreRunHow_Binary

cpOutputCoreRunModules
  :: EHCCompileRunner m =>
        CPOutputCoreRunHow
     -> (Int -> String -> String)
     -> String -> HsName
     -> [(String,CoreRun.Mod)]
     -> EHCompilePhaseT m [FPath]
cpOutputCoreRunModules how mknmsuff suff modNm crMods
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; cpOutputSomeModules write mkOutputFPath mknmsuff suff modNm crMods
       }
  where write opts _ fpC fnC crMod = case how of
          CPOutputCoreRunHow_Text ->
            putPPFPath fpC (ppMod' opts crMod) 100
          CPOutputCoreRunHow_Binary ->
            putSerializeFile fnC crMod


{-# LINE 238 "src/ehc/EHC/CompilePhase/Output.chs" #-}
cpOutputCoreRun :: EHCCompileRunner m => CPOutputCoreRunHow -> String -> String -> HsName -> EHCompilePhaseT m FPath
cpOutputCoreRun how nmsuff suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,_,_) = crBaseInfo modNm cr
                 mbCoreRun = ecuMbCoreRun ecu
                 cMod   = panicJust "cpOutputCoreRun" mbCoreRun
         ;  cpMsg modNm VerboseALot "Emit CoreRun"
         ;  fmap head $ cpOutputCoreRunModules how (\_ nm -> nm) suff modNm [(nmsuff,cMod)]
         }

{-# LINE 381 "src/ehc/EHC/CompilePhase/Output.chs" #-}
cpOutputHI :: EHCCompileRunner m => String -> HsName -> EHCompilePhaseT m ()
cpOutputHI suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mmi    = panicJust "cpOutputHI.crsiModMp" $ Map.lookup modNm $ crsiModMp crsi
                 hii1   = ecuHIInfo ecu
                 impNmS = ecuImpNmS ecu
                 hii2   = hii1 { HI.hiiValidity             = HI.HIValidity_Ok
                               , HI.hiiModuleNm             = modNm
                               , HI.hiiExps                 = mmiExps       mmi
                               , HI.hiiHiddenExps           = mmiHiddenExps mmi
                               , HI.hiiHasMain              = ecuHasMain ecu
                               , HI.hiiTarget               = ehcOptTarget opts
                               , HI.hiiTargetFlavor         = ehcOptTargetFlavor opts
                               , HI.hiiSrcTimeStamp         = Sig.timestamp
                               , HI.hiiSrcSig               = Sig.sig
                               , HI.hiiSrcVersionMajor      = Cfg.verMajor Cfg.version
                               , HI.hiiSrcVersionMinor      = Cfg.verMinor Cfg.version
                               , HI.hiiSrcVersionMinorMinor = Cfg.verMinorMinor Cfg.version
                               , HI.hiiSrcVersionSvn        = Cfg.verSvnRevision Cfg.version
                               , HI.hiiCompileFlags         = optsDiscrRecompileRepr opts
                               , HI.hiiCompiler             = Cfg.installVariant opts
                               , HI.hiiTransClosedUsedModMp = Map.unions $
                                                                Map.singleton modNm impNmS : [ ecuTransClosedUsedModMp $ crCU m cr | m <- Set.toList impNmS ]
                               , HI.hiiTransClosedOrphanModS= Set.unions $
                                                                [ Set.unions [if ecuIsOrphan me then Set.singleton m else Set.empty, ecuTransClosedOrphanModS me]
                                                                | m <- Set.toList impNmS
                                                                , let me = crCU m cr
                                                                ]
                               }
                 hii3   = hii2
                 fpH    = mkOutputFPath opts modNm fp suff
                 fnH    = fpathToStr fpH
         ;  cpMsg modNm VerboseALot "Emit HI"
         ;  hiExists <- liftIO $ doesFileExist fnH
         ;  when (hiExists)
                 (liftIO $ removeFile fnH)
         ;  when (ehcOptVerbosity opts > VerboseALot)
                 (do { liftIO $ putPPLn ("hii3: " >#< hii3)
                     ; liftIO $ putPPLn ("orph: " >#< vlist [ m >#< (fmap Set.toList $ HI.hiiMbOrphan $ ecuHIInfo me) | m <- Set.toList impNmS, let me = crCU m cr ])
                     ; liftIO $ putPPLn ("used nms: " >#< (pp $ show $ ecuUsedNames ecu))
                     })
         ;  liftIO $ do { fpathEnsureExists fpH
                      ; putSerializeFile fnH hii3
                      }
         ;  now <- liftIO $ getClockTime
         ;  cpUpdCU modNm ( ecuStoreHIInfoTime now
                          . ecuStoreHIInfo hii3
                          )
         }


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Output
( CPOutputCoreHow (..), cpOutputCoreModules
, cpOutputCore
, CPOutputCoreRunHow (..), cpOutputCoreRunModules
, cpOutputCoreRun
, cpOutputHI )
where
import qualified UHC.Util.FastSeq as Seq
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import qualified UHC.Light.Compiler.Config as Cfg
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.Core.Trf.EraseExtractTysigCore
import UHC.Light.Compiler.CoreRun as CoreRun
import UHC.Light.Compiler.Core.ToCoreRun
import UHC.Light.Compiler.CoreRun.Pretty
import UHC.Light.Compiler.Core as Core
import UHC.Light.Compiler.Core.Pretty
import UHC.Util.Time
import System.Directory
import qualified UHC.Light.Compiler.SourceCodeSig as Sig
import qualified UHC.Light.Compiler.HI as HI
import qualified UHC.Util.Binary as Bin
import UHC.Util.Serialize
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.EH.MainAG as EHSem
import UHC.Light.Compiler.Gam.Utils




























































-- | Abstraction for writing a module to output with variation in suffices
cpOutputSomeModules
  ::    EHCCompileRunner m =>
        (EHCOpts -> EHCompileUnit -> FPath -> FilePath -> mod -> IO ())
     -> (EHCOpts -> HsName -> FPath -> String -> FPath)
     -> (Int -> String -> String)
     -> String
     -> HsName
     -> [(String,mod)]
     -> EHCompilePhaseT m [FPath]
cpOutputSomeModules write mkfp mknmsuff suff modNm mods = do
    cr <- get
    let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
    forM (zip [1..] mods) $ \(nr,(nmsuff,mod)) -> do
      let fpC     = mkfp opts modNm fp (suff ++ mknmsuff nr nmsuff) -- for now nmsuff after suff, but should be inside name
          fnC     = fpathToStr fpC
      liftIO $ unless (ecuSrcHasSuffix suff ecu) $ do
        fpathEnsureExists fpC
        write opts ecu fpC fnC mod
      return fpC







































data CPOutputCoreHow
  = CPOutputCoreHow_Text
  | CPOutputCoreHow_Binary
  | CPOutputCoreHow_CoreRun_Text
  | CPOutputCoreHow_CoreRun_Binary

cpOutputCoreModules
  :: EHCCompileRunner m =>
        CPOutputCoreHow -> [CoreOpt]
     -> (Int -> String -> String)
     -> String -> HsName
     -> [(String,CModule)]
     -> EHCompilePhaseT m [FPath]
cpOutputCoreModules how coreOpts mknmsuff suff modNm cMods
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; cpOutputSomeModules write mkOutputFPath mknmsuff suff modNm cMods
       }
  where write opts _ fpC fnC cMod = case how of
          CPOutputCoreHow_Text -> do
            let cMod' = cmodTrfEraseTyCore opts cMod
            putPPFPath fpC (ppCModule (opts {ehcOptCoreOpts = coreOpts ++ ehcOptCoreOpts opts}) cMod') 100
          CPOutputCoreHow_Binary ->
            putSerializeFile fnC cMod
          CPOutputCoreHow_CoreRun_Text -> do
            let cMod' = cmod2CoreRun cMod
            putPPFPath fpC (ppMod' opts cMod') 100
          CPOutputCoreHow_CoreRun_Binary -> do
            let cMod' = cmod2CoreRun cMod
            putSerializeFile fnC cMod'















cpOutputCore :: EHCCompileRunner m => CPOutputCoreHow -> [CoreOpt] -> String -> String -> HsName -> EHCompilePhaseT m FPath
cpOutputCore how coreOpts nmsuff suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,_,_) = crBaseInfo modNm cr
                 mbCore = ecuMbCore ecu
                 cMod   = panicJust "cpOutputCore" mbCore
         ;  cpMsg modNm VerboseALot "Emit Core"
         ;  fmap head $ cpOutputCoreModules how coreOpts (\_ nm -> nm) suff modNm [(nmsuff,cMod)]
         }



data CPOutputCoreRunHow
  = CPOutputCoreRunHow_Text
  | CPOutputCoreRunHow_Binary

cpOutputCoreRunModules
  :: EHCCompileRunner m =>
        CPOutputCoreRunHow
     -> (Int -> String -> String)
     -> String -> HsName
     -> [(String,CoreRun.Mod)]
     -> EHCompilePhaseT m [FPath]
cpOutputCoreRunModules how mknmsuff suff modNm crMods
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr
       ; cpOutputSomeModules write mkOutputFPath mknmsuff suff modNm crMods
       }
  where write opts _ fpC fnC crMod = case how of
          CPOutputCoreRunHow_Text ->
            putPPFPath fpC (ppMod' opts crMod) 100
          CPOutputCoreRunHow_Binary ->
            putSerializeFile fnC crMod








cpOutputCoreRun :: EHCCompileRunner m => CPOutputCoreRunHow -> String -> String -> HsName -> EHCompilePhaseT m FPath
cpOutputCoreRun how nmsuff suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,_,_) = crBaseInfo modNm cr
                 mbCoreRun = ecuMbCoreRun ecu
                 cMod   = panicJust "cpOutputCoreRun" mbCoreRun
         ;  cpMsg modNm VerboseALot "Emit CoreRun"
         ;  fmap head $ cpOutputCoreRunModules how (\_ nm -> nm) suff modNm [(nmsuff,cMod)]
         }






































































































































cpOutputHI :: EHCCompileRunner m => String -> HsName -> EHCompilePhaseT m ()
cpOutputHI suff modNm
  =  do  {  cr <- get
         ;  let  (ecu,crsi,opts,fp) = crBaseInfo modNm cr
                 mmi    = panicJust "cpOutputHI.crsiModMp" $ Map.lookup modNm $ crsiModMp crsi
                 hii1   = ecuHIInfo ecu
                 impNmS = ecuImpNmS ecu
                 hii2   = hii1 { HI.hiiValidity             = HI.HIValidity_Ok
                               , HI.hiiModuleNm             = modNm
                               , HI.hiiExps                 = mmiExps       mmi
                               , HI.hiiHiddenExps           = mmiHiddenExps mmi
                               , HI.hiiHasMain              = ecuHasMain ecu
                               , HI.hiiTarget               = ehcOptTarget opts
                               , HI.hiiTargetFlavor         = ehcOptTargetFlavor opts
                               , HI.hiiSrcTimeStamp         = Sig.timestamp
                               , HI.hiiSrcSig               = Sig.sig
                               , HI.hiiSrcVersionMajor      = Cfg.verMajor Cfg.version
                               , HI.hiiSrcVersionMinor      = Cfg.verMinor Cfg.version
                               , HI.hiiSrcVersionMinorMinor = Cfg.verMinorMinor Cfg.version
                               , HI.hiiSrcVersionSvn        = Cfg.verSvnRevision Cfg.version
                               , HI.hiiCompileFlags         = optsDiscrRecompileRepr opts
                               , HI.hiiCompiler             = Cfg.installVariant opts
                               , HI.hiiTransClosedUsedModMp = Map.unions $
                                                                Map.singleton modNm impNmS : [ ecuTransClosedUsedModMp $ crCU m cr | m <- Set.toList impNmS ]
                               , HI.hiiTransClosedOrphanModS= Set.unions $
                                                                [ Set.unions [if ecuIsOrphan me then Set.singleton m else Set.empty, ecuTransClosedOrphanModS me]
                                                                | m <- Set.toList impNmS
                                                                , let me = crCU m cr
                                                                ]
                               }
                 hii3   = hii2
                 fpH    = mkOutputFPath opts modNm fp suff
                 fnH    = fpathToStr fpH
         ;  cpMsg modNm VerboseALot "Emit HI"
         ;  hiExists <- liftIO $ doesFileExist fnH
         ;  when (hiExists)
                 (liftIO $ removeFile fnH)
         ;  when (ehcOptVerbosity opts > VerboseALot)
                 (do { liftIO $ putPPLn ("hii3: " >#< hii3)
                     ; liftIO $ putPPLn ("orph: " >#< vlist [ m >#< (fmap Set.toList $ HI.hiiMbOrphan $ ecuHIInfo me) | m <- Set.toList impNmS, let me = crCU m cr ])
                     ; liftIO $ putPPLn ("used nms: " >#< (pp $ show $ ecuUsedNames ecu))
                     })
         ;  liftIO $ do { fpathEnsureExists fpH
                      ; putSerializeFile fnH hii3
                      }
         ;  now <- liftIO $ getClockTime
         ;  cpUpdCU modNm ( ecuStoreHIInfoTime now
                          . ecuStoreHIInfo hii3
                          )
         }



</pre>