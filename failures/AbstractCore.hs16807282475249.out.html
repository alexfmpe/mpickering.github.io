<a href="AbstractCore.hs1622650073984943658.out.html">prev</a></br><a href="failures.html">home</a></br><a href="AbstractSyntax.hs1010275441457850878.out.html">next</a></br></br><pre>52d51
< , cSubstAppSubst
53c52
< , CSubstitutable (..)
---
> , cSubstAppSubst------------------------- constructing: expr -------------------------
53a53
> , CSubstitutable-- | 1 arg application, together with meta info about the argument, packaged in the bind(..)
56d55
< , rcaTag
57c56
< , raltIsVar, raltIsConst
---
> , rcaTag-- | 1 arg application, together with meta info about the argument
57a57
> , raltIsVar-- acoreLam1Ty :: HsName -> ty -> expr -> expr, raltIsConst
59c59
< , raltIsIrrefutable
---
> , raltIsIrrefutable-- | 1 lam abstraction, together with meta info about, and type of the argument
62c62
< , ctagTrue, ctagFalse
---
> , ctagTrue-- | a tuple, with tag, and ty, ctagFalse
65c65
< , cafailHasId
---
> , cafailHasId-- | a value binding, for a name to value + type + metas + meta level
68c68
< , whatExprMbVar, whatExprMbApp, whatExprMbLam, whatExprMbLam', whatExprAppArity, whatExprMbBind
---
> , whatExprMbVar-- | a value binding aspect, for a name + value, optionally type + metas + meta level, whatExprMbApp, whatExprMbLam, whatExprMbLam', whatExprAppArity, whatExprMbBind
71c71
< , whatExprIsFFI
---
> , whatExprIsFFI-- | a type for value binding aspect, for a name + type, optionally meta level
74c74
< , acoreCoeLamLetTy, acoreCoeLamLet, acoreCoeLetRec
---
> , acoreCoeLamLetTy-- | meta for something bound; for a name, meta level and label, acoreCoeLamLet, acoreCoeLetRec
77c77
< , acoreCSubstFromUidImplsL, acoreCSubstFromUidBindLL
---
> , acoreCSubstFromUidImplsL-- | a expr binding aspect, for a name, meta level and label, acoreCSubstFromUidBindLL
80c80
< , acoreBuiltinInteger
---
> , acoreBuiltinInteger-- | a binding, for/from a single aspect (for now, later multiple)
83c83
< , acoreBuiltinListSingleton
---
> , acoreBuiltinListSingleton-- | basic let binding
86c86
< import UHC.Light.Compiler.Base.Common
---
> import-- | cast, defaults to noopUHC.Light.Compiler.Base.Common
90d89
< import UHC.Light.Compiler.Ty
91d89
< import UHC.Util.Pretty
92d89
< import UHC.Util.Utils
93c90
< import Data.List
---
> import-- | A Case expression, possibly with a default value.UHC.Light.Compiler.Ty
93a91
> import UHC.Util.Pretty      -- ^ The scrutinee. Required to be in WHNF.
93a92
> import UHC.Util.Utils       -- ^ The alternatives.
93a93
> import Data.List            -- ^ The default value. (TODO what is the behaviour if it is Nothing?)
96c96
< import qualified Data.Set as Set
---
> import-- | Creates a variable expression.qualified Data.Set as Set
99c99
< import UHC.Util.Binary
---
> import-- | stringUHC.Util.Binary
102d101
< import Data.Generics (Data)
103d101
< 
104d101
< 
105d101
< 
106d101
< 
107d101
< {-# LINE 38 "src/ehc/AbstractCore.chs" #-}
108c102
< class AbstractCore  expr metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
---
> import-- | charData.Generics (Data) AbstractCore  expr metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
122d115
<   ------------------------- constructing: expr -------------------------
123c116
<   -- | 1 arg application, together with meta info about the argument, packaged in the bind
---
> 
123a117
> 
126d119
<   -- | 1 arg application, together with meta info about the argument
127d119
<   -- acoreLam1Ty :: HsName -> ty -> expr -> expr
129c121
<   -- | 1 lam abstraction, together with meta info about, and type of the argument
---
> 
129a122
> 
129a123
> 
132c126
<   -- | a tuple, with tag, and ty
---
> 
135c129
<   -- | a value binding, for a name to value + type + metas + meta level
---
> 
138c132
<   -- | a value binding aspect, for a name + value, optionally type + metas + meta level
---
> 
141c135
<   -- | a type for value binding aspect, for a name + type, optionally meta level
---
> 
144c138
<   -- | meta for something bound; for a name, meta level and label
---
> 
147c141
<   -- | a expr binding aspect, for a name, meta level and label
---
> 
150c144
<   -- | a binding, for/from a single aspect (for now, later multiple)
---
> 
153c147
<   -- | basic let binding
---
> 
156c150
<   -- | cast, defaults to noop
---
> 
160d153
<   -- | A Case expression, possibly with a default value.
161d153
<   acoreCaseDflt  :: expr    -- ^ The scrutinee. Required to be in WHNF.
162d153
<         -> [alt]            -- ^ The alternatives.
163c154
<         -> Maybe expr       -- ^ The default value. (TODO what is the behaviour if it is Nothing?)
---
> 
163a155
>   acoreCaseDflt  :: expr
163a156
>         -> [alt]
163a157
>         -> Maybe expr
166c160
<   -- | Creates a variable expression.
---
> 
169c163
<   -- | string
---
> 
172c166
<   -- | char
---
> 
366c360
< {-# LINE 321 "src/ehc/AbstractCore.chs" #-}
---
> 
366a361
> 
366a362
> 
366a363
> 
366a364
> 
366a365
> 
366a366
> 
366a367
> 
366a368
> 
366a369
> 
366a370
> 
366a371
> 
366a372
> 
366a373
> 
366a374
> 
366a375
> 
366a376
> 
366a377
> 
366a378
> 
366a379
> 
366a380
> 
366a381
> 
366a382
> 
366a383
> 
366a384
> 
369c387
< {-# LINE 325 "src/ehc/AbstractCore.chs" #-}
---
> 
369a388
> 
386c405
< {-# LINE 356 "src/ehc/AbstractCore.chs" #-}
---
> 
386a406
> 
386a407
> 
386a408
> 
386a409
> 
386a410
> 
386a411
> 
386a412
> 
386a413
> 
386a414
> 
386a415
> 
386a416
> 
386a417
> 
386a418
> 
386a419
> 
393c426
< {-# LINE 368 "src/ehc/AbstractCore.chs" #-}
---
> 
393a427
> 
393a428
> 
393a429
> 
393a430
> 
393a431
> 
397c435
< {-# LINE 373 "src/ehc/AbstractCore.chs" #-}
---
> 
397a436
> 
401c440
< {-# LINE 383 "src/ehc/AbstractCore.chs" #-}
---
> 
401a441
> 
401a442
> 
401a443
> 
401a444
> 
401a445
> 
401a446
> 
431c476
< {-# LINE 424 "src/ehc/AbstractCore.chs" #-}
---
> 
431a477
> 
431a478
> 
431a479
> 
431a480
> 
431a481
> 
431a482
> 
431a483
> 
431a484
> 
431a485
> 
431a486
> 
431a487
> 
435c491
< {-# LINE 435 "src/ehc/AbstractCore.chs" #-}
---
> 
435a492
> 
435a493
> 
435a494
> 
435a495
> 
435a496
> 
435a497
> 
435a498
> 
476c539
< {-# LINE 494 "src/ehc/AbstractCore.chs" #-}
---
> 
476a540
> 
476a541
> 
476a542
> 
476a543
> 
476a544
> 
476a545
> 
476a546
> 
476a547
> 
476a548
> 
476a549
> 
476a550
> 
476a551
> 
476a552
> 
476a553
> 
476a554
> 
476a555
> 
476a556
> 
476a557
> 
482c563
< {-# LINE 501 "src/ehc/AbstractCore.chs" #-}
---
> 
482a564
> 
486c568
< {-# LINE 506 "src/ehc/AbstractCore.chs" #-}
---
> 
486a569
> 
494c577
< {-# LINE 515 "src/ehc/AbstractCore.chs" #-}
---
> 
494a578
> 
498c582
< {-# LINE 524 "src/ehc/AbstractCore.chs" #-}
---
> 
498a583
> 
498a584
> 
498a585
> 
498a586
> 
498a587
> 
519c608
< {-# LINE 546 "src/ehc/AbstractCore.chs" #-}
---
> 
519a609
> 
524c614
< {-# LINE 552 "src/ehc/AbstractCore.chs" #-}
---
> 
524a615
> 
529c620
< {-# LINE 558 "src/ehc/AbstractCore.chs" #-}
---
> 
529a621
> 
536c628
< {-# LINE 566 "src/ehc/AbstractCore.chs" #-}
---
> 
536a629
> 
540c633
< {-# LINE 575 "src/ehc/AbstractCore.chs" #-}
---
> 
540a634
> 
540a635
> 
540a636
> 
540a637
> 
540a638
> 
555c653
< {-# LINE 595 "src/ehc/AbstractCore.chs" #-}
---
> 
555a654
> 
555a655
> 
555a656
> 
555a657
> 
555a658
> 
576c679
< {-# LINE 617 "src/ehc/AbstractCore.chs" #-}
---
> 
576a680
> 
597c701
< {-# LINE 650 "src/ehc/AbstractCore.chs" #-}
---
> 
597a702
> 
597a703
> 
597a704
> 
597a705
> 
597a706
> 
597a707
> 
597a708
> 
597a709
> 
597a710
> 
597a711
> 
597a712
> 
597a713
> 
634c750
< {-# LINE 688 "src/ehc/AbstractCore.chs" #-}
---
> 
634a751
> 
660c777
< {-# LINE 715 "src/ehc/AbstractCore.chs" #-}
---
> 
660a778
> 
677c795
< {-# LINE 737 "src/ehc/AbstractCore.chs" #-}
---
> 
677a796
> 
677a797
> 
677a798
> 
677a799
> 
677a800
> 
698c821
< {-# LINE 759 "src/ehc/AbstractCore.chs" #-}
---
> 
698a822
> 
708c832
< {-# LINE 770 "src/ehc/AbstractCore.chs" #-}
---
> 
708a833
> 
717c842
< {-# LINE 790 "src/ehc/AbstractCore.chs" #-}
---
> 
717a843
> 
717a844
> 
717a845
> 
717a846
> 
717a847
> 
717a848
> 
717a849
> 
717a850
> 
717a851
> 
717a852
> 
717a853
> 
722c858
< {-# LINE 800 "src/ehc/AbstractCore.chs" #-}
---
> 
722a859
> 
722a860
> 
722a861
> 
722a862
> 
722a863
> 
754c895
< {-# LINE 833 "src/ehc/AbstractCore.chs" #-}
---
> 
754a896
> 
758c900
< {-# LINE 838 "src/ehc/AbstractCore.chs" #-}
---
> 
758a901
> 
773c916
< {-# LINE 854 "src/ehc/AbstractCore.chs" #-}
---
> 
773a917
> 
788c932
< {-# LINE 870 "src/ehc/AbstractCore.chs" #-}
---
> 
788a933
> 
815c960
< {-# LINE 902 "src/ehc/AbstractCore.chs" #-}
---
> 
815a961
> 
815a962
> 
815a963
> 
815a964
> 
815a965
> 
822c972
< {-# LINE 914 "src/ehc/AbstractCore.chs" #-}
---
> 
822a973
> 
822a974
> 
822a975
> 
822a976
> 
822a977
> 
828c983
< {-# LINE 925 "src/ehc/AbstractCore.chs" #-}
---
> 
828a984
> 
828a985
> 
828a986
> 
828a987
> 
828a988
> 
839c999
< {-# LINE 941 "src/ehc/AbstractCore.chs" #-}
---
> 
839a1000
> 
839a1001
> 
839a1002
> 
839a1003
> 
839a1004
> 
843c1008
< {-# LINE 946 "src/ehc/AbstractCore.chs" #-}
---
> 
843a1009
> 
852c1018
< {-# LINE 956 "src/ehc/AbstractCore.chs" #-}
---
> 
852a1019
> 
856c1023
< {-# LINE 961 "src/ehc/AbstractCore.chs" #-}
---
> 
856a1024
> 
860c1028
< {-# LINE 966 "src/ehc/AbstractCore.chs" #-}
---
> 
860a1029
> 
869c1038
< {-# LINE 976 "src/ehc/AbstractCore.chs" #-}
---
> 
869a1039
> 
881c1051
< {-# LINE 989 "src/ehc/AbstractCore.chs" #-}
---
> 
881a1052
> 
889c1060
< {-# LINE 998 "src/ehc/AbstractCore.chs" #-}
---
> 
889a1061
> 
895c1067
< {-# LINE 1009 "src/ehc/AbstractCore.chs" #-}
---
> 
895a1068
> 
895a1069
> 
895a1070
> 
895a1071
> 
895a1072
> 
907c1084
< {-# LINE 1026 "src/ehc/AbstractCore.chs" #-}
---
> 
907a1085
> 
907a1086
> 
907a1087
> 
907a1088
> 
907a1089
> 
913c1095
< {-# LINE 1037 "src/ehc/AbstractCore.chs" #-}
---
> 
913a1096
> 
913a1097
> 
913a1098
> 
913a1099
> 
913a1100
> 
919c1106
< {-# LINE 1048 "src/ehc/AbstractCore.chs" #-}
---
> 
919a1107
> 
919a1108
> 
919a1109
> 
919a1110
> 
919a1111
> 
925c1117
< {-# LINE 1059 "src/ehc/AbstractCore.chs" #-}
---
> 
925a1118
> 
925a1119
> 
925a1120
> 
925a1121
> 
925a1122
> 
937c1134
< {-# LINE 1072 "src/ehc/AbstractCore.chs" #-}
---
> 
937a1135
> 
942c1140
< {-# LINE 1102 "src/ehc/AbstractCore.chs" #-}
---
> 
942a1141
> 
942a1142
> 
942a1143
> 
942a1144
> 
942a1145
> 
942a1146
> 
942a1147
> 
942a1148
> 
942a1149
> 
942a1150
> 
942a1151
> 
942a1152
> 
942a1153
> 
942a1154
> 
942a1155
> 
942a1156
> 
942a1157
> 
942a1158
> 
942a1159
> 
942a1160
> 
942a1161
> 
942a1162
> 
942a1163
> 
942a1164
> 
942a1165
> 
961c1184
< {-# LINE 1139 "src/ehc/AbstractCore.chs" #-}
---
> 
961a1185
> 
961a1186
> 
961a1187
> 
961a1188
> 
961a1189
> 
961a1190
> 
961a1191
> 
961a1192
> 
961a1193
> 
961a1194
> 
961a1195
> 
961a1196
> 
961a1197
> 
961a1198
> 
961a1199
> 
961a1200
> 
961a1201
> 
961a1202
> 
974c1215
< {-# LINE 1157 "src/ehc/AbstractCore.chs" #-}
---
> 
974a1216
> 
974a1217
> 
974a1218
> 
974a1219
> 
974a1220
> 
985c1231
< {-# LINE 1169 "src/ehc/AbstractCore.chs" #-}
---
> 
985a1232
> 
999c1246
< {-# LINE 1184 "src/ehc/AbstractCore.chs" #-}
---
> 
999a1247
> 
1016c1264
< {-# LINE 1202 "src/ehc/AbstractCore.chs" #-}
---
> 
1016a1265
> 
1026c1275
< {-# LINE 1213 "src/ehc/AbstractCore.chs" #-}
---
> 
1026a1276
> 
1034c1284
< {-# LINE 1222 "src/ehc/AbstractCore.chs" #-}
---
> 
1034a1285
> 
1041c1292
< {-# LINE 1230 "src/ehc/AbstractCore.chs" #-}
---
> 
1041a1293
> 
1054c1306
< {-# LINE 1248 "src/ehc/AbstractCore.chs" #-}
---
> 
1054a1307
> 
1054a1308
> 
1054a1309
> 
1054a1310
> 
1054a1311
> 
1059c1316
< {-# LINE 1258 "src/ehc/AbstractCore.chs" #-}
---
> 
1059a1317
> 
1059a1318
> 
1059a1319
> 
1059a1320
> 
1059a1321
> 
1066c1328
< {-# LINE 1266 "src/ehc/AbstractCore.chs" #-}
---
> 
1066a1329
> 
1081c1344
< {-# LINE 1284 "src/ehc/AbstractCore.chs" #-}
---
> 
1081a1345
> 
1081a1346
> 
1081a1347
> 
1087c1353
< {-# LINE 1295 "src/ehc/AbstractCore.chs" #-}
---
> 
1087a1354
> 
1087a1355
> 
1087a1356
> 
1087a1357
> 
1087a1358
> 
1091c1362
< {-# LINE 1300 "src/ehc/AbstractCore.chs" #-}
---
> 
1091a1363
> 
1095c1367
< {-# LINE 1305 "src/ehc/AbstractCore.chs" #-}
---
> 
1095a1368
> 
1099c1372
< {-# LINE 1310 "src/ehc/AbstractCore.chs" #-}
---
> 
1099a1373
> 
1106c1380
< {-# LINE 1322 "src/ehc/AbstractCore.chs" #-}
---
> 
1106a1381
> 
1106a1382
> 
1106a1383
> 
1106a1384
> 
1106a1385
> 
1111c1390
< {-# LINE 1332 "src/ehc/AbstractCore.chs" #-}
---
> 
1111a1391
> 
1111a1392
> 
1111a1393
> 
1111a1394
> 
1111a1395
> 
1122c1406
< {-# LINE 1348 "src/ehc/AbstractCore.chs" #-}
---
> 
1122a1407
> 
1122a1408
> 
1122a1409
> 
1122a1410
> 
1122a1411
> 
1143c1432
< {-# LINE 1372 "src/ehc/AbstractCore.chs" #-}
---
> 
1143a1433
> 
1143a1434
> 
1143a1435
> 
1150c1442
< {-# LINE 1380 "src/ehc/AbstractCore.chs" #-}
---
> 
1150a1443
> 
1159c1452
< {-# LINE 1390 "src/ehc/AbstractCore.chs" #-}
---
> 
1159a1453
> 
1171c1465
< {-# LINE 1403 "src/ehc/AbstractCore.chs" #-}
---
> 
1171a1466
> 
1176c1471
< {-# LINE 1409 "src/ehc/AbstractCore.chs" #-}
---
> 
1176a1472
> 
1181c1477
< {-# LINE 1415 "src/ehc/AbstractCore.chs" #-}
---
> 
1181a1478
> 
1189c1486
< {-# LINE 1426 "src/ehc/AbstractCore.chs" #-}
---
> 
1189a1487
> 
1189a1488
> 
1189a1489
> 
1195c1495
< {-# LINE 1437 "src/ehc/AbstractCore.chs" #-}
---
> 
1195a1496
> 
1195a1497
> 
1195a1498
> 
1195a1499
> 
1195a1500
> 
1206c1511
< {-# LINE 1451 "src/ehc/AbstractCore.chs" #-}
---
> 
1206a1512
> 
1206a1513
> 
1206a1514
> 
1216c1524
< {-# LINE 1468 "src/ehc/AbstractCore.chs" #-}
---
> 
1216a1525
> 
1216a1526
> 
1216a1527
> 
1216a1528
> 
1216a1529
> 
1216a1530
> 
1216a1531
> 
1221c1536
< {-# LINE 1480 "src/ehc/AbstractCore.chs" #-}
---
> 
1221a1537
> 
1221a1538
> 
1221a1539
> 
1221a1540
> 
1221a1541
> 
1221a1542
> 
1221a1543
> 
1226c1548
< {-# LINE 1490 "src/ehc/AbstractCore.chs" #-}
---
> 
1226a1549
> 
1226a1550
> 
1226a1551
> 
1226a1552
> 
1226a1553
> 
1239c1566
< {-# LINE 1504 "src/ehc/AbstractCore.chs" #-}
---
> 
1239a1567
> 
1244c1572
< {-# LINE 1510 "src/ehc/AbstractCore.chs" #-}
---
> 
1244a1573
> 
1248c1577
< {-# LINE 1519 "src/ehc/AbstractCore.chs" #-}
---
> 
1248a1578
> 
1248a1579
> 
1248a1580
> 
1248a1581
> 
1248a1582
> 
1255d1588
< {-# LINE 1531 "src/ehc/AbstractCore.chs" #-}
1256a1590
> 
1256a1591
> 
1256a1592
> 
1256a1593
> 
1256a1594
> 
1256a1595
> 
1272c1611
< {-# LINE 1549 "src/ehc/AbstractCore.chs" #-}
---
> 
1272a1612
> 
1303c1643
< {-# LINE 1581 "src/ehc/AbstractCore.chs" #-}
---
> 
1303a1644
> 
1312c1653
< {-# LINE 1591 "src/ehc/AbstractCore.chs" #-}
---
> 
1312a1654
> 
1327c1669
< {-# LINE 1607 "src/ehc/AbstractCore.chs" #-}
---
> 
1327a1670
> 
1334c1677
< {-# LINE 1625 "src/ehc/AbstractCore.chs" #-}
---
> 
1334a1678
> 
1334a1679
> 
1334a1680
> 
1334a1681
> 
1334a1682
> 
1334a1683
> 
1334a1684
> 
1334a1685
> 
1334a1686
> 
1334a1687
> 
1334a1688
> 
1354c1708
< {-# LINE 1656 "src/ehc/AbstractCore.chs" #-}
---
> 
1354a1709
> 
1354a1710
> 
1354a1711
> 
1354a1712
> 
1354a1713
> 
1354a1714
> 
1354a1715
> 
1354a1716
> 
1354a1717
> 
1354a1718
> 
1354a1719
> 
1359c1724
< {-# LINE 1662 "src/ehc/AbstractCore.chs" #-}
---
> 
1359a1725
> 
1369c1735
< {-# LINE 1677 "src/ehc/AbstractCore.chs" #-}
---
> 
1369a1736
> 
1369a1737
> 
1369a1738
> 
1369a1739
> 
1369a1740
> 
1375c1746
< {-# LINE 1684 "src/ehc/AbstractCore.chs" #-}
---
> 
1375a1747
> 
1381a1754
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.AbstractCore
( AbstractCore (..)
, ACoreAppLikeMetaBound
, acoreMetaLift
, ACoreBindAspectKey (..), ACoreBindAspectKeyS, ACoreBindAspMp
, acbaspkeyMetaLev
, acbaspkeyDefaultTy, acbaspkeyTy, acbaspkeyDefaultCore, acbaspkeyNone, acbaspkeyDefault, acbaspkeyDefaultRelevTy, acbaspkeyStrict, acbaspkeyDebug
, ppACBaspKeyS
, hsnUniqifyACoreBindAspectKeyS
, ACoreBindRef (..), acoreMkRef, acoreMkAspRef
, acbrefAspAnd
, ppACoreBindRef
, acore1App, acoreApp, acoreAppBound
, acoreLamBind, acoreLam1Ty, acoreLam1, acoreLamTy, acoreLam
, acoreTagTupTy, acoreTagTup, acoreTupTy, acoreTup, acoreTag
, acoreBind1CatLevMetaTyWith, acoreBind1CatLevMetaTy, acoreBind1CatLevTy, acoreBind1CatMetaTy, acoreBind1CatTy, acoreBind1Cat, acoreBind1LevTy, acoreBind1Ty, acoreBind1
, acoreBind1MetasTy, acoreBind1CatMeta, acoreBind1MetaTy
, acoreBind1Asp1, acoreBind1NmLevTy1, acoreBind1Nm1
, acoreBoundVal1CatLevMetaTy, acoreBoundVal1CatLevTy, acoreBoundVal1CatMetaTy, acoreBoundVal1CatTy, acoreBoundVal1Cat
, acoreBoundVal1Metas, acoreBoundVal1Meta
, acoreBound1AspkeyVal, acoreBound1Val
, acoreTyErrLift
, acoreLetMerge, acoreLet, acoreLetRec
, acoreLetN
, acoreLet1PlainTy, acoreLet1Plain
, acoreLet1StrictTy, acoreLet1Strict
, acoreLet1StrictInMetaTyWith, acoreLet1StrictInMetaTy, acoreLet1StrictInMeta, acoreLet1StrictIn, acoreLet1StrictInTy
, acoreBindcategDflt
, acoreChar, acoreInt, acoreInt2
, acoreBuiltinApp
, acoreBuiltinAddInt
, acoreBuiltinGtInt
, acoreBuiltinString
, acoreBuiltinError, acoreBuiltinUndefined
, acorePatConMbTag, acoreAltMbTag
, acoreBindNm
, acorePatFldTy
, acoreUnBoundVal
, Coe' (..)
, CoeCtx (..)
, acoreCoeId, acoreCoeMap
, acoreCoeApp1, acoreCoeAppN, acoreCoeAppNbyName
, acoreCoeLam1Ty, acoreCoeLam1
, acoreCoeCompose
, acoreCoeIsId
, CSubstKey (..)
, CSubstInfo' (..)
, CSubst', emptyCSubst
, acoreCSubstFromNmTyL
, acoreCSubstFromRefExprL
, acoreCSubstFromUidExprL
, cSubstAppSubst
, CSubstitutable (..)
, RAlt' (..), RPat' (..), RPatConBind' (..), RPatFld' (..), RCEAltL'
, rcaPat, raltLPatNms
, rcaTag
, raltIsVar, raltIsConst
, raltIsConMany
, raltIsIrrefutable
, rpatConBindUnFlatten
, acoreRPat2Pat
, ctagTrue, ctagFalse
, ctagCons, ctagNil
, CaseAltFailReason (..)
, cafailHasId
, AppFunKind (..)
, WhatExpr (..)
, whatExprMbVar, whatExprMbApp, whatExprMbLam, whatExprMbLam', whatExprAppArity, whatExprMbBind
, whatExprIsWHNF
, whatExprIsLam, whatExprIsTup, whatExprIsBind
, whatExprIsFFI
, acoreMetaLiftDict
, acoreNmHolePred, acoreNmHole
, acoreCoeLamLetTy, acoreCoeLamLet, acoreCoeLetRec
, acoreCoePoiLApp, acoreCoeImplsApp
, acoreCoePoiLLamTy, acoreCoeImplsLam
, acoreCSubstFromUidImplsL, acoreCSubstFromUidBindLL
, acoreIf
, acbaspkeyFusionRole
, acoreBuiltinInteger
, raltMbBoolExpr, raltIsBoolExpr
, acoreBuiltinEqChar
, acoreBuiltinListSingleton
, acoreMatchChar )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Opts.Base
import UHC.Light.Compiler.Ty
import UHC.Util.Pretty
import UHC.Util.Utils
import Data.List
import Data.Maybe
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Applicative ((<|>),(<$>))
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize
import Data.Typeable (Typeable)
import Data.Generics (Data)




{-# LINE 38 "src/ehc/AbstractCore.chs" #-}
class AbstractCore  expr metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
    | expr       ->      metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
    , metaval    -> expr
    , bind       -> expr
    , bound      -> expr
    , boundmeta  -> expr
    , bindcateg  -> expr
    , metabind   -> expr
    , ty         -> expr
    , pat        -> expr
    , patrest    -> expr
    , patfld     -> expr
    , alt        -> expr
  where
  ------------------------- constructing: expr -------------------------
  -- | 1 arg application, together with meta info about the argument, packaged in the bind
  acoreLam1Bind :: bind -> expr -> expr

  -- | 1 arg application, together with meta info about the argument
  -- acoreLam1Ty :: HsName -> ty -> expr -> expr

  -- | 1 lam abstraction, together with meta info about, and type of the argument
  acore1AppBound :: expr -> bound -> expr

  -- | a tuple, with tag, and ty
  acoreTagTyTupBound :: CTag -> ty -> [bound] -> expr

  -- | a value binding, for a name to value + type + metas + meta level
  acoreBind1CatLevMetasTy :: bindcateg -> HsName -> MetaLev -> (metabind,metaval) -> ty -> expr -> bind

  -- | a value binding aspect, for a name + value, optionally type + metas + meta level
  acoreBoundVal1CatLevMetasTy :: bindcateg -> HsName -> MetaLev -> (metabind,metaval) -> ty -> expr -> bound

  -- | a type for value binding aspect, for a name + type, optionally meta level
  acoreBoundValTy1CatLev :: bindcateg -> HsName -> MetaLev -> ty -> bound

  -- | meta for something bound; for a name, meta level and label
  acoreBoundmeta :: ACoreBindAspectKeyS -> MetaLev -> CLbl -> boundmeta

  -- | a expr binding aspect, for a name, meta level and label
  acoreBound1MetaVal :: boundmeta -> expr -> bound

  -- | a binding, for/from a single aspect (for now, later multiple)
  acoreBind1Asp :: HsName -> [bound] -> bind

  -- | basic let binding
  acoreLetBase :: bindcateg -> [bind] -> expr -> expr

  -- | cast, defaults to noop
  acoreCast :: ty -> expr -> expr
  acoreCast _ e = e

  -- | A Case expression, possibly with a default value.
  acoreCaseDflt  :: expr    -- ^ The scrutinee. Required to be in WHNF.
        -> [alt]            -- ^ The alternatives.
        -> Maybe expr       -- ^ The default value. (TODO what is the behaviour if it is Nothing?)
        -> expr

  -- | Creates a variable expression.
  acoreVar  :: HsName -> expr

  -- | string
  acoreStringTy  :: ty -> String -> expr

  -- | char
  acoreCharTy  :: ty -> Char -> expr

  -- | int as Int
  acoreIntTy  :: ty -> Int -> expr

  -- | int as Integer
  acoreIntTy2 :: ty -> Integer -> expr

  -- | hole: placeholder for CSubst to fill in
  acoreUidHole :: UID -> expr

  -- | hole: let with hole for bindings to be filled in later by means of a CSubst
  acoreHoleLet :: UID -> expr -> expr

  -- | a default, fallback
  -- acoreDflt :: expr

  -- | get error/default expr
  acoreExprErr :: String -> expr
  acoreExprErr s = panic $ "AbstractCore.acoreExprErr: " ++ s


  ------------------------- constructing: ty constants -------------------------
  -- Int
  -- acoreTyInt2 :: ty

  -- Bool
  acoreTyBool :: EHCOpts -> ty

  ------------------------- constructing: pat -------------------------
  -- | pat var, with type
  acorePatVarTy :: HsName -> ty -> pat

  -- | Matches the case scrutinee with the given constructor tag.
  acorePatCon :: CTag   -- ^ The constructor to match.
    -> patrest          -- ^ ???
    -> [patfld]         -- ^ ???
    -> pat

  -- | pat int
  acorePatIntTy :: ty -> Int -> pat

  -- | pat Integer
  acorePatIntTy2 :: ty -> Integer -> pat

  -- | pat char
  acorePatCharTy :: ty -> Char -> pat

  -- | pat boolean guard
  acorePatBoolExpr :: expr -> pat
  ------------------------- constructing: pat field -------------------------
  -- | TODO ??? pat field
  acorePatFldBind :: (HsName,expr)  -- ^ lbl, offset ???
    -> bind     -- ^ ??
    -> patfld
  -- acorePatFldTy :: ty -> (HsName,expr) -> HsName -> patfld

  ------------------------- constructing: patrest -------------------------
  -- | patrest, empty TODO what does it mean?
  acorePatRestEmpty :: patrest

  -- | patrest, var
  acorePatRestVar :: HsName -> patrest

  ------------------------- constructing: alt -------------------------
  -- | Creates an alternative of a case statement.
  acoreAlt :: pat   -- ^ The pattern with which to match the case scrutinee.
        -> expr     -- ^ The value of this alternative.
        -> alt

  ------------------------- constructing: top level -------------------------
  -- | Wraps main expr into a form which can be directly run by evaluating
  acoreRunMain :: expr     -- ^ main
        -> expr
  acoreRunMain e = acore1App e (acoreTup [])

  ------------------------- type related -------------------------
  -- | construct ty from Ty, usable in Core context
  acoreTy2ty :: EHCOpts -> Ty -> ty

  ------------------------- defaults -------------------------
  -- | get default for metaval
  acoreMetavalDflt :: metaval

  -- | get default for metaval, for dicts
  acoreMetavalDfltDict :: metaval

  -- | get default for metabind
  acoreMetabindDflt :: metabind

  -- | get default for metabind
  acoreDfltBoundmeta :: boundmeta
  acoreDfltBoundmeta = panic "AbstractCore.acoreDfltBoundmeta not implemented"

  -- | get error/default ty, type indexed by ty
  acoreTyErr :: String -> ty
  acoreTyErr s = panic $ "AbstractCore.acoreTyErr: " ++ s

  -- | get the ty representing the absent type, no type info
  acoreTyNone :: ty

  -- | get char ty
  acoreTyChar :: EHCOpts -> ty

  -- | get int ty
  acoreTyInt :: EHCOpts -> ty

  -- | get String ty
  acoreTyString :: EHCOpts -> ty

  ------------------------- bindcateg values -------------------------
  -- | get recursive bindcateg
  acoreBindcategRec :: bindcateg

  -- | get strict bindcateg
  acoreBindcategStrict :: bindcateg

  -- | get plain bindcateg
  acoreBindcategPlain :: bindcateg

  ------------------------- inspecting/deconstructing -------------------------
  -- | is expr an application?
  acoreExprMbApp :: expr -> Maybe (expr,bound)


  -- | is expr a lambda?
  acoreExprMbLam :: expr -> Maybe (bind,expr)

  -- | is expr a let?
  acoreExprMbLet :: expr -> Maybe (bindcateg,[bind],expr)

  -- | is expr a var?
  acoreExprMbVar :: expr -> Maybe HsName

  -- | is expr a int?
  acoreExprMbInt :: expr -> Maybe (ty,Integer)

  -- | is bindcateg recursive?
  acoreBindcategMbRec :: bindcateg -> Maybe bindcateg

  -- | is bindcateg strict?
  acoreBindcategMbStrict :: bindcateg -> Maybe bindcateg

  -- | is pat a con?
  acorePatMbCon :: pat -> Maybe(CTag,patrest,[patfld])

  -- | is pat a int?
  acorePatMbInt :: pat -> Maybe(ty,Integer)

  -- | is pat a char?
  acorePatMbChar :: pat -> Maybe(ty,Char)

  -- | 'un' alt
  acoreUnAlt :: alt -> (pat,expr)

  -- | 'un' patfld
  acoreUnPatFld :: patfld -> ((HsName,expr),bind)

  -- | 'un' patfld
  -- acoreUnPatFld :: patfld -> (ty,(HsName,expr),HsName)

  -- | 'un' bind
  acoreUnBind :: bind -> (HsName,[bound])

  -- | is bound a expr?
  acoreBoundMbVal :: bound -> Maybe (boundmeta,expr)

  ------------------------- transforming -------------------------
  -- | thunk expr, i.e. turn into delayed computation
  acoreExprThunk :: expr -> expr
  acoreExprThunk = id

  -- | thunk ty, i.e. ty of 'acoreExprThunk'-ed expr
  acoreTyThunk :: ty -> ty
  acoreTyThunk = id

  -- | unthunk expr, i.e. force computation of delayed computation
  acoreExprUnThunk :: expr -> expr
  acoreExprUnThunk = id

  -- | unthunk ty, i.e. ty of 'acoreExprUnThunk'-ed expr
  acoreTyUnThunk :: ty -> ty
  acoreTyUnThunk = id

  ------------------------- coercion related: construction -------------------------
  -- | coercion arg placeholder
  acoreCoeArg :: expr

  ------------------------- coercion related: inspecting/deconstructing -------------------------
  -- | coercion arg placeholder
  acoreExprIsCoeArg :: expr -> Bool


{-# LINE 321 "src/ehc/AbstractCore.chs" #-}
type ACoreAppLikeMetaBound = (ACoreBindAspectKeyS,MetaLev,CLbl)

{-# LINE 325 "src/ehc/AbstractCore.chs" #-}
instance AbstractCore e m b bound boundmeta bcat mbind t p pr pf a => AppLike e boundmeta {- () () -} where
  app1App       = acore1App
  appTop        = id
  appCon        = acoreVar . mkHNm
  appPar        = id
  appVar        = acoreVar . mkHNm

  -- appDflt       =
  appDfltBoundmeta x = acoreDfltBoundmeta
  appDbg        = acoreExprErr

  appMbCon      = acoreExprMbVar
  appMbApp1 e   = do (f,b) <- acoreExprMbApp e
                     (_,a) <- acoreBoundMbVal b
                     return (f,a)

{-# LINE 356 "src/ehc/AbstractCore.chs" #-}
instance AbstractCore e m b bound boundmeta bcat mbind t p pr pf a => RecLike e boundmeta {- () () -} where
  recRow _ fs   = acoreTagTyTupBound CTagRec (acoreTyErr "AbstractCore.RecLike.recRow") [ acoreBound1MetaVal (acoreBoundmeta acbaspkeyDefault 0 (CLbl_Nm n)) e | (n,e) <- fs ]

  recMbRecRow  _= Nothing -- tyMbRecRowWithLkup (const Nothing)
  recUnRowExts e= (e,[])

{-# LINE 368 "src/ehc/AbstractCore.chs" #-}
acoreMetaLift :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => f x -> f (x,m)
acoreMetaLift = fmap2Tuple acoreMetavalDflt

{-# LINE 373 "src/ehc/AbstractCore.chs" #-}
acoreMetaLiftDict :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => f x -> f (x,m)
acoreMetaLiftDict = fmap2Tuple acoreMetavalDfltDict

{-# LINE 383 "src/ehc/AbstractCore.chs" #-}
-- | A ACoreBindAspectKeyS formed out of multiple ACoreBindAspectKey identifies a particular binding aspect
data ACoreBindAspectKey
  = ACoreBindAspectKey_Default              -- identifies the default binding, if omitted in a reference this aspect is the one chosen.
  | ACoreBindAspectKey_Ty                   -- the normal ty
  | ACoreBindAspectKey_RelevTy              -- the relevance ty
  | ACoreBindAspectKey_Strict               -- the as strict as possible variant
  | ACoreBindAspectKey_Debug                -- internal debugging only
  | ACoreBindAspectKey_Core                 -- core
  | ACoreBindAspectKey_FusionRole           -- fusion role
  deriving (Eq,Ord)

instance Show ACoreBindAspectKey where
  show ACoreBindAspectKey_Default       = "dft"
  show ACoreBindAspectKey_Strict        = "str"
  show ACoreBindAspectKey_Ty            = "ty"
  show ACoreBindAspectKey_RelevTy       = "rty"
  show ACoreBindAspectKey_Debug         = "dbg"
  show ACoreBindAspectKey_Core          = "core"
  show ACoreBindAspectKey_FusionRole    = "fusionrole"

instance PP ACoreBindAspectKey where
  pp = pp . show

type ACoreBindAspectKeyS        =   Set.Set ACoreBindAspectKey
type ACoreBindAspMp x           =   Map.Map ACoreBindAspectKeyS x

acbaspkeyMk :: [ACoreBindAspectKey] -> ACoreBindAspectKeyS
acbaspkeyMk = Set.fromList

{-# LINE 424 "src/ehc/AbstractCore.chs" #-}
acbaspkeyMetaLev :: MetaLev -> ACoreBindAspectKeyS -> MetaLev
acbaspkeyMetaLev mlev _ = mlev

{-# LINE 435 "src/ehc/AbstractCore.chs" #-}
-- | predefined:
acbaspkeyNone :: ACoreBindAspectKeyS
acbaspkeyNone = acbaspkeyMk
  [  ]

-- | predefined:
acbaspkeyDefault :: ACoreBindAspectKeyS
acbaspkeyDefault = acbaspkeyMk
  [ ACoreBindAspectKey_Default ]

-- | predefined:
acbaspkeyTy :: ACoreBindAspectKeyS
acbaspkeyTy = acbaspkeyMk
  [ ACoreBindAspectKey_Ty ]

-- | predefined:
acbaspkeyDefaultTy :: ACoreBindAspectKeyS
acbaspkeyDefaultTy = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_Ty ]

-- | predefined:
acbaspkeyDefaultCore :: ACoreBindAspectKeyS
acbaspkeyDefaultCore = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_Core ]

-- | predefined:
acbaspkeyDefaultRelevTy :: ACoreBindAspectKeyS
acbaspkeyDefaultRelevTy = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_RelevTy ]

-- | predefined:
acbaspkeyStrict :: ACoreBindAspectKeyS
acbaspkeyStrict = acbaspkeyMk
  [ ACoreBindAspectKey_Strict ]

-- | predefined:
acbaspkeyDebug :: ACoreBindAspectKeyS
acbaspkeyDebug = acbaspkeyMk
  [ ACoreBindAspectKey_Debug ]

{-# LINE 494 "src/ehc/AbstractCore.chs" #-}
-- | predefined:
acbaspkeyFusionRole :: ACoreBindAspectKeyS
acbaspkeyFusionRole = acbaspkeyMk
  [ ACoreBindAspectKey_FusionRole ]

{-# LINE 501 "src/ehc/AbstractCore.chs" #-}
ppACBaspKeyS :: ACoreBindAspectKeyS -> PP_Doc
ppACBaspKeyS = ppCurlysCommas . Set.toList

{-# LINE 506 "src/ehc/AbstractCore.chs" #-}
-- | uniqify with ACoreBindAspectKeyS, omitting the default
hsnUniqifyACoreBindAspectKeyS :: ACoreBindAspectKeyS -> HsName -> HsName
hsnUniqifyACoreBindAspectKeyS as n
  = foldr mk n $ Set.toList as
  where mk ACoreBindAspectKey_Strict = hsnUniqify    HsNameUniqifier_Strict
        mk a                         = hsnUniqifyStr HsNameUniqifier_BindAspect (show a)

{-# LINE 515 "src/ehc/AbstractCore.chs" #-}
deriving instance Typeable ACoreBindAspectKey
deriving instance Data ACoreBindAspectKey

{-# LINE 524 "src/ehc/AbstractCore.chs" #-}
-- | reference to binding aspect: name + aspect keys
data ACoreBindRef
  = ACoreBindRef
      { acbrefNm        :: !HsName
      , acbrefMbAspKey  :: !(Maybe ACoreBindAspectKeyS)
      }
  deriving (Eq,Ord)

acoreMkRef :: HsName -> ACoreBindRef
acoreMkRef n = ACoreBindRef n Nothing

acoreMkAspRef :: ACoreBindAspectKeyS -> HsName -> ACoreBindRef
acoreMkAspRef a n = ACoreBindRef n (Just a)

instance HSNM ACoreBindRef where
  mkHNm (ACoreBindRef n ma) = maybe n (\a -> hsnUniqifyACoreBindAspectKeyS a n) ma

instance Show ACoreBindRef where
  show = show . mkHNm

{-# LINE 546 "src/ehc/AbstractCore.chs" #-}
acbrefAspKey :: ACoreBindRef -> ACoreBindAspectKeyS
acbrefAspKey = maybe acbaspkeyNone id . acbrefMbAspKey
{-# INLINE acbrefAspKey #-}

{-# LINE 552 "src/ehc/AbstractCore.chs" #-}
-- | narrow down aspects by adding more to ref; assume extra aspects non empty
acbrefAspAnd :: ACoreBindAspectKeyS -> ACoreBindRef -> ACoreBindRef
acbrefAspAnd a r = r {acbrefMbAspKey = Just $ a `Set.union` acbrefAspKey r }

{-# LINE 558 "src/ehc/AbstractCore.chs" #-}
ppACoreBindRef :: (HsName -> PP_Doc) -> ACoreBindRef -> PP_Doc
ppACoreBindRef ppN r = ppN (acbrefNm r) >|< (maybe empty (ppCurlysCommas . Set.toList) $ acbrefMbAspKey r)

instance PP ACoreBindRef where
  pp = ppACoreBindRef pp

{-# LINE 566 "src/ehc/AbstractCore.chs" #-}
deriving instance Typeable ACoreBindRef
deriving instance Data ACoreBindRef

{-# LINE 575 "src/ehc/AbstractCore.chs" #-}
acore1App :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> e -> e
acore1App f a = acore1AppBound f (acoreBound1Val a)
{-# INLINE acore1App #-}

-- | Applies the first expression to all given arguments.
acoreApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => e    -- ^ The lambda to apply.
    -> [e]  -- ^ The arguments (the empty list is allowed).
    -> e
acoreApp f as = foldl (\f a -> acore1App f a) f as

acoreAppBound :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> [bound] -> e
acoreAppBound f as = foldl (\f a -> acore1AppBound f a) f as

{-# LINE 595 "src/ehc/AbstractCore.chs" #-}
acoreLamBind :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [b] -> e -> e
acoreLamBind = flip (foldr acoreLam1Bind)
{-# INLINE acoreLamBind #-}

acoreLam1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e
acoreLam1Ty a t e = acoreLam1Bind (acoreBind1NmTy1 a t) e
-- acoreLam1Ty a t e = acoreLam1Bind (acoreBind1Nm1 a) e
-- acoreLam1Ty a t e = acoreLam1Bind (acoreBind1Ty a t) e       -- 20120418, TBD: ignore type for now
{-# INLINE acoreLam1Ty #-}

acoreLam1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> e
acoreLam1 a e = acoreLam1Ty a (acoreTyErr "acoreLam1") e
{-# INLINE acoreLam1 #-}

acoreLamTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(HsName,t)] -> e -> e
acoreLamTy as e = foldr (\(n,t) e -> acoreLam1Ty n t e) e as

acoreLam :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [HsName] -> e -> e
acoreLam as e = foldr (\(n) e -> acoreLam1 n e) e as

{-# LINE 617 "src/ehc/AbstractCore.chs" #-}
acoreTagTupTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> t -> [e] -> e
acoreTagTupTy tg t es = acoreTagTyTupBound tg t $ map acoreBound1Val es

-- | Creates a new tuple/record with the given values.
-- Has to be fully applied, partial application is not allowed.
acoreTagTup :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> [e] -> e
acoreTagTup tg es = acoreTagTupTy tg (acoreTyErr "acoreTupTy") es

acoreTupTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => t -> [e] -> e
acoreTupTy t es = acoreTagTupTy CTagRec t es
{-# INLINE acoreTupTy #-}

acoreTup :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [e] -> e
acoreTup es = acoreTagTup CTagRec es
{-# INLINE acoreTup #-}

acoreTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> e
acoreTag tg = acoreTagTup tg []
{-# INLINE acoreTag #-}

{-# LINE 650 "src/ehc/AbstractCore.chs" #-}
acoreBind1CatLevMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> bcat -> HsName -> MetaLev -> m -> t -> e -> b
acoreBind1CatLevMetaTyWith mkT mkE cat n l m t e = acoreBind1CatLevMetasTy cat n l (acoreMetabindDflt,m) (mkT t) (mkE e)
{-# INLINE acoreBind1CatLevMetaTyWith #-}

acoreBind1CatLevMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> m -> t -> e -> b
acoreBind1CatLevMetaTy = acoreBind1CatLevMetaTyWith id id
{-# INLINE acoreBind1CatLevMetaTy #-}

acoreBind1CatLevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> t -> e -> b
acoreBind1CatLevTy cat n l t e = acoreBind1CatLevMetaTy cat n l acoreMetavalDflt t e
{-# INLINE acoreBind1CatLevTy #-}

acoreBind1CatMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> t -> e -> b
acoreBind1CatMetaTy cat n m t e = acoreBind1CatLevMetaTy cat n metaLevVal m t e
{-# INLINE acoreBind1CatMetaTy #-}

acoreBind1CatTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> t -> e -> b
acoreBind1CatTy cat n t e = acoreBind1CatLevTy cat n metaLevVal t e
{-# INLINE acoreBind1CatTy #-}

acoreBind1LevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> MetaLev -> t -> e -> b
acoreBind1LevTy n l t e = acoreBind1CatLevTy (acoreBindcategDflt e) n l t e
{-# INLINE acoreBind1LevTy #-}

acoreBind1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> b
acoreBind1Ty n t e = acoreBind1LevTy n metaLevVal t e
{-# INLINE acoreBind1Ty #-}

acoreBind1Cat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> e -> b
acoreBind1Cat cat n e = acoreBind1CatTy cat n acoreTyNone {- (acoreTyErr "acoreBind1Cat") -} e
{-# INLINE acoreBind1Cat #-}

acoreBind1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> b
acoreBind1 n e = acoreBind1Cat (acoreBindcategDflt e) n e
{-# INLINE acoreBind1 #-}

{-# LINE 688 "src/ehc/AbstractCore.chs" #-}
acoreBind1MetasTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> t -> e -> b
acoreBind1MetasTy n m t e = acoreBind1CatLevMetasTy (acoreBindcategDflt e) n metaLevVal m t e
{-# INLINE acoreBind1MetasTy #-}

{-
acoreBind1Metas :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> e -> b
acoreBind1Metas n m e = aacoreBind1MetasTy n m acoreTyNone e
{-# INLINE acoreBind1Metas #-}
-}

acoreBind1CatMeta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> e -> b
acoreBind1CatMeta cat n m e = acoreBind1CatLevMetaTy cat n metaLevVal m (acoreTyErr "acoreBind1CatMeta") e
{-# INLINE acoreBind1CatMeta #-}

acoreBind1MetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> t -> e -> b
acoreBind1MetaTy n m t e = acoreBind1MetasTy n (acoreMetabindDflt,m) t e
{-# INLINE acoreBind1MetaTy #-}

{-
acoreBind1Meta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> b
acoreBind1Meta n m e = acoreBind1MetaTy n m acoreTyNone e
{-# INLINE acoreBind1Meta #-}
-}


{-# LINE 715 "src/ehc/AbstractCore.chs" #-}
acoreBind1Asp1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> bound -> b
acoreBind1Asp1 n ba = acoreBind1Asp n [ba]
{-# INLINE acoreBind1Asp1 #-}

acoreBind1NmLevTy1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> MetaLev -> t -> b
acoreBind1NmLevTy1 n l t = acoreBind1Asp n [acoreBoundValTy1CatLev acoreBindcategPlain n l t]
-- {-# INLINE acoreBind1NmLevTy1 #-}

acoreBind1NmTy1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> b
acoreBind1NmTy1 n t = acoreBind1NmLevTy1 n metaLevTy t
{-# INLINE acoreBind1NmTy1 #-}

acoreBind1Nm1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> b
acoreBind1Nm1 n = acoreBind1Asp n []
{-# INLINE acoreBind1Nm1 #-}

{-# LINE 737 "src/ehc/AbstractCore.chs" #-}
acoreBoundVal1CatLevMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> m -> t -> e -> bound
acoreBoundVal1CatLevMetaTy bcat n mlev m t e = acoreBoundVal1CatLevMetasTy bcat n mlev (acoreMetabindDflt,m) t e
{-# INLINE acoreBoundVal1CatLevMetaTy #-}

acoreBoundVal1CatLevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> t -> e -> bound
acoreBoundVal1CatLevTy cat n l t e = acoreBoundVal1CatLevMetaTy cat n l acoreMetavalDflt t e
{-# INLINE acoreBoundVal1CatLevTy #-}

acoreBoundVal1CatMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> t -> e -> bound
acoreBoundVal1CatMetaTy cat n m t e = acoreBoundVal1CatLevMetaTy cat n metaLevVal m t e
{-# INLINE acoreBoundVal1CatMetaTy #-}

acoreBoundVal1CatTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> t -> e -> bound
acoreBoundVal1CatTy cat n t e = acoreBoundVal1CatLevTy cat n metaLevVal t e
{-# INLINE acoreBoundVal1CatTy #-}

acoreBoundVal1Cat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> e -> bound
acoreBoundVal1Cat cat n e = acoreBoundVal1CatTy cat n (acoreTyErr "acoreBoundVal1Cat") e
{-# INLINE acoreBoundVal1Cat #-}

{-# LINE 759 "src/ehc/AbstractCore.chs" #-}
acoreBoundVal1Metas :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> e -> bound
acoreBoundVal1Metas n m e = acoreBoundVal1CatLevMetasTy (acoreBindcategDflt e) n metaLevVal m (acoreTyErr "acoreBoundVal1Metas") e
{-# INLINE acoreBoundVal1Metas #-}

acoreBoundVal1Meta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> bound
acoreBoundVal1Meta n m e = acoreBoundVal1Metas n (acoreMetabindDflt,m) e
{-# INLINE acoreBoundVal1Meta #-}


{-# LINE 770 "src/ehc/AbstractCore.chs" #-}
acoreBound1AspkeyVal :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => ACoreBindAspectKeyS -> e -> bound
acoreBound1AspkeyVal a e = acoreBound1MetaVal (acoreBoundmeta a 0 CLbl_None) e
{-# INLINE acoreBound1AspkeyVal #-}

acoreBound1Val :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> bound
acoreBound1Val e = acoreBound1AspkeyVal acbaspkeyDefault e
{-# INLINE acoreBound1Val #-}

{-# LINE 790 "src/ehc/AbstractCore.chs" #-}
acoreTyErrLift :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => String -> f x -> f (x,t)
acoreTyErrLift msg = fmap (\n -> (n,acoreTyErr msg))
{-# INLINE acoreTyErrLift #-}

{-# LINE 800 "src/ehc/AbstractCore.chs" #-}
-- | Construct let, possibly merging bindings
acoreLetMerge :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Bool -> bcat -> [b] -> e -> e
acoreLetMerge merge c bs e
  = if null bs
    then e
    else case acoreBindcategMbStrict c of
           {-
           Just _
             ->
           -}
           _ -> case acoreExprMbLet e of
                  Just (c',bs',e') | merge && c' == c
                    -> mk c (bs++bs') e'
                  _ -> mk c bs e
  where mk c bs e
          = case acoreBindcategMbRec c of
              Just c -> acoreLetBase c bs e
              _      -> foldr (\b e -> acoreLetBase c [b] e) e bs

acoreLet :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> [b] -> e -> e
acoreLet c bs e = acoreLetMerge False c bs e
{-# INLINE acoreLet #-}

-- | Creates a let binding, where the bindings may be mutually recursive.
acoreLetRec :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => [b]  -- ^ The bindings.
    -> e    -- ^ The body.
    -> e
acoreLetRec bs e = acoreLet (acoreBindcategRec) bs e
{-# INLINE acoreLetRec #-}

{-# LINE 833 "src/ehc/AbstractCore.chs" #-}
acoreLetN :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(bcat,[b])] -> e -> e
acoreLetN cbs e = foldr (\(c,bs) e -> acoreLet c bs e) e cbs

{-# LINE 838 "src/ehc/AbstractCore.chs" #-}
acoreLet1PlainTy :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e -> e
acoreLet1PlainTy nm t e
  = acoreLet cat [acoreBind1CatTy cat nm t e]
  where cat = acoreBindcategPlain

-- | Creates a (non-recursive) let binding.
acoreLet1Plain :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => HsName   -- ^ The identifier.
    -> e       -- ^ The expression to bind.
    -> e       -- ^ The body.
    -> e
acoreLet1Plain nm e = acoreLet1PlainTy nm (acoreTyErr "acoreLet1Plain") e
{-# INLINE acoreLet1Plain #-}

{-# LINE 854 "src/ehc/AbstractCore.chs" #-}
acoreLet1StrictTy :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e -> e
acoreLet1StrictTy nm t e
  = acoreLet cat [acoreBind1CatTy cat nm t e]
  where cat = acoreBindcategStrict

-- | Creates a let binding, which is strict in the bound expression.
acoreLet1Strict :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => HsName   -- ^ The identifer.
    -> e        -- ^ The expression to bind. Will be evaluated to WHNF, before the body is evaluated.
    -> e        -- ^ The body.
    -> e
acoreLet1Strict nm e = acoreLet1StrictTy nm (acoreTyErr "acoreLet1Strict") e
{-# INLINE acoreLet1Strict #-}

{-# LINE 870 "src/ehc/AbstractCore.chs" #-}
-- | evaluate an expr, with a continuation for the evaluated expr
acoreLet1StrictInMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> HsName -> m -> t -> e -> (e -> e) -> e
acoreLet1StrictInMetaTyWith mkT mkE nm m t e mkC
  = acoreLetBase cat [acoreBind1CatMetaTy cat nm m (mkT t) (mkE e)] (mkC (acoreVar nm))
  where cat = acoreBindcategStrict

acoreMbLet1StrictInMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> Maybe (HsName,t) -> m -> e -> (e -> e) -> e
acoreMbLet1StrictInMetaTyWith mkT mkE (Just (nm,t)) m e mkC = acoreLet1StrictInMetaTyWith mkT mkE nm m t e mkC
acoreMbLet1StrictInMetaTyWith _   _   _             m e mkC = mkC e

acoreLet1StrictInMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> t -> e -> (e -> e) -> e
acoreLet1StrictInMetaTy = acoreLet1StrictInMetaTyWith acoreTyUnThunk acoreExprUnThunk
{-# INLINE acoreLet1StrictInMetaTy #-}

acoreLet1StrictInMeta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> (e -> e) -> e
acoreLet1StrictInMeta nm m e mkC = acoreLet1StrictInMetaTy nm m (acoreTyErr "acoreLet1StrictInMeta") e mkC
{-# INLINE acoreLet1StrictInMeta #-}

acoreLet1StrictInTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> (e -> e) -> e
acoreLet1StrictInTy nm t e mkC = acoreLet1StrictInMetaTy nm acoreMetavalDflt t e mkC
{-# INLINE acoreLet1StrictInTy #-}

acoreLet1StrictIn :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> (e -> e) -> e
acoreLet1StrictIn nm e mkC = acoreLet1StrictInMeta nm acoreMetavalDflt e mkC
{-# INLINE acoreLet1StrictIn #-}

{-# LINE 902 "src/ehc/AbstractCore.chs" #-}
acoreNmHole :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => UID -> e
acoreNmHole = acoreVar . mkHNm

acoreNmHolePred :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => PredOccId -> e
acoreNmHolePred = acoreNmHole . poiId

{-# LINE 914 "src/ehc/AbstractCore.chs" #-}
-- | get default for bindcateg
acoreBindcategDflt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> bcat
acoreBindcategDflt _ = acoreBindcategPlain
{-# INLINE acoreBindcategDflt #-}

{-# LINE 925 "src/ehc/AbstractCore.chs" #-}
acoreChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Char -> e
acoreChar opts i = let x = acoreCharTy (acoreTyChar opts) i in x

-- | Creates an `Int` constant.
acoreInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Int -> e
acoreInt opts i = let x = acoreIntTy (acoreTyInt opts) i in x

acoreInt2 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Integer -> e
acoreInt2 opts i = let x = acoreIntTy2 (acoreTyInt opts) i in x

{-# LINE 941 "src/ehc/AbstractCore.chs" #-}
acoreBuiltinApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> (EHBuiltinNames -> HsName) -> [e] -> e
acoreBuiltinApp opts bnmOf args = acoreVar (ehcOptBuiltin opts bnmOf) `acoreApp` args

{-# LINE 946 "src/ehc/AbstractCore.chs" #-}
acoreBuiltinAddInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> Int -> e
acoreBuiltinAddInt opts e i
  = if i == 0
    then e
    else case acoreExprMbInt e of
           Just (t,i') -> acoreIntTy2 t (toInteger i + i')
           _           -> acoreBuiltinApp opts ehbnPrimAddInt [e,acoreInt opts i]

{-# LINE 956 "src/ehc/AbstractCore.chs" #-}
acoreBuiltinGtInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> Int -> e
acoreBuiltinGtInt opts e i = acoreBuiltinApp opts ehbnPrimGtInt [e,acoreInt opts i]

{-# LINE 961 "src/ehc/AbstractCore.chs" #-}
acoreBuiltinEqChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Char -> e -> e
acoreBuiltinEqChar opts c e = acoreBuiltinApp opts ehbnPrimEqChar [e,acoreChar opts c]

{-# LINE 966 "src/ehc/AbstractCore.chs" #-}
-- | Creates a string expression.
-- The expression represents a packed String, which can be passed to Haskell generated Core functions.
acoreBuiltinString :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> String   -- ^ The string.
    -> e
acoreBuiltinString opts m = let x = acoreBuiltinApp opts ehbnPackedStringToString [acoreStringTy (acoreTyString opts) m] in x

{-# LINE 976 "src/ehc/AbstractCore.chs" #-}
-- | Generates an error expression, failing with the given string when evaluated. ('error' in haskell)
acoreBuiltinError :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> String -- ^ The error message.
    -> e
acoreBuiltinError opts m = acoreBuiltinApp opts ehbnError [acoreBuiltinString opts m]

-- | Generates an undefined expression, failing when evaluated. ('undefined' in haskell)
acoreBuiltinUndefined :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e
acoreBuiltinUndefined opts = acoreBuiltinApp opts ehbnUndefined []

{-# LINE 989 "src/ehc/AbstractCore.chs" #-}
-- | Creates a Core 'Integer' constant.
acoreBuiltinInteger :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> Integer  -- ^ The integer.
    -> e
acoreBuiltinInteger opts i = acoreBuiltinApp opts ehbnPackedStringToInteger [acoreStringTy (acoreTyString opts) (show i)]

{-# LINE 998 "src/ehc/AbstractCore.chs" #-}
-- | Builtin list singleton (note: hardcoded of tags)
acoreBuiltinListSingleton :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> e
acoreBuiltinListSingleton opts e
  = acoreTagTupTy (ctagCons opts) (acoreTyErr "acoreBuiltinListSingleton.Cons") [e, acoreTagTupTy (ctagNil opts) (acoreTyErr "acoreBuiltinListSingleton.Nil") []]

{-# LINE 1009 "src/ehc/AbstractCore.chs" #-}
-- | when pat is con get tag
acorePatConMbTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => p -> Maybe CTag
acorePatConMbTag = fmap (\(tg,_,_) -> tg) . acorePatMbCon

-- | possibly get tag of alt
acoreAltMbTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => a -> Maybe CTag
acoreAltMbTag = (\p ->     (\(tg,_,_) -> tg) <$> acorePatMbCon  p
                       <|> (const ctagInt)   <$> acorePatMbInt  p
                       -- <|> (const ctagChar)  <$> acorePatMbChar p
                ) . fst . acoreUnAlt

{-# LINE 1026 "src/ehc/AbstractCore.chs" #-}
-- | bound name of binding
acoreBindNm :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => b -> HsName
acoreBindNm = fst . acoreUnBind
{-# INLINE acoreBindNm #-}

{-# LINE 1037 "src/ehc/AbstractCore.chs" #-}
-- | bound name of binding
acorePatFldTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => t -> (HsName,e) -> HsName -> pf
acorePatFldTy t lbloff n = acorePatFldBind lbloff (acoreBind1NmTy1 n t)
{-# INLINE acorePatFldTy #-}

{-# LINE 1048 "src/ehc/AbstractCore.chs" #-}
-- | possible expr of bound (may panic)
acoreUnBoundVal :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bound -> e
acoreUnBoundVal = maybe (panic "acoreBoundMbVal") (\(_,a) -> a) . acoreBoundMbVal
{-# INLINE acoreUnBoundVal #-}

{-# LINE 1059 "src/ehc/AbstractCore.chs" #-}
-- | Construct 'if' expression. Hardcoded: tag nr, ordered alts (by tag)
acoreIf :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Maybe HsName -> e -> e -> e -> e
acoreIf opts cn c t f
  = acoreMbLet1StrictInMetaTyWith id id (fmap (\n -> (n,acoreTyBool opts)) cn) acoreMetavalDflt c
    $ (\c -> acoreCaseDflt c
               [ acoreAlt (acorePatCon (ctagFalse opts) acorePatRestEmpty []) f
               , acoreAlt (acorePatCon (ctagTrue  opts) acorePatRestEmpty []) t
               ]
               Nothing {-(tcUndefined opts)-}
      )

{-# LINE 1072 "src/ehc/AbstractCore.chs" #-}
acoreMatchChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Maybe HsName -> Char -> e -> e -> e -> e
acoreMatchChar opts cn cchar cexpr t f
  = acoreIf opts cn (acoreBuiltinEqChar opts cchar cexpr) t f

{-# LINE 1102 "src/ehc/AbstractCore.chs" #-}
data Coe' expr metaval bind bindasp ty
  = Coe_Map             !(expr -> expr)                 -- normal, expression as function
  | Coe_C               !expr                           -- constant
  | Coe_Compose         !(Coe' expr metaval bind bindasp ty)    -- composition
                        !(Coe' expr metaval bind bindasp ty)
  | Coe_App1            !expr                           -- apply
  | Coe_App             [HsName]                        -- apply n args
  | Coe_Lam             !HsName !ty                     -- lambda
  | Coe_CloseExists     !TyVarId !ty !ty                -- closing existential
  | Coe_OpenExists      !TyVarId !ty !ty                -- opening existential
  | Coe_LamLet          !HsName !ty !UID                -- lambda with a let binding in the body
  | Coe_LetRec          ![bind]                         -- let rec
  | Coe_ImplApp         !ImplsVarId                     -- implicits, for apply
  | Coe_ImplLam         !ImplsVarId                     -- implicits, for lambda

instance Show (Coe' expr metaval bind bindasp ty) where
  show _ = "COE"

{-# LINE 1139 "src/ehc/AbstractCore.chs" #-}
-- | Coercions may either be applied or not on type arguments.
--   In particular, due to lack of proper analysis (and generics code like generation),
--   it is only known for arrow and product types how to construct a coercion from its type args, as they directly
--   correspond to values.
--
--   A CoeCtx encodes this yes/no may allow.
--   A CoeCtx is isomorphic (for now) to Bool.
data CoeCtx
  = CoeCtx_Allow
  | CoeCtx_DontAllow
  deriving (Eq,Show)

{-# LINE 1157 "src/ehc/AbstractCore.chs" #-}
-- | Non inspectable, most general, coercion
acoreCoeMap :: (e -> e) -> Coe' e m b ba t
acoreCoeMap = Coe_Map
{-# INLINE acoreCoeMap #-}

-- | Coe identity
acoreCoeId :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t
acoreCoeId = Coe_C acoreCoeArg
{-# INLINE acoreCoeId #-}

{-# LINE 1169 "src/ehc/AbstractCore.chs" #-}
acoreCoeLamLetTy :: HsName -> t -> UID -> Coe' e m b ba t
acoreCoeLamLetTy = Coe_LamLet
{-# INLINE acoreCoeLamLetTy #-}

acoreCoeLamLet :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> UID -> Coe' e m b ba t
acoreCoeLamLet n u = acoreCoeLamLetTy n (acoreTyErr "acoreCoeLamLet") u
{-# INLINE acoreCoeLamLet #-}

-- | Let still requiring a body
acoreCoeLetRec :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [b] -> Coe' e m b ba t
acoreCoeLetRec [] = acoreCoeId
acoreCoeLetRec bs = Coe_LetRec bs

{-# LINE 1184 "src/ehc/AbstractCore.chs" #-}
-- | Application still requiring a function
acoreCoeApp1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> Coe' e m b ba t
acoreCoeApp1 = Coe_App1 -- a acoreMetavalDflt
{-# INLINE acoreCoeApp1 #-}

acoreCoeAppNbyName :: [(HsName)] -> Coe' e m b ba t
acoreCoeAppNbyName = Coe_App
{-# INLINE acoreCoeAppNbyName #-}

-- acoreCoeApp2 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(e)] -> Coe' e m b ba t
-- acoreCoeApp2 as = acoreCoeMap (\e -> acoreApp e as)

acoreCoeAppN :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [e] -> Coe' e m b ba t
acoreCoeAppN as = acoreCoeMap (\e -> acoreApp e as)
{-# INLINE acoreCoeAppN #-}

{-# LINE 1202 "src/ehc/AbstractCore.chs" #-}
-- | Lambda still requiring a body
acoreCoeLam1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> Coe' e m b ba t
acoreCoeLam1Ty = Coe_Lam
{-# INLINE acoreCoeLam1Ty #-}

acoreCoeLam1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> Coe' e m b ba t
acoreCoeLam1 n = acoreCoeLam1Ty n (acoreTyErr "acoreCoeLam1")
{-# INLINE acoreCoeLam1 #-}

{-# LINE 1213 "src/ehc/AbstractCore.chs" #-}
-- | Composition of 2 Coe's
acoreCoeCompose :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Coe' e m b ba t -> Coe' e m b ba t
acoreCoeCompose c1 c2
  | acoreCoeIsId c1 = c2
  | otherwise  = Coe_Compose c1 c2


{-# LINE 1222 "src/ehc/AbstractCore.chs" #-}
acoreCoePoiLApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [PredOccId] -> [Coe' e m b ba t]
acoreCoePoiLApp = map (\i -> acoreCoeApp1 (acoreNmHolePred i))

acoreCoeImplsApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Impls -> [Coe' e m b ba t]
acoreCoeImplsApp = acoreCoePoiLApp . implsPrIdL

{-# LINE 1230 "src/ehc/AbstractCore.chs" #-}
acoreCoePoiLLamTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> [(PredOccId,t)] -> [Coe' e m b ba t]
acoreCoePoiLLamTy onLast poiL
  =  case map mk poiL of
       l@(_:_)            -> h ++ [t `acoreCoeCompose` onLast]
                          where (h,t) = fromJust $ initlast l
       _ | acoreCoeIsId onLast -> []
         | otherwise      -> [onLast]
  where mk (poi,ty) = acoreCoeLam1Ty (poiHNm poi) ty

acoreCoeImplsLam :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Impls -> [Coe' e m b ba t]
acoreCoeImplsLam onLast is = acoreCoePoiLLamTy onLast (acoreTyErrLift "acoreCoeImplsLam" (implsPrIdL is))

{-# LINE 1248 "src/ehc/AbstractCore.chs" #-}
acoreCoeIsId :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Bool
acoreCoeIsId (Coe_C e) = acoreExprIsCoeArg e
acoreCoeIsId _         = False

{-# LINE 1258 "src/ehc/AbstractCore.chs" #-}
data CSubstKey
  = CSKey_UID   UID
  | CSKey_Nm    HsName
  | CSKey_Ref   ACoreBindRef
  deriving (Show,Eq,Ord)

{-# LINE 1266 "src/ehc/AbstractCore.chs" #-}
data CSubstInfo' expr metaval bind bindasp ty
  =  CSITy        { csiTy      :: !ty
                  }
  |  CSIExpr      { csiRepl    :: !expr
                  }
  |  CSIImpls     { csiAppCoeL :: ![Coe' expr metaval bind bindasp ty]
                  , csiLamCoeL :: ![Coe' expr metaval bind bindasp ty]
                  }
  |  CSIBinds     { csiBindL   :: ![bind]
                  }

instance Show (CSubstInfo' e m b ba t) where
  show _ = "CSubstInfo'"

{-# LINE 1284 "src/ehc/AbstractCore.chs" #-}
type CSubst' e m b ba t = Map.Map CSubstKey (CSubstInfo' e m b ba t)

emptyCSubst :: CSubst' e m b ba t
emptyCSubst = Map.empty

{-# LINE 1295 "src/ehc/AbstractCore.chs" #-}
acoreCSubstFromNmTyL :: AssocL HsName t -> CSubst' e m b ba t
acoreCSubstFromNmTyL l = Map.fromList [ (CSKey_Nm k,CSITy v) | (k,v) <- l ]

{-# LINE 1300 "src/ehc/AbstractCore.chs" #-}
acoreCSubstFromRefExprL :: AssocL ACoreBindRef e -> CSubst' e m b ba t
acoreCSubstFromRefExprL l = Map.fromList [ (CSKey_Ref k,CSIExpr v) | (k,v) <- l ]

{-# LINE 1305 "src/ehc/AbstractCore.chs" #-}
acoreCSubstFromUidExprL :: AssocL UID e -> CSubst' e m b ba t
acoreCSubstFromUidExprL l = Map.fromList [ (CSKey_UID k,CSIExpr v) | (k,v) <- l ]

{-# LINE 1310 "src/ehc/AbstractCore.chs" #-}
acoreCSubstFromUidBindLL :: AssocL UID [b] -> CSubst' e m b ba t
acoreCSubstFromUidBindLL l = Map.fromList [ (CSKey_UID k,CSIBinds v) | (k,v) <- l ]

acoreCSubstFromUidImplsL :: AssocL UID ([Coe' e m b ba t],[Coe' e m b ba t]) -> CSubst' e m b ba t
acoreCSubstFromUidImplsL l = Map.fromList [ (CSKey_UID k,uncurry CSIImpls v) | (k,v) <- l ]

{-# LINE 1322 "src/ehc/AbstractCore.chs" #-}
-- | Combine CSubst: union only, application is postponed
cSubstAppSubst :: CSubst' e m b ba t -> CSubst' e m b ba t -> CSubst' e m b ba t
cSubstAppSubst = Map.union

{-# LINE 1332 "src/ehc/AbstractCore.chs" #-}
infixr `cSubstApp`

class CSubstitutable       e m b ba t a
                   | a  -> e m b ba t
  where
  cSubstApp :: CSubst' e m b ba t -> a -> a

instance CSubstitutable e m b ba t (CSubst' e m b ba t) where
  cSubstApp cs s = cs `cSubstAppSubst` s

{-# LINE 1348 "src/ehc/AbstractCore.chs" #-}
data RAlt' e t b pr
  = RAlt_Alt            { rcaPats :: ![RPat' e t b pr], raaExpr :: !e, raaFailS :: UIDS }

data RPat' e t b pr
  = RPat_Var            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpMustEval :: Bool }
  | RPat_Con            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpTag :: !CTag, rcpBinds :: !(RPatConBind' e t b pr) }
  | RPat_Int            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpInt :: !Integer }
  | RPat_Char           { rcpPNm :: !RPatNm, rcpTy :: !t, rcpChar :: !Char }
  | RPat_Irrefutable    { rcpPNm :: !RPatNm, rcpTy :: !t, rcpValBindL :: ![b] }
  | RPat_BoolExpr       { rcpPNm :: !RPatNm, rcpTy :: !t, rcpExpr :: !e, rcpMbConst :: Maybe SrcConst }

data RPatConBind' e t b pr
  = RPatConBind_One     { rpcbRest :: !pr, rpcbBinds :: ![RPatFld' e t b pr] }
  | RPatConBind_Many    { rpcbConBinds :: ![RPatConBind' e t b pr] }

data RPatFld' e t b pr
  = RPatFld_Fld         { rpbLbl :: !HsName, rpbOffset :: !e, rpbNm :: !HsName, rpbPat :: !(RPat' e t b pr)}

type RCEAltL' e t b pr = [RAlt' e t b pr]

{-# LINE 1372 "src/ehc/AbstractCore.chs" #-}
rcaPat :: RAlt' e t b pr -> RPat' e t b pr
rcaPat = head . rcaPats

raltLPatNms :: [RAlt' e t b pr] -> [RPatNm]
raltLPatNms = nub . sort . map (rcpPNm . rcaPat)

{-# LINE 1380 "src/ehc/AbstractCore.chs" #-}
rpatConTag :: RPat' e t b pr -> CTag
rpatConTag (RPat_Int  _ _ _ )  = ctagInt
rpatConTag (RPat_Char _ _ _ )  = ctagChar
rpatConTag p                   = rcpTag p

rcaTag :: RAlt' e t b pr -> CTag
rcaTag = rpatConTag . head . rcaPats

{-# LINE 1390 "src/ehc/AbstractCore.chs" #-}
raltIsVar :: RAlt' e t b pr -> Bool
raltIsVar (RAlt_Alt (RPat_Var _ _ _ : _) _ _)  = True
raltIsVar _                                    = False

raltIsConst :: RAlt' e t b pr -> Bool
raltIsConst (RAlt_Alt (p : _) _ _)
  = c p
  where c (RPat_Int   _ _ _) = True
        c (RPat_Char  _ _ _) = True
        c _                  = False

{-# LINE 1403 "src/ehc/AbstractCore.chs" #-}
raltIsConMany :: RAlt' e t b pr -> Bool
raltIsConMany (RAlt_Alt (RPat_Con _ _ _ (RPatConBind_Many _) : _) _ _) = True
raltIsConMany _                                                        = False

{-# LINE 1409 "src/ehc/AbstractCore.chs" #-}
raltIsIrrefutable :: RAlt' e t b pr -> Bool
raltIsIrrefutable (RAlt_Alt (RPat_Irrefutable _ _ _ : _) _ _) = True
raltIsIrrefutable _                                           = False

{-# LINE 1415 "src/ehc/AbstractCore.chs" #-}
raltMbBoolExpr :: RAlt' e t b pr -> Maybe (Maybe SrcConst)
raltMbBoolExpr (RAlt_Alt (RPat_BoolExpr _ _ _ e : _) _ _)  = Just e
raltMbBoolExpr _                                           = Nothing

raltIsBoolExpr :: RAlt' e t b pr -> Bool
raltIsBoolExpr = isJust . raltMbBoolExpr

{-# LINE 1426 "src/ehc/AbstractCore.chs" #-}
rpatConBindUnFlatten :: RPatConBind' e t b pr -> [RPatConBind' e t b pr] -> RPatConBind' e t b pr
rpatConBindUnFlatten z []  = z
rpatConBindUnFlatten _ [b] = b
rpatConBindUnFlatten _ bs  = RPatConBind_Many bs

{-# LINE 1437 "src/ehc/AbstractCore.chs" #-}
acoreRPat2Pat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPat' e t b pr -> p
acoreRPat2Pat p
  = case p of
      RPat_Var      n ty _    -> acorePatVarTy  (rpatNmNm n) ty
      RPat_Con      n _ t b   -> acorePatCon    t r bs
                              where (r,bs) = acoreRPatConBind2PatConBind b
      RPat_Int      n ty v    -> acorePatIntTy2 ty v
      RPat_Char     n ty v    -> acorePatCharTy ty v
      RPat_BoolExpr n _  v _  -> acorePatBoolExpr  v

{-# LINE 1451 "src/ehc/AbstractCore.chs" #-}
acoreRPatConBind2PatConBind :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPatConBind' e t b pr -> (pr,[pf])
acoreRPatConBind2PatConBind b
  = case b of
      RPatConBind_One   r bs    -> (r,map acoreRPatBind2PatFld bs)
      RPatConBind_Many  bs      -> head (map acoreRPatConBind2PatConBind bs)

acoreRPatBind2PatFld :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPatFld' e t b pr -> pf
acoreRPatBind2PatFld (RPatFld_Fld l o _ p@(RPat_Var n _ _)) = acorePatFldTy (rcpTy p) (l,o) (rpatNmNm n)

{-# LINE 1468 "src/ehc/AbstractCore.chs" #-}
ctagTrue, ctagFalse :: EHCOpts -> CTag
ctagTrue  opts = CTag (ehcOptBuiltin opts ehbnDataBool) (ehcOptBuiltin opts ehbnBoolTrue)  tagBoolTrue  0 0        -- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagFalse opts = CTag (ehcOptBuiltin opts ehbnDataBool) (ehcOptBuiltin opts ehbnBoolFalse) tagBoolFalse 0 0        -- this makes it hardcoded, ideally dependent on datatype def itself !!

{-# LINE 1480 "src/ehc/AbstractCore.chs" #-}
ctagCons, ctagNil :: EHCOpts -> CTag
ctagCons opts = CTag (ehcOptBuiltin opts ehbnDataList) (ehcOptBuiltin opts ehbnDataListAltCons) tagListCons 2 2       -- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagNil  opts = CTag (ehcOptBuiltin opts ehbnDataList) (ehcOptBuiltin opts ehbnDataListAltNil ) tagListNil  0 2       -- this makes it hardcoded, ideally dependent on datatype def itself !!

{-# LINE 1490 "src/ehc/AbstractCore.chs" #-}
-- | Reason to fail a case alternative
data CaseAltFailReason
  = CaseAltFailReason_Absence                   -- failed because of absence
  | CaseAltFailReason_Continue
      { cafailCaseId        :: UID              -- failed as part of case match attempt, but continues with code identified by id
      }
  deriving (Show,Eq,Ord)

instance PP CaseAltFailReason where
  pp (CaseAltFailReason_Continue i) = pp i
  pp (CaseAltFailReason_Absence   ) = pp "absent"

{-# LINE 1504 "src/ehc/AbstractCore.chs" #-}
cafailHasId :: CaseAltFailReason -> (Bool,UID)
cafailHasId (CaseAltFailReason_Absence   ) = (False,uidUnused)
cafailHasId (CaseAltFailReason_Continue i) = (True ,i)

{-# LINE 1510 "src/ehc/AbstractCore.chs" #-}
deriving instance Typeable CaseAltFailReason
deriving instance Data CaseAltFailReason

{-# LINE 1519 "src/ehc/AbstractCore.chs" #-}
data AppFunKind
  = AppFunKind_NoApp                    -- inlined Nothing
  | AppFunKind_Fun  ACoreBindRef
  | AppFunKind_Tag  CTag
  | AppFunKind_FFI

{-# LINE 1531 "src/ehc/AbstractCore.chs" #-}

-- | What kind of Expr?
data WhatExpr
  = ExprIsLam   Int             -- arity
                (Maybe HsName)  -- possibly name bound to
  | ExprIsApp   Int             -- arity
                WhatExpr        -- function
  | ExprIsVar   HsName
  | ExprIsInt   Int
  | ExprIsTup   CTag
  | ExprIsFFI
  | ExprIsOtherWHNF
  | ExprIsOther
  | ExprIsBind  HsName
  deriving Eq

{-# LINE 1549 "src/ehc/AbstractCore.chs" #-}
-- | is an var?
whatExprMbVar :: WhatExpr -> Maybe HsName
whatExprMbVar (ExprIsVar a) = Just a
whatExprMbVar _             = Nothing

-- | is an app?
whatExprMbApp :: WhatExpr -> Maybe (Int,WhatExpr)
whatExprMbApp (ExprIsApp a w) = Just (a,w)
whatExprMbApp _               = Nothing

-- | is a lam?
whatExprMbLam' :: WhatExpr -> Maybe (Int, Maybe HsName)
whatExprMbLam' (ExprIsLam a n) = Just (a, n)
whatExprMbLam' _               = Nothing

-- | is a lam?
whatExprMbLam :: WhatExpr -> Maybe Int
whatExprMbLam (ExprIsLam a _) = Just a
whatExprMbLam _               = Nothing

-- | is a bind?
whatExprMbBind :: WhatExpr -> Maybe HsName
whatExprMbBind (ExprIsBind n) = Just n
whatExprMbBind _              = Nothing

-- | app arity
whatExprAppArity :: WhatExpr -> Int
whatExprAppArity (ExprIsApp a _) = a
whatExprAppArity _               = 0

{-# LINE 1581 "src/ehc/AbstractCore.chs" #-}
whatExprIsWHNF :: WhatExpr -> Bool
whatExprIsWHNF (ExprIsLam _ _)  = True
whatExprIsWHNF (ExprIsVar _)    = True
whatExprIsWHNF (ExprIsInt _)    = True
whatExprIsWHNF (ExprIsTup _)    = True
whatExprIsWHNF ExprIsOtherWHNF  = True
whatExprIsWHNF _                = False

{-# LINE 1591 "src/ehc/AbstractCore.chs" #-}
whatExprIsBind :: WhatExpr -> Bool
whatExprIsBind = isJust . whatExprMbBind
{-# INLINE whatExprIsBind #-}

whatExprIsLam :: WhatExpr -> Bool
whatExprIsLam = isJust . whatExprMbLam
{-# INLINE whatExprIsLam #-}

-- | Is Expr a Tup?
whatExprIsTup :: WhatExpr -> Bool
whatExprIsTup (ExprIsTup _) = True
whatExprIsTup _             = False


{-# LINE 1607 "src/ehc/AbstractCore.chs" #-}
-- | Is Expr a FFI?
whatExprIsFFI :: WhatExpr -> Bool
whatExprIsFFI (ExprIsFFI  ) = True
whatExprIsFFI _             = False


{-# LINE 1625 "src/ehc/AbstractCore.chs" #-}
instance Serialize ACoreBindAspectKey where
  sput (ACoreBindAspectKey_Default       ) = sputWord8 0
  sput (ACoreBindAspectKey_Strict        ) = sputWord8 1
  sput (ACoreBindAspectKey_Ty            ) = sputWord8 2
  sput (ACoreBindAspectKey_RelevTy       ) = sputWord8 3
  sput (ACoreBindAspectKey_Debug         ) = sputWord8 4
  sput (ACoreBindAspectKey_Core          ) = sputWord8 5
  sput (ACoreBindAspectKey_FusionRole    ) = sputWord8 7
  sget = do
    t <- sgetWord8
    case t of
        0 -> return ACoreBindAspectKey_Default
        1 -> return ACoreBindAspectKey_Strict
        2 -> return ACoreBindAspectKey_Ty
        3 -> return ACoreBindAspectKey_RelevTy
        4 -> return ACoreBindAspectKey_Debug
        5 -> return ACoreBindAspectKey_Core
        7 -> return ACoreBindAspectKey_FusionRole

{-# LINE 1656 "src/ehc/AbstractCore.chs" #-}
instance Serialize ACoreBindRef where
  sput (ACoreBindRef a b) = sput a >> sput b
  sget = liftM2 ACoreBindRef sget sget

{-# LINE 1662 "src/ehc/AbstractCore.chs" #-}
instance Serialize CaseAltFailReason where
  sput (CaseAltFailReason_Continue a) = sputWord8 0 >> sput a
  sput (CaseAltFailReason_Absence   ) = sputWord8 1
  sget = do
    t <- sgetWord8
    case t of
      0 -> liftM  CaseAltFailReason_Continue sget
      1 -> return CaseAltFailReason_Absence

{-# LINE 1677 "src/ehc/AbstractCore.chs" #-}
instance PP CSubstKey where
  pp (CSKey_UID i)  = pp i
  pp (CSKey_Nm  n)  = pp n
  pp (CSKey_Ref r)  = pp r

{-# LINE 1684 "src/ehc/AbstractCore.chs" #-}
instance (PP expr, PP ty) => PP (CSubstInfo' expr metaval bind bindasp ty) where
  pp (CSITy         t    )  = pp t
  pp (CSIExpr       e    )  = pp e
  pp (CSIImpls      l r  )  = pp "CSIImpls" -- pp (fst $ coeWeaveOnAsSubst uidStart l r CExpr_CoeArg)
  pp (CSIBinds      b    )  = pp "CSIBinds" -- ppCBindL b

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.AbstractCore
( AbstractCore (..)
, ACoreAppLikeMetaBound
, acoreMetaLift
, ACoreBindAspectKey (..), ACoreBindAspectKeyS, ACoreBindAspMp
, acbaspkeyMetaLev
, acbaspkeyDefaultTy, acbaspkeyTy, acbaspkeyDefaultCore, acbaspkeyNone, acbaspkeyDefault, acbaspkeyDefaultRelevTy, acbaspkeyStrict, acbaspkeyDebug
, ppACBaspKeyS
, hsnUniqifyACoreBindAspectKeyS
, ACoreBindRef (..), acoreMkRef, acoreMkAspRef
, acbrefAspAnd
, ppACoreBindRef
, acore1App, acoreApp, acoreAppBound
, acoreLamBind, acoreLam1Ty, acoreLam1, acoreLamTy, acoreLam
, acoreTagTupTy, acoreTagTup, acoreTupTy, acoreTup, acoreTag
, acoreBind1CatLevMetaTyWith, acoreBind1CatLevMetaTy, acoreBind1CatLevTy, acoreBind1CatMetaTy, acoreBind1CatTy, acoreBind1Cat, acoreBind1LevTy, acoreBind1Ty, acoreBind1
, acoreBind1MetasTy, acoreBind1CatMeta, acoreBind1MetaTy
, acoreBind1Asp1, acoreBind1NmLevTy1, acoreBind1Nm1
, acoreBoundVal1CatLevMetaTy, acoreBoundVal1CatLevTy, acoreBoundVal1CatMetaTy, acoreBoundVal1CatTy, acoreBoundVal1Cat
, acoreBoundVal1Metas, acoreBoundVal1Meta
, acoreBound1AspkeyVal, acoreBound1Val
, acoreTyErrLift
, acoreLetMerge, acoreLet, acoreLetRec
, acoreLetN
, acoreLet1PlainTy, acoreLet1Plain
, acoreLet1StrictTy, acoreLet1Strict
, acoreLet1StrictInMetaTyWith, acoreLet1StrictInMetaTy, acoreLet1StrictInMeta, acoreLet1StrictIn, acoreLet1StrictInTy
, acoreBindcategDflt
, acoreChar, acoreInt, acoreInt2
, acoreBuiltinApp
, acoreBuiltinAddInt
, acoreBuiltinGtInt
, acoreBuiltinString
, acoreBuiltinError, acoreBuiltinUndefined
, acorePatConMbTag, acoreAltMbTag
, acoreBindNm
, acorePatFldTy
, acoreUnBoundVal
, Coe' (..)
, CoeCtx (..)
, acoreCoeId, acoreCoeMap
, acoreCoeApp1, acoreCoeAppN, acoreCoeAppNbyName
, acoreCoeLam1Ty, acoreCoeLam1
, acoreCoeCompose
, acoreCoeIsId
, CSubstKey (..)
, CSubstInfo' (..)
, CSubst', emptyCSubst
, acoreCSubstFromNmTyL
, acoreCSubstFromRefExprL
, acoreCSubstFromUidExprL
, cSubstAppSubst------------------------- constructing: expr -------------------------
, CSubstitutable-- | 1 arg application, together with meta info about the argument, packaged in the bind(..)
, RAlt' (..), RPat' (..), RPatConBind' (..), RPatFld' (..), RCEAltL'
, rcaPat, raltLPatNms
, rcaTag-- | 1 arg application, together with meta info about the argument
, raltIsVar-- acoreLam1Ty :: HsName -> ty -> expr -> expr, raltIsConst
, raltIsConMany
, raltIsIrrefutable-- | 1 lam abstraction, together with meta info about, and type of the argument
, rpatConBindUnFlatten
, acoreRPat2Pat
, ctagTrue-- | a tuple, with tag, and ty, ctagFalse
, ctagCons, ctagNil
, CaseAltFailReason (..)
, cafailHasId-- | a value binding, for a name to value + type + metas + meta level
, AppFunKind (..)
, WhatExpr (..)
, whatExprMbVar-- | a value binding aspect, for a name + value, optionally type + metas + meta level, whatExprMbApp, whatExprMbLam, whatExprMbLam', whatExprAppArity, whatExprMbBind
, whatExprIsWHNF
, whatExprIsLam, whatExprIsTup, whatExprIsBind
, whatExprIsFFI-- | a type for value binding aspect, for a name + type, optionally meta level
, acoreMetaLiftDict
, acoreNmHolePred, acoreNmHole
, acoreCoeLamLetTy-- | meta for something bound; for a name, meta level and label, acoreCoeLamLet, acoreCoeLetRec
, acoreCoePoiLApp, acoreCoeImplsApp
, acoreCoePoiLLamTy, acoreCoeImplsLam
, acoreCSubstFromUidImplsL-- | a expr binding aspect, for a name, meta level and label, acoreCSubstFromUidBindLL
, acoreIf
, acbaspkeyFusionRole
, acoreBuiltinInteger-- | a binding, for/from a single aspect (for now, later multiple)
, raltMbBoolExpr, raltIsBoolExpr
, acoreBuiltinEqChar
, acoreBuiltinListSingleton-- | basic let binding
, acoreMatchChar )
where
import-- | cast, defaults to noopUHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Opts.Base
import-- | A Case expression, possibly with a default value.UHC.Light.Compiler.Ty
import UHC.Util.Pretty      -- ^ The scrutinee. Required to be in WHNF.
import UHC.Util.Utils       -- ^ The alternatives.
import Data.List            -- ^ The default value. (TODO what is the behaviour if it is Nothing?)
import Data.Maybe
import qualified Data.Map as Map
import-- | Creates a variable expression.qualified Data.Set as Set
import Control.Applicative ((<|>),(<$>))
import Control.Monad
import-- | stringUHC.Util.Binary
import UHC.Util.Serialize
import Data.Typeable (Typeable)
import-- | charData.Generics (Data) AbstractCore  expr metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
    | expr       ->      metaval bind bound boundmeta bindcateg metabind ty pat patrest patfld alt
    , metaval    -> expr
    , bind       -> expr
    , bound      -> expr
    , boundmeta  -> expr
    , bindcateg  -> expr
    , metabind   -> expr
    , ty         -> expr
    , pat        -> expr
    , patrest    -> expr
    , patfld     -> expr
    , alt        -> expr
  where


  acoreLam1Bind :: bind -> expr -> expr





  acore1AppBound :: expr -> bound -> expr


  acoreTagTyTupBound :: CTag -> ty -> [bound] -> expr


  acoreBind1CatLevMetasTy :: bindcateg -> HsName -> MetaLev -> (metabind,metaval) -> ty -> expr -> bind


  acoreBoundVal1CatLevMetasTy :: bindcateg -> HsName -> MetaLev -> (metabind,metaval) -> ty -> expr -> bound


  acoreBoundValTy1CatLev :: bindcateg -> HsName -> MetaLev -> ty -> bound


  acoreBoundmeta :: ACoreBindAspectKeyS -> MetaLev -> CLbl -> boundmeta


  acoreBound1MetaVal :: boundmeta -> expr -> bound


  acoreBind1Asp :: HsName -> [bound] -> bind


  acoreLetBase :: bindcateg -> [bind] -> expr -> expr


  acoreCast :: ty -> expr -> expr
  acoreCast _ e = e


  acoreCaseDflt  :: expr
        -> [alt]
        -> Maybe expr
        -> expr


  acoreVar  :: HsName -> expr


  acoreStringTy  :: ty -> String -> expr


  acoreCharTy  :: ty -> Char -> expr

  -- | int as Int
  acoreIntTy  :: ty -> Int -> expr

  -- | int as Integer
  acoreIntTy2 :: ty -> Integer -> expr

  -- | hole: placeholder for CSubst to fill in
  acoreUidHole :: UID -> expr

  -- | hole: let with hole for bindings to be filled in later by means of a CSubst
  acoreHoleLet :: UID -> expr -> expr

  -- | a default, fallback
  -- acoreDflt :: expr

  -- | get error/default expr
  acoreExprErr :: String -> expr
  acoreExprErr s = panic $ "AbstractCore.acoreExprErr: " ++ s


  ------------------------- constructing: ty constants -------------------------
  -- Int
  -- acoreTyInt2 :: ty

  -- Bool
  acoreTyBool :: EHCOpts -> ty

  ------------------------- constructing: pat -------------------------
  -- | pat var, with type
  acorePatVarTy :: HsName -> ty -> pat

  -- | Matches the case scrutinee with the given constructor tag.
  acorePatCon :: CTag   -- ^ The constructor to match.
    -> patrest          -- ^ ???
    -> [patfld]         -- ^ ???
    -> pat

  -- | pat int
  acorePatIntTy :: ty -> Int -> pat

  -- | pat Integer
  acorePatIntTy2 :: ty -> Integer -> pat

  -- | pat char
  acorePatCharTy :: ty -> Char -> pat

  -- | pat boolean guard
  acorePatBoolExpr :: expr -> pat
  ------------------------- constructing: pat field -------------------------
  -- | TODO ??? pat field
  acorePatFldBind :: (HsName,expr)  -- ^ lbl, offset ???
    -> bind     -- ^ ??
    -> patfld
  -- acorePatFldTy :: ty -> (HsName,expr) -> HsName -> patfld

  ------------------------- constructing: patrest -------------------------
  -- | patrest, empty TODO what does it mean?
  acorePatRestEmpty :: patrest

  -- | patrest, var
  acorePatRestVar :: HsName -> patrest

  ------------------------- constructing: alt -------------------------
  -- | Creates an alternative of a case statement.
  acoreAlt :: pat   -- ^ The pattern with which to match the case scrutinee.
        -> expr     -- ^ The value of this alternative.
        -> alt

  ------------------------- constructing: top level -------------------------
  -- | Wraps main expr into a form which can be directly run by evaluating
  acoreRunMain :: expr     -- ^ main
        -> expr
  acoreRunMain e = acore1App e (acoreTup [])

  ------------------------- type related -------------------------
  -- | construct ty from Ty, usable in Core context
  acoreTy2ty :: EHCOpts -> Ty -> ty

  ------------------------- defaults -------------------------
  -- | get default for metaval
  acoreMetavalDflt :: metaval

  -- | get default for metaval, for dicts
  acoreMetavalDfltDict :: metaval

  -- | get default for metabind
  acoreMetabindDflt :: metabind

  -- | get default for metabind
  acoreDfltBoundmeta :: boundmeta
  acoreDfltBoundmeta = panic "AbstractCore.acoreDfltBoundmeta not implemented"

  -- | get error/default ty, type indexed by ty
  acoreTyErr :: String -> ty
  acoreTyErr s = panic $ "AbstractCore.acoreTyErr: " ++ s

  -- | get the ty representing the absent type, no type info
  acoreTyNone :: ty

  -- | get char ty
  acoreTyChar :: EHCOpts -> ty

  -- | get int ty
  acoreTyInt :: EHCOpts -> ty

  -- | get String ty
  acoreTyString :: EHCOpts -> ty

  ------------------------- bindcateg values -------------------------
  -- | get recursive bindcateg
  acoreBindcategRec :: bindcateg

  -- | get strict bindcateg
  acoreBindcategStrict :: bindcateg

  -- | get plain bindcateg
  acoreBindcategPlain :: bindcateg

  ------------------------- inspecting/deconstructing -------------------------
  -- | is expr an application?
  acoreExprMbApp :: expr -> Maybe (expr,bound)


  -- | is expr a lambda?
  acoreExprMbLam :: expr -> Maybe (bind,expr)

  -- | is expr a let?
  acoreExprMbLet :: expr -> Maybe (bindcateg,[bind],expr)

  -- | is expr a var?
  acoreExprMbVar :: expr -> Maybe HsName

  -- | is expr a int?
  acoreExprMbInt :: expr -> Maybe (ty,Integer)

  -- | is bindcateg recursive?
  acoreBindcategMbRec :: bindcateg -> Maybe bindcateg

  -- | is bindcateg strict?
  acoreBindcategMbStrict :: bindcateg -> Maybe bindcateg

  -- | is pat a con?
  acorePatMbCon :: pat -> Maybe(CTag,patrest,[patfld])

  -- | is pat a int?
  acorePatMbInt :: pat -> Maybe(ty,Integer)

  -- | is pat a char?
  acorePatMbChar :: pat -> Maybe(ty,Char)

  -- | 'un' alt
  acoreUnAlt :: alt -> (pat,expr)

  -- | 'un' patfld
  acoreUnPatFld :: patfld -> ((HsName,expr),bind)

  -- | 'un' patfld
  -- acoreUnPatFld :: patfld -> (ty,(HsName,expr),HsName)

  -- | 'un' bind
  acoreUnBind :: bind -> (HsName,[bound])

  -- | is bound a expr?
  acoreBoundMbVal :: bound -> Maybe (boundmeta,expr)

  ------------------------- transforming -------------------------
  -- | thunk expr, i.e. turn into delayed computation
  acoreExprThunk :: expr -> expr
  acoreExprThunk = id

  -- | thunk ty, i.e. ty of 'acoreExprThunk'-ed expr
  acoreTyThunk :: ty -> ty
  acoreTyThunk = id

  -- | unthunk expr, i.e. force computation of delayed computation
  acoreExprUnThunk :: expr -> expr
  acoreExprUnThunk = id

  -- | unthunk ty, i.e. ty of 'acoreExprUnThunk'-ed expr
  acoreTyUnThunk :: ty -> ty
  acoreTyUnThunk = id

  ------------------------- coercion related: construction -------------------------
  -- | coercion arg placeholder
  acoreCoeArg :: expr

  ------------------------- coercion related: inspecting/deconstructing -------------------------
  -- | coercion arg placeholder
  acoreExprIsCoeArg :: expr -> Bool



























type ACoreAppLikeMetaBound = (ACoreBindAspectKeyS,MetaLev,CLbl)



instance AbstractCore e m b bound boundmeta bcat mbind t p pr pf a => AppLike e boundmeta {- () () -} where
  app1App       = acore1App
  appTop        = id
  appCon        = acoreVar . mkHNm
  appPar        = id
  appVar        = acoreVar . mkHNm

  -- appDflt       =
  appDfltBoundmeta x = acoreDfltBoundmeta
  appDbg        = acoreExprErr

  appMbCon      = acoreExprMbVar
  appMbApp1 e   = do (f,b) <- acoreExprMbApp e
                     (_,a) <- acoreBoundMbVal b
                     return (f,a)
















instance AbstractCore e m b bound boundmeta bcat mbind t p pr pf a => RecLike e boundmeta {- () () -} where
  recRow _ fs   = acoreTagTyTupBound CTagRec (acoreTyErr "AbstractCore.RecLike.recRow") [ acoreBound1MetaVal (acoreBoundmeta acbaspkeyDefault 0 (CLbl_Nm n)) e | (n,e) <- fs ]

  recMbRecRow  _= Nothing -- tyMbRecRowWithLkup (const Nothing)
  recUnRowExts e= (e,[])







acoreMetaLift :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => f x -> f (x,m)
acoreMetaLift = fmap2Tuple acoreMetavalDflt



acoreMetaLiftDict :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => f x -> f (x,m)
acoreMetaLiftDict = fmap2Tuple acoreMetavalDfltDict








-- | A ACoreBindAspectKeyS formed out of multiple ACoreBindAspectKey identifies a particular binding aspect
data ACoreBindAspectKey
  = ACoreBindAspectKey_Default              -- identifies the default binding, if omitted in a reference this aspect is the one chosen.
  | ACoreBindAspectKey_Ty                   -- the normal ty
  | ACoreBindAspectKey_RelevTy              -- the relevance ty
  | ACoreBindAspectKey_Strict               -- the as strict as possible variant
  | ACoreBindAspectKey_Debug                -- internal debugging only
  | ACoreBindAspectKey_Core                 -- core
  | ACoreBindAspectKey_FusionRole           -- fusion role
  deriving (Eq,Ord)

instance Show ACoreBindAspectKey where
  show ACoreBindAspectKey_Default       = "dft"
  show ACoreBindAspectKey_Strict        = "str"
  show ACoreBindAspectKey_Ty            = "ty"
  show ACoreBindAspectKey_RelevTy       = "rty"
  show ACoreBindAspectKey_Debug         = "dbg"
  show ACoreBindAspectKey_Core          = "core"
  show ACoreBindAspectKey_FusionRole    = "fusionrole"

instance PP ACoreBindAspectKey where
  pp = pp . show

type ACoreBindAspectKeyS        =   Set.Set ACoreBindAspectKey
type ACoreBindAspMp x           =   Map.Map ACoreBindAspectKeyS x

acbaspkeyMk :: [ACoreBindAspectKey] -> ACoreBindAspectKeyS
acbaspkeyMk = Set.fromList













acbaspkeyMetaLev :: MetaLev -> ACoreBindAspectKeyS -> MetaLev
acbaspkeyMetaLev mlev _ = mlev









-- | predefined:
acbaspkeyNone :: ACoreBindAspectKeyS
acbaspkeyNone = acbaspkeyMk
  [  ]

-- | predefined:
acbaspkeyDefault :: ACoreBindAspectKeyS
acbaspkeyDefault = acbaspkeyMk
  [ ACoreBindAspectKey_Default ]

-- | predefined:
acbaspkeyTy :: ACoreBindAspectKeyS
acbaspkeyTy = acbaspkeyMk
  [ ACoreBindAspectKey_Ty ]

-- | predefined:
acbaspkeyDefaultTy :: ACoreBindAspectKeyS
acbaspkeyDefaultTy = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_Ty ]

-- | predefined:
acbaspkeyDefaultCore :: ACoreBindAspectKeyS
acbaspkeyDefaultCore = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_Core ]

-- | predefined:
acbaspkeyDefaultRelevTy :: ACoreBindAspectKeyS
acbaspkeyDefaultRelevTy = acbaspkeyMk
  [ ACoreBindAspectKey_Default, ACoreBindAspectKey_RelevTy ]

-- | predefined:
acbaspkeyStrict :: ACoreBindAspectKeyS
acbaspkeyStrict = acbaspkeyMk
  [ ACoreBindAspectKey_Strict ]

-- | predefined:
acbaspkeyDebug :: ACoreBindAspectKeyS
acbaspkeyDebug = acbaspkeyMk
  [ ACoreBindAspectKey_Debug ]




















-- | predefined:
acbaspkeyFusionRole :: ACoreBindAspectKeyS
acbaspkeyFusionRole = acbaspkeyMk
  [ ACoreBindAspectKey_FusionRole ]



ppACBaspKeyS :: ACoreBindAspectKeyS -> PP_Doc
ppACBaspKeyS = ppCurlysCommas . Set.toList



-- | uniqify with ACoreBindAspectKeyS, omitting the default
hsnUniqifyACoreBindAspectKeyS :: ACoreBindAspectKeyS -> HsName -> HsName
hsnUniqifyACoreBindAspectKeyS as n
  = foldr mk n $ Set.toList as
  where mk ACoreBindAspectKey_Strict = hsnUniqify    HsNameUniqifier_Strict
        mk a                         = hsnUniqifyStr HsNameUniqifier_BindAspect (show a)



deriving instance Typeable ACoreBindAspectKey
deriving instance Data ACoreBindAspectKey







-- | reference to binding aspect: name + aspect keys
data ACoreBindRef
  = ACoreBindRef
      { acbrefNm        :: !HsName
      , acbrefMbAspKey  :: !(Maybe ACoreBindAspectKeyS)
      }
  deriving (Eq,Ord)

acoreMkRef :: HsName -> ACoreBindRef
acoreMkRef n = ACoreBindRef n Nothing

acoreMkAspRef :: ACoreBindAspectKeyS -> HsName -> ACoreBindRef
acoreMkAspRef a n = ACoreBindRef n (Just a)

instance HSNM ACoreBindRef where
  mkHNm (ACoreBindRef n ma) = maybe n (\a -> hsnUniqifyACoreBindAspectKeyS a n) ma

instance Show ACoreBindRef where
  show = show . mkHNm



acbrefAspKey :: ACoreBindRef -> ACoreBindAspectKeyS
acbrefAspKey = maybe acbaspkeyNone id . acbrefMbAspKey
{-# INLINE acbrefAspKey #-}



-- | narrow down aspects by adding more to ref; assume extra aspects non empty
acbrefAspAnd :: ACoreBindAspectKeyS -> ACoreBindRef -> ACoreBindRef
acbrefAspAnd a r = r {acbrefMbAspKey = Just $ a `Set.union` acbrefAspKey r }



ppACoreBindRef :: (HsName -> PP_Doc) -> ACoreBindRef -> PP_Doc
ppACoreBindRef ppN r = ppN (acbrefNm r) >|< (maybe empty (ppCurlysCommas . Set.toList) $ acbrefMbAspKey r)

instance PP ACoreBindRef where
  pp = ppACoreBindRef pp



deriving instance Typeable ACoreBindRef
deriving instance Data ACoreBindRef







acore1App :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> e -> e
acore1App f a = acore1AppBound f (acoreBound1Val a)
{-# INLINE acore1App #-}

-- | Applies the first expression to all given arguments.
acoreApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => e    -- ^ The lambda to apply.
    -> [e]  -- ^ The arguments (the empty list is allowed).
    -> e
acoreApp f as = foldl (\f a -> acore1App f a) f as

acoreAppBound :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> [bound] -> e
acoreAppBound f as = foldl (\f a -> acore1AppBound f a) f as







acoreLamBind :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [b] -> e -> e
acoreLamBind = flip (foldr acoreLam1Bind)
{-# INLINE acoreLamBind #-}

acoreLam1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e
acoreLam1Ty a t e = acoreLam1Bind (acoreBind1NmTy1 a t) e
-- acoreLam1Ty a t e = acoreLam1Bind (acoreBind1Nm1 a) e
-- acoreLam1Ty a t e = acoreLam1Bind (acoreBind1Ty a t) e       -- 20120418, TBD: ignore type for now
{-# INLINE acoreLam1Ty #-}

acoreLam1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> e
acoreLam1 a e = acoreLam1Ty a (acoreTyErr "acoreLam1") e
{-# INLINE acoreLam1 #-}

acoreLamTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(HsName,t)] -> e -> e
acoreLamTy as e = foldr (\(n,t) e -> acoreLam1Ty n t e) e as

acoreLam :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [HsName] -> e -> e
acoreLam as e = foldr (\(n) e -> acoreLam1 n e) e as



acoreTagTupTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> t -> [e] -> e
acoreTagTupTy tg t es = acoreTagTyTupBound tg t $ map acoreBound1Val es

-- | Creates a new tuple/record with the given values.
-- Has to be fully applied, partial application is not allowed.
acoreTagTup :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> [e] -> e
acoreTagTup tg es = acoreTagTupTy tg (acoreTyErr "acoreTupTy") es

acoreTupTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => t -> [e] -> e
acoreTupTy t es = acoreTagTupTy CTagRec t es
{-# INLINE acoreTupTy #-}

acoreTup :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [e] -> e
acoreTup es = acoreTagTup CTagRec es
{-# INLINE acoreTup #-}

acoreTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => CTag -> e
acoreTag tg = acoreTagTup tg []
{-# INLINE acoreTag #-}














acoreBind1CatLevMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> bcat -> HsName -> MetaLev -> m -> t -> e -> b
acoreBind1CatLevMetaTyWith mkT mkE cat n l m t e = acoreBind1CatLevMetasTy cat n l (acoreMetabindDflt,m) (mkT t) (mkE e)
{-# INLINE acoreBind1CatLevMetaTyWith #-}

acoreBind1CatLevMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> m -> t -> e -> b
acoreBind1CatLevMetaTy = acoreBind1CatLevMetaTyWith id id
{-# INLINE acoreBind1CatLevMetaTy #-}

acoreBind1CatLevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> t -> e -> b
acoreBind1CatLevTy cat n l t e = acoreBind1CatLevMetaTy cat n l acoreMetavalDflt t e
{-# INLINE acoreBind1CatLevTy #-}

acoreBind1CatMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> t -> e -> b
acoreBind1CatMetaTy cat n m t e = acoreBind1CatLevMetaTy cat n metaLevVal m t e
{-# INLINE acoreBind1CatMetaTy #-}

acoreBind1CatTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> t -> e -> b
acoreBind1CatTy cat n t e = acoreBind1CatLevTy cat n metaLevVal t e
{-# INLINE acoreBind1CatTy #-}

acoreBind1LevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> MetaLev -> t -> e -> b
acoreBind1LevTy n l t e = acoreBind1CatLevTy (acoreBindcategDflt e) n l t e
{-# INLINE acoreBind1LevTy #-}

acoreBind1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> b
acoreBind1Ty n t e = acoreBind1LevTy n metaLevVal t e
{-# INLINE acoreBind1Ty #-}

acoreBind1Cat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> e -> b
acoreBind1Cat cat n e = acoreBind1CatTy cat n acoreTyNone {- (acoreTyErr "acoreBind1Cat") -} e
{-# INLINE acoreBind1Cat #-}

acoreBind1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> b
acoreBind1 n e = acoreBind1Cat (acoreBindcategDflt e) n e
{-# INLINE acoreBind1 #-}



acoreBind1MetasTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> t -> e -> b
acoreBind1MetasTy n m t e = acoreBind1CatLevMetasTy (acoreBindcategDflt e) n metaLevVal m t e
{-# INLINE acoreBind1MetasTy #-}

{-
acoreBind1Metas :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> e -> b
acoreBind1Metas n m e = aacoreBind1MetasTy n m acoreTyNone e
{-# INLINE acoreBind1Metas #-}
-}

acoreBind1CatMeta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> e -> b
acoreBind1CatMeta cat n m e = acoreBind1CatLevMetaTy cat n metaLevVal m (acoreTyErr "acoreBind1CatMeta") e
{-# INLINE acoreBind1CatMeta #-}

acoreBind1MetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> t -> e -> b
acoreBind1MetaTy n m t e = acoreBind1MetasTy n (acoreMetabindDflt,m) t e
{-# INLINE acoreBind1MetaTy #-}

{-
acoreBind1Meta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> b
acoreBind1Meta n m e = acoreBind1MetaTy n m acoreTyNone e
{-# INLINE acoreBind1Meta #-}
-}




acoreBind1Asp1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> bound -> b
acoreBind1Asp1 n ba = acoreBind1Asp n [ba]
{-# INLINE acoreBind1Asp1 #-}

acoreBind1NmLevTy1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> MetaLev -> t -> b
acoreBind1NmLevTy1 n l t = acoreBind1Asp n [acoreBoundValTy1CatLev acoreBindcategPlain n l t]
-- {-# INLINE acoreBind1NmLevTy1 #-}

acoreBind1NmTy1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> b
acoreBind1NmTy1 n t = acoreBind1NmLevTy1 n metaLevTy t
{-# INLINE acoreBind1NmTy1 #-}

acoreBind1Nm1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> b
acoreBind1Nm1 n = acoreBind1Asp n []
{-# INLINE acoreBind1Nm1 #-}







acoreBoundVal1CatLevMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> m -> t -> e -> bound
acoreBoundVal1CatLevMetaTy bcat n mlev m t e = acoreBoundVal1CatLevMetasTy bcat n mlev (acoreMetabindDflt,m) t e
{-# INLINE acoreBoundVal1CatLevMetaTy #-}

acoreBoundVal1CatLevTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> MetaLev -> t -> e -> bound
acoreBoundVal1CatLevTy cat n l t e = acoreBoundVal1CatLevMetaTy cat n l acoreMetavalDflt t e
{-# INLINE acoreBoundVal1CatLevTy #-}

acoreBoundVal1CatMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> m -> t -> e -> bound
acoreBoundVal1CatMetaTy cat n m t e = acoreBoundVal1CatLevMetaTy cat n metaLevVal m t e
{-# INLINE acoreBoundVal1CatMetaTy #-}

acoreBoundVal1CatTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> t -> e -> bound
acoreBoundVal1CatTy cat n t e = acoreBoundVal1CatLevTy cat n metaLevVal t e
{-# INLINE acoreBoundVal1CatTy #-}

acoreBoundVal1Cat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> HsName -> e -> bound
acoreBoundVal1Cat cat n e = acoreBoundVal1CatTy cat n (acoreTyErr "acoreBoundVal1Cat") e
{-# INLINE acoreBoundVal1Cat #-}



acoreBoundVal1Metas :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> (mbind,m) -> e -> bound
acoreBoundVal1Metas n m e = acoreBoundVal1CatLevMetasTy (acoreBindcategDflt e) n metaLevVal m (acoreTyErr "acoreBoundVal1Metas") e
{-# INLINE acoreBoundVal1Metas #-}

acoreBoundVal1Meta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> bound
acoreBoundVal1Meta n m e = acoreBoundVal1Metas n (acoreMetabindDflt,m) e
{-# INLINE acoreBoundVal1Meta #-}




acoreBound1AspkeyVal :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => ACoreBindAspectKeyS -> e -> bound
acoreBound1AspkeyVal a e = acoreBound1MetaVal (acoreBoundmeta a 0 CLbl_None) e
{-# INLINE acoreBound1AspkeyVal #-}

acoreBound1Val :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> bound
acoreBound1Val e = acoreBound1AspkeyVal acbaspkeyDefault e
{-# INLINE acoreBound1Val #-}













acoreTyErrLift :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a, Functor f) => String -> f x -> f (x,t)
acoreTyErrLift msg = fmap (\n -> (n,acoreTyErr msg))
{-# INLINE acoreTyErrLift #-}







-- | Construct let, possibly merging bindings
acoreLetMerge :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Bool -> bcat -> [b] -> e -> e
acoreLetMerge merge c bs e
  = if null bs
    then e
    else case acoreBindcategMbStrict c of
           {-
           Just _
             ->
           -}
           _ -> case acoreExprMbLet e of
                  Just (c',bs',e') | merge && c' == c
                    -> mk c (bs++bs') e'
                  _ -> mk c bs e
  where mk c bs e
          = case acoreBindcategMbRec c of
              Just c -> acoreLetBase c bs e
              _      -> foldr (\b e -> acoreLetBase c [b] e) e bs

acoreLet :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bcat -> [b] -> e -> e
acoreLet c bs e = acoreLetMerge False c bs e
{-# INLINE acoreLet #-}

-- | Creates a let binding, where the bindings may be mutually recursive.
acoreLetRec :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => [b]  -- ^ The bindings.
    -> e    -- ^ The body.
    -> e
acoreLetRec bs e = acoreLet (acoreBindcategRec) bs e
{-# INLINE acoreLetRec #-}



acoreLetN :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(bcat,[b])] -> e -> e
acoreLetN cbs e = foldr (\(c,bs) e -> acoreLet c bs e) e cbs



acoreLet1PlainTy :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e -> e
acoreLet1PlainTy nm t e
  = acoreLet cat [acoreBind1CatTy cat nm t e]
  where cat = acoreBindcategPlain

-- | Creates a (non-recursive) let binding.
acoreLet1Plain :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => HsName   -- ^ The identifier.
    -> e       -- ^ The expression to bind.
    -> e       -- ^ The body.
    -> e
acoreLet1Plain nm e = acoreLet1PlainTy nm (acoreTyErr "acoreLet1Plain") e
{-# INLINE acoreLet1Plain #-}



acoreLet1StrictTy :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> e -> e
acoreLet1StrictTy nm t e
  = acoreLet cat [acoreBind1CatTy cat nm t e]
  where cat = acoreBindcategStrict

-- | Creates a let binding, which is strict in the bound expression.
acoreLet1Strict :: (Eq bcat, AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => HsName   -- ^ The identifer.
    -> e        -- ^ The expression to bind. Will be evaluated to WHNF, before the body is evaluated.
    -> e        -- ^ The body.
    -> e
acoreLet1Strict nm e = acoreLet1StrictTy nm (acoreTyErr "acoreLet1Strict") e
{-# INLINE acoreLet1Strict #-}



-- | evaluate an expr, with a continuation for the evaluated expr
acoreLet1StrictInMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> HsName -> m -> t -> e -> (e -> e) -> e
acoreLet1StrictInMetaTyWith mkT mkE nm m t e mkC
  = acoreLetBase cat [acoreBind1CatMetaTy cat nm m (mkT t) (mkE e)] (mkC (acoreVar nm))
  where cat = acoreBindcategStrict

acoreMbLet1StrictInMetaTyWith :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => (t->t) -> (e->e) -> Maybe (HsName,t) -> m -> e -> (e -> e) -> e
acoreMbLet1StrictInMetaTyWith mkT mkE (Just (nm,t)) m e mkC = acoreLet1StrictInMetaTyWith mkT mkE nm m t e mkC
acoreMbLet1StrictInMetaTyWith _   _   _             m e mkC = mkC e

acoreLet1StrictInMetaTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> t -> e -> (e -> e) -> e
acoreLet1StrictInMetaTy = acoreLet1StrictInMetaTyWith acoreTyUnThunk acoreExprUnThunk
{-# INLINE acoreLet1StrictInMetaTy #-}

acoreLet1StrictInMeta :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> m -> e -> (e -> e) -> e
acoreLet1StrictInMeta nm m e mkC = acoreLet1StrictInMetaTy nm m (acoreTyErr "acoreLet1StrictInMeta") e mkC
{-# INLINE acoreLet1StrictInMeta #-}

acoreLet1StrictInTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> e -> (e -> e) -> e
acoreLet1StrictInTy nm t e mkC = acoreLet1StrictInMetaTy nm acoreMetavalDflt t e mkC
{-# INLINE acoreLet1StrictInTy #-}

acoreLet1StrictIn :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> e -> (e -> e) -> e
acoreLet1StrictIn nm e mkC = acoreLet1StrictInMeta nm acoreMetavalDflt e mkC
{-# INLINE acoreLet1StrictIn #-}







acoreNmHole :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => UID -> e
acoreNmHole = acoreVar . mkHNm

acoreNmHolePred :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => PredOccId -> e
acoreNmHolePred = acoreNmHole . poiId







-- | get default for bindcateg
acoreBindcategDflt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> bcat
acoreBindcategDflt _ = acoreBindcategPlain
{-# INLINE acoreBindcategDflt #-}







acoreChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Char -> e
acoreChar opts i = let x = acoreCharTy (acoreTyChar opts) i in x

-- | Creates an `Int` constant.
acoreInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Int -> e
acoreInt opts i = let x = acoreIntTy (acoreTyInt opts) i in x

acoreInt2 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Integer -> e
acoreInt2 opts i = let x = acoreIntTy2 (acoreTyInt opts) i in x







acoreBuiltinApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> (EHBuiltinNames -> HsName) -> [e] -> e
acoreBuiltinApp opts bnmOf args = acoreVar (ehcOptBuiltin opts bnmOf) `acoreApp` args



acoreBuiltinAddInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> Int -> e
acoreBuiltinAddInt opts e i
  = if i == 0
    then e
    else case acoreExprMbInt e of
           Just (t,i') -> acoreIntTy2 t (toInteger i + i')
           _           -> acoreBuiltinApp opts ehbnPrimAddInt [e,acoreInt opts i]



acoreBuiltinGtInt :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> Int -> e
acoreBuiltinGtInt opts e i = acoreBuiltinApp opts ehbnPrimGtInt [e,acoreInt opts i]



acoreBuiltinEqChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Char -> e -> e
acoreBuiltinEqChar opts c e = acoreBuiltinApp opts ehbnPrimEqChar [e,acoreChar opts c]



-- | Creates a string expression.
-- The expression represents a packed String, which can be passed to Haskell generated Core functions.
acoreBuiltinString :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> String   -- ^ The string.
    -> e
acoreBuiltinString opts m = let x = acoreBuiltinApp opts ehbnPackedStringToString [acoreStringTy (acoreTyString opts) m] in x



-- | Generates an error expression, failing with the given string when evaluated. ('error' in haskell)
acoreBuiltinError :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> String -- ^ The error message.
    -> e
acoreBuiltinError opts m = acoreBuiltinApp opts ehbnError [acoreBuiltinString opts m]

-- | Generates an undefined expression, failing when evaluated. ('undefined' in haskell)
acoreBuiltinUndefined :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e
acoreBuiltinUndefined opts = acoreBuiltinApp opts ehbnUndefined []



-- | Creates a Core 'Integer' constant.
acoreBuiltinInteger :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a)
    => EHCOpts
    -> Integer  -- ^ The integer.
    -> e
acoreBuiltinInteger opts i = acoreBuiltinApp opts ehbnPackedStringToInteger [acoreStringTy (acoreTyString opts) (show i)]



-- | Builtin list singleton (note: hardcoded of tags)
acoreBuiltinListSingleton :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> e -> e
acoreBuiltinListSingleton opts e
  = acoreTagTupTy (ctagCons opts) (acoreTyErr "acoreBuiltinListSingleton.Cons") [e, acoreTagTupTy (ctagNil opts) (acoreTyErr "acoreBuiltinListSingleton.Nil") []]







-- | when pat is con get tag
acorePatConMbTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => p -> Maybe CTag
acorePatConMbTag = fmap (\(tg,_,_) -> tg) . acorePatMbCon

-- | possibly get tag of alt
acoreAltMbTag :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => a -> Maybe CTag
acoreAltMbTag = (\p ->     (\(tg,_,_) -> tg) <$> acorePatMbCon  p
                       <|> (const ctagInt)   <$> acorePatMbInt  p
                       -- <|> (const ctagChar)  <$> acorePatMbChar p
                ) . fst . acoreUnAlt







-- | bound name of binding
acoreBindNm :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => b -> HsName
acoreBindNm = fst . acoreUnBind
{-# INLINE acoreBindNm #-}







-- | bound name of binding
acorePatFldTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => t -> (HsName,e) -> HsName -> pf
acorePatFldTy t lbloff n = acorePatFldBind lbloff (acoreBind1NmTy1 n t)
{-# INLINE acorePatFldTy #-}







-- | possible expr of bound (may panic)
acoreUnBoundVal :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => bound -> e
acoreUnBoundVal = maybe (panic "acoreBoundMbVal") (\(_,a) -> a) . acoreBoundMbVal
{-# INLINE acoreUnBoundVal #-}







-- | Construct 'if' expression. Hardcoded: tag nr, ordered alts (by tag)
acoreIf :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Maybe HsName -> e -> e -> e -> e
acoreIf opts cn c t f
  = acoreMbLet1StrictInMetaTyWith id id (fmap (\n -> (n,acoreTyBool opts)) cn) acoreMetavalDflt c
    $ (\c -> acoreCaseDflt c
               [ acoreAlt (acorePatCon (ctagFalse opts) acorePatRestEmpty []) f
               , acoreAlt (acorePatCon (ctagTrue  opts) acorePatRestEmpty []) t
               ]
               Nothing {-(tcUndefined opts)-}
      )



acoreMatchChar :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => EHCOpts -> Maybe HsName -> Char -> e -> e -> e -> e
acoreMatchChar opts cn cchar cexpr t f
  = acoreIf opts cn (acoreBuiltinEqChar opts cchar cexpr) t f



























data Coe' expr metaval bind bindasp ty
  = Coe_Map             !(expr -> expr)                 -- normal, expression as function
  | Coe_C               !expr                           -- constant
  | Coe_Compose         !(Coe' expr metaval bind bindasp ty)    -- composition
                        !(Coe' expr metaval bind bindasp ty)
  | Coe_App1            !expr                           -- apply
  | Coe_App             [HsName]                        -- apply n args
  | Coe_Lam             !HsName !ty                     -- lambda
  | Coe_CloseExists     !TyVarId !ty !ty                -- closing existential
  | Coe_OpenExists      !TyVarId !ty !ty                -- opening existential
  | Coe_LamLet          !HsName !ty !UID                -- lambda with a let binding in the body
  | Coe_LetRec          ![bind]                         -- let rec
  | Coe_ImplApp         !ImplsVarId                     -- implicits, for apply
  | Coe_ImplLam         !ImplsVarId                     -- implicits, for lambda

instance Show (Coe' expr metaval bind bindasp ty) where
  show _ = "COE"




















-- | Coercions may either be applied or not on type arguments.
--   In particular, due to lack of proper analysis (and generics code like generation),
--   it is only known for arrow and product types how to construct a coercion from its type args, as they directly
--   correspond to values.
--
--   A CoeCtx encodes this yes/no may allow.
--   A CoeCtx is isomorphic (for now) to Bool.
data CoeCtx
  = CoeCtx_Allow
  | CoeCtx_DontAllow
  deriving (Eq,Show)







-- | Non inspectable, most general, coercion
acoreCoeMap :: (e -> e) -> Coe' e m b ba t
acoreCoeMap = Coe_Map
{-# INLINE acoreCoeMap #-}

-- | Coe identity
acoreCoeId :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t
acoreCoeId = Coe_C acoreCoeArg
{-# INLINE acoreCoeId #-}



acoreCoeLamLetTy :: HsName -> t -> UID -> Coe' e m b ba t
acoreCoeLamLetTy = Coe_LamLet
{-# INLINE acoreCoeLamLetTy #-}

acoreCoeLamLet :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> UID -> Coe' e m b ba t
acoreCoeLamLet n u = acoreCoeLamLetTy n (acoreTyErr "acoreCoeLamLet") u
{-# INLINE acoreCoeLamLet #-}

-- | Let still requiring a body
acoreCoeLetRec :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [b] -> Coe' e m b ba t
acoreCoeLetRec [] = acoreCoeId
acoreCoeLetRec bs = Coe_LetRec bs



-- | Application still requiring a function
acoreCoeApp1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => e -> Coe' e m b ba t
acoreCoeApp1 = Coe_App1 -- a acoreMetavalDflt
{-# INLINE acoreCoeApp1 #-}

acoreCoeAppNbyName :: [(HsName)] -> Coe' e m b ba t
acoreCoeAppNbyName = Coe_App
{-# INLINE acoreCoeAppNbyName #-}

-- acoreCoeApp2 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [(e)] -> Coe' e m b ba t
-- acoreCoeApp2 as = acoreCoeMap (\e -> acoreApp e as)

acoreCoeAppN :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [e] -> Coe' e m b ba t
acoreCoeAppN as = acoreCoeMap (\e -> acoreApp e as)
{-# INLINE acoreCoeAppN #-}



-- | Lambda still requiring a body
acoreCoeLam1Ty :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> t -> Coe' e m b ba t
acoreCoeLam1Ty = Coe_Lam
{-# INLINE acoreCoeLam1Ty #-}

acoreCoeLam1 :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => HsName -> Coe' e m b ba t
acoreCoeLam1 n = acoreCoeLam1Ty n (acoreTyErr "acoreCoeLam1")
{-# INLINE acoreCoeLam1 #-}



-- | Composition of 2 Coe's
acoreCoeCompose :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Coe' e m b ba t -> Coe' e m b ba t
acoreCoeCompose c1 c2
  | acoreCoeIsId c1 = c2
  | otherwise  = Coe_Compose c1 c2




acoreCoePoiLApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => [PredOccId] -> [Coe' e m b ba t]
acoreCoePoiLApp = map (\i -> acoreCoeApp1 (acoreNmHolePred i))

acoreCoeImplsApp :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Impls -> [Coe' e m b ba t]
acoreCoeImplsApp = acoreCoePoiLApp . implsPrIdL



acoreCoePoiLLamTy :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> [(PredOccId,t)] -> [Coe' e m b ba t]
acoreCoePoiLLamTy onLast poiL
  =  case map mk poiL of
       l@(_:_)            -> h ++ [t `acoreCoeCompose` onLast]
                          where (h,t) = fromJust $ initlast l
       _ | acoreCoeIsId onLast -> []
         | otherwise      -> [onLast]
  where mk (poi,ty) = acoreCoeLam1Ty (poiHNm poi) ty

acoreCoeImplsLam :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Impls -> [Coe' e m b ba t]
acoreCoeImplsLam onLast is = acoreCoePoiLLamTy onLast (acoreTyErrLift "acoreCoeImplsLam" (implsPrIdL is))







acoreCoeIsId :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => Coe' e m b ba t -> Bool
acoreCoeIsId (Coe_C e) = acoreExprIsCoeArg e
acoreCoeIsId _         = False







data CSubstKey
  = CSKey_UID   UID
  | CSKey_Nm    HsName
  | CSKey_Ref   ACoreBindRef
  deriving (Show,Eq,Ord)



data CSubstInfo' expr metaval bind bindasp ty
  =  CSITy        { csiTy      :: !ty
                  }
  |  CSIExpr      { csiRepl    :: !expr
                  }
  |  CSIImpls     { csiAppCoeL :: ![Coe' expr metaval bind bindasp ty]
                  , csiLamCoeL :: ![Coe' expr metaval bind bindasp ty]
                  }
  |  CSIBinds     { csiBindL   :: ![bind]
                  }

instance Show (CSubstInfo' e m b ba t) where
  show _ = "CSubstInfo'"





type CSubst' e m b ba t = Map.Map CSubstKey (CSubstInfo' e m b ba t)

emptyCSubst :: CSubst' e m b ba t
emptyCSubst = Map.empty







acoreCSubstFromNmTyL :: AssocL HsName t -> CSubst' e m b ba t
acoreCSubstFromNmTyL l = Map.fromList [ (CSKey_Nm k,CSITy v) | (k,v) <- l ]



acoreCSubstFromRefExprL :: AssocL ACoreBindRef e -> CSubst' e m b ba t
acoreCSubstFromRefExprL l = Map.fromList [ (CSKey_Ref k,CSIExpr v) | (k,v) <- l ]



acoreCSubstFromUidExprL :: AssocL UID e -> CSubst' e m b ba t
acoreCSubstFromUidExprL l = Map.fromList [ (CSKey_UID k,CSIExpr v) | (k,v) <- l ]



acoreCSubstFromUidBindLL :: AssocL UID [b] -> CSubst' e m b ba t
acoreCSubstFromUidBindLL l = Map.fromList [ (CSKey_UID k,CSIBinds v) | (k,v) <- l ]

acoreCSubstFromUidImplsL :: AssocL UID ([Coe' e m b ba t],[Coe' e m b ba t]) -> CSubst' e m b ba t
acoreCSubstFromUidImplsL l = Map.fromList [ (CSKey_UID k,uncurry CSIImpls v) | (k,v) <- l ]







-- | Combine CSubst: union only, application is postponed
cSubstAppSubst :: CSubst' e m b ba t -> CSubst' e m b ba t -> CSubst' e m b ba t
cSubstAppSubst = Map.union







infixr `cSubstApp`

class CSubstitutable       e m b ba t a
                   | a  -> e m b ba t
  where
  cSubstApp :: CSubst' e m b ba t -> a -> a

instance CSubstitutable e m b ba t (CSubst' e m b ba t) where
  cSubstApp cs s = cs `cSubstAppSubst` s







data RAlt' e t b pr
  = RAlt_Alt            { rcaPats :: ![RPat' e t b pr], raaExpr :: !e, raaFailS :: UIDS }

data RPat' e t b pr
  = RPat_Var            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpMustEval :: Bool }
  | RPat_Con            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpTag :: !CTag, rcpBinds :: !(RPatConBind' e t b pr) }
  | RPat_Int            { rcpPNm :: !RPatNm, rcpTy :: !t, rcpInt :: !Integer }
  | RPat_Char           { rcpPNm :: !RPatNm, rcpTy :: !t, rcpChar :: !Char }
  | RPat_Irrefutable    { rcpPNm :: !RPatNm, rcpTy :: !t, rcpValBindL :: ![b] }
  | RPat_BoolExpr       { rcpPNm :: !RPatNm, rcpTy :: !t, rcpExpr :: !e, rcpMbConst :: Maybe SrcConst }

data RPatConBind' e t b pr
  = RPatConBind_One     { rpcbRest :: !pr, rpcbBinds :: ![RPatFld' e t b pr] }
  | RPatConBind_Many    { rpcbConBinds :: ![RPatConBind' e t b pr] }

data RPatFld' e t b pr
  = RPatFld_Fld         { rpbLbl :: !HsName, rpbOffset :: !e, rpbNm :: !HsName, rpbPat :: !(RPat' e t b pr)}

type RCEAltL' e t b pr = [RAlt' e t b pr]





rcaPat :: RAlt' e t b pr -> RPat' e t b pr
rcaPat = head . rcaPats

raltLPatNms :: [RAlt' e t b pr] -> [RPatNm]
raltLPatNms = nub . sort . map (rcpPNm . rcaPat)



rpatConTag :: RPat' e t b pr -> CTag
rpatConTag (RPat_Int  _ _ _ )  = ctagInt
rpatConTag (RPat_Char _ _ _ )  = ctagChar
rpatConTag p                   = rcpTag p

rcaTag :: RAlt' e t b pr -> CTag
rcaTag = rpatConTag . head . rcaPats



raltIsVar :: RAlt' e t b pr -> Bool
raltIsVar (RAlt_Alt (RPat_Var _ _ _ : _) _ _)  = True
raltIsVar _                                    = False

raltIsConst :: RAlt' e t b pr -> Bool
raltIsConst (RAlt_Alt (p : _) _ _)
  = c p
  where c (RPat_Int   _ _ _) = True
        c (RPat_Char  _ _ _) = True
        c _                  = False



raltIsConMany :: RAlt' e t b pr -> Bool
raltIsConMany (RAlt_Alt (RPat_Con _ _ _ (RPatConBind_Many _) : _) _ _) = True
raltIsConMany _                                                        = False



raltIsIrrefutable :: RAlt' e t b pr -> Bool
raltIsIrrefutable (RAlt_Alt (RPat_Irrefutable _ _ _ : _) _ _) = True
raltIsIrrefutable _                                           = False



raltMbBoolExpr :: RAlt' e t b pr -> Maybe (Maybe SrcConst)
raltMbBoolExpr (RAlt_Alt (RPat_BoolExpr _ _ _ e : _) _ _)  = Just e
raltMbBoolExpr _                                           = Nothing

raltIsBoolExpr :: RAlt' e t b pr -> Bool
raltIsBoolExpr = isJust . raltMbBoolExpr





rpatConBindUnFlatten :: RPatConBind' e t b pr -> [RPatConBind' e t b pr] -> RPatConBind' e t b pr
rpatConBindUnFlatten z []  = z
rpatConBindUnFlatten _ [b] = b
rpatConBindUnFlatten _ bs  = RPatConBind_Many bs







acoreRPat2Pat :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPat' e t b pr -> p
acoreRPat2Pat p
  = case p of
      RPat_Var      n ty _    -> acorePatVarTy  (rpatNmNm n) ty
      RPat_Con      n _ t b   -> acorePatCon    t r bs
                              where (r,bs) = acoreRPatConBind2PatConBind b
      RPat_Int      n ty v    -> acorePatIntTy2 ty v
      RPat_Char     n ty v    -> acorePatCharTy ty v
      RPat_BoolExpr n _  v _  -> acorePatBoolExpr  v





acoreRPatConBind2PatConBind :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPatConBind' e t b pr -> (pr,[pf])
acoreRPatConBind2PatConBind b
  = case b of
      RPatConBind_One   r bs    -> (r,map acoreRPatBind2PatFld bs)
      RPatConBind_Many  bs      -> head (map acoreRPatConBind2PatConBind bs)

acoreRPatBind2PatFld :: (AbstractCore e m b bound boundmeta bcat mbind t p pr pf a) => RPatFld' e t b pr -> pf
acoreRPatBind2PatFld (RPatFld_Fld l o _ p@(RPat_Var n _ _)) = acorePatFldTy (rcpTy p) (l,o) (rpatNmNm n)









ctagTrue, ctagFalse :: EHCOpts -> CTag
ctagTrue  opts = CTag (ehcOptBuiltin opts ehbnDataBool) (ehcOptBuiltin opts ehbnBoolTrue)  tagBoolTrue  0 0        -- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagFalse opts = CTag (ehcOptBuiltin opts ehbnDataBool) (ehcOptBuiltin opts ehbnBoolFalse) tagBoolFalse 0 0        -- this makes it hardcoded, ideally dependent on datatype def itself !!









ctagCons, ctagNil :: EHCOpts -> CTag
ctagCons opts = CTag (ehcOptBuiltin opts ehbnDataList) (ehcOptBuiltin opts ehbnDataListAltCons) tagListCons 2 2       -- this makes it hardcoded, ideally dependent on datatype def itself !!
ctagNil  opts = CTag (ehcOptBuiltin opts ehbnDataList) (ehcOptBuiltin opts ehbnDataListAltNil ) tagListNil  0 2       -- this makes it hardcoded, ideally dependent on datatype def itself !!







-- | Reason to fail a case alternative
data CaseAltFailReason
  = CaseAltFailReason_Absence                   -- failed because of absence
  | CaseAltFailReason_Continue
      { cafailCaseId        :: UID              -- failed as part of case match attempt, but continues with code identified by id
      }
  deriving (Show,Eq,Ord)

instance PP CaseAltFailReason where
  pp (CaseAltFailReason_Continue i) = pp i
  pp (CaseAltFailReason_Absence   ) = pp "absent"



cafailHasId :: CaseAltFailReason -> (Bool,UID)
cafailHasId (CaseAltFailReason_Absence   ) = (False,uidUnused)
cafailHasId (CaseAltFailReason_Continue i) = (True ,i)



deriving instance Typeable CaseAltFailReason
deriving instance Data CaseAltFailReason







data AppFunKind
  = AppFunKind_NoApp                    -- inlined Nothing
  | AppFunKind_Fun  ACoreBindRef
  | AppFunKind_Tag  CTag
  | AppFunKind_FFI








-- | What kind of Expr?
data WhatExpr
  = ExprIsLam   Int             -- arity
                (Maybe HsName)  -- possibly name bound to
  | ExprIsApp   Int             -- arity
                WhatExpr        -- function
  | ExprIsVar   HsName
  | ExprIsInt   Int
  | ExprIsTup   CTag
  | ExprIsFFI
  | ExprIsOtherWHNF
  | ExprIsOther
  | ExprIsBind  HsName
  deriving Eq



-- | is an var?
whatExprMbVar :: WhatExpr -> Maybe HsName
whatExprMbVar (ExprIsVar a) = Just a
whatExprMbVar _             = Nothing

-- | is an app?
whatExprMbApp :: WhatExpr -> Maybe (Int,WhatExpr)
whatExprMbApp (ExprIsApp a w) = Just (a,w)
whatExprMbApp _               = Nothing

-- | is a lam?
whatExprMbLam' :: WhatExpr -> Maybe (Int, Maybe HsName)
whatExprMbLam' (ExprIsLam a n) = Just (a, n)
whatExprMbLam' _               = Nothing

-- | is a lam?
whatExprMbLam :: WhatExpr -> Maybe Int
whatExprMbLam (ExprIsLam a _) = Just a
whatExprMbLam _               = Nothing

-- | is a bind?
whatExprMbBind :: WhatExpr -> Maybe HsName
whatExprMbBind (ExprIsBind n) = Just n
whatExprMbBind _              = Nothing

-- | app arity
whatExprAppArity :: WhatExpr -> Int
whatExprAppArity (ExprIsApp a _) = a
whatExprAppArity _               = 0



whatExprIsWHNF :: WhatExpr -> Bool
whatExprIsWHNF (ExprIsLam _ _)  = True
whatExprIsWHNF (ExprIsVar _)    = True
whatExprIsWHNF (ExprIsInt _)    = True
whatExprIsWHNF (ExprIsTup _)    = True
whatExprIsWHNF ExprIsOtherWHNF  = True
whatExprIsWHNF _                = False



whatExprIsBind :: WhatExpr -> Bool
whatExprIsBind = isJust . whatExprMbBind
{-# INLINE whatExprIsBind #-}

whatExprIsLam :: WhatExpr -> Bool
whatExprIsLam = isJust . whatExprMbLam
{-# INLINE whatExprIsLam #-}

-- | Is Expr a Tup?
whatExprIsTup :: WhatExpr -> Bool
whatExprIsTup (ExprIsTup _) = True
whatExprIsTup _             = False




-- | Is Expr a FFI?
whatExprIsFFI :: WhatExpr -> Bool
whatExprIsFFI (ExprIsFFI  ) = True
whatExprIsFFI _             = False














instance Serialize ACoreBindAspectKey where
  sput (ACoreBindAspectKey_Default       ) = sputWord8 0
  sput (ACoreBindAspectKey_Strict        ) = sputWord8 1
  sput (ACoreBindAspectKey_Ty            ) = sputWord8 2
  sput (ACoreBindAspectKey_RelevTy       ) = sputWord8 3
  sput (ACoreBindAspectKey_Debug         ) = sputWord8 4
  sput (ACoreBindAspectKey_Core          ) = sputWord8 5
  sput (ACoreBindAspectKey_FusionRole    ) = sputWord8 7
  sget = do
    t <- sgetWord8
    case t of
        0 -> return ACoreBindAspectKey_Default
        1 -> return ACoreBindAspectKey_Strict
        2 -> return ACoreBindAspectKey_Ty
        3 -> return ACoreBindAspectKey_RelevTy
        4 -> return ACoreBindAspectKey_Debug
        5 -> return ACoreBindAspectKey_Core
        7 -> return ACoreBindAspectKey_FusionRole













instance Serialize ACoreBindRef where
  sput (ACoreBindRef a b) = sput a >> sput b
  sget = liftM2 ACoreBindRef sget sget



instance Serialize CaseAltFailReason where
  sput (CaseAltFailReason_Continue a) = sputWord8 0 >> sput a
  sput (CaseAltFailReason_Absence   ) = sputWord8 1
  sget = do
    t <- sgetWord8
    case t of
      0 -> liftM  CaseAltFailReason_Continue sget
      1 -> return CaseAltFailReason_Absence







instance PP CSubstKey where
  pp (CSKey_UID i)  = pp i
  pp (CSKey_Nm  n)  = pp n
  pp (CSKey_Ref r)  = pp r



instance (PP expr, PP ty) => PP (CSubstInfo' expr metaval bind bindasp ty) where
  pp (CSITy         t    )  = pp t
  pp (CSIExpr       e    )  = pp e
  pp (CSIImpls      l r  )  = pp "CSIImpls" -- pp (fst $ coeWeaveOnAsSubst uidStart l r CExpr_CoeArg)
  pp (CSIBinds      b    )  = pp "CSIBinds" -- ppCBindL b


</pre>