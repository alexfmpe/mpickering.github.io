<a href="Token.hs726943819710298150.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TopLevelPhases.hs1042143836434826720.out.html">next</a></br></br><pre>10c10
< {-# LINE 38 "src/ehc/Scanner/TokenParser.chs" #-}
---
> 
10a11
> 
10a12
> 
10a13
> 
10a14
> 
10a15
> 
10a16
> 
10a17
> 
10a18
> 
10a19
> 
10a20
> 
10a21
> 
10a22
> 
10a23
> 
10a24
> 
10a25
> 
10a26
> 
10a27
> 
10a28
> 
10a29
> 
10a30
> 
10a31
> 
10a32
> 
10a33
> 
10a34
> 
10a35
> 
10a36
> 
10a37
> 
17c44
< {-# LINE 46 "src/ehc/Scanner/TokenParser.chs" #-}
---
> 
17a45
> 
120a149
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Scanner.TokenParser
where
import UU.Parsing.Interface (IsParser (..))
import UU.Parsing.Derived (pListSep,pPacked)
import UU.Scanner.Position (Pos)
import UU.Scanner.GenTokenParser
import UHC.Light.Compiler.Scanner.Token


{-# LINE 38 "src/ehc/Scanner/TokenParser.chs" #-}
pHsValToken :: IsParser p Token => EnumValToken -> String -> p (String,Pos)
pHsValToken t s = valTokenStringRes <$> pValToken t [s]

pHsCostValToken'          :: IsParser p Token => Int -> EnumValToken -> String -> p Token
pHsCostValToken' c tp val =  pCostValToken' c tp [val]

{-# LINE 46 "src/ehc/Scanner/TokenParser.chs" #-}
-------------------------------------------------------------------------
-- IsParsers for  Symbols
-------------------------------------------------------------------------

valTokenStringRes :: (ValTokenVal,Pos) -> (String,Pos)
valTokenStringRes (l,p) = (concat l,p)

pKeyPos           :: IsParser p Token => String -> p Pos
pKeyPos  keyword  =  pReserved keyword


pSpecPos          :: IsParser p Token => Char -> p Pos
pSpecPos s        =  pReserved [s]

pKey              :: IsParser p Token => String -> p String
pKey  key         =  key <$ pKeyPos key

pSpec             :: IsParser p Token => Char -> p String
pSpec c           =  [c] <$ pSpecPos c

pStringPos, pCharPos,
  pInteger8Pos, pInteger10Pos, pInteger16Pos, pFractionPos,
  pVaridPos, pConidPos, pVarsymPos, pConsymPos,
  pTextnmPos, pTextlnPos, pIntegerPos  :: IsParser p Token => p (String,Pos)

pStringPos            =   pHsValToken TkString           ""
pCharPos              =   pHsValToken TkChar             "\NUL"
pInteger8Pos          =   pHsValToken TkInteger8         "0"
pInteger10Pos         =   pHsValToken TkInteger10        "0"
pInteger16Pos         =   pHsValToken TkInteger16        "0"
pFractionPos          =   pHsValToken TkFraction         "0.0"
pVaridPos             =   pHsValToken TkVarid            "<identifier>"
pConidPos             =   pHsValToken TkConid            "<Identifier>"
pConsymPos            =   pHsValToken TkConOp          "<conoperator>"
pVarsymPos            =   pHsValToken TkOp               "<operator>"
pTextnmPos            =   pHsValToken TkTextnm           "<name>"
pTextlnPos            =   pHsValToken TkTextln           "<line>"
pIntegerPos           =   pInteger10Pos

pString, pChar,
  pInteger8, pInteger10, pInteger16, pFraction,
  pVarid, pConid, pVarsym, pConsym,
  pTextnm, pTextln, pInteger  :: IsParser p Token => p String

pString        = fst <$> pStringPos
pChar          = fst <$> pCharPos
pInteger8      = fst <$> pInteger8Pos
pInteger10     = fst <$> pInteger10Pos
pInteger16     = fst <$> pInteger16Pos
pFraction      = fst <$> pFractionPos
pVarid         = fst <$> pVaridPos
pConid         = fst <$> pConidPos
pVarsym        = fst <$> pVarsymPos
pConsym        = fst <$> pConsymPos
pTextnm        = fst <$> pTextnmPos
pTextln        = fst <$> pTextlnPos
pInteger       = fst <$> pIntegerPos

pComma, pSemi, pOParen, pCParen, pOBrack, pCBrack, pOCurly, pCCurly
   :: IsParser p Token => p String

pComma  = pSpec ','
pSemi   = pSpec ';'
pOParen = pSpec '('
pCParen = pSpec ')'
pOBrack = pSpec '['
pCBrack = pSpec ']'
pOCurly = pSpec '{'
pCCurly = pSpec '}'

pCommaPos, pSemiPos, pOParenPos, pCParenPos, pOBrackPos, pCBrackPos, pOCurlyPos, pCCurlyPos
   :: IsParser p Token => p Pos

pCommaPos  = pSpecPos ','
pSemiPos   = pSpecPos ';'
pOParenPos = pSpecPos '('
pCParenPos = pSpecPos ')'
pOBrackPos = pSpecPos '['
pCBrackPos = pSpecPos ']'
pOCurlyPos = pSpecPos '{'
pCCurlyPos = pSpecPos '}'

pCommas ::  IsParser p Token => p a -> p [a]
pSemics ::  IsParser p Token => p a -> p [a]
pParens ::  IsParser p Token => p a -> p a
pBracks ::  IsParser p Token => p a -> p a
pCurly  ::  IsParser p Token => p a -> p a

pCommas  = pListSep pComma
pSemics  = pListSep pSemi
pParens  = pPacked pOParen pCParen
pBracks  = pPacked pOBrack pCBrack
pCurly   = pPacked pOCurly pCCurly

pParens_pCommas :: IsParser p Token => p a -> p [a]
pBracks_pCommas :: IsParser p Token => p a -> p [a]
pCurly_pSemics  :: IsParser p Token => p a -> p [a]

pParens_pCommas = pParens.pCommas
pBracks_pCommas = pBracks.pCommas
pCurly_pSemics  = pCurly .pSemics


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Scanner.TokenParser
where
import UU.Parsing.Interface (IsParser (..))
import UU.Parsing.Derived (pListSep,pPacked)
import UU.Scanner.Position (Pos)
import UU.Scanner.GenTokenParser
import UHC.Light.Compiler.Scanner.Token






























pHsValToken :: IsParser p Token => EnumValToken -> String -> p (String,Pos)
pHsValToken t s = valTokenStringRes <$> pValToken t [s]

pHsCostValToken'          :: IsParser p Token => Int -> EnumValToken -> String -> p Token
pHsCostValToken' c tp val =  pCostValToken' c tp [val]



-------------------------------------------------------------------------
-- IsParsers for  Symbols
-------------------------------------------------------------------------

valTokenStringRes :: (ValTokenVal,Pos) -> (String,Pos)
valTokenStringRes (l,p) = (concat l,p)

pKeyPos           :: IsParser p Token => String -> p Pos
pKeyPos  keyword  =  pReserved keyword


pSpecPos          :: IsParser p Token => Char -> p Pos
pSpecPos s        =  pReserved [s]

pKey              :: IsParser p Token => String -> p String
pKey  key         =  key <$ pKeyPos key

pSpec             :: IsParser p Token => Char -> p String
pSpec c           =  [c] <$ pSpecPos c

pStringPos, pCharPos,
  pInteger8Pos, pInteger10Pos, pInteger16Pos, pFractionPos,
  pVaridPos, pConidPos, pVarsymPos, pConsymPos,
  pTextnmPos, pTextlnPos, pIntegerPos  :: IsParser p Token => p (String,Pos)

pStringPos            =   pHsValToken TkString           ""
pCharPos              =   pHsValToken TkChar             "\NUL"
pInteger8Pos          =   pHsValToken TkInteger8         "0"
pInteger10Pos         =   pHsValToken TkInteger10        "0"
pInteger16Pos         =   pHsValToken TkInteger16        "0"
pFractionPos          =   pHsValToken TkFraction         "0.0"
pVaridPos             =   pHsValToken TkVarid            "<identifier>"
pConidPos             =   pHsValToken TkConid            "<Identifier>"
pConsymPos            =   pHsValToken TkConOp          "<conoperator>"
pVarsymPos            =   pHsValToken TkOp               "<operator>"
pTextnmPos            =   pHsValToken TkTextnm           "<name>"
pTextlnPos            =   pHsValToken TkTextln           "<line>"
pIntegerPos           =   pInteger10Pos

pString, pChar,
  pInteger8, pInteger10, pInteger16, pFraction,
  pVarid, pConid, pVarsym, pConsym,
  pTextnm, pTextln, pInteger  :: IsParser p Token => p String

pString        = fst <$> pStringPos
pChar          = fst <$> pCharPos
pInteger8      = fst <$> pInteger8Pos
pInteger10     = fst <$> pInteger10Pos
pInteger16     = fst <$> pInteger16Pos
pFraction      = fst <$> pFractionPos
pVarid         = fst <$> pVaridPos
pConid         = fst <$> pConidPos
pVarsym        = fst <$> pVarsymPos
pConsym        = fst <$> pConsymPos
pTextnm        = fst <$> pTextnmPos
pTextln        = fst <$> pTextlnPos
pInteger       = fst <$> pIntegerPos

pComma, pSemi, pOParen, pCParen, pOBrack, pCBrack, pOCurly, pCCurly
   :: IsParser p Token => p String

pComma  = pSpec ','
pSemi   = pSpec ';'
pOParen = pSpec '('
pCParen = pSpec ')'
pOBrack = pSpec '['
pCBrack = pSpec ']'
pOCurly = pSpec '{'
pCCurly = pSpec '}'

pCommaPos, pSemiPos, pOParenPos, pCParenPos, pOBrackPos, pCBrackPos, pOCurlyPos, pCCurlyPos
   :: IsParser p Token => p Pos

pCommaPos  = pSpecPos ','
pSemiPos   = pSpecPos ';'
pOParenPos = pSpecPos '('
pCParenPos = pSpecPos ')'
pOBrackPos = pSpecPos '['
pCBrackPos = pSpecPos ']'
pOCurlyPos = pSpecPos '{'
pCCurlyPos = pSpecPos '}'

pCommas ::  IsParser p Token => p a -> p [a]
pSemics ::  IsParser p Token => p a -> p [a]
pParens ::  IsParser p Token => p a -> p a
pBracks ::  IsParser p Token => p a -> p a
pCurly  ::  IsParser p Token => p a -> p a

pCommas  = pListSep pComma
pSemics  = pListSep pSemi
pParens  = pPacked pOParen pCParen
pBracks  = pPacked pOBrack pCBrack
pCurly   = pPacked pOCurly pCCurly

pParens_pCommas :: IsParser p Token => p a -> p [a]
pBracks_pCommas :: IsParser p Token => p a -> p [a]
pCurly_pSemics  :: IsParser p Token => p a -> p [a]

pParens_pCommas = pParens.pCommas
pBracks_pCommas = pBracks.pCommas
pCurly_pSemics  = pCurly .pSemics



</pre>