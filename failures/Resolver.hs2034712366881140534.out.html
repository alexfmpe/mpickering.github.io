<a href="Resolver.hs1534827968280090412.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Resource.hs152607844784559590.out.html">next</a></br></br><pre>16c16
< data Name = Name {symbol ∷ String, reference ∷ Compiler Edge}
---
> data Name = Name {symbol :: String, reference :: Compiler Edge}
18c18
< resolve ∷ Λ → Graph NodeWW
---
> resolve :: Λ -> Graph NodeWW
20d19
<     o ← newEdge
21c20
<     i ← newNode Initiator {out = o}
---
>     o <- newEdge
21a21
>     i <- newNode Initiator {out = o}
24c24
< compile ∷ Environment → Edge → Λ → Compiler ()
---
> compile :: Environment -> Edge -> Λ -> Compiler ()
26d25
<     A func arg → do
27d25
<         f ← newEdge
28d25
<         x ← newEdge
29c26
<         _ ← newNode Applicator {inp = p, func = f, arg = x}
---
>     A func arg -> do
29a27
>         f <- newEdge
29a28
>         x <- newEdge
29a29
>         _ <- newNode Applicator {inp = p, func = f, arg = x}
32d31
<     Λ x e → do
33d31
<         b ← newEdge
34d31
<         (v, n) ← bindName x
35c32
<         _ ← newNode Abstractor {name = x, inp = p, body = b, var = v}
---
>     Λ x e -> do
35a33
>         b <- newEdge
35a34
>         (v, n) <- bindName x
35a35
>         _ <- newNode Abstractor {name = x, inp = p, body = b, var = v}
37d36
<     V var → case env of
38d36
<         [  ] → newNode Primitive {inp = p, name = var} >> return ()
39c37
<         n:ns → if var ≡ symbol n
---
>     V var -> case env of
39a38
>         [  ] -> newNode Primitive {inp = p, name = var} >> return ()
39a39
>         n:ns -> if var ≡ symbol n
42d41
<     L binds e → do
43c42
<         (es, names) ← liftM unzip $ mapM bindName (map fst binds)
---
>     L binds e -> do
43a43
>         (es, names) <- liftM unzip $ mapM bindName (map fst binds)
45c45
<         _ ← zipWithM (compile env') es (Prelude.map snd binds)
---
>         _ <- zipWithM (compile env') es (Prelude.map snd binds)
48c48
< bindName ∷ String → Compiler (Edge, Name)
---
> bindName :: String -> Compiler (Edge, Name)
50d49
<     v ← newEdge
51c50
<     s ← newNode Multiplexer {out = v, ins = []}
---
>     v <- newEdge
51a51
>     s <- newNode Multiplexer {out = v, ins = []}
53d52
<         e ← newEdge
54c53
<         modifyNode s $ \s → s {ins = e : ins s}
---
>         e <- newEdge
54a54
>         modifyNode s $ \s -> s {ins = e : ins s}
56a57
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | Term to graph transformation where variable names are resolved to graph edges (or constants)
module Resolver (resolve) where

import Prelude.Unicode
import Term
import Graph
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import Control.Monad (liftM, zipWithM)


type Compiler = Rewrite NodeWW

type Environment = [Name]
data Name = Name {symbol ∷ String, reference ∷ Compiler Edge}

resolve ∷ Λ → Graph NodeWW
resolve term = flip execGraph emptyGraph $ do
    o ← newEdge
    i ← newNode Initiator {out = o}
    compile [] o term

compile ∷ Environment → Edge → Λ → Compiler ()
compile env p term = case term of
    A func arg → do
        f ← newEdge
        x ← newEdge
        _ ← newNode Applicator {inp = p, func = f, arg = x}
        compile env f func
        compile env x arg
    Λ x e → do
        b ← newEdge
        (v, n) ← bindName x
        _ ← newNode Abstractor {name = x, inp = p, body = b, var = v}
        compile (n : env) b e
    V var → case env of
        [  ] → newNode Primitive {inp = p, name = var} >> return ()
        n:ns → if var ≡ symbol n
            then mergeEdges p =<< reference n
            else compile ns p term
    L binds e → do
        (es, names) ← liftM unzip $ mapM bindName (map fst binds)
        let env' = names ⧺ env
        _ ← zipWithM (compile env') es (Prelude.map snd binds)
        compile env' p e

bindName ∷ String → Compiler (Edge, Name)
bindName sym = do
    v ← newEdge
    s ← newNode Multiplexer {out = v, ins = []}
    let ref = do
        e ← newEdge
        modifyNode s $ \s → s {ins = e : ins s}
        return e
    return (v, Name {symbol = sym, reference = ref})
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | Term to graph transformation where variable names are resolved to graph edges (or constants)
module Resolver (resolve) where

import Prelude.Unicode
import Term
import Graph
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import Control.Monad (liftM, zipWithM)


type Compiler = Rewrite NodeWW

type Environment = [Name]
data Name = Name {symbol :: String, reference :: Compiler Edge}

resolve :: Λ -> Graph NodeWW
resolve term = flip execGraph emptyGraph $ do
    o <- newEdge
    i <- newNode Initiator {out = o}
    compile [] o term

compile :: Environment -> Edge -> Λ -> Compiler ()
compile env p term = case term of
    A func arg -> do
        f <- newEdge
        x <- newEdge
        _ <- newNode Applicator {inp = p, func = f, arg = x}
        compile env f func
        compile env x arg
    Λ x e -> do
        b <- newEdge
        (v, n) <- bindName x
        _ <- newNode Abstractor {name = x, inp = p, body = b, var = v}
        compile (n : env) b e
    V var -> case env of
        [  ] -> newNode Primitive {inp = p, name = var} >> return ()
        n:ns -> if var ≡ symbol n
            then mergeEdges p =<< reference n
            else compile ns p term
    L binds e -> do
        (es, names) <- liftM unzip $ mapM bindName (map fst binds)
        let env' = names ⧺ env
        _ <- zipWithM (compile env') es (Prelude.map snd binds)
        compile env' p e

bindName :: String -> Compiler (Edge, Name)
bindName sym = do
    v <- newEdge
    s <- newNode Multiplexer {out = v, ins = []}
    let ref = do
        e <- newEdge
        modifyNode s $ \s -> s {ins = e : ins s}
        return e
    return (v, Name {symbol = sym, reference = ref})

</pre>