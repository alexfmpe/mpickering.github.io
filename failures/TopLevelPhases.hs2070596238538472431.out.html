<a href="TokenParser.hs1677949663544733637.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Transcendental.hs1781814877303180324.out.html">next</a></br></br><pre>6d5
< where
7c6
< import qualified Data.Map as Map
---
> where{-|
7a7
> Top level combinations, stratified into 6 levels,
7a8
> where higher numbered levels use lower numbered levels.
7a9
> 
7a10
> Levels:
7a11
> 1: processing building blocks
7a12
> 2: ehc compilation phases, including progress messages, stopping when asked for
7a13
> 3: ehc grouping of compilation phases for a single module
7a14
> 4: single module compilation
7a15
> 5: full program phases
7a16
> 6: full program compilation
7a17
> 
7a18
> Naming convention for functions:
7a19
> level 1    : with prefix 'cpProcess'
7a20
> level 2..6 : with prefix 'cpEhc'
7a21
> 
7a22
> -} qualified Data.Map as Map
38d52
< {-# LINE 6 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
39d52
< {-|
40d52
< Top level combinations, stratified into 6 levels,
41d52
< where higher numbered levels use lower numbered levels.
43d53
< Levels:
44d53
< 1: processing building blocks
45d53
< 2: ehc compilation phases, including progress messages, stopping when asked for
46d53
< 3: ehc grouping of compilation phases for a single module
47d53
< 4: single module compilation
48d53
< 5: full program phases
49d53
< 6: full program compilation
51d54
< Naming convention for functions:
52d54
< level 1    : with prefix 'cpProcess'
53d54
< level 2..6 : with prefix 'cpEhc'
55d55
< -}
71c71
< {-# LINE 114 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
71a72
> 
71a73
> 
71a74
> 
71a75
> 
71a76
> 
71a77
> 
71a78
> 
71a79
> 
71a80
> 
71a81
> 
71a82
> 
71a83
> 
71a84
> 
71a85
> 
71a86
> 
71a87
> 
71a88
> 
71a89
> 
71a90
> 
71a91
> 
71a92
> 
71a93
> 
71a94
> 
71a95
> 
71a96
> 
71a97
> 
71a98
> 
71a99
> 
71a100
> 
71a101
> 
71a102
> 
71a103
> 
71a104
> 
71a105
> 
71a106
> 
71a107
> 
71a108
> 
71a109
> 
71a110
> 
71a111
> 
71a112
> 
71a113
> 
71a114
> 
71a115
> 
71a116
> 
71a117
> 
71a118
> 
71a119
> 
71a120
> 
71a121
> 
71a122
> 
71a123
> 
71a124
> 
71a125
> 
71a126
> 
71a127
> 
71a128
> 
116c173
< {-# LINE 171 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
116a174
> 
116a175
> 
116a176
> 
116a177
> 
116a178
> 
116a179
> 
116a180
> 
116a181
> 
116a182
> 
116a183
> 
116a184
> 
116a185
> 
126c195
< {-# LINE 194 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
126a196
> 
126a197
> 
126a198
> 
126a199
> 
126a200
> 
126a201
> 
126a202
> 
126a203
> 
126a204
> 
126a205
> 
126a206
> 
126a207
> 
126a208
> 
142c224
< {-# LINE 226 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
142a225
> 
142a226
> 
142a227
> 
142a228
> 
142a229
> 
142a230
> 
142a231
> 
142a232
> 
142a233
> 
142a234
> 
142a235
> 
142a236
> 
142a237
> 
142a238
> 
142a239
> 
142a240
> 
148c246
< {-# LINE 268 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
148a247
> 
148a248
> 
148a249
> 
148a250
> 
148a251
> 
148a252
> 
148a253
> 
148a254
> 
148a255
> 
148a256
> 
148a257
> 
148a258
> 
148a259
> 
148a260
> 
148a261
> 
148a262
> 
148a263
> 
148a264
> 
148a265
> 
148a266
> 
148a267
> 
148a268
> 
148a269
> 
148a270
> 
148a271
> 
148a272
> 
148a273
> 
148a274
> 
148a275
> 
148a276
> 
148a277
> 
148a278
> 
148a279
> 
148a280
> 
148a281
> 
148a282
> 
170c304
< {-# LINE 293 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
170a305
> 
170a306
> 
170a307
> 
175d311
< {-# LINE 297 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
185c321
< {-# LINE 308 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
185a322
> 
190d326
< {-# LINE 312 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
214c350
< {-# LINE 337 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
214a351
> 
219d355
< {-# LINE 341 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
237c373
< {-# LINE 360 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
237a374
> 
242d378
< {-# LINE 364 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
253c389
< {-# LINE 386 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
253a390
> 
253a391
> 
253a392
> 
253a393
> 
253a394
> 
253a395
> 
253a396
> 
253a397
> 
253a398
> 
253a399
> 
253a400
> 
256c403
< {-# LINE 390 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
256a404
> 
265c413
< {-# LINE 418 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
265a414
> 
265a415
> 
265a416
> 
265a417
> 
265a418
> 
265a419
> 
265a420
> 
265a421
> 
265a422
> 
265a423
> 
265a424
> 
265a425
> 
265a426
> 
265a427
> 
265a428
> 
265a429
> 
265a430
> 
265a431
> 
265a432
> 
320c487
< {-# LINE 489 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
320a488
> 
320a489
> 
320a490
> 
320a491
> 
320a492
> 
320a493
> 
320a494
> 
320a495
> 
320a496
> 
320a497
> 
320a498
> 
320a499
> 
320a500
> 
320a501
> 
320a502
> 
320a503
> 
413c596
< {-# LINE 618 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
413a597
> 
413a598
> 
413a599
> 
413a600
> 
413a601
> 
413a602
> 
413a603
> 
413a604
> 
413a605
> 
413a606
> 
413a607
> 
413a608
> 
413a609
> 
413a610
> 
413a611
> 
413a612
> 
413a613
> 
413a614
> 
413a615
> 
413a616
> 
413a617
> 
413a618
> 
413a619
> 
413a620
> 
413a621
> 
413a622
> 
413a623
> 
413a624
> 
413a625
> 
413a626
> 
413a627
> 
413a628
> 
413a629
> 
413a630
> 
413a631
> 
413a632
> 
418d636
< {-# LINE 622 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
426c644
< {-# LINE 639 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
426a645
> 
426a646
> 
426a647
> 
426a648
> 
426a649
> 
426a650
> 
426a651
> 
426a652
> 
426a653
> 
433c660
< {-# LINE 647 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
433a661
> 
447c675
< {-# LINE 666 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
447a676
> 
447a677
> 
447a678
> 
447a679
> 
447a680
> 
467c700
< {-# LINE 693 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
467a701
> 
467a702
> 
467a703
> 
467a704
> 
467a705
> 
467a706
> 
467a707
> 
485c725
< {-# LINE 712 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
485a726
> 
503c744
< {-# LINE 735 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
503a745
> 
503a746
> 
503a747
> 
503a748
> 
503a749
> 
509c755
< {-# LINE 752 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
509a756
> 
509a757
> 
509a758
> 
509a759
> 
509a760
> 
509a761
> 
509a762
> 
509a763
> 
509a764
> 
509a765
> 
509a766
> 
543c800
< {-# LINE 797 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
543a801
> 
543a802
> 
543a803
> 
543a804
> 
543a805
> 
543a806
> 
543a807
> 
543a808
> 
543a809
> 
543a810
> 
543a811
> 
550c818
< {-# LINE 807 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
550a819
> 
550a820
> 
550a821
> 
600c871
< {-# LINE 873 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
600a872
> 
600a873
> 
600a874
> 
600a875
> 
600a876
> 
600a877
> 
600a878
> 
600a879
> 
600a880
> 
600a881
> 
600a882
> 
600a883
> 
600a884
> 
600a885
> 
600a886
> 
600a887
> 
619c906
< {-# LINE 901 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
619a907
> 
619a908
> 
619a909
> 
619a910
> 
619a911
> 
619a912
> 
619a913
> 
619a914
> 
619a915
> 
626c922
< {-# LINE 909 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
626a923
> 
633c930
< {-# LINE 917 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
633a931
> 
643c941
< {-# LINE 933 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
643a942
> 
643a943
> 
643a944
> 
643a945
> 
643a946
> 
643a947
> 
654c958
< {-# LINE 950 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
654a959
> 
654a960
> 
654a961
> 
654a962
> 
654a963
> 
654a964
> 
665c975
< {-# LINE 967 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
665a976
> 
665a977
> 
665a978
> 
665a979
> 
665a980
> 
665a981
> 
676c992
< {-# LINE 979 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
676a993
> 
686c1003
< {-# LINE 990 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
686a1004
> 
703c1021
< {-# LINE 1022 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
703a1022
> 
703a1023
> 
703a1024
> 
703a1025
> 
703a1026
> 
703a1027
> 
703a1028
> 
703a1029
> 
703a1030
> 
703a1031
> 
703a1032
> 
703a1033
> 
703a1034
> 
703a1035
> 
703a1036
> 
719c1052
< {-# LINE 1039 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
719a1053
> 
735c1069
< {-# LINE 1056 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
735a1070
> 
747c1082
< {-# LINE 1069 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
747a1083
> 
759c1095
< {-# LINE 1082 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
759a1096
> 
770c1107
< {-# LINE 1101 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
770a1108
> 
770a1109
> 
770a1110
> 
770a1111
> 
770a1112
> 
770a1113
> 
770a1114
> 
770a1115
> 
775c1120
< {-# LINE 1132 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
775a1121
> 
775a1122
> 
775a1123
> 
775a1124
> 
775a1125
> 
775a1126
> 
775a1127
> 
775a1128
> 
775a1129
> 
775a1130
> 
775a1131
> 
775a1132
> 
775a1133
> 
775a1134
> 
775a1135
> 
775a1136
> 
775a1137
> 
775a1138
> 
775a1139
> 
775a1140
> 
775a1141
> 
775a1142
> 
775a1143
> 
775a1144
> 
775a1145
> 
775a1146
> 
785c1156
< {-# LINE 1143 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
785a1157
> 
795c1167
< {-# LINE 1169 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
795a1168
> 
795a1169
> 
795a1170
> 
795a1171
> 
795a1172
> 
795a1173
> 
795a1174
> 
795a1175
> 
795a1176
> 
795a1177
> 
795a1178
> 
795a1179
> 
795a1180
> 
795a1181
> 
795a1182
> 
795a1183
> 
804c1192
< {-# LINE 1183 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
804a1193
> 
804a1194
> 
804a1195
> 
804a1196
> 
804a1197
> 
831c1224
< {-# LINE 1245 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
831a1225
> 
831a1226
> 
831a1227
> 
831a1228
> 
831a1229
> 
831a1230
> 
831a1231
> 
831a1232
> 
831a1233
> 
831a1234
> 
831a1235
> 
831a1236
> 
831a1237
> 
831a1238
> 
831a1239
> 
831a1240
> 
831a1241
> 
831a1242
> 
831a1243
> 
831a1244
> 
831a1245
> 
831a1246
> 
831a1247
> 
831a1248
> 
831a1249
> 
831a1250
> 
831a1251
> 
831a1252
> 
831a1253
> 
831a1254
> 
831a1255
> 
831a1256
> 
831a1257
> 
831a1258
> 
831a1259
> 
846c1274
< {-# LINE 1265 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
846a1275
> 
846a1276
> 
846a1277
> 
846a1278
> 
846a1279
> 
861c1294
< {-# LINE 1287 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
861a1295
> 
861a1296
> 
861a1297
> 
861a1298
> 
861a1299
> 
861a1300
> 
861a1301
> 
869c1309
< {-# LINE 1296 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
869a1310
> 
877c1318
< {-# LINE 1305 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
877a1319
> 
896c1338
< {-# LINE 1343 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
---
> 
896a1339
> 
896a1340
> 
896a1341
> 
896a1342
> 
896a1343
> 
896a1344
> 
896a1345
> 
896a1346
> 
896a1347
> 
896a1348
> 
896a1349
> 
896a1350
> 
896a1351
> 
896a1352
> 
896a1353
> 
896a1354
> 
896a1355
> 
896a1356
> 
896a1357
> 
914a1376
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.TopLevelPhases
( cpEhcCheckAbsenceOfMutRecModules
, cpEhcFullProgCompileAllModules
, cpEhcFullProgModuleDetermineNeedsCompile
, cpEhcModuleCompile1 )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import qualified UHC.Light.Compiler.Config as Cfg
import System.IO.Unsafe
import Debug.Trace
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.CompilePhase.Parsers
import UHC.Light.Compiler.EHC.CompilePhase.Translations
import UHC.Light.Compiler.EHC.CompilePhase.Output
import UHC.Light.Compiler.EHC.CompilePhase.Transformations
import UHC.Light.Compiler.EHC.CompilePhase.Semantics
import UHC.Light.Compiler.EHC.CompilePhase.FlowBetweenPhase
import UHC.Light.Compiler.EHC.CompilePhase.CompileC
import UHC.Light.Compiler.EHC.CompilePhase.Run
import UHC.Light.Compiler.EHC.CompileGroup
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.Core as Core (cModMergeByConcat)
import qualified UHC.Light.Compiler.Core.Merge as CMerge (cModMerge)
import qualified UHC.Light.Compiler.Core.Check as Core2ChkSem
import qualified UHC.Light.Compiler.CoreRun.Check as CoreRun2ChkSem
import UHC.Light.Compiler.Base.PackageDatabase
import UHC.Light.Compiler.EHC.CompilePhase.Link
import UHC.Light.Compiler.Base.Pragma
import UHC.Light.Compiler.EHC.CompilePhase.Cleanup
{-# LINE 6 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Top level combinations, stratified into 6 levels,
where higher numbered levels use lower numbered levels.

Levels:
1: processing building blocks
2: ehc compilation phases, including progress messages, stopping when asked for
3: ehc grouping of compilation phases for a single module
4: single module compilation
5: full program phases
6: full program compilation

Naming convention for functions:
level 1    : with prefix 'cpProcess'
level 2..6 : with prefix 'cpEhc'

-}















{-# LINE 114 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | top lever driver for after all per-module work has been done, and whole program stuff like combining/linking can start
cpEhcFullProgLinkAllModules :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpEhcFullProgLinkAllModules modNmL
 = do { cr <- get
      ; let (mainModNmL,impModNmL) = crPartitionMainAndImported cr modNmL
            (_,opts) = crBaseInfo' cr   -- '
      ; when (not $ null modNmL)
             (cpMsg (head modNmL) VerboseDebug ("Main mod split: " ++ show mainModNmL ++ ": " ++ show impModNmL))
      ; case (mainModNmL, ehcOptLinkingStyle opts) of
          ([mainModNm], LinkingStyle_Exec)
                -> case () of
                     () | ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
                            -> cpSeq (  hpt
                                     ++ exec
                                     )
                        | targetDoesHPTAnalysis (ehcOptTarget opts)
                            -> cpSeq $ hpt ++ exec
                        | otherwise
                            -> cpSeq exec
                        where exec = [ cpEhcExecutablePerModule FinalCompile_Exec impModNmL mainModNm ]
                              hpt  = [ cpEhcFullProgPostModulePhases opts modNmL (impModNmL,mainModNm)
                                     , cpEhcCorePerModulePart2 mainModNm
                                     ]
          ([mainModNm], _)
                -> return ()
                   -- cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MayNotHaveMain mainModNm]
          ([], LinkingStyle_Exec)
                -> cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MustHaveMain]
          ([], LinkingStyle_None)
                -> return ()
          ([], LinkingStyle_Pkg)
                -> do let cfgwr o = liftIO $ pkgWritePkgOptionAsCfg o fp
                            where (fp,_) = mkInOrOutputFPathDirFor OutputFor_Pkg opts l l ""
                                  l = mkFPath ""
                      case ehcOptPkgOpt opts of
                        Just (pkgopt@(PkgOption {pkgoptName=pkg})) -> do
                          cfgwr pkgopt
                          case () of
                            () | targetAllowsOLinking (ehcOptTarget opts) -> do
                                   cpLinkO impModNmL pkg
                            _ -> return ()
                        _ -> return ()
      }

{-# LINE 171 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcCheckAbsenceOfMutRecModules :: EHCCompileRunner m => EHCompilePhaseT m ()
cpEhcCheckAbsenceOfMutRecModules
 = do { cr <- get
      ; let mutRecL = filter (\ml -> length ml > 1) $ crCompileOrder cr
      ; when (not $ null mutRecL)
             (cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MutRecModules mutRecL]
             )
      }

{-# LINE 194 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgCompileAllModules :: EHCCompileRunner m => EHCompilePhaseT m ()
cpEhcFullProgCompileAllModules
 = do { cr <- get
      ; let modNmLL = crCompileOrder cr
            modNmL = map head modNmLL
      ; cpSeq (   []
               ++ (let modNmL2 = filter (\m -> let (ecu,_,_,_) = crBaseInfo m cr in not $ filelocIsPkg $ ecuFileLocation ecu) modNmL
                       nrMods = length modNmL2
                   in  zipWith (\m i -> cpUpdCU m (ecuStoreSeqNr (EHCCompileSeqNr i nrMods)) ) modNmL2 [1..nrMods]
                  )
               ++ [cpEhcFullProgModuleCompileN modNmL]
               ++ [cpEhcFullProgLinkAllModules modNmL]
              )
      }

{-# LINE 226 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgPostModulePhases :: EHCCompileRunner m => EHCOpts -> [HsName] -> ([HsName],HsName) -> EHCompilePhaseT m ()
cpEhcFullProgPostModulePhases opts modNmL modSpl
  | ehcOptOptimizationScope opts >= OptimizationScope_WholeCore = cpEhcCoreFullProgPostModulePhases opts modNmL modSpl
  | otherwise                                                   = return ()

{-# LINE 268 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcCoreFullProgPostModulePhases :: EHCCompileRunner m => EHCOpts -> [HsName] -> ([HsName],HsName) -> EHCompilePhaseT m ()
cpEhcCoreFullProgPostModulePhases opts modNmL (impModNmL,mainModNm)
  = cpSeq ([ cpSeq [void $ cpGetPrevCore m | m <- modNmL]
           , mergeIntoOneBigCore
           , cpTransformCore OptimizationScope_WholeCore mainModNm
           , cpFlowHILamMp mainModNm
           , cpProcessCoreFold mainModNm -- redo folding for replaced main module
           ]
           -- ++ (if ehcOptDumpCoreStages opts then [void $ cpOutputCore CPOutputCoreHow_Text "" "full.core" mainModNm] else [])
           ++ [ cpMsg mainModNm VerboseDebug ("Full Core generated, from: " ++ show impModNmL)
              ]
          )
  where mergeIntoOneBigCore
          = do { cr <- get
               ; cpUpdCU mainModNm
                 $ ecuStoreCore
                 $ CMerge.cModMerge (mOf mainModNm cr, [ mOf m cr | m <- impModNmL ])
               ; cpCleanupCore impModNmL -- clean up Core and CoreSem (it can still be read through cr in the next statement)
               }
          where mOf m cr = panicJust "cpEhcCoreFullProgPostModulePhases.mergeIntoOneBigCore" $ ecuMbCore $ crCU m cr

{-# LINE 293 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Per module compilation of (import) ordered sequence of module, as part of a full program compilation

-}
{-# LINE 297 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgModuleCompileN :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpEhcFullProgModuleCompileN modNmL
  = cpSeq (merge (map cpEhcFullProgModuleCompile1    modNmL)
                 (map cpEhcFullProgBetweenModuleFlow modNmL)
          )
  where merge (c1:cs1) (c2:cs2) = c1 : c2 : merge cs1 cs2
        merge []       cs       = cs
        merge cs       []       = cs

{-# LINE 308 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Find out whether a compilation is needed, and if so, can be done.

-}
{-# LINE 312 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgModuleDetermineNeedsCompile :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgModuleDetermineNeedsCompile modNm
  = do { cr <- get
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             needsCompile = crModNeedsCompile modNm cr
             canCompile   = crModCanCompile modNm cr
       ; when (ehcOptVerbosity opts >= VerboseDebug)
              (liftIO $ putStrLn
                (  show modNm
                ++ ", src fpath: " ++ show (ecuSrcFilePath ecu)
                ++ ", fileloc: " ++ show (ecuFileLocation ecu)
                ++ ", needs compile: " ++ show needsCompile
                ++ ", can compile: " ++ show canCompile
                ++ ", can use HI instead of HS: " ++ show (ecuCanUseHIInsteadOfHS ecu)
                ++ ", has main: " ++ show (ecuHasMain ecu)
                ++ ", is main: " ++ show (ecuIsMainMod ecu)
                ++ ", is top: " ++ show (ecuIsTopMod ecu)
                ++ ", valid HI: " ++ show (ecuIsValidHIInfo ecu)
                ++ ", HS newer: " ++ show (ecuIsHSNewerThanHI ecu)
                ))
       ; cpUpdCU modNm (ecuSetNeedsCompile (needsCompile && canCompile))
       }

{-# LINE 337 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Compilation of 1 module, as part of a full program compilation

-}
{-# LINE 341 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgModuleCompile1 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgModuleCompile1 modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr   -- '
       ; when (ehcOptVerbosity opts >= VerboseALot)
              (liftIO $ putStrLn ("====================== Compile1: " ++ show modNm ++ "======================"))
       ; cpEhcFullProgModuleDetermineNeedsCompile modNm
       ; cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
             targ = ecuFinalDestinationState ecu -- ECUS_Haskell $ if ecuNeedsCompile ecu then HSAllSem else HIAllSem
       ; cpEhcModuleCompile1 (Just targ) modNm
       ; cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       -- ; return ()
       ; when (ecuHasMain ecu) (crSetAndCheckMain modNm)
       }

{-# LINE 360 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Flow of info between modules, as part of a full program compilation

-}
{-# LINE 364 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcFullProgBetweenModuleFlow :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgBetweenModuleFlow modNm
  = do { cr <- get
       ; case ecuState $ crCU modNm cr of
           ECUS_Haskell HSAllSem -> return ()
           ECUS_Haskell HIAllSem -> cpFlowHISem modNm
           _                     -> return ()
       ; cpCleanupFlow modNm
       }

{-# LINE 386 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcModuleCompile1 :: EHCCompileRunner m => Maybe EHCompileUnitState -> HsName -> EHCompilePhaseT m HsName
cpEhcModuleCompile1 targHSState modNm
{-# LINE 390 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
  = do { cr <- get
       ; let (ecu,_,opts,fp) = crBaseInfo modNm cr
             defaultResult = modNm
       ; when (ehcOptVerbosity opts >= VerboseALot)
              (liftIO $ putStrLn ("====================== Module: " ++ show modNm ++ " ======================"))
       ; when (ehcOptVerbosity opts >= VerboseDebug)
              (liftIO $ putStrLn ("State: in: " ++ show (ecuState ecu) ++ ", to: " ++ show targHSState))
       ; case (ecuState ecu,targHSState) of
{-# LINE 418 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
           (ECUS_Haskell st,Just (ECUS_Haskell HSOnlyImports))
             |    st == HSStart
               || st == LHSStart
             -> do { cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcHaskellImport stnext
                                                  (pkgExposedPackages $ ehcOptPkgDb opts)
                                                  modNm
                   ; cpEhcHaskellModulePrepareHS2 modNm2
                   ; cpMsg modNm2 VerboseNormal ("Imports of " ++ hsstateShowLit st ++ "Haskell")
                   ; when (ehcOptVerbosity opts >= VerboseDebug)
                          (do { cr <- get
                              ; let (ecu,_,opts,fp) = crBaseInfo modNm2 cr
                              ; liftIO $ putStrLn ("After HS import: nm=" ++ show modNm ++ ", newnm=" ++ show modNm2 ++ ", fp=" ++ show fp ++ ", imp=" ++ show (ecuImpNmS ecu))
                              })
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_Haskell stnext))
                   ; cpStopAt CompilePoint_Imports
                   ; return modNm2
                   }
             where stnext = hsstateNext st
           (ECUS_Haskell HIStart,Just (ECUS_Haskell HSOnlyImports))
             -> do { cpMsg modNm VerboseNormal ("Imports of HI")
                   ; cpEhcHaskellModulePrepareHI modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell (hsstateNext HIStart)))
                   ; when (ehcOptVerbosity opts >= VerboseDebug)
                          (do { cr <- get
                              ; let (ecu,_,opts,fp) = crBaseInfo modNm cr
                              ; liftIO $ putStrLn ("After HI import: nm=" ++ show modNm ++ ", fp=" ++ show fp ++ ", imp=" ++ show (ecuImpNmS ecu))
                              })
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HSOnlyImports))
             |    st == HSOnlyImports
               || st == HIOnlyImports
               || st == LHSOnlyImports
             -> return defaultResult
           (ECUS_Haskell st,Just (ECUS_Haskell HSAllSem))
             |    st == HSOnlyImports
               || st == LHSOnlyImports
             -> do { cpMsg modNm VerboseMinimal ("Compiling " ++ hsstateShowLit st ++ "Haskell")
                   ; cpEhcHaskellModuleAfterImport (ecuIsTopMod ecu) opts st
                                                   (pkgExposedPackages $ ehcOptPkgDb opts)
                                                   modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HSAllSem))
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HIAllSem))
             |    st == HSOnlyImports
               || st == HIOnlyImports
               || st == LHSOnlyImports
             -> do { cpMsg modNm VerboseNormal "Reading HI"
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HIAllSem))
                   ; return defaultResult
                   }

{-# LINE 489 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
           (ECUS_Haskell HSStart,_)
             -> do { cpMsg modNm VerboseMinimal "Compiling Haskell"
                   ; cpEhcHaskellModulePrepare modNm
                   ; cpEhcHaskellParse
                                       (ehcOptCPP opts) False
                                       (pkgExposedPackages $ ehcOptPkgDb opts)
                                       modNm
                   ; cpEhcHaskellModuleCommonPhases True True opts modNm
                   ; when (ehcOptWholeProgHPTAnalysis opts)
                          (cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm)
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HSAllSem))
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HMOnlyMinimal))
             |    st == HIStart || st == HSStart -- st /= HMOnlyMinimal
             -> do { let mod = emptyMod' modNm
                   ; cpUpdCU modNm (ecuStoreMod mod)
                   -- ; cpCheckModsWithBuiltin [modNm]
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HMOnlyMinimal))
                   ; return defaultResult
                   }
           (ECUS_CoreRun cst, Just (ECUS_Haskell HSOnlyImports))
             | {- cst == CRRStartText || -} isBinary
             -> do { cpMsg modNm VerboseNormal $ "Reading CoreRun (" ++ (if isBinary then "binary" else "textual") ++ ")"
                   ; cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcCoreRunImport isBinary modNm
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_CoreRun CRROnlyImports))
                   ; return modNm2
                   }
             where isBinary = cst == CRRStartBinary
           (ECUS_CoreRun CRROnlyImports,Just (ECUS_CoreRun CRRAllSem))
             -> do { cpMsg modNm VerboseMinimal "Compiling CoreRun"
                   ; cpEhcCoreRunModuleAfterImport (ecuIsTopMod ecu) opts modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_CoreRun CRRAllSem))
                   ; return defaultResult
                   }
           (ECUS_Core cst, Just (ECUS_Haskell HSOnlyImports))
             | cst == CRStartText || isBinary
             -> do { cpMsg modNm VerboseNormal $ "Reading Core (" ++ (if isBinary then "binary" else "textual") ++ ")"
                   ; cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcCoreImport isBinary modNm
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_Core CROnlyImports))
                   ; return modNm2
                   }
             where isBinary = cst == CRStartBinary
           (ECUS_Core CROnlyImports,Just (ECUS_Core CRAllSem))
             -> do { cpMsg modNm VerboseMinimal "Compiling Core"
                   ; cpEhcCoreModuleAfterImport (ecuIsTopMod ecu) opts modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Core CRAllSem))
                   ; return defaultResult
                   }
           (_,Just (ECUS_Haskell HSOnlyImports))
             -> return defaultResult
           (ECUS_Eh EHStart,_)
             -> do { cpMsg modNm VerboseMinimal "Compiling EH"
                   ; cpUpdOpts (\o -> o {ehcOptHsChecksInEH = True})
                   ; cpEhcEhParse modNm
                   ; cpGetDummyCheckSrcMod modNm
                   ; cpEhcEhModuleCommonPhases True True True opts modNm

                   ; when (ehcOptWholeProgHPTAnalysis opts)
                          (cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm)
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Eh EHAllSem))
                   ; return defaultResult
                   }
           (ECUS_C CStart,_)
             | targetIsOnUnixAndOrC (ehcOptTarget opts)
             -> do { cpSeq [ cpMsg modNm VerboseMinimal "Compiling C"
                           , cpCompileWithGCC FinalCompile_Module [] modNm
                           , cpUpdCU modNm (ecuStoreState (ECUS_C CAllSem))
                           ]
                   ; return defaultResult
                   }
             | otherwise
             -> do { cpMsg modNm VerboseMinimal "Skipping C"
                   ; return defaultResult
                   }
           (ECUS_O OStart,_)
             | targetIsOnUnixAndOrC (ehcOptTarget opts)
             -> do { cpSeq [ cpMsg modNm VerboseMinimal "Passing through .o file"
                           -- , cpCompileWithGCC FinalCompile_Module [] modNm
                           , cpUpdCU modNm (ecuStoreState (ECUS_O OAllSem))
                           ]
                   ; return defaultResult
                   }
             | otherwise
             -> do { cpMsg modNm VerboseMinimal "Skipping .o file"
                   ; return defaultResult
                   }
           _ -> return defaultResult
       }

{-# LINE 618 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
EH common phases: analysis + core + grin

-}
{-# LINE 622 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcCoreModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcCoreModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
  = cpSeq ([
             cpEhcCorePerModulePart1 modNm
           ]
          )

{-# LINE 639 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcEhModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcEhModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
  = cpSeq [ cpEhcEhAnalyseModuleDefs modNm
          , cpEhcCoreModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
          ]

{-# LINE 647 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Common phases when starting with a Haskell module.
-- HS common phases: HS analysis + EH common
cpEhcHaskellModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellModuleCommonPhases isTopMod doMkExec opts modNm
  = cpSeq [ cpEhcHaskellAnalyseModuleDefs modNm
          , do { cr <- get
               ; let (ecu,_,_,_) = crBaseInfo modNm cr
               ; cpEhcEhModuleCommonPhases
                   (ecuIsMainMod ecu)
                   isTopMod doMkExec opts modNm
               }
          ]

{-# LINE 666 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | All the work to be done after Haskell src imports have been read/analysed.
-- Post module import common phases: Parse + Module analysis + HS common
cpEhcHaskellModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts -> HSState
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellModuleAfterImport
     isTopMod opts hsst
     pkgKeyDirL
     modNm
  = cpSeq [ cpEhcHaskellParse False (hsstateIsLiteral hsst)
                              pkgKeyDirL
                              modNm
          , cpEhcHaskellAnalyseModuleItf modNm
          , cpEhcHaskellModuleCommonPhases isTopMod False opts modNm
          , cpEhcHaskellModulePostlude modNm
          ]

{-# LINE 693 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | All the work to be done after Core src/binary imports have been read/analysed
cpEhcCoreModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts
     -> HsName -> EHCompilePhaseT m ()
cpEhcCoreModuleAfterImport
     isTopMod opts
     modNm
  = do { cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       ; cpSeq
          [ cpEhcCoreAnalyseModuleItf modNm
          , cpProcessCoreModFold modNm
          , cpEhcCoreModuleCommonPhases (ecuIsMainMod ecu) isTopMod False opts modNm
          ]
       }

{-# LINE 712 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | All the work to be done after CoreRun src/binary imports have been read/analysed
cpEhcCoreRunModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts
     -> HsName -> EHCompilePhaseT m ()
cpEhcCoreRunModuleAfterImport
     isTopMod opts
     modNm
  = do { cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       ; cpSeq
          [ cpEhcCoreRunAnalyseModuleItf modNm
          , cpProcessCoreRunModFold modNm
          -- , cpEhcCoreRunModuleCommonPhases (ecuIsMainMod ecu) isTopMod False opts modNm
          ]
       }

{-# LINE 735 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
{-|
Prepare module for compilation.
This should be the first step before compilation of a module and is meant to obtain cached info from a previous compilation.

-}
{-# LINE 752 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcHaskellModulePrepareSrc :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareSrc modNm
  = cpGetMetaInfo [GetMeta_Src,GetMeta_Dir] modNm

cpEhcHaskellModulePrepareHS2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareHS2 modNm
  = cpSeq [ cpGetMetaInfo
              [ GetMeta_Src, GetMeta_HI, GetMeta_Core
              , GetMeta_CoreRun
              , GetMeta_Dir
              ] modNm
          , cpGetPrevHI modNm
          -- , cpFoldHI modNm
          , cpFoldHIInfo modNm
          ]

cpEhcHaskellModulePrepareHI :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareHI modNm
  = cpSeq [ cpGetMetaInfo
              [ GetMeta_HI, GetMeta_Core
              , GetMeta_CoreRun
              ] modNm
          , cpGetPrevHI modNm
          -- , cpFoldHI modNm
          , cpFoldHIInfo modNm
          ]

cpEhcHaskellModulePrepare :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepare modNm
  = cpSeq [ cpEhcHaskellModulePrepareSrc modNm
          , cpEhcHaskellModulePrepareHS2 modNm
          ]

{-# LINE 797 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcHaskellModulePostlude :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePostlude modNm
  = cpSeq [ cpOutputHI "hi" modNm
          , cpCleanupCU modNm
          ]

{-# LINE 807 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Get import information from Haskell module source text.
cpEhcHaskellImport
  :: EHCCompileRunner m =>
        HSState
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m HsName
cpEhcHaskellImport
     hsst
     pkgKeyDirL
     modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       -- 1st, parse
       ; cppAndParse modNm
           (ehcOptCPP opts)
       ; cpStepUID

       -- and then get pragmas and imports
       ; modNm' <- foldAndImport modNm
       ; cr2 <- get
       ; let (ecu,_,opts2,_) = crBaseInfo modNm' cr2

       -- if we find out that CPP should have invoked or cmdline options (pragma OPTIONS_UHC) have been specified,
       --  we backtrack to the original runstate and redo the above with CPP
       ; if (not (ehcOptCPP opts2)                      -- reinvoke if CPP has not been invoked before
             || ehcOptCmdLineOptsDoneViaPragma opts2    -- or options have been set via pragma
            )
            -- check whether the pragma has a cmdline option like effect
            && (not $ null $ filter pragmaInvolvesCmdLine $ Set.toList $ ecuPragmas ecu) -- Set.member Pragma_CPP (ecuPragmas ecu)
         then do { put cr
                 ; when (isJust $ ecuMbOpts ecu)
                        (cpUpdCU modNm (ecuStoreOpts opts2))
                 ; cppAndParse modNm (ehcOptCPP opts || Set.member Pragma_CPP (ecuPragmas ecu))
                 ; cpStepUID
                 ; foldAndImport modNm
                 }
         else return modNm'
       }
  where cppAndParse modNm
          doCPP
          = cpSeq [ when doCPP (cpPreprocessWithCPP pkgKeyDirL modNm)
                  , cpParseHsImport (hsstateIsLiteral hsst) modNm
                  ]
        foldAndImport modNm
          = do { cpFoldHsMod modNm
               ; cpGetHsModnameAndImports modNm
               }

{-# LINE 873 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Parse a Haskell module
cpEhcHaskellParse
  :: EHCCompileRunner m =>
         Bool -> Bool
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellParse
     doCPP litmode
     pkgKeyDirL
     modNm
  = cpSeq (
             (if doCPP then [cpPreprocessWithCPP pkgKeyDirL modNm] else [])
          ++ [ cpParseHs litmode modNm ]
          ++ [ cpMsg modNm VerboseALot "Parsing done"
             , cpStopAt CompilePoint_Parse
             ]
          )

{-# LINE 901 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcEhParse :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcEhParse modNm
  = cpSeq [ cpParseEH modNm
          , cpStopAt CompilePoint_Parse
          ]

{-# LINE 909 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpEhcCoreParse :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreParse modNm
  = cpSeq [ cpParseCoreWithFPath Nothing modNm
          , cpStopAt CompilePoint_Parse
          ]

{-# LINE 917 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a Haskell src module for
--     (1) module information (import, export, etc),
cpEhcHaskellAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellAnalyseModuleItf modNm
  = cpSeq [ cpStepUID, cpFoldHsMod modNm, cpGetHsMod modNm
          , cpCheckModsWithBuiltin [modNm]
          , cpCleanupHSMod modNm
          ]

{-# LINE 933 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a Core text/binary src module for
--     (1) module information (import, export, etc).
-- Note: TBD: identical to cpEhcCoreRunAnalyseModuleItf
cpEhcCoreAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreAnalyseModuleItf modNm
  = cpSeq [ cpMsg modNm VerboseDebug "cpEhcCoreAnalyseModuleItf"
          , cpCheckModsWithoutBuiltin [modNm]
          -- , cpCleanupHSMod modNm
          ]

{-# LINE 950 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a CoreRun text/binary src module for
--     (1) module information (import, export, etc).
-- Note: TBD: identical to cpEhcCoreAnalyseModuleItf
cpEhcCoreRunAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunAnalyseModuleItf modNm
  = cpSeq [ cpMsg modNm VerboseDebug "cpEhcCoreRunAnalyseModuleItf"
          , cpCheckModsWithoutBuiltin [modNm]
          -- , cpCleanupHSMod modNm
          ]

{-# LINE 967 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a Haskell src module for
--     (2) names + dependencies
cpEhcHaskellAnalyseModuleDefs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellAnalyseModuleDefs modNm
  = cpSeq [ cpStepUID
          , cpProcessHs modNm
          , cpMsg modNm VerboseALot "Name+dependency analysis done"
          , cpStopAt CompilePoint_AnalHS
          ]

{-# LINE 979 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a Haskell src module for
--     (3) types
cpEhcEhAnalyseModuleDefs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcEhAnalyseModuleDefs modNm
  = cpSeq [ cpStepUID, cpProcessEH modNm
          , cpMsg modNm VerboseALot "Type analysis done"
          , cpStopAt CompilePoint_AnalEH
          ]

{-# LINE 990 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Part 1 Core processing, on a per module basis, part1 is done always
cpEhcCorePerModulePart1 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCorePerModulePart1 modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
             earlyMerge = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
       ; cpSeq
           (  [ cpStepUID ]
           ++ [ cpProcessCoreBasic modNm
              , cpMsg modNm VerboseALot "Core (basic) done"
              , when (not earlyMerge) $ cpProcessCoreRest modNm
              , cpStopAt CompilePoint_Core
              ]
           )
       }

{-# LINE 1022 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Get import information from Core module source text/binary.
cpEhcCoreImport
  :: EHCCompileRunner m => Bool -> HsName -> EHCompilePhaseT m HsName
cpEhcCoreImport
     isBinary modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       ; if isBinary
         then cpDecodeCore Nothing modNm
         else cpParseCoreWithFPath Nothing modNm
       ; cpFoldCoreMod modNm
       ; cpGetCoreModnameAndImports modNm
       }

{-# LINE 1039 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Get import information from CoreRun module source text/binary.
cpEhcCoreRunImport
  :: EHCCompileRunner m => Bool -> HsName -> EHCompilePhaseT m HsName
cpEhcCoreRunImport
     isBinary modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       ; {- if isBinary
         then -} cpDecodeCoreRun Nothing modNm
         {- else cpParseCoreWithFPath Nothing modNm -}
       ; cpFoldCoreRunMod modNm
       ; cpGetCoreRunModnameAndImports modNm
       }

{-# LINE 1056 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a Core src module
cpEhcCoreAnalyseModule :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreAnalyseModule modNm
  = do { cr <- get
       ; cpUpdateModOffMp [modNm]
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             coreSem = panicJust "cpEhcCoreAnalyseModule" $ ecuMbCoreSemMod ecu
             errs = Seq.toList $ Core2ChkSem.errs_Syn_CodeAGItf coreSem
       ; cpSetLimitErrsWhen 5 "Core analysis" errs
       }

{-# LINE 1069 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Analyse a CoreRun src module
cpEhcCoreRunAnalyseModule :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunAnalyseModule modNm
  = do { cr <- get
       ; cpUpdateModOffMp [modNm]
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             corerunSem = panicJust "cpEhcCoreRunAnalyseModule" $ ecuMbCoreRunSemMod ecu
             errs = [] -- No errors -- Seq.toList $ CoreRun2ChkSem.errs_Syn_AGItf corerunSem
       ; cpSetLimitErrsWhen 5 "CoreRun analysis" errs
       }

{-# LINE 1082 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Part 2 Core processing, part2 is done either for per individual module compilation or after full program analysis
cpEhcCorePerModulePart2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCorePerModulePart2 modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
             earlyMerge = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
       ; cpSeq [ when earlyMerge $ cpProcessCoreRest modNm
               ]
       }

{-# LINE 1101 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Part 2 CoreRun processing, part2 is done either for per individual module compilation or after full program analysis
cpEhcCoreRunPerModulePart2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunPerModulePart2 = cpProcessCoreRunRest

{-# LINE 1132 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Core+grin processing, on a per module basis, may only be done when full program analysis is done
cpEhcCoreGrinPerModuleDoneFullProgAnalysis :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm
  = cpSeq (  [ cpEhcCorePerModulePart2 modNm
             , cpEhcExecutablePerModule FinalCompile_Exec [] modNm
             , cpMsg modNm VerboseALot "Full Program Analysis (Core+Grin) done"
             ]
          )

{-# LINE 1143 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | Make final executable code, either still partly or fully (i.e. also linking)
cpEhcExecutablePerModule :: EHCCompileRunner m => FinalCompileHow -> [HsName] -> HsName -> EHCompilePhaseT m ()
cpEhcExecutablePerModule how impModNmL modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq $
              [ cpCompileWithGCC how impModNmL modNm ]
       }

{-# LINE 1169 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpProcessHs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessHs modNm
  = cpSeq [ cpFoldHs modNm
          , cpFlowHsSem1 modNm
          , cpTranslateHs2EH modNm
          , cpCleanupHS modNm
          ]

{-# LINE 1183 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpProcessEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessEH modNm
  = do { cr <- get
       ; let (_,_,opts,fp) = crBaseInfo modNm cr
       {-
             optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { s <- execStateT (do { cpMsg modNm VerboseALot ("EH>: " ++ s)
                                                                                             ; x `seq` cpMsg modNm VerboseALot ("EH<: " ++ s)
                                                                                             }) cr
                                                                       ; return x
                                                                       }) }
             -- optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { putCompileMsg VerboseALot (ehcOptVerbosity opts) ("EH: " ++ s) Nothing modNm fp ; return x }) }
             -- optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { putStrLn ("EH: " ++ s) ; return x }) }
             -- optsTr = opts { ehcOptTrace = trace }
       -- ; cpUpdStateInfo (\crsi -> crsi {crsiOpts = optsTr})
       ; cpUpdCU modNm (ecuStoreOpts optsTr)
       -}
       ; cpSeq [ cpFoldEH modNm
               , cpCleanupFoldEH modNm
               , cpFlowEHSem1 modNm
               , cpTranslateEH2Output modNm
               ,
                      cpTranslateEH2Core modNm
               , cpCleanupEH modNm
               ]
       }

{-# LINE 1245 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- unprocessed core -> folded core
cpProcessCoreBasic :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreBasic modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq [ cpTransformCore OptimizationScope_PerModule modNm
               , cpFlowHILamMp modNm
               , void $ cpOutputCore    CPOutputCoreHow_Binary    [] "" Cfg.suffixDotlessBinaryCore    modNm
               , cpProcessCoreFold modNm
               , when (targetIsCoreVariation (ehcOptTarget opts)) $
                   void $ cpOutputCoreRun CPOutputCoreRunHow_Binary "" Cfg.suffixDotlessBinaryCoreRun modNm
               ]
        }

{-# LINE 1265 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- unfolded core -> folded core
-- (called on merged core, and on core directly generated from cached grin)
cpProcessCoreFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreFold modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq $ [] ++
          [ cpFlowCoreSemBeforeFold modNm ] ++
          (if targetIsViaGrin (ehcOptTarget opts) then [ cpFoldCore2Grin modNm ] else []) ++
          (if targetIsCoreVariation (ehcOptTarget opts) then [ cpFoldCore2CoreRun modNm ] else []) ++
          [ cpFlowCoreSemAfterFold modNm ] ++
          []
       }

{-# LINE 1287 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpProcessCoreModFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreModFold modNm
  = cpSeq $
      [ cpEhcCoreAnalyseModule modNm
      , cpFlowCoreModSem modNm
      ]

{-# LINE 1296 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
cpProcessCoreRunModFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRunModFold modNm
  = cpSeq $
      [ cpEhcCoreRunAnalyseModule modNm
      -- , cpFlowCoreRunModSem modNm
      ]

{-# LINE 1305 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- folded core -> grin, jazy, and the rest
cpProcessCoreRest :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRest modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq (   []
                ++ (if CoreOpt_Dump `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_Text [] "" Cfg.suffixDotlessOutputTextualCore modNm]
                    else [])
                ++ (if CoreOpt_DumpBinary `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_Binary [] "" Cfg.suffixDotlessInputOutputBinaryCore modNm]
                    else [])
                ++ [ cpProcessCoreRunRest modNm ]
                ++ [ cpCleanupCore [modNm] ]
               )
       }


{-# LINE 1343 "src/ehc/EHC/CompilePhase/TopLevelPhases.chs" #-}
-- | folded corerun -> ...
cpProcessCoreRunRest :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRunRest modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq (   []
                ++ (if CoreOpt_RunDump `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_CoreRun_Text [] "" Cfg.suffixDotlessInputOutputCoreRun modNm]
                    else [])
                ++ (if CoreOpt_Run `elem` ehcOptCoreOpts opts       -- TBD: only when right backend? For now, just do it
                    then [cpRunCoreRun  modNm]
                         -- [cpRunCoreRun2 modNm]
                         -- [cpRunCoreRun3 modNm]
                    else [])
               )
       }


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.TopLevelPhases
( cpEhcCheckAbsenceOfMutRecModules
, cpEhcFullProgCompileAllModules
, cpEhcFullProgModuleDetermineNeedsCompile
, cpEhcModuleCompile1 )
where{-|
Top level combinations, stratified into 6 levels,
where higher numbered levels use lower numbered levels.

Levels:
1: processing building blocks
2: ehc compilation phases, including progress messages, stopping when asked for
3: ehc grouping of compilation phases for a single module
4: single module compilation
5: full program phases
6: full program compilation

Naming convention for functions:
level 1    : with prefix 'cpProcess'
level 2..6 : with prefix 'cpEhc'

-} qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import qualified UHC.Light.Compiler.Config as Cfg
import System.IO.Unsafe
import Debug.Trace
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.CompilePhase.Parsers
import UHC.Light.Compiler.EHC.CompilePhase.Translations
import UHC.Light.Compiler.EHC.CompilePhase.Output
import UHC.Light.Compiler.EHC.CompilePhase.Transformations
import UHC.Light.Compiler.EHC.CompilePhase.Semantics
import UHC.Light.Compiler.EHC.CompilePhase.FlowBetweenPhase
import UHC.Light.Compiler.EHC.CompilePhase.CompileC
import UHC.Light.Compiler.EHC.CompilePhase.Run
import UHC.Light.Compiler.EHC.CompileGroup
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.Core as Core (cModMergeByConcat)
import qualified UHC.Light.Compiler.Core.Merge as CMerge (cModMerge)
import qualified UHC.Light.Compiler.Core.Check as Core2ChkSem
import qualified UHC.Light.Compiler.CoreRun.Check as CoreRun2ChkSem
import UHC.Light.Compiler.Base.PackageDatabase
import UHC.Light.Compiler.EHC.CompilePhase.Link
import UHC.Light.Compiler.Base.Pragma
import UHC.Light.Compiler.EHC.CompilePhase.Cleanup












































































-- | top lever driver for after all per-module work has been done, and whole program stuff like combining/linking can start
cpEhcFullProgLinkAllModules :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpEhcFullProgLinkAllModules modNmL
 = do { cr <- get
      ; let (mainModNmL,impModNmL) = crPartitionMainAndImported cr modNmL
            (_,opts) = crBaseInfo' cr   -- '
      ; when (not $ null modNmL)
             (cpMsg (head modNmL) VerboseDebug ("Main mod split: " ++ show mainModNmL ++ ": " ++ show impModNmL))
      ; case (mainModNmL, ehcOptLinkingStyle opts) of
          ([mainModNm], LinkingStyle_Exec)
                -> case () of
                     () | ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
                            -> cpSeq (  hpt
                                     ++ exec
                                     )
                        | targetDoesHPTAnalysis (ehcOptTarget opts)
                            -> cpSeq $ hpt ++ exec
                        | otherwise
                            -> cpSeq exec
                        where exec = [ cpEhcExecutablePerModule FinalCompile_Exec impModNmL mainModNm ]
                              hpt  = [ cpEhcFullProgPostModulePhases opts modNmL (impModNmL,mainModNm)
                                     , cpEhcCorePerModulePart2 mainModNm
                                     ]
          ([mainModNm], _)
                -> return ()
                   -- cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MayNotHaveMain mainModNm]
          ([], LinkingStyle_Exec)
                -> cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MustHaveMain]
          ([], LinkingStyle_None)
                -> return ()
          ([], LinkingStyle_Pkg)
                -> do let cfgwr o = liftIO $ pkgWritePkgOptionAsCfg o fp
                            where (fp,_) = mkInOrOutputFPathDirFor OutputFor_Pkg opts l l ""
                                  l = mkFPath ""
                      case ehcOptPkgOpt opts of
                        Just (pkgopt@(PkgOption {pkgoptName=pkg})) -> do
                          cfgwr pkgopt
                          case () of
                            () | targetAllowsOLinking (ehcOptTarget opts) -> do
                                   cpLinkO impModNmL pkg
                            _ -> return ()
                        _ -> return ()
      }














cpEhcCheckAbsenceOfMutRecModules :: EHCCompileRunner m => EHCompilePhaseT m ()
cpEhcCheckAbsenceOfMutRecModules
 = do { cr <- get
      ; let mutRecL = filter (\ml -> length ml > 1) $ crCompileOrder cr
      ; when (not $ null mutRecL)
             (cpSetLimitErrs 1 "compilation run" [rngLift emptyRange Err_MutRecModules mutRecL]
             )
      }















cpEhcFullProgCompileAllModules :: EHCCompileRunner m => EHCompilePhaseT m ()
cpEhcFullProgCompileAllModules
 = do { cr <- get
      ; let modNmLL = crCompileOrder cr
            modNmL = map head modNmLL
      ; cpSeq (   []
               ++ (let modNmL2 = filter (\m -> let (ecu,_,_,_) = crBaseInfo m cr in not $ filelocIsPkg $ ecuFileLocation ecu) modNmL
                       nrMods = length modNmL2
                   in  zipWith (\m i -> cpUpdCU m (ecuStoreSeqNr (EHCCompileSeqNr i nrMods)) ) modNmL2 [1..nrMods]
                  )
               ++ [cpEhcFullProgModuleCompileN modNmL]
               ++ [cpEhcFullProgLinkAllModules modNmL]
              )
      }


















cpEhcFullProgPostModulePhases :: EHCCompileRunner m => EHCOpts -> [HsName] -> ([HsName],HsName) -> EHCompilePhaseT m ()
cpEhcFullProgPostModulePhases opts modNmL modSpl
  | ehcOptOptimizationScope opts >= OptimizationScope_WholeCore = cpEhcCoreFullProgPostModulePhases opts modNmL modSpl
  | otherwise                                                   = return ()






































cpEhcCoreFullProgPostModulePhases :: EHCCompileRunner m => EHCOpts -> [HsName] -> ([HsName],HsName) -> EHCompilePhaseT m ()
cpEhcCoreFullProgPostModulePhases opts modNmL (impModNmL,mainModNm)
  = cpSeq ([ cpSeq [void $ cpGetPrevCore m | m <- modNmL]
           , mergeIntoOneBigCore
           , cpTransformCore OptimizationScope_WholeCore mainModNm
           , cpFlowHILamMp mainModNm
           , cpProcessCoreFold mainModNm -- redo folding for replaced main module
           ]
           -- ++ (if ehcOptDumpCoreStages opts then [void $ cpOutputCore CPOutputCoreHow_Text "" "full.core" mainModNm] else [])
           ++ [ cpMsg mainModNm VerboseDebug ("Full Core generated, from: " ++ show impModNmL)
              ]
          )
  where mergeIntoOneBigCore
          = do { cr <- get
               ; cpUpdCU mainModNm
                 $ ecuStoreCore
                 $ CMerge.cModMerge (mOf mainModNm cr, [ mOf m cr | m <- impModNmL ])
               ; cpCleanupCore impModNmL -- clean up Core and CoreSem (it can still be read through cr in the next statement)
               }
          where mOf m cr = panicJust "cpEhcCoreFullProgPostModulePhases.mergeIntoOneBigCore" $ ecuMbCore $ crCU m cr





{-|
Per module compilation of (import) ordered sequence of module, as part of a full program compilation

-}
cpEhcFullProgModuleCompileN :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpEhcFullProgModuleCompileN modNmL
  = cpSeq (merge (map cpEhcFullProgModuleCompile1    modNmL)
                 (map cpEhcFullProgBetweenModuleFlow modNmL)
          )
  where merge (c1:cs1) (c2:cs2) = c1 : c2 : merge cs1 cs2
        merge []       cs       = cs
        merge cs       []       = cs



{-|
Find out whether a compilation is needed, and if so, can be done.

-}
cpEhcFullProgModuleDetermineNeedsCompile :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgModuleDetermineNeedsCompile modNm
  = do { cr <- get
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             needsCompile = crModNeedsCompile modNm cr
             canCompile   = crModCanCompile modNm cr
       ; when (ehcOptVerbosity opts >= VerboseDebug)
              (liftIO $ putStrLn
                (  show modNm
                ++ ", src fpath: " ++ show (ecuSrcFilePath ecu)
                ++ ", fileloc: " ++ show (ecuFileLocation ecu)
                ++ ", needs compile: " ++ show needsCompile
                ++ ", can compile: " ++ show canCompile
                ++ ", can use HI instead of HS: " ++ show (ecuCanUseHIInsteadOfHS ecu)
                ++ ", has main: " ++ show (ecuHasMain ecu)
                ++ ", is main: " ++ show (ecuIsMainMod ecu)
                ++ ", is top: " ++ show (ecuIsTopMod ecu)
                ++ ", valid HI: " ++ show (ecuIsValidHIInfo ecu)
                ++ ", HS newer: " ++ show (ecuIsHSNewerThanHI ecu)
                ))
       ; cpUpdCU modNm (ecuSetNeedsCompile (needsCompile && canCompile))
       }



{-|
Compilation of 1 module, as part of a full program compilation

-}
cpEhcFullProgModuleCompile1 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgModuleCompile1 modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr   -- '
       ; when (ehcOptVerbosity opts >= VerboseALot)
              (liftIO $ putStrLn ("====================== Compile1: " ++ show modNm ++ "======================"))
       ; cpEhcFullProgModuleDetermineNeedsCompile modNm
       ; cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
             targ = ecuFinalDestinationState ecu -- ECUS_Haskell $ if ecuNeedsCompile ecu then HSAllSem else HIAllSem
       ; cpEhcModuleCompile1 (Just targ) modNm
       ; cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       -- ; return ()
       ; when (ecuHasMain ecu) (crSetAndCheckMain modNm)
       }



{-|
Flow of info between modules, as part of a full program compilation

-}
cpEhcFullProgBetweenModuleFlow :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcFullProgBetweenModuleFlow modNm
  = do { cr <- get
       ; case ecuState $ crCU modNm cr of
           ECUS_Haskell HSAllSem -> return ()
           ECUS_Haskell HIAllSem -> cpFlowHISem modNm
           _                     -> return ()
       ; cpCleanupFlow modNm
       }













cpEhcModuleCompile1 :: EHCCompileRunner m => Maybe EHCompileUnitState -> HsName -> EHCompilePhaseT m HsName
cpEhcModuleCompile1 targHSState modNm


  = do { cr <- get
       ; let (ecu,_,opts,fp) = crBaseInfo modNm cr
             defaultResult = modNm
       ; when (ehcOptVerbosity opts >= VerboseALot)
              (liftIO $ putStrLn ("====================== Module: " ++ show modNm ++ " ======================"))
       ; when (ehcOptVerbosity opts >= VerboseDebug)
              (liftIO $ putStrLn ("State: in: " ++ show (ecuState ecu) ++ ", to: " ++ show targHSState))
       ; case (ecuState ecu,targHSState) of




















           (ECUS_Haskell st,Just (ECUS_Haskell HSOnlyImports))
             |    st == HSStart
               || st == LHSStart
             -> do { cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcHaskellImport stnext
                                                  (pkgExposedPackages $ ehcOptPkgDb opts)
                                                  modNm
                   ; cpEhcHaskellModulePrepareHS2 modNm2
                   ; cpMsg modNm2 VerboseNormal ("Imports of " ++ hsstateShowLit st ++ "Haskell")
                   ; when (ehcOptVerbosity opts >= VerboseDebug)
                          (do { cr <- get
                              ; let (ecu,_,opts,fp) = crBaseInfo modNm2 cr
                              ; liftIO $ putStrLn ("After HS import: nm=" ++ show modNm ++ ", newnm=" ++ show modNm2 ++ ", fp=" ++ show fp ++ ", imp=" ++ show (ecuImpNmS ecu))
                              })
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_Haskell stnext))
                   ; cpStopAt CompilePoint_Imports
                   ; return modNm2
                   }
             where stnext = hsstateNext st
           (ECUS_Haskell HIStart,Just (ECUS_Haskell HSOnlyImports))
             -> do { cpMsg modNm VerboseNormal ("Imports of HI")
                   ; cpEhcHaskellModulePrepareHI modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell (hsstateNext HIStart)))
                   ; when (ehcOptVerbosity opts >= VerboseDebug)
                          (do { cr <- get
                              ; let (ecu,_,opts,fp) = crBaseInfo modNm cr
                              ; liftIO $ putStrLn ("After HI import: nm=" ++ show modNm ++ ", fp=" ++ show fp ++ ", imp=" ++ show (ecuImpNmS ecu))
                              })
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HSOnlyImports))
             |    st == HSOnlyImports
               || st == HIOnlyImports
               || st == LHSOnlyImports
             -> return defaultResult
           (ECUS_Haskell st,Just (ECUS_Haskell HSAllSem))
             |    st == HSOnlyImports
               || st == LHSOnlyImports
             -> do { cpMsg modNm VerboseMinimal ("Compiling " ++ hsstateShowLit st ++ "Haskell")
                   ; cpEhcHaskellModuleAfterImport (ecuIsTopMod ecu) opts st
                                                   (pkgExposedPackages $ ehcOptPkgDb opts)
                                                   modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HSAllSem))
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HIAllSem))
             |    st == HSOnlyImports
               || st == HIOnlyImports
               || st == LHSOnlyImports
             -> do { cpMsg modNm VerboseNormal "Reading HI"
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HIAllSem))
                   ; return defaultResult
                   }


















           (ECUS_Haskell HSStart,_)
             -> do { cpMsg modNm VerboseMinimal "Compiling Haskell"
                   ; cpEhcHaskellModulePrepare modNm
                   ; cpEhcHaskellParse
                                       (ehcOptCPP opts) False
                                       (pkgExposedPackages $ ehcOptPkgDb opts)
                                       modNm
                   ; cpEhcHaskellModuleCommonPhases True True opts modNm
                   ; when (ehcOptWholeProgHPTAnalysis opts)
                          (cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm)
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HSAllSem))
                   ; return defaultResult
                   }
           (ECUS_Haskell st,Just (ECUS_Haskell HMOnlyMinimal))
             |    st == HIStart || st == HSStart -- st /= HMOnlyMinimal
             -> do { let mod = emptyMod' modNm
                   ; cpUpdCU modNm (ecuStoreMod mod)
                   -- ; cpCheckModsWithBuiltin [modNm]
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Haskell HMOnlyMinimal))
                   ; return defaultResult
                   }
           (ECUS_CoreRun cst, Just (ECUS_Haskell HSOnlyImports))
             | {- cst == CRRStartText || -} isBinary
             -> do { cpMsg modNm VerboseNormal $ "Reading CoreRun (" ++ (if isBinary then "binary" else "textual") ++ ")"
                   ; cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcCoreRunImport isBinary modNm
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_CoreRun CRROnlyImports))
                   ; return modNm2
                   }
             where isBinary = cst == CRRStartBinary
           (ECUS_CoreRun CRROnlyImports,Just (ECUS_CoreRun CRRAllSem))
             -> do { cpMsg modNm VerboseMinimal "Compiling CoreRun"
                   ; cpEhcCoreRunModuleAfterImport (ecuIsTopMod ecu) opts modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_CoreRun CRRAllSem))
                   ; return defaultResult
                   }
           (ECUS_Core cst, Just (ECUS_Haskell HSOnlyImports))
             | cst == CRStartText || isBinary
             -> do { cpMsg modNm VerboseNormal $ "Reading Core (" ++ (if isBinary then "binary" else "textual") ++ ")"
                   ; cpEhcHaskellModulePrepareSrc modNm
                   ; modNm2 <- cpEhcCoreImport isBinary modNm
                   ; cpUpdCU modNm2 (ecuStoreState (ECUS_Core CROnlyImports))
                   ; return modNm2
                   }
             where isBinary = cst == CRStartBinary
           (ECUS_Core CROnlyImports,Just (ECUS_Core CRAllSem))
             -> do { cpMsg modNm VerboseMinimal "Compiling Core"
                   ; cpEhcCoreModuleAfterImport (ecuIsTopMod ecu) opts modNm
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Core CRAllSem))
                   ; return defaultResult
                   }
           (_,Just (ECUS_Haskell HSOnlyImports))
             -> return defaultResult
           (ECUS_Eh EHStart,_)
             -> do { cpMsg modNm VerboseMinimal "Compiling EH"
                   ; cpUpdOpts (\o -> o {ehcOptHsChecksInEH = True})
                   ; cpEhcEhParse modNm
                   ; cpGetDummyCheckSrcMod modNm
                   ; cpEhcEhModuleCommonPhases True True True opts modNm

                   ; when (ehcOptWholeProgHPTAnalysis opts)
                          (cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm)
                   ; cpUpdCU modNm (ecuStoreState (ECUS_Eh EHAllSem))
                   ; return defaultResult
                   }
           (ECUS_C CStart,_)
             | targetIsOnUnixAndOrC (ehcOptTarget opts)
             -> do { cpSeq [ cpMsg modNm VerboseMinimal "Compiling C"
                           , cpCompileWithGCC FinalCompile_Module [] modNm
                           , cpUpdCU modNm (ecuStoreState (ECUS_C CAllSem))
                           ]
                   ; return defaultResult
                   }
             | otherwise
             -> do { cpMsg modNm VerboseMinimal "Skipping C"
                   ; return defaultResult
                   }
           (ECUS_O OStart,_)
             | targetIsOnUnixAndOrC (ehcOptTarget opts)
             -> do { cpSeq [ cpMsg modNm VerboseMinimal "Passing through .o file"
                           -- , cpCompileWithGCC FinalCompile_Module [] modNm
                           , cpUpdCU modNm (ecuStoreState (ECUS_O OAllSem))
                           ]
                   ; return defaultResult
                   }
             | otherwise
             -> do { cpMsg modNm VerboseMinimal "Skipping .o file"
                   ; return defaultResult
                   }
           _ -> return defaultResult
       }






































{-|
EH common phases: analysis + core + grin

-}
cpEhcCoreModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcCoreModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
  = cpSeq ([
             cpEhcCorePerModulePart1 modNm
           ]
          )











cpEhcEhModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcEhModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
  = cpSeq [ cpEhcEhAnalyseModuleDefs modNm
          , cpEhcCoreModuleCommonPhases isMainMod isTopMod doMkExec opts modNm
          ]



-- | Common phases when starting with a Haskell module.
-- HS common phases: HS analysis + EH common
cpEhcHaskellModuleCommonPhases :: EHCCompileRunner m => Bool -> Bool -> EHCOpts -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellModuleCommonPhases isTopMod doMkExec opts modNm
  = cpSeq [ cpEhcHaskellAnalyseModuleDefs modNm
          , do { cr <- get
               ; let (ecu,_,_,_) = crBaseInfo modNm cr
               ; cpEhcEhModuleCommonPhases
                   (ecuIsMainMod ecu)
                   isTopMod doMkExec opts modNm
               }
          ]







-- | All the work to be done after Haskell src imports have been read/analysed.
-- Post module import common phases: Parse + Module analysis + HS common
cpEhcHaskellModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts -> HSState
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellModuleAfterImport
     isTopMod opts hsst
     pkgKeyDirL
     modNm
  = cpSeq [ cpEhcHaskellParse False (hsstateIsLiteral hsst)
                              pkgKeyDirL
                              modNm
          , cpEhcHaskellAnalyseModuleItf modNm
          , cpEhcHaskellModuleCommonPhases isTopMod False opts modNm
          , cpEhcHaskellModulePostlude modNm
          ]









-- | All the work to be done after Core src/binary imports have been read/analysed
cpEhcCoreModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts
     -> HsName -> EHCompilePhaseT m ()
cpEhcCoreModuleAfterImport
     isTopMod opts
     modNm
  = do { cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       ; cpSeq
          [ cpEhcCoreAnalyseModuleItf modNm
          , cpProcessCoreModFold modNm
          , cpEhcCoreModuleCommonPhases (ecuIsMainMod ecu) isTopMod False opts modNm
          ]
       }



-- | All the work to be done after CoreRun src/binary imports have been read/analysed
cpEhcCoreRunModuleAfterImport
  :: EHCCompileRunner m =>
        Bool -> EHCOpts
     -> HsName -> EHCompilePhaseT m ()
cpEhcCoreRunModuleAfterImport
     isTopMod opts
     modNm
  = do { cr <- get
       ; let (ecu,_,_,_) = crBaseInfo modNm cr
       ; cpSeq
          [ cpEhcCoreRunAnalyseModuleItf modNm
          , cpProcessCoreRunModFold modNm
          -- , cpEhcCoreRunModuleCommonPhases (ecuIsMainMod ecu) isTopMod False opts modNm
          ]
       }







{-|
Prepare module for compilation.
This should be the first step before compilation of a module and is meant to obtain cached info from a previous compilation.

-}












cpEhcHaskellModulePrepareSrc :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareSrc modNm
  = cpGetMetaInfo [GetMeta_Src,GetMeta_Dir] modNm

cpEhcHaskellModulePrepareHS2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareHS2 modNm
  = cpSeq [ cpGetMetaInfo
              [ GetMeta_Src, GetMeta_HI, GetMeta_Core
              , GetMeta_CoreRun
              , GetMeta_Dir
              ] modNm
          , cpGetPrevHI modNm
          -- , cpFoldHI modNm
          , cpFoldHIInfo modNm
          ]

cpEhcHaskellModulePrepareHI :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepareHI modNm
  = cpSeq [ cpGetMetaInfo
              [ GetMeta_HI, GetMeta_Core
              , GetMeta_CoreRun
              ] modNm
          , cpGetPrevHI modNm
          -- , cpFoldHI modNm
          , cpFoldHIInfo modNm
          ]

cpEhcHaskellModulePrepare :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePrepare modNm
  = cpSeq [ cpEhcHaskellModulePrepareSrc modNm
          , cpEhcHaskellModulePrepareHS2 modNm
          ]













cpEhcHaskellModulePostlude :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellModulePostlude modNm
  = cpSeq [ cpOutputHI "hi" modNm
          , cpCleanupCU modNm
          ]





-- | Get import information from Haskell module source text.
cpEhcHaskellImport
  :: EHCCompileRunner m =>
        HSState
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m HsName
cpEhcHaskellImport
     hsst
     pkgKeyDirL
     modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       -- 1st, parse
       ; cppAndParse modNm
           (ehcOptCPP opts)
       ; cpStepUID

       -- and then get pragmas and imports
       ; modNm' <- foldAndImport modNm
       ; cr2 <- get
       ; let (ecu,_,opts2,_) = crBaseInfo modNm' cr2

       -- if we find out that CPP should have invoked or cmdline options (pragma OPTIONS_UHC) have been specified,
       --  we backtrack to the original runstate and redo the above with CPP
       ; if (not (ehcOptCPP opts2)                      -- reinvoke if CPP has not been invoked before
             || ehcOptCmdLineOptsDoneViaPragma opts2    -- or options have been set via pragma
            )
            -- check whether the pragma has a cmdline option like effect
            && (not $ null $ filter pragmaInvolvesCmdLine $ Set.toList $ ecuPragmas ecu) -- Set.member Pragma_CPP (ecuPragmas ecu)
         then do { put cr
                 ; when (isJust $ ecuMbOpts ecu)
                        (cpUpdCU modNm (ecuStoreOpts opts2))
                 ; cppAndParse modNm (ehcOptCPP opts || Set.member Pragma_CPP (ecuPragmas ecu))
                 ; cpStepUID
                 ; foldAndImport modNm
                 }
         else return modNm'
       }
  where cppAndParse modNm
          doCPP
          = cpSeq [ when doCPP (cpPreprocessWithCPP pkgKeyDirL modNm)
                  , cpParseHsImport (hsstateIsLiteral hsst) modNm
                  ]
        foldAndImport modNm
          = do { cpFoldHsMod modNm
               ; cpGetHsModnameAndImports modNm
               }


















-- | Parse a Haskell module
cpEhcHaskellParse
  :: EHCCompileRunner m =>
         Bool -> Bool
     -> [PkgModulePartition]
     -> HsName -> EHCompilePhaseT m ()
cpEhcHaskellParse
     doCPP litmode
     pkgKeyDirL
     modNm
  = cpSeq (
             (if doCPP then [cpPreprocessWithCPP pkgKeyDirL modNm] else [])
          ++ [ cpParseHs litmode modNm ]
          ++ [ cpMsg modNm VerboseALot "Parsing done"
             , cpStopAt CompilePoint_Parse
             ]
          )











cpEhcEhParse :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcEhParse modNm
  = cpSeq [ cpParseEH modNm
          , cpStopAt CompilePoint_Parse
          ]



cpEhcCoreParse :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreParse modNm
  = cpSeq [ cpParseCoreWithFPath Nothing modNm
          , cpStopAt CompilePoint_Parse
          ]



-- | Analyse a Haskell src module for
--     (1) module information (import, export, etc),
cpEhcHaskellAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellAnalyseModuleItf modNm
  = cpSeq [ cpStepUID, cpFoldHsMod modNm, cpGetHsMod modNm
          , cpCheckModsWithBuiltin [modNm]
          , cpCleanupHSMod modNm
          ]








-- | Analyse a Core text/binary src module for
--     (1) module information (import, export, etc).
-- Note: TBD: identical to cpEhcCoreRunAnalyseModuleItf
cpEhcCoreAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreAnalyseModuleItf modNm
  = cpSeq [ cpMsg modNm VerboseDebug "cpEhcCoreAnalyseModuleItf"
          , cpCheckModsWithoutBuiltin [modNm]
          -- , cpCleanupHSMod modNm
          ]








-- | Analyse a CoreRun text/binary src module for
--     (1) module information (import, export, etc).
-- Note: TBD: identical to cpEhcCoreAnalyseModuleItf
cpEhcCoreRunAnalyseModuleItf :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunAnalyseModuleItf modNm
  = cpSeq [ cpMsg modNm VerboseDebug "cpEhcCoreRunAnalyseModuleItf"
          , cpCheckModsWithoutBuiltin [modNm]
          -- , cpCleanupHSMod modNm
          ]








-- | Analyse a Haskell src module for
--     (2) names + dependencies
cpEhcHaskellAnalyseModuleDefs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcHaskellAnalyseModuleDefs modNm
  = cpSeq [ cpStepUID
          , cpProcessHs modNm
          , cpMsg modNm VerboseALot "Name+dependency analysis done"
          , cpStopAt CompilePoint_AnalHS
          ]



-- | Analyse a Haskell src module for
--     (3) types
cpEhcEhAnalyseModuleDefs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcEhAnalyseModuleDefs modNm
  = cpSeq [ cpStepUID, cpProcessEH modNm
          , cpMsg modNm VerboseALot "Type analysis done"
          , cpStopAt CompilePoint_AnalEH
          ]



-- | Part 1 Core processing, on a per module basis, part1 is done always
cpEhcCorePerModulePart1 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCorePerModulePart1 modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
             earlyMerge = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
       ; cpSeq
           (  [ cpStepUID ]
           ++ [ cpProcessCoreBasic modNm
              , cpMsg modNm VerboseALot "Core (basic) done"
              , when (not earlyMerge) $ cpProcessCoreRest modNm
              , cpStopAt CompilePoint_Core
              ]
           )
       }

















-- | Get import information from Core module source text/binary.
cpEhcCoreImport
  :: EHCCompileRunner m => Bool -> HsName -> EHCompilePhaseT m HsName
cpEhcCoreImport
     isBinary modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       ; if isBinary
         then cpDecodeCore Nothing modNm
         else cpParseCoreWithFPath Nothing modNm
       ; cpFoldCoreMod modNm
       ; cpGetCoreModnameAndImports modNm
       }



-- | Get import information from CoreRun module source text/binary.
cpEhcCoreRunImport
  :: EHCCompileRunner m => Bool -> HsName -> EHCompilePhaseT m HsName
cpEhcCoreRunImport
     isBinary modNm
  = do { cr <- get
       ; let (_,opts) = crBaseInfo' cr

       ; {- if isBinary
         then -} cpDecodeCoreRun Nothing modNm
         {- else cpParseCoreWithFPath Nothing modNm -}
       ; cpFoldCoreRunMod modNm
       ; cpGetCoreRunModnameAndImports modNm
       }



-- | Analyse a Core src module
cpEhcCoreAnalyseModule :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreAnalyseModule modNm
  = do { cr <- get
       ; cpUpdateModOffMp [modNm]
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             coreSem = panicJust "cpEhcCoreAnalyseModule" $ ecuMbCoreSemMod ecu
             errs = Seq.toList $ Core2ChkSem.errs_Syn_CodeAGItf coreSem
       ; cpSetLimitErrsWhen 5 "Core analysis" errs
       }



-- | Analyse a CoreRun src module
cpEhcCoreRunAnalyseModule :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunAnalyseModule modNm
  = do { cr <- get
       ; cpUpdateModOffMp [modNm]
       ; let (ecu,_,opts,_) = crBaseInfo modNm cr
             corerunSem = panicJust "cpEhcCoreRunAnalyseModule" $ ecuMbCoreRunSemMod ecu
             errs = [] -- No errors -- Seq.toList $ CoreRun2ChkSem.errs_Syn_AGItf corerunSem
       ; cpSetLimitErrsWhen 5 "CoreRun analysis" errs
       }



-- | Part 2 Core processing, part2 is done either for per individual module compilation or after full program analysis
cpEhcCorePerModulePart2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCorePerModulePart2 modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
             earlyMerge = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore
       ; cpSeq [ when earlyMerge $ cpProcessCoreRest modNm
               ]
       }










-- | Part 2 CoreRun processing, part2 is done either for per individual module compilation or after full program analysis
cpEhcCoreRunPerModulePart2 :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreRunPerModulePart2 = cpProcessCoreRunRest




























-- | Core+grin processing, on a per module basis, may only be done when full program analysis is done
cpEhcCoreGrinPerModuleDoneFullProgAnalysis :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpEhcCoreGrinPerModuleDoneFullProgAnalysis modNm
  = cpSeq (  [ cpEhcCorePerModulePart2 modNm
             , cpEhcExecutablePerModule FinalCompile_Exec [] modNm
             , cpMsg modNm VerboseALot "Full Program Analysis (Core+Grin) done"
             ]
          )



-- | Make final executable code, either still partly or fully (i.e. also linking)
cpEhcExecutablePerModule :: EHCCompileRunner m => FinalCompileHow -> [HsName] -> HsName -> EHCompilePhaseT m ()
cpEhcExecutablePerModule how impModNmL modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq $
              [ cpCompileWithGCC how impModNmL modNm ]
       }


















cpProcessHs :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessHs modNm
  = cpSeq [ cpFoldHs modNm
          , cpFlowHsSem1 modNm
          , cpTranslateHs2EH modNm
          , cpCleanupHS modNm
          ]







cpProcessEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessEH modNm
  = do { cr <- get
       ; let (_,_,opts,fp) = crBaseInfo modNm cr
       {-
             optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { s <- execStateT (do { cpMsg modNm VerboseALot ("EH>: " ++ s)
                                                                                             ; x `seq` cpMsg modNm VerboseALot ("EH<: " ++ s)
                                                                                             }) cr
                                                                       ; return x
                                                                       }) }
             -- optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { putCompileMsg VerboseALot (ehcOptVerbosity opts) ("EH: " ++ s) Nothing modNm fp ; return x }) }
             -- optsTr = opts { ehcOptTrace = \s x -> unsafePerformIO (do { putStrLn ("EH: " ++ s) ; return x }) }
             -- optsTr = opts { ehcOptTrace = trace }
       -- ; cpUpdStateInfo (\crsi -> crsi {crsiOpts = optsTr})
       ; cpUpdCU modNm (ecuStoreOpts optsTr)
       -}
       ; cpSeq [ cpFoldEH modNm
               , cpCleanupFoldEH modNm
               , cpFlowEHSem1 modNm
               , cpTranslateEH2Output modNm
               ,
                      cpTranslateEH2Core modNm
               , cpCleanupEH modNm
               ]
       }





































-- unprocessed core -> folded core
cpProcessCoreBasic :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreBasic modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq [ cpTransformCore OptimizationScope_PerModule modNm
               , cpFlowHILamMp modNm
               , void $ cpOutputCore    CPOutputCoreHow_Binary    [] "" Cfg.suffixDotlessBinaryCore    modNm
               , cpProcessCoreFold modNm
               , when (targetIsCoreVariation (ehcOptTarget opts)) $
                   void $ cpOutputCoreRun CPOutputCoreRunHow_Binary "" Cfg.suffixDotlessBinaryCoreRun modNm
               ]
        }







-- unfolded core -> folded core
-- (called on merged core, and on core directly generated from cached grin)
cpProcessCoreFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreFold modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq $ [] ++
          [ cpFlowCoreSemBeforeFold modNm ] ++
          (if targetIsViaGrin (ehcOptTarget opts) then [ cpFoldCore2Grin modNm ] else []) ++
          (if targetIsCoreVariation (ehcOptTarget opts) then [ cpFoldCore2CoreRun modNm ] else []) ++
          [ cpFlowCoreSemAfterFold modNm ] ++
          []
       }









cpProcessCoreModFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreModFold modNm
  = cpSeq $
      [ cpEhcCoreAnalyseModule modNm
      , cpFlowCoreModSem modNm
      ]



cpProcessCoreRunModFold :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRunModFold modNm
  = cpSeq $
      [ cpEhcCoreRunAnalyseModule modNm
      -- , cpFlowCoreRunModSem modNm
      ]



-- folded core -> grin, jazy, and the rest
cpProcessCoreRest :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRest modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq (   []
                ++ (if CoreOpt_Dump `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_Text [] "" Cfg.suffixDotlessOutputTextualCore modNm]
                    else [])
                ++ (if CoreOpt_DumpBinary `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_Binary [] "" Cfg.suffixDotlessInputOutputBinaryCore modNm]
                    else [])
                ++ [ cpProcessCoreRunRest modNm ]
                ++ [ cpCleanupCore [modNm] ]
               )
       }






















-- | folded corerun -> ...
cpProcessCoreRunRest :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpProcessCoreRunRest modNm
  = do { cr <- get
       ; let (_,_,opts,_) = crBaseInfo modNm cr
       ; cpSeq (   []
                ++ (if CoreOpt_RunDump `elem` ehcOptCoreOpts opts
                    then [void $ cpOutputCore CPOutputCoreHow_CoreRun_Text [] "" Cfg.suffixDotlessInputOutputCoreRun modNm]
                    else [])
                ++ (if CoreOpt_Run `elem` ehcOptCoreOpts opts       -- TBD: only when right backend? For now, just do it
                    then [cpRunCoreRun  modNm]
                         -- [cpRunCoreRun2 modNm]
                         -- [cpRunCoreRun3 modNm]
                    else [])
               )
       }



</pre>