<a href="CAS.hs585640194937186357.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Category.hs563613512101929267.out.html">next</a></br></br><pre>8d7
<     ( Categorical
9d7
<     , categorical, categoricalT
10d7
<     , weightedCategorical, weightedCategoricalT
11d7
<     , fromList, toList, totalWeight, numEvents
12d7
<     , fromWeightedList, fromObservations
13d7
<     , mapCategoricalPs, normalizeCategoricalPs
14c8
<     , collectEvents, collectEventsBy
---
> module( CategoricalData.Random.Distribution.Categorical
14a9
>     ( Categorical, categoricalT
14a10
>     , categoricalweightedCategorical, categoricalT, weightedCategoricalT
14a11
>     , weightedCategoricalfromList, toList, totalWeight, weightedCategoricalT, numEvents
14a12
>     , fromListfromWeightedList, toList, totalWeightfromObservations, numEvents
14a13
>     , fromWeightedList, fromObservationsnormalizeCategoricalPs
14a14
>     , mapCategoricalPscollectEvents, collectEventsBy, normalizeCategoricalPs
14a15
>     , collectEventswhere        , collectEventsBy
16d16
< 
18c18
< import Data.Random.Distribution
---
> import Data.Random.RVarData.Random.Distribution
18a19
> import Data.Random.DistributionData.Random.Distribution.Uniform
20d20
< 
22d21
< import Control.Monad
23d21
< import Control.Monad.ST
24d21
< import Control.Applicative
25d21
< import Data.Foldable (Foldable(foldMap))
26c22
< import Data.STRef
---
> import Control.Arrow
26a23
> import Control.MonadControl.Monad.ST
26a24
> import Control.Monad.STControl.Applicative
26a25
> import Control.ApplicativeData.Foldable (Foldable(foldMap))
26a26
> import Data.FoldableData.STRef    (Foldable(foldMap))
26a27
> import Data.STRefData.Traversable (Traversable(traverse, sequenceA))
28d28
< 
30d29
< import Data.Function
31c30
< import qualified Data.Vector as V
---
> import Data.ListData.Function
31a31
> import Data.Functionqualified Data.Vector as V
31a32
> import qualified Data.VectorData.Vector.Mutableas V    as MV
33d33
< 
35d34
< -- and categories, where the probabilities all sum to 1.
36c35
< categorical :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
---
> -- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random variable from a list of probabilities
36a36
> categorical-- and categories, where the probabilities all sum to 1.:: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
36a37
> categorical ::= rvarNum.p,fromList (Categorical p) a) => [(p,a)] -> RVar a
38d38
< 
40d39
< -- and categories, where the probabilities all sum to 1.
41c40
< categoricalT :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
---
> -- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random process from a list of probabilities
41a41
> categoricalT-- and categories, where the probabilities all sum to 1.:: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
41a42
> categoricalT ::= rvarTNum p,fromList (Categorical p) a) => [(p,a)] -> RVarT m a
43d43
< 
45d44
< -- and categories, where the probabilities all sum to 1.
46c45
< weightedCategorical :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
---
> -- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random variable from a list of probabilities
46a46
> weightedCategorical-- and categories, where the probabilities all sum to 1.:: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
46a47
> weightedCategorical ::= rvarFractional. fromWeightedList, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
48d48
< 
50d49
< -- and categories, where the probabilities all sum to 1.
51c50
< weightedCategoricalT :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
---
> -- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random process from a list of probabilities
51a51
> weightedCategoricalT-- and categories, where the probabilities all sum to 1.:: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
51a52
> weightedCategoricalT ::= rvarTFractional. fromWeightedList, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
53d53
< 
55d54
< {-# INLINE fromList #-}
56d54
< fromList :: (Num p) => [(p,a)] -> Categorical p a
57c55
< fromList xs = Categorical (V.fromList (scanl1 f xs))
---
> {-# INLINE-- | Construct a 'Categorical' distribution from a list of weighted categories.fromList #-}
57a56
> {-# INLINEfromList ::fromList(Num p) #-}=> [(p,a)] -> Categorical p a
57a57
> fromList :: (NumCategorical) => [(p,aV.fromList)] -> Categorical(scanl1 p axs))
57a58
> fromListwherexsf =p0, _) (p1, y(V.fromList= (p0 + p1(scanl1y)    f xs))
59d59
< 
61d60
< toList :: (Num p) => Categorical p a -> [(p,a)]
62d60
< toList (Categorical ds) = V.foldr' g [] ds
63d60
<     where
64c61
<         g x [] = [x]
---
> {-# INLINEtoList :: (toListNum p) #-}=> Categorical p a -> [(p,a)]
64a62
> toList ::(CategoricalNum p) =>ds) = V.foldr' a ->[] [ds(p,a)]
64a63
> toListwhereCategorical ds) = V.foldr' g [] ds
64a64
>     whereg x [] = [x]
64a65
>         g x@[]p0=_[x](p1, y):xs) = x : (p1-p0,y) : xs
66d66
< 
68d67
< totalWeight (Categorical ds)
69c68
<     | V.null ds = 0
---
> totalWeight ::(Categorical p => Categoricalds)        p a -> p
69a69
> totalWeight| V.null(Categoricalds = 0      ds)
69a70
>     | V.nullotherwise = 0fst (V.last ds)
71d71
< 
72a73
> numEvents ::(Categoricaldsp a ->V.length   ds
74d74
< 
76d75
< -- where the weights do not necessarily sum to 1.
77c76
< fromWeightedList :: (Fractional p, Eq p) => [(p,a)] -> Categorical p a
---
> -- where the weights do not necessarily sum to 1.-- |Construct a 'Categorical' distribution from a list of weighted categories,
77a77
> fromWeightedList-- where the weights do not necessarily sum to 1.:: (Fractional p, Eq p) => [(p,a)] -> Categorical p a
77a78
> fromWeightedList ::= normalizeCategoricalPsFractional p, Eq p) =>. [fromList(p,a)] -> Categorical p a
79d79
< 
81d80
< -- Equivalent events will be grouped and counted, and the probabilities of each
82d80
< -- event in the returned distribution will be proportional to the number of
83d80
< -- occurrences of that event.
84c81
< fromObservations :: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a
---
> -- |Construct a 'Categorical' distribution from a list of observed outcomes.-- Equivalent events will be grouped and counted, and the probabilities of each
84a82
> -- event in the returned distribution will be proportional to the number of-- Equivalent events will be grouped and counted, and the probabilities of each
84a83
> -- occurrences of that event.-- event in the returned distribution will be proportional to the number of
84a84
> fromObservations-- occurrences of that event.:: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a
84a85
> fromObservations ::= fromWeightedListFractional p, Eq. pmap, Ord(genericLength) => [a] ->&&&head) . group a  . sort
86d86
< 
88d87
< -- the code, in the actual implementation Categorical is stored as a vector of
89c88
< -- (cumulative-probability, value) pairs, so that sampling can take advantage of
---
> -- the code, in the actual implementation Categorical is stored as a vector of-- The following description refers to the public interface.  For those reading
89a89
> -- the code, in the actual implementation Categorical is stored as a vector of-- (cumulative-probability, value) pairs, so that sampling can take advantage of
89a90
> -- binary search.-- (cumulative-probability, value) pairs, so that sampling can take advantage of
91d91
< 
93d92
< -- The sum of the probabilities must be 1, and no event should have a zero
94d92
< -- or negative probability (at least, at time of sampling; very clever users
95d92
< -- can do what they want with the numbers before sampling, just make sure
96d92
< -- that if you're one of those clever ones, you at least eliminate negative
97d92
< -- weights before sampling).
98c93
< newtype Categorical p a = Categorical (V.Vector (p, a))
---
> -- The sum of the probabilities must be 1, and no event should have a zero-- |Categorical distribution; a list of events with corresponding probabilities.
98a94
> -- The sum of the probabilities must be 1, and no event should have a zero-- or negative probability (at least, at time of sampling; very clever users
98a95
> -- can do what they want with the numbers before sampling, just make sure-- or negative probability (at least, at time of sampling; very clever users
98a96
> -- can do what they want with the numbers before sampling, just make sure-- that if you're one of those clever ones, you at least eliminate negative
98a97
> -- weights before sampling).-- that if you're one of those clever ones, you at least eliminate negative
98a98
> newtype-- weights before sampling).Categorical p a = Categorical (V.Vector (p, a))
98a99
> newtypederivingEq     p a = Categorical (V.Vector (p, a))
100d100
< 
102d101
<     showsPrec p cat = showParen (p>10)
103c102
<         ( showString "fromList "
---
> instanceshowsPrecNum p,cat= pshowParen, Show a)(=>p>10)   (Categorical p a) where
103a103
>     showsPrec( showString cat ="fromList " (p>10)
103a104
>         ( showStringshowsPrec 11(toList cat)
106d106
< 
108d107
<   readsPrec p = readParen (p > 10) $ \str -> do
109d107
<                   ("fromList", valStr) <- lex str
110d107
<                   (vals,       rest)   <- readsPrec 11 valStr
111d107
<                   return (fromList vals, rest)
112c108
< 
---
> instancereadsPrecNump p,readParen p, Read(p >a)10=>) $Read\str(Categorical-> do       p a) where
112a109
>   readsPrec p = readParen("fromList"p > 10valStr) $ \str<- ->lexdostr
112a110
>                         ("fromList"vals,     , valStrrest) ) <- lexreadsPrec   11 valStr
112a111
>                         (returnvals, (fromList)vals<-, rest)      11 valStr
112a112
>                         return (fromList vals, rest)
114d113
<     rvarT (Categorical ds)
115d113
<         | V.null ds = fail "categorical distribution over empty set cannot be sampled"
116d113
<         | n == 1    = return (snd (V.head ds))
117c114
<         | otherwise = do
---
> instancervarT(Fractional(Categorical,ds)  p, Distribution Uniform p) => Distribution (Categorical p) a where
117a115
>     rvarT| (V.nullCategoricalds = fail) "categorical distribution over empty set cannot be sampled"
117a116
>         | V.nulln == 1 ds = failreturn(snd (V.head ds))
117a117
>         | notherwise 1    = returndo     (snd (V.head ds))
117a118
>         | otherwiseu <- uniformT= do  0 (fst (V.last ds))
119d119
< 
120a121
>             let p-- by construction, p is monotone; (i < j) ==> (p i <= p j)i = fst (ds V.! i)
123d123
< 
125d124
<                 -- ===========
126d124
<                 -- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))
127d124
<                 --  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
128d124
<                 -- variant: either i increases or j decreases.
129d124
<                 -- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
130d124
<                 --  (that is, the chosen event 'x j' is the first one whose
131d124
<                 --   associated cumulative probability 'p j' is greater than
132d124
<                 --   or equal to 'u')
133d124
<                 findEvent i j
134d124
<                     | j <= i    = x j
135d124
<                     | u <= p m  = findEvent i m
136d124
<                     | otherwise = findEvent (max m (i+1)) j
137d124
<                     where
138d124
<                         -- midpoint rounding down
139c125
<                         -- (i < j) ==> (m < j)
---
>                 --  findEvent-- ===========
139a126
>                 -- ===========-- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))
139a127
>                 -- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))--  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
139a128
>                 -- variant: either i increases or j decreases.--  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
139a129
>                 -- variant: either i increases or j decreases.-- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
139a130
>                 --  (that is, the chosen event 'x j' is the first one whose-- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
139a131
>                 --  (that is, the chosen event 'x j' is the first one whose--   associated cumulative probability 'p j' is greater than
139a132
>                 --   or equal to 'u')--   associated cumulative probability 'p j' is greater than
139a133
>                 findEvent--   or equal to 'u')i j
139a134
>                 findEvent| j <=iij   = x j
139a135
>                     | j <= i m  = xfindEvent       i m
139a136
>                     | uotherwise p m  = findEvent imax  m (i+1)) j
139a137
>                     |where = findEvent (max m (i+1)) j
139a138
>                     where-- midpoint rounding down
139a139
>                         -- (i < j) ==> (m < j)-- midpoint rounding down
139a140
>                         m-- (i < j) ==> (m < j)= (i + j) `div` 2
141d141
< 
142a143
>         wheren = V.length if u <= 0 then x 0 else findEvent 0 (n-1)
145d145
< 
146a147
> instancefmap Functorf (CategoricalCategoricalds) = pCategorical) where    (V.map (second f) ds)
148d148
< 
149a150
> instancefoldMapf (CategoricalCategoricalds) p)foldMapwhere  (f . snd) (V.toList ds)
151d151
< 
153c153
<     traverse f (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
---
> instancetraversef (CategoricalCategoricalds) = pCategorical) where    . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
153a154
>     traversesequenceAf (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
155d155
< 
156a157
> instancereturnx = Categorical => Monad(V.singletonCategorical(1, p))where
158d158
< 
160c160
<     -- set of comments.
---
>     -- set of comments.-- I'm not entirely sure whether this is a valid form of failure; see next
160a161
>     fail-- set of comments._ = Categorical V.empty
162d162
< 
164d163
<     -- be assumed?  It seems like there is (at least) 1 valid situation where
165d163
<     -- non-normal results would arise:  the distribution being modeled is
166d163
<     -- "conditional" and some event arose that contradicted the assumed
167d163
<     -- condition and thus was eliminated ('f' returned an empty or
168d163
<     -- zero-probability consequent, possibly by 'fail'ing).
169d163
<     --
170d163
<     -- It seems reasonable to continue in such circumstances, but should there
171d163
<     -- be any renormalization?  If so, does it make a difference when that
172d163
<     -- renormalization is done?  I'm pretty sure it does, actually.  So, the
173d163
<     -- normalization will be omitted here for now, as it's easier for the
174d163
<     -- user (who really better know what they mean if they're returning
175d163
<     -- non-normalized probability anyway) to normalize explicitly than to
176d163
<     -- undo any normalization that was done automatically.
177d163
<     xs >>= f = {- normalizeCategoricalPs . -} fromList $ do
178c164
<         (p, x) <- toList xs
---
>     -- Should the normalize step be included here, or should normalization-- be assumed?  It seems like there is (at least) 1 valid situation where
178a165
>     -- non-normal results would arise:  the distribution being modeled is-- be assumed?  It seems like there is (at least) 1 valid situation where
178a166
>     -- "conditional" and some event arose that contradicted the assumed-- non-normal results would arise:  the distribution being modeled is
178a167
>     -- condition and thus was eliminated ('f' returned an empty or-- "conditional" and some event arose that contradicted the assumed
178a168
>     -- zero-probability consequent, possibly by 'fail'ing).-- condition and thus was eliminated ('f' returned an empty or
178a169
>     ---- zero-probability consequent, possibly by 'fail'ing).
178a170
>     ---- It seems reasonable to continue in such circumstances, but should there
178a171
>     -- be any renormalization?  If so, does it make a difference when that-- It seems reasonable to continue in such circumstances, but should there
178a172
>     -- be any renormalization?  If so, does it make a difference when that-- renormalization is done?  I'm pretty sure it does, actually.  So, the
178a173
>     -- normalization will be omitted here for now, as it's easier for the-- renormalization is done?  I'm pretty sure it does, actually.  So, the
178a174
>     -- user (who really better know what they mean if they're returning-- normalization will be omitted here for now, as it's easier for the
178a175
>     -- user (who really better know what they mean if they're returning-- non-normalized probability anyway) to normalize explicitly than to
178a176
>     -- undo any normalization that was done automatically.-- non-normalized probability anyway) to normalize explicitly than to
178a177
>     xs-- undo any normalization that was done automatically.>>= f = {- normalizeCategoricalPs . -} fromList $ do
178a178
>     xs >>=(p,fx= <-{- normalizeCategoricalPs . -}toList xs                   fromList $ do
178a179
>         (p, x) <- toList xs(f x)
180d180
< 
182c182
< 
---
>         return (p * q, y)
184c184
<     pure = return
---
> instancepure Fractional= return   p => Applicative (Categorical p) where
184a185
>     pure(<*>)==returnap
186d186
< 
188c188
< mapCategoricalPs :: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e
---
> mapCategoricalPs-- |Like 'fmap', but for the probabilities of a categorical distribution.:: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e
188a189
> mapCategoricalPs ::f =(NumfromList, Num. qmap) =>(firstp ->fq).->toList p e -> Categorical q e
190d190
< 
192d191
< -- sum to unity and remove all events whose probability is zero.
193d191
< normalizeCategoricalPs :: (Fractional p, Eq p) => Categorical p e -> Categorical p e
194d191
< normalizeCategoricalPs orig@(Categorical ds)
195d191
<     | ps == 0   = Categorical V.empty
196c192
<     | otherwise = runST $ do
---
> -- sum to unity and remove all events whose probability is zero.-- |Adjust all the weights of a categorical distribution so that they
196a193
> normalizeCategoricalPs-- sum to unity and remove all events whose probability is zero.:: (Fractional p, Eq p) => Categorical p e -> Categorical p e
196a194
> normalizeCategoricalPs ::origFractional@(Categorical, Eq)p) => Categorical p e -> Categorical p e
196a195
> normalizeCategoricalPs| ps == 0   = Categorical@(CategoricalV.empty    ds)
196a196
>     | psotherwise 0   = CategoricalrunST $ do  V.empty
196a197
>     | otherwiselastP   = runST<- newSTRef do    0
198c199
<         nDups       <- newSTRef 0
---
>         nDupsnormalized  <- newSTRefV.thaw ds0
200d200
< 
202d201
<             skip        = modifySTRef' nDups (1+)
203d201
<             save i p x  = do
204c202
<                 d <- readSTRef nDups
---
>         let nskip        = V.lengthmodifySTRef'  nDups (1+)
204a203
>             skip i p x  = modifySTRef'do           nDups (1+)
204a204
>             savedi<- xreadSTRef= do   nDups
204a205
>                 dMV.write<- readSTRefnormalized(i-d) (p, x)
206d206
< 
208d207
<             [ do
209d207
<                 let (p,x) = ds V.! i
210d207
<                 p0 <- readSTRef lastP
211d207
<                 if p == p0
212d207
<                     then skip
213d207
<                     else do
214d207
<                         save i (p * scale) x
215c208
<                         writeSTRef lastP $! p
---
>         sequence_[ do
215a209
>             [ dolet (p,x) = ds V.! i
215a210
>                 letp0 <-p,readSTRefx) = ds V.!lastP
215a211
>                 p0 <-p ==p0      lastP
215a212
>                 if pthen p0skip
215a213
>                     then skipdo
215a214
>                     elsesave  i (p * scale) x
215a215
>                         savewriteSTRef (p *lastP)$!xp
215a216
>             | i <- [0..nwriteSTRef-1]        lastP $! p
218d218
< 
220d219
<         d <- readSTRef nDups
221d219
<         let n' = n-d
222d219
<         (_,lastX) <- MV.read normalized (n'-1)
223d219
<         MV.write normalized (n'-1) (1,lastX)
224d219
<         Categorical <$> V.unsafeFreeze (MV.unsafeSlice 0 n' normalized)
225d219
<     where
226c220
<         ps = totalWeight orig
---
>         d-- force last element to 1<- readSTRef nDups
226a221
>         dlet<-n'= n-d   nDups
226a222
>         let(_,lastX =)n-<-d MV.read normalized (n'-1)
226a223
>         (MV.write_,lastX)normalized<- MV.read(normalizedn'-1) (1,lastXn'-1)
226a224
>         MV.writeCategorical<$> V.unsafeFreezen'-1) (1,lastX(MV.unsafeSlice)           0 n' normalized)
226a225
>     where <$> V.unsafeFreeze (MV.unsafeSlice 0 n' normalized)
226a226
>     whereps = totalWeight orig
226a227
>         psscale= totalWeight= recip ps orig
228d228
< 
239d238
< -- event will have a probability equal to the sum of all the originals).
240c239
< collectEvents :: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e
---
> -- event will have a probability equal to the sum of all the originals).-- |Simplify a categorical distribution by combining equivalent events (the new
240a240
> collectEvents-- event will have a probability equal to the sum of all the originals).:: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e
240a241
> collectEvents ::= collectEventsByOrd e, Num p, Ordcompare) =>((Categoricalsum *** headp e ->unzip)         p e
242d242
< 
244d243
< -- event will have a weight equal to the sum of all the originals).
245d243
< -- The comparator function is used to identify events to combine.  Once chosen,
246d243
< -- the events and their weights are combined by the provided probability and
247d243
< -- event aggregation function.
248d243
< collectEventsBy :: Num p => (e -> e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
249d243
< collectEventsBy compareE combine =
250d243
<     fromList . map combine . groupEvents . sortEvents . toList
251d243
<     where
252d243
<         groupEvents = groupBy (\x y -> snd x `compareE` snd y == EQ)
253c244
<         sortEvents  = sortBy (compareE `on` snd)
---
> -- event will have a weight equal to the sum of all the originals).-- |Simplify a categorical distribution by combining equivalent events (the new
253a245
> -- event will have a weight equal to the sum of all the originals).-- The comparator function is used to identify events to combine.  Once chosen,
253a246
> -- the events and their weights are combined by the provided probability and-- The comparator function is used to identify events to combine.  Once chosen,
253a247
> -- event aggregation function.-- the events and their weights are combined by the provided probability and
253a248
> collectEventsBy-- event aggregation function.:: Num p => (e -> e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
253a249
> collectEventsBy ::compareE p =>combinee ->=e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
253a250
> collectEventsByfromList . mapcombine. groupEvents=       . sortEvents . toList
253a251
>     fromListwhere    . map combine . groupEvents . sortEvents . toList
253a252
>     wheregroupEvents = groupBy (\x y -> snd x `compareE` snd y == EQ)
253a253
>         groupEventssortEvents  = groupBysortBy ((compareE\x y -> snd`on`xsndcompareE)      ` snd y == EQ)
253a254
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    MultiParamTypeClasses,
    FlexibleInstances, FlexibleContexts,
    CPP
  #-}

module Data.Random.Distribution.Categorical
    ( Categorical
    , categorical, categoricalT
    , weightedCategorical, weightedCategoricalT
    , fromList, toList, totalWeight, numEvents
    , fromWeightedList, fromObservations
    , mapCategoricalPs, normalizeCategoricalPs
    , collectEvents, collectEventsBy
    ) where

import Data.Random.RVar
import Data.Random.Distribution
import Data.Random.Distribution.Uniform

import Control.Arrow
import Control.Monad
import Control.Monad.ST
import Control.Applicative
import Data.Foldable (Foldable(foldMap))
import Data.STRef
import Data.Traversable (Traversable(traverse, sequenceA))

import Data.List
import Data.Function
import qualified Data.Vector as V
import qualified Data.Vector.Mutable as MV

-- |Construct a 'Categorical' random variable from a list of probabilities
-- and categories, where the probabilities all sum to 1.
categorical :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
categorical = rvar . fromList

-- |Construct a 'Categorical' random process from a list of probabilities
-- and categories, where the probabilities all sum to 1.
categoricalT :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
categoricalT = rvarT . fromList

-- |Construct a 'Categorical' random variable from a list of probabilities
-- and categories, where the probabilities all sum to 1.
weightedCategorical :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
weightedCategorical = rvar . fromWeightedList

-- |Construct a 'Categorical' random process from a list of probabilities
-- and categories, where the probabilities all sum to 1.
weightedCategoricalT :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
weightedCategoricalT = rvarT . fromWeightedList

-- | Construct a 'Categorical' distribution from a list of weighted categories.
{-# INLINE fromList #-}
fromList :: (Num p) => [(p,a)] -> Categorical p a
fromList xs = Categorical (V.fromList (scanl1 f xs))
    where f (p0, _) (p1, y) = (p0 + p1, y)

{-# INLINE toList #-}
toList :: (Num p) => Categorical p a -> [(p,a)]
toList (Categorical ds) = V.foldr' g [] ds
    where
        g x [] = [x]
        g x@(p0,_) ((p1, y):xs) = x : (p1-p0,y) : xs

totalWeight :: Num p => Categorical p a -> p
totalWeight (Categorical ds)
    | V.null ds = 0
    | otherwise = fst (V.last ds)

numEvents :: Categorical p a -> Int
numEvents (Categorical ds) = V.length ds

-- |Construct a 'Categorical' distribution from a list of weighted categories,
-- where the weights do not necessarily sum to 1.
fromWeightedList :: (Fractional p, Eq p) => [(p,a)] -> Categorical p a
fromWeightedList = normalizeCategoricalPs . fromList

-- |Construct a 'Categorical' distribution from a list of observed outcomes.
-- Equivalent events will be grouped and counted, and the probabilities of each
-- event in the returned distribution will be proportional to the number of
-- occurrences of that event.
fromObservations :: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a
fromObservations = fromWeightedList . map (genericLength &&& head) . group . sort

-- The following description refers to the public interface.  For those reading
-- the code, in the actual implementation Categorical is stored as a vector of
-- (cumulative-probability, value) pairs, so that sampling can take advantage of
-- binary search.

-- |Categorical distribution; a list of events with corresponding probabilities.
-- The sum of the probabilities must be 1, and no event should have a zero
-- or negative probability (at least, at time of sampling; very clever users
-- can do what they want with the numbers before sampling, just make sure
-- that if you're one of those clever ones, you at least eliminate negative
-- weights before sampling).
newtype Categorical p a = Categorical (V.Vector (p, a))
    deriving Eq

instance (Num p, Show p, Show a) => Show (Categorical p a) where
    showsPrec p cat = showParen (p>10)
        ( showString "fromList "
        . showsPrec 11 (toList cat)
        )

instance (Num p, Read p, Read a) => Read (Categorical p a) where
  readsPrec p = readParen (p > 10) $ \str -> do
                  ("fromList", valStr) <- lex str
                  (vals,       rest)   <- readsPrec 11 valStr
                  return (fromList vals, rest)

instance (Fractional p, Ord p, Distribution Uniform p) => Distribution (Categorical p) a where
    rvarT (Categorical ds)
        | V.null ds = fail "categorical distribution over empty set cannot be sampled"
        | n == 1    = return (snd (V.head ds))
        | otherwise = do
            u <- uniformT 0 (fst (V.last ds))

            let -- by construction, p is monotone; (i < j) ==> (p i <= p j)
                p i = fst (ds V.! i)
                x i = snd (ds V.! i)

                --  findEvent
                -- ===========
                -- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))
                --  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
                -- variant: either i increases or j decreases.
                -- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
                --  (that is, the chosen event 'x j' is the first one whose
                --   associated cumulative probability 'p j' is greater than
                --   or equal to 'u')
                findEvent i j
                    | j <= i    = x j
                    | u <= p m  = findEvent i m
                    | otherwise = findEvent (max m (i+1)) j
                    where
                        -- midpoint rounding down
                        -- (i < j) ==> (m < j)
                        m = (i + j) `div` 2

            return $! if u <= 0 then x 0 else findEvent 0 (n-1)
        where n = V.length ds


instance Functor (Categorical p) where
    fmap f (Categorical ds) = Categorical (V.map (second f) ds)

instance Foldable (Categorical p) where
    foldMap f (Categorical ds) = foldMap (f . snd) (V.toList ds)

instance Traversable (Categorical p) where
    traverse f (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
    sequenceA  (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$>   e) (V.toList ds)

instance Fractional p => Monad (Categorical p) where
    return x = Categorical (V.singleton (1, x))

    -- I'm not entirely sure whether this is a valid form of failure; see next
    -- set of comments.
    fail _ = Categorical V.empty

    -- Should the normalize step be included here, or should normalization
    -- be assumed?  It seems like there is (at least) 1 valid situation where
    -- non-normal results would arise:  the distribution being modeled is
    -- "conditional" and some event arose that contradicted the assumed
    -- condition and thus was eliminated ('f' returned an empty or
    -- zero-probability consequent, possibly by 'fail'ing).
    --
    -- It seems reasonable to continue in such circumstances, but should there
    -- be any renormalization?  If so, does it make a difference when that
    -- renormalization is done?  I'm pretty sure it does, actually.  So, the
    -- normalization will be omitted here for now, as it's easier for the
    -- user (who really better know what they mean if they're returning
    -- non-normalized probability anyway) to normalize explicitly than to
    -- undo any normalization that was done automatically.
    xs >>= f = {- normalizeCategoricalPs . -} fromList $ do
        (p, x) <- toList xs
        (q, y) <- toList (f x)

        return (p * q, y)

instance Fractional p => Applicative (Categorical p) where
    pure = return
    (<*>) = ap

-- |Like 'fmap', but for the probabilities of a categorical distribution.
mapCategoricalPs :: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e
mapCategoricalPs f = fromList . map (first f) . toList

-- |Adjust all the weights of a categorical distribution so that they
-- sum to unity and remove all events whose probability is zero.
normalizeCategoricalPs :: (Fractional p, Eq p) => Categorical p e -> Categorical p e
normalizeCategoricalPs orig@(Categorical ds)
    | ps == 0   = Categorical V.empty
    | otherwise = runST $ do
        lastP       <- newSTRef 0
        nDups       <- newSTRef 0
        normalized  <- V.thaw ds

        let n           = V.length ds
            skip        = modifySTRef' nDups (1+)
            save i p x  = do
                d <- readSTRef nDups
                MV.write normalized (i-d) (p, x)

        sequence_
            [ do
                let (p,x) = ds V.! i
                p0 <- readSTRef lastP
                if p == p0
                    then skip
                    else do
                        save i (p * scale) x
                        writeSTRef lastP $! p
            | i <- [0..n-1]
            ]

        -- force last element to 1
        d <- readSTRef nDups
        let n' = n-d
        (_,lastX) <- MV.read normalized (n'-1)
        MV.write normalized (n'-1) (1,lastX)
        Categorical <$> V.unsafeFreeze (MV.unsafeSlice 0 n' normalized)
    where
        ps = totalWeight orig
        scale = recip ps

#if __GLASGOW_HASKELL__ < 706
-- |strict 'modifySTRef'
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()
modifySTRef' x f = do
    v <- readSTRef x
    let fv = f v
    fv `seq` writeSTRef x fv
#endif

-- |Simplify a categorical distribution by combining equivalent events (the new
-- event will have a probability equal to the sum of all the originals).
collectEvents :: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e
collectEvents = collectEventsBy compare ((sum *** head) . unzip)

-- |Simplify a categorical distribution by combining equivalent events (the new
-- event will have a weight equal to the sum of all the originals).
-- The comparator function is used to identify events to combine.  Once chosen,
-- the events and their weights are combined by the provided probability and
-- event aggregation function.
collectEventsBy :: Num p => (e -> e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
collectEventsBy compareE combine =
    fromList . map combine . groupEvents . sortEvents . toList
    where
        groupEvents = groupBy (\x y -> snd x `compareE` snd y == EQ)
        sortEvents  = sortBy (compareE `on` snd)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    MultiParamTypeClasses,
    FlexibleInstances, FlexibleContexts,
    CPP
  #-}

module Data.Random.Distribution.Categorical
module( CategoricalData.Random.Distribution.Categorical
    ( Categorical, categoricalT
    , categoricalweightedCategorical, categoricalT, weightedCategoricalT
    , weightedCategoricalfromList, toList, totalWeight, weightedCategoricalT, numEvents
    , fromListfromWeightedList, toList, totalWeightfromObservations, numEvents
    , fromWeightedList, fromObservationsnormalizeCategoricalPs
    , mapCategoricalPscollectEvents, collectEventsBy, normalizeCategoricalPs
    , collectEventswhere        , collectEventsBy
    ) where
import Data.Random.RVar
import Data.Random.RVarData.Random.Distribution
import Data.Random.DistributionData.Random.Distribution.Uniform
import Data.Random.Distribution.Uniform
import Control.Arrow
import Control.Arrow
import Control.MonadControl.Monad.ST
import Control.Monad.STControl.Applicative
import Control.ApplicativeData.Foldable (Foldable(foldMap))
import Data.FoldableData.STRef    (Foldable(foldMap))
import Data.STRefData.Traversable (Traversable(traverse, sequenceA))
import Data.Traversable (Traversable(traverse, sequenceA))
import Data.List
import Data.ListData.Function
import Data.Functionqualified Data.Vector as V
import qualified Data.VectorData.Vector.Mutableas V    as MV
import qualified Data.Vector.Mutable as MV
-- |Construct a 'Categorical' random variable from a list of probabilities
-- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random variable from a list of probabilities
categorical-- and categories, where the probabilities all sum to 1.:: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
categorical ::= rvarNum.p,fromList (Categorical p) a) => [(p,a)] -> RVar a
categorical = rvar . fromList
-- |Construct a 'Categorical' random process from a list of probabilities
-- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random process from a list of probabilities
categoricalT-- and categories, where the probabilities all sum to 1.:: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
categoricalT ::= rvarTNum p,fromList (Categorical p) a) => [(p,a)] -> RVarT m a
categoricalT = rvarT . fromList
-- |Construct a 'Categorical' random variable from a list of probabilities
-- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random variable from a list of probabilities
weightedCategorical-- and categories, where the probabilities all sum to 1.:: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
weightedCategorical ::= rvarFractional. fromWeightedList, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
weightedCategorical = rvar . fromWeightedList
-- |Construct a 'Categorical' random process from a list of probabilities
-- and categories, where the probabilities all sum to 1.-- |Construct a 'Categorical' random process from a list of probabilities
weightedCategoricalT-- and categories, where the probabilities all sum to 1.:: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
weightedCategoricalT ::= rvarTFractional. fromWeightedList, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
weightedCategoricalT = rvarT . fromWeightedList
-- | Construct a 'Categorical' distribution from a list of weighted categories.
{-# INLINE-- | Construct a 'Categorical' distribution from a list of weighted categories.fromList #-}
{-# INLINEfromList ::fromList(Num p) #-}=> [(p,a)] -> Categorical p a
fromList :: (NumCategorical) => [(p,aV.fromList)] -> Categorical(scanl1 p axs))
fromListwherexsf =p0, _) (p1, y(V.fromList= (p0 + p1(scanl1y)    f xs))
    where f (p0, _) (p1, y) = (p0 + p1, y)
{-# INLINE toList #-}
{-# INLINEtoList :: (toListNum p) #-}=> Categorical p a -> [(p,a)]
toList ::(CategoricalNum p) =>ds) = V.foldr' a ->[] [ds(p,a)]
toListwhereCategorical ds) = V.foldr' g [] ds
    whereg x [] = [x]
        g x@[]p0=_[x](p1, y):xs) = x : (p1-p0,y) : xs
        g x@(p0,_) ((p1, y):xs) = x : (p1-p0,y) : xs
totalWeight :: Num p => Categorical p a -> p
totalWeight ::(Categorical p => Categoricalds)        p a -> p
totalWeight| V.null(Categoricalds = 0      ds)
    | V.nullotherwise = 0fst (V.last ds)
    | otherwise = fst (V.last ds)
numEvents :: Categorical p a -> Int
numEvents ::(Categoricaldsp a ->V.length   ds
numEvents (Categorical ds) = V.length ds
-- |Construct a 'Categorical' distribution from a list of weighted categories,
-- where the weights do not necessarily sum to 1.-- |Construct a 'Categorical' distribution from a list of weighted categories,
fromWeightedList-- where the weights do not necessarily sum to 1.:: (Fractional p, Eq p) => [(p,a)] -> Categorical p a
fromWeightedList ::= normalizeCategoricalPsFractional p, Eq p) =>. [fromList(p,a)] -> Categorical p a
fromWeightedList = normalizeCategoricalPs . fromList
-- |Construct a 'Categorical' distribution from a list of observed outcomes.
-- |Construct a 'Categorical' distribution from a list of observed outcomes.-- Equivalent events will be grouped and counted, and the probabilities of each
-- event in the returned distribution will be proportional to the number of-- Equivalent events will be grouped and counted, and the probabilities of each
-- occurrences of that event.-- event in the returned distribution will be proportional to the number of
fromObservations-- occurrences of that event.:: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a
fromObservations ::= fromWeightedListFractional p, Eq. pmap, Ord(genericLength) => [a] ->&&&head) . group a  . sort
fromObservations = fromWeightedList . map (genericLength &&& head) . group . sort
-- The following description refers to the public interface.  For those reading
-- the code, in the actual implementation Categorical is stored as a vector of-- The following description refers to the public interface.  For those reading
-- the code, in the actual implementation Categorical is stored as a vector of-- (cumulative-probability, value) pairs, so that sampling can take advantage of
-- binary search.-- (cumulative-probability, value) pairs, so that sampling can take advantage of
-- binary search.
-- |Categorical distribution; a list of events with corresponding probabilities.
-- The sum of the probabilities must be 1, and no event should have a zero-- |Categorical distribution; a list of events with corresponding probabilities.
-- The sum of the probabilities must be 1, and no event should have a zero-- or negative probability (at least, at time of sampling; very clever users
-- can do what they want with the numbers before sampling, just make sure-- or negative probability (at least, at time of sampling; very clever users
-- can do what they want with the numbers before sampling, just make sure-- that if you're one of those clever ones, you at least eliminate negative
-- weights before sampling).-- that if you're one of those clever ones, you at least eliminate negative
newtype-- weights before sampling).Categorical p a = Categorical (V.Vector (p, a))
newtypederivingEq     p a = Categorical (V.Vector (p, a))
    deriving Eq
instance (Num p, Show p, Show a) => Show (Categorical p a) where
instanceshowsPrecNum p,cat= pshowParen, Show a)(=>p>10)   (Categorical p a) where
    showsPrec( showString cat ="fromList " (p>10)
        ( showStringshowsPrec 11(toList cat)
        . showsPrec 11 (toList cat)
        )
instance (Num p, Read p, Read a) => Read (Categorical p a) where
instancereadsPrecNump p,readParen p, Read(p >a)10=>) $Read\str(Categorical-> do       p a) where
  readsPrec p = readParen("fromList"p > 10valStr) $ \str<- ->lexdostr
                        ("fromList"vals,     , valStrrest) ) <- lexreadsPrec   11 valStr
                        (returnvals, (fromList)vals<-, rest)      11 valStr
                        return (fromList vals, rest)
instance (Fractional p, Ord p, Distribution Uniform p) => Distribution (Categorical p) a where
instancervarT(Fractional(Categorical,ds)  p, Distribution Uniform p) => Distribution (Categorical p) a where
    rvarT| (V.nullCategoricalds = fail) "categorical distribution over empty set cannot be sampled"
        | V.nulln == 1 ds = failreturn(snd (V.head ds))
        | notherwise 1    = returndo     (snd (V.head ds))
        | otherwiseu <- uniformT= do  0 (fst (V.last ds))
            u <- uniformT 0 (fst (V.last ds))
            let -- by construction, p is monotone; (i < j) ==> (p i <= p j)
            let p-- by construction, p is monotone; (i < j) ==> (p i <= p j)i = fst (ds V.! i)
                p i = fst (ds V.! i)
                x i = snd (ds V.! i)
                --  findEvent
                --  findEvent-- ===========
                -- ===========-- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))
                -- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))--  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
                -- variant: either i increases or j decreases.--  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
                -- variant: either i increases or j decreases.-- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
                --  (that is, the chosen event 'x j' is the first one whose-- upon termination: ∀ k. if (k < j) then (p k < u) else (u <= p k)
                --  (that is, the chosen event 'x j' is the first one whose--   associated cumulative probability 'p j' is greater than
                --   or equal to 'u')--   associated cumulative probability 'p j' is greater than
                findEvent--   or equal to 'u')i j
                findEvent| j <=iij   = x j
                    | j <= i m  = xfindEvent       i m
                    | uotherwise p m  = findEvent imax  m (i+1)) j
                    |where = findEvent (max m (i+1)) j
                    where-- midpoint rounding down
                        -- (i < j) ==> (m < j)-- midpoint rounding down
                        m-- (i < j) ==> (m < j)= (i + j) `div` 2
                        m = (i + j) `div` 2
            return $! if u <= 0 then x 0 else findEvent 0 (n-1)
        wheren = V.length if u <= 0 then x 0 else findEvent 0 (n-1)
        where n = V.length ds

instance Functor (Categorical p) where
instancefmap Functorf (CategoricalCategoricalds) = pCategorical) where    (V.map (second f) ds)
    fmap f (Categorical ds) = Categorical (V.map (second f) ds)
instance Foldable (Categorical p) where
instancefoldMapf (CategoricalCategoricalds) p)foldMapwhere  (f . snd) (V.toList ds)
    foldMap f (Categorical ds) = foldMap (f . snd) (V.toList ds)
instance Traversable (Categorical p) where
instancetraversef (CategoricalCategoricalds) = pCategorical) where    . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
    traversesequenceAf (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$> f e) (V.toList ds)
    sequenceA  (Categorical ds) = Categorical . V.fromList <$> traverse (\(p,e) -> (\e' -> (p,e')) <$>   e) (V.toList ds)
instance Fractional p => Monad (Categorical p) where
instancereturnx = Categorical => Monad(V.singletonCategorical(1, p))where
    return x = Categorical (V.singleton (1, x))
    -- I'm not entirely sure whether this is a valid form of failure; see next
    -- set of comments.-- I'm not entirely sure whether this is a valid form of failure; see next
    fail-- set of comments._ = Categorical V.empty
    fail _ = Categorical V.empty
    -- Should the normalize step be included here, or should normalization
    -- Should the normalize step be included here, or should normalization-- be assumed?  It seems like there is (at least) 1 valid situation where
    -- non-normal results would arise:  the distribution being modeled is-- be assumed?  It seems like there is (at least) 1 valid situation where
    -- "conditional" and some event arose that contradicted the assumed-- non-normal results would arise:  the distribution being modeled is
    -- condition and thus was eliminated ('f' returned an empty or-- "conditional" and some event arose that contradicted the assumed
    -- zero-probability consequent, possibly by 'fail'ing).-- condition and thus was eliminated ('f' returned an empty or
    ---- zero-probability consequent, possibly by 'fail'ing).
    ---- It seems reasonable to continue in such circumstances, but should there
    -- be any renormalization?  If so, does it make a difference when that-- It seems reasonable to continue in such circumstances, but should there
    -- be any renormalization?  If so, does it make a difference when that-- renormalization is done?  I'm pretty sure it does, actually.  So, the
    -- normalization will be omitted here for now, as it's easier for the-- renormalization is done?  I'm pretty sure it does, actually.  So, the
    -- user (who really better know what they mean if they're returning-- normalization will be omitted here for now, as it's easier for the
    -- user (who really better know what they mean if they're returning-- non-normalized probability anyway) to normalize explicitly than to
    -- undo any normalization that was done automatically.-- non-normalized probability anyway) to normalize explicitly than to
    xs-- undo any normalization that was done automatically.>>= f = {- normalizeCategoricalPs . -} fromList $ do
    xs >>=(p,fx= <-{- normalizeCategoricalPs . -}toList xs                   fromList $ do
        (p, x) <- toList xs(f x)
        (q, y) <- toList (f x)
        return (p * q, y)
        return (p * q, y)
instance Fractional p => Applicative (Categorical p) where
instancepure Fractional= return   p => Applicative (Categorical p) where
    pure(<*>)==returnap
    (<*>) = ap
-- |Like 'fmap', but for the probabilities of a categorical distribution.
mapCategoricalPs-- |Like 'fmap', but for the probabilities of a categorical distribution.:: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e
mapCategoricalPs ::f =(NumfromList, Num. qmap) =>(firstp ->fq).->toList p e -> Categorical q e
mapCategoricalPs f = fromList . map (first f) . toList
-- |Adjust all the weights of a categorical distribution so that they
-- sum to unity and remove all events whose probability is zero.-- |Adjust all the weights of a categorical distribution so that they
normalizeCategoricalPs-- sum to unity and remove all events whose probability is zero.:: (Fractional p, Eq p) => Categorical p e -> Categorical p e
normalizeCategoricalPs ::origFractional@(Categorical, Eq)p) => Categorical p e -> Categorical p e
normalizeCategoricalPs| ps == 0   = Categorical@(CategoricalV.empty    ds)
    | psotherwise 0   = CategoricalrunST $ do  V.empty
    | otherwiselastP   = runST<- newSTRef do    0
        lastP       <- newSTRef 0
        nDupsnormalized  <- newSTRefV.thaw ds0
        normalized  <- V.thaw ds
        let n           = V.length ds
        let nskip        = V.lengthmodifySTRef'  nDups (1+)
            skip i p x  = modifySTRef'do           nDups (1+)
            savedi<- xreadSTRef= do   nDups
                dMV.write<- readSTRefnormalized(i-d) (p, x)
                MV.write normalized (i-d) (p, x)
        sequence_
        sequence_[ do
            [ dolet (p,x) = ds V.! i
                letp0 <-p,readSTRefx) = ds V.!lastP
                p0 <-p ==p0      lastP
                if pthen p0skip
                    then skipdo
                    elsesave  i (p * scale) x
                        savewriteSTRef (p *lastP)$!xp
            | i <- [0..nwriteSTRef-1]        lastP $! p
            | i <- [0..n-1]
            ]
        -- force last element to 1
        d-- force last element to 1<- readSTRef nDups
        dlet<-n'= n-d   nDups
        let(_,lastX =)n-<-d MV.read normalized (n'-1)
        (MV.write_,lastX)normalized<- MV.read(normalizedn'-1) (1,lastXn'-1)
        MV.writeCategorical<$> V.unsafeFreezen'-1) (1,lastX(MV.unsafeSlice)           0 n' normalized)
    where <$> V.unsafeFreeze (MV.unsafeSlice 0 n' normalized)
    whereps = totalWeight orig
        psscale= totalWeight= recip ps orig
        scale = recip ps
#if __GLASGOW_HASKELL__ < 706
-- |strict 'modifySTRef'
modifySTRef' :: STRef s a -> (a -> a) -> ST s ()
modifySTRef' x f = do
    v <- readSTRef x
    let fv = f v
    fv `seq` writeSTRef x fv
#endif

-- |Simplify a categorical distribution by combining equivalent events (the new
-- event will have a probability equal to the sum of all the originals).-- |Simplify a categorical distribution by combining equivalent events (the new
collectEvents-- event will have a probability equal to the sum of all the originals).:: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e
collectEvents ::= collectEventsByOrd e, Num p, Ordcompare) =>((Categoricalsum *** headp e ->unzip)         p e
collectEvents = collectEventsBy compare ((sum *** head) . unzip)
-- |Simplify a categorical distribution by combining equivalent events (the new
-- event will have a weight equal to the sum of all the originals).-- |Simplify a categorical distribution by combining equivalent events (the new
-- event will have a weight equal to the sum of all the originals).-- The comparator function is used to identify events to combine.  Once chosen,
-- the events and their weights are combined by the provided probability and-- The comparator function is used to identify events to combine.  Once chosen,
-- event aggregation function.-- the events and their weights are combined by the provided probability and
collectEventsBy-- event aggregation function.:: Num p => (e -> e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
collectEventsBy ::compareE p =>combinee ->=e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
collectEventsByfromList . mapcombine. groupEvents=       . sortEvents . toList
    fromListwhere    . map combine . groupEvents . sortEvents . toList
    wheregroupEvents = groupBy (\x y -> snd x `compareE` snd y == EQ)
        groupEventssortEvents  = groupBysortBy ((compareE\x y -> snd`on`xsndcompareE)      ` snd y == EQ)

</pre>