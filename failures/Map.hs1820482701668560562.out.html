<a href="ManualCommands.hs2082344010414780911.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Map.hs19252285421179996045.out.html">next</a></br></br><pre>29c29
<     $expect $ equal
---
>     expect $ equal
33c33
<     $expect $ equal
---
>     expect $ equal
43c43
<     $expect $ equal
---
>     expect $ equal
47c47
<     $expect $ equal
---
>     expect $ equal
56c56
<     $expect $ equal
---
>     expect $ equal
63c63
<     $expect $ equal
---
>     expect $ equal
67c67
<     $expect $ equal
---
>     expect $ equal
77c77
<     $expect $ equal
---
>     expect $ equal
81c81
<     $expect $ equal
---
>     expect $ equal
91c91
<     $expect $ equal
---
>     expect $ equal
95c95
<     $expect $ equal
---
>     expect $ equal
105c105
<     $expect $ equal
---
>     expect $ equal
109c109
<     $expect $ equal
---
>     expect $ equal
119c119
<     $expect $ equal
---
>     expect $ equal
123c123
<     $expect $ equal
---
>     expect $ equal
133c133
<     $expect $ equal
---
>     expect $ equal
137c137
<     $expect $ equal
---
>     expect $ equal
142a143
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.List.Map
    ( test_Map
    , test_MapM
    , test_MapM_
    , test_ConcatMap
    , test_ConcatMapM
    , test_ConcatMapAccum
    , test_ConcatMapAccumM
    , test_MapAccum
    , test_MapAccumM
    ) where

import           Control.Monad.Trans.Writer (execWriter, tell)
import           Data.Char (chr, ord, toLower)
import           Test.Chell

import           Data.Enumerator (($$), (=$))
import qualified Data.Enumerator as E
import qualified Data.Enumerator.List as EL

test_Map :: Suite
test_Map = assertions "map" $ do
    $expect $ equal
        ['a', 'b', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.map toLower =$ EL.consume)
    $expect $ equal
        (['a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.map toLower =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapM :: Suite
test_MapM = assertions "mapM" $ do
    let step = return . toLower
    $expect $ equal
        ['a', 'b', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapM step =$ EL.consume)
    $expect $ equal
        (['a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapM step =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapM_ :: Suite
test_MapM_ = assertions "mapM_" $ do
    $expect $ equal
        ['A', 'B', 'C']
        (execWriter (E.run_ (E.enumList 1 ['A', 'B', 'C'] $$ EL.mapM_ (\x -> tell [x]))))

test_ConcatMap :: Suite
test_ConcatMap = assertions "concatMap" $ do
    let step ao = [ao, toLower ao]
    $expect $ equal
        ['A', 'a', 'B', 'b', 'C', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMap step =$ EL.consume)
    $expect $ equal
        (['A', 'a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMap step =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapM :: Suite
test_ConcatMapM = assertions "concatMapM" $ do
    let step ao = return [ao, toLower ao]
    $expect $ equal
        ['A', 'a', 'B', 'b', 'C', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapM step =$ EL.consume)
    $expect $ equal
        (['A', 'a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapM step =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_MapAccum :: Suite
test_MapAccum = assertions "mapAccum" $ do
    let step s ao = (s + 1, chr (ord ao + s))
    $expect $ equal
        ['B', 'D', 'F']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapAccum step 1 =$ EL.consume)
    $expect $ equal
        (['B'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapAccum step 1 =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapAccumM :: Suite
test_MapAccumM = assertions "mapAccumM" $ do
    let step s ao = return (s + 1, chr (ord ao + s))
    $expect $ equal
        ['B', 'D', 'F']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapAccumM step 1 =$ EL.consume)
    $expect $ equal
        (['B'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapAccumM step 1 =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapAccum :: Suite
test_ConcatMapAccum = assertions "concatMapAccum" $ do
    let step s ao = (s + 1, replicate s ao)
    $expect $ equal
        ['A', 'B', 'B', 'C', 'C', 'C']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapAccum step 1 =$ EL.consume)
    $expect $ equal
        (['A', 'B'], ['C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapAccum step 1 =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapAccumM :: Suite
test_ConcatMapAccumM = assertions "concatMapAccumM" $ do
    let step s ao = return (s + 1, replicate s ao)
    $expect $ equal
        ['A', 'B', 'B', 'C', 'C', 'C']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapAccumM step 1 =$ EL.consume)
    $expect $ equal
        (['A', 'B'], ['C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapAccumM step 1 =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.List.Map
    ( test_Map
    , test_MapM
    , test_MapM_
    , test_ConcatMap
    , test_ConcatMapM
    , test_ConcatMapAccum
    , test_ConcatMapAccumM
    , test_MapAccum
    , test_MapAccumM
    ) where

import           Control.Monad.Trans.Writer (execWriter, tell)
import           Data.Char (chr, ord, toLower)
import           Test.Chell

import           Data.Enumerator (($$), (=$))
import qualified Data.Enumerator as E
import qualified Data.Enumerator.List as EL

test_Map :: Suite
test_Map = assertions "map" $ do
    expect $ equal
        ['a', 'b', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.map toLower =$ EL.consume)
    expect $ equal
        (['a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.map toLower =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapM :: Suite
test_MapM = assertions "mapM" $ do
    let step = return . toLower
    expect $ equal
        ['a', 'b', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapM step =$ EL.consume)
    expect $ equal
        (['a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapM step =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapM_ :: Suite
test_MapM_ = assertions "mapM_" $ do
    expect $ equal
        ['A', 'B', 'C']
        (execWriter (E.run_ (E.enumList 1 ['A', 'B', 'C'] $$ EL.mapM_ (\x -> tell [x]))))

test_ConcatMap :: Suite
test_ConcatMap = assertions "concatMap" $ do
    let step ao = [ao, toLower ao]
    expect $ equal
        ['A', 'a', 'B', 'b', 'C', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMap step =$ EL.consume)
    expect $ equal
        (['A', 'a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMap step =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapM :: Suite
test_ConcatMapM = assertions "concatMapM" $ do
    let step ao = return [ao, toLower ao]
    expect $ equal
        ['A', 'a', 'B', 'b', 'C', 'c']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapM step =$ EL.consume)
    expect $ equal
        (['A', 'a'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapM step =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_MapAccum :: Suite
test_MapAccum = assertions "mapAccum" $ do
    let step s ao = (s + 1, chr (ord ao + s))
    expect $ equal
        ['B', 'D', 'F']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapAccum step 1 =$ EL.consume)
    expect $ equal
        (['B'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapAccum step 1 =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_MapAccumM :: Suite
test_MapAccumM = assertions "mapAccumM" $ do
    let step s ao = return (s + 1, chr (ord ao + s))
    expect $ equal
        ['B', 'D', 'F']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.mapAccumM step 1 =$ EL.consume)
    expect $ equal
        (['B'], ['B', 'C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.mapAccumM step 1 =$ EL.take 1
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapAccum :: Suite
test_ConcatMapAccum = assertions "concatMapAccum" $ do
    let step s ao = (s + 1, replicate s ao)
    expect $ equal
        ['A', 'B', 'B', 'C', 'C', 'C']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapAccum step 1 =$ EL.consume)
    expect $ equal
        (['A', 'B'], ['C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapAccum step 1 =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

test_ConcatMapAccumM :: Suite
test_ConcatMapAccumM = assertions "concatMapAccumM" $ do
    let step s ao = return (s + 1, replicate s ao)
    expect $ equal
        ['A', 'B', 'B', 'C', 'C', 'C']
        (E.runLists_ [['A', 'B'], ['C']] $ do
            EL.concatMapAccumM step 1 =$ EL.consume)
    expect $ equal
        (['A', 'B'], ['C'])
        (E.runLists_ [['A', 'B'], ['C']] $ do
            xs <- EL.concatMapAccumM step 1 =$ EL.take 2
            extra <- EL.consume
            return (xs, extra))

</pre>