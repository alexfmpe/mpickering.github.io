<a href="Aeson.hs19548990971636807826.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Affine.hs1137623865997389814.out.html">next</a></br></br><pre>12d11
< -- for data types with a 'Generic' instance.
13d11
< --
14d11
< -- The structure of the generated JSON is meant to be close to
15d11
< -- idiomatic JSON. This means:
16d11
< --
17d11
< -- * Enumerations are converted to JSON strings.
18d11
< --
19d11
< -- * Record fields become JSON keys.
20d11
< --
21d11
< -- * Data types with one unlabeled field convert to just that field.
22d11
< --
23d11
< -- * Data types with multiple unlabeled fields become arrays.
24d11
< --
25d11
< -- * Multiple constructors are represented by keys.
26d11
< --
27d11
< -- * 'Maybe' values are either an absent key, or the value.
28d11
< --
29d11
< -- See 'tests/Main.hs' for more examples.
30d11
< module Generics.Generic.Aeson
31d11
<   ( gtoJson
32d11
<   , gparseJson
33d11
<   , GtoJson (..)
34d11
<   , GfromJson (..)
35d11
<   , formatLabel
36d11
<   , Settings (..)
37d11
<   , defaultSettings
38d11
<   , gtoJsonWithSettings
39c12
<   , gparseJsonWithSettings
---
> -- for data types with a 'Generic' instance.-- | This module offers generic conversions to an from JSON 'Value's
39a13
> ---- for data types with a 'Generic' instance.
39a14
> ---- The structure of the generated JSON is meant to be close to
39a15
> -- idiomatic JSON. This means:-- The structure of the generated JSON is meant to be close to
39a16
> ---- idiomatic JSON. This means:
39a17
> ---- * Enumerations are converted to JSON strings.
39a18
> ---- * Enumerations are converted to JSON strings.
39a19
> ---- * Record fields become JSON keys.
39a20
> ---- * Record fields become JSON keys.
39a21
> ---- * Data types with one unlabeled field convert to just that field.
39a22
> ---- * Data types with one unlabeled field convert to just that field.
39a23
> ---- * Data types with multiple unlabeled fields become arrays.
39a24
> ---- * Data types with multiple unlabeled fields become arrays.
39a25
> ---- * Multiple constructors are represented by keys.
39a26
> ---- * Multiple constructors are represented by keys.
39a27
> ---- * 'Maybe' values are either an absent key, or the value.
39a28
> ---- * 'Maybe' values are either an absent key, or the value.
39a29
> ---- See 'tests/Main.hs' for more examples.
39a30
> module-- See 'tests/Main.hs' for more examples.Generics.Generic.Aeson
39a31
> module( gtoJsonGenerics.Generic.Aeson
39a32
>   ( gtoJsongparseJson
39a33
>   , gparseJsonGtoJson (..)
39a34
>   , GtoJsonGfromJson(..()..)
39a35
>   , GfromJsonformatLabel(..)
39a36
>   , formatLabelSettings (..)
39a37
>   , SettingsdefaultSettings(..)
39a38
>   , defaultSettingsgtoJsonWithSettings
39a39
>   , gtoJsonWithSettingsgparseJsonWithSettings
39a40
>   , gparseJsonWithSettingswhere
41d41
< 
42a43
> import Control.Applicative
44d44
< import Control.Monad.State
45d44
< import Data.Aeson
46d44
< import Data.Aeson.Types hiding (GFromJSON, GToJSON)
47d44
< import Data.Proxy
48d44
< import Data.Text (Text)
49d44
< import GHC.Generics
50d44
< import Generics.Deriving.ConNames
51d44
< import qualified Data.HashMap.Strict as H
52c45
< import qualified Data.Text           as T
---
> import Control.Monad.StateData.Aeson
52a46
> import Data.AesonData.Aeson.Types hiding (GFromJSON, GToJSON)
52a47
> import Data.Aeson.TypesData.Proxy       hiding (GFromJSON, GToJSON)
52a48
> import Data.ProxyData.Text (Text)
52a49
> import Data.TextGHC.GenericsText)
52a50
> import GHC.GenericsGenerics.Deriving.ConNames
52a51
> import Generics.Deriving.ConNamesqualified Data.HashMap.Strict as H
52a52
> import qualified Data.HashMap.StrictData.Text           as H
52a53
> import qualified Data.TextData.Vector         as T
54d54
< 
56c56
< 
---
> import Generics.Generic.Aeson.Util
58d57
< -- You generally don't need to give any custom instances. Just add
59d57
< -- 'deriving Generic' and call 'gToJson'.
60c58
< class GtoJson f where
---
> -- You generally don't need to give any custom instances. Just add-- | Class for converting the functors from "GHC.Generics" to JSON.
60a59
> -- 'deriving Generic' and call 'gToJson'.-- You generally don't need to give any custom instances. Just add
60a60
> class-- 'deriving Generic' and call 'gToJson'.GtoJson f where
60a61
> class-- | Generically show a functor as a JSON value.  The first argument f where
62d62
<   -- tells us if there are multiple constructors in the data type. The
63d62
<   -- second indicates if this data type is an enumeration (only empty
64d62
<   -- constructors). A functor is then converted to either a list
65d62
<   -- of values (for non-labeled fields) or a list of String/value
66c63
<   -- pairs (for labeled fields).
---
>   -- second indicates if this data type is an enumeration (only empty-- tells us if there are multiple constructors in the data type. The
66a64
>   -- constructors). A functor is then converted to either a list-- second indicates if this data type is an enumeration (only empty
66a65
>   -- constructors). A functor is then converted to either a list-- of values (for non-labeled fields) or a list of String/value
66a66
>   -- pairs (for labeled fields).-- of values (for non-labeled fields) or a list of String/value
66a67
>   gtoJSONf-- pairs (for labeled fields).:: Settings -> Bool -> Bool -> f a -> Either [Value] [(Text, Value)]
68d68
< 
70d69
< -- You generally don't need to give any custom instances. Just add
71d69
< -- 'deriving Generic' and call 'gFromJson'.
72d69
< class GfromJson f where
73d69
<   -- | Generically read a functor from a JSON value.  The first
74d69
<   -- argument tells us if there are multiple constructors in the data
75d69
<   -- type. The second indicates if we've already detected that this
76d69
<   -- data type has multiple constructors. When this is False, the
77d69
<   -- (:*:) puts the fields in the state. The third indicates if this
78d69
<   -- data type is an enumeration (only empty constructors). The third
79d69
<   -- is a function for parsing the recursive positions. A JSON value
80c70
<   -- is then parsed to either a functor, or a failure.
---
> -- | Class for parsing the functors from "GHC.Generics" from JSON.
80a71
> -- 'deriving Generic' and call 'gFromJson'.-- You generally don't need to give any custom instances. Just add
80a72
> class-- 'deriving Generic' and call 'gFromJson'.GfromJson f where
80a73
> class-- | Generically read a functor from a JSON value.  The first f where
80a74
>   -- | Generically read a functor from a JSON value.  The first-- argument tells us if there are multiple constructors in the data
80a75
>   -- type. The second indicates if we've already detected that this-- argument tells us if there are multiple constructors in the data
80a76
>   -- data type has multiple constructors. When this is False, the-- type. The second indicates if we've already detected that this
80a77
>   -- data type has multiple constructors. When this is False, the-- (:*:) puts the fields in the state. The third indicates if this
80a78
>   -- (:*:) puts the fields in the state. The third indicates if this-- data type is an enumeration (only empty constructors). The third
80a79
>   -- is a function for parsing the recursive positions. A JSON value-- data type is an enumeration (only empty constructors). The third
80a80
>   -- is then parsed to either a functor, or a failure.-- is a function for parsing the recursive positions. A JSON value
80a81
>   gparseJSONf-- is then parsed to either a functor, or a failure.:: Settings -> Bool -> Bool -> Bool -> StateT [Value] Parser (f a)
82d82
< 
83a84
> -- instance GJSON V1-- Void: Used for data types without constructors
85d85
< 
87d86
< instance GtoJson U1 where
88d86
<   gtoJSONf _ _ _ U1 = Right []
89c87
< instance GfromJson U1 where
---
> instance-- Unit: Used for constructors without argumentsGtoJson U1 where
89a88
> instancegtoJSONf_ _ _ U1 where= Right []
89a89
> instanceGfromJson _ _ U1U1= Right []
89a90
> instancegparseJSONf_ _ _U1_ where= return U1
91d91
< 
93c93
< 
---
> -- | Convert any datatype with a 'Generic' instance to a JSON 'Value'.
95d94
<   :: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
96c95
<   => a -> Value
---
> gtoJson:: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
96a96
>   :: foralla -> Value. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
96a97
> gtoJson=> a ->= ValuegtoJsonWithSettings defaultSettings
98d98
< 
100d99
<   :: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
101d99
<    => Settings -> a -> Value
102d99
< gtoJsonWithSettings settings x =
103d99
<   case gtoJSONf settings (multipleConstructors $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
104d99
<     Left  [v] -> v
105c100
<     Left  _   -> error "The impossible happened: multiple returned values in gtoJSON."
---
> gtoJsonWithSettings:: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
105a101
>   ::=>forallSettings. (->Generica -> Value, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
105a102
> gtoJsonWithSettings=> Settings -> a ->settings x =
105a103
> gtoJsonWithSettingscase gtoJSONf settings(multipleConstructors =               $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
105a104
>   caseLeft[v] ->settingsv       (multipleConstructors $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
105a105
>     Left  [v] -> verror "The impossible happened: multiple returned values in gtoJSON."
105a106
>     LeftRight _   -> error "The impossible happened: multiple returned values in gtoJSON.""The impossible happened: labeled values returned in gtoJSON."
107d107
< 
109d108
< gparseJson
110d108
<   :: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
111c109
<   => Value -> Parser a
---
> gparseJson-- | Parse any datatype with a 'Generic' instance from a JSON 'Value'.
111a110
> gparseJson:: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
111a111
>   :: forallValue ->.ParserGenerica  a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
111a112
> gparseJson=> Value ->= gparseJsonWithSettings a              defaultSettings
113d113
< 
115d114
<   :: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
116d114
<   => Settings -> Value -> Parser a
117d114
< gparseJsonWithSettings set
118d114
<   = fmap to
119c115
<   . evalStateT (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
---
> gparseJsonWithSettings:: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
119a116
>   :: forallSettings.->GenericValue ->,Parsera   (Rep a), ConNames (Rep a), GIsEnum (Rep a))
119a117
> gparseJsonWithSettings=> Settings -> Value ->setParser a
119a118
> gparseJsonWithSettings= fmap to            set
119a119
>   = fmapevalStateT    (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
119a120
>   . evalStateTreturn     (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
121d121
< 
123d122
< instance (ToJSON c) => GtoJson (K1 a c) where
124d122
<   gtoJSONf _ _ _ (K1 a) = Left [toJSON a]
125c123
< instance (FromJSON c) => GfromJson (K1 a c) where
---
> instance-- Structure type for constant values.(ToJSON c) => GtoJson (K1 a c) where
125a124
> instancegtoJSONfToJSON_ _ _ c)K1=>a)GtoJson= Left (K1toJSON c)awhere]
125a125
> instance(FromJSON _ _ (K1c)a)=>=GfromJson [toJSON(K1 a]c) where
125a126
> instancegparseJSONfFromJSON_ _ _c) =>=GfromJsonlift . fmapK1K1 c)parseJSONwhere    =<< pop
127d127
< 
128a129
> instancegtoJSONfGtoJsonset mc fenm, GtoJson(L1 x) g)gtoJSONf=> GtoJsonset(fmc:+:enmg) where
130d130
<   gtoJSONf set mc enm (R1 x) = gtoJSONf set mc enm x
131d130
< instance (GfromJson f, GfromJson g) => GfromJson (f :+: g) where
132d130
<   gparseJSONf set mc smf enm
133c131
<     =  L1 <$> gparseJSONf set mc smf enm
---
> instance(GfromJson mc enmf,(R1GfromJson) = gtoJSONfg) => GfromJson mc enm(fx:+: g) where
133a132
> instancegparseJSONfGfromJsonset mcf,smfenm     g) => GfromJson (f :+: g) where
133a133
>   gparseJSONf=  L1 <$> setgparseJSONf smf enmset mc smf enm
133a134
>    <|>=  L1 <$> gparseJSONf set mc smf enm
135d135
< 
137d136
<   gtoJSONf set mc enm (x :*: y) =
138d136
<     case (gtoJSONf set mc enm x, gtoJSONf set mc enm y) of
139d136
<       (Left  xvs, Left  yvs) -> Left  (xvs ++ yvs)
140d136
<       (Right xvs, Right yvs) -> Right (xvs ++ yvs)
141d136
<       _                      -> error "The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."
142d136
< instance (GfromJson f, GfromJson g) => GfromJson (f :*: g) where
143d136
<   gparseJSONf set mc smf enm =
144d136
<     do unless smf selFields
145d136
<        (:*:) <$> gparseJSONf set mc True enm <*> gparseJSONf set mc True enm
146d136
<     where
147d136
<       selFields =
148d136
<         do v <- pop
149d136
<            case v of
150d136
<              o@Object{} -> put (repeat o)
151c137
<              Array vs   -> put (V.toList vs)
---
> instancegtoJSONfGtoJsonset mc fenm, GtoJson(x :*: g) =>=  GtoJson (f :*: g) where
151a138
>   gtoJSONfcase (gtoJSONf mc enmset(xmc:*:enmy),=gtoJSONf set mc enm y) of
151a139
>     case(LeftgtoJSONfxvs, Left mcyvs) ->,Left(xvsset++ mcyvsenm)   y) of
151a140
>       (LeftRight xvs, LeftRight yvs) -> LeftRight (xvs ++ yvs)
151a141
>       (Right xvs, Right yvs) -> Right ("The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."xvs ++ yvs)
151a142
> instance  (GfromJson f, GfromJson errorg) =>"The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."GfromJson (f :*: g) where
151a143
> instancegparseJSONfGfromJsonset mcf,smfenm =   g) => GfromJson (f :*: g) where
151a144
>   gparseJSONfdo unless set mcselFields enm =
151a145
>     do unless(:*:) <$>gparseJSONf  set mc True enm <*> gparseJSONf set mc True enm
151a146
>     where:*:) <$> gparseJSONf set mc True enm <*> gparseJSONf set mc True enm
151a147
>     whereselFields =
151a148
>       selFieldsdo v <- =pop
151a149
>         do vcase<- popv of
151a150
>            caseo@Object of {} -> put (repeat o)
151a151
>              oArray@Objectvs{} -> put (repeatV.toList)vs)
151a152
>              Array_     vs   -> putfail(V.toList"Expected object or array in gparseJSONf for (:*:).")
153d153
< 
155d154
<   gtoJSONf set a b (M1 x) = gtoJSONf set a b x
156c155
< instance GfromJson f => GfromJson (M1 D c f) where
---
> instancegtoJSONfset a f =>(M1GtoJsonx) = gtoJSONfM1 D cset) wherea b x
156a156
> instanceGfromJson a b (M1=>x)GfromJson= gtoJSONf(M1setD cafb xwhere
156a157
> instancegparseJSONfset afb=>x GfromJson= M1 <$> gparseJSONfM1 D c f) whereset a b x
158d158
< 
160d159
<   gtoJSONf set _  True  (M1 _) = Left [toJSON $ conNameT set (undefined :: M1 C c f p)]
161d159
<   gtoJSONf set mc False (M1 x) =
162d159
<     case gtoJSONf set mc False x of
163d159
<       -- Single field constructors are not wrapped in an array.
164d159
<       Left  [v] -> Left [wrap v]
165d159
<       Left  vs  -> Left [wrap . Array $ V.fromList vs]
166d159
<       Right vs  -> Left [wrap $ toObject vs]
167d159
<     where
168d159
<       wrap = if mc
169d159
<              then toObject
170d159
<                 . return
171d159
<                 . (conNameT set (undefined :: M1 C c f p), )
172d159
<              else id
173d159
< instance (Constructor c, GfromJson f) => GfromJson (M1 C c f) where
174d159
<   gparseJSONf set mc smf True =
175d159
<     do str    <- pop
176d159
<        conStr <- lift (parseJSON str)
177d159
<        let expectedConStr = conNameT set (undefined :: M1 C c f p)
178d159
<        unless (conStr == expectedConStr) $
179d159
<          fail $ "Error parsing enumeration: expected " ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
180d159
<        M1 <$> gparseJSONf set mc smf True
181d159
<   gparseJSONf set mc smf False =
182d159
<     do
183d159
<        when mc (selProp "C" propName)
184d159
<        M1 <$> gparseJSONf set mc smf False
185d159
<     where
186d159
<       propName = case conNameT set (undefined :: M1 C c f p) of
187c160
<         "" -> Nothing
---
> instancegtoJSONfConstructorset _  Truec,(GtoJsonM1 _) = fLeft) =>[GtoJsontoJSON $(M1conNameT c f)setwhere(undefined :: M1 C c f p)]
187a161
>   gtoJSONf set _mc TrueFalse (M1 _) = Left [toJSON $ conNameT set (undefined :: M1 C c f p)]
187a162
>   gtoJSONfcase gtoJSONf mc Falseset mc(M1False) = of
187a163
>     case-- Single field constructors are not wrapped in an array. set mc False x of
187a164
>       Left-- Single field constructors are not wrapped in an array.[v] -> Left [wrap v]
187a165
>       Left  [vsv] -> Left [wrap v]Array $ V.fromList vs]
187a166
>       LeftRight vs  -> Left [wrap . ArraytoObject V.fromListvs]       vs]
187a167
>     where vs  -> Left [wrap $ toObject vs]
187a168
>     wherewrap = if mc
187a169
>       wrap = ifthentoObject
187a170
>              then. toObjectreturn
187a171
>                 . return(conNameT set (undefined :: M1 C c f p), )
187a172
>              else (idconNameT set (undefined :: M1 C c f p), )
187a173
> instance (Constructorelse id  c, GfromJson f) => GfromJson (M1 C c f) where
187a174
> instancegparseJSONfConstructorset mc smf, GfromJsonTrue =    f) => GfromJson (M1 C c f) where
187a175
>   gparseJSONfdo str    set<- pop smf True =
187a176
>     do strconStr <- poplift (parseJSON str)
187a177
>        conStrlet expectedConStr<- lift (parseJSON= conNameT)set (undefined :: M1 C c f p)
187a178
>        letunless(conStr == expectedConStr= conNameT set) (undefined :: M1 C c f p)
187a179
>        unlessfail (conStr"Error parsing enumeration: expected " expectedConStr) $             ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
187a180
>        M1fail<$> $gparseJSONfset mc smf True              ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
187a181
>   gparseJSONf <$> gparseJSONfset mc smf False mc= smf True
187a182
>   gparseJSONfdo        set mc smf False =
187a183
>     do when mc (selProp "C" propName)
187a184
>        whenM1 <$>gparseJSONfselProp "C"setmc smf)False
187a185
>     where <$> gparseJSONf set mc smf False
187a186
>     wherepropName = case conNameT set (undefined :: M1 C c f p) of
187a187
>       propName"" -> Nothing= case conNameT set (undefined :: M1 C c f p) of
187a188
>         ""n  -> NothingJust n
189d189
< 
191d190
<   gtoJSONf set mc enm (M1 x) =
192d190
<     case gtoJSONf set mc enm x of
193d190
<       Left  [v] -> case selNameT set (undefined :: M1 S c f p) of
194d190
<         Nothing -> Left [v]
195d190
<         Just n  -> Right [(n, v)]
196d190
<       Left  _   -> error "The impossible happened: multiple returned values inside label in GJSON instance for S."
197d190
<       Right _   -> error "The impossible happened: label inside a label in GJSON instance for S."
198d190
< instance (Selector c, GfromJson f) => GfromJson (M1 S c f) where
199d190
<   gparseJSONf set mc smf enm =
200d190
<     do selProp "S" propName
201d190
<        M1 <$> gparseJSONf set mc smf enm
202c191
<     where
---
> instancegtoJSONfSelectorset mc enm, GtoJson(M1 x) =f) => GtoJson (M1 S c f) where
202a192
>   gtoJSONfcase gtoJSONf mc enm (mcM1enm) = of
202a193
>     caseLeft[v] ->setcaseselNameT x ofset (undefined :: M1 S c f p) of
202a194
>       LeftNothingv] -> case selNameT[v]      set (undefined :: M1 S c f p) of
202a195
>         NothingJust n  -> LeftRight[v]n, v)]
202a196
>       Left_n  -> Right ["The impossible happened: multiple returned values inside label in GJSON instance for S."(n, v)]
202a197
>       LeftRight _   -> error "The impossible happened: multiple returned values inside label in GJSON instance for S.""The impossible happened: label inside a label in GJSON instance for S."
202a198
> instance(Selector   -> errorc, GfromJsonf) => GfromJson (M1 S c f) where
202a199
> instancegparseJSONfSelectorset mc,smfenm =  f) => GfromJson (M1 S c f) where
202a200
>   gparseJSONfdo selPropset"S"mcpropName enm =
202a201
>     do selPropM1 <$> gparseJSONf propNameset mc smf enm
202a202
>     where <$> gparseJSONf set mc smf enm
202a203
>     wherepropName = selNameT set (undefined :: M1 S c f p)
204d204
< 
206d205
<   gtoJSONf set   _  _   (M1 (K1 n@Nothing)) = case selNameT set (undefined :: M1 S c f p) of
207d205
<     Nothing -> Left [toJSON n]
208d205
<     Just _  -> Right []
209d205
<   gtoJSONf set mc enm (M1 (K1 (Just x))) = gtoJSONf set mc enm (M1 (K1 x) :: (M1 S c (K1 i a)) p)
210d205
< instance (Selector c, FromJSON a) => GfromJson (M1 S c (K1 i (Maybe a))) where
211d205
<   gparseJSONf set mc smf enm =
212d205
<     do (M1 (K1 x)) <- parser
213d205
<        return (M1 (K1 (Just x)))
214d205
<     <|>
215d205
<     do case selNameT set (undefined :: M1 S c (K1 i a) p) of
216d205
<          Nothing ->
217d205
<            do o <- pop
218d205
<               M1 . K1 <$> lift (parseJSON o)
219d205
<          Just n  ->
220d205
<            do o <- pop
221d205
<               case o of
222d205
<                 Object h | H.member n h -> error impossible <$> parser
223d205
<                          | otherwise    -> return $ M1 (K1 Nothing)
224d205
<                 _ -> lift $ typeMismatch "Object" (Array V.empty)
225d205
<     where
226c206
<       parser = (gparseJSONf set mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
---
> instancegtoJSONfSelectorset   _ c, ToJSON(M1 (aK1) =>n@Nothing))(M1= case c (selNameTK1 i (Maybeset a)undefined)) where :: M1 S c f p) of
226a207
>   gtoJSONfNothingset-> Left  _toJSONM1 (K1]  n@Nothing)) = case selNameT set (undefined :: M1 S c f p) of
226a208
>     NothingJust _  -> LeftRight[toJSON[]     n]
226a209
>   gtoJSONf _ set Rightmc enm[]M1 (K1 (Just x))) = gtoJSONf set mc enm (M1 (K1 x) :: (M1 S c (K1 i a)) p)
226a210
> instance(Selector mc enmc, (FromJSONM1 (K1 (Justa) =>x)GfromJson)) = gtoJSONf(M1 Ssetc (mc enmi (MaybeM1 (K1a))x)where:: (M1 S c (K1 i a)) p)
226a211
> instancegparseJSONfSelectorset mc,smfenm = a) => GfromJson (M1 S c (K1 i (Maybe a))) where
226a212
>   gparseJSONfdo (M1 (K1setx))mc<-smfparser =
226a213
>     do (returnM1 (K1(xM1))(<- parser(Just x)))
226a214
>     <|>return (M1 (K1 (Just x)))
226a215
>     <|>do case selNameT set (undefined :: M1 S c (K1 i a) p) of
226a216
>     do caseNothing->  set (undefined :: M1 S c (K1 i a) p) of
226a217
>          Nothingdo o <-pop
226a218
>            do oM1<-. popK1 <$> lift (parseJSON o)
226a219
>          Just M1n  .->K1 <$> lift (parseJSON o)
226a220
>          Justdo n  <-pop
226a221
>            do ocase<- popo of
226a222
>               caseObject ofh | H.member n h -> error impossible <$> parser
226a223
>                 Object h | H.memberotherwisen h -> errorreturnimpossible$ M1 (K1 Nothing parser)
226a224
>                 _ -> lift|$otherwisetypeMismatch->"Object" $Array (K1V.empty) )
226a225
>     where       _ -> lift $ typeMismatch "Object" (Array V.empty)
226a226
>     whereparser = (gparseJSONf set mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
226a227
>       parserimpossible= (gparseJSONf= "The impossible happened: parser succeeded after failing in GfromJson S Maybe" mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
228d228
< 
230d229
< selProp cname propName =
231d229
<   case propName of
232d229
<     Nothing -> do o <- pop
233d229
<                   modify (o:)
234d229
<     Just p  -> do o <- pop
235d229
<                   v <- lift (withObject ("Expected property " ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
236c230
<                                         (.: p) o)
---
> selProp ::cnamepropName-> Maybe= Text -> StateT [Value] Parser ()
236a231
> selPropcase propName propNameof     =
236a232
>   caseNothing-> doofo <- pop
236a233
>     Nothing -> do omodify<- pop(o:)
236a234
>     Just p  -> do modifyo <- popo:)
236a235
>     Just p  -> do o <- poplift (withObject ("Expected property " ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
236a236
>                   v <- lift (withObject ("Expected property ".: p) o)             ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
236a237
>                   modify (v:)           (.: p) o)
238d238
< 
240d239
< pop =
241d239
<   do (v:vs) <- get
242c240
<      put vs
---
> pop ::=  MonadState [Value] m => m Value
242a241
> popdo=(v:vs) <- get
242a242
>   do (putv:vsvs) <- get
242a243
>      putreturn v
244d244
< 
246c246
< toObject = object . map (uncurry (.=))
---
> toObject ::= object.vmap=> [(uncurryText, v)].=->)) Value
246a247
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    CPP
  , FlexibleContexts
  , FlexibleInstances
  , OverlappingInstances
  , OverloadedStrings
  , ScopedTypeVariables
  , TupleSections
  , TypeOperators
  #-}
-- | This module offers generic conversions to an from JSON 'Value's
-- for data types with a 'Generic' instance.
--
-- The structure of the generated JSON is meant to be close to
-- idiomatic JSON. This means:
--
-- * Enumerations are converted to JSON strings.
--
-- * Record fields become JSON keys.
--
-- * Data types with one unlabeled field convert to just that field.
--
-- * Data types with multiple unlabeled fields become arrays.
--
-- * Multiple constructors are represented by keys.
--
-- * 'Maybe' values are either an absent key, or the value.
--
-- See 'tests/Main.hs' for more examples.
module Generics.Generic.Aeson
  ( gtoJson
  , gparseJson
  , GtoJson (..)
  , GfromJson (..)
  , formatLabel
  , Settings (..)
  , defaultSettings
  , gtoJsonWithSettings
  , gparseJsonWithSettings
  ) where

import Control.Applicative
import Control.Monad.Error
import Control.Monad.State
import Data.Aeson
import Data.Aeson.Types hiding (GFromJSON, GToJSON)
import Data.Proxy
import Data.Text (Text)
import GHC.Generics
import Generics.Deriving.ConNames
import qualified Data.HashMap.Strict as H
import qualified Data.Text           as T
import qualified Data.Vector         as V

import Generics.Generic.Aeson.Util

-- | Class for converting the functors from "GHC.Generics" to JSON.
-- You generally don't need to give any custom instances. Just add
-- 'deriving Generic' and call 'gToJson'.
class GtoJson f where
  -- | Generically show a functor as a JSON value.  The first argument
  -- tells us if there are multiple constructors in the data type. The
  -- second indicates if this data type is an enumeration (only empty
  -- constructors). A functor is then converted to either a list
  -- of values (for non-labeled fields) or a list of String/value
  -- pairs (for labeled fields).
  gtoJSONf :: Settings -> Bool -> Bool -> f a -> Either [Value] [(Text, Value)]

-- | Class for parsing the functors from "GHC.Generics" from JSON.
-- You generally don't need to give any custom instances. Just add
-- 'deriving Generic' and call 'gFromJson'.
class GfromJson f where
  -- | Generically read a functor from a JSON value.  The first
  -- argument tells us if there are multiple constructors in the data
  -- type. The second indicates if we've already detected that this
  -- data type has multiple constructors. When this is False, the
  -- (:*:) puts the fields in the state. The third indicates if this
  -- data type is an enumeration (only empty constructors). The third
  -- is a function for parsing the recursive positions. A JSON value
  -- is then parsed to either a functor, or a failure.
  gparseJSONf :: Settings -> Bool -> Bool -> Bool -> StateT [Value] Parser (f a)

-- Void: Used for data types without constructors
-- instance GJSON V1

-- Unit: Used for constructors without arguments
instance GtoJson U1 where
  gtoJSONf _ _ _ U1 = Right []
instance GfromJson U1 where
  gparseJSONf _ _ _ _ = return U1

-- | Convert any datatype with a 'Generic' instance to a JSON 'Value'.

gtoJson
  :: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  => a -> Value
gtoJson = gtoJsonWithSettings defaultSettings

gtoJsonWithSettings
  :: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
   => Settings -> a -> Value
gtoJsonWithSettings settings x =
  case gtoJSONf settings (multipleConstructors $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
    Left  [v] -> v
    Left  _   -> error "The impossible happened: multiple returned values in gtoJSON."
    Right _   -> error "The impossible happened: labeled values returned in gtoJSON."

-- | Parse any datatype with a 'Generic' instance from a JSON 'Value'.
gparseJson
  :: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  => Value -> Parser a
gparseJson = gparseJsonWithSettings defaultSettings

gparseJsonWithSettings
  :: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  => Settings -> Value -> Parser a
gparseJsonWithSettings set
  = fmap to
  . evalStateT (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
  . return

-- Structure type for constant values.
instance (ToJSON c) => GtoJson (K1 a c) where
  gtoJSONf _ _ _ (K1 a) = Left [toJSON a]
instance (FromJSON c) => GfromJson (K1 a c) where
  gparseJSONf _ _ _ _   = lift . fmap K1 . parseJSON =<< pop

instance (GtoJson f, GtoJson g) => GtoJson (f :+: g) where
  gtoJSONf set mc enm (L1 x) = gtoJSONf set mc enm x
  gtoJSONf set mc enm (R1 x) = gtoJSONf set mc enm x
instance (GfromJson f, GfromJson g) => GfromJson (f :+: g) where
  gparseJSONf set mc smf enm
    =  L1 <$> gparseJSONf set mc smf enm
   <|> R1 <$> gparseJSONf set mc smf enm

instance (GtoJson f, GtoJson g) => GtoJson (f :*: g) where
  gtoJSONf set mc enm (x :*: y) =
    case (gtoJSONf set mc enm x, gtoJSONf set mc enm y) of
      (Left  xvs, Left  yvs) -> Left  (xvs ++ yvs)
      (Right xvs, Right yvs) -> Right (xvs ++ yvs)
      _                      -> error "The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."
instance (GfromJson f, GfromJson g) => GfromJson (f :*: g) where
  gparseJSONf set mc smf enm =
    do unless smf selFields
       (:*:) <$> gparseJSONf set mc True enm <*> gparseJSONf set mc True enm
    where
      selFields =
        do v <- pop
           case v of
             o@Object{} -> put (repeat o)
             Array vs   -> put (V.toList vs)
             _          -> fail "Expected object or array in gparseJSONf for (:*:)."

instance GtoJson f => GtoJson (M1 D c f) where
  gtoJSONf set a b (M1 x) = gtoJSONf set a b x
instance GfromJson f => GfromJson (M1 D c f) where
  gparseJSONf set a b x = M1 <$> gparseJSONf set a b x

instance (Constructor c, GtoJson f) => GtoJson (M1 C c f) where
  gtoJSONf set _  True  (M1 _) = Left [toJSON $ conNameT set (undefined :: M1 C c f p)]
  gtoJSONf set mc False (M1 x) =
    case gtoJSONf set mc False x of
      -- Single field constructors are not wrapped in an array.
      Left  [v] -> Left [wrap v]
      Left  vs  -> Left [wrap . Array $ V.fromList vs]
      Right vs  -> Left [wrap $ toObject vs]
    where
      wrap = if mc
             then toObject
                . return
                . (conNameT set (undefined :: M1 C c f p), )
             else id
instance (Constructor c, GfromJson f) => GfromJson (M1 C c f) where
  gparseJSONf set mc smf True =
    do str    <- pop
       conStr <- lift (parseJSON str)
       let expectedConStr = conNameT set (undefined :: M1 C c f p)
       unless (conStr == expectedConStr) $
         fail $ "Error parsing enumeration: expected " ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
       M1 <$> gparseJSONf set mc smf True
  gparseJSONf set mc smf False =
    do
       when mc (selProp "C" propName)
       M1 <$> gparseJSONf set mc smf False
    where
      propName = case conNameT set (undefined :: M1 C c f p) of
        "" -> Nothing
        n  -> Just n

instance (Selector c, GtoJson f) => GtoJson (M1 S c f) where
  gtoJSONf set mc enm (M1 x) =
    case gtoJSONf set mc enm x of
      Left  [v] -> case selNameT set (undefined :: M1 S c f p) of
        Nothing -> Left [v]
        Just n  -> Right [(n, v)]
      Left  _   -> error "The impossible happened: multiple returned values inside label in GJSON instance for S."
      Right _   -> error "The impossible happened: label inside a label in GJSON instance for S."
instance (Selector c, GfromJson f) => GfromJson (M1 S c f) where
  gparseJSONf set mc smf enm =
    do selProp "S" propName
       M1 <$> gparseJSONf set mc smf enm
    where
      propName = selNameT set (undefined :: M1 S c f p)

instance (Selector c, ToJSON a) => GtoJson (M1 S c (K1 i (Maybe a))) where
  gtoJSONf set   _  _   (M1 (K1 n@Nothing)) = case selNameT set (undefined :: M1 S c f p) of
    Nothing -> Left [toJSON n]
    Just _  -> Right []
  gtoJSONf set mc enm (M1 (K1 (Just x))) = gtoJSONf set mc enm (M1 (K1 x) :: (M1 S c (K1 i a)) p)
instance (Selector c, FromJSON a) => GfromJson (M1 S c (K1 i (Maybe a))) where
  gparseJSONf set mc smf enm =
    do (M1 (K1 x)) <- parser
       return (M1 (K1 (Just x)))
    <|>
    do case selNameT set (undefined :: M1 S c (K1 i a) p) of
         Nothing ->
           do o <- pop
              M1 . K1 <$> lift (parseJSON o)
         Just n  ->
           do o <- pop
              case o of
                Object h | H.member n h -> error impossible <$> parser
                         | otherwise    -> return $ M1 (K1 Nothing)
                _ -> lift $ typeMismatch "Object" (Array V.empty)
    where
      parser = (gparseJSONf set mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
      impossible = "The impossible happened: parser succeeded after failing in GfromJson S Maybe"

selProp :: Text -> Maybe Text -> StateT [Value] Parser ()
selProp cname propName =
  case propName of
    Nothing -> do o <- pop
                  modify (o:)
    Just p  -> do o <- pop
                  v <- lift (withObject ("Expected property " ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
                                        (.: p) o)
                  modify (v:)

pop :: MonadState [Value] m => m Value
pop =
  do (v:vs) <- get
     put vs
     return v

toObject :: ToJSON v => [(Text, v)] -> Value
toObject = object . map (uncurry (.=))
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    CPP
  , FlexibleContexts
  , FlexibleInstances
  , OverlappingInstances
  , OverloadedStrings
  , ScopedTypeVariables
  , TupleSections
  , TypeOperators
  #-}
-- | This module offers generic conversions to an from JSON 'Value's
-- for data types with a 'Generic' instance.-- | This module offers generic conversions to an from JSON 'Value's
---- for data types with a 'Generic' instance.
---- The structure of the generated JSON is meant to be close to
-- idiomatic JSON. This means:-- The structure of the generated JSON is meant to be close to
---- idiomatic JSON. This means:
---- * Enumerations are converted to JSON strings.
---- * Enumerations are converted to JSON strings.
---- * Record fields become JSON keys.
---- * Record fields become JSON keys.
---- * Data types with one unlabeled field convert to just that field.
---- * Data types with one unlabeled field convert to just that field.
---- * Data types with multiple unlabeled fields become arrays.
---- * Data types with multiple unlabeled fields become arrays.
---- * Multiple constructors are represented by keys.
---- * Multiple constructors are represented by keys.
---- * 'Maybe' values are either an absent key, or the value.
---- * 'Maybe' values are either an absent key, or the value.
---- See 'tests/Main.hs' for more examples.
module-- See 'tests/Main.hs' for more examples.Generics.Generic.Aeson
module( gtoJsonGenerics.Generic.Aeson
  ( gtoJsongparseJson
  , gparseJsonGtoJson (..)
  , GtoJsonGfromJson(..()..)
  , GfromJsonformatLabel(..)
  , formatLabelSettings (..)
  , SettingsdefaultSettings(..)
  , defaultSettingsgtoJsonWithSettings
  , gtoJsonWithSettingsgparseJsonWithSettings
  , gparseJsonWithSettingswhere
  ) where
import Control.Applicative
import Control.Applicative
import Control.Monad.Error
import Control.Monad.StateData.Aeson
import Data.AesonData.Aeson.Types hiding (GFromJSON, GToJSON)
import Data.Aeson.TypesData.Proxy       hiding (GFromJSON, GToJSON)
import Data.ProxyData.Text (Text)
import Data.TextGHC.GenericsText)
import GHC.GenericsGenerics.Deriving.ConNames
import Generics.Deriving.ConNamesqualified Data.HashMap.Strict as H
import qualified Data.HashMap.StrictData.Text           as H
import qualified Data.TextData.Vector         as T
import qualified Data.Vector         as V
import Generics.Generic.Aeson.Util
import Generics.Generic.Aeson.Util
-- | Class for converting the functors from "GHC.Generics" to JSON.
-- You generally don't need to give any custom instances. Just add-- | Class for converting the functors from "GHC.Generics" to JSON.
-- 'deriving Generic' and call 'gToJson'.-- You generally don't need to give any custom instances. Just add
class-- 'deriving Generic' and call 'gToJson'.GtoJson f where
class-- | Generically show a functor as a JSON value.  The first argument f where
  -- | Generically show a functor as a JSON value.  The first argument
  -- second indicates if this data type is an enumeration (only empty-- tells us if there are multiple constructors in the data type. The
  -- constructors). A functor is then converted to either a list-- second indicates if this data type is an enumeration (only empty
  -- constructors). A functor is then converted to either a list-- of values (for non-labeled fields) or a list of String/value
  -- pairs (for labeled fields).-- of values (for non-labeled fields) or a list of String/value
  gtoJSONf-- pairs (for labeled fields).:: Settings -> Bool -> Bool -> f a -> Either [Value] [(Text, Value)]
  gtoJSONf :: Settings -> Bool -> Bool -> f a -> Either [Value] [(Text, Value)]
-- | Class for parsing the functors from "GHC.Generics" from JSON.
-- | Class for parsing the functors from "GHC.Generics" from JSON.
-- 'deriving Generic' and call 'gFromJson'.-- You generally don't need to give any custom instances. Just add
class-- 'deriving Generic' and call 'gFromJson'.GfromJson f where
class-- | Generically read a functor from a JSON value.  The first f where
  -- | Generically read a functor from a JSON value.  The first-- argument tells us if there are multiple constructors in the data
  -- type. The second indicates if we've already detected that this-- argument tells us if there are multiple constructors in the data
  -- data type has multiple constructors. When this is False, the-- type. The second indicates if we've already detected that this
  -- data type has multiple constructors. When this is False, the-- (:*:) puts the fields in the state. The third indicates if this
  -- (:*:) puts the fields in the state. The third indicates if this-- data type is an enumeration (only empty constructors). The third
  -- is a function for parsing the recursive positions. A JSON value-- data type is an enumeration (only empty constructors). The third
  -- is then parsed to either a functor, or a failure.-- is a function for parsing the recursive positions. A JSON value
  gparseJSONf-- is then parsed to either a functor, or a failure.:: Settings -> Bool -> Bool -> Bool -> StateT [Value] Parser (f a)
  gparseJSONf :: Settings -> Bool -> Bool -> Bool -> StateT [Value] Parser (f a)
-- Void: Used for data types without constructors
-- instance GJSON V1-- Void: Used for data types without constructors
-- instance GJSON V1
-- Unit: Used for constructors without arguments
instance-- Unit: Used for constructors without argumentsGtoJson U1 where
instancegtoJSONf_ _ _ U1 where= Right []
instanceGfromJson _ _ U1U1= Right []
instancegparseJSONf_ _ _U1_ where= return U1
  gparseJSONf _ _ _ _ = return U1
-- | Convert any datatype with a 'Generic' instance to a JSON 'Value'.
-- | Convert any datatype with a 'Generic' instance to a JSON 'Value'.
gtoJson
gtoJson:: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  :: foralla -> Value. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
gtoJson=> a ->= ValuegtoJsonWithSettings defaultSettings
gtoJson = gtoJsonWithSettings defaultSettings
gtoJsonWithSettings
gtoJsonWithSettings:: forall a. (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  ::=>forallSettings. (->Generica -> Value, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
gtoJsonWithSettings=> Settings -> a ->settings x =
gtoJsonWithSettingscase gtoJSONf settings(multipleConstructors =               $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
  caseLeft[v] ->settingsv       (multipleConstructors $ conNames x) (isEnum (Proxy :: Proxy a)) (from x) of
    Left  [v] -> verror "The impossible happened: multiple returned values in gtoJSON."
    LeftRight _   -> error "The impossible happened: multiple returned values in gtoJSON.""The impossible happened: labeled values returned in gtoJSON."
    Right _   -> error "The impossible happened: labeled values returned in gtoJSON."
-- | Parse any datatype with a 'Generic' instance from a JSON 'Value'.
gparseJson-- | Parse any datatype with a 'Generic' instance from a JSON 'Value'.
gparseJson:: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  :: forallValue ->.ParserGenerica  a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
gparseJson=> Value ->= gparseJsonWithSettings a              defaultSettings
gparseJson = gparseJsonWithSettings defaultSettings
gparseJsonWithSettings
gparseJsonWithSettings:: forall a. (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a))
  :: forallSettings.->GenericValue ->,Parsera   (Rep a), ConNames (Rep a), GIsEnum (Rep a))
gparseJsonWithSettings=> Settings -> Value ->setParser a
gparseJsonWithSettings= fmap to            set
  = fmapevalStateT    (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
  . evalStateTreturn     (gparseJSONf set (multipleConstructors $ conNames (undefined :: a)) False (isEnum (Proxy :: Proxy a)))
  . return
-- Structure type for constant values.
instance-- Structure type for constant values.(ToJSON c) => GtoJson (K1 a c) where
instancegtoJSONfToJSON_ _ _ c)K1=>a)GtoJson= Left (K1toJSON c)awhere]
instance(FromJSON _ _ (K1c)a)=>=GfromJson [toJSON(K1 a]c) where
instancegparseJSONfFromJSON_ _ _c) =>=GfromJsonlift . fmapK1K1 c)parseJSONwhere    =<< pop
  gparseJSONf _ _ _ _   = lift . fmap K1 . parseJSON =<< pop
instance (GtoJson f, GtoJson g) => GtoJson (f :+: g) where
instancegtoJSONfGtoJsonset mc fenm, GtoJson(L1 x) g)gtoJSONf=> GtoJsonset(fmc:+:enmg) where
  gtoJSONf set mc enm (L1 x) = gtoJSONf set mc enm x
instance(GfromJson mc enmf,(R1GfromJson) = gtoJSONfg) => GfromJson mc enm(fx:+: g) where
instancegparseJSONfGfromJsonset mcf,smfenm     g) => GfromJson (f :+: g) where
  gparseJSONf=  L1 <$> setgparseJSONf smf enmset mc smf enm
   <|>=  L1 <$> gparseJSONf set mc smf enm
   <|> R1 <$> gparseJSONf set mc smf enm
instance (GtoJson f, GtoJson g) => GtoJson (f :*: g) where
instancegtoJSONfGtoJsonset mc fenm, GtoJson(x :*: g) =>=  GtoJson (f :*: g) where
  gtoJSONfcase (gtoJSONf mc enmset(xmc:*:enmy),=gtoJSONf set mc enm y) of
    case(LeftgtoJSONfxvs, Left mcyvs) ->,Left(xvsset++ mcyvsenm)   y) of
      (LeftRight xvs, LeftRight yvs) -> LeftRight (xvs ++ yvs)
      (Right xvs, Right yvs) -> Right ("The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."xvs ++ yvs)
instance  (GfromJson f, GfromJson errorg) =>"The impossible happened: product of mixed label and non-label fields in GJSON instance for (:*:)."GfromJson (f :*: g) where
instancegparseJSONfGfromJsonset mcf,smfenm =   g) => GfromJson (f :*: g) where
  gparseJSONfdo unless set mcselFields enm =
    do unless(:*:) <$>gparseJSONf  set mc True enm <*> gparseJSONf set mc True enm
    where:*:) <$> gparseJSONf set mc True enm <*> gparseJSONf set mc True enm
    whereselFields =
      selFieldsdo v <- =pop
        do vcase<- popv of
           caseo@Object of {} -> put (repeat o)
             oArray@Objectvs{} -> put (repeatV.toList)vs)
             Array_     vs   -> putfail(V.toList"Expected object or array in gparseJSONf for (:*:).")
             _          -> fail "Expected object or array in gparseJSONf for (:*:)."
instance GtoJson f => GtoJson (M1 D c f) where
instancegtoJSONfset a f =>(M1GtoJsonx) = gtoJSONfM1 D cset) wherea b x
instanceGfromJson a b (M1=>x)GfromJson= gtoJSONf(M1setD cafb xwhere
instancegparseJSONfset afb=>x GfromJson= M1 <$> gparseJSONfM1 D c f) whereset a b x
  gparseJSONf set a b x = M1 <$> gparseJSONf set a b x
instance (Constructor c, GtoJson f) => GtoJson (M1 C c f) where
instancegtoJSONfConstructorset _  Truec,(GtoJsonM1 _) = fLeft) =>[GtoJsontoJSON $(M1conNameT c f)setwhere(undefined :: M1 C c f p)]
  gtoJSONf set _mc TrueFalse (M1 _) = Left [toJSON $ conNameT set (undefined :: M1 C c f p)]
  gtoJSONfcase gtoJSONf mc Falseset mc(M1False) = of
    case-- Single field constructors are not wrapped in an array. set mc False x of
      Left-- Single field constructors are not wrapped in an array.[v] -> Left [wrap v]
      Left  [vsv] -> Left [wrap v]Array $ V.fromList vs]
      LeftRight vs  -> Left [wrap . ArraytoObject V.fromListvs]       vs]
    where vs  -> Left [wrap $ toObject vs]
    wherewrap = if mc
      wrap = ifthentoObject
             then. toObjectreturn
                . return(conNameT set (undefined :: M1 C c f p), )
             else (idconNameT set (undefined :: M1 C c f p), )
instance (Constructorelse id  c, GfromJson f) => GfromJson (M1 C c f) where
instancegparseJSONfConstructorset mc smf, GfromJsonTrue =    f) => GfromJson (M1 C c f) where
  gparseJSONfdo str    set<- pop smf True =
    do strconStr <- poplift (parseJSON str)
       conStrlet expectedConStr<- lift (parseJSON= conNameT)set (undefined :: M1 C c f p)
       letunless(conStr == expectedConStr= conNameT set) (undefined :: M1 C c f p)
       unlessfail (conStr"Error parsing enumeration: expected " expectedConStr) $             ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
       M1fail<$> $gparseJSONfset mc smf True              ++ T.unpack expectedConStr ++ ", found " ++ T.unpack conStr ++ "."
  gparseJSONf <$> gparseJSONfset mc smf False mc= smf True
  gparseJSONfdo        set mc smf False =
    do when mc (selProp "C" propName)
       whenM1 <$>gparseJSONfselProp "C"setmc smf)False
    where <$> gparseJSONf set mc smf False
    wherepropName = case conNameT set (undefined :: M1 C c f p) of
      propName"" -> Nothing= case conNameT set (undefined :: M1 C c f p) of
        ""n  -> NothingJust n
        n  -> Just n
instance (Selector c, GtoJson f) => GtoJson (M1 S c f) where
instancegtoJSONfSelectorset mc enm, GtoJson(M1 x) =f) => GtoJson (M1 S c f) where
  gtoJSONfcase gtoJSONf mc enm (mcM1enm) = of
    caseLeft[v] ->setcaseselNameT x ofset (undefined :: M1 S c f p) of
      LeftNothingv] -> case selNameT[v]      set (undefined :: M1 S c f p) of
        NothingJust n  -> LeftRight[v]n, v)]
      Left_n  -> Right ["The impossible happened: multiple returned values inside label in GJSON instance for S."(n, v)]
      LeftRight _   -> error "The impossible happened: multiple returned values inside label in GJSON instance for S.""The impossible happened: label inside a label in GJSON instance for S."
instance(Selector   -> errorc, GfromJsonf) => GfromJson (M1 S c f) where
instancegparseJSONfSelectorset mc,smfenm =  f) => GfromJson (M1 S c f) where
  gparseJSONfdo selPropset"S"mcpropName enm =
    do selPropM1 <$> gparseJSONf propNameset mc smf enm
    where <$> gparseJSONf set mc smf enm
    wherepropName = selNameT set (undefined :: M1 S c f p)
      propName = selNameT set (undefined :: M1 S c f p)
instance (Selector c, ToJSON a) => GtoJson (M1 S c (K1 i (Maybe a))) where
instancegtoJSONfSelectorset   _ c, ToJSON(M1 (aK1) =>n@Nothing))(M1= case c (selNameTK1 i (Maybeset a)undefined)) where :: M1 S c f p) of
  gtoJSONfNothingset-> Left  _toJSONM1 (K1]  n@Nothing)) = case selNameT set (undefined :: M1 S c f p) of
    NothingJust _  -> LeftRight[toJSON[]     n]
  gtoJSONf _ set Rightmc enm[]M1 (K1 (Just x))) = gtoJSONf set mc enm (M1 (K1 x) :: (M1 S c (K1 i a)) p)
instance(Selector mc enmc, (FromJSONM1 (K1 (Justa) =>x)GfromJson)) = gtoJSONf(M1 Ssetc (mc enmi (MaybeM1 (K1a))x)where:: (M1 S c (K1 i a)) p)
instancegparseJSONfSelectorset mc,smfenm = a) => GfromJson (M1 S c (K1 i (Maybe a))) where
  gparseJSONfdo (M1 (K1setx))mc<-smfparser =
    do (returnM1 (K1(xM1))(<- parser(Just x)))
    <|>return (M1 (K1 (Just x)))
    <|>do case selNameT set (undefined :: M1 S c (K1 i a) p) of
    do caseNothing->  set (undefined :: M1 S c (K1 i a) p) of
         Nothingdo o <-pop
           do oM1<-. popK1 <$> lift (parseJSON o)
         Just M1n  .->K1 <$> lift (parseJSON o)
         Justdo n  <-pop
           do ocase<- popo of
              caseObject ofh | H.member n h -> error impossible <$> parser
                Object h | H.memberotherwisen h -> errorreturnimpossible$ M1 (K1 Nothing parser)
                _ -> lift|$otherwisetypeMismatch->"Object" $Array (K1V.empty) )
    where       _ -> lift $ typeMismatch "Object" (Array V.empty)
    whereparser = (gparseJSONf set mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
      parserimpossible= (gparseJSONf= "The impossible happened: parser succeeded after failing in GfromJson S Maybe" mc smf enm :: StateT [Value] Parser (M1 S c (K1 i a) p))
      impossible = "The impossible happened: parser succeeded after failing in GfromJson S Maybe"
selProp :: Text -> Maybe Text -> StateT [Value] Parser ()
selProp ::cnamepropName-> Maybe= Text -> StateT [Value] Parser ()
selPropcase propName propNameof     =
  caseNothing-> doofo <- pop
    Nothing -> do omodify<- pop(o:)
    Just p  -> do modifyo <- popo:)
    Just p  -> do o <- poplift (withObject ("Expected property " ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
                  v <- lift (withObject ("Expected property ".: p) o)             ++ show propName ++ " in object in gparseJSONf for " ++ show cname ++ ".")
                  modify (v:)           (.: p) o)
                  modify (v:)
pop :: MonadState [Value] m => m Value
pop ::=  MonadState [Value] m => m Value
popdo=(v:vs) <- get
  do (putv:vsvs) <- get
     putreturn v
     return v
toObject :: ToJSON v => [(Text, v)] -> Value
toObject ::= object.vmap=> [(uncurryText, v)].=->)) Value

</pre>