<a href="Chan.hs1580723810704877633.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Char8.hs1534827968280090412.out.html">next</a></br></br><pre>587d586
< -}
588d586
< 
589c587
< -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
---
> -}-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
591d588
< -- if there is no such element.
592c589
< find :: (Char -> Bool) -> ByteString -> Maybe Char
---
> -- if there is no such element.-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
592a590
> find-- and returns the first element in matching the predicate, or 'Nothing':: (Char -> Bool) -> ByteString -> Maybe Char
592a591
> find-- if there is no such element.f ps = w2c `fmap` L.find (f . w2c) ps
592a592
> find{-# INLINE:: (Charfind->#-}) -> ByteString -> Maybe Char
594c594
< {-# INLINE find #-}
---
> {-# INLINE{-
594a595
> -- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
594a596
> -- case of filtering a single Char. It is more efficient to use
594a597
> -- filterChar in this case.
594a598
> --
594a599
> -- > filterChar == filter . (==)
594a600
> --
594a601
> -- filterChar is around 10x faster, and uses much less space, than its
594a602
> -- filter equivalent
594a603
> --
594a604
> filterChar :: Char -> ByteString -> ByteString
594a605
> filterChar c = L.filterByte (c2w c)
594a606
> {-# INLINE filterChar #-}
595a608
> -- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
595a609
> -- case of filtering a single Char out of a list. It is more efficient
595a610
> -- to use /filterNotChar/ in this case.
595a611
> --
595a612
> -- > filterNotChar == filter . (/=)
595a613
> --
595a614
> -- filterNotChar is around 3x faster, and uses much less space, than its
595a615
> -- filter equivalent
595a616
> --
595a617
> filterNotChar :: Char -> ByteString -> ByteString
595a618
> filterNotChar c = L.filterNotByte (c2w c)
595a619
> {-# INLINE filterNotChar #-}
595a620
> -}          #-}
595a621
> 
622d647
< -}
623d647
< 
624c648
< -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
---
> -}-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
626d649
< -- excess elements of the longer ByteString are discarded. This is
627d649
< -- equivalent to a pair of 'unpack' operations, and so space
628d649
< -- usage may be large for multi-megabyte ByteStrings
629d649
< zip :: ByteString -> ByteString -> [(Char,Char)]
630c650
< zip ps qs
---
> -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- excess elements of the longer ByteString are discarded. This is
630a651
> -- equivalent to a pair of 'unpack' operations, and so space-- corresponding pairs of Chars. If one input ByteString is short,
630a652
> -- usage may be large for multi-megabyte ByteStrings-- excess elements of the longer ByteString are discarded. This is
630a653
> zip-- equivalent to a pair of 'unpack' operations, and so space:: ByteString -> ByteString -> [(Char,Char)]
630a654
> zip-- usage may be large for multi-megabyte ByteStringsps qs
630a655
> zip ::| L.nullps ||->L.nullqs = [->]  [(Char,Char)]
630a656
> zip ps| otherwise       = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
632d657
<     | otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
633d657
< 
634c658
< -- | 'zipWith' generalises 'zip' by zipping with the function given as
---
> -- | 'zipWith' generalises 'zip' by zipping with the function given as otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
636d659
< -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
637c660
< -- of corresponding sums.
---
> -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list-- | 'zipWith' generalises 'zip' by zipping with the function given as
637a661
> -- of corresponding sums.-- the first argument, instead of a tupling function.  For example,
637a662
> zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
637a663
> zipWith-- of corresponding sums.f = L.zipWith ((. w2c) . f . w2c)
639d664
< zipWith f = L.zipWith ((. w2c) . f . w2c)
640d664
< 
641c665
< -- | 'lines' breaks a ByteString up into a list of ByteStrings at
---
> zipWith-- | 'lines' breaks a ByteString up into a list of ByteStrings at = L.zipWith ((. w2c) . f . w2c)
643d666
< --
644d666
< -- As of bytestring 0.9.0.3, this function is stricter than its
645d666
< -- list cousin.
646d666
< --
647d666
< lines :: ByteString -> [ByteString]
648d666
< lines Empty          = []
649d666
< lines (Chunk c0 cs0) = loop0 c0 cs0
650d666
<     where
651d666
<     -- this is a really performance sensitive function but the
652d666
<     -- chunked representation makes the general case a bit expensive
653d666
<     -- however assuming a large chunk size and normalish line lengths
654d666
<     -- we will find line endings much more frequently than chunk
655d666
<     -- endings so it makes sense to optimise for that common case.
656c667
<     -- So we partition into two special cases depending on whether we
---
> ---- | 'lines' breaks a ByteString up into a list of ByteStrings at
656a668
> -- As of bytestring 0.9.0.3, this function is stricter than its-- newline Chars. The resulting strings do not contain newlines.
656a669
> ---- list cousin.
656a670
> ---- As of bytestring 0.9.0.3, this function is stricter than its
656a671
> lines-- list cousin.:: ByteString -> [ByteString]
656a672
> --lines Empty          = []
656a673
> lines ::(Chunkc0 cs0)->= [loop0ByteStringc0 cs0]
656a674
> lineswhere          = []
656a675
> lines-- this is a really performance sensitive function but theChunk c0 cs0) = loop0 c0 cs0
656a676
>     where-- chunked representation makes the general case a bit expensive
656a677
>     -- this is a really performance sensitive function but the-- however assuming a large chunk size and normalish line lengths
656a678
>     -- we will find line endings much more frequently than chunk-- chunked representation makes the general case a bit expensive
656a679
>     -- endings so it makes sense to optimise for that common case.-- however assuming a large chunk size and normalish line lengths
656a680
>     -- we will find line endings much more frequently than chunk-- So we partition into two special cases depending on whether we
656a681
>     -- endings so it makes sense to optimise for that common case.-- are keeping back a list of chunks that will eventually be output
656a682
>     -- once we get to the end of the current line.-- So we partition into two special cases depending on whether we
658d683
<     -- once we get to the end of the current line.
659d683
< 
660c684
<     -- the common special case where we have no existing chunks of
---
>     -- once we get to the end of the current line.-- the common special case where we have no existing chunks of
662d685
<     loop0 :: S.ByteString -> ByteString -> [ByteString]
663d685
<     loop0 c cs =
664d685
<         case B.elemIndex (c2w '\n') c of
665d685
<             Nothing -> case cs of
666d685
<                            Empty  | B.null c  ->                 []
667d685
<                                   | otherwise -> Chunk c Empty : []
668c686
<                            (Chunk c' cs')
---
>     loop0-- the common special case where we have no existing chunks of:: S.ByteString -> ByteString -> [ByteString]
668a687
>     loop0-- the current linec cs =
668a688
>     loop0case:: S.ByteStringB.elemIndex (->c2wByteString'\n') c of-> [ByteString]
668a689
>     loop0 c csNothing=    -> case cs of
668a690
>         case B.elemIndex (c2wEmpty) cB.nullof   c  ->                 []
668a691
>             Nothing -> case cs of | otherwise -> Chunk c Empty : []
668a692
>                            Empty(Chunk |c'B.nullcs')  c  ->                 []
668a693
>                                | B.null otherwisec  -> ->loop0c' c Emptycs' : []
668a694
>                            (Chunk| otherwise cs')  -> loop  c' [c] cs'
670d695
<                                | otherwise -> loop  c' [c] cs'
671d695
< 
672c696
<             Just n | n /= 0    -> Chunk (B.unsafeTake n c) Empty
---
>             Just n | n /= 0    |->otherwiseChunk (B.unsafeTake-> loop  c'n[c] cs'Empty
673a698
>             Just n | notherwise 0    -> Chunk (B.unsafeTake n c) Empty
673a699
>                                 : loop0 (B.unsafeDrop (n+1cs) c) cs
675d700
<                                 : loop0 (B.unsafeTail c) cs
676d700
< 
677c701
<     -- the general case when we are building a list of chunks that are
---
>     -- the general case when we are building a list of chunks that are loop0 (B.unsafeTail c) cs
679d702
<     loop :: S.ByteString -> [S.ByteString] -> ByteString -> [ByteString]
680d702
<     loop c line cs =
681d702
<         case B.elemIndex (c2w '\n') c of
682d702
<             Nothing ->
683c703
<                 case cs of
---
>     loop-- the general case when we are building a list of chunks that are:: S.ByteString -> [S.ByteString] -> ByteString -> [ByteString]
683a704
>     loop-- part of the same linec line cs =
683a705
>     loopcase:: S.ByteStringB.elemIndex ->(c2wS.ByteString'\n') c of ] -> ByteString -> [ByteString]
683a706
>     loop c lineNothing =->
683a707
>         case B.elemIndexcase cs ofc2w '\n') c of
683a708
>             Nothing ->Empty -> let c' = revChunks (c : line)
683a709
>                 case cs of    in c' `seq` (c' : [])
685d710
<                               in c' `seq` (c' : [])
686d710
< 
687c711
<                     (Chunk c' cs') -> loop c' (c : line) cs'
---
>                     (Chunk c' incs'c') ->seqloop` (c' :c[])line) cs'
689c713
<             Just n ->
---
>             Just n ->Chunk c' cs') -> loop c' (c : line) cs'
691d714
<                  in c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)
692c715
< 
---
>             Just nin->c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)
692a716
>                 let c' = revChunks (B.unsafeTake n c : line)
714c738
< -}
---
> -}               in c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)
715a740
> {-
716a742
> This function is too strict!  Consider,
716a743
> 
716a744
> > prop_lazy =
716a745
>     (L.unpack . head . lazylines $ L.append (L.pack "a\nb\n") (error "failed"))
716a746
>   ==
716a747
>     "a"
716a748
> 
716a749
> fails.  Here's a properly lazy version of 'lines' for lazy bytestrings
716a750
> 
716a751
>     lazylines           :: L.ByteString -> [L.ByteString]
716a752
>     lazylines s
716a753
>         | L.null s  = []
716a754
>         | otherwise =
716a755
>             let (l,s') = L.break ((==) '\n') s
716a756
>             in l : if L.null s' then []
716a757
>                                 else lazylines (L.tail s')
716a758
> 
716a759
> we need a similarly lazy, but efficient version.
716a760
> 
716a761
> -}
719d763
< unlines :: [ByteString] -> ByteString
720c764
< unlines [] = empty
---
> unlines-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,:: [ByteString] -> ByteString
720a765
> unlines-- after appending a terminating newline to each.[] = empty
720a766
> unlines :: [ByteString(concat $]List.intersperse-> ByteString   nl ss) `append` nl -- half as much space
720a767
> unlineswhere]nl= empty= singleton '\n'
722d768
<     where nl = singleton '\n'
723d768
< 
724c769
< -- | 'words' breaks a ByteString up into a list of words, which
---
> -- | 'words' breaks a ByteString up into a list of words, whichwhere nl = singleton '\n'
726d770
< --
727c771
< -- > tokens isSpace = words
---
> ---- | 'words' breaks a ByteString up into a list of words, which
727a772
> -- > tokens isSpace = words-- were delimited by Chars representing white space. And
729c774
< words :: ByteString -> [ByteString]
---
> words-- > tokens isSpace = words:: ByteString -> [ByteString]
729a775
> --words = List.filter (not . L.null) . L.splitWith isSpaceWord8
729a776
> words{-# INLINE:: ByteStringwords #-}-> [ByteString]
731d777
< {-# INLINE words #-}
732d777
< 
733c778
< -- | The 'unwords' function is analogous to the 'unlines' function, on words.
---
> {-# INLINE-- | The 'unwords' function is analogous to the 'unlines' function, on words. #-}
734a780
> unwords-- | The 'unwords' function is analogous to the 'unlines' function, on words.= intercalate (singleton ' ')
734a781
> unwords{-# INLINE:: [unwordsByteString#-}] -> ByteString
736d782
< {-# INLINE unwords #-}
737d782
< 
738c783
< -- | readInt reads an Int from the beginning of the ByteString.  If
---
> {-# INLINE-- | readInt reads an Int from the beginning of the ByteString.  If #-}
739a785
> -- | readInt reads an Int from the beginning of the ByteString.  If-- Nothing, otherwise it just returns the int read, and the rest of the
739a786
> -- string.-- there is no integer at the beginning of the string, it returns
741d787
< -- string.
742d787
< 
743c788
< {-
---
> -- string.{-
748d792
< -}
749d792
< 
750c793
< readInt :: ByteString -> Maybe (Int, ByteString)
---
> -}readInt :: ByteString -> Maybe (Int, ByteString)
752d794
< readInt Empty        = Nothing
753d794
< readInt (Chunk x xs) = case w2c (B.unsafeHead x) of
754c795
<     '-' -> loop True  0 0 (B.unsafeTail x) xs
---
> readInt ::Empty=->Nothing (Int, ByteString)
754a796
> {-# INLINEreadInt (Chunkx xs#-}) = case w2c (B.unsafeHead x) of
754a797
> readInt'-' Empty-> loop True =0Nothing0 (B.unsafeTail x) xs
754a798
> readInt'+' (->ChunkloopxFalse) =0case0 (B.unsafeTail (B.unsafeHeadx) xs x) of
754a799
>     '-'_   -> loop TrueFalse 0 0 (B.unsafeTailxs          x) xs
756d800
<     _   -> loop False 0 0 x xs
757d800
< 
758c801
<     where loop :: Bool -> Int -> Int
---
>     _whereloop::Bool0-> xInt-> Int
760d802
<           loop !neg !i !n !c !cs
761d802
<               | B.null c = case cs of
762d802
<                              Empty          -> end  neg i n c  cs
763d802
<                              (Chunk c' cs') -> loop neg i n c' cs'
764d802
<               | otherwise =
765d802
<                   case B.unsafeHead c of
766d802
<                     w | w >= 0x30
767d802
<                      && w <= 0x39 -> loop neg (i+1)
768c803
<                                           (n * 10 + (fromIntegral w - 0x30))
---
>     where loop ::!neg!i ->!n Int!c !-> Int
768a804
>               | ->B.nullc = case -> ByteStringof         -> Maybe (Int, ByteString)
768a805
>           loop !neg !i !n !c !Emptycs            -> end  neg i n c  cs
768a806
>               | B.null c = case(Chunk ofc' cs') -> loop neg i n c' cs'
768a807
>               | otherwise =  Empty          -> end  neg i n c  cs
768a808
>                   case B.unsafeHeadChunk c'c of) -> loop neg i n c' cs'
768a809
>               | otherwisew | w =>= 0x30
768a810
>                   case&&B.unsafeHeadw <= 0x39 ->cloopof  neg (i+1)
768a811
>                     w | w >= 0x30         (n * 10 + (fromIntegral w - 0x30))
768a812
>                      && w <= 0x39 -> loop neg(B.unsafeTaili+1)     c) cs
768a813
>                       | otherwise -> end negn * 10n c+csfromIntegral w - 0x30))
770d814
<                       | otherwise -> end neg i n c cs
771d814
< 
772c815
<           {-# INLINE end #-}
---
>           {-# INLINE end otherwise#-}      -> end neg i n c cs
774d816
<           end neg _ n c cs = e `seq` e
775d816
<                 where n' = if neg then negate n else n
776c817
<                       c' = chunk c cs
---
>           {-# INLINEend neg _ nendc cs#-}= e `seq` e
776a818
>           end _ where _ _n' _ =ifNothingneg then negate n else n
776a819
>           end neg _ n cc'cs= =chunk `seqc `cse
776a820
>                 where n'e  = if neg`seqthen` c' negate`seq` Just else$! nn',c')
776a821
>          --                  in n' `seq` c' `seq` JustS n' c' = chunk c cs
779d823
< 
780d823
< 
783d825
< -- otherwise it just returns the int read, and the rest of the string.
784d825
< readInteger :: ByteString -> Maybe (Integer, ByteString)
785d825
< readInteger Empty = Nothing
786d825
< readInteger (Chunk c0 cs0) =
787d825
<         case w2c (B.unsafeHead c0) of
788c826
<             '-' -> first (B.unsafeTail c0) cs0 >>= \(n, cs') -> return (-n, cs')
---
> -- otherwise it just returns the int read, and the rest of the string.-- | readInteger reads an Integer from the beginning of the ByteString.  If
788a827
> readInteger-- there is no integer at the beginning of the string, it returns Nothing,:: ByteString -> Maybe (Integer, ByteString)
788a828
> readInteger-- otherwise it just returns the int read, and the rest of the string.Empty = Nothing
788a829
> readInteger ::(Chunkc0 cs0)->= Maybe (Integer, ByteString)
788a830
> readIntegercaseEmptyw2c (=B.unsafeHead    c0) of
788a831
> readInteger ('-'Chunk-> c0first)B.unsafeTail=           c0) cs0 >>= \(n, cs') -> return (-n, cs')
788a832
>         case'+'->B.unsafeHeadfirst (B.unsafeTail) of  c0) cs0
788a833
>             '-'_   -> first (c0B.unsafeTailcs0        c0) cs0 >>= \(n, cs') -> return (-n, cs')
790d834
<             _   -> first c0 cs0
791d834
< 
792c835
<     where first c cs
---
>     where first   ->c cs c0 cs0
794c837
<                   Empty          -> Nothing
---
>     where first c csEmpty          -> Nothing
794a838
>               | B.null(Chunk =c'casecs')cs->offirst' c' cs'
794a839
>               | otherwise   = first'cNothingcs
796d840
<               | otherwise = first' c cs
797d840
< 
798c841
<           first' c cs = case B.unsafeHead c of
---
>           first' otherwisec cs = case= first'B.unsafeHead cs   c of
799a843
>           first' cloop =1case(fromIntegralw -c0x30of ) [] (B.unsafeTail c) cs
799a844
>               w | wotherwise 0x30 && w <= 0x39 -> JustNothing
801d845
<                 | otherwise              -> Nothing
802d845
< 
803c846
<           loop :: Int -> Int -> [Integer]
---
>           loop :: otherwiseInt -> Int -> [Integer]-> Nothing
805d847
<           loop !d !acc !ns !c !cs
806d847
<               | B.null c = case cs of
807d847
<                              Empty          -> combine d acc ns c cs
808d847
<                              (Chunk c' cs') -> loop d acc ns c' cs'
809d847
<               | otherwise =
810d847
<                   case B.unsafeHead c of
811d847
<                    w | w >= 0x30 && w <= 0x39 ->
812d847
<                        if d < 9 then loop (d+1)
813d847
<                                           (10*acc + (fromIntegral w - 0x30))
814d847
<                                           ns (B.unsafeTail c) cs
815d847
<                                 else loop 1 (fromIntegral w - 0x30)
816c848
<                                           (fromIntegral acc : ns)
---
>           loop ::!d Int!acc->!ns!c->!csInteger]
816a849
>               |->B.nullc = case->csByteStringof        -> (Integer, ByteString)
816a850
>           loop !d !acc !ns !cEmpty!cs           -> combine d acc ns c cs
816a851
>               | B.null c = case(Chunk ofc' cs') -> loop d acc ns c' cs'
816a852
>               | otherwise =  Empty          -> combine d acc ns c cs
816a853
>                   case B.unsafeHeadChunk c'c of) -> loop d acc ns c' cs'
816a854
>               | otherwisew | w >== 0x30 && w <= 0x39 ->
816a855
>                   case B.unsafeHeadif d < 9 thencloopof  (d+1)
816a856
>                    w | w >= 0x30 && w <= 0x39(10*->acc + (fromIntegral w - 0x30))
816a857
>                        if d < 9 then loop (nsd+1)B.unsafeTail c) cs
816a858
>                                 else loop (10(*fromIntegralacc + (fromIntegralw - 0x30w - 0x30))
816a859
>                                           ns(fromIntegralB.unsafeTailaccc) cs)
816a860
>                                 else loop 1B.unsafeTailfromIntegralc)wcs 0x30)
816a861
>                      | otherwise -> combinefromIntegrald acc ns c cs : ns)
818d862
<                      | otherwise -> combine d acc ns c cs
819d862
< 
820c863
<           combine _ acc [] c cs = end (fromIntegral acc) c cs
---
>           combine _ acc otherwise[] c cs =->end(fromIntegral acc nsacc cs) c cs
822d864
<               end (10^d * combine1 1000000000 ns + fromIntegral acc) c cs
824d865
<           combine1 _ [n] = n
825d865
<           combine1 b ns  = combine1 (b*b) $ combine2 b ns
826d865
< 
827d865
<           combine2 b (n:m:ns) = let t = n+m*b in t `seq` (t : combine2 b ns)
828d865
<           combine2 _ ns       = ns
829d865
< 
830d865
<           end n c cs = let c' = chunk c cs
831d865
<                         in c' `seq` (n, c')
832d865
< 
833d865
< -- | Read an entire file /lazily/ into a 'ByteString'. Use 'text mode'
834d865
< -- on Windows to interpret newlines
835d865
< readFile :: FilePath -> IO ByteString
836d865
< readFile f = openFile f ReadMode >>= hGetContents
837d865
< 
838d865
< -- | Write a 'ByteString' to a file.
839d865
< writeFile :: FilePath -> ByteString -> IO ()
840d865
< writeFile f txt = bracket (openFile f WriteMode) hClose
841d865
<     (\hdl -> hPut hdl txt)
842d865
< 
843d865
< -- | Append a 'ByteString' to a file.
844d865
< appendFile :: FilePath -> ByteString -> IO ()
845d865
< appendFile f txt = bracket (openFile f AppendMode) hClose
846d865
<     (\hdl -> hPut hdl txt)
847d865
< 
848d865
< 
849d865
< -- | Write a ByteString to a handle, appending a newline byte
850d865
< --
851d865
< hPutStrLn :: Handle -> ByteString -> IO ()
852d865
< hPutStrLn h ps = hPut h ps >> hPut h (L.singleton 0x0a)
853d865
< 
854d865
< -- | Write a ByteString to stdout, appending a newline byte
855d865
< putStrLn :: ByteString -> IO ()
856d865
< putStrLn = hPutStrLn stdout
857d865
< 
858d865
< 
859d865
< -- ---------------------------------------------------------------------
860d865
< -- Internal utilities
861d865
< 
862d865
< -- reverse a list of possibly-empty chunks into a lazy ByteString
863d865
< revChunks :: [S.ByteString] -> ByteString
864d865
< revChunks cs = List.foldl' (flip chunk) Empty cs
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-orphans #-}

-- |
-- Module      : Data.Vector.Storable.ByteString.Lazy.Char8
-- Copyright   : (c) Don Stewart 2006, (c) Bas van Dijk 2011
-- License     : BSD-style
--
-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental
-- Portability : non-portable (imports Data.Vector.Storable.ByteString.Lazy)
--
-- Manipulate /lazy/ 'ByteString's using 'Char' operations. All Chars will
-- be truncated to 8 bits. It can be expected that these functions will
-- run at identical speeds to their 'Data.Word.Word8' equivalents in
-- "Data.ByteString.Lazy".
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.Vector.Storable.ByteString.Lazy.Char8 as C
--

module Data.Vector.Storable.ByteString.Lazy.Char8 (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        cons',                  -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        uncons,                 -- :: ByteString -> Maybe (Char, ByteString)
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transforming ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Char -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
--      scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Infinite ByteStrings
        repeat,                 -- :: Char -> ByteString
        replicate,              -- :: Int64 -> Char -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Char -> Char) -> Char -> ByteString

        -- ** Unfolding ByteStrings
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
--      isSuffixOf,             -- :: ByteString -> ByteString -> Bool

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int64
        elemIndices,            -- :: Char -> ByteString -> [Int64]
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Char -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
--      unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,
        readInteger,

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int64 -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int64 -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()

  ) where

-- Functions transparently exported
import Data.Vector.Storable.ByteString.Lazy
        (fromChunks, toChunks
        ,empty,null,length,tail,init,append,reverse,transpose,cycle
        ,concat,take,drop,splitAt,intercalate,isPrefixOf,group,inits,tails,copy
        ,hGetContents, hGet, hPut, getContents
        ,hGetNonBlocking, hPutNonBlocking
        ,putStr, hPutStr, interact)

-- Functions we need to wrap.
import qualified Data.Vector.Storable.ByteString.Lazy as L
import qualified Data.Vector.Storable.ByteString as S (ByteString) -- typename only
import qualified Data.Vector.Storable.ByteString as B
import qualified Data.Vector.Storable.ByteString.Unsafe as B
import Data.Vector.Storable.ByteString.Lazy.Internal

import Data.Vector.Storable.ByteString.Internal (w2c, c2w, isSpaceWord8)

import Data.Int (Int64)
import qualified Data.List as List

import Prelude hiding
        (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
        ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter
        ,unwords,words,maximum,minimum,all,concatMap,scanl,scanl1,foldl1,foldr1
        ,readFile,writeFile,appendFile,replicate,getContents,getLine,putStr,putStrLn
        ,zip,zipWith,unzip,notElem,repeat,iterate,interact,cycle)

import System.IO            (Handle,stdout,hClose,openFile,IOMode(..))
import Control.Exception    (bracket)

import Data.String          (IsString(..))


------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = L.singleton . c2w
{-# INLINE singleton #-}

instance IsString ByteString where
    fromString = pack
    {-# INLINE fromString #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'.
pack :: [Char] -> ByteString
pack = L.pack. List.map c2w

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = List.map w2c . L.unpack
{-# INLINE unpack #-}

-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
cons :: Char -> ByteString -> ByteString
cons = L.cons . c2w
{-# INLINE cons #-}

-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons\' c xs in xs
--
-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.
--
cons' :: Char -> ByteString -> ByteString
cons' = L.cons' . c2w
{-# INLINE cons' #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = L.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . L.head
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Char, ByteString)
uncons bs = case L.uncons bs of
                  Nothing -> Nothing
                  Just (w, bs') -> Just (w2c w, bs')
{-# INLINE uncons #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . L.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = L.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = L.intersperse . c2w
{-# INLINE intersperse #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = L.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = L.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = L.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (L.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (L.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (L.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = L.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = L.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = L.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . L.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . L.minimum
{-# INLINE minimum #-}

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = L.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = L.mapAccumL (\a w -> case f a (w2c w) of (a',c) -> (a', c2w c))

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = L.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

------------------------------------------------------------------------
-- Generating and unfolding ByteStrings

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Char -> Char) -> Char -> ByteString
iterate f = L.iterate (c2w . f . w2c) . c2w

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Char -> ByteString
repeat = L.repeat . c2w

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Char -> ByteString
replicate w c = L.replicate w (c2w c)

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f = L.unfoldr $ \a -> case f a of
                                    Nothing      -> Nothing
                                    Just (c, a') -> Just (c2w c, a')

------------------------------------------------------------------------

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = L.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = L.dropWhile (f . w2c)
{-# INLINE dropWhile #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = L.break (f . w2c)
{-# INLINE break #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = L.span (f . w2c)
{-# INLINE span #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = L.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = L.spanByte . c2w
{-# INLINE spanChar #-}
-}

--
-- TODO, more rules for breakChar*
--

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = L.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = L.splitWith (f . w2c)
{-# INLINE splitWith #-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = L.groupBy (\a b -> k (w2c a) (w2c b))

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Char
index = (w2c .) . L.index
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int64
elemIndex = L.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int64]
elemIndices = L.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
findIndex f = L.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int64]
findIndices f = L.findIndices (f . w2c)

-- | count returns the number of times its argument appears in the ByteString
--
-- > count      == length . elemIndices
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int64
count c = L.count (c2w c)

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem c = L.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = L.notElem (c2w c)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = L.filter (f . w2c)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single Char. It is more
-- efficient to use /filterChar/ in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c ps = replicate (count c ps) c
{-# INLINE filterChar #-}

{-# RULES
  "ByteString specialise filter (== x)" forall x.
      filter ((==) x) = filterChar x
  #-}

{-# RULES
  "ByteString specialise filter (== x)" forall x.
     filter (== x) = filterChar x
  #-}
-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find :: (Char -> Bool) -> ByteString -> Maybe Char
find f ps = w2c `fmap` L.find (f . w2c) ps
{-# INLINE find #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = L.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = L.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings
zip :: ByteString -> ByteString -> [(Char,Char)]
zip ps qs
    | L.null ps || L.null qs = []
    | otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = L.zipWith ((. w2c) . f . w2c)

-- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- newline Chars. The resulting strings do not contain newlines.
--
-- As of bytestring 0.9.0.3, this function is stricter than its
-- list cousin.
--
lines :: ByteString -> [ByteString]
lines Empty          = []
lines (Chunk c0 cs0) = loop0 c0 cs0
    where
    -- this is a really performance sensitive function but the
    -- chunked representation makes the general case a bit expensive
    -- however assuming a large chunk size and normalish line lengths
    -- we will find line endings much more frequently than chunk
    -- endings so it makes sense to optimise for that common case.
    -- So we partition into two special cases depending on whether we
    -- are keeping back a list of chunks that will eventually be output
    -- once we get to the end of the current line.

    -- the common special case where we have no existing chunks of
    -- the current line
    loop0 :: S.ByteString -> ByteString -> [ByteString]
    loop0 c cs =
        case B.elemIndex (c2w '\n') c of
            Nothing -> case cs of
                           Empty  | B.null c  ->                 []
                                  | otherwise -> Chunk c Empty : []
                           (Chunk c' cs')
                               | B.null c  -> loop0 c'     cs'
                               | otherwise -> loop  c' [c] cs'

            Just n | n /= 0    -> Chunk (B.unsafeTake n c) Empty
                                : loop0 (B.unsafeDrop (n+1) c) cs
                   | otherwise -> Empty
                                : loop0 (B.unsafeTail c) cs

    -- the general case when we are building a list of chunks that are
    -- part of the same line
    loop :: S.ByteString -> [S.ByteString] -> ByteString -> [ByteString]
    loop c line cs =
        case B.elemIndex (c2w '\n') c of
            Nothing ->
                case cs of
                    Empty -> let c' = revChunks (c : line)
                              in c' `seq` (c' : [])

                    (Chunk c' cs') -> loop c' (c : line) cs'

            Just n ->
                let c' = revChunks (B.unsafeTake n c : line)
                 in c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)

{-

This function is too strict!  Consider,

> prop_lazy =
    (L.unpack . head . lazylines $ L.append (L.pack "a\nb\n") (error "failed"))
  ==
    "a"

fails.  Here's a properly lazy version of 'lines' for lazy bytestrings

    lazylines           :: L.ByteString -> [L.ByteString]
    lazylines s
        | L.null s  = []
        | otherwise =
            let (l,s') = L.break ((==) '\n') s
            in l : if L.null s' then []
                                else lazylines (L.tail s')

we need a similarly lazy, but efficient version.

-}


-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = empty
unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
    where nl = singleton '\n'

-- | 'words' breaks a ByteString up into a list of words, which
-- were delimited by Chars representing white space. And
--
-- > tokens isSpace = words
--
words :: ByteString -> [ByteString]
words = List.filter (not . L.null) . L.splitWith isSpaceWord8
{-# INLINE words #-}

-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords :: [ByteString] -> ByteString
unwords = intercalate (singleton ' ')
{-# INLINE unwords #-}

-- | readInt reads an Int from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns
-- Nothing, otherwise it just returns the int read, and the rest of the
-- string.

{-
-- Faster:

data MaybeS = NothingS
            | JustS {-# UNPACK #-} !Int {-# UNPACK #-} !ByteString
-}

readInt :: ByteString -> Maybe (Int, ByteString)
{-# INLINE readInt #-}
readInt Empty        = Nothing
readInt (Chunk x xs) = case w2c (B.unsafeHead x) of
    '-' -> loop True  0 0 (B.unsafeTail x) xs
    '+' -> loop False 0 0 (B.unsafeTail x) xs
    _   -> loop False 0 0 x xs

    where loop :: Bool -> Int -> Int
                -> S.ByteString -> ByteString -> Maybe (Int, ByteString)
          loop !neg !i !n !c !cs
              | B.null c = case cs of
                             Empty          -> end  neg i n c  cs
                             (Chunk c' cs') -> loop neg i n c' cs'
              | otherwise =
                  case B.unsafeHead c of
                    w | w >= 0x30
                     && w <= 0x39 -> loop neg (i+1)
                                          (n * 10 + (fromIntegral w - 0x30))
                                          (B.unsafeTail c) cs
                      | otherwise -> end neg i n c cs

          {-# INLINE end #-}
          end _   0 _ _  _ = Nothing
          end neg _ n c cs = e `seq` e
                where n' = if neg then negate n else n
                      c' = chunk c cs
                      e  = n' `seq` c' `seq` Just $! (n',c')
         --                  in n' `seq` c' `seq` JustS n' c'


-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.
readInteger :: ByteString -> Maybe (Integer, ByteString)
readInteger Empty = Nothing
readInteger (Chunk c0 cs0) =
        case w2c (B.unsafeHead c0) of
            '-' -> first (B.unsafeTail c0) cs0 >>= \(n, cs') -> return (-n, cs')
            '+' -> first (B.unsafeTail c0) cs0
            _   -> first c0 cs0

    where first c cs
              | B.null c = case cs of
                  Empty          -> Nothing
                  (Chunk c' cs') -> first' c' cs'
              | otherwise = first' c cs

          first' c cs = case B.unsafeHead c of
              w | w >= 0x30 && w <= 0x39 -> Just $
                  loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail c) cs
                | otherwise              -> Nothing

          loop :: Int -> Int -> [Integer]
               -> S.ByteString -> ByteString -> (Integer, ByteString)
          loop !d !acc !ns !c !cs
              | B.null c = case cs of
                             Empty          -> combine d acc ns c cs
                             (Chunk c' cs') -> loop d acc ns c' cs'
              | otherwise =
                  case B.unsafeHead c of
                   w | w >= 0x30 && w <= 0x39 ->
                       if d < 9 then loop (d+1)
                                          (10*acc + (fromIntegral w - 0x30))
                                          ns (B.unsafeTail c) cs
                                else loop 1 (fromIntegral w - 0x30)
                                          (fromIntegral acc : ns)
                                          (B.unsafeTail c) cs
                     | otherwise -> combine d acc ns c cs

          combine _ acc [] c cs = end (fromIntegral acc) c cs
          combine d acc ns c cs =
              end (10^d * combine1 1000000000 ns + fromIntegral acc) c cs

          combine1 _ [n] = n
          combine1 b ns  = combine1 (b*b) $ combine2 b ns

          combine2 b (n:m:ns) = let t = n+m*b in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns

          end n c cs = let c' = chunk c cs
                        in c' `seq` (n, c')

-- | Read an entire file /lazily/ into a 'ByteString'. Use 'text mode'
-- on Windows to interpret newlines
readFile :: FilePath -> IO ByteString
readFile f = openFile f ReadMode >>= hGetContents

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)


-- | Write a ByteString to a handle, appending a newline byte
--
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn h ps = hPut h ps >> hPut h (L.singleton 0x0a)

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn = hPutStrLn stdout


-- ---------------------------------------------------------------------
-- Internal utilities

-- reverse a list of possibly-empty chunks into a lazy ByteString
revChunks :: [S.ByteString] -> ByteString
revChunks cs = List.foldl' (flip chunk) Empty cs
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-orphans #-}

-- |
-- Module      : Data.Vector.Storable.ByteString.Lazy.Char8
-- Copyright   : (c) Don Stewart 2006, (c) Bas van Dijk 2011
-- License     : BSD-style
--
-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental
-- Portability : non-portable (imports Data.Vector.Storable.ByteString.Lazy)
--
-- Manipulate /lazy/ 'ByteString's using 'Char' operations. All Chars will
-- be truncated to 8 bits. It can be expected that these functions will
-- run at identical speeds to their 'Data.Word.Word8' equivalents in
-- "Data.ByteString.Lazy".
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.Vector.Storable.ByteString.Lazy.Char8 as C
--

module Data.Vector.Storable.ByteString.Lazy.Char8 (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        cons',                  -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        uncons,                 -- :: ByteString -> Maybe (Char, ByteString)
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transforming ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Char -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
--      scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
--      scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Infinite ByteStrings
        repeat,                 -- :: Char -> ByteString
        replicate,              -- :: Int64 -> Char -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Char -> Char) -> Char -> ByteString

        -- ** Unfolding ByteStrings
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
--      isSuffixOf,             -- :: ByteString -> ByteString -> Bool

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int64
        elemIndices,            -- :: Char -> ByteString -> [Int64]
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Char -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
--      unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,
        readInteger,

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int64 -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int64 -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()

  ) where

-- Functions transparently exported
import Data.Vector.Storable.ByteString.Lazy
        (fromChunks, toChunks
        ,empty,null,length,tail,init,append,reverse,transpose,cycle
        ,concat,take,drop,splitAt,intercalate,isPrefixOf,group,inits,tails,copy
        ,hGetContents, hGet, hPut, getContents
        ,hGetNonBlocking, hPutNonBlocking
        ,putStr, hPutStr, interact)

-- Functions we need to wrap.
import qualified Data.Vector.Storable.ByteString.Lazy as L
import qualified Data.Vector.Storable.ByteString as S (ByteString) -- typename only
import qualified Data.Vector.Storable.ByteString as B
import qualified Data.Vector.Storable.ByteString.Unsafe as B
import Data.Vector.Storable.ByteString.Lazy.Internal

import Data.Vector.Storable.ByteString.Internal (w2c, c2w, isSpaceWord8)

import Data.Int (Int64)
import qualified Data.List as List

import Prelude hiding
        (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
        ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter
        ,unwords,words,maximum,minimum,all,concatMap,scanl,scanl1,foldl1,foldr1
        ,readFile,writeFile,appendFile,replicate,getContents,getLine,putStr,putStrLn
        ,zip,zipWith,unzip,notElem,repeat,iterate,interact,cycle)

import System.IO            (Handle,stdout,hClose,openFile,IOMode(..))
import Control.Exception    (bracket)

import Data.String          (IsString(..))


------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = L.singleton . c2w
{-# INLINE singleton #-}

instance IsString ByteString where
    fromString = pack
    {-# INLINE fromString #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'.
pack :: [Char] -> ByteString
pack = L.pack. List.map c2w

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = List.map w2c . L.unpack
{-# INLINE unpack #-}

-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
cons :: Char -> ByteString -> ByteString
cons = L.cons . c2w
{-# INLINE cons #-}

-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons\' c xs in xs
--
-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.
--
cons' :: Char -> ByteString -> ByteString
cons' = L.cons' . c2w
{-# INLINE cons' #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = L.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . L.head
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Char, ByteString)
uncons bs = case L.uncons bs of
                  Nothing -> Nothing
                  Just (w, bs') -> Just (w2c w, bs')
{-# INLINE uncons #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . L.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = L.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = L.intersperse . c2w
{-# INLINE intersperse #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = L.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = L.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = L.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (L.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (L.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (L.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = L.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = L.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = L.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . L.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . L.minimum
{-# INLINE minimum #-}

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = L.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = L.mapAccumL (\a w -> case f a (w2c w) of (a',c) -> (a', c2w c))

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = L.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

------------------------------------------------------------------------
-- Generating and unfolding ByteStrings

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Char -> Char) -> Char -> ByteString
iterate f = L.iterate (c2w . f . w2c) . c2w

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Char -> ByteString
repeat = L.repeat . c2w

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Char -> ByteString
replicate w c = L.replicate w (c2w c)

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f = L.unfoldr $ \a -> case f a of
                                    Nothing      -> Nothing
                                    Just (c, a') -> Just (c2w c, a')

------------------------------------------------------------------------

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = L.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = L.dropWhile (f . w2c)
{-# INLINE dropWhile #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = L.break (f . w2c)
{-# INLINE break #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = L.span (f . w2c)
{-# INLINE span #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = L.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = L.spanByte . c2w
{-# INLINE spanChar #-}
-}

--
-- TODO, more rules for breakChar*
--

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X"]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = L.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = L.splitWith (f . w2c)
{-# INLINE splitWith #-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = L.groupBy (\a b -> k (w2c a) (w2c b))

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Char
index = (w2c .) . L.index
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int64
elemIndex = L.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int64]
elemIndices = L.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int64
findIndex f = L.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int64]
findIndices f = L.findIndices (f . w2c)

-- | count returns the number of times its argument appears in the ByteString
--
-- > count      == length . elemIndices
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int64
count c = L.count (c2w c)

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem c = L.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = L.notElem (c2w c)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = L.filter (f . w2c)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single Char. It is more
-- efficient to use /filterChar/ in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c ps = replicate (count c ps) c
{-# INLINE filterChar #-}

{-# RULES
  "ByteString specialise filter (== x)" forall x.
      filter ((==) x) = filterChar x
  #-}

{-# RULES
  "ByteString specialise filter (== x)" forall x.
     filter (== x) = filterChar x
  #-}
-}-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
find-- and returns the first element in matching the predicate, or 'Nothing':: (Char -> Bool) -> ByteString -> Maybe Char
find-- if there is no such element.f ps = w2c `fmap` L.find (f . w2c) ps
find{-# INLINE:: (Charfind->#-}) -> ByteString -> Maybe Char
find f ps = w2c `fmap` L.find (f . w2c) ps
{-# INLINE{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = L.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = L.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}          #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = L.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = L.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space-- corresponding pairs of Chars. If one input ByteString is short,
-- usage may be large for multi-megabyte ByteStrings-- excess elements of the longer ByteString are discarded. This is
zip-- equivalent to a pair of 'unpack' operations, and so space:: ByteString -> ByteString -> [(Char,Char)]
zip-- usage may be large for multi-megabyte ByteStringsps qs
zip ::| L.nullps ||->L.nullqs = [->]  [(Char,Char)]
zip ps| otherwise       = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
    | L.null ps || L.null qs = []
-- | 'zipWith' generalises 'zip' by zipping with the function given as otherwise = (head ps, head qs) : zip (L.tail ps) (L.tail qs)
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- of corresponding sums.-- the first argument, instead of a tupling function.  For example,
zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith-- of corresponding sums.f = L.zipWith ((. w2c) . f . w2c)
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith-- | 'lines' breaks a ByteString up into a list of ByteStrings at = L.zipWith ((. w2c) . f . w2c)
-- newline Chars. The resulting strings do not contain newlines.
---- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- As of bytestring 0.9.0.3, this function is stricter than its-- newline Chars. The resulting strings do not contain newlines.
---- list cousin.
---- As of bytestring 0.9.0.3, this function is stricter than its
lines-- list cousin.:: ByteString -> [ByteString]
--lines Empty          = []
lines ::(Chunkc0 cs0)->= [loop0ByteStringc0 cs0]
lineswhere          = []
lines-- this is a really performance sensitive function but theChunk c0 cs0) = loop0 c0 cs0
    where-- chunked representation makes the general case a bit expensive
    -- this is a really performance sensitive function but the-- however assuming a large chunk size and normalish line lengths
    -- we will find line endings much more frequently than chunk-- chunked representation makes the general case a bit expensive
    -- endings so it makes sense to optimise for that common case.-- however assuming a large chunk size and normalish line lengths
    -- we will find line endings much more frequently than chunk-- So we partition into two special cases depending on whether we
    -- endings so it makes sense to optimise for that common case.-- are keeping back a list of chunks that will eventually be output
    -- once we get to the end of the current line.-- So we partition into two special cases depending on whether we
    -- are keeping back a list of chunks that will eventually be output
    -- once we get to the end of the current line.-- the common special case where we have no existing chunks of
    -- the current line
    loop0-- the common special case where we have no existing chunks of:: S.ByteString -> ByteString -> [ByteString]
    loop0-- the current linec cs =
    loop0case:: S.ByteStringB.elemIndex (->c2wByteString'\n') c of-> [ByteString]
    loop0 c csNothing=    -> case cs of
        case B.elemIndex (c2wEmpty) cB.nullof   c  ->                 []
            Nothing -> case cs of | otherwise -> Chunk c Empty : []
                           Empty(Chunk |c'B.nullcs')  c  ->                 []
                               | B.null otherwisec  -> ->loop0c' c Emptycs' : []
                           (Chunk| otherwise cs')  -> loop  c' [c] cs'
                               | B.null c  -> loop0 c'     cs'
            Just n | n /= 0    |->otherwiseChunk (B.unsafeTake-> loop  c'n[c] cs'Empty
                                : loop0 (B.unsafeDrop (n+1) c) cs
            Just n | notherwise 0    -> Chunk (B.unsafeTake n c) Empty
                                : loop0 (B.unsafeDrop (n+1cs) c) cs
                   | otherwise -> Empty
    -- the general case when we are building a list of chunks that are loop0 (B.unsafeTail c) cs
    -- part of the same line
    loop-- the general case when we are building a list of chunks that are:: S.ByteString -> [S.ByteString] -> ByteString -> [ByteString]
    loop-- part of the same linec line cs =
    loopcase:: S.ByteStringB.elemIndex ->(c2wS.ByteString'\n') c of ] -> ByteString -> [ByteString]
    loop c lineNothing =->
        case B.elemIndexcase cs ofc2w '\n') c of
            Nothing ->Empty -> let c' = revChunks (c : line)
                case cs of    in c' `seq` (c' : [])
                    Empty -> let c' = revChunks (c : line)
                    (Chunk c' incs'c') ->seqloop` (c' :c[])line) cs'

            Just n ->Chunk c' cs') -> loop c' (c : line) cs'
                let c' = revChunks (B.unsafeTake n c : line)
            Just nin->c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)
                let c' = revChunks (B.unsafeTake n c : line)
{-

This function is too strict!  Consider,

> prop_lazy =
    (L.unpack . head . lazylines $ L.append (L.pack "a\nb\n") (error "failed"))
  ==
    "a"

fails.  Here's a properly lazy version of 'lines' for lazy bytestrings

    lazylines           :: L.ByteString -> [L.ByteString]
    lazylines s
        | L.null s  = []
        | otherwise =
            let (l,s') = L.break ((==) '\n') s
            in l : if L.null s' then []
                                else lazylines (L.tail s')

we need a similarly lazy, but efficient version.

-}               in c' `seq` (c' : loop0 (B.unsafeDrop (n+1) c) cs)

{-

This function is too strict!  Consider,

> prop_lazy =
    (L.unpack . head . lazylines $ L.append (L.pack "a\nb\n") (error "failed"))
  ==
    "a"

fails.  Here's a properly lazy version of 'lines' for lazy bytestrings

    lazylines           :: L.ByteString -> [L.ByteString]
    lazylines s
        | L.null s  = []
        | otherwise =
            let (l,s') = L.break ((==) '\n') s
            in l : if L.null s' then []
                                else lazylines (L.tail s')

we need a similarly lazy, but efficient version.

-}
-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,:: [ByteString] -> ByteString
unlines-- after appending a terminating newline to each.[] = empty
unlines :: [ByteString(concat $]List.intersperse-> ByteString   nl ss) `append` nl -- half as much space
unlineswhere]nl= empty= singleton '\n'
unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
-- | 'words' breaks a ByteString up into a list of words, whichwhere nl = singleton '\n'
-- were delimited by Chars representing white space. And
---- | 'words' breaks a ByteString up into a list of words, which
-- > tokens isSpace = words-- were delimited by Chars representing white space. And
--
words-- > tokens isSpace = words:: ByteString -> [ByteString]
--words = List.filter (not . L.null) . L.splitWith isSpaceWord8
words{-# INLINE:: ByteStringwords #-}-> [ByteString]
words = List.filter (not . L.null) . L.splitWith isSpaceWord8
{-# INLINE-- | The 'unwords' function is analogous to the 'unlines' function, on words. #-}
unwords :: [ByteString] -> ByteString
unwords-- | The 'unwords' function is analogous to the 'unlines' function, on words.= intercalate (singleton ' ')
unwords{-# INLINE:: [unwordsByteString#-}] -> ByteString
unwords = intercalate (singleton ' ')
{-# INLINE-- | readInt reads an Int from the beginning of the ByteString.  If #-}
-- there is no integer at the beginning of the string, it returns
-- | readInt reads an Int from the beginning of the ByteString.  If-- Nothing, otherwise it just returns the int read, and the rest of the
-- string.-- there is no integer at the beginning of the string, it returns
-- Nothing, otherwise it just returns the int read, and the rest of the
-- string.{-
-- Faster:

data MaybeS = NothingS
            | JustS {-# UNPACK #-} !Int {-# UNPACK #-} !ByteString
-}readInt :: ByteString -> Maybe (Int, ByteString)
{-# INLINE readInt #-}
readInt ::Empty=->Nothing (Int, ByteString)
{-# INLINEreadInt (Chunkx xs#-}) = case w2c (B.unsafeHead x) of
readInt'-' Empty-> loop True =0Nothing0 (B.unsafeTail x) xs
readInt'+' (->ChunkloopxFalse) =0case0 (B.unsafeTail (B.unsafeHeadx) xs x) of
    '-'_   -> loop TrueFalse 0 0 (B.unsafeTailxs          x) xs
    '+' -> loop False 0 0 (B.unsafeTail x) xs
    _whereloop::Bool0-> xInt-> Int
                -> S.ByteString -> ByteString -> Maybe (Int, ByteString)
    where loop ::!neg!i ->!n Int!c !-> Int
              | ->B.nullc = case -> ByteStringof         -> Maybe (Int, ByteString)
          loop !neg !i !n !c !Emptycs            -> end  neg i n c  cs
              | B.null c = case(Chunk ofc' cs') -> loop neg i n c' cs'
              | otherwise =  Empty          -> end  neg i n c  cs
                  case B.unsafeHeadChunk c'c of) -> loop neg i n c' cs'
              | otherwisew | w =>= 0x30
                  case&&B.unsafeHeadw <= 0x39 ->cloopof  neg (i+1)
                    w | w >= 0x30         (n * 10 + (fromIntegral w - 0x30))
                     && w <= 0x39 -> loop neg(B.unsafeTaili+1)     c) cs
                      | otherwise -> end negn * 10n c+csfromIntegral w - 0x30))
                                          (B.unsafeTail c) cs
          {-# INLINE end otherwise#-}      -> end neg i n c cs
          end _   0 _ _  _ = Nothing
          {-# INLINEend neg _ nendc cs#-}= e `seq` e
          end _ where _ _n' _ =ifNothingneg then negate n else n
          end neg _ n cc'cs= =chunk `seqc `cse
                where n'e  = if neg`seqthen` c' negate`seq` Just else$! nn',c')
         --                  in n' `seq` c' `seq` JustS n' c' = chunk c cs
                      e  = n' `seq` c' `seq` Just $! (n',c')
         --                  in n' `seq` c' `seq` JustS n' c'
-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.-- | readInteger reads an Integer from the beginning of the ByteString.  If
readInteger-- there is no integer at the beginning of the string, it returns Nothing,:: ByteString -> Maybe (Integer, ByteString)
readInteger-- otherwise it just returns the int read, and the rest of the string.Empty = Nothing
readInteger ::(Chunkc0 cs0)->= Maybe (Integer, ByteString)
readIntegercaseEmptyw2c (=B.unsafeHead    c0) of
readInteger ('-'Chunk-> c0first)B.unsafeTail=           c0) cs0 >>= \(n, cs') -> return (-n, cs')
        case'+'->B.unsafeHeadfirst (B.unsafeTail) of  c0) cs0
            '-'_   -> first (c0B.unsafeTailcs0        c0) cs0 >>= \(n, cs') -> return (-n, cs')
            '+' -> first (B.unsafeTail c0) cs0
    where first   ->c cs c0 cs0
              | B.null c = case cs of
    where first c csEmpty          -> Nothing
              | B.null(Chunk =c'casecs')cs->offirst' c' cs'
              | otherwise   = first'cNothingcs
                  (Chunk c' cs') -> first' c' cs'
          first' otherwisec cs = case= first'B.unsafeHead cs   c of
              w | w >= 0x30 && w <= 0x39 -> Just $
          first' cloop =1case(fromIntegralw -c0x30of ) [] (B.unsafeTail c) cs
              w | wotherwise 0x30 && w <= 0x39 -> JustNothing
                  loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail c) cs
          loop :: otherwiseInt -> Int -> [Integer]-> Nothing
               -> S.ByteString -> ByteString -> (Integer, ByteString)
          loop ::!d Int!acc->!ns!c->!csInteger]
              |->B.nullc = case->csByteStringof        -> (Integer, ByteString)
          loop !d !acc !ns !cEmpty!cs           -> combine d acc ns c cs
              | B.null c = case(Chunk ofc' cs') -> loop d acc ns c' cs'
              | otherwise =  Empty          -> combine d acc ns c cs
                  case B.unsafeHeadChunk c'c of) -> loop d acc ns c' cs'
              | otherwisew | w >== 0x30 && w <= 0x39 ->
                  case B.unsafeHeadif d < 9 thencloopof  (d+1)
                   w | w >= 0x30 && w <= 0x39(10*->acc + (fromIntegral w - 0x30))
                       if d < 9 then loop (nsd+1)B.unsafeTail c) cs
                                else loop (10(*fromIntegralacc + (fromIntegralw - 0x30w - 0x30))
                                          ns(fromIntegralB.unsafeTailaccc) cs)
                                else loop 1B.unsafeTailfromIntegralc)wcs 0x30)
                     | otherwise -> combinefromIntegrald acc ns c cs : ns)
                                          (B.unsafeTail c) cs
          combine _ acc otherwise[] c cs =->end(fromIntegral acc nsacc cs) c cs
          combine d acc ns c cs =

</pre>