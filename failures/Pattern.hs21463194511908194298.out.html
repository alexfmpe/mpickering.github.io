<a href="Pattern.hs18171295601131570933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Pattern.hs3228420821463179852.out.html">next</a></br></br><pre>20d19
< instance Monad m ⇒ Monad (PatternT n m) where
21d19
<     return x = PatternT $ \h → return ([],x)
22d19
<     p >>= f = PatternT $ \h → do
23d19
<         (m1,x) ← patternT p h
24c20
<         (m2,y) ← patternT (f x) (reverse m1 ⧺ h)
---
> instance Monad m => Monad (PatternT n m) where
24a21
>     return x = PatternT $ \h -> return ([],x)
24a22
>     p >>= f = PatternT $ \h -> do
24a23
>         (m1,x) <- patternT p h
24a24
>         (m2,y) <- patternT (f x) (reverse m1 ⧺ h)
26c26
<     fail str = PatternT $ \h → lift (fail str)
---
>     fail str = PatternT $ \h -> lift (fail str)
29d28
<     lift m = PatternT $ \h → do
30c29
<         x ← lift $ lift m
---
>     lift m = PatternT $ \h -> do
30a30
>         x <- lift $ lift m
34c34
< instance Monad m ⇒ Functor (PatternT n m) where fmap = liftM
---
> instance Monad m => Functor (PatternT n m) where fmap = liftM
37c37
< instance Monad m ⇒ Applicative (PatternT n m) where
---
> instance Monad m => Applicative (PatternT n m) where
40c40
<         f' ← f
---
>         f' <- f
43c43
< instance Monad m ⇒ Alternative (PatternT n m) where
---
> instance Monad m => Alternative (PatternT n m) where
47c47
< instance Monad m ⇒ Monoid (PatternT n m a) where
---
> instance Monad m => Monoid (PatternT n m a) where
51c51
< instance Monad m ⇒ MonadPlus (PatternT n m) where
---
> instance Monad m => MonadPlus (PatternT n m) where
53d52
<     mplus p q = PatternT $ \h → do -- TODO: this implements choice. Is mplus the right function for that?
54c53
<         g ← ask
---
>     mplus p q = PatternT $ \h -> do -- TODO: this implements choice. Is mplus the right function for that?
54a54
>         g <- ask
57c57
< runPatternT ∷ PatternT n m a → Graph n → m [(Match,a)]
---
> runPatternT :: PatternT n m a -> Graph n -> m [(Match,a)]
61c61
< runPattern ∷ Pattern n a → Graph n → [(Match,a)]
---
> runPattern :: Pattern n a -> Graph n -> [(Match,a)]
64c64
< evalPattern ∷ Pattern n a → Graph n → [a]
---
> evalPattern :: Pattern n a -> Graph n -> [a]
67c67
< execPattern ∷ Pattern n a → Graph n → [Match]
---
> execPattern :: Pattern n a -> Graph n -> [Match]
73d72
< branch ∷ Monad m ⇒ [a] → PatternT n m a -- TODO: express this using Alternative?
74c73
< branch xs = PatternT $ \h → lift $ ListT $ return [([],x) | x ← xs]
---
> branch :: Monad m => [a] -> PatternT n m a -- TODO: express this using Alternative?
74a74
> branch xs = PatternT $ \h -> lift $ ListT $ return [([],x) | x <- xs]
77c77
< branchNodes ∷ Monad m ⇒ [Node] → PatternT n m Node
---
> branchNodes :: Monad m => [Node] -> PatternT n m Node
79c79
<     n ← branch ns
---
>     n <- branch ns
84c84
< probe ∷ Monad m ⇒ PatternT n m a → PatternT n m Bool
---
> probe :: Monad m => PatternT n m a -> PatternT n m Bool
88c88
< matches ∷ Monad m ⇒ PatternT n m a → PatternT n m [Match]
---
> matches :: Monad m => PatternT n m a -> PatternT n m [Match]
93d92
< match ∷ Monad m ⇒ PatternT n m a → PatternT n m [(Match, a)]
94d92
< match p = PatternT $ \h → do
95d92
<     matches ← liftM (runReaderT $ patternT p h) ask -- list of all possible matches
96c93
<     let roundup = liftM (\xs → [(concatMap fst xs, xs)]) (runListT matches) -- concatenation into one big match
---
> match :: Monad m => PatternT n m a -> PatternT n m [(Match, a)]
96a94
> match p = PatternT $ \h -> do
96a95
>     matches <- liftM (runReaderT $ patternT p h) ask -- list of all possible matches
96a96
>     let roundup = liftM (\xs -> [(concatMap fst xs, xs)]) (runListT matches) -- concatenation into one big match
100c100
< anyOf ∷ Alternative f ⇒ [f a] → f a
---
> anyOf :: Alternative f => [f a] -> f a
104c104
< require ∷ Monad m ⇒ Bool → m ()
---
> require :: Monad m => Bool -> m ()
108c108
< requireFailure ∷ Monad m ⇒ PatternT n m a → PatternT n m ()
---
> requireFailure :: Monad m => PatternT n m a -> PatternT n m ()
112c112
< requireM ∷ Monad m ⇒ m Bool → m ()
---
> requireM :: Monad m => m Bool -> m ()
118d117
< liftReader ∷ Monad m ⇒ Reader (Graph n) a → PatternT n m a
119d117
< liftReader r = PatternT $ \h → do
120c118
<     x ← runReader r `liftM` ask
---
> liftReader :: Monad m => Reader (Graph n) a -> PatternT n m a
120a119
> liftReader r = PatternT $ \h -> do
120a120
>     x <- runReader r `liftM` ask
124c124
< node ∷ (Monad m, View v n) ⇒ PatternT n m v
---
> node :: (Monad m, View v n) => PatternT n m v
128c128
< nodeAt ∷ (Monad m, View v n) ⇒ Node → PatternT n m v
---
> nodeAt :: (Monad m, View v n) => Node -> PatternT n m v
130d129
<     n ← liftReader $ inspectNode ref
131c130
<     PatternT $ \h → lift $ return ([ref],n)
---
>     n <- liftReader $ inspectNode ref
131a131
>     PatternT $ \h -> lift $ return ([ref],n)
134c134
< edge ∷ Monad m ⇒ PatternT n m Edge
---
> edge :: Monad m => PatternT n m Edge
138c138
< nodeWith ∷ (Monad m, View v n) ⇒ Edge → PatternT n m v
---
> nodeWith :: (Monad m, View v n) => Edge -> PatternT n m v
142c142
< edgeOf ∷ (Monad m, View [Port] n) ⇒ Node → PatternT n m Edge
---
> edgeOf :: (Monad m, View [Port] n) => Node -> PatternT n m Edge
146c146
< neighbour ∷ Monad m => (View [Port] n, View v n) ⇒ Node → PatternT n m v
---
> neighbour :: Monad m => (View [Port] n, View v n) => Node -> PatternT n m v
150c150
< relative ∷ (Monad m, View [Port] n, View v n) ⇒ Node → PatternT n m v
---
> relative :: (Monad m, View [Port] n, View v n) => Node -> PatternT n m v
155c155
< adverse ∷ (Monad m, View [Port] n, View v n) ⇒ Port → Node → PatternT n m v
---
> adverse :: (Monad m, View [Port] n, View v n) => Port -> Node -> PatternT n m v
161c161
< visit ∷ Monad m ⇒ Node → PatternT n m ()
---
> visit :: Monad m => Node -> PatternT n m ()
163c163
<     exists ← liftReader $ existNode n
---
>     exists <- liftReader $ existNode n
165c165
<         then PatternT $ \h → lift $ return ([n],())
---
>         then PatternT $ \h -> lift $ return ([n],())
169d168
< amnesia ∷ Monad m ⇒ PatternT n m a → PatternT n m a
170d168
< amnesia p = PatternT $ \h → do
171c169
<     (h',x) ← patternT p h
---
> amnesia :: Monad m => PatternT n m a -> PatternT n m a
171a170
> amnesia p = PatternT $ \h -> do
171a171
>     (h',x) <- patternT p h
175d174
< history ∷ Monad m ⇒ PatternT n m Match
176c175
< history = PatternT $ \h → return ([],h)
---
> history :: Monad m => PatternT n m Match
176a176
> history = PatternT $ \h -> return ([],h)
179c179
< previous ∷ Monad m ⇒ PatternT n m Node
---
> previous :: Monad m => PatternT n m Node
183d182
< nextFresh ∷ Monad m ⇒ PatternT n m a → PatternT n m a
184c183
< nextFresh = restrictOverlap $ \past future → null future ∨ not (head future ∈ past)
---
> nextFresh :: Monad m => PatternT n m a -> PatternT n m a
184a184
> nextFresh = restrictOverlap $ \past future -> null future ∨ not (head future ∈ past)
187d186
< nextIs ∷ Monad m ⇒ Node → PatternT n m a → PatternT n m a
188c187
< nextIs next = restrictOverlap $ \past future → not (null future) ∧ head future ≡ next
---
> nextIs :: Monad m => Node -> PatternT n m a -> PatternT n m a
188a188
> nextIs next = restrictOverlap $ \past future -> not (null future) ∧ head future ≡ next
191d190
< restrictOverlap ∷ Monad m ⇒ (Match → Match → Bool) → PatternT n m a → PatternT n m a
192d190
< restrictOverlap c p = PatternT $ \h → do
193c191
<     (h',x) ← patternT p h
---
> restrictOverlap :: Monad m => (Match -> Match -> Bool) -> PatternT n m a -> PatternT n m a
193a192
> restrictOverlap c p = PatternT $ \h -> do
193a193
>     (h',x) <- patternT p h
199d198
< linear ∷ Monad m ⇒ PatternT n m a → PatternT n m a
200c199
< linear = restrictOverlap $ \hist future → isLinear Set.empty future where
---
> linear :: Monad m => PatternT n m a -> PatternT n m a
200a200
> linear = restrictOverlap $ \hist future -> isLinear Set.empty future where
202a203
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
-- | Patterns allow monadic scrutinisation of the graph (modifications are not possible) while keeping track of matched nodes (history). A 'Pattern' is interpreted by 'runPattern' that returns a result for each position in the graph where the pattern matches. It is allowed to 'fail' inside the 'Pattern' monad, indicating that the pattern does not match, which corresponds to conditional rewriting.
module GraphRewriting.Pattern (module GraphRewriting.Pattern, PatternT, Pattern, Match, (<|>)) where

import Prelude.Unicode
import GraphRewriting.Pattern.Internal
import GraphRewriting.Graph.Read
import Control.Monad.Reader
import Control.Monad.List
import Control.Monad.Identity
import qualified Data.Set as Set (empty, insert, member)
import Control.Applicative
import Data.Functor
import Data.Monoid


-- | A pattern represents a graph scrutinisation that memorises all the scrutinised nodes during matching.
type Pattern n = PatternT n Identity

instance Monad m ⇒ Monad (PatternT n m) where
    return x = PatternT $ \h → return ([],x)
    p >>= f = PatternT $ \h → do
        (m1,x) ← patternT p h
        (m2,y) ← patternT (f x) (reverse m1 ⧺ h)
        return (m1 ⧺ m2, y)
    fail str = PatternT $ \h → lift (fail str)

instance MonadTrans (PatternT n) where
    lift m = PatternT $ \h → do
        x ← lift $ lift m
        return ([],x)

-- TODO: Change constraint to Functor m if possible
instance Monad m ⇒ Functor (PatternT n m) where fmap = liftM

-- TODO: Change constraint from Monad m if possible
instance Monad m ⇒ Applicative (PatternT n m) where
    pure = return
    f <*> x = do
        f' ← f
        f' <$> x

instance Monad m ⇒ Alternative (PatternT n m) where
    empty = mzero
    (<|>) = mplus

instance Monad m ⇒ Monoid (PatternT n m a) where
    mempty = mzero
    mappend = mplus

instance Monad m ⇒ MonadPlus (PatternT n m) where
    mzero = fail "empty result list"
    mplus p q = PatternT $ \h → do -- TODO: this implements choice. Is mplus the right function for that?
        g ← ask
        lift $ runReaderT (patternT p h) g `mplus` runReaderT (patternT q h) g

runPatternT ∷ PatternT n m a → Graph n → m [(Match,a)]
runPatternT = runPatternT' []

-- | Apply a pattern on a graph returning a result for each matching position in the graph together with the matched nodes.
runPattern ∷ Pattern n a → Graph n → [(Match,a)]
runPattern p = runIdentity . runPatternT p

evalPattern ∷ Pattern n a → Graph n → [a]
evalPattern p = map snd . runPattern p

execPattern ∷ Pattern n a → Graph n → [Match]
execPattern p = map fst . runPattern p

-- combinators ---------------------------------------------------------------

-- | Something like an implicit monadic map
branch ∷ Monad m ⇒ [a] → PatternT n m a -- TODO: express this using Alternative?
branch xs = PatternT $ \h → lift $ ListT $ return [([],x) | x ← xs]

-- | 'branch' on each node, add it to the history, and return it
branchNodes ∷ Monad m ⇒ [Node] → PatternT n m Node
branchNodes ns = do -- TODO: express this using Alternative?
    n ← branch ns
    visit n
    return n

-- | Probe whether a pattern matches somewhere on the graph. You might want to combine this with 'amnesia'.
probe ∷ Monad m ⇒ PatternT n m a → PatternT n m Bool
probe p = not . null <$> matches p

-- | probe a pattern returning the matches it has on the graph. You might want to combine this with 'amnesia'.
matches ∷ Monad m ⇒ PatternT n m a → PatternT n m [Match]
matches p = map fst <$> match p

-- TODO: isn't this essentially same as runPatternT?
-- | probe a pattern returning the matches it has on the graph. You might want to combine this with 'amnesia'.
match ∷ Monad m ⇒ PatternT n m a → PatternT n m [(Match, a)]
match p = PatternT $ \h → do
    matches ← liftM (runReaderT $ patternT p h) ask -- list of all possible matches
    let roundup = liftM (\xs → [(concatMap fst xs, xs)]) (runListT matches) -- concatenation into one big match
    lift $ ListT roundup

-- | choice over a list of patterns
anyOf ∷ Alternative f ⇒ [f a] → f a
anyOf = foldr (<|>) empty

-- | conditional rewriting: 'fail' when predicate is not met
require ∷ Monad m ⇒ Bool → m ()
require p = unless p $ fail "requirement not met"

-- | 'fail' if given pattern succeeds, succeed if it fails.
requireFailure ∷ Monad m ⇒ PatternT n m a → PatternT n m ()
requireFailure p = require . not =<< probe p

-- | 'fail' when monadic predicate is not met
requireM ∷ Monad m ⇒ m Bool → m ()
requireM p = p >>= require

-- some base patterns --------------------------------------------------------

-- | Lift a scrutinisation from 'Reader' to 'Pattern' leaving the history unchanged.
liftReader ∷ Monad m ⇒ Reader (Graph n) a → PatternT n m a
liftReader r = PatternT $ \h → do
    x ← runReader r `liftM` ask
    return ([],x)

-- | any node anywhere in the graph
node ∷ (Monad m, View v n) ⇒ PatternT n m v
node = liftReader . inspectNode =<< branchNodes =<< liftReader readNodeList

-- | A specific node
nodeAt ∷ (Monad m, View v n) ⇒ Node → PatternT n m v
nodeAt ref = do
    n ← liftReader $ inspectNode ref
    PatternT $ \h → lift $ return ([ref],n)

-- | any edge anywhere in the graph
edge ∷ Monad m ⇒ PatternT n m Edge
edge = branch =<< liftReader readEdgeList

-- | node that is connected to given edge
nodeWith ∷ (Monad m, View v n) ⇒ Edge → PatternT n m v
nodeWith e = liftReader . inspectNode =<< branchNodes =<< liftReader (attachedNodes e)

-- | edge that is attached to given node
edgeOf ∷ (Monad m, View [Port] n) ⇒ Node → PatternT n m Edge
edgeOf n = branch =<< liftReader (attachedEdges n)

-- | node that is connected to the given node, but not that node itself
neighbour ∷ Monad m => (View [Port] n, View v n) ⇒ Node → PatternT n m v
neighbour n = liftReader . inspectNode =<< branchNodes =<< liftReader (neighbours n)

-- | node that is connected to the given node, permitting the node itself
relative ∷ (Monad m, View [Port] n, View v n) ⇒ Node → PatternT n m v
relative n = liftReader . inspectNode =<< branchNodes =<< liftReader (relatives n)

-- | nodes connected to given port of the specified node, not including the node itself.
-- Consider as an alternative 'linear' combined with 'nodeWith'.
adverse ∷ (Monad m, View [Port] n, View v n) ⇒ Port → Node → PatternT n m v
adverse p n = liftReader . inspectNode =<< branchNodes =<< liftReader (adverseNodes n p)

-- controlling history and future --------------------------------------------

-- | A specific node
visit ∷ Monad m ⇒ Node → PatternT n m ()
visit n = do
    exists ← liftReader $ existNode n
    if exists
        then PatternT $ \h → lift $ return ([n],())
        else fail $ "visit: node with ID " ⧺ show n ⧺ " does not exist"

-- | Do not remember any of the nodes matched by the supplied pattern
amnesia ∷ Monad m ⇒ PatternT n m a → PatternT n m a
amnesia p = PatternT $ \h → do
    (h',x) ← patternT p h
    return ([],x)

-- | list of nodes matched until now with the most recent node in head position
history ∷ Monad m ⇒ PatternT n m Match
history = PatternT $ \h → return ([],h)

-- | a reference to the lastly matched node
previous ∷ Monad m ⇒ PatternT n m Node
previous = head <$> history

-- | only match nodes in the next pattern that have not been matched before
nextFresh ∷ Monad m ⇒ PatternT n m a → PatternT n m a
nextFresh = restrictOverlap $ \past future → null future ∨ not (head future ∈ past)

-- | only accept the given node in the next match
nextIs ∷ Monad m ⇒ Node → PatternT n m a → PatternT n m a
nextIs next = restrictOverlap $ \past future → not (null future) ∧ head future ≡ next

-- | Restrict a pattern based on the which of nodes have matched been previously and which nodes will be matched in the future. The first parameter of the supplied function is the history with the most recently matched node in head position. The second parameter is the future with the next matched node in head position.
restrictOverlap ∷ Monad m ⇒ (Match → Match → Bool) → PatternT n m a → PatternT n m a
restrictOverlap c p = PatternT $ \h → do
    (h',x) ← patternT p h
    require (c h h')
    return (h',x)
-- TODO: the check is only done after the whole pattern has matched (maybe do the check more often inbetween?)

-- | Nodes in the future may not be matched more than once.
linear ∷ Monad m ⇒ PatternT n m a → PatternT n m a
linear = restrictOverlap $ \hist future → isLinear Set.empty future where
    isLinear left [] = True
    isLinear left (r:rs) = not (r `Set.member` left) ∧ isLinear (r `Set.insert` left) rs
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
-- | Patterns allow monadic scrutinisation of the graph (modifications are not possible) while keeping track of matched nodes (history). A 'Pattern' is interpreted by 'runPattern' that returns a result for each position in the graph where the pattern matches. It is allowed to 'fail' inside the 'Pattern' monad, indicating that the pattern does not match, which corresponds to conditional rewriting.
module GraphRewriting.Pattern (module GraphRewriting.Pattern, PatternT, Pattern, Match, (<|>)) where

import Prelude.Unicode
import GraphRewriting.Pattern.Internal
import GraphRewriting.Graph.Read
import Control.Monad.Reader
import Control.Monad.List
import Control.Monad.Identity
import qualified Data.Set as Set (empty, insert, member)
import Control.Applicative
import Data.Functor
import Data.Monoid


-- | A pattern represents a graph scrutinisation that memorises all the scrutinised nodes during matching.
type Pattern n = PatternT n Identity

instance Monad m => Monad (PatternT n m) where
    return x = PatternT $ \h -> return ([],x)
    p >>= f = PatternT $ \h -> do
        (m1,x) <- patternT p h
        (m2,y) <- patternT (f x) (reverse m1 ⧺ h)
        return (m1 ⧺ m2, y)
    fail str = PatternT $ \h -> lift (fail str)

instance MonadTrans (PatternT n) where
    lift m = PatternT $ \h -> do
        x <- lift $ lift m
        return ([],x)

-- TODO: Change constraint to Functor m if possible
instance Monad m => Functor (PatternT n m) where fmap = liftM

-- TODO: Change constraint from Monad m if possible
instance Monad m => Applicative (PatternT n m) where
    pure = return
    f <*> x = do
        f' <- f
        f' <$> x

instance Monad m => Alternative (PatternT n m) where
    empty = mzero
    (<|>) = mplus

instance Monad m => Monoid (PatternT n m a) where
    mempty = mzero
    mappend = mplus

instance Monad m => MonadPlus (PatternT n m) where
    mzero = fail "empty result list"
    mplus p q = PatternT $ \h -> do -- TODO: this implements choice. Is mplus the right function for that?
        g <- ask
        lift $ runReaderT (patternT p h) g `mplus` runReaderT (patternT q h) g

runPatternT :: PatternT n m a -> Graph n -> m [(Match,a)]
runPatternT = runPatternT' []

-- | Apply a pattern on a graph returning a result for each matching position in the graph together with the matched nodes.
runPattern :: Pattern n a -> Graph n -> [(Match,a)]
runPattern p = runIdentity . runPatternT p

evalPattern :: Pattern n a -> Graph n -> [a]
evalPattern p = map snd . runPattern p

execPattern :: Pattern n a -> Graph n -> [Match]
execPattern p = map fst . runPattern p

-- combinators ---------------------------------------------------------------

-- | Something like an implicit monadic map
branch :: Monad m => [a] -> PatternT n m a -- TODO: express this using Alternative?
branch xs = PatternT $ \h -> lift $ ListT $ return [([],x) | x <- xs]

-- | 'branch' on each node, add it to the history, and return it
branchNodes :: Monad m => [Node] -> PatternT n m Node
branchNodes ns = do -- TODO: express this using Alternative?
    n <- branch ns
    visit n
    return n

-- | Probe whether a pattern matches somewhere on the graph. You might want to combine this with 'amnesia'.
probe :: Monad m => PatternT n m a -> PatternT n m Bool
probe p = not . null <$> matches p

-- | probe a pattern returning the matches it has on the graph. You might want to combine this with 'amnesia'.
matches :: Monad m => PatternT n m a -> PatternT n m [Match]
matches p = map fst <$> match p

-- TODO: isn't this essentially same as runPatternT?
-- | probe a pattern returning the matches it has on the graph. You might want to combine this with 'amnesia'.
match :: Monad m => PatternT n m a -> PatternT n m [(Match, a)]
match p = PatternT $ \h -> do
    matches <- liftM (runReaderT $ patternT p h) ask -- list of all possible matches
    let roundup = liftM (\xs -> [(concatMap fst xs, xs)]) (runListT matches) -- concatenation into one big match
    lift $ ListT roundup

-- | choice over a list of patterns
anyOf :: Alternative f => [f a] -> f a
anyOf = foldr (<|>) empty

-- | conditional rewriting: 'fail' when predicate is not met
require :: Monad m => Bool -> m ()
require p = unless p $ fail "requirement not met"

-- | 'fail' if given pattern succeeds, succeed if it fails.
requireFailure :: Monad m => PatternT n m a -> PatternT n m ()
requireFailure p = require . not =<< probe p

-- | 'fail' when monadic predicate is not met
requireM :: Monad m => m Bool -> m ()
requireM p = p >>= require

-- some base patterns --------------------------------------------------------

-- | Lift a scrutinisation from 'Reader' to 'Pattern' leaving the history unchanged.
liftReader :: Monad m => Reader (Graph n) a -> PatternT n m a
liftReader r = PatternT $ \h -> do
    x <- runReader r `liftM` ask
    return ([],x)

-- | any node anywhere in the graph
node :: (Monad m, View v n) => PatternT n m v
node = liftReader . inspectNode =<< branchNodes =<< liftReader readNodeList

-- | A specific node
nodeAt :: (Monad m, View v n) => Node -> PatternT n m v
nodeAt ref = do
    n <- liftReader $ inspectNode ref
    PatternT $ \h -> lift $ return ([ref],n)

-- | any edge anywhere in the graph
edge :: Monad m => PatternT n m Edge
edge = branch =<< liftReader readEdgeList

-- | node that is connected to given edge
nodeWith :: (Monad m, View v n) => Edge -> PatternT n m v
nodeWith e = liftReader . inspectNode =<< branchNodes =<< liftReader (attachedNodes e)

-- | edge that is attached to given node
edgeOf :: (Monad m, View [Port] n) => Node -> PatternT n m Edge
edgeOf n = branch =<< liftReader (attachedEdges n)

-- | node that is connected to the given node, but not that node itself
neighbour :: Monad m => (View [Port] n, View v n) => Node -> PatternT n m v
neighbour n = liftReader . inspectNode =<< branchNodes =<< liftReader (neighbours n)

-- | node that is connected to the given node, permitting the node itself
relative :: (Monad m, View [Port] n, View v n) => Node -> PatternT n m v
relative n = liftReader . inspectNode =<< branchNodes =<< liftReader (relatives n)

-- | nodes connected to given port of the specified node, not including the node itself.
-- Consider as an alternative 'linear' combined with 'nodeWith'.
adverse :: (Monad m, View [Port] n, View v n) => Port -> Node -> PatternT n m v
adverse p n = liftReader . inspectNode =<< branchNodes =<< liftReader (adverseNodes n p)

-- controlling history and future --------------------------------------------

-- | A specific node
visit :: Monad m => Node -> PatternT n m ()
visit n = do
    exists <- liftReader $ existNode n
    if exists
        then PatternT $ \h -> lift $ return ([n],())
        else fail $ "visit: node with ID " ⧺ show n ⧺ " does not exist"

-- | Do not remember any of the nodes matched by the supplied pattern
amnesia :: Monad m => PatternT n m a -> PatternT n m a
amnesia p = PatternT $ \h -> do
    (h',x) <- patternT p h
    return ([],x)

-- | list of nodes matched until now with the most recent node in head position
history :: Monad m => PatternT n m Match
history = PatternT $ \h -> return ([],h)

-- | a reference to the lastly matched node
previous :: Monad m => PatternT n m Node
previous = head <$> history

-- | only match nodes in the next pattern that have not been matched before
nextFresh :: Monad m => PatternT n m a -> PatternT n m a
nextFresh = restrictOverlap $ \past future -> null future ∨ not (head future ∈ past)

-- | only accept the given node in the next match
nextIs :: Monad m => Node -> PatternT n m a -> PatternT n m a
nextIs next = restrictOverlap $ \past future -> not (null future) ∧ head future ≡ next

-- | Restrict a pattern based on the which of nodes have matched been previously and which nodes will be matched in the future. The first parameter of the supplied function is the history with the most recently matched node in head position. The second parameter is the future with the next matched node in head position.
restrictOverlap :: Monad m => (Match -> Match -> Bool) -> PatternT n m a -> PatternT n m a
restrictOverlap c p = PatternT $ \h -> do
    (h',x) <- patternT p h
    require (c h h')
    return (h',x)
-- TODO: the check is only done after the whole pattern has matched (maybe do the check more often inbetween?)

-- | Nodes in the future may not be matched more than once.
linear :: Monad m => PatternT n m a -> PatternT n m a
linear = restrictOverlap $ \hist future -> isLinear Set.empty future where
    isLinear left [] = True
    isLinear left (r:rs) = not (r `Set.member` left) ∧ isLinear (r `Set.insert` left) rs

</pre>