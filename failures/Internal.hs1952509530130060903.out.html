<a href="Internal.hs19427277221083454666.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Internal.hs2014119113515204530.out.html">next</a></br></br><pre>64c64
< (⊕) ∷ Monoid m ⇒ m → m → m
---
> (⊕) :: Monoid m => m -> m -> m
68c68
< ø ∷ Monoid m ⇒ m
---
> ø :: Monoid m => m
72c72
< (≡) ∷ Eq a ⇒ a → a → Bool
---
> (≡) :: Eq a => a -> a -> Bool
76c76
< (≢) ∷ Eq a ⇒ a → a → Bool
---
> (≢) :: Eq a => a -> a -> Bool
80c80
< (≥) ∷ Ord a ⇒ a → a → Bool
---
> (≥) :: Ord a => a -> a -> Bool
84c84
< (≫) ∷ Monad m ⇒ m a → m b → m b
---
> (≫) :: Monad m => m a -> m b -> m b
90c90
<     | Partial (δ → Result δ r)
---
>     | Partial (δ -> Result δ r)
94d93
<     = Parser { runParser ∷ forall r. S δ
95d93
<                          → Failure     δ   r
96d93
<                          → Success     δ a r
97c94
<                          → Result      δ   r }
---
>     = Parser { runParser :: forall r. S δ
97a95
>                          -> Failure     δ   r
97a96
>                          -> Success     δ a r
97a97
>                          -> Result      δ   r }
99d98
< type Failure δ   r =     S δ → [String] → String → Result δ r
100c99
< type Success δ a r = a → S δ →                     Result δ r
---
> type Failure δ   r =     S δ -> [String] -> String -> Result δ r
100a100
> type Success δ a r = a -> S δ ->                     Result δ r
111d110
< data S δ = S { input ∷ !δ
112d110
<              , _added ∷ !δ
113c111
<              , more ∷ !More
---
> data S δ = S { input :: !δ
113a112
>              , _added :: !δ
113a113
>              , more :: !More
116c116
< instance (Show δ, Show r) ⇒ Show (Result δ r) where
---
> instance (Show δ, Show r) => Show (Result δ r) where
121c121
< instance Monoid δ ⇒ Monoid (S δ) where
---
> instance Monoid δ => Monoid (S δ) where
124d123
<     {-# SPECIALIZE mempty ∷ S B.ByteString #-}
125c124
<     {-# SPECIALIZE mempty ∷ S LB.ByteString #-}
---
>     {-# SPECIALIZE mempty :: S B.ByteString #-}
125a125
>     {-# SPECIALIZE mempty :: S LB.ByteString #-}
129d128
<     {-# SPECIALIZE mappend ∷ S B.ByteString → S B.ByteString → S B.ByteString #-}
130c129
<     {-# SPECIALIZE mappend ∷ S LB.ByteString → S LB.ByteString → S LB.ByteString #-}
---
>     {-# SPECIALIZE mappend :: S B.ByteString -> S B.ByteString -> S B.ByteString #-}
130a130
>     {-# SPECIALIZE mappend :: S LB.ByteString -> S LB.ByteString -> S LB.ByteString #-}
133c133
<     f `fmap` Parser p = Parser $ \s fa su → p s fa (su . f)
---
>     f `fmap` Parser p = Parser $ \s fa su -> p s fa (su . f)
136c136
< instance Monoid δ ⇒ Applicative (Parser δ) where
---
> instance Monoid δ => Applicative (Parser δ) where
139d138
<     {-# SPECIALIZE pure ∷ a → Parser B.ByteString a #-}
140c139
<     {-# SPECIALIZE pure ∷ a → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE pure :: a -> Parser B.ByteString a #-}
140a140
>     {-# SPECIALIZE pure :: a -> Parser LB.ByteString a #-}
143d142
<     {-# SPECIALIZE (<*>) ∷ Parser B.ByteString (a → b) → Parser B.ByteString a → Parser B.ByteString b #-}
144c143
<     {-# SPECIALIZE (<*>) ∷ Parser LB.ByteString (a → b) → Parser LB.ByteString a → Parser LB.ByteString b #-}
---
>     {-# SPECIALIZE (<*>) :: Parser B.ByteString (a -> b) -> Parser B.ByteString a -> Parser B.ByteString b #-}
144a144
>     {-# SPECIALIZE (<*>) :: Parser LB.ByteString (a -> b) -> Parser LB.ByteString a -> Parser LB.ByteString b #-}
147d146
<     {-# SPECIALIZE (*>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
148d146
<     {-# SPECIALIZE (*>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
149c147
<     x <* y = x >>= \a → y >> return a
---
>     {-# SPECIALIZE (*>) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString b #-}
149a148
>     {-# SPECIALIZE (*>) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString b #-}
149a149
>     x <* y = x >>= \a -> y >> return a
151d150
<     {-# SPECIALIZE (<*) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString a #-}
152c151
<     {-# SPECIALIZE (<*) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE (<*) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString a #-}
152a152
>     {-# SPECIALIZE (<*) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString a #-}
154d153
< instance Monoid δ ⇒ Monad (Parser δ) where
155c154
<     return x = Parser $ \s _ su → su x s
---
> instance Monoid δ => Monad (Parser δ) where
155a155
>     return x = Parser $ \s _ su -> su x s
157d156
<     {-# SPECIALIZE return ∷ a → Parser B.ByteString a #-}
158c157
<     {-# SPECIALIZE return ∷ a → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE return :: a -> Parser B.ByteString a #-}
158a158
>     {-# SPECIALIZE return :: a -> Parser LB.ByteString a #-}
160c160
<         = Parser $ \s fa su → p s fa (\a s' → runParser (g a) s' fa su)
---
>         = Parser $ \s fa su -> p s fa (\a s' -> runParser (g a) s' fa su)
162d161
<     {-# SPECIALIZE (>>=) ∷ Parser B.ByteString a → (a → Parser B.ByteString b) → Parser B.ByteString b #-}
163c162
<     {-# SPECIALIZE (>>=) ∷ Parser LB.ByteString a → (a → Parser LB.ByteString b) → Parser LB.ByteString b #-}
---
>     {-# SPECIALIZE (>>=) :: Parser B.ByteString a -> (a -> Parser B.ByteString b) -> Parser B.ByteString b #-}
163a163
>     {-# SPECIALIZE (>>=) :: Parser LB.ByteString a -> (a -> Parser LB.ByteString b) -> Parser LB.ByteString b #-}
165c165
<         = Parser $ \s fa su → p s fa (\_ s' → r s' fa su)
---
>         = Parser $ \s fa su -> p s fa (\_ s' -> r s' fa su)
167d166
<     {-# SPECIALIZE (>>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
168d166
<     {-# SPECIALIZE (>>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
169c167
<     fail err = Parser (\s fa _ → fa s [] ("Failed reading: " ++ err))
---
>     {-# SPECIALIZE (>>) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString b #-}
169a168
>     {-# SPECIALIZE (>>) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString b #-}
169a169
>     fail err = Parser (\s fa _ -> fa s [] ("Failed reading: " ++ err))
171d170
<     {-# SPECIALIZE fail ∷ String → Parser B.ByteString a #-}
172c171
<     {-# SPECIALIZE fail ∷ String → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE fail :: String -> Parser B.ByteString a #-}
172a172
>     {-# SPECIALIZE fail :: String -> Parser LB.ByteString a #-}
174c174
< instance Monoid δ ⇒ Monoid (Parser δ a) where
---
> instance Monoid δ => Monoid (Parser δ a) where
177d176
<     {-# SPECIALIZE mempty ∷ Parser B.ByteString a #-}
178c177
<     {-# SPECIALIZE mempty ∷ Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE mempty :: Parser B.ByteString a #-}
178a178
>     {-# SPECIALIZE mempty :: Parser LB.ByteString a #-}
180d179
<         = Parser $ \s fa su → let fa' s' _ _ = r (s ⊕ s') fa su
181d179
<                                   !s'' = noAdds s
182c180
<                               in p s'' fa' su
---
>         = Parser $ \s fa su -> let fa' s' _ _ = r (s ⊕ s') fa su
182a181
>                                    !s'' = noAdds s
182a182
>                                in p s'' fa' su
184d183
<     {-# SPECIALIZE mappend ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
185c184
<     {-# SPECIALIZE mappend ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE mappend :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
185a185
>     {-# SPECIALIZE mappend :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}
187c187
< instance Monoid δ ⇒ Alternative (Parser δ) where
---
> instance Monoid δ => Alternative (Parser δ) where
190d189
<     {-# SPECIALIZE empty ∷ Parser B.ByteString a #-}
191c190
<     {-# SPECIALIZE empty ∷ Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE empty :: Parser B.ByteString a #-}
191a191
>     {-# SPECIALIZE empty :: Parser LB.ByteString a #-}
194d193
<     {-# SPECIALIZE (<|>) ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
195c194
<     {-# SPECIALIZE (<|>) ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE (<|>) :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
195a195
>     {-# SPECIALIZE (<|>) :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}
197c197
< instance Monoid δ ⇒ MonadPlus (Parser δ) where
---
> instance Monoid δ => MonadPlus (Parser δ) where
200d199
<     {-# SPECIALIZE mzero ∷ Parser B.ByteString a #-}
201c200
<     {-# SPECIALIZE mzero ∷ Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE mzero :: Parser B.ByteString a #-}
201a201
>     {-# SPECIALIZE mzero :: Parser LB.ByteString a #-}
204d203
<     {-# SPECIALIZE mplus ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
205c204
<     {-# SPECIALIZE mplus ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}
---
>     {-# SPECIALIZE mplus :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
205a205
>     {-# SPECIALIZE mplus :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}
207c207
< instance (Eq δ, LL.ListLike δ ε, IsString δ) ⇒ IsString (Parser δ δ) where
---
> instance (Eq δ, LL.ListLike δ ε, IsString δ) => IsString (Parser δ δ) where
210c210
< noAdds ∷ Monoid δ ⇒ S δ → S δ
---
> noAdds :: Monoid δ => S δ -> S δ
213d212
< {-# SPECIALIZE noAdds ∷ S B.ByteString → S B.ByteString #-}
214c213
< {-# SPECIALIZE noAdds ∷ S LB.ByteString → S LB.ByteString #-}
---
> {-# SPECIALIZE noAdds :: S B.ByteString -> S B.ByteString #-}
214a214
> {-# SPECIALIZE noAdds :: S LB.ByteString -> S LB.ByteString #-}
217d216
< ensure ∷ LL.ListLike δ ε ⇒ Int → Parser δ ()
218c217
< ensure n = Parser $ \st@(S s _ _) fa su →
---
> ensure :: LL.ListLike δ ε => Int -> Parser δ ()
218a218
> ensure n = Parser $ \st@(S s _ _) fa su ->
222d221
< {-# SPECIALIZE ensure ∷ Int → Parser B.ByteString () #-}
223c222
< {-# SPECIALIZE ensure ∷ Int → Parser LB.ByteString () #-}
---
> {-# SPECIALIZE ensure :: Int -> Parser B.ByteString () #-}
223a223
> {-# SPECIALIZE ensure :: Int -> Parser LB.ByteString () #-}
227d226
< prompt ∷ LL.ListLike δ ε
228d226
<        ⇒ S δ → (S δ → Result δ r) → (S δ → Result δ r) → Result δ r
229c227
< prompt (S s a _) fa su = Partial $ \p →
---
> prompt :: LL.ListLike δ ε
229a228
>        => S δ -> (S δ -> Result δ r) -> (S δ -> Result δ r) -> Result δ r
229a229
> prompt (S s a _) fa su = Partial $ \p ->
233d232
< {-# SPECIALIZE prompt ∷ S B.ByteString
234d232
<                       → (S B.ByteString → Result B.ByteString r)
235d232
<                       → (S B.ByteString → Result B.ByteString r)
236d232
<                       → Result B.ByteString r #-}
237d232
< {-# SPECIALIZE prompt ∷ S LB.ByteString
238d232
<                       → (S LB.ByteString → Result LB.ByteString r)
239d232
<                       → (S LB.ByteString → Result LB.ByteString r)
240c233
<                       → Result LB.ByteString r #-}
---
> {-# SPECIALIZE prompt :: S B.ByteString
240a234
>                       -> (S B.ByteString -> Result B.ByteString r)
240a235
>                       -> (S B.ByteString -> Result B.ByteString r)
240a236
>                       -> Result B.ByteString r #-}
240a237
> {-# SPECIALIZE prompt :: S LB.ByteString
240a238
>                       -> (S LB.ByteString -> Result LB.ByteString r)
240a239
>                       -> (S LB.ByteString -> Result LB.ByteString r)
240a240
>                       -> Result LB.ByteString r #-}
244d243
< demandInput ∷ LL.ListLike δ ε ⇒ Parser δ ()
245c244
< demandInput = Parser $ \st fa su →
---
> demandInput :: LL.ListLike δ ε => Parser δ ()
245a245
> demandInput = Parser $ \st fa su ->
248c248
<         else prompt st (\st' → fa st' ["demandInput"] "not enough characters")
---
>         else prompt st (\st' -> fa st' ["demandInput"] "not enough characters")
250d249
< {-# SPECIALIZE demandInput ∷ Parser B.ByteString () #-}
251c250
< {-# SPECIALIZE demandInput ∷ Parser LB.ByteString () #-}
---
> {-# SPECIALIZE demandInput :: Parser B.ByteString () #-}
251a251
> {-# SPECIALIZE demandInput :: Parser LB.ByteString () #-}
256d255
< wantInput ∷ LL.ListLike δ ε ⇒ Parser δ Bool
257d255
< wantInput = Parser $ \st@(S s _ c) _ su → case () of
258d255
<   _ | not (LL.null s) → su True st
259d255
<     | c ≡ Complete    → su False st
260d255
<     | otherwise       → prompt st (su False) (su True)
261d255
< {-# SPECIALIZE wantInput ∷ Parser B.ByteString Bool #-}
262c256
< {-# SPECIALIZE wantInput ∷ Parser LB.ByteString Bool #-}
---
> wantInput :: LL.ListLike δ ε => Parser δ Bool
262a257
> wantInput = Parser $ \st@(S s _ c) _ su -> case () of
262a258
>   _ | not (LL.null s) -> su True st
262a259
>     | c ≡ Complete    -> su False st
262a260
>     | otherwise       -> prompt st (su False) (su True)
262a261
> {-# SPECIALIZE wantInput :: Parser B.ByteString Bool #-}
262a262
> {-# SPECIALIZE wantInput :: Parser LB.ByteString Bool #-}
264d263
< get ∷ Parser δ δ
265c264
< get = Parser (\st _ su → su (input st) st)
---
> get :: Parser δ δ
265a265
> get = Parser (\st _ su -> su (input st) st)
267d266
< put ∷ δ → Parser δ ()
268c267
< put s = Parser (\(S _ a c) _ su → su () (S s a c))
---
> put :: δ -> Parser δ ()
268a268
> put s = Parser (\(S _ a c) _ su -> su () (S s a c))
277d276
< try ∷ Monoid δ ⇒ Parser δ a → Parser δ a
278d276
< try p = Parser (\st fa su → runParser p (noAdds st) (fa . (st ⊕)) su)
279d276
< {-# SPECIALIZE try ∷ Parser B.ByteString a → Parser B.ByteString a #-}
280c277
< {-# SPECIALIZE try ∷ Parser LB.ByteString a → Parser LB.ByteString a #-}
---
> try :: Monoid δ => Parser δ a -> Parser δ a
280a278
> try p = Parser (\st fa su -> runParser p (noAdds st) (fa . (st ⊕)) su)
280a279
> {-# SPECIALIZE try :: Parser B.ByteString a -> Parser B.ByteString a #-}
280a280
> {-# SPECIALIZE try :: Parser LB.ByteString a -> Parser LB.ByteString a #-}
288c288
< satisfy ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ε
---
> satisfy :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ε
291c291
<     s ← get
---
>     s <- get
296d295
< {-# SPECIALIZE satisfy ∷ (Word8 → Bool) → Parser B.ByteString Word8 #-}
297c296
< {-# SPECIALIZE satisfy ∷ (Word8 → Bool) → Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE satisfy :: (Word8 -> Bool) -> Parser B.ByteString Word8 #-}
297a297
> {-# SPECIALIZE satisfy :: (Word8 -> Bool) -> Parser LB.ByteString Word8 #-}
304c304
< skip ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ()
---
> skip :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ()
307c307
<   s ← get
---
>   s <- get
311d310
< {-# SPECIALIZE skip ∷ (Word8 → Bool) → Parser B.ByteString () #-}
312c311
< {-# SPECIALIZE skip ∷ (Word8 → Bool) → Parser LB.ByteString () #-}
---
> {-# SPECIALIZE skip :: (Word8 -> Bool) -> Parser B.ByteString () #-}
312a312
> {-# SPECIALIZE skip :: (Word8 -> Bool) -> Parser LB.ByteString () #-}
317c317
< satisfyWith ∷ LL.ListLike δ ε ⇒ (ε → a) → (a → Bool) → Parser δ a
---
> satisfyWith :: LL.ListLike δ ε => (ε -> a) -> (a -> Bool) -> Parser δ a
320c320
<     s ← get
---
>     s <- get
325d324
< {-# SPECIALIZE satisfyWith ∷ (Word8 → a) → (a → Bool) → Parser B.ByteString a #-}
326c325
< {-# SPECIALIZE satisfyWith ∷ (Word8 → a) → (a → Bool) → Parser LB.ByteString a #-}
---
> {-# SPECIALIZE satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser B.ByteString a #-}
326a326
> {-# SPECIALIZE satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser LB.ByteString a #-}
330c330
< takeWith ∷ LL.ListLike δ ε ⇒ Int → (δ → Bool) → Parser δ δ
---
> takeWith :: LL.ListLike δ ε => Int -> (δ -> Bool) -> Parser δ δ
333c333
<     s ← get
---
>     s <- get
338d337
< {-# SPECIALIZE takeWith ∷ Int → (B.ByteString → Bool) → Parser B.ByteString B.ByteString #-}
339c338
< {-# SPECIALIZE takeWith ∷ Int → (LB.ByteString → Bool) → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE takeWith :: Int -> (B.ByteString -> Bool) -> Parser B.ByteString B.ByteString #-}
339a339
> {-# SPECIALIZE takeWith :: Int -> (LB.ByteString -> Bool) -> Parser LB.ByteString LB.ByteString #-}
342c342
< take ∷ LL.ListLike δ ε ⇒ Int → Parser δ δ
---
> take :: LL.ListLike δ ε => Int -> Parser δ δ
345d344
< {-# SPECIALIZE take ∷ Int → Parser B.ByteString B.ByteString #-}
346c345
< {-# SPECIALIZE take ∷ Int → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE take :: Int -> Parser B.ByteString B.ByteString #-}
346a346
> {-# SPECIALIZE take :: Int -> Parser LB.ByteString LB.ByteString #-}
363c363
< string ∷ (Eq δ, LL.ListLike δ ε) ⇒ δ → Parser δ δ
---
> string :: (Eq δ, LL.ListLike δ ε) => δ -> Parser δ δ
366d365
< {-# SPECIALIZE string ∷ B.ByteString → Parser B.ByteString B.ByteString #-}
367c366
< {-# SPECIALIZE string ∷ LB.ByteString → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE string :: B.ByteString -> Parser B.ByteString B.ByteString #-}
367a367
> {-# SPECIALIZE string :: LB.ByteString -> Parser LB.ByteString LB.ByteString #-}
369c369
< stringTransform ∷ (LL.ListLike δ ε, Eq δ) ⇒ (δ → δ) → δ → Parser δ δ
---
> stringTransform :: (LL.ListLike δ ε, Eq δ) => (δ -> δ) -> δ -> Parser δ δ
372d371
< {-# SPECIALIZE stringTransform ∷ (B.ByteString → B.ByteString) → B.ByteString → Parser B.ByteString B.ByteString #-}
373c372
< {-# SPECIALIZE stringTransform ∷ (LB.ByteString → LB.ByteString) → LB.ByteString → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE stringTransform :: (B.ByteString -> B.ByteString) -> B.ByteString -> Parser B.ByteString B.ByteString #-}
373a373
> {-# SPECIALIZE stringTransform :: (LB.ByteString -> LB.ByteString) -> LB.ByteString -> Parser LB.ByteString LB.ByteString #-}
375c375
< skipWhile ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ()
---
> skipWhile :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ()
378d377
<                       _ ← wantInput
379c378
<                       t ← LL.dropWhile p <$> get
---
>                       _ <- wantInput
379a379
>                       t <- LL.dropWhile p <$> get
382d381
< {-# SPECIALIZE skipWhile ∷ (Word8 → Bool) → Parser B.ByteString () #-}
383c382
< {-# SPECIALIZE skipWhile ∷ (Word8 → Bool) → Parser LB.ByteString () #-}
---
> {-# SPECIALIZE skipWhile :: (Word8 -> Bool) -> Parser B.ByteString () #-}
383a383
> {-# SPECIALIZE skipWhile :: (Word8 -> Bool) -> Parser LB.ByteString () #-}
394c394
< takeTill ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
---
> takeTill :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
397d396
< {-# SPECIALIZE takeTill ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
398c397
< {-# SPECIALIZE takeTill ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE takeTill :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
398a398
> {-# SPECIALIZE takeTill :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}
409c409
< takeWhile ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
---
> takeWhile :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
415c415
<                             (h, t) ← LL.span p <$> get
---
>                             (h, t) <- LL.span p <$> get
421d420
< {-# SPECIALIZE takeWhile ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
422c421
< {-# SPECIALIZE takeWhile ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE takeWhile :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
422a422
> {-# SPECIALIZE takeWhile :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}
430c430
< takeWhile1 ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
---
> takeWhile1 :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
433c433
<   (h, t) ← LL.span p <$> get
---
>   (h, t) <- LL.span p <$> get
439d438
< {-# SPECIALIZE takeWhile1 ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
440c439
< {-# SPECIALIZE takeWhile1 ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}
---
> {-# SPECIALIZE takeWhile1 :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
440a440
> {-# SPECIALIZE takeWhile1 :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}
442c442
< anyElem ∷ LL.ListLike δ ε ⇒ Parser δ ε
---
> anyElem :: LL.ListLike δ ε => Parser δ ε
445d444
< {-# SPECIALIZE anyElem ∷ Parser B.ByteString Word8 #-}
446c445
< {-# SPECIALIZE anyElem ∷ Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE anyElem :: Parser B.ByteString Word8 #-}
446a446
> {-# SPECIALIZE anyElem :: Parser LB.ByteString Word8 #-}
448c448
< elem ∷ (Eq ε, Show ε, LL.ListLike δ ε) ⇒ ε → Parser δ ε
---
> elem :: (Eq ε, Show ε, LL.ListLike δ ε) => ε -> Parser δ ε
451d450
< {-# SPECIALIZE elem ∷ Word8 → Parser B.ByteString Word8 #-}
452c451
< {-# SPECIALIZE elem ∷ Word8 → Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE elem :: Word8 -> Parser B.ByteString Word8 #-}
452a452
> {-# SPECIALIZE elem :: Word8 -> Parser LB.ByteString Word8 #-}
454c454
< notElem ∷ (Eq ε, Show ε, LL.ListLike δ ε) ⇒ ε → Parser δ ε
---
> notElem :: (Eq ε, Show ε, LL.ListLike δ ε) => ε -> Parser δ ε
457d456
< {-# SPECIALIZE notElem ∷ Word8 → Parser B.ByteString Word8 #-}
458c457
< {-# SPECIALIZE notElem ∷ Word8 → Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE notElem :: Word8 -> Parser B.ByteString Word8 #-}
458a458
> {-# SPECIALIZE notElem :: Word8 -> Parser LB.ByteString Word8 #-}
460c460
< elem' ∷ (Eq ε, LL.ListLike δ ε) ⇒ String → ε → Parser δ ε
---
> elem' :: (Eq ε, LL.ListLike δ ε) => String -> ε -> Parser δ ε
463d462
< {-# SPECIALIZE elem' ∷ String → Word8 → Parser B.ByteString Word8 #-}
464c463
< {-# SPECIALIZE elem' ∷ String → Word8 → Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE elem' :: String -> Word8 -> Parser B.ByteString Word8 #-}
464a464
> {-# SPECIALIZE elem' :: String -> Word8 -> Parser LB.ByteString Word8 #-}
466c466
< notElem' ∷ (Eq ε, LL.ListLike δ ε) ⇒ String → ε → Parser δ ε
---
> notElem' :: (Eq ε, LL.ListLike δ ε) => String -> ε -> Parser δ ε
469d468
< {-# SPECIALIZE notElem' ∷ String → Word8 → Parser B.ByteString Word8 #-}
470c469
< {-# SPECIALIZE notElem' ∷ String → Word8 → Parser LB.ByteString Word8 #-}
---
> {-# SPECIALIZE notElem' :: String -> Word8 -> Parser B.ByteString Word8 #-}
470a470
> {-# SPECIALIZE notElem' :: String -> Word8 -> Parser LB.ByteString Word8 #-}
473d472
< endOfInput ∷ LL.ListLike δ ε ⇒ Parser δ ()
474d472
< endOfInput = Parser $ \st@(S i _ mo) fa su → case () of
475d472
<     _ | not (LL.null i) → fa    st [] "endOfInput"
476d472
<       | mo ≡ Complete   → su () st
477d472
<       | otherwise       → let su' _ st'     = su () (st ⊕ st')
478d472
<                               fa'   st' _ _ = fa    (st ⊕ st') [] "endOfInput"
479d472
<                           in runParser demandInput st fa' su'
480d472
< {-# SPECIALIZE endOfInput ∷ Parser B.ByteString () #-}
481c473
< {-# SPECIALIZE endOfInput ∷ Parser LB.ByteString () #-}
---
> endOfInput :: LL.ListLike δ ε => Parser δ ()
481a474
> endOfInput = Parser $ \st@(S i _ mo) fa su -> case () of
481a475
>     _ | not (LL.null i) -> fa    st [] "endOfInput"
481a476
>       | mo ≡ Complete   -> su () st
481a477
>       | otherwise       -> let su' _ st'     = su () (st ⊕ st')
481a478
>                                fa'   st' _ _ = fa    (st ⊕ st') [] "endOfInput"
481a479
>                            in runParser demandInput st fa' su'
481a480
> {-# SPECIALIZE endOfInput :: Parser B.ByteString () #-}
481a481
> {-# SPECIALIZE endOfInput :: Parser LB.ByteString () #-}
485d484
< (<?>) ∷ Parser δ a → String → Parser δ a
486c485
< p <?> ms = Parser $ \s fa su → runParser p s (\s' sts m → fa s' (ms:sts) m) su
---
> (<?>) :: Parser δ a -> String -> Parser δ a
486a486
> p <?> ms = Parser $ \s fa su -> runParser p s (\s' sts m -> fa s' (ms:sts) m) su
491c491
< parse ∷ Monoid δ ⇒ Parser δ a → δ → Result δ a
---
> parse :: Monoid δ => Parser δ a -> δ -> Result δ a
494d493
< {-# SPECIALIZE parse ∷ Parser B.ByteString a → B.ByteString → Result B.ByteString a #-}
495c494
< {-# SPECIALIZE parse ∷ Parser LB.ByteString a → LB.ByteString → Result LB.ByteString a #-}
---
> {-# SPECIALIZE parse :: Parser B.ByteString a -> B.ByteString -> Result B.ByteString a #-}
495a495
> {-# SPECIALIZE parse :: Parser LB.ByteString a -> LB.ByteString -> Result LB.ByteString a #-}
495a496
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-|
Module      : Data.Nanoparsec.Internal
Copyright   : © 2011  Maciej Piechotka
License     : BSD3

Maintainer  : uzytkownik2@gmail.com
Stability   : experimental
Portability :
-}
module Data.Nanoparsec.Internal
  (
    -- * Parser types
    Parser
  , Result(..)
  , S(input)

    -- * Running parsers
  , parse

    -- * Combinators
  , (<?>)
  , try

    -- * Parsing individual elements
  , satisfy
  , satisfyWith
  , anyElem
  , skip
  , elem
  , notElem
  , elem'
  , notElem'

    -- * Efficient substring handling
  , skipWhile
  , string
  , stringTransform
  , take
  , takeWhile
  , takeWhile1
  , takeTill

    -- * State observation and manipulation functions
  , endOfInput
  , ensure
  )
where

import Control.Applicative
import Control.Monad
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as LB
import Data.Monoid
import Data.String
import qualified Data.ListLike as LL
import Data.Word
import Prelude hiding (take, takeWhile, elem, notElem)

(⊕) ∷ Monoid m ⇒ m → m → m
(⊕) = mappend
{-# INLINE (⊕) #-}

ø ∷ Monoid m ⇒ m
ø = mempty
{-# INLINE ø #-}

(≡) ∷ Eq a ⇒ a → a → Bool
(≡) = (==)
{-# INLINE (≡) #-}

(≢) ∷ Eq a ⇒ a → a → Bool
(≢) = (/=)
{-# INLINE (≢) #-}

(≥) ∷ Ord a ⇒ a → a → Bool
(≥) = (>=)
{-# INLINE (≥) #-}

(≫) ∷ Monad m ⇒ m a → m b → m b
(≫) = (>>)
{-# INLINE (≫) #-}

data Result δ r
    = Fail (S δ) [String] String
    | Partial (δ → Result δ r)
    | Done r (S δ)

newtype Parser δ a
    = Parser { runParser ∷ forall r. S δ
                         → Failure     δ   r
                         → Success     δ a r
                         → Result      δ   r }

type Failure δ   r =     S δ → [String] → String → Result δ r
type Success δ a r = a → S δ →                     Result δ r

data More = Complete | Incomplete deriving (Eq, Show)

instance Monoid More where
    mappend Complete _        = Complete
    mappend _        Complete = Complete
    mappend _        _        = Incomplete
    mempty                    = Incomplete
    {-# INLINE mappend #-}

data S δ = S { input ∷ !δ
             , _added ∷ !δ
             , more ∷ !More
             } deriving (Show)

instance (Show δ, Show r) ⇒ Show (Result δ r) where
    show (Fail _ stack msg) = "Fail " ++ show stack ++ " " ++ show msg
    show (Partial _)        = "Partial _"
    show (Done str r)       = "Done " ++ show str ++ " " ++ show r

instance Monoid δ ⇒ Monoid (S δ) where
    mempty = S mempty mempty mempty
    {-# INLINE mempty #-}
    {-# SPECIALIZE mempty ∷ S B.ByteString #-}
    {-# SPECIALIZE mempty ∷ S LB.ByteString #-}
    mappend (S inp add mor) (S _ add' mor')
        = S (inp ⊕ add') (add ⊕ add') (mor ⊕ mor')
    {-# INLINE mappend #-}
    {-# SPECIALIZE mappend ∷ S B.ByteString → S B.ByteString → S B.ByteString #-}
    {-# SPECIALIZE mappend ∷ S LB.ByteString → S LB.ByteString → S LB.ByteString #-}

instance Functor (Parser δ) where
    f `fmap` Parser p = Parser $ \s fa su → p s fa (su . f)
    {-# INLINE fmap #-}

instance Monoid δ ⇒ Applicative (Parser δ) where
    pure = return
    {-# INLINE pure #-}
    {-# SPECIALIZE pure ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE pure ∷ a → Parser LB.ByteString a #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
    {-# SPECIALIZE (<*>) ∷ Parser B.ByteString (a → b) → Parser B.ByteString a → Parser B.ByteString b #-}
    {-# SPECIALIZE (<*>) ∷ Parser LB.ByteString (a → b) → Parser LB.ByteString a → Parser LB.ByteString b #-}
    (*>) = (>>)
    {-# INLINE (*>) #-}
    {-# SPECIALIZE (*>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (*>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    x <* y = x >>= \a → y >> return a
    {-# INLINE (<*) #-}
    {-# SPECIALIZE (<*) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString a #-}
    {-# SPECIALIZE (<*) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString a #-}

instance Monoid δ ⇒ Monad (Parser δ) where
    return x = Parser $ \s _ su → su x s
    {-# INLINE return #-}
    {-# SPECIALIZE return ∷ a → Parser B.ByteString a #-}
    {-# SPECIALIZE return ∷ a → Parser LB.ByteString a #-}
    Parser p >>= g
        = Parser $ \s fa su → p s fa (\a s' → runParser (g a) s' fa su)
    {-# INLINE (>>=) #-}
    {-# SPECIALIZE (>>=) ∷ Parser B.ByteString a → (a → Parser B.ByteString b) → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>=) ∷ Parser LB.ByteString a → (a → Parser LB.ByteString b) → Parser LB.ByteString b #-}
    Parser p >> Parser r
        = Parser $ \s fa su → p s fa (\_ s' → r s' fa su)
    {-# INLINE (>>) #-}
    {-# SPECIALIZE (>>) ∷ Parser B.ByteString a → Parser B.ByteString b → Parser B.ByteString b #-}
    {-# SPECIALIZE (>>) ∷ Parser LB.ByteString a → Parser LB.ByteString b → Parser LB.ByteString b #-}
    fail err = Parser (\s fa _ → fa s [] ("Failed reading: " ++ err))
    {-# INLINE fail #-}
    {-# SPECIALIZE fail ∷ String → Parser B.ByteString a #-}
    {-# SPECIALIZE fail ∷ String → Parser LB.ByteString a #-}

instance Monoid δ ⇒ Monoid (Parser δ a) where
    mempty = fail "mempty"
    {-# INLINE mempty #-}
    {-# SPECIALIZE mempty ∷ Parser B.ByteString a #-}
    {-# SPECIALIZE mempty ∷ Parser LB.ByteString a #-}
    Parser p `mappend` Parser r
        = Parser $ \s fa su → let fa' s' _ _ = r (s ⊕ s') fa su
                                  !s'' = noAdds s
                              in p s'' fa' su
    {-# INLINE mappend #-}
    {-# SPECIALIZE mappend ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
    {-# SPECIALIZE mappend ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}

instance Monoid δ ⇒ Alternative (Parser δ) where
    empty = fail "empty"
    {-# INLINE empty #-}
    {-# SPECIALIZE empty ∷ Parser B.ByteString a #-}
    {-# SPECIALIZE empty ∷ Parser LB.ByteString a #-}
    (<|>) = mappend
    {-# INLINE (<|>) #-}
    {-# SPECIALIZE (<|>) ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
    {-# SPECIALIZE (<|>) ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}

instance Monoid δ ⇒ MonadPlus (Parser δ) where
    mzero = fail "mzero"
    {-# INLINE mzero #-}
    {-# SPECIALIZE mzero ∷ Parser B.ByteString a #-}
    {-# SPECIALIZE mzero ∷ Parser LB.ByteString a #-}
    mplus = mappend
    {-# INLINE mplus #-}
    {-# SPECIALIZE mplus ∷ Parser B.ByteString a → Parser B.ByteString a → Parser B.ByteString a #-}
    {-# SPECIALIZE mplus ∷ Parser LB.ByteString a → Parser LB.ByteString a → Parser LB.ByteString a #-}

instance (Eq δ, LL.ListLike δ ε, IsString δ) ⇒ IsString (Parser δ δ) where
    fromString = string . fromString

noAdds ∷ Monoid δ ⇒ S δ → S δ
noAdds (S s _ c) = S s ø c
{-# INLINE noAdds #-}
{-# SPECIALIZE noAdds ∷ S B.ByteString → S B.ByteString #-}
{-# SPECIALIZE noAdds ∷ S LB.ByteString → S LB.ByteString #-}

-- | Succeed only if at least @n@ elements of input are available.
ensure ∷ LL.ListLike δ ε ⇒ Int → Parser δ ()
ensure n = Parser $ \st@(S s _ _) fa su →
    if LL.length s ≥ n
        then su () st
        else runParser (demandInput ≫ ensure n) st fa su
{-# SPECIALIZE ensure ∷ Int → Parser B.ByteString () #-}
{-# SPECIALIZE ensure ∷ Int → Parser LB.ByteString () #-}

-- | Ask for input.  If we receive any, pass it to a success
-- continuation, otherwise to a failure continuation.
prompt ∷ LL.ListLike δ ε
       ⇒ S δ → (S δ → Result δ r) → (S δ → Result δ r) → Result δ r
prompt (S s a _) fa su = Partial $ \p →
    if LL.null s
        then fa $ S s a Complete
        else su $ S (s ⊕ p) (a ⊕ p) Incomplete
{-# SPECIALIZE prompt ∷ S B.ByteString
                      → (S B.ByteString → Result B.ByteString r)
                      → (S B.ByteString → Result B.ByteString r)
                      → Result B.ByteString r #-}
{-# SPECIALIZE prompt ∷ S LB.ByteString
                      → (S LB.ByteString → Result LB.ByteString r)
                      → (S LB.ByteString → Result LB.ByteString r)
                      → Result LB.ByteString r #-}

-- | Immediately demand more input via a 'Partial' continuation
-- result.
demandInput ∷ LL.ListLike δ ε ⇒ Parser δ ()
demandInput = Parser $ \st fa su →
    if more st ≡ Complete
        then fa st ["demandInput"] "not enough characters"
        else prompt st (\st' → fa st' ["demandInput"] "not enough characters")
                       (su ())
{-# SPECIALIZE demandInput ∷ Parser B.ByteString () #-}
{-# SPECIALIZE demandInput ∷ Parser LB.ByteString () #-}

-- | This parser always succeeds.  It returns 'True' if any input is
-- available either immediately or on demand, and 'False' if the end
-- of all input has been reached.
wantInput ∷ LL.ListLike δ ε ⇒ Parser δ Bool
wantInput = Parser $ \st@(S s _ c) _ su → case () of
  _ | not (LL.null s) → su True st
    | c ≡ Complete    → su False st
    | otherwise       → prompt st (su False) (su True)
{-# SPECIALIZE wantInput ∷ Parser B.ByteString Bool #-}
{-# SPECIALIZE wantInput ∷ Parser LB.ByteString Bool #-}

get ∷ Parser δ δ
get = Parser (\st _ su → su (input st) st)

put ∷ δ → Parser δ ()
put s = Parser (\(S _ a c) _ su → su () (S s a c))

-- | Attempt a parse, and if it fails, rewind the input so that no
-- input appears to have been consumed.
--
-- This combinator is useful in cases where a parser might consume
-- some input before failing, i.e. the parser needs arbitrary
-- lookahead.  The downside to using this combinator is that it can
-- retain input for longer than is desirable.
try ∷ Monoid δ ⇒ Parser δ a → Parser δ a
try p = Parser (\st fa su → runParser p (noAdds st) (fa . (st ⊕)) su)
{-# SPECIALIZE try ∷ Parser B.ByteString a → Parser B.ByteString a #-}
{-# SPECIALIZE try ∷ Parser LB.ByteString a → Parser LB.ByteString a #-}

-- | The parser @satisfy p@ succeeds for any element for which the
-- predicate @p@ returns 'True'. Returns the element that is actually
-- parsed.
--
-- >digit = satisfy isDigit
-- >    where isDigit w = w >= 48 && w <= 57
satisfy ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ε
satisfy p = do
    ensure 1
    s ← get
    let w = LL.head s
    if p w
        then put (LL.tail s) ≫ return w
        else fail "satisfy"
{-# SPECIALIZE satisfy ∷ (Word8 → Bool) → Parser B.ByteString Word8 #-}
{-# SPECIALIZE satisfy ∷ (Word8 → Bool) → Parser LB.ByteString Word8 #-}

-- | The parser @skip p@ succeeds for any element for which the predicate
-- @p@ returns 'True'.
--
-- >space = skip isSpace
-- >    where isDigit w = w == 9 || w == 10 || w == 13 || w == 32
skip ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ()
skip p = do
  ensure 1
  s ← get
  if p (LL.head s)
      then put (LL.tail s)
      else fail "skip"
{-# SPECIALIZE skip ∷ (Word8 → Bool) → Parser B.ByteString () #-}
{-# SPECIALIZE skip ∷ (Word8 → Bool) → Parser LB.ByteString () #-}

-- | The parser @satisfyWith f p@ transforms an element, and succeeds if
-- the predicate @p@ returns 'True' on the transformed value. The
-- parser returns the transformed element that was parsed.
satisfyWith ∷ LL.ListLike δ ε ⇒ (ε → a) → (a → Bool) → Parser δ a
satisfyWith f p = do
    ensure 1
    s ← get
    let c = f (LL.head s)
    if p c
        then put (LL.tail s) ≫ return c
        else fail "satisfyWith"
{-# SPECIALIZE satisfyWith ∷ (Word8 → a) → (a → Bool) → Parser B.ByteString a #-}
{-# SPECIALIZE satisfyWith ∷ (Word8 → a) → (a → Bool) → Parser LB.ByteString a #-}

-- | Consume @n@ element of input, but succeed only if the predicate
-- returns 'True'.
takeWith ∷ LL.ListLike δ ε ⇒ Int → (δ → Bool) → Parser δ δ
takeWith n p = do
    ensure n
    s ← get
    let (h, t) = LL.splitAt n s
    if p h
        then put t ≫ return h
        else fail "takeWith"
{-# SPECIALIZE takeWith ∷ Int → (B.ByteString → Bool) → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWith ∷ Int → (LB.ByteString → Bool) → Parser LB.ByteString LB.ByteString #-}

-- | Consume exactly @n@ elements of input.
take ∷ LL.ListLike δ ε ⇒ Int → Parser δ δ
take n = takeWith n (const True)
{-# INLINE take #-}
{-# SPECIALIZE take ∷ Int → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE take ∷ Int → Parser LB.ByteString LB.ByteString #-}

-- | @string s@ parses a sequence of elements that identically match
-- @s@. Returns the parsed string (i.e. @s@).  This parser consumes no
-- input if it fails (even if a partial match).
--
-- /Note/: The behaviour of this parser is different to that of the
-- similarly-named parser in Parsec, as this one is all-or-nothing.
-- To illustrate the difference, the following parser will fail under
-- Parsec given an input of @"for"@:
--
-- >string "foo" <|> string "for"
--
-- The reason for its failure is that that the first branch is a
-- partial match, and will consume the letters @\'f\'@ and @\'o\'@
-- before failing.  In Nnaoparsec, the above parser will /succeed/ on
-- that input, because the failed first branch will consume nothing.
string ∷ (Eq δ, LL.ListLike δ ε) ⇒ δ → Parser δ δ
string s = takeWith (LL.length s) (≡ s)
{-# INLINE string #-}
{-# SPECIALIZE string ∷ B.ByteString → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE string ∷ LB.ByteString → Parser LB.ByteString LB.ByteString #-}

stringTransform ∷ (LL.ListLike δ ε, Eq δ) ⇒ (δ → δ) → δ → Parser δ δ
stringTransform f s = takeWith (LL.length s) ((≡ f s) . f)
{-# INLINE stringTransform #-}
{-# SPECIALIZE stringTransform ∷ (B.ByteString → B.ByteString) → B.ByteString → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE stringTransform ∷ (LB.ByteString → LB.ByteString) → LB.ByteString → Parser LB.ByteString LB.ByteString #-}

skipWhile ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ ()
skipWhile p = go
              where go = do
                      _ ← wantInput
                      t ← LL.dropWhile p <$> get
                      put t
                      when (LL.null t) go
{-# SPECIALIZE skipWhile ∷ (Word8 → Bool) → Parser B.ByteString () #-}
{-# SPECIALIZE skipWhile ∷ (Word8 → Bool) → Parser LB.ByteString () #-}

-- | Consume input as long as the predicate returns 'False'
-- (i.e. until it returns 'True'), and return the consumed input.
--
-- This parser does not fail.  It will return an empty string if the
-- predicate returns 'True' on the first element of input.
--
-- /Note/: Because this parser does not fail, do not use it with
-- combinators such as 'many', because such parsers loop until a
-- failure occurs.  Careless use will thus result in an infinite loop.
takeTill ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
takeTill p = takeWhile (not . p)
{-# INLINE takeTill #-}
{-# SPECIALIZE takeTill ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeTill ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}

-- | Consume input as long as the predicate returns 'True', and return
-- the consumed input.
--
-- This parser does not fail.  It will return an empty string if the
-- predicate returns 'False' on the first element of input.
--
-- /Note/: Because this parser does not fail, do not use it with
-- combinators such as 'many', because such parsers loop until a
-- failure occurs.  Careless use will thus result in an infinite loop.
takeWhile ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
takeWhile p = go ø
              where go acc = do
                      inp <- wantInput
                      if inp
                          then do
                            (h, t) ← LL.span p <$> get
                            put t
                            if (LL.null t)
                                then go (h ⊕ acc)
                                else return h
                          else return ø
{-# SPECIALIZE takeWhile ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWhile ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}

-- | Consume input as long as the predicate returns 'True', and return
-- the consumed input.
--
-- This parser requires the predicate to succeed on at least one element
-- of input: it will fail if the predicate never returns 'True' or if
-- there is no input left.
takeWhile1 ∷ LL.ListLike δ ε ⇒ (ε → Bool) → Parser δ δ
takeWhile1 p = do
  (`when` demandInput) =<< LL.null <$> get
  (h, t) ← LL.span p <$> get
  when (LL.null h) $ fail "takeWhile1"
  put t
  if LL.null t
      then (h ⊕) `fmap` takeWhile p
      else return h
{-# SPECIALIZE takeWhile1 ∷ (Word8 → Bool) → Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWhile1 ∷ (Word8 → Bool) → Parser LB.ByteString LB.ByteString #-}

anyElem ∷ LL.ListLike δ ε ⇒ Parser δ ε
anyElem = satisfy (const True)
{-# INLINE anyElem #-}
{-# SPECIALIZE anyElem ∷ Parser B.ByteString Word8 #-}
{-# SPECIALIZE anyElem ∷ Parser LB.ByteString Word8 #-}

elem ∷ (Eq ε, Show ε, LL.ListLike δ ε) ⇒ ε → Parser δ ε
elem x = elem' (show x) x
{-# INLINE elem #-}
{-# SPECIALIZE elem ∷ Word8 → Parser B.ByteString Word8 #-}
{-# SPECIALIZE elem ∷ Word8 → Parser LB.ByteString Word8 #-}

notElem ∷ (Eq ε, Show ε, LL.ListLike δ ε) ⇒ ε → Parser δ ε
notElem x = notElem' ("not " ⊕ show x) x
{-# INLINE notElem #-}
{-# SPECIALIZE notElem ∷ Word8 → Parser B.ByteString Word8 #-}
{-# SPECIALIZE notElem ∷ Word8 → Parser LB.ByteString Word8 #-}

elem' ∷ (Eq ε, LL.ListLike δ ε) ⇒ String → ε → Parser δ ε
elem' p c = satisfy (≡ c) <?> p
{-# INLINE elem' #-}
{-# SPECIALIZE elem' ∷ String → Word8 → Parser B.ByteString Word8 #-}
{-# SPECIALIZE elem' ∷ String → Word8 → Parser LB.ByteString Word8 #-}

notElem' ∷ (Eq ε, LL.ListLike δ ε) ⇒ String → ε → Parser δ ε
notElem' p c = satisfy (≢ c) <?> p
{-# INLINE notElem' #-}
{-# SPECIALIZE notElem' ∷ String → Word8 → Parser B.ByteString Word8 #-}
{-# SPECIALIZE notElem' ∷ String → Word8 → Parser LB.ByteString Word8 #-}

-- | Match only if all input has been consumed.
endOfInput ∷ LL.ListLike δ ε ⇒ Parser δ ()
endOfInput = Parser $ \st@(S i _ mo) fa su → case () of
    _ | not (LL.null i) → fa    st [] "endOfInput"
      | mo ≡ Complete   → su () st
      | otherwise       → let su' _ st'     = su () (st ⊕ st')
                              fa'   st' _ _ = fa    (st ⊕ st') [] "endOfInput"
                          in runParser demandInput st fa' su'
{-# SPECIALIZE endOfInput ∷ Parser B.ByteString () #-}
{-# SPECIALIZE endOfInput ∷ Parser LB.ByteString () #-}

-- | Match either a single newline character @\'\\n\'@, or a carriage
-- return followed by a newline character @\"\\r\\n\"@.
(<?>) ∷ Parser δ a → String → Parser δ a
p <?> ms = Parser $ \s fa su → runParser p s (\s' sts m → fa s' (ms:sts) m) su
{-# INLINE (<?>) #-}
infix 0 <?>

-- | Run a parser.
parse ∷ Monoid δ ⇒ Parser δ a → δ → Result δ a
parse m s = runParser m (S s ø Incomplete) Fail Done
{-# INLINE parse #-}
{-# SPECIALIZE parse ∷ Parser B.ByteString a → B.ByteString → Result B.ByteString a #-}
{-# SPECIALIZE parse ∷ Parser LB.ByteString a → LB.ByteString → Result LB.ByteString a #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-|
Module      : Data.Nanoparsec.Internal
Copyright   : © 2011  Maciej Piechotka
License     : BSD3

Maintainer  : uzytkownik2@gmail.com
Stability   : experimental
Portability :
-}
module Data.Nanoparsec.Internal
  (
    -- * Parser types
    Parser
  , Result(..)
  , S(input)

    -- * Running parsers
  , parse

    -- * Combinators
  , (<?>)
  , try

    -- * Parsing individual elements
  , satisfy
  , satisfyWith
  , anyElem
  , skip
  , elem
  , notElem
  , elem'
  , notElem'

    -- * Efficient substring handling
  , skipWhile
  , string
  , stringTransform
  , take
  , takeWhile
  , takeWhile1
  , takeTill

    -- * State observation and manipulation functions
  , endOfInput
  , ensure
  )
where

import Control.Applicative
import Control.Monad
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as LB
import Data.Monoid
import Data.String
import qualified Data.ListLike as LL
import Data.Word
import Prelude hiding (take, takeWhile, elem, notElem)

(⊕) :: Monoid m => m -> m -> m
(⊕) = mappend
{-# INLINE (⊕) #-}

ø :: Monoid m => m
ø = mempty
{-# INLINE ø #-}

(≡) :: Eq a => a -> a -> Bool
(≡) = (==)
{-# INLINE (≡) #-}

(≢) :: Eq a => a -> a -> Bool
(≢) = (/=)
{-# INLINE (≢) #-}

(≥) :: Ord a => a -> a -> Bool
(≥) = (>=)
{-# INLINE (≥) #-}

(≫) :: Monad m => m a -> m b -> m b
(≫) = (>>)
{-# INLINE (≫) #-}

data Result δ r
    = Fail (S δ) [String] String
    | Partial (δ -> Result δ r)
    | Done r (S δ)

newtype Parser δ a
    = Parser { runParser :: forall r. S δ
                         -> Failure     δ   r
                         -> Success     δ a r
                         -> Result      δ   r }

type Failure δ   r =     S δ -> [String] -> String -> Result δ r
type Success δ a r = a -> S δ ->                     Result δ r

data More = Complete | Incomplete deriving (Eq, Show)

instance Monoid More where
    mappend Complete _        = Complete
    mappend _        Complete = Complete
    mappend _        _        = Incomplete
    mempty                    = Incomplete
    {-# INLINE mappend #-}

data S δ = S { input :: !δ
             , _added :: !δ
             , more :: !More
             } deriving (Show)

instance (Show δ, Show r) => Show (Result δ r) where
    show (Fail _ stack msg) = "Fail " ++ show stack ++ " " ++ show msg
    show (Partial _)        = "Partial _"
    show (Done str r)       = "Done " ++ show str ++ " " ++ show r

instance Monoid δ => Monoid (S δ) where
    mempty = S mempty mempty mempty
    {-# INLINE mempty #-}
    {-# SPECIALIZE mempty :: S B.ByteString #-}
    {-# SPECIALIZE mempty :: S LB.ByteString #-}
    mappend (S inp add mor) (S _ add' mor')
        = S (inp ⊕ add') (add ⊕ add') (mor ⊕ mor')
    {-# INLINE mappend #-}
    {-# SPECIALIZE mappend :: S B.ByteString -> S B.ByteString -> S B.ByteString #-}
    {-# SPECIALIZE mappend :: S LB.ByteString -> S LB.ByteString -> S LB.ByteString #-}

instance Functor (Parser δ) where
    f `fmap` Parser p = Parser $ \s fa su -> p s fa (su . f)
    {-# INLINE fmap #-}

instance Monoid δ => Applicative (Parser δ) where
    pure = return
    {-# INLINE pure #-}
    {-# SPECIALIZE pure :: a -> Parser B.ByteString a #-}
    {-# SPECIALIZE pure :: a -> Parser LB.ByteString a #-}
    (<*>) = ap
    {-# INLINE (<*>) #-}
    {-# SPECIALIZE (<*>) :: Parser B.ByteString (a -> b) -> Parser B.ByteString a -> Parser B.ByteString b #-}
    {-# SPECIALIZE (<*>) :: Parser LB.ByteString (a -> b) -> Parser LB.ByteString a -> Parser LB.ByteString b #-}
    (*>) = (>>)
    {-# INLINE (*>) #-}
    {-# SPECIALIZE (*>) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString b #-}
    {-# SPECIALIZE (*>) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString b #-}
    x <* y = x >>= \a -> y >> return a
    {-# INLINE (<*) #-}
    {-# SPECIALIZE (<*) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString a #-}
    {-# SPECIALIZE (<*) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString a #-}

instance Monoid δ => Monad (Parser δ) where
    return x = Parser $ \s _ su -> su x s
    {-# INLINE return #-}
    {-# SPECIALIZE return :: a -> Parser B.ByteString a #-}
    {-# SPECIALIZE return :: a -> Parser LB.ByteString a #-}
    Parser p >>= g
        = Parser $ \s fa su -> p s fa (\a s' -> runParser (g a) s' fa su)
    {-# INLINE (>>=) #-}
    {-# SPECIALIZE (>>=) :: Parser B.ByteString a -> (a -> Parser B.ByteString b) -> Parser B.ByteString b #-}
    {-# SPECIALIZE (>>=) :: Parser LB.ByteString a -> (a -> Parser LB.ByteString b) -> Parser LB.ByteString b #-}
    Parser p >> Parser r
        = Parser $ \s fa su -> p s fa (\_ s' -> r s' fa su)
    {-# INLINE (>>) #-}
    {-# SPECIALIZE (>>) :: Parser B.ByteString a -> Parser B.ByteString b -> Parser B.ByteString b #-}
    {-# SPECIALIZE (>>) :: Parser LB.ByteString a -> Parser LB.ByteString b -> Parser LB.ByteString b #-}
    fail err = Parser (\s fa _ -> fa s [] ("Failed reading: " ++ err))
    {-# INLINE fail #-}
    {-# SPECIALIZE fail :: String -> Parser B.ByteString a #-}
    {-# SPECIALIZE fail :: String -> Parser LB.ByteString a #-}

instance Monoid δ => Monoid (Parser δ a) where
    mempty = fail "mempty"
    {-# INLINE mempty #-}
    {-# SPECIALIZE mempty :: Parser B.ByteString a #-}
    {-# SPECIALIZE mempty :: Parser LB.ByteString a #-}
    Parser p `mappend` Parser r
        = Parser $ \s fa su -> let fa' s' _ _ = r (s ⊕ s') fa su
                                   !s'' = noAdds s
                               in p s'' fa' su
    {-# INLINE mappend #-}
    {-# SPECIALIZE mappend :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
    {-# SPECIALIZE mappend :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}

instance Monoid δ => Alternative (Parser δ) where
    empty = fail "empty"
    {-# INLINE empty #-}
    {-# SPECIALIZE empty :: Parser B.ByteString a #-}
    {-# SPECIALIZE empty :: Parser LB.ByteString a #-}
    (<|>) = mappend
    {-# INLINE (<|>) #-}
    {-# SPECIALIZE (<|>) :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
    {-# SPECIALIZE (<|>) :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}

instance Monoid δ => MonadPlus (Parser δ) where
    mzero = fail "mzero"
    {-# INLINE mzero #-}
    {-# SPECIALIZE mzero :: Parser B.ByteString a #-}
    {-# SPECIALIZE mzero :: Parser LB.ByteString a #-}
    mplus = mappend
    {-# INLINE mplus #-}
    {-# SPECIALIZE mplus :: Parser B.ByteString a -> Parser B.ByteString a -> Parser B.ByteString a #-}
    {-# SPECIALIZE mplus :: Parser LB.ByteString a -> Parser LB.ByteString a -> Parser LB.ByteString a #-}

instance (Eq δ, LL.ListLike δ ε, IsString δ) => IsString (Parser δ δ) where
    fromString = string . fromString

noAdds :: Monoid δ => S δ -> S δ
noAdds (S s _ c) = S s ø c
{-# INLINE noAdds #-}
{-# SPECIALIZE noAdds :: S B.ByteString -> S B.ByteString #-}
{-# SPECIALIZE noAdds :: S LB.ByteString -> S LB.ByteString #-}

-- | Succeed only if at least @n@ elements of input are available.
ensure :: LL.ListLike δ ε => Int -> Parser δ ()
ensure n = Parser $ \st@(S s _ _) fa su ->
    if LL.length s ≥ n
        then su () st
        else runParser (demandInput ≫ ensure n) st fa su
{-# SPECIALIZE ensure :: Int -> Parser B.ByteString () #-}
{-# SPECIALIZE ensure :: Int -> Parser LB.ByteString () #-}

-- | Ask for input.  If we receive any, pass it to a success
-- continuation, otherwise to a failure continuation.
prompt :: LL.ListLike δ ε
       => S δ -> (S δ -> Result δ r) -> (S δ -> Result δ r) -> Result δ r
prompt (S s a _) fa su = Partial $ \p ->
    if LL.null s
        then fa $ S s a Complete
        else su $ S (s ⊕ p) (a ⊕ p) Incomplete
{-# SPECIALIZE prompt :: S B.ByteString
                      -> (S B.ByteString -> Result B.ByteString r)
                      -> (S B.ByteString -> Result B.ByteString r)
                      -> Result B.ByteString r #-}
{-# SPECIALIZE prompt :: S LB.ByteString
                      -> (S LB.ByteString -> Result LB.ByteString r)
                      -> (S LB.ByteString -> Result LB.ByteString r)
                      -> Result LB.ByteString r #-}

-- | Immediately demand more input via a 'Partial' continuation
-- result.
demandInput :: LL.ListLike δ ε => Parser δ ()
demandInput = Parser $ \st fa su ->
    if more st ≡ Complete
        then fa st ["demandInput"] "not enough characters"
        else prompt st (\st' -> fa st' ["demandInput"] "not enough characters")
                       (su ())
{-# SPECIALIZE demandInput :: Parser B.ByteString () #-}
{-# SPECIALIZE demandInput :: Parser LB.ByteString () #-}

-- | This parser always succeeds.  It returns 'True' if any input is
-- available either immediately or on demand, and 'False' if the end
-- of all input has been reached.
wantInput :: LL.ListLike δ ε => Parser δ Bool
wantInput = Parser $ \st@(S s _ c) _ su -> case () of
  _ | not (LL.null s) -> su True st
    | c ≡ Complete    -> su False st
    | otherwise       -> prompt st (su False) (su True)
{-# SPECIALIZE wantInput :: Parser B.ByteString Bool #-}
{-# SPECIALIZE wantInput :: Parser LB.ByteString Bool #-}

get :: Parser δ δ
get = Parser (\st _ su -> su (input st) st)

put :: δ -> Parser δ ()
put s = Parser (\(S _ a c) _ su -> su () (S s a c))

-- | Attempt a parse, and if it fails, rewind the input so that no
-- input appears to have been consumed.
--
-- This combinator is useful in cases where a parser might consume
-- some input before failing, i.e. the parser needs arbitrary
-- lookahead.  The downside to using this combinator is that it can
-- retain input for longer than is desirable.
try :: Monoid δ => Parser δ a -> Parser δ a
try p = Parser (\st fa su -> runParser p (noAdds st) (fa . (st ⊕)) su)
{-# SPECIALIZE try :: Parser B.ByteString a -> Parser B.ByteString a #-}
{-# SPECIALIZE try :: Parser LB.ByteString a -> Parser LB.ByteString a #-}

-- | The parser @satisfy p@ succeeds for any element for which the
-- predicate @p@ returns 'True'. Returns the element that is actually
-- parsed.
--
-- >digit = satisfy isDigit
-- >    where isDigit w = w >= 48 && w <= 57
satisfy :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ε
satisfy p = do
    ensure 1
    s <- get
    let w = LL.head s
    if p w
        then put (LL.tail s) ≫ return w
        else fail "satisfy"
{-# SPECIALIZE satisfy :: (Word8 -> Bool) -> Parser B.ByteString Word8 #-}
{-# SPECIALIZE satisfy :: (Word8 -> Bool) -> Parser LB.ByteString Word8 #-}

-- | The parser @skip p@ succeeds for any element for which the predicate
-- @p@ returns 'True'.
--
-- >space = skip isSpace
-- >    where isDigit w = w == 9 || w == 10 || w == 13 || w == 32
skip :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ()
skip p = do
  ensure 1
  s <- get
  if p (LL.head s)
      then put (LL.tail s)
      else fail "skip"
{-# SPECIALIZE skip :: (Word8 -> Bool) -> Parser B.ByteString () #-}
{-# SPECIALIZE skip :: (Word8 -> Bool) -> Parser LB.ByteString () #-}

-- | The parser @satisfyWith f p@ transforms an element, and succeeds if
-- the predicate @p@ returns 'True' on the transformed value. The
-- parser returns the transformed element that was parsed.
satisfyWith :: LL.ListLike δ ε => (ε -> a) -> (a -> Bool) -> Parser δ a
satisfyWith f p = do
    ensure 1
    s <- get
    let c = f (LL.head s)
    if p c
        then put (LL.tail s) ≫ return c
        else fail "satisfyWith"
{-# SPECIALIZE satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser B.ByteString a #-}
{-# SPECIALIZE satisfyWith :: (Word8 -> a) -> (a -> Bool) -> Parser LB.ByteString a #-}

-- | Consume @n@ element of input, but succeed only if the predicate
-- returns 'True'.
takeWith :: LL.ListLike δ ε => Int -> (δ -> Bool) -> Parser δ δ
takeWith n p = do
    ensure n
    s <- get
    let (h, t) = LL.splitAt n s
    if p h
        then put t ≫ return h
        else fail "takeWith"
{-# SPECIALIZE takeWith :: Int -> (B.ByteString -> Bool) -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWith :: Int -> (LB.ByteString -> Bool) -> Parser LB.ByteString LB.ByteString #-}

-- | Consume exactly @n@ elements of input.
take :: LL.ListLike δ ε => Int -> Parser δ δ
take n = takeWith n (const True)
{-# INLINE take #-}
{-# SPECIALIZE take :: Int -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE take :: Int -> Parser LB.ByteString LB.ByteString #-}

-- | @string s@ parses a sequence of elements that identically match
-- @s@. Returns the parsed string (i.e. @s@).  This parser consumes no
-- input if it fails (even if a partial match).
--
-- /Note/: The behaviour of this parser is different to that of the
-- similarly-named parser in Parsec, as this one is all-or-nothing.
-- To illustrate the difference, the following parser will fail under
-- Parsec given an input of @"for"@:
--
-- >string "foo" <|> string "for"
--
-- The reason for its failure is that that the first branch is a
-- partial match, and will consume the letters @\'f\'@ and @\'o\'@
-- before failing.  In Nnaoparsec, the above parser will /succeed/ on
-- that input, because the failed first branch will consume nothing.
string :: (Eq δ, LL.ListLike δ ε) => δ -> Parser δ δ
string s = takeWith (LL.length s) (≡ s)
{-# INLINE string #-}
{-# SPECIALIZE string :: B.ByteString -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE string :: LB.ByteString -> Parser LB.ByteString LB.ByteString #-}

stringTransform :: (LL.ListLike δ ε, Eq δ) => (δ -> δ) -> δ -> Parser δ δ
stringTransform f s = takeWith (LL.length s) ((≡ f s) . f)
{-# INLINE stringTransform #-}
{-# SPECIALIZE stringTransform :: (B.ByteString -> B.ByteString) -> B.ByteString -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE stringTransform :: (LB.ByteString -> LB.ByteString) -> LB.ByteString -> Parser LB.ByteString LB.ByteString #-}

skipWhile :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ ()
skipWhile p = go
              where go = do
                      _ <- wantInput
                      t <- LL.dropWhile p <$> get
                      put t
                      when (LL.null t) go
{-# SPECIALIZE skipWhile :: (Word8 -> Bool) -> Parser B.ByteString () #-}
{-# SPECIALIZE skipWhile :: (Word8 -> Bool) -> Parser LB.ByteString () #-}

-- | Consume input as long as the predicate returns 'False'
-- (i.e. until it returns 'True'), and return the consumed input.
--
-- This parser does not fail.  It will return an empty string if the
-- predicate returns 'True' on the first element of input.
--
-- /Note/: Because this parser does not fail, do not use it with
-- combinators such as 'many', because such parsers loop until a
-- failure occurs.  Careless use will thus result in an infinite loop.
takeTill :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
takeTill p = takeWhile (not . p)
{-# INLINE takeTill #-}
{-# SPECIALIZE takeTill :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeTill :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}

-- | Consume input as long as the predicate returns 'True', and return
-- the consumed input.
--
-- This parser does not fail.  It will return an empty string if the
-- predicate returns 'False' on the first element of input.
--
-- /Note/: Because this parser does not fail, do not use it with
-- combinators such as 'many', because such parsers loop until a
-- failure occurs.  Careless use will thus result in an infinite loop.
takeWhile :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
takeWhile p = go ø
              where go acc = do
                      inp <- wantInput
                      if inp
                          then do
                            (h, t) <- LL.span p <$> get
                            put t
                            if (LL.null t)
                                then go (h ⊕ acc)
                                else return h
                          else return ø
{-# SPECIALIZE takeWhile :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWhile :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}

-- | Consume input as long as the predicate returns 'True', and return
-- the consumed input.
--
-- This parser requires the predicate to succeed on at least one element
-- of input: it will fail if the predicate never returns 'True' or if
-- there is no input left.
takeWhile1 :: LL.ListLike δ ε => (ε -> Bool) -> Parser δ δ
takeWhile1 p = do
  (`when` demandInput) =<< LL.null <$> get
  (h, t) <- LL.span p <$> get
  when (LL.null h) $ fail "takeWhile1"
  put t
  if LL.null t
      then (h ⊕) `fmap` takeWhile p
      else return h
{-# SPECIALIZE takeWhile1 :: (Word8 -> Bool) -> Parser B.ByteString B.ByteString #-}
{-# SPECIALIZE takeWhile1 :: (Word8 -> Bool) -> Parser LB.ByteString LB.ByteString #-}

anyElem :: LL.ListLike δ ε => Parser δ ε
anyElem = satisfy (const True)
{-# INLINE anyElem #-}
{-# SPECIALIZE anyElem :: Parser B.ByteString Word8 #-}
{-# SPECIALIZE anyElem :: Parser LB.ByteString Word8 #-}

elem :: (Eq ε, Show ε, LL.ListLike δ ε) => ε -> Parser δ ε
elem x = elem' (show x) x
{-# INLINE elem #-}
{-# SPECIALIZE elem :: Word8 -> Parser B.ByteString Word8 #-}
{-# SPECIALIZE elem :: Word8 -> Parser LB.ByteString Word8 #-}

notElem :: (Eq ε, Show ε, LL.ListLike δ ε) => ε -> Parser δ ε
notElem x = notElem' ("not " ⊕ show x) x
{-# INLINE notElem #-}
{-# SPECIALIZE notElem :: Word8 -> Parser B.ByteString Word8 #-}
{-# SPECIALIZE notElem :: Word8 -> Parser LB.ByteString Word8 #-}

elem' :: (Eq ε, LL.ListLike δ ε) => String -> ε -> Parser δ ε
elem' p c = satisfy (≡ c) <?> p
{-# INLINE elem' #-}
{-# SPECIALIZE elem' :: String -> Word8 -> Parser B.ByteString Word8 #-}
{-# SPECIALIZE elem' :: String -> Word8 -> Parser LB.ByteString Word8 #-}

notElem' :: (Eq ε, LL.ListLike δ ε) => String -> ε -> Parser δ ε
notElem' p c = satisfy (≢ c) <?> p
{-# INLINE notElem' #-}
{-# SPECIALIZE notElem' :: String -> Word8 -> Parser B.ByteString Word8 #-}
{-# SPECIALIZE notElem' :: String -> Word8 -> Parser LB.ByteString Word8 #-}

-- | Match only if all input has been consumed.
endOfInput :: LL.ListLike δ ε => Parser δ ()
endOfInput = Parser $ \st@(S i _ mo) fa su -> case () of
    _ | not (LL.null i) -> fa    st [] "endOfInput"
      | mo ≡ Complete   -> su () st
      | otherwise       -> let su' _ st'     = su () (st ⊕ st')
                               fa'   st' _ _ = fa    (st ⊕ st') [] "endOfInput"
                           in runParser demandInput st fa' su'
{-# SPECIALIZE endOfInput :: Parser B.ByteString () #-}
{-# SPECIALIZE endOfInput :: Parser LB.ByteString () #-}

-- | Match either a single newline character @\'\\n\'@, or a carriage
-- return followed by a newline character @\"\\r\\n\"@.
(<?>) :: Parser δ a -> String -> Parser δ a
p <?> ms = Parser $ \s fa su -> runParser p s (\s' sts m -> fa s' (ms:sts) m) su
{-# INLINE (<?>) #-}
infix 0 <?>

-- | Run a parser.
parse :: Monoid δ => Parser δ a -> δ -> Result δ a
parse m s = runParser m (S s ø Incomplete) Fail Done
{-# INLINE parse #-}
{-# SPECIALIZE parse :: Parser B.ByteString a -> B.ByteString -> Result B.ByteString a #-}
{-# SPECIALIZE parse :: Parser LB.ByteString a -> LB.ByteString -> Result LB.ByteString a #-}

</pre>