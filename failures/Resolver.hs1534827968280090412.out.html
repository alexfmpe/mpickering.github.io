<a href="ResolveLocals.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Resolver.hs2034712366881140534.out.html">next</a></br></br><pre>17c17
< data Name = Name {symbol ∷ String, boundByLambda ∷ Bool, reference ∷ Compiler Edge}
---
> data Name = Name {symbol :: String, boundByLambda :: Bool, reference :: Compiler Edge}
19c19
< resolve ∷ Λ → Graph NodeLS
---
> resolve :: Λ -> Graph NodeLS
21d20
<     o ← newEdge
22c21
<     i ← newNode Initiator {out = o}
---
>     o <- newEdge
22a22
>     i <- newNode Initiator {out = o}
25c25
< compile ∷ Environment → Edge → Λ → Compiler ()
---
> compile :: Environment -> Edge -> Λ -> Compiler ()
27d26
<     A func arg → do
28d26
<         f ← newEdge
29c27
<         x ← newEdge
---
>     A func arg -> do
29a28
>         f <- newEdge
29a29
>         x <- newEdge
33d32
<     Λ x e → do
34d32
<         b ← newEdge
35c33
<         (v, name) ← bindName True x
---
>     Λ x e -> do
35a34
>         b <- newEdge
35a35
>         (v, name) <- bindName True x
38d37
<     L binds e → do
39c38
<         (es, names) ← liftM unzip $ mapM (bindName False) (map fst binds)
---
>     L binds e -> do
39a39
>         (es, names) <- liftM unzip $ mapM (bindName False) (map fst binds)
43d42
<     C name [] → case env of
44d42
<         [  ] → void $ newNode $ fromMaybe (Constant {inp = p, name = name, args = []}) (operator name p)
45c43
<         n:ns → if name ≡ symbol n
---
>     C name [] -> case env of
45a44
>         [  ] -> void $ newNode $ fromMaybe (Constant {inp = p, name = name, args = []}) (operator name p)
45a45
>         n:ns -> if name ≡ symbol n
49c49
<                         p' ← newEdge
---
>                         p' <- newEdge
53c53
<     Term.Case exp cases → do
---
>     Term.Case exp cases -> do
55d54
<         alts ← replicateM (length cases) newEdge -- edges going from the Case node to the CaseAlts
56c55
<         o    ← newEdge
---
>         alts <- replicateM (length cases) newEdge -- edges going from the Case node to the CaseAlts
56a56
>         o    <- newEdge
58c58
<         mapM_ (\(alt, (pat,exp)) → compile env alt (foldr Λ exp (vars pat))) (zip alts cases) -- compile the different cases
---
>         mapM_ (\(alt, (pat,exp)) -> compile env alt (foldr Λ exp (vars pat))) (zip alts cases) -- compile the different cases
61c61
< operator ∷ String → Edge → Maybe NodeLS
---
> operator :: String -> Edge -> Maybe NodeLS
63d62
<     "+" → op 2 $ liftM (show . sum) . mapM read
64d62
<     "-" → op 2 $ liftM (show . minus) . mapM read where minus [x,y] = x - y
65d62
<     "==" → op 2 $ \[x,y] → Just $ if x ≡ y then "T" else "F"
66c63
<     _ → Nothing
---
>     "+" -> op 2 $ liftM (show . sum) . mapM read
66a64
>     "-" -> op 2 $ liftM (show . minus) . mapM read where minus [x,y] = x - y
66a65
>     "==" -> op 2 $ \[x,y] -> Just $ if x ≡ y then "T" else "F"
66a66
>     _ -> Nothing
69d68
<     read ∷ Read a ⇒ String → Maybe a
70d68
<     read str = case [ x | (x, "") ← reads str ] of
71d68
<         [] → Nothing
72c69
<         x:_ → Just x
---
>     read :: Read a => String -> Maybe a
72a70
>     read str = case [ x | (x, "") <- reads str ] of
72a71
>         [] -> Nothing
72a72
>         x:_ -> Just x
77c77
< bindName ∷ Bool → String → Compiler (Edge, Name)
---
> bindName :: Bool -> String -> Compiler (Edge, Name)
79d78
<     v ← newEdge
80c79
<     s ← newNode Multiplexer {out = v, ins = []}
---
>     v <- newEdge
80a80
>     s <- newNode Multiplexer {out = v, ins = []}
82d81
<         e ← newEdge
83c82
<         modifyNode s $ \s → s {ins = e : ins s}
---
>         e <- newEdge
83a83
>         modifyNode s $ \s -> s {ins = e : ins s}
85a86
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | Term to graph transformation where variable names are resolved to graph edges (or constants)
module Resolver (resolve) where

import Prelude.Unicode
import Term
import Graph
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import Control.Monad
import Data.Maybe (fromMaybe)


type Compiler = Rewrite NodeLS

type Environment = [Name]
data Name = Name {symbol ∷ String, boundByLambda ∷ Bool, reference ∷ Compiler Edge}

resolve ∷ Λ → Graph NodeLS
resolve term = flip execGraph emptyGraph $ do
    o ← newEdge
    i ← newNode Initiator {out = o}
    compile [] o term

compile ∷ Environment → Edge → Λ → Compiler ()
compile env p term = case term of
    A func arg → do
        f ← newEdge
        x ← newEdge
        void $ newNode Applicator {inp = p, func = f, arg = x}
        compile env f func
        compile env x arg
    Λ x e → do
        b ← newEdge
        (v, name) ← bindName True x
        void $ newNode Abstractor {inp = p, body = b, var = v, name = x}
        compile (name : env) b e
    L binds e → do
        (es, names) ← liftM unzip $ mapM (bindName False) (map fst binds)
        let env' = names ⧺ env
        void $ zipWithM (compile env') es (Prelude.map snd binds)
        compile env' p e
    C name [] → case env of
        [  ] → void $ newNode $ fromMaybe (Constant {inp = p, name = name, args = []}) (operator name p)
        n:ns → if name ≡ symbol n
            then mergeEdges p =<< reference n
            else if boundByLambda n
                    then do
                        p' ← newEdge
                        void $ newNode Delimiter {level = 0, inp = p', out = p}
                        compile ns p' term
                    else compile ns p term
    Term.Case exp cases → do
        let (pats, _) = unzip cases
        alts ← replicateM (length cases) newEdge -- edges going from the Case node to the CaseAlts
        o    ← newEdge
        void $ newNode Graph.Case {inp = p, out = o, alts = alts, names = map constr pats}
        mapM_ (\(alt, (pat,exp)) → compile env alt (foldr Λ exp (vars pat))) (zip alts cases) -- compile the different cases
        compile env o exp -- compile the scrutiny

operator ∷ String → Edge → Maybe NodeLS
operator n p = case n of
    "+" → op 2 $ liftM (show . sum) . mapM read
    "-" → op 2 $ liftM (show . minus) . mapM read where minus [x,y] = x - y
    "==" → op 2 $ \[x,y] → Just $ if x ≡ y then "T" else "F"
    _ → Nothing
    where

    read ∷ Read a ⇒ String → Maybe a
    read str = case [ x | (x, "") ← reads str ] of
        [] → Nothing
        x:_ → Just x

    op a f = Just Operator
        {inp = p, ops = [], arity = a, lmop = 0, function = f, name = n}

bindName ∷ Bool → String → Compiler (Edge, Name)
bindName lambda sym = do
    v ← newEdge
    s ← newNode Multiplexer {out = v, ins = []}
    let ref = do
        e ← newEdge
        modifyNode s $ \s → s {ins = e : ins s}
        return e
    return (v, Name {symbol = sym, boundByLambda = lambda, reference = ref})
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
-- | Term to graph transformation where variable names are resolved to graph edges (or constants)
module Resolver (resolve) where

import Prelude.Unicode
import Term
import Graph
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import Control.Monad
import Data.Maybe (fromMaybe)


type Compiler = Rewrite NodeLS

type Environment = [Name]
data Name = Name {symbol :: String, boundByLambda :: Bool, reference :: Compiler Edge}

resolve :: Λ -> Graph NodeLS
resolve term = flip execGraph emptyGraph $ do
    o <- newEdge
    i <- newNode Initiator {out = o}
    compile [] o term

compile :: Environment -> Edge -> Λ -> Compiler ()
compile env p term = case term of
    A func arg -> do
        f <- newEdge
        x <- newEdge
        void $ newNode Applicator {inp = p, func = f, arg = x}
        compile env f func
        compile env x arg
    Λ x e -> do
        b <- newEdge
        (v, name) <- bindName True x
        void $ newNode Abstractor {inp = p, body = b, var = v, name = x}
        compile (name : env) b e
    L binds e -> do
        (es, names) <- liftM unzip $ mapM (bindName False) (map fst binds)
        let env' = names ⧺ env
        void $ zipWithM (compile env') es (Prelude.map snd binds)
        compile env' p e
    C name [] -> case env of
        [  ] -> void $ newNode $ fromMaybe (Constant {inp = p, name = name, args = []}) (operator name p)
        n:ns -> if name ≡ symbol n
            then mergeEdges p =<< reference n
            else if boundByLambda n
                    then do
                        p' <- newEdge
                        void $ newNode Delimiter {level = 0, inp = p', out = p}
                        compile ns p' term
                    else compile ns p term
    Term.Case exp cases -> do
        let (pats, _) = unzip cases
        alts <- replicateM (length cases) newEdge -- edges going from the Case node to the CaseAlts
        o    <- newEdge
        void $ newNode Graph.Case {inp = p, out = o, alts = alts, names = map constr pats}
        mapM_ (\(alt, (pat,exp)) -> compile env alt (foldr Λ exp (vars pat))) (zip alts cases) -- compile the different cases
        compile env o exp -- compile the scrutiny

operator :: String -> Edge -> Maybe NodeLS
operator n p = case n of
    "+" -> op 2 $ liftM (show . sum) . mapM read
    "-" -> op 2 $ liftM (show . minus) . mapM read where minus [x,y] = x - y
    "==" -> op 2 $ \[x,y] -> Just $ if x ≡ y then "T" else "F"
    _ -> Nothing
    where

    read :: Read a => String -> Maybe a
    read str = case [ x | (x, "") <- reads str ] of
        [] -> Nothing
        x:_ -> Just x

    op a f = Just Operator
        {inp = p, ops = [], arity = a, lmop = 0, function = f, name = n}

bindName :: Bool -> String -> Compiler (Edge, Name)
bindName lambda sym = do
    v <- newEdge
    s <- newNode Multiplexer {out = v, ins = []}
    let ref = do
        e <- newEdge
        modifyNode s $ \s -> s {ins = e : ins s}
        return e
    return (v, Name {symbol = sym, boundByLambda = lambda, reference = ref})

</pre>