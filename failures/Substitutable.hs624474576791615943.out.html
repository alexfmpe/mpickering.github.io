<a href="SubOptDistance.hs18193439671841887383.out.html">prev</a></br><a href="failures.html">home</a></br><a href="SubsumeCommon.hs1027960836431830537.out.html">next</a></br></br><pre>31c31
< {-# LINE 46 "src/ehc/Substitutable.chs" #-}
---
> 
31a32
> 
31a33
> 
31a34
> 
31a35
> 
31a36
> 
31a37
> 
31a38
> 
31a39
> 
31a40
> 
31a41
> 
31a42
> 
31a43
> 
31a44
> 
31a45
> 
34c48
< {-# LINE 50 "src/ehc/Substitutable.chs" #-}
---
> 
34a49
> 
37c52
< {-# LINE 54 "src/ehc/Substitutable.chs" #-}
---
> 
37a53
> 
43c59
< {-# LINE 65 "src/ehc/Substitutable.chs" #-}
---
> 
43a60
> 
43a61
> 
43a62
> 
43a63
> 
43a64
> 
52c73
< {-# LINE 75 "src/ehc/Substitutable.chs" #-}
---
> 
52a74
> 
58c80
< {-# LINE 86 "src/ehc/Substitutable.chs" #-}
---
> 
58a81
> 
58a82
> 
58a83
> 
58a84
> 
58a85
> 
66c93
< {-# LINE 99 "src/ehc/Substitutable.chs" #-}
---
> 
66a94
> 
66a95
> 
66a96
> 
66a97
> 
66a98
> 
74c106
< {-# LINE 114 "src/ehc/Substitutable.chs" #-}
---
> 
74a107
> 
74a108
> 
74a109
> 
74a110
> 
74a111
> 
74a112
> 
74a113
> 
92c131
< {-# LINE 133 "src/ehc/Substitutable.chs" #-}
---
> 
92a132
> 
101c141
< {-# LINE 166 "src/ehc/Substitutable.chs" #-}
---
> 
101a142
> 
101a143
> 
101a144
> 
101a145
> 
101a146
> 
101a147
> 
101a148
> 
101a149
> 
101a150
> 
101a151
> 
101a152
> 
101a153
> 
101a154
> 
101a155
> 
101a156
> 
101a157
> 
101a158
> 
101a159
> 
101a160
> 
101a161
> 
101a162
> 
101a163
> 
101a164
> 
101a165
> 
108c172
< {-# LINE 176 "src/ehc/Substitutable.chs" #-}
---
> 
108a173
> 
108a174
> 
108a175
> 
115c182
< {-# LINE 184 "src/ehc/Substitutable.chs" #-}
---
> 
115a183
> 
154c222
< {-# LINE 240 "src/ehc/Substitutable.chs" #-}
---
> 
154a223
> 
154a224
> 
154a225
> 
154a226
> 
154a227
> 
154a228
> 
154a229
> 
154a230
> 
154a231
> 
154a232
> 
154a233
> 
154a234
> 
154a235
> 
154a236
> 
154a237
> 
154a238
> 
154a239
> 
165c250
< {-# LINE 258 "src/ehc/Substitutable.chs" #-}
---
> 
165a251
> 
165a252
> 
165a253
> 
165a254
> 
165a255
> 
165a256
> 
165a257
> 
177c269
< {-# LINE 292 "src/ehc/Substitutable.chs" #-}
---
> 
177a270
> 
177a271
> 
177a272
> 
177a273
> 
177a274
> 
177a275
> 
177a276
> 
177a277
> 
177a278
> 
177a279
> 
177a280
> 
177a281
> 
177a282
> 
177a283
> 
177a284
> 
177a285
> 
177a286
> 
177a287
> 
177a288
> 
177a289
> 
177a290
> 
177a291
> 
188c302
< {-# LINE 308 "src/ehc/Substitutable.chs" #-}
---
> 
188a303
> 
188a304
> 
188a305
> 
188a306
> 
188a307
> 
213c332
< {-# LINE 338 "src/ehc/Substitutable.chs" #-}
---
> 
213a333
> 
213a334
> 
213a335
> 
213a336
> 
213a337
> 
217c341
< {-# LINE 347 "src/ehc/Substitutable.chs" #-}
---
> 
217a342
> 
217a343
> 
217a344
> 
217a345
> 
217a346
> 
223c352
< {-# LINE 367 "src/ehc/Substitutable.chs" #-}
---
> 
223a353
> 
223a354
> 
223a355
> 
223a356
> 
223a357
> 
223a358
> 
223a359
> 
223a360
> 
223a361
> 
223a362
> 
223a363
> 
223a364
> 
223a365
> 
223a366
> 
227c370
< {-# LINE 384 "src/ehc/Substitutable.chs" #-}
---
> 
227a371
> 
227a372
> 
227a373
> 
227a374
> 
227a375
> 
227a376
> 
227a377
> 
227a378
> 
227a379
> 
227a380
> 
227a381
> 
227a382
> 
227a383
> 
230a387
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Substitutable
( VarUpdatable (..)
, VarExtractable (..)
, ppS
, substLift
, varmpMapTyVarKey
, setSubst
, tyFixTyVars, tyMetaTyVars
, varmpinfoFtvMp
, varmpOccurErr )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Trf.Subst
import UHC.Light.Compiler.Ty.Ftv
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Light.Compiler.Error
import qualified Data.Map as Map
import UHC.Light.Compiler.VarLookup
import UHC.Light.Compiler.Base.TermLike







{-# LINE 46 "src/ehc/Substitutable.chs" #-}
infixr 6 {-- |=>, -} `varUpd`

{-# LINE 50 "src/ehc/Substitutable.chs" #-}
infixr 6 {-- |==>, -} `varUpdCyc`

{-# LINE 54 "src/ehc/Substitutable.chs" #-}
class VarUpdatable vv subst where
  varUpd            ::  subst -> vv -> vv
  varUpdCyc        ::  subst -> vv -> (vv,VarMp)
  s `varUpdCyc` x = (s `varUpd` x,emptyVarMp)

{-# LINE 65 "src/ehc/Substitutable.chs" #-}
class Ord k => VarExtractable vv k | vv -> k where
  varFree           ::  vv -> [k]
  varFreeSet        ::  vv -> Set.Set k

  -- default
  varFree           =   Set.toList . varFreeSet
  varFreeSet        =   Set.fromList . varFree

{-# LINE 75 "src/ehc/Substitutable.chs" #-}
substLift :: (v' -> v) -> (v' -> v -> v') -> (subst -> v -> (v,r)) -> subst -> v' -> (v',r)
substLift toV updV app s v'
  = (updV v' x,r)
  where (x,r) = app s $ toV v'

{-# LINE 86 "src/ehc/Substitutable.chs" #-}
varmpinfoFtvMp :: VarMpInfo -> TvCatMp
varmpinfoFtvMp i
  = case i of
      VMITy       t  -> tyFtvMp    t
      VMIImpls    i  -> implsFtvMp i
      _              -> emptyTvCatMp        -- incomplete

{-# LINE 99 "src/ehc/Substitutable.chs" #-}
instance VarLookup m TyVarId VarMpInfo => VarUpdatable Ty m where
  varUpd        = tyAppVarLookup
  varUpdCyc    = tyAppVarLookup2

instance VarExtractable Ty TyVarId where
  varFreeSet    = tyFtv

{-# LINE 114 "src/ehc/Substitutable.chs" #-}
-- instance VarUpdatable Label VarMp where
instance VarLookup m ImplsVarId VarMpInfo => VarUpdatable Label m where
  s `varUpd` lb          = maybe lb id $ varmpLabelLookupLabelCyc lb s

instance VarExtractable Label TyVarId where
  varFree (Label_Var v) = [v]
  varFree _             = []

-- instance VarUpdatable LabelOffset VarMp where
instance VarLookup m UID VarMpInfo => VarUpdatable LabelOffset m where
  s `varUpd` o@(LabelOffset_Var v) = maybe o id $ varmpOffsetLookup v s
  s `varUpd` o                     = o

instance VarExtractable LabelOffset TyVarId where
  varFree (LabelOffset_Var v) = [v]
  varFree _                   = []

{-# LINE 133 "src/ehc/Substitutable.chs" #-}
instance (VarUpdatable vv subst) => VarUpdatable [vv] subst where
  s      `varUpd`  l   =   map (varUpd s) l
  s      `varUpdCyc` l   =   (l,varmpUnions m)
                  where (l,m) = unzip $ map (varUpdCyc s) l

instance (VarExtractable vv k) => VarExtractable [vv] k where
  varFreeSet      l   =   Set.unions $ map varFreeSet l

{-# LINE 166 "src/ehc/Substitutable.chs" #-}
instance VarLookupCmb m (VarMp' k v) => VarUpdatable (VarMp' k v) m where
  varUpd                                =   (|+>)

instance VarExtractable VarMp TyVarId where
  varFreeSet               (VarMp _ sl)    =   Set.unions $ map (varFreeSet . Map.elems) sl

{-# LINE 176 "src/ehc/Substitutable.chs" #-}
instance VarUpdatable vv subst => VarUpdatable (HsName,vv) subst where
  s `varUpd`  (k,v) =  (k,s `varUpd` v)

instance VarExtractable vv k => VarExtractable (HsName,vv) k where
  varFreeSet (_,v) =  varFreeSet v

{-# LINE 184 "src/ehc/Substitutable.chs" #-}
instance VarUpdatable Pred VarMp where
  s `varUpd`  p  =  (\(Ty_Pred p) -> p) (s `varUpd` (Ty_Pred p))

instance VarExtractable Pred TyVarId where
  varFreeSet p  =  varFreeSet (Ty_Pred p)

-- instance VarUpdatable PredScope VarMp where
instance VarLookup m ImplsVarId VarMpInfo => VarUpdatable PredScope m where
  s `varUpd`  sc                   = maybe sc id $ varmpScopeLookupScopeCyc sc s

instance VarExtractable PredScope TyVarId where
  varFree    (PredScope_Var v)    = [v]
  varFree    _                    = []

instance VarUpdatable CHRPredOccCxt VarMp where
  s `varUpd`  (CHRPredOccCxt_Scope1 sc) = CHRPredOccCxt_Scope1 (s `varUpd` sc)

instance VarExtractable CHRPredOccCxt TyVarId where
  varFree    (CHRPredOccCxt_Scope1 sc) = varFree sc

instance VarUpdatable PredOcc VarMp where
  s `varUpd`  (PredOcc pr id sc r)  = PredOcc (s `varUpd` pr) id (s `varUpd` sc) r

instance VarExtractable PredOcc TyVarId where
  varFreeSet (PredOcc pr id sc _)  = varFreeSet pr `Set.union` varFreeSet sc

instance VarUpdatable CHRPredOcc VarMp where
  s `varUpd`  (CHRPredOcc pr sc r)  = CHRPredOcc (s `varUpd` pr) (s `varUpd` sc) r

instance VarExtractable CHRPredOcc TyVarId where
  varFreeSet (CHRPredOcc pr sc _)  = varFreeSet pr `Set.union` varFreeSet sc

instance VarUpdatable Impls VarMp where
  s `varUpd`  i  =  (\(Ty_Impls i) -> i) (s `varUpd` (Ty_Impls i))

instance VarExtractable Impls TyVarId where
  varFreeSet i  =  varFreeSet (Ty_Impls i)

{-# LINE 240 "src/ehc/Substitutable.chs" #-}
instance VarUpdatable VarMpInfo VarMp where
  s `varUpd` vmi =  case vmi of
                 VMITy       t  -> VMITy (s `varUpd` t)
                 VMIImpls    i  -> VMIImpls (s `varUpd` i)
                 VMIPred     i  -> VMIPred (s `varUpd` i)
                 VMIScope    sc -> VMIScope (s `varUpd` sc)
                 VMIPredSeq  x  -> VMIPredSeq (s `varUpd` x)
                 -- VMIExts     x  -> VMIExts (s `varUpd` x)
                 vmi            -> vmi

{-# LINE 258 "src/ehc/Substitutable.chs" #-}
instance VarExtractable VarMpInfo VarId where
  varFreeSet vmi = case vmi of
                 VMITy       t  -> varFreeSet t
                 VMIImpls    i  -> varFreeSet i
                 VMIPred     i  -> varFreeSet i
                 VMIScope    sc -> varFreeSet sc
                 VMIPredSeq  x  -> varFreeSet x
                 -- VMIExts     x  -> varFreeSet x
                 vmi            -> Set.empty


{-# LINE 292 "src/ehc/Substitutable.chs" #-}
instance VarUpdatable PredSeq VarMp where
  s `varUpd`  a@(PredSeq_Var  v  ) = maybe a id $ varmpPredSeqLookup v s
  s `varUpd`    (PredSeq_Cons h t) = PredSeq_Cons (s `varUpd` h) (s `varUpd` t)
  _ `varUpd`    x                  = x

instance VarExtractable PredSeq TyVarId where
  varFreeSet   (PredSeq_Var  v  ) = Set.singleton v
  varFreeSet   (PredSeq_Cons h t) = varFreeSet h `Set.union` varFreeSet t
  varFreeSet _                    = Set.empty

{-# LINE 308 "src/ehc/Substitutable.chs" #-}
-- | Construct varmp for fixing tvars to new fresh fixed tvars + varmp for unfixing those to (again) fresh tvars, resp meta tvars
fixTyVarsVarMp :: UID -> Ty -> (VarMp,VarMp,VarMp,VarMp)
fixTyVarsVarMp uniq t
  = ( mk TyVarCateg_Fixed fv rv
    , mk TyVarCateg_Meta  fv rv
    , mk TyVarCateg_Plain rv rv2
    , mk TyVarCateg_Meta  rv rv2
    )
  where fv = varFree t
        l  = length fv
        (rv,rv2) = splitAt l $ mkNewUIDL (2*l) uniq
        mk cat fv rv = mkVarMp $ Map.fromList $ zipWith (\v r -> (v,VMITy (Ty_Var r cat))) fv rv

tyFixTyVars :: UID -> Ty -> (Ty,VarMp,VarMp,VarMp)
tyFixTyVars uniq t
  = (sTo `varUpd` t, sTo, sFr, smFr)
  where (sTo,_,sFr,smFr) = fixTyVarsVarMp uniq t

-- | replace tvars with tvars having TyVarCateg_Meta
tyMetaTyVars :: UID -> Ty -> Ty
tyMetaTyVars uniq t
  = smTo `varUpd` t
  where (_,smTo,_,_) = fixTyVarsVarMp uniq t

{-# LINE 338 "src/ehc/Substitutable.chs" #-}
setSubst :: VarMp -> TyVarIdS -> TyVarIdS
setSubst m s = varFreeSet $ (varUpd m) $ map mkTyVar $ Set.toList s

{-# LINE 347 "src/ehc/Substitutable.chs" #-}
varmpMapTyVarKey :: VarMp -> VarMp -> VarMp
varmpMapTyVarKey mMap m
  = varmpUnions [ varmpTyUnit v x | (Ty_Var v _,x) <- assocLMapKey (\v -> fst $ appUnAnnCanon $ mMap `varUpd` mkTyVar v) $ varmpToAssocTyL m ]


{-# LINE 367 "src/ehc/Substitutable.chs" #-}
ppS :: VarUpdatable x m => (x -> PP_Doc) -> m -> x -> PP_Doc
ppS pp c x = (pp $ c `varUpd` x) >#< ppParens (pp x)

{-# LINE 384 "src/ehc/Substitutable.chs" #-}
varmpOccurErr :: Range -> VarMp -> VarMp -> [Err]
varmpOccurErr r m mc = [ Err_OccurCycle r v (varmpDel [v] m `varUpd` t) | (v,t) <- varmpToAssocTyL mc ]

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Substitutable
( VarUpdatable (..)
, VarExtractable (..)
, ppS
, substLift
, varmpMapTyVarKey
, setSubst
, tyFixTyVars, tyMetaTyVars
, varmpinfoFtvMp
, varmpOccurErr )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Trf.Subst
import UHC.Light.Compiler.Ty.Ftv
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Light.Compiler.Error
import qualified Data.Map as Map
import UHC.Light.Compiler.VarLookup
import UHC.Light.Compiler.Base.TermLike






















infixr 6 {-- |=>, -} `varUpd`



infixr 6 {-- |==>, -} `varUpdCyc`



class VarUpdatable vv subst where
  varUpd            ::  subst -> vv -> vv
  varUpdCyc        ::  subst -> vv -> (vv,VarMp)
  s `varUpdCyc` x = (s `varUpd` x,emptyVarMp)







class Ord k => VarExtractable vv k | vv -> k where
  varFree           ::  vv -> [k]
  varFreeSet        ::  vv -> Set.Set k

  -- default
  varFree           =   Set.toList . varFreeSet
  varFreeSet        =   Set.fromList . varFree



substLift :: (v' -> v) -> (v' -> v -> v') -> (subst -> v -> (v,r)) -> subst -> v' -> (v',r)
substLift toV updV app s v'
  = (updV v' x,r)
  where (x,r) = app s $ toV v'







varmpinfoFtvMp :: VarMpInfo -> TvCatMp
varmpinfoFtvMp i
  = case i of
      VMITy       t  -> tyFtvMp    t
      VMIImpls    i  -> implsFtvMp i
      _              -> emptyTvCatMp        -- incomplete







instance VarLookup m TyVarId VarMpInfo => VarUpdatable Ty m where
  varUpd        = tyAppVarLookup
  varUpdCyc    = tyAppVarLookup2

instance VarExtractable Ty TyVarId where
  varFreeSet    = tyFtv









-- instance VarUpdatable Label VarMp where
instance VarLookup m ImplsVarId VarMpInfo => VarUpdatable Label m where
  s `varUpd` lb          = maybe lb id $ varmpLabelLookupLabelCyc lb s

instance VarExtractable Label TyVarId where
  varFree (Label_Var v) = [v]
  varFree _             = []

-- instance VarUpdatable LabelOffset VarMp where
instance VarLookup m UID VarMpInfo => VarUpdatable LabelOffset m where
  s `varUpd` o@(LabelOffset_Var v) = maybe o id $ varmpOffsetLookup v s
  s `varUpd` o                     = o

instance VarExtractable LabelOffset TyVarId where
  varFree (LabelOffset_Var v) = [v]
  varFree _                   = []



instance (VarUpdatable vv subst) => VarUpdatable [vv] subst where
  s      `varUpd`  l   =   map (varUpd s) l
  s      `varUpdCyc` l   =   (l,varmpUnions m)
                  where (l,m) = unzip $ map (varUpdCyc s) l

instance (VarExtractable vv k) => VarExtractable [vv] k where
  varFreeSet      l   =   Set.unions $ map varFreeSet l


























instance VarLookupCmb m (VarMp' k v) => VarUpdatable (VarMp' k v) m where
  varUpd                                =   (|+>)

instance VarExtractable VarMp TyVarId where
  varFreeSet               (VarMp _ sl)    =   Set.unions $ map (varFreeSet . Map.elems) sl





instance VarUpdatable vv subst => VarUpdatable (HsName,vv) subst where
  s `varUpd`  (k,v) =  (k,s `varUpd` v)

instance VarExtractable vv k => VarExtractable (HsName,vv) k where
  varFreeSet (_,v) =  varFreeSet v



instance VarUpdatable Pred VarMp where
  s `varUpd`  p  =  (\(Ty_Pred p) -> p) (s `varUpd` (Ty_Pred p))

instance VarExtractable Pred TyVarId where
  varFreeSet p  =  varFreeSet (Ty_Pred p)

-- instance VarUpdatable PredScope VarMp where
instance VarLookup m ImplsVarId VarMpInfo => VarUpdatable PredScope m where
  s `varUpd`  sc                   = maybe sc id $ varmpScopeLookupScopeCyc sc s

instance VarExtractable PredScope TyVarId where
  varFree    (PredScope_Var v)    = [v]
  varFree    _                    = []

instance VarUpdatable CHRPredOccCxt VarMp where
  s `varUpd`  (CHRPredOccCxt_Scope1 sc) = CHRPredOccCxt_Scope1 (s `varUpd` sc)

instance VarExtractable CHRPredOccCxt TyVarId where
  varFree    (CHRPredOccCxt_Scope1 sc) = varFree sc

instance VarUpdatable PredOcc VarMp where
  s `varUpd`  (PredOcc pr id sc r)  = PredOcc (s `varUpd` pr) id (s `varUpd` sc) r

instance VarExtractable PredOcc TyVarId where
  varFreeSet (PredOcc pr id sc _)  = varFreeSet pr `Set.union` varFreeSet sc

instance VarUpdatable CHRPredOcc VarMp where
  s `varUpd`  (CHRPredOcc pr sc r)  = CHRPredOcc (s `varUpd` pr) (s `varUpd` sc) r

instance VarExtractable CHRPredOcc TyVarId where
  varFreeSet (CHRPredOcc pr sc _)  = varFreeSet pr `Set.union` varFreeSet sc

instance VarUpdatable Impls VarMp where
  s `varUpd`  i  =  (\(Ty_Impls i) -> i) (s `varUpd` (Ty_Impls i))

instance VarExtractable Impls TyVarId where
  varFreeSet i  =  varFreeSet (Ty_Impls i)



















instance VarUpdatable VarMpInfo VarMp where
  s `varUpd` vmi =  case vmi of
                 VMITy       t  -> VMITy (s `varUpd` t)
                 VMIImpls    i  -> VMIImpls (s `varUpd` i)
                 VMIPred     i  -> VMIPred (s `varUpd` i)
                 VMIScope    sc -> VMIScope (s `varUpd` sc)
                 VMIPredSeq  x  -> VMIPredSeq (s `varUpd` x)
                 -- VMIExts     x  -> VMIExts (s `varUpd` x)
                 vmi            -> vmi









instance VarExtractable VarMpInfo VarId where
  varFreeSet vmi = case vmi of
                 VMITy       t  -> varFreeSet t
                 VMIImpls    i  -> varFreeSet i
                 VMIPred     i  -> varFreeSet i
                 VMIScope    sc -> varFreeSet sc
                 VMIPredSeq  x  -> varFreeSet x
                 -- VMIExts     x  -> varFreeSet x
                 vmi            -> Set.empty

























instance VarUpdatable PredSeq VarMp where
  s `varUpd`  a@(PredSeq_Var  v  ) = maybe a id $ varmpPredSeqLookup v s
  s `varUpd`    (PredSeq_Cons h t) = PredSeq_Cons (s `varUpd` h) (s `varUpd` t)
  _ `varUpd`    x                  = x

instance VarExtractable PredSeq TyVarId where
  varFreeSet   (PredSeq_Var  v  ) = Set.singleton v
  varFreeSet   (PredSeq_Cons h t) = varFreeSet h `Set.union` varFreeSet t
  varFreeSet _                    = Set.empty







-- | Construct varmp for fixing tvars to new fresh fixed tvars + varmp for unfixing those to (again) fresh tvars, resp meta tvars
fixTyVarsVarMp :: UID -> Ty -> (VarMp,VarMp,VarMp,VarMp)
fixTyVarsVarMp uniq t
  = ( mk TyVarCateg_Fixed fv rv
    , mk TyVarCateg_Meta  fv rv
    , mk TyVarCateg_Plain rv rv2
    , mk TyVarCateg_Meta  rv rv2
    )
  where fv = varFree t
        l  = length fv
        (rv,rv2) = splitAt l $ mkNewUIDL (2*l) uniq
        mk cat fv rv = mkVarMp $ Map.fromList $ zipWith (\v r -> (v,VMITy (Ty_Var r cat))) fv rv

tyFixTyVars :: UID -> Ty -> (Ty,VarMp,VarMp,VarMp)
tyFixTyVars uniq t
  = (sTo `varUpd` t, sTo, sFr, smFr)
  where (sTo,_,sFr,smFr) = fixTyVarsVarMp uniq t

-- | replace tvars with tvars having TyVarCateg_Meta
tyMetaTyVars :: UID -> Ty -> Ty
tyMetaTyVars uniq t
  = smTo `varUpd` t
  where (_,smTo,_,_) = fixTyVarsVarMp uniq t







setSubst :: VarMp -> TyVarIdS -> TyVarIdS
setSubst m s = varFreeSet $ (varUpd m) $ map mkTyVar $ Set.toList s







varmpMapTyVarKey :: VarMp -> VarMp -> VarMp
varmpMapTyVarKey mMap m
  = varmpUnions [ varmpTyUnit v x | (Ty_Var v _,x) <- assocLMapKey (\v -> fst $ appUnAnnCanon $ mMap `varUpd` mkTyVar v) $ varmpToAssocTyL m ]

















ppS :: VarUpdatable x m => (x -> PP_Doc) -> m -> x -> PP_Doc
ppS pp c x = (pp $ c `varUpd` x) >#< ppParens (pp x)















varmpOccurErr :: Range -> VarMp -> VarMp -> [Err]
varmpOccurErr r m mc = [ Err_OccurCycle r v (varmpDel [v] m `varUpd` t) | (v,t) <- varmpToAssocTyL mc ]


</pre>