<a href="Options.hs20494589851766946662.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Ord.hs1256830559902053221.out.html">next</a></br></br><pre>66c66
< {-# LINE 70 "src/ehc/Opts.chs" #-}
---
> 
66a67
> 
66a68
> 
66a69
> 
87c90
< {-# LINE 96 "src/ehc/Opts.chs" #-}
---
> 
87a91
> 
87a92
> 
87a93
> 
87a94
> 
87a95
> 
94c102
< {-# LINE 108 "src/ehc/Opts.chs" #-}
---
> 
94a103
> 
94a104
> 
94a105
> 
94a106
> 
94a107
> 
102c115
< {-# LINE 117 "src/ehc/Opts.chs" #-}
---
> 
102a116
> 
119c133
< {-# LINE 180 "src/ehc/Opts.chs" #-}
---
> 
119a134
> 
119a135
> 
119a136
> 
119a137
> 
119a138
> 
119a139
> 
119a140
> 
119a141
> 
119a142
> 
119a143
> 
119a144
> 
119a145
> 
119a146
> 
119a147
> 
119a148
> 
119a149
> 
119a150
> 
119a151
> 
119a152
> 
119a153
> 
119a154
> 
119a155
> 
119a156
> 
119a157
> 
119a158
> 
119a159
> 
119a160
> 
119a161
> 
119a162
> 
119a163
> 
119a164
> 
119a165
> 
119a166
> 
119a167
> 
119a168
> 
119a169
> 
119a170
> 
119a171
> 
119a172
> 
119a173
> 
119a174
> 
119a175
> 
119a176
> 
119a177
> 
119a178
> 
119a179
> 
128c188
< {-# LINE 196 "src/ehc/Opts.chs" #-}
---
> 
128a189
> 
128a190
> 
128a191
> 
128a192
> 
128a193
> 
128a194
> 
128a195
> 
134c201
< {-# LINE 203 "src/ehc/Opts.chs" #-}
---
> 
134a202
> 
140c208
< {-# LINE 210 "src/ehc/Opts.chs" #-}
---
> 
140a209
> 
146c215
< {-# LINE 276 "src/ehc/Opts.chs" #-}
---
> 
146a216
> 
146a217
> 
146a218
> 
146a219
> 
146a220
> 
146a221
> 
146a222
> 
146a223
> 
146a224
> 
146a225
> 
146a226
> 
146a227
> 
146a228
> 
146a229
> 
146a230
> 
146a231
> 
146a232
> 
146a233
> 
146a234
> 
146a235
> 
146a236
> 
146a237
> 
146a238
> 
146a239
> 
146a240
> 
146a241
> 
146a242
> 
146a243
> 
146a244
> 
146a245
> 
146a246
> 
146a247
> 
146a248
> 
146a249
> 
146a250
> 
146a251
> 
146a252
> 
146a253
> 
146a254
> 
146a255
> 
146a256
> 
146a257
> 
146a258
> 
146a259
> 
146a260
> 
146a261
> 
146a262
> 
146a263
> 
146a264
> 
146a265
> 
146a266
> 
146a267
> 
146a268
> 
146a269
> 
146a270
> 
146a271
> 
146a272
> 
146a273
> 
146a274
> 
146a275
> 
151c280
< {-# LINE 286 "src/ehc/Opts.chs" #-}
---
> 
151a281
> 
151a282
> 
151a283
> 
151a284
> 
151a285
> 
160c294
< {-# LINE 302 "src/ehc/Opts.chs" #-}
---
> 
160a295
> 
160a296
> 
160a297
> 
160a298
> 
160a299
> 
160a300
> 
160a301
> 
215c356
< {-# LINE 466 "src/ehc/Opts.chs" #-}
---
> 
215a357
> 
215a358
> 
215a359
> 
215a360
> 
215a361
> 
215a362
> 
215a363
> 
215a364
> 
215a365
> 
215a366
> 
215a367
> 
215a368
> 
215a369
> 
215a370
> 
215a371
> 
215a372
> 
215a373
> 
215a374
> 
215a375
> 
215a376
> 
215a377
> 
215a378
> 
215a379
> 
215a380
> 
215a381
> 
215a382
> 
215a383
> 
215a384
> 
215a385
> 
215a386
> 
215a387
> 
215a388
> 
215a389
> 
215a390
> 
215a391
> 
215a392
> 
215a393
> 
215a394
> 
215a395
> 
215a396
> 
215a397
> 
215a398
> 
215a399
> 
215a400
> 
215a401
> 
215a402
> 
215a403
> 
215a404
> 
215a405
> 
215a406
> 
215a407
> 
215a408
> 
215a409
> 
215a410
> 
215a411
> 
215a412
> 
215a413
> 
215a414
> 
215a415
> 
215a416
> 
215a417
> 
215a418
> 
215a419
> 
215a420
> 
215a421
> 
215a422
> 
215a423
> 
215a424
> 
215a425
> 
215a426
> 
215a427
> 
215a428
> 
215a429
> 
215a430
> 
215a431
> 
215a432
> 
215a433
> 
215a434
> 
215a435
> 
215a436
> 
215a437
> 
215a438
> 
215a439
> 
215a440
> 
215a441
> 
215a442
> 
215a443
> 
215a444
> 
215a445
> 
215a446
> 
215a447
> 
215a448
> 
215a449
> 
215a450
> 
215a451
> 
215a452
> 
215a453
> 
215a454
> 
215a455
> 
215a456
> 
215a457
> 
215a458
> 
215a459
> 
215a460
> 
215a461
> 
215a462
> 
215a463
> 
215a464
> 
215a465
> 
364c614
< {-# LINE 755 "src/ehc/Opts.chs" #-}
---
> 
364a615
> 
364a616
> 
364a617
> 
364a618
> 
364a619
> 
364a620
> 
364a621
> 
364a622
> 
364a623
> 
364a624
> 
364a625
> 
364a626
> 
364a627
> 
364a628
> 
364a629
> 
364a630
> 
364a631
> 
364a632
> 
364a633
> 
364a634
> 
364a635
> 
364a636
> 
364a637
> 
364a638
> 
364a639
> 
364a640
> 
364a641
> 
364a642
> 
364a643
> 
364a644
> 
364a645
> 
364a646
> 
364a647
> 
364a648
> 
364a649
> 
364a650
> 
364a651
> 
364a652
> 
364a653
> 
364a654
> 
364a655
> 
364a656
> 
364a657
> 
364a658
> 
364a659
> 
364a660
> 
364a661
> 
364a662
> 
364a663
> 
364a664
> 
364a665
> 
364a666
> 
364a667
> 
364a668
> 
364a669
> 
364a670
> 
364a671
> 
364a672
> 
364a673
> 
364a674
> 
364a675
> 
364a676
> 
364a677
> 
364a678
> 
364a679
> 
364a680
> 
364a681
> 
364a682
> 
364a683
> 
364a684
> 
364a685
> 
364a686
> 
364a687
> 
364a688
> 
364a689
> 
364a690
> 
364a691
> 
364a692
> 
364a693
> 
364a694
> 
364a695
> 
364a696
> 
364a697
> 
364a698
> 
364a699
> 
364a700
> 
364a701
> 
364a702
> 
364a703
> 
364a704
> 
364a705
> 
364a706
> 
364a707
> 
364a708
> 
364a709
> 
364a710
> 
364a711
> 
364a712
> 
364a713
> 
364a714
> 
364a715
> 
364a716
> 
364a717
> 
364a718
> 
364a719
> 
364a720
> 
364a721
> 
364a722
> 
364a723
> 
364a724
> 
364a725
> 
364a726
> 
364a727
> 
364a728
> 
364a729
> 
364a730
> 
364a731
> 
364a732
> 
364a733
> 
364a734
> 
364a735
> 
364a736
> 
364a737
> 
364a738
> 
364a739
> 
364a740
> 
364a741
> 
364a742
> 
364a743
> 
364a744
> 
364a745
> 
364a746
> 
364a747
> 
364a748
> 
364a749
> 
364a750
> 
364a751
> 
364a752
> 
364a753
> 
364a754
> 
376c766
< {-# LINE 776 "src/ehc/Opts.chs" #-}
---
> 
376a767
> 
376a768
> 
376a769
> 
376a770
> 
376a771
> 
376a772
> 
376a773
> 
376a774
> 
376a775
> 
393c792
< {-# LINE 806 "src/ehc/Opts.chs" #-}
---
> 
393a793
> 
393a794
> 
393a795
> 
393a796
> 
393a797
> 
393a798
> 
393a799
> 
393a800
> 
393a801
> 
393a802
> 
393a803
> 
393a804
> 
393a805
> 
410c822
< {-# LINE 824 "src/ehc/Opts.chs" #-}
---
> 
410a823
> 
414c827
< {-# LINE 833 "src/ehc/Opts.chs" #-}
---
> 
414a828
> 
414a829
> 
414a830
> 
414a831
> 
414a832
> 
423c841
< {-# LINE 843 "src/ehc/Opts.chs" #-}
---
> 
423a842
> 
433c852
< {-# LINE 854 "src/ehc/Opts.chs" #-}
---
> 
433a853
> 
439c859
< {-# LINE 861 "src/ehc/Opts.chs" #-}
---
> 
439a860
> 
460c881
< {-# LINE 883 "src/ehc/Opts.chs" #-}
---
> 
460a882
> 
476c898
< {-# LINE 904 "src/ehc/Opts.chs" #-}
---
> 
476a899
> 
476a900
> 
476a901
> 
476a902
> 
476a903
> 
479c906
< {-# LINE 908 "src/ehc/Opts.chs" #-}
---
> 
479a907
> 
482c910
< {-# LINE 916 "src/ehc/Opts.chs" #-}
---
> 
482a911
> 
482a912
> 
482a913
> 
482a914
> 
482a915
> 
485c918
< {-# LINE 936 "src/ehc/Opts.chs" #-}
---
> 
485a919
> 
485a920
> 
485a921
> 
485a922
> 
485a923
> 
485a924
> 
485a925
> 
485a926
> 
485a927
> 
485a928
> 
485a929
> 
485a930
> 
485a931
> 
485a932
> 
485a933
> 
485a934
> 
485a935
> 
488c938
< {-# LINE 940 "src/ehc/Opts.chs" #-}
---
> 
488a939
> 
491c942
< {-# LINE 948 "src/ehc/Opts.chs" #-}
---
> 
491a943
> 
491a944
> 
491a945
> 
491a946
> 
491a947
> 
507c963
< {-# LINE 969 "src/ehc/Opts.chs" #-}
---
> 
507a964
> 
507a965
> 
507a966
> 
507a967
> 
507a968
> 
521c982
< {-# LINE 990 "src/ehc/Opts.chs" #-}
---
> 
521a983
> 
521a984
> 
521a985
> 
521a986
> 
521a987
> 
521a988
> 
521a989
> 
526c994
< {-# LINE 996 "src/ehc/Opts.chs" #-}
---
> 
526a995
> 
539c1008
< {-# LINE 1030 "src/ehc/Opts.chs" #-}
---
> 
539a1009
> 
539a1010
> 
539a1011
> 
539a1012
> 
539a1013
> 
539a1014
> 
539a1015
> 
539a1016
> 
539a1017
> 
539a1018
> 
539a1019
> 
539a1020
> 
539a1021
> 
539a1022
> 
539a1023
> 
539a1024
> 
539a1025
> 
539a1026
> 
539a1027
> 
539a1028
> 
539a1029
> 
548c1038
< {-# LINE 1040 "src/ehc/Opts.chs" #-}
---
> 
548a1039
> 
562c1053
< {-# LINE 1070 "src/ehc/Opts.chs" #-}
---
> 
562a1054
> 
562a1055
> 
562a1056
> 
562a1057
> 
562a1058
> 
562a1059
> 
562a1060
> 
562a1061
> 
562a1062
> 
562a1063
> 
562a1064
> 
562a1065
> 
562a1066
> 
562a1067
> 
562a1068
> 
562a1069
> 
566c1073
< {-# LINE 1075 "src/ehc/Opts.chs" #-}
---
> 
566a1074
> 
577c1085
< {-# LINE 1091 "src/ehc/Opts.chs" #-}
---
> 
577a1086
> 
577a1087
> 
577a1088
> 
577a1089
> 
577a1090
> 
581c1094
< {-# LINE 1096 "src/ehc/Opts.chs" #-}
---
> 
581a1095
> 
585c1099
< {-# LINE 1101 "src/ehc/Opts.chs" #-}
---
> 
585a1100
> 
592c1107
< {-# LINE 1120 "src/ehc/Opts.chs" #-}
---
> 
592a1108
> 
592a1109
> 
592a1110
> 
592a1111
> 
592a1112
> 
592a1113
> 
592a1114
> 
592a1115
> 
592a1116
> 
592a1117
> 
592a1118
> 
592a1119
> 
596c1123
< {-# LINE 1125 "src/ehc/Opts.chs" #-}
---
> 
596a1124
> 
603c1131
< {-# LINE 1133 "src/ehc/Opts.chs" #-}
---
> 
603a1132
> 
617c1146
< {-# LINE 1150 "src/ehc/Opts.chs" #-}
---
> 
617a1147
> 
617a1148
> 
617a1149
> 
621c1153
< {-# LINE 1155 "src/ehc/Opts.chs" #-}
---
> 
621a1154
> 
625c1158
< {-# LINE 1160 "src/ehc/Opts.chs" #-}
---
> 
625a1159
> 
630c1164
< {-# LINE 1166 "src/ehc/Opts.chs" #-}
---
> 
630a1165
> 
634c1169
< {-# LINE 1175 "src/ehc/Opts.chs" #-}
---
> 
634a1170
> 
634a1171
> 
634a1172
> 
634a1173
> 
634a1174
> 
637a1178
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Opts
( module UHC.Light.Compiler.Opts.Base
, optOptsIsYes, showStr2stMp
, defaultEHCOpts
, ehcCmdLineOpts
, ehcrunCmdLineOpts
, GetOptCmdLineOpts
, ehcCmdLineOptsApply, ehcrunCmdLineOptsApply
, FIOpts (..)
, strongFIOpts
, instLFIOpts
, instLRFIOpts
, unifyFIOpts, instFIOpts
, fioSwapPolarity, fioSwapOpts
, fioMkStrong
, fioMkWeak
, fioMkUnify
, fioIsSubsume
, weakFIOpts
, Optimize (..), OptimizationLevel (..)
, module UHC.Light.Compiler.Base.FileSearchLocation
, ehcOptWholeProgHPTAnalysis
, ehcOptOptimizes
, fioMkFinal
, FIOBind (..)
, fioBindIsYes, fioBindNoSet
, predFIOpts, implFIOpts
, ehcOptWholeProgOptimizationScope
, ehcOptEarlyModMerge
, optsDiscrRecompileRepr
, ehcOptUpdateWithPragmas )
where
import System.Console.GetOpt
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import UHC.Util.Utils
import Data.Maybe
import qualified Data.Map as Map
import Data.Char
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty
import qualified Data.Set as Set
import Data.List
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Util.FPath
import UHC.Light.Compiler.EHC.Environment
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.Base.FileSearchLocation
import UHC.Light.Compiler.Error
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.Base.Pragma
import UHC.Light.Compiler.Opts.CommandLine
import UHC.Light.Compiler.Base.Parser
import UHC.Light.Compiler.Base.Parser2
import UHC.Light.Compiler.Base.Debug









{-# LINE 70 "src/ehc/Opts.chs" #-}
-- | possibly adapt with pragmas
ehcOptUpdateWithPragmas :: Set.Set Pragma -> EHCOpts -> (EHCOpts,Bool)
ehcOptUpdateWithPragmas pragmas opts
  = foldr (\p om@(o,modf) -> maybe om (\o -> (o,True)) $ upd p o) (opts,False) (Set.toList pragmas)
  where upd pragma opts
          = case pragma of
              Pragma_NoGenericDeriving      -> Just $ opts { ehcOptGenGenerics          = False }
              Pragma_GenericDeriving        -> Just $ opts { ehcOptGenGenerics          = True  }
              Pragma_NoBangPatterns         -> Just $ opts { ehcOptBangPatterns         = False }
              Pragma_BangPatterns           -> Just $ opts { ehcOptBangPatterns         = True  }
              Pragma_NoOverloadedStrings    -> Just $ opts { ehcOptOverloadedStrings    = False }
              Pragma_OverloadedStrings      -> Just $ opts { ehcOptOverloadedStrings    = True  }
              Pragma_NoPolyKinds            -> Just $ opts { ehcOptPolyKinds            = False }
              Pragma_PolyKinds              -> Just $ opts { ehcOptPolyKinds            = True  }
              Pragma_ExtensibleRecords      -> Just $ opts { ehcOptExtensibleRecords    = True  }
              Pragma_Fusion                 -> Just $ opts { ehcOptFusion               = True  }
              Pragma_OptionsUHC o           -> fmap (\o -> o {ehcOptCmdLineOptsDoneViaPragma = True}) mo
                                            where (mo,_,_) = ehcCmdLineOptsApply [] (words o) opts
              _                             -> Nothing

{-# LINE 96 "src/ehc/Opts.chs" #-}
mkStringPath :: String -> [String]
mkStringPath = wordsBy (`elem` ";,")

mkFileLocPath :: String -> FileLocPath
mkFileLocPath = map mkDirFileLoc . mkStringPath

{-# LINE 108 "src/ehc/Opts.chs" #-}
optOpts :: Map.Map String opt -> String -> [opt]
optOpts m s = catMaybes $ map (\os -> Map.lookup os m) $ wordsBy (==',') s

optOptsIsYes :: Eq opt => Maybe [opt] -> opt -> Bool
optOptsIsYes mos o = maybe False (o `elem`) mos


{-# LINE 117 "src/ehc/Opts.chs" #-}
instance Show CoreOpt where
  -- show CoreOpt_PPParseable      = "pp-parseable"
  show CoreOpt_Dump                 = "dump"
  show CoreOpt_DumpBinary           = "dump-binary"
  show CoreOpt_DumpAlsoNonParseable = "whendump-alsononparseable"
  show CoreOpt_Run                  = "run"
  show CoreOpt_RunDump              = "dump-run"
  show CoreOpt_RunTrace             = "run-trace"
  show CoreOpt_RunTraceExtensive    = "run-trace-extensive"
  show CoreOpt_RunPPNames           = "run-ppnames"
  show CoreOpt_RunPPVerbose         = "run-ppverbose"
  show _                            = "-"

coreOptMp :: Map.Map String CoreOpt
coreOptMp = str2stMpWithOmit [CoreOpt_NONE]

{-# LINE 180 "src/ehc/Opts.chs" #-}
instance Show PgmExec where
  show PgmExec_CPP      = "P"
  show PgmExec_C        = "c"
  show PgmExec_Linker   = "l"

pgmExecMp :: Map.Map String PgmExec
pgmExecMp = str2stMp

{-# LINE 196 "src/ehc/Opts.chs" #-}
-- do something with whole program
ehcOptWholeProgOptimizationScope :: EHCOpts -> Bool
ehcOptWholeProgOptimizationScope opts
  = ehcOptOptimizationScope opts > OptimizationScope_PerModule

{-# LINE 203 "src/ehc/Opts.chs" #-}
-- compatibility option
ehcOptEarlyModMerge :: EHCOpts -> Bool
ehcOptEarlyModMerge opts
  = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore

{-# LINE 210 "src/ehc/Opts.chs" #-}
-- do whole program analysis, with HPT
ehcOptWholeProgHPTAnalysis :: EHCOpts -> Bool
ehcOptWholeProgHPTAnalysis opts
  = False

{-# LINE 276 "src/ehc/Opts.chs" #-}
-- | optimizes a particular option
ehcOptOptimizes :: Optimize -> EHCOpts -> Bool
ehcOptOptimizes o opts = o `Set.member` ehcOptOptimizations opts

{-# LINE 286 "src/ehc/Opts.chs" #-}
-- | The default EHC options.
defaultEHCOpts
  = emptyEHCOpts
      { ehcOptExecOptsMp = ehcOptExecOptsMp emptyEHCOpts `Map.union` Map.fromList
          [ (Cfg.shellCmdCpp, [ExecOpt_Plain "traditional-cpp", ExecOpt_Plain "std=gnu99", ExecOpt_Plain "fno-show-column", ExecOpt_Plain "P"])
          ]
      }

{-# LINE 302 "src/ehc/Opts.chs" #-}
-- | Commandline opts for ehc/uhc (EHC)
ehcCmdLineOpts :: GetOptCmdLineOpts
ehcCmdLineOpts = sharedCmdLineOpts ++
     [
        Option "t"  ["target"]              (ReqArg oTarget (showSupportedTargets'  "|"))
                                                                                    ("generate code for target, default=" ++ show defaultTarget)
     ,  Option ""   ["target-flavor"]       (ReqArg oTargetFlavor (showAllTargetFlavors' "|"))
                                                                                    ("generate code for target flavor, default=" ++ show defaultTargetFlavor)
     ,  Option "p"  ["pretty"]              (OptArg oPretty "hs|eh|ast|-")          "show pretty printed source or EH abstract syntax tree, default=eh, -=off, (downstream only)"


     ,  Option "O"  ["optimise"]            (OptArg oOptimization ("0|1|2|3|<opt>[=" ++ boolArgStr ++ "]"))
                                                                                    ("optimise with level or specific <opt> by optim name: "
                                                                                     ++ showStr2stMp allOptimizeMp
                                                                                     ++ ", or by scope name: "
                                                                                     ++ showStr2stMp allOptimScopeMp
                                                                                     ++ ", default=1")
     ,  Option ""   ["gen-trampoline"]      (boolArg oSetGenTrampoline)             "codegen: use trampoline mechanism (development/internal use only)"
     ,  Option ""   ["no-recomp"]           (NoArg oNoRecomp)                       "turn off recompilation check (force recompile)"
     ,  Option ""   ["no-prelude"]          (NoArg oNoPrelude)                      "do not assume presence of Prelude"
     ,  Option ""   ["no-hi-check"]         (NoArg oNoHiCheck)                      "no check on .hi files not matching the compiler version"
     ,  Option "c"  ["compile-only"]        (NoArg oCompileOnly)                    "compile only, do not link"
     ,  Option "i"  ["import-path"]         (ReqArg oUsrFileLocPath "path")         "search path for user files, separators=';', appended to previous"
     ,  Option "L"  ["lib-search-path"]     (ReqArg oLibFileLocPath "path")         "search path for library files, see also --import-path"
     ,  Option ""   ["cpp"]                 (NoArg oCPP)                            "preprocess source with CPP"
     ,  Option ""   ["limit-tysyn-expand"]  (intArg oLimitTyBetaRed)                "type synonym expansion limit"
     ,  Option ""   ["odir"]                (ReqArg oOutputDir "dir")               "base directory for generated files"
     ,  Option "o"  ["output"]              (ReqArg oOutputFile "file")             "file to generate executable to (implies --compile-only off)"
     ,  Option ""   ["keep-intermediate-files"] (NoArg oKeepIntermediateFiles)      "keep intermediate files (default=off)"
     ,  Option ""   ["meta-variant"]        (NoArg oVariant)                        "meta: print variant (then stop)"
     ,  Option ""   ["meta-target-default"] (NoArg oTargetDflt)                     "meta: print the default codegeneration target (then stop)"
     ,  Option ""   ["meta-targets"]        (NoArg oTargets)                        "meta: print supported codegeneration targets (then stop)"
     ,  Option ""   ["meta-optimizations"]  (NoArg oOptimizations)                  "meta: print optimization names (then stop)"
     ,  Option ""   ["meta-pkgdir-system"]  (NoArg oMetaPkgdirSys)                  "meta: print system package dir (then stop)"
     ,  Option ""   ["meta-pkgdir-user"]    (NoArg oMetaPkgdirUser)                 "meta: print user package dir (then stop)"
     ,  Option ""   ["package"]             (ReqArg oExposePackage "package")       "see --pkg-expose"
     ,  Option ""   ["hide-all-packages"]   (NoArg oHideAllPackages)                "see --pkg-hide-all"
     ,  Option ""   ["pkg-expose"]          (ReqArg oExposePackage "package")       "pkg: expose/use package"
     ,  Option ""   ["pkg-hide"]            (ReqArg oHidePackage   "package")       "pkg: hide package"
     ,  Option ""   ["pkg-hide-all"]        (NoArg oHideAllPackages)                "pkg: hide all (implicitly) assumed/used packages"
     ,  Option ""   ["pkg-searchpath"]      (ReqArg oPkgdirLocPath "path")          "pkg: package search directories, each dir has <pkg>/<variant>/<target>/<flavor>"
     ,  Option ""   ["pkg-build"]           (ReqArg oPkgBuild "package")            "pkg build: build package from files. Implies --compile-only"
     ,  Option ""   ["pkg-build-exposed"]   (ReqArg oPkgBuildExposedModules "modules")
                                                                                    "pkg build: for package building, exposed modules (blank separated)"
     ,  Option ""   ["pkg-build-depends"]   (ReqArg oPkgBuildBuildDepends "packages")
                                                                                    "pkg build: for package building, depended on packages (blank separated)"
     ,  Option ""   ["cfg-install-root"]    (ReqArg oCfgInstallRoot "dir")          "cfg: installation root (to be used only by wrapper script)"
     ,  Option ""   ["cfg-install-variant"] (ReqArg oCfgInstallVariant "variant")   "cfg: installation variant (to be used only by wrapper script)"
     ,  Option ""   ["optP"]                (ReqArg (oCmdLineOpts Cmd_CPP_Preprocessing) "opt for cmd")
                                                                                    "opt: option for cmd used by compiler, currently only P (preprocessing)"
     ,  Option ""   ["pgmP"]                (ReqArg (oPgmExec PgmExec_CPP)          "alternate program for cmd")
                                                                                    "pgm: alternate executable used by compiler, currently only P (preprocessing)"
     ,  Option ""   ["coreopt"]             (ReqArg oOptCore "opt[,...]")           ("opts (specific) for core: " ++ showStr2stMp coreOptMp)
     ]
{-# LINE 466 "src/ehc/Opts.chs" #-}
  where  oPretty     ms  o =  case ms of
                                Just "-"     -> o { ehcOptShowEH       = False     }
                                Just "no"    -> o { ehcOptShowEH       = False     }
                                Just "off"   -> o { ehcOptShowEH       = False     }
                                Just "hs"    -> o { ehcOptShowHS       = True      }
                                Just "eh"    -> o { ehcOptShowEH       = True      }
                                Just "pp"    -> o { ehcOptShowEH       = True      }
                                _            -> o
         oShowTopTy  ms  o =  case ms of
                                Just "yes"  -> o { ehcOptShowTopTyPP   = True      }
                                _           -> o
         oVariant        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_Variant }
         oDebug          o =  o { ehcOptDebug         = True
                                }
         oStopAt       s o =  o { ehcStopAtPoint       =
                                    case s of
                                      "0" -> CompilePoint_Imports
                                      "1" -> CompilePoint_Parse
                                      "2" -> CompilePoint_AnalHS
                                      "3" -> CompilePoint_AnalEH
                                      "4" -> CompilePoint_Core
                                      _   -> CompilePoint_All
                                }
         oOptCore    s   o =  o { ehcOptCoreOpts = optOpts coreOptMp s ++ ehcOptCoreOpts o}
         oTarget        s o =  o { ehcOptMbTarget          = mbtarget
                                 , ehcOptOptimizationScope = if isJustOk mbtarget && targetDoesHPTAnalysis (fromJustOk mbtarget)
                                                             then max oscope (maxBound :: OptimizationScope)
                                                             else oscope
                                 }
                            where mbtarget = maybe (NotOk s) JustOk $ Map.lookup s supportedTargetMp
                                  oscope = ehcOptOptimizationScope o
         oTargetFlavor  s o =  o { ehcOptMbTargetFlavor  = maybe (NotOk s) JustOk $ Map.lookup s allTargetFlavorMp }
         oOptimizations   o =  o { ehcOptImmQuit         = Just ImmediateQuitOption_Meta_Optimizations       }
         oTargets        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_Targets       }
         oTargetDflt     o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_TargetDefault  }

         oCode       ms  o =  case ms of
                                Just "hs"    -> o { ehcOptEmitHS           = True   }
                                Just "eh"    -> o { ehcOptEmitEH           = True   }
                                Just "-"     -> o -- { ehcOptEmitCore         = False  }
                                Just "core"  -> o { ehcOptMbTarget         = JustOk Target_None_Core_AsIs
                                                  }
                                Just "tycore"-> o { ehcOptMbTarget         = JustOk Target_None_TyCore_None
                                                  }
                                _            -> o

         oOptimization ms o
                           = o' {ehcOptOptimizations = optimizeRequiresClosure os}
                           where (o',doSetOpts)
                                    = case ms of
                                        Just (clevel:',':cscope:_)
                                          | isJust mbO -> (fromJust mbO o, True)
                                          where mbO = mbLevelScope (Just clevel) (Just cscope)
                                        Just (',':cscope:_)
                                          | isJust mbO -> (fromJust mbO o, True)
                                          where mbO = mbLevelScope Nothing (Just cscope)
                                        Just olevel@(clevel:_)
                                          | isDigit clevel && l >= 0 && l < (maxscp * maxlev)
                                            -> ( o { ehcOptOptimizationLevel = toEnum lev, ehcOptOptimizationScope = toEnum sc }
                                               , True
                                               )
                                          where l = read olevel :: Int
                                                (sc,lev) = quotRem l maxlev
                                        Just scpname@(_:_)
                                          | isJust mbScp
                                            -> ( o { ehcOptOptimizationScope = sc }
                                               , True
                                               )
                                          where mbScp@(~(Just sc)) = Map.lookup scpname allOptimScopeMp
                                        Just optname@(_:_)
                                          -> case break (== '=') optname of
                                               (nm, yesno)
                                                 -> ( o { ehcOptOptimizations = os
                                                        , ehcOptOptimizeOptionMp = osmp `Map.union` ehcOptOptimizeOptionMp o
                                                        }
                                                    , False
                                                    )
                                                 where set True  opt = Set.insert opt $ ehcOptOptimizations o
                                                       set False opt = Set.delete opt $ ehcOptOptimizations o
                                                       (os,osmp)
                                                          = -- lookup name, and attempt to extract boolean of assumedly '=' prefixed string, or if not a boolean try to extract specific config whilst also assuming True for the boolean
                                                            case (Map.lookup nm allOptimizeMp, optArgTake optArgAllAllow $ drop 1 yesno) of
                                                              (Just opt, Just (OptArg_Bool b,_ ))   -> (set b     opt           , Map.empty)
                                                              (Just opt, Just (OptArg_Int  i,_ ))   -> (set True  opt           , optimizeOptionMpSingleton opt optopt v)
                                                                                                    where (optopt,optdflt) = allOptimizeOptionMpAnyOption opt
                                                                                                          v = maybe optdflt (\(_,(lo,_)) -> toEnum $ fromEnum lo + i)
                                                                                                              $ mapLookup2 opt optopt allOptimizeOptionMp
                                                              (Just opt, _                      )   -> (set True  opt           , Map.empty)
                                                              _                                     -> (ehcOptOptimizations o   , Map.empty)
                                        Nothing
                                          -> (o { ehcOptOptimizationLevel      = OptimizationLevel_Much       }, True)
                                        _ -> (o, False)
                                 os | doSetOpts = Map.findWithDefault Set.empty (ehcOptOptimizationLevel o') optimizationLevelMp
                                    | otherwise = ehcOptOptimizations o'
                                 maxlev = fromEnum (maxBound :: OptimizationLevel) + 1
                                 maxscp = fromEnum (maxBound :: OptimizationScope) + 1
                                 mbLevelScope ml ms
                                   | isJust l && isJust s = Just (\o -> o { ehcOptOptimizationLevel = toEnum (fromJust l), ehcOptOptimizationScope = toEnum (fromJust s) })
                                   | otherwise            = Nothing
                                   where l = r ehcOptOptimizationLevel maxlev ml
                                         s = r ehcOptOptimizationScope maxscp ms
                                         r dflt mx m
                                           | x >= 0 && x < mx = Just x
                                           | otherwise        = Nothing
                                           where x = (maybe (fromEnum $ dflt o) (\c -> read [c]) m) :: Int
         oNoRecomp              o   = o { ehcOptCheckRecompile              = False    }
         oCompileOnly           o   = o { ehcOptLinkingStyle                = LinkingStyle_None }
         oNoHiCheck             o   = o { ehcOptHiValidityCheck             = False    }
         oUsrFileLocPath      s o   = o { ehcOptImportFileLocPath           = ehcOptImportFileLocPath o ++ mkFileLocPath s }
         oLibFileLocPath      s o   = o { ehcOptLibFileLocPath              = ehcOptLibFileLocPath o ++ mkFileLocPath s }
         oPkgdirLocPath       s o   = o { ehcOptPkgdirLocPath               = ehcOptPkgdirLocPath o ++ mkStringPath s }
         oNoPrelude             o   = o { ehcOptUseAssumePrelude            = False   }
         oCPP                   o   = o { ehcOptCPP                         = True    }
         oLimitTyBetaRed        o l = o { ehcOptTyBetaRedCutOffAt           = l }
         oLimitCtxtRed          o l = o { ehcOptPrfCutOffAt                 = l }
         oMetaPkgdirSys         o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_Meta_Pkgdir_System }
         oMetaPkgdirUser        o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_Meta_Pkgdir_User }
         oExposePackage       s o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ pkgSearchFilter parsePkgKey PackageSearchFilter_ExposePkg [s]
                                        -- , ehcOptLibPackages                 = ehcOptLibPackages   o ++ [s]
                                        }
         oHidePackage         s o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ pkgSearchFilter parsePkgKey PackageSearchFilter_HidePkg [s]
                                        }
         oHideAllPackages       o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ [PackageSearchFilter_HideAll]
                                        -- , ehcOptHideAllPackages             = True
                                        }
         oOutputDir           s o   = o { ehcOptOutputDir                   = Just s
                                          -- no linking when no output file is generated. This is not failsafe, requires better solution as now no executable is generated when no --output is specified. Should depend on existence of main.
                                        -- , ehcOptDoExecLinking                   = isJust (ehcOptMbOutputFile o)
                                        }
         oOutputFile          s o   = o { ehcOptMbOutputFile                = Just (mkFPath s)
                                        , ehcOptLinkingStyle                = LinkingStyle_Exec
                                        }
         oKeepIntermediateFiles o   = o { ehcOptKeepIntermediateFiles       = True }
         oPkgBuild            s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptName=s})
                                        , ehcOptLinkingStyle                = LinkingStyle_Pkg
                                        }
         oPkgBuildExposedModules
                              s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptExposedModules = words s})
                                        }
         oPkgBuildBuildDepends
                              s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptBuildDepends = words s})
                                        }
         oCfgInstallRoot      s o   = o { ehcOptCfgInstallRoot              = Just s }
         oCfgInstallVariant   s o   = o { ehcOptCfgInstallVariant           = Just s }
         oCmdLineOpts cmd     s o   = o { ehcOptCmdLineOpts                 = -- (\v -> tr "XX" (pp s >#< show v) v) $
                                                                              nub $ ehcOptCmdLineOpts o ++ fst (parseCmdLineOpts cmd s) }
         oPgmExec     cmd     s o   = o { ehcOptPgmExecMp                   = Map.insert cmd s $ ehcOptPgmExecMp o }

{-# LINE 755 "src/ehc/Opts.chs" #-}
-- | Commandline opts for ehcr/uhcr (EHCRun)
ehcrunCmdLineOpts :: GetOptCmdLineOpts
ehcrunCmdLineOpts
     =  sharedCmdLineOpts
     ++ [  Option ""   ["trace"]               (boolArg optTrace)                      "corerun: trace execution"
        ]
  where
        optTrace o b = o { ehcOptCoreOpts = upd $ ehcOptCoreOpts o }
          where upd | b         = (CoreOpt_RunTrace :)
                    | otherwise = (\\ [CoreOpt_RunTrace])

{-# LINE 776 "src/ehc/Opts.chs" #-}
-- | The description for GetOpt
type GetOptCmdLineOpts = [OptDescr (EHCOpts -> EHCOpts)]

-- | Commandline opts shared between main invocations
sharedCmdLineOpts :: GetOptCmdLineOpts
sharedCmdLineOpts
  =  [  Option "h"  ["help"]                (NoArg oHelp)                           "print this help (then stop)"
     ,  Option ""   ["version"]             (NoArg oVersion)                        "print version info (then stop)"
     ,  Option ""   ["version-dotted"]      (NoArg oNumVersion)                     ("print version in \"x.y.z\" style (then stop)")
     ,  Option ""   ["version-asnumber"]    (NoArg oVersionAsNumber)                ("print version in \"xyz\" style (then stop)")
     ,  Option ""   ["numeric-version"]     (NoArg oNumVersion)                     "see --version-dotted (to become obsolete)"
     ,  Option "v"  ["verbose"]             (OptArg oVerbose "0|1|2|3|4")           (   "be verbose, 0=quiet, 4=debug, "
                                                                                    ++ "default=1"
                                                                                    )
     ]

{-# LINE 806 "src/ehc/Opts.chs" #-}
-- | Help
oHelp           o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Help    }

-- | Version
oVersion        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Version }

-- | Verbosity
oVerbose    ms  o =  case ms of
                       Just "0"    -> o { ehcOptVerbosity     = VerboseQuiet       }
                       Just "1"    -> o { ehcOptVerbosity     = VerboseMinimal     }
                       Just "2"    -> o { ehcOptVerbosity     = VerboseNormal      }
                       Just "3"    -> o { ehcOptVerbosity     = VerboseALot        }
                       Just "4"    -> o { ehcOptVerbosity     = VerboseDebug       }
                       Nothing     -> o { ehcOptVerbosity     = succ (ehcOptVerbosity o)}
                       _           -> o

{-# LINE 824 "src/ehc/Opts.chs" #-}
oNumVersion            o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_VersionDotted }
oVersionAsNumber       o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_VersionAsNumber }

{-# LINE 833 "src/ehc/Opts.chs" #-}
-- | Int option
intArg  tr = ReqArg (optInt tr) "<nr>"

-- | EHCOpts updater for Int option
optInt :: (EHCOpts -> Int -> EHCOpts) -> String -> EHCOpts -> EHCOpts
optInt tr s o
 = tr o $ read s

{-# LINE 843 "src/ehc/Opts.chs" #-}
-- | What kind of optional args are allowed
data OptArgAllow
  = OptArgAllow_Bool
  | OptArgAllow_Int
  deriving (Eq,Enum,Bounded)

optArgAllAllow :: [OptArgAllow]
optArgAllAllow = [minBound .. maxBound]

{-# LINE 854 "src/ehc/Opts.chs" #-}
-- | An optional arg, universal type for all occurring variants
data OptArg
  = OptArg_Bool     Bool
  | OptArg_Int      Int

{-# LINE 861 "src/ehc/Opts.chs" #-}
optArgTake :: [OptArgAllow] -> String -> Maybe (OptArg,String)
optArgTake allow s
  = case s of
      ('-':r)           -> Just (OptArg_Bool False,r)
      ('n':'o':r)       -> Just (OptArg_Bool False,r)
      ('n':r)           -> Just (OptArg_Bool False,r)
      ('o':'f':'f':r)   -> Just (OptArg_Bool False,r)
      ('0':r) | noInt   -> Just (OptArg_Bool False,r)
      ('+':r)           -> Just (OptArg_Bool True ,r)
      ('y':'e':'s':r)   -> Just (OptArg_Bool True ,r)
      ('y':r)           -> Just (OptArg_Bool True ,r)
      ('o':'n':r)       -> Just (OptArg_Bool True ,r)
      ('1':r) | noInt   -> Just (OptArg_Bool True ,r)
      ( c :_) | yesInt && isDigit c
                        -> Just (OptArg_Int (read d) ,r)
                        where (d,r) = span isDigit s
      _                 -> Nothing
  where yesInt = OptArgAllow_Int `elem` allow
        noInt  = not yesInt

{-# LINE 883 "src/ehc/Opts.chs" #-}
optBooleanTake :: String -> Maybe (Bool,String)
optBooleanTake s
  = case optArgTake [OptArgAllow_Bool] s of
      Just (OptArg_Bool b, r)   -> Just (b,r)
      _                         -> Nothing

optBoolean :: (EHCOpts -> Bool -> EHCOpts) -> Maybe String -> EHCOpts -> EHCOpts
optBoolean tr ms o
 = case ms of
     Just s -> maybe o (tr o . fst) (optBooleanTake s)
     _      -> o

boolArgStr = "Bool"
boolArg tr = OptArg (optBoolean tr) boolArgStr

{-# LINE 904 "src/ehc/Opts.chs" #-}
oPriv                o b = o { ehcOptPriv           = b }

{-# LINE 908 "src/ehc/Opts.chs" #-}
optDumpCoreStages    o b = o { ehcOptDumpCoreStages = b }

{-# LINE 916 "src/ehc/Opts.chs" #-}
oSetGenTrampoline    o b = o { ehcOptGenTrampoline_ = b }

{-# LINE 936 "src/ehc/Opts.chs" #-}
oStopAtCoreError     o b = o { ehcDebugStopAtCoreError     = b }

{-# LINE 940 "src/ehc/Opts.chs" #-}
oStopAtHIError       o b = o { ehcDebugStopAtHIError       = b }

{-# LINE 948 "src/ehc/Opts.chs" #-}
-- | Apply the cmdline opts description to a EHCOpts, returning Nothing when there were no options
cmdlineOptsApply :: [OptDescr (EHCOpts -> EHCOpts)] -> [EHCOpts -> EHCOpts] -> [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
cmdlineOptsApply cmdlopts postopts args opts
  = (if null o' then Nothing else Just (foldl (flip ($)) opts o'),n,errs)
  where oo@(o,n,errs)  = getOpt Permute cmdlopts args
        o' = o ++ postopts

-- | Apply the cmdline opts description for 'EHC' to a EHCOpts, returning Nothing when there were no options
ehcCmdLineOptsApply :: [EHCOpts -> EHCOpts] -> [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
ehcCmdLineOptsApply = cmdlineOptsApply ehcCmdLineOpts

-- | Apply the cmdline opts description for 'EHCRun' to a EHCOpts, returning Nothing when there were no options
ehcrunCmdLineOptsApply :: [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
ehcrunCmdLineOptsApply = cmdlineOptsApply ehcrunCmdLineOpts []

{-# LINE 969 "src/ehc/Opts.chs" #-}
optsDiscrRecompileRepr :: EHCOpts -> String
optsDiscrRecompileRepr opts
  = concat
    $ intersperse " "
    $ [ show (ehcOptAspects opts)
      , o "clsrec"          (ehcCfgClassViaRec      opts)
      -- , o "exec"            (ehcOptEmitExecC        opts)
      -- , o "bexec"           (ehcOptEmitExecBytecode opts)
      , show (ehcOptTarget opts)
      , show (ehcOptOptimizationLevel opts)
      ]
  where o m v = if v then m else ""

{-# LINE 990 "src/ehc/Opts.chs" #-}
data FIOBind
  = FIOBindYes | FIOBindNoBut TyVarIdS
  deriving (Show)

{-# LINE 996 "src/ehc/Opts.chs" #-}
data FIOpts =  FIOpts   {  fioLeaveRInst     ::  !Bool                ,  fioBindRFirst           ::  !Bool
                        ,  fioBindLFirst     ::  !Bool                ,  fioBindLBeforeR         ::  !Bool
                        ,  fioMode           ::  !FIMode              ,  fioUniq                 ::  !UID
                        ,  fioBindCategs     ::  ![TyVarCateg]
                        ,  fioNoRLabElimFor  ::  ![HsName]            ,  fioNoLLabElimFor        ::  ![HsName]
                        ,  fioDontBind       ::  !TyVarIdS
                        ,  fioExpandEqTyVar  ::  !Bool                -- expand tyvars also when equal. Required for Sys F translation.
                        ,  fioPredAsTy       ::  !Bool                ,  fioAllowRPredElim       ::  !Bool
                        ,  fioBindLVars      ::  !FIOBind             ,  fioBindRVars            ::  !FIOBind
                        ,  fiMbMkErrClash    ::  Maybe (Ty -> Ty -> Err) -- alternate error construction for type clash
                        }

{-# LINE 1030 "src/ehc/Opts.chs" #-}
fioBindNoSet :: FIOBind -> TyVarIdS
fioBindNoSet (FIOBindNoBut s) = s
fioBindNoSet _                = Set.empty

fioBindIsYes :: FIOBind -> Bool
fioBindIsYes FIOBindYes = True
fioBindIsYes _          = False

{-# LINE 1040 "src/ehc/Opts.chs" #-}
strongFIOpts :: FIOpts
strongFIOpts =  FIOpts  {  fioLeaveRInst     =   False               ,  fioBindRFirst           =   True
                        ,  fioBindLFirst     =   True                ,  fioBindLBeforeR         =   True
                        ,  fioMode           =   FitSubLR            ,  fioUniq                 =   uidStart
                        ,  fioBindCategs     =   [TyVarCateg_Plain]
                        ,  fioNoRLabElimFor  =   []                  ,  fioNoLLabElimFor        =   []
                        ,  fioDontBind       =   Set.empty
                        ,  fioExpandEqTyVar  =   False
                        ,  fioPredAsTy       =   False               ,  fioAllowRPredElim       =   True
                        ,  fioBindLVars      =   FIOBindYes          ,  fioBindRVars            =   FIOBindYes
                        ,  fiMbMkErrClash    =   Nothing
                        }

{-# LINE 1070 "src/ehc/Opts.chs" #-}
instance Show FIOpts where
  show o =  "FIOpts"

{-# LINE 1075 "src/ehc/Opts.chs" #-}
instance PP FIOpts where
  pp   o =  "FIOpts{"
            >#< "leaveRInst=" >|< pp (fioLeaveRInst o)
            >#< "bindLFirst=" >|< pp (fioBindLFirst o)
            >#< "bindRFirst=" >|< pp (fioBindRFirst o)
            >#< "fioNoLLabElimFor=" >|< pp (show $ fioNoLLabElimFor o)
            >#< "fioNoRLabElimFor=" >|< pp (show $ fioNoRLabElimFor o)
            >#< "allowRPredElim=" >|< pp (fioAllowRPredElim o)
            >#< "}"

{-# LINE 1091 "src/ehc/Opts.chs" #-}
instLFIOpts :: FIOpts
instLFIOpts = strongFIOpts {fioBindRFirst = False}

{-# LINE 1096 "src/ehc/Opts.chs" #-}
instLRFIOpts :: FIOpts
instLRFIOpts = strongFIOpts {fioBindRFirst = False, fioBindLFirst = False}

{-# LINE 1101 "src/ehc/Opts.chs" #-}
unifyFIOpts :: FIOpts
unifyFIOpts = strongFIOpts {fioMode = FitUnify}

instFIOpts :: FIOpts
instFIOpts = instLFIOpts {fioLeaveRInst = True, fioBindLFirst = False}

{-# LINE 1120 "src/ehc/Opts.chs" #-}
weakFIOpts :: FIOpts
weakFIOpts = fioMkWeak strongFIOpts

{-# LINE 1125 "src/ehc/Opts.chs" #-}
predFIOpts :: FIOpts
predFIOpts = strongFIOpts {fioPredAsTy = True, fioLeaveRInst = True}

implFIOpts  :: FIOpts
implFIOpts = strongFIOpts {fioAllowRPredElim = False}

{-# LINE 1133 "src/ehc/Opts.chs" #-}
fioSwapOpts :: FIOpts -> FIOpts
fioSwapOpts fio
  = fio
      { fioBindRFirst   = fioBindLFirst fio
      , fioBindLFirst   = fioBindRFirst fio
      , fioBindLBeforeR = not (fioBindLBeforeR fio)
      , fioBindLVars    = fioBindRVars fio
      , fioBindRVars    = fioBindLVars fio
      }

fioSwapPolarity :: Polarity -> FIOpts -> FIOpts
fioSwapPolarity pol fio = fio {fioMode = fimSwapPol pol (fioMode fio)}

{-# LINE 1150 "src/ehc/Opts.chs" #-}
fioMkStrong :: FIOpts -> FIOpts
fioMkStrong fi = fi {fioLeaveRInst = False, fioBindRFirst = True, fioBindLFirst = True}

{-# LINE 1155 "src/ehc/Opts.chs" #-}
fioMkWeak :: FIOpts -> FIOpts
fioMkWeak fi = fi {fioLeaveRInst = True, fioBindRFirst = False}

{-# LINE 1160 "src/ehc/Opts.chs" #-}
-- | Adapt options for extracting final ty
fioMkFinal :: FIOpts -> FIOpts
fioMkFinal fi = fi {fioBindLFirst = False, fioBindRFirst = False, fioExpandEqTyVar = True}

{-# LINE 1166 "src/ehc/Opts.chs" #-}
fioMkUnify :: FIOpts -> FIOpts
fioMkUnify fi = fi {fioMode = FitUnify}

{-# LINE 1175 "src/ehc/Opts.chs" #-}
fioIsSubsume :: FIOpts -> Bool
fioIsSubsume fio =  case fioMode fio of {FitSubLR -> True ; _ -> False}

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Opts
( module UHC.Light.Compiler.Opts.Base
, optOptsIsYes, showStr2stMp
, defaultEHCOpts
, ehcCmdLineOpts
, ehcrunCmdLineOpts
, GetOptCmdLineOpts
, ehcCmdLineOptsApply, ehcrunCmdLineOptsApply
, FIOpts (..)
, strongFIOpts
, instLFIOpts
, instLRFIOpts
, unifyFIOpts, instFIOpts
, fioSwapPolarity, fioSwapOpts
, fioMkStrong
, fioMkWeak
, fioMkUnify
, fioIsSubsume
, weakFIOpts
, Optimize (..), OptimizationLevel (..)
, module UHC.Light.Compiler.Base.FileSearchLocation
, ehcOptWholeProgHPTAnalysis
, ehcOptOptimizes
, fioMkFinal
, FIOBind (..)
, fioBindIsYes, fioBindNoSet
, predFIOpts, implFIOpts
, ehcOptWholeProgOptimizationScope
, ehcOptEarlyModMerge
, optsDiscrRecompileRepr
, ehcOptUpdateWithPragmas )
where
import System.Console.GetOpt
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts.Base
import UHC.Util.Utils
import Data.Maybe
import qualified Data.Map as Map
import Data.Char
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty
import qualified Data.Set as Set
import Data.List
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Util.FPath
import UHC.Light.Compiler.EHC.Environment
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.Base.FileSearchLocation
import UHC.Light.Compiler.Error
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.Base.Pragma
import UHC.Light.Compiler.Opts.CommandLine
import UHC.Light.Compiler.Base.Parser
import UHC.Light.Compiler.Base.Parser2
import UHC.Light.Compiler.Base.Debug













-- | possibly adapt with pragmas
ehcOptUpdateWithPragmas :: Set.Set Pragma -> EHCOpts -> (EHCOpts,Bool)
ehcOptUpdateWithPragmas pragmas opts
  = foldr (\p om@(o,modf) -> maybe om (\o -> (o,True)) $ upd p o) (opts,False) (Set.toList pragmas)
  where upd pragma opts
          = case pragma of
              Pragma_NoGenericDeriving      -> Just $ opts { ehcOptGenGenerics          = False }
              Pragma_GenericDeriving        -> Just $ opts { ehcOptGenGenerics          = True  }
              Pragma_NoBangPatterns         -> Just $ opts { ehcOptBangPatterns         = False }
              Pragma_BangPatterns           -> Just $ opts { ehcOptBangPatterns         = True  }
              Pragma_NoOverloadedStrings    -> Just $ opts { ehcOptOverloadedStrings    = False }
              Pragma_OverloadedStrings      -> Just $ opts { ehcOptOverloadedStrings    = True  }
              Pragma_NoPolyKinds            -> Just $ opts { ehcOptPolyKinds            = False }
              Pragma_PolyKinds              -> Just $ opts { ehcOptPolyKinds            = True  }
              Pragma_ExtensibleRecords      -> Just $ opts { ehcOptExtensibleRecords    = True  }
              Pragma_Fusion                 -> Just $ opts { ehcOptFusion               = True  }
              Pragma_OptionsUHC o           -> fmap (\o -> o {ehcOptCmdLineOptsDoneViaPragma = True}) mo
                                            where (mo,_,_) = ehcCmdLineOptsApply [] (words o) opts
              _                             -> Nothing







mkStringPath :: String -> [String]
mkStringPath = wordsBy (`elem` ";,")

mkFileLocPath :: String -> FileLocPath
mkFileLocPath = map mkDirFileLoc . mkStringPath







optOpts :: Map.Map String opt -> String -> [opt]
optOpts m s = catMaybes $ map (\os -> Map.lookup os m) $ wordsBy (==',') s

optOptsIsYes :: Eq opt => Maybe [opt] -> opt -> Bool
optOptsIsYes mos o = maybe False (o `elem`) mos




instance Show CoreOpt where
  -- show CoreOpt_PPParseable      = "pp-parseable"
  show CoreOpt_Dump                 = "dump"
  show CoreOpt_DumpBinary           = "dump-binary"
  show CoreOpt_DumpAlsoNonParseable = "whendump-alsononparseable"
  show CoreOpt_Run                  = "run"
  show CoreOpt_RunDump              = "dump-run"
  show CoreOpt_RunTrace             = "run-trace"
  show CoreOpt_RunTraceExtensive    = "run-trace-extensive"
  show CoreOpt_RunPPNames           = "run-ppnames"
  show CoreOpt_RunPPVerbose         = "run-ppverbose"
  show _                            = "-"

coreOptMp :: Map.Map String CoreOpt
coreOptMp = str2stMpWithOmit [CoreOpt_NONE]
















































instance Show PgmExec where
  show PgmExec_CPP      = "P"
  show PgmExec_C        = "c"
  show PgmExec_Linker   = "l"

pgmExecMp :: Map.Map String PgmExec
pgmExecMp = str2stMp









-- do something with whole program
ehcOptWholeProgOptimizationScope :: EHCOpts -> Bool
ehcOptWholeProgOptimizationScope opts
  = ehcOptOptimizationScope opts > OptimizationScope_PerModule



-- compatibility option
ehcOptEarlyModMerge :: EHCOpts -> Bool
ehcOptEarlyModMerge opts
  = ehcOptOptimizationScope opts >= OptimizationScope_WholeCore



-- do whole program analysis, with HPT
ehcOptWholeProgHPTAnalysis :: EHCOpts -> Bool
ehcOptWholeProgHPTAnalysis opts
  = False






























































-- | optimizes a particular option
ehcOptOptimizes :: Optimize -> EHCOpts -> Bool
ehcOptOptimizes o opts = o `Set.member` ehcOptOptimizations opts







-- | The default EHC options.
defaultEHCOpts
  = emptyEHCOpts
      { ehcOptExecOptsMp = ehcOptExecOptsMp emptyEHCOpts `Map.union` Map.fromList
          [ (Cfg.shellCmdCpp, [ExecOpt_Plain "traditional-cpp", ExecOpt_Plain "std=gnu99", ExecOpt_Plain "fno-show-column", ExecOpt_Plain "P"])
          ]
      }









-- | Commandline opts for ehc/uhc (EHC)
ehcCmdLineOpts :: GetOptCmdLineOpts
ehcCmdLineOpts = sharedCmdLineOpts ++
     [
        Option "t"  ["target"]              (ReqArg oTarget (showSupportedTargets'  "|"))
                                                                                    ("generate code for target, default=" ++ show defaultTarget)
     ,  Option ""   ["target-flavor"]       (ReqArg oTargetFlavor (showAllTargetFlavors' "|"))
                                                                                    ("generate code for target flavor, default=" ++ show defaultTargetFlavor)
     ,  Option "p"  ["pretty"]              (OptArg oPretty "hs|eh|ast|-")          "show pretty printed source or EH abstract syntax tree, default=eh, -=off, (downstream only)"


     ,  Option "O"  ["optimise"]            (OptArg oOptimization ("0|1|2|3|<opt>[=" ++ boolArgStr ++ "]"))
                                                                                    ("optimise with level or specific <opt> by optim name: "
                                                                                     ++ showStr2stMp allOptimizeMp
                                                                                     ++ ", or by scope name: "
                                                                                     ++ showStr2stMp allOptimScopeMp
                                                                                     ++ ", default=1")
     ,  Option ""   ["gen-trampoline"]      (boolArg oSetGenTrampoline)             "codegen: use trampoline mechanism (development/internal use only)"
     ,  Option ""   ["no-recomp"]           (NoArg oNoRecomp)                       "turn off recompilation check (force recompile)"
     ,  Option ""   ["no-prelude"]          (NoArg oNoPrelude)                      "do not assume presence of Prelude"
     ,  Option ""   ["no-hi-check"]         (NoArg oNoHiCheck)                      "no check on .hi files not matching the compiler version"
     ,  Option "c"  ["compile-only"]        (NoArg oCompileOnly)                    "compile only, do not link"
     ,  Option "i"  ["import-path"]         (ReqArg oUsrFileLocPath "path")         "search path for user files, separators=';', appended to previous"
     ,  Option "L"  ["lib-search-path"]     (ReqArg oLibFileLocPath "path")         "search path for library files, see also --import-path"
     ,  Option ""   ["cpp"]                 (NoArg oCPP)                            "preprocess source with CPP"
     ,  Option ""   ["limit-tysyn-expand"]  (intArg oLimitTyBetaRed)                "type synonym expansion limit"
     ,  Option ""   ["odir"]                (ReqArg oOutputDir "dir")               "base directory for generated files"
     ,  Option "o"  ["output"]              (ReqArg oOutputFile "file")             "file to generate executable to (implies --compile-only off)"
     ,  Option ""   ["keep-intermediate-files"] (NoArg oKeepIntermediateFiles)      "keep intermediate files (default=off)"
     ,  Option ""   ["meta-variant"]        (NoArg oVariant)                        "meta: print variant (then stop)"
     ,  Option ""   ["meta-target-default"] (NoArg oTargetDflt)                     "meta: print the default codegeneration target (then stop)"
     ,  Option ""   ["meta-targets"]        (NoArg oTargets)                        "meta: print supported codegeneration targets (then stop)"
     ,  Option ""   ["meta-optimizations"]  (NoArg oOptimizations)                  "meta: print optimization names (then stop)"
     ,  Option ""   ["meta-pkgdir-system"]  (NoArg oMetaPkgdirSys)                  "meta: print system package dir (then stop)"
     ,  Option ""   ["meta-pkgdir-user"]    (NoArg oMetaPkgdirUser)                 "meta: print user package dir (then stop)"
     ,  Option ""   ["package"]             (ReqArg oExposePackage "package")       "see --pkg-expose"
     ,  Option ""   ["hide-all-packages"]   (NoArg oHideAllPackages)                "see --pkg-hide-all"
     ,  Option ""   ["pkg-expose"]          (ReqArg oExposePackage "package")       "pkg: expose/use package"
     ,  Option ""   ["pkg-hide"]            (ReqArg oHidePackage   "package")       "pkg: hide package"
     ,  Option ""   ["pkg-hide-all"]        (NoArg oHideAllPackages)                "pkg: hide all (implicitly) assumed/used packages"
     ,  Option ""   ["pkg-searchpath"]      (ReqArg oPkgdirLocPath "path")          "pkg: package search directories, each dir has <pkg>/<variant>/<target>/<flavor>"
     ,  Option ""   ["pkg-build"]           (ReqArg oPkgBuild "package")            "pkg build: build package from files. Implies --compile-only"
     ,  Option ""   ["pkg-build-exposed"]   (ReqArg oPkgBuildExposedModules "modules")
                                                                                    "pkg build: for package building, exposed modules (blank separated)"
     ,  Option ""   ["pkg-build-depends"]   (ReqArg oPkgBuildBuildDepends "packages")
                                                                                    "pkg build: for package building, depended on packages (blank separated)"
     ,  Option ""   ["cfg-install-root"]    (ReqArg oCfgInstallRoot "dir")          "cfg: installation root (to be used only by wrapper script)"
     ,  Option ""   ["cfg-install-variant"] (ReqArg oCfgInstallVariant "variant")   "cfg: installation variant (to be used only by wrapper script)"
     ,  Option ""   ["optP"]                (ReqArg (oCmdLineOpts Cmd_CPP_Preprocessing) "opt for cmd")
                                                                                    "opt: option for cmd used by compiler, currently only P (preprocessing)"
     ,  Option ""   ["pgmP"]                (ReqArg (oPgmExec PgmExec_CPP)          "alternate program for cmd")
                                                                                    "pgm: alternate executable used by compiler, currently only P (preprocessing)"
     ,  Option ""   ["coreopt"]             (ReqArg oOptCore "opt[,...]")           ("opts (specific) for core: " ++ showStr2stMp coreOptMp)
     ]














































































































  where  oPretty     ms  o =  case ms of
                                Just "-"     -> o { ehcOptShowEH       = False     }
                                Just "no"    -> o { ehcOptShowEH       = False     }
                                Just "off"   -> o { ehcOptShowEH       = False     }
                                Just "hs"    -> o { ehcOptShowHS       = True      }
                                Just "eh"    -> o { ehcOptShowEH       = True      }
                                Just "pp"    -> o { ehcOptShowEH       = True      }
                                _            -> o
         oShowTopTy  ms  o =  case ms of
                                Just "yes"  -> o { ehcOptShowTopTyPP   = True      }
                                _           -> o
         oVariant        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_Variant }
         oDebug          o =  o { ehcOptDebug         = True
                                }
         oStopAt       s o =  o { ehcStopAtPoint       =
                                    case s of
                                      "0" -> CompilePoint_Imports
                                      "1" -> CompilePoint_Parse
                                      "2" -> CompilePoint_AnalHS
                                      "3" -> CompilePoint_AnalEH
                                      "4" -> CompilePoint_Core
                                      _   -> CompilePoint_All
                                }
         oOptCore    s   o =  o { ehcOptCoreOpts = optOpts coreOptMp s ++ ehcOptCoreOpts o}
         oTarget        s o =  o { ehcOptMbTarget          = mbtarget
                                 , ehcOptOptimizationScope = if isJustOk mbtarget && targetDoesHPTAnalysis (fromJustOk mbtarget)
                                                             then max oscope (maxBound :: OptimizationScope)
                                                             else oscope
                                 }
                            where mbtarget = maybe (NotOk s) JustOk $ Map.lookup s supportedTargetMp
                                  oscope = ehcOptOptimizationScope o
         oTargetFlavor  s o =  o { ehcOptMbTargetFlavor  = maybe (NotOk s) JustOk $ Map.lookup s allTargetFlavorMp }
         oOptimizations   o =  o { ehcOptImmQuit         = Just ImmediateQuitOption_Meta_Optimizations       }
         oTargets        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_Targets       }
         oTargetDflt     o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Meta_TargetDefault  }

         oCode       ms  o =  case ms of
                                Just "hs"    -> o { ehcOptEmitHS           = True   }
                                Just "eh"    -> o { ehcOptEmitEH           = True   }
                                Just "-"     -> o -- { ehcOptEmitCore         = False  }
                                Just "core"  -> o { ehcOptMbTarget         = JustOk Target_None_Core_AsIs
                                                  }
                                Just "tycore"-> o { ehcOptMbTarget         = JustOk Target_None_TyCore_None
                                                  }
                                _            -> o

         oOptimization ms o
                           = o' {ehcOptOptimizations = optimizeRequiresClosure os}
                           where (o',doSetOpts)
                                    = case ms of
                                        Just (clevel:',':cscope:_)
                                          | isJust mbO -> (fromJust mbO o, True)
                                          where mbO = mbLevelScope (Just clevel) (Just cscope)
                                        Just (',':cscope:_)
                                          | isJust mbO -> (fromJust mbO o, True)
                                          where mbO = mbLevelScope Nothing (Just cscope)
                                        Just olevel@(clevel:_)
                                          | isDigit clevel && l >= 0 && l < (maxscp * maxlev)
                                            -> ( o { ehcOptOptimizationLevel = toEnum lev, ehcOptOptimizationScope = toEnum sc }
                                               , True
                                               )
                                          where l = read olevel :: Int
                                                (sc,lev) = quotRem l maxlev
                                        Just scpname@(_:_)
                                          | isJust mbScp
                                            -> ( o { ehcOptOptimizationScope = sc }
                                               , True
                                               )
                                          where mbScp@(~(Just sc)) = Map.lookup scpname allOptimScopeMp
                                        Just optname@(_:_)
                                          -> case break (== '=') optname of
                                               (nm, yesno)
                                                 -> ( o { ehcOptOptimizations = os
                                                        , ehcOptOptimizeOptionMp = osmp `Map.union` ehcOptOptimizeOptionMp o
                                                        }
                                                    , False
                                                    )
                                                 where set True  opt = Set.insert opt $ ehcOptOptimizations o
                                                       set False opt = Set.delete opt $ ehcOptOptimizations o
                                                       (os,osmp)
                                                          = -- lookup name, and attempt to extract boolean of assumedly '=' prefixed string, or if not a boolean try to extract specific config whilst also assuming True for the boolean
                                                            case (Map.lookup nm allOptimizeMp, optArgTake optArgAllAllow $ drop 1 yesno) of
                                                              (Just opt, Just (OptArg_Bool b,_ ))   -> (set b     opt           , Map.empty)
                                                              (Just opt, Just (OptArg_Int  i,_ ))   -> (set True  opt           , optimizeOptionMpSingleton opt optopt v)
                                                                                                    where (optopt,optdflt) = allOptimizeOptionMpAnyOption opt
                                                                                                          v = maybe optdflt (\(_,(lo,_)) -> toEnum $ fromEnum lo + i)
                                                                                                              $ mapLookup2 opt optopt allOptimizeOptionMp
                                                              (Just opt, _                      )   -> (set True  opt           , Map.empty)
                                                              _                                     -> (ehcOptOptimizations o   , Map.empty)
                                        Nothing
                                          -> (o { ehcOptOptimizationLevel      = OptimizationLevel_Much       }, True)
                                        _ -> (o, False)
                                 os | doSetOpts = Map.findWithDefault Set.empty (ehcOptOptimizationLevel o') optimizationLevelMp
                                    | otherwise = ehcOptOptimizations o'
                                 maxlev = fromEnum (maxBound :: OptimizationLevel) + 1
                                 maxscp = fromEnum (maxBound :: OptimizationScope) + 1
                                 mbLevelScope ml ms
                                   | isJust l && isJust s = Just (\o -> o { ehcOptOptimizationLevel = toEnum (fromJust l), ehcOptOptimizationScope = toEnum (fromJust s) })
                                   | otherwise            = Nothing
                                   where l = r ehcOptOptimizationLevel maxlev ml
                                         s = r ehcOptOptimizationScope maxscp ms
                                         r dflt mx m
                                           | x >= 0 && x < mx = Just x
                                           | otherwise        = Nothing
                                           where x = (maybe (fromEnum $ dflt o) (\c -> read [c]) m) :: Int
         oNoRecomp              o   = o { ehcOptCheckRecompile              = False    }
         oCompileOnly           o   = o { ehcOptLinkingStyle                = LinkingStyle_None }
         oNoHiCheck             o   = o { ehcOptHiValidityCheck             = False    }
         oUsrFileLocPath      s o   = o { ehcOptImportFileLocPath           = ehcOptImportFileLocPath o ++ mkFileLocPath s }
         oLibFileLocPath      s o   = o { ehcOptLibFileLocPath              = ehcOptLibFileLocPath o ++ mkFileLocPath s }
         oPkgdirLocPath       s o   = o { ehcOptPkgdirLocPath               = ehcOptPkgdirLocPath o ++ mkStringPath s }
         oNoPrelude             o   = o { ehcOptUseAssumePrelude            = False   }
         oCPP                   o   = o { ehcOptCPP                         = True    }
         oLimitTyBetaRed        o l = o { ehcOptTyBetaRedCutOffAt           = l }
         oLimitCtxtRed          o l = o { ehcOptPrfCutOffAt                 = l }
         oMetaPkgdirSys         o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_Meta_Pkgdir_System }
         oMetaPkgdirUser        o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_Meta_Pkgdir_User }
         oExposePackage       s o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ pkgSearchFilter parsePkgKey PackageSearchFilter_ExposePkg [s]
                                        -- , ehcOptLibPackages                 = ehcOptLibPackages   o ++ [s]
                                        }
         oHidePackage         s o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ pkgSearchFilter parsePkgKey PackageSearchFilter_HidePkg [s]
                                        }
         oHideAllPackages       o   = o { ehcOptPackageSearchFilter         = ehcOptPackageSearchFilter o ++ [PackageSearchFilter_HideAll]
                                        -- , ehcOptHideAllPackages             = True
                                        }
         oOutputDir           s o   = o { ehcOptOutputDir                   = Just s
                                          -- no linking when no output file is generated. This is not failsafe, requires better solution as now no executable is generated when no --output is specified. Should depend on existence of main.
                                        -- , ehcOptDoExecLinking                   = isJust (ehcOptMbOutputFile o)
                                        }
         oOutputFile          s o   = o { ehcOptMbOutputFile                = Just (mkFPath s)
                                        , ehcOptLinkingStyle                = LinkingStyle_Exec
                                        }
         oKeepIntermediateFiles o   = o { ehcOptKeepIntermediateFiles       = True }
         oPkgBuild            s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptName=s})
                                        , ehcOptLinkingStyle                = LinkingStyle_Pkg
                                        }
         oPkgBuildExposedModules
                              s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptExposedModules = words s})
                                        }
         oPkgBuildBuildDepends
                              s o   = o { ehcOptPkgOpt                      = Just ((maybe emptyPkgOption id $ ehcOptPkgOpt o) {pkgoptBuildDepends = words s})
                                        }
         oCfgInstallRoot      s o   = o { ehcOptCfgInstallRoot              = Just s }
         oCfgInstallVariant   s o   = o { ehcOptCfgInstallVariant           = Just s }
         oCmdLineOpts cmd     s o   = o { ehcOptCmdLineOpts                 = -- (\v -> tr "XX" (pp s >#< show v) v) $
                                                                              nub $ ehcOptCmdLineOpts o ++ fst (parseCmdLineOpts cmd s) }
         oPgmExec     cmd     s o   = o { ehcOptPgmExecMp                   = Map.insert cmd s $ ehcOptPgmExecMp o }














































































































































-- | Commandline opts for ehcr/uhcr (EHCRun)
ehcrunCmdLineOpts :: GetOptCmdLineOpts
ehcrunCmdLineOpts
     =  sharedCmdLineOpts
     ++ [  Option ""   ["trace"]               (boolArg optTrace)                      "corerun: trace execution"
        ]
  where
        optTrace o b = o { ehcOptCoreOpts = upd $ ehcOptCoreOpts o }
          where upd | b         = (CoreOpt_RunTrace :)
                    | otherwise = (\\ [CoreOpt_RunTrace])











-- | The description for GetOpt
type GetOptCmdLineOpts = [OptDescr (EHCOpts -> EHCOpts)]

-- | Commandline opts shared between main invocations
sharedCmdLineOpts :: GetOptCmdLineOpts
sharedCmdLineOpts
  =  [  Option "h"  ["help"]                (NoArg oHelp)                           "print this help (then stop)"
     ,  Option ""   ["version"]             (NoArg oVersion)                        "print version info (then stop)"
     ,  Option ""   ["version-dotted"]      (NoArg oNumVersion)                     ("print version in \"x.y.z\" style (then stop)")
     ,  Option ""   ["version-asnumber"]    (NoArg oVersionAsNumber)                ("print version in \"xyz\" style (then stop)")
     ,  Option ""   ["numeric-version"]     (NoArg oNumVersion)                     "see --version-dotted (to become obsolete)"
     ,  Option "v"  ["verbose"]             (OptArg oVerbose "0|1|2|3|4")           (   "be verbose, 0=quiet, 4=debug, "
                                                                                    ++ "default=1"
                                                                                    )
     ]















-- | Help
oHelp           o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Help    }

-- | Version
oVersion        o =  o { ehcOptImmQuit       = Just ImmediateQuitOption_Version }

-- | Verbosity
oVerbose    ms  o =  case ms of
                       Just "0"    -> o { ehcOptVerbosity     = VerboseQuiet       }
                       Just "1"    -> o { ehcOptVerbosity     = VerboseMinimal     }
                       Just "2"    -> o { ehcOptVerbosity     = VerboseNormal      }
                       Just "3"    -> o { ehcOptVerbosity     = VerboseALot        }
                       Just "4"    -> o { ehcOptVerbosity     = VerboseDebug       }
                       Nothing     -> o { ehcOptVerbosity     = succ (ehcOptVerbosity o)}
                       _           -> o



oNumVersion            o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_VersionDotted }
oVersionAsNumber       o   = o { ehcOptImmQuit                     = Just ImmediateQuitOption_VersionAsNumber }







-- | Int option
intArg  tr = ReqArg (optInt tr) "<nr>"

-- | EHCOpts updater for Int option
optInt :: (EHCOpts -> Int -> EHCOpts) -> String -> EHCOpts -> EHCOpts
optInt tr s o
 = tr o $ read s



-- | What kind of optional args are allowed
data OptArgAllow
  = OptArgAllow_Bool
  | OptArgAllow_Int
  deriving (Eq,Enum,Bounded)

optArgAllAllow :: [OptArgAllow]
optArgAllAllow = [minBound .. maxBound]



-- | An optional arg, universal type for all occurring variants
data OptArg
  = OptArg_Bool     Bool
  | OptArg_Int      Int



optArgTake :: [OptArgAllow] -> String -> Maybe (OptArg,String)
optArgTake allow s
  = case s of
      ('-':r)           -> Just (OptArg_Bool False,r)
      ('n':'o':r)       -> Just (OptArg_Bool False,r)
      ('n':r)           -> Just (OptArg_Bool False,r)
      ('o':'f':'f':r)   -> Just (OptArg_Bool False,r)
      ('0':r) | noInt   -> Just (OptArg_Bool False,r)
      ('+':r)           -> Just (OptArg_Bool True ,r)
      ('y':'e':'s':r)   -> Just (OptArg_Bool True ,r)
      ('y':r)           -> Just (OptArg_Bool True ,r)
      ('o':'n':r)       -> Just (OptArg_Bool True ,r)
      ('1':r) | noInt   -> Just (OptArg_Bool True ,r)
      ( c :_) | yesInt && isDigit c
                        -> Just (OptArg_Int (read d) ,r)
                        where (d,r) = span isDigit s
      _                 -> Nothing
  where yesInt = OptArgAllow_Int `elem` allow
        noInt  = not yesInt



optBooleanTake :: String -> Maybe (Bool,String)
optBooleanTake s
  = case optArgTake [OptArgAllow_Bool] s of
      Just (OptArg_Bool b, r)   -> Just (b,r)
      _                         -> Nothing

optBoolean :: (EHCOpts -> Bool -> EHCOpts) -> Maybe String -> EHCOpts -> EHCOpts
optBoolean tr ms o
 = case ms of
     Just s -> maybe o (tr o . fst) (optBooleanTake s)
     _      -> o

boolArgStr = "Bool"
boolArg tr = OptArg (optBoolean tr) boolArgStr







oPriv                o b = o { ehcOptPriv           = b }



optDumpCoreStages    o b = o { ehcOptDumpCoreStages = b }







oSetGenTrampoline    o b = o { ehcOptGenTrampoline_ = b }



















oStopAtCoreError     o b = o { ehcDebugStopAtCoreError     = b }



oStopAtHIError       o b = o { ehcDebugStopAtHIError       = b }







-- | Apply the cmdline opts description to a EHCOpts, returning Nothing when there were no options
cmdlineOptsApply :: [OptDescr (EHCOpts -> EHCOpts)] -> [EHCOpts -> EHCOpts] -> [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
cmdlineOptsApply cmdlopts postopts args opts
  = (if null o' then Nothing else Just (foldl (flip ($)) opts o'),n,errs)
  where oo@(o,n,errs)  = getOpt Permute cmdlopts args
        o' = o ++ postopts

-- | Apply the cmdline opts description for 'EHC' to a EHCOpts, returning Nothing when there were no options
ehcCmdLineOptsApply :: [EHCOpts -> EHCOpts] -> [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
ehcCmdLineOptsApply = cmdlineOptsApply ehcCmdLineOpts

-- | Apply the cmdline opts description for 'EHCRun' to a EHCOpts, returning Nothing when there were no options
ehcrunCmdLineOptsApply :: [String] -> EHCOpts -> (Maybe EHCOpts, [String], [String])
ehcrunCmdLineOptsApply = cmdlineOptsApply ehcrunCmdLineOpts []







optsDiscrRecompileRepr :: EHCOpts -> String
optsDiscrRecompileRepr opts
  = concat
    $ intersperse " "
    $ [ show (ehcOptAspects opts)
      , o "clsrec"          (ehcCfgClassViaRec      opts)
      -- , o "exec"            (ehcOptEmitExecC        opts)
      -- , o "bexec"           (ehcOptEmitExecBytecode opts)
      , show (ehcOptTarget opts)
      , show (ehcOptOptimizationLevel opts)
      ]
  where o m v = if v then m else ""









data FIOBind
  = FIOBindYes | FIOBindNoBut TyVarIdS
  deriving (Show)



data FIOpts =  FIOpts   {  fioLeaveRInst     ::  !Bool                ,  fioBindRFirst           ::  !Bool
                        ,  fioBindLFirst     ::  !Bool                ,  fioBindLBeforeR         ::  !Bool
                        ,  fioMode           ::  !FIMode              ,  fioUniq                 ::  !UID
                        ,  fioBindCategs     ::  ![TyVarCateg]
                        ,  fioNoRLabElimFor  ::  ![HsName]            ,  fioNoLLabElimFor        ::  ![HsName]
                        ,  fioDontBind       ::  !TyVarIdS
                        ,  fioExpandEqTyVar  ::  !Bool                -- expand tyvars also when equal. Required for Sys F translation.
                        ,  fioPredAsTy       ::  !Bool                ,  fioAllowRPredElim       ::  !Bool
                        ,  fioBindLVars      ::  !FIOBind             ,  fioBindRVars            ::  !FIOBind
                        ,  fiMbMkErrClash    ::  Maybe (Ty -> Ty -> Err) -- alternate error construction for type clash
                        }























fioBindNoSet :: FIOBind -> TyVarIdS
fioBindNoSet (FIOBindNoBut s) = s
fioBindNoSet _                = Set.empty

fioBindIsYes :: FIOBind -> Bool
fioBindIsYes FIOBindYes = True
fioBindIsYes _          = False



strongFIOpts :: FIOpts
strongFIOpts =  FIOpts  {  fioLeaveRInst     =   False               ,  fioBindRFirst           =   True
                        ,  fioBindLFirst     =   True                ,  fioBindLBeforeR         =   True
                        ,  fioMode           =   FitSubLR            ,  fioUniq                 =   uidStart
                        ,  fioBindCategs     =   [TyVarCateg_Plain]
                        ,  fioNoRLabElimFor  =   []                  ,  fioNoLLabElimFor        =   []
                        ,  fioDontBind       =   Set.empty
                        ,  fioExpandEqTyVar  =   False
                        ,  fioPredAsTy       =   False               ,  fioAllowRPredElim       =   True
                        ,  fioBindLVars      =   FIOBindYes          ,  fioBindRVars            =   FIOBindYes
                        ,  fiMbMkErrClash    =   Nothing
                        }


















instance Show FIOpts where
  show o =  "FIOpts"



instance PP FIOpts where
  pp   o =  "FIOpts{"
            >#< "leaveRInst=" >|< pp (fioLeaveRInst o)
            >#< "bindLFirst=" >|< pp (fioBindLFirst o)
            >#< "bindRFirst=" >|< pp (fioBindRFirst o)
            >#< "fioNoLLabElimFor=" >|< pp (show $ fioNoLLabElimFor o)
            >#< "fioNoRLabElimFor=" >|< pp (show $ fioNoRLabElimFor o)
            >#< "allowRPredElim=" >|< pp (fioAllowRPredElim o)
            >#< "}"







instLFIOpts :: FIOpts
instLFIOpts = strongFIOpts {fioBindRFirst = False}



instLRFIOpts :: FIOpts
instLRFIOpts = strongFIOpts {fioBindRFirst = False, fioBindLFirst = False}



unifyFIOpts :: FIOpts
unifyFIOpts = strongFIOpts {fioMode = FitUnify}

instFIOpts :: FIOpts
instFIOpts = instLFIOpts {fioLeaveRInst = True, fioBindLFirst = False}














weakFIOpts :: FIOpts
weakFIOpts = fioMkWeak strongFIOpts



predFIOpts :: FIOpts
predFIOpts = strongFIOpts {fioPredAsTy = True, fioLeaveRInst = True}

implFIOpts  :: FIOpts
implFIOpts = strongFIOpts {fioAllowRPredElim = False}



fioSwapOpts :: FIOpts -> FIOpts
fioSwapOpts fio
  = fio
      { fioBindRFirst   = fioBindLFirst fio
      , fioBindLFirst   = fioBindRFirst fio
      , fioBindLBeforeR = not (fioBindLBeforeR fio)
      , fioBindLVars    = fioBindRVars fio
      , fioBindRVars    = fioBindLVars fio
      }

fioSwapPolarity :: Polarity -> FIOpts -> FIOpts
fioSwapPolarity pol fio = fio {fioMode = fimSwapPol pol (fioMode fio)}





fioMkStrong :: FIOpts -> FIOpts
fioMkStrong fi = fi {fioLeaveRInst = False, fioBindRFirst = True, fioBindLFirst = True}



fioMkWeak :: FIOpts -> FIOpts
fioMkWeak fi = fi {fioLeaveRInst = True, fioBindRFirst = False}



-- | Adapt options for extracting final ty
fioMkFinal :: FIOpts -> FIOpts
fioMkFinal fi = fi {fioBindLFirst = False, fioBindRFirst = False, fioExpandEqTyVar = True}



fioMkUnify :: FIOpts -> FIOpts
fioMkUnify fi = fi {fioMode = FitUnify}







fioIsSubsume :: FIOpts -> Bool
fioIsSubsume fio =  case fioMode fio of {FitSubLR -> True ; _ -> False}


</pre>