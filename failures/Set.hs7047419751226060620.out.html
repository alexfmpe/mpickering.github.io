<a href="Set.hs18657213551770083638.out.html">prev</a></br><a href="failures.html">home</a></br><a href="SetupNoTH.hs1295247375180901986.out.html">next</a></br></br><pre>14d13
<     Empty :: Set '[]
15c14
<     Ext :: e -> Set s -> Set (e ': s)
---
>     Empty :: Set 
15a15
>     Ext :: e -> Set s -> Set (e  : s)
24d23
< type SetProperties f = (Union f '[] ~ f, Split f '[] f,
25c24
<                         Union '[] f ~ f, Split '[] f f,
---
> type SetProperties f = (Union f     ~ f, Split f     f,
25a25
>                         Union     f ~ f, Split     f f,
27c27
<                         Unionable f '[], Unionable '[] f)
---
>                         Unionable f    , Unionable     f)
41d40
<             Append '[] t = t
42c41
<             Append (x ': xs) ys = x ': (Append xs ys)
---
>             Append     t = t
42a42
>             Append (x  : xs) ys = x  : (Append xs ys)
51d50
<     Nub '[]           = '[]
52d50
<     Nub '[e]          = '[e]
53d50
<     Nub (e ': e ': s) = Nub (e ': s)
54c51
<     Nub (e ': f ': s) = e ': Nub (f ': s)
---
>     Nub               = 
54a52
>     Nub  '[e]          =  '[e]
54a53
>     Nub (e  : e  : s) = Nub (e  : s)
54a54
>     Nub (e  : f  : s) = e  : Nub (f  : s)
59c59
< instance Nubable '[] where
---
> instance Nubable     where
62c62
< instance Nubable '[e] where
---
> instance Nubable  '[e] where
68d67
< instance (Nub (e ': f ': s) ~ (e ': Nub (f ': s)),
69c68
<               Nubable (f ': s)) => Nubable (e ': f ': s) where
---
> instance (Nub (e  : f  : s) ~ (e  : Nub (f  : s)),
69a69
>               Nubable (f  : s)) => Nubable (e  : f  : s) where
82d81
<             Bubble l '[] = l
83c82
<             Bubble l (x ': xs) = Pass (Bubble l xs)
---
>             Bubble l     = l
83a83
>             Bubble l (x  : xs) = Pass (Bubble l xs)
88c88
< instance Bubbler s '[] where
---
> instance Bubbler s     where
91c91
< instance (Bubbler s t, Passer (Bubble s t)) => Bubbler s (e ': t) where
---
> instance (Bubbler s t, Passer (Bubble s t)) => Bubbler s (e  : t) where
96d95
<     Pass '[]           = '[]
97d95
<     Pass '[e]          = '[e]
98c96
<     Pass (e ': f ': s) = Min e f ': (Pass ((Max e f) ': s))
---
>     Pass               = 
98a97
>     Pass  '[e]          =  '[e]
98a98
>     Pass (e  : f  : s) = Min e f  : (Pass ((Max e f)  : s))
103c103
< instance Passer '[] where
---
> instance Passer     where
106c106
< instance Passer '[e] where
---
> instance Passer  '[e] where
109c109
< instance (Passer ((Max e f) ': s), OrdH e f) => Passer (e ': f ': s) where
---
> instance (Passer ((Max e f)  : s), OrdH e f) => Passer (e  : f  : s) where
121c121
< instance Show (Set '[]) where
---
> instance Show (Set    ) where
123c123
< instance (Show e, Show' (Set s)) => Show (Set (e ': s)) where
---
> instance (Show e, Show' (Set s)) => Show (Set (e  : s)) where
128c128
< instance Show' (Set '[]) where
---
> instance Show' (Set    ) where
130c130
< instance (Show' (Set s), Show e) => Show' (Set (e ': s)) where
---
> instance (Show' (Set s), Show e) => Show' (Set (e  : s)) where
137c137
< instance Split '[] '[] '[] where
---
> instance Split             where
140c140
< instance Split s t st => Split (x ': s) (x ': t) (x ': st) where
---
> instance Split s t st => Split (x  : s) (x  : t) (x  : st) where
144c144
< instance Split s t st => Split (x ': s) t (x ': st) where
---
> instance Split s t st => Split (x  : s) t (x  : st) where
148c148
< instance Split s t st => Split s (x ': t) (x ': st) where
---
> instance Split s t st => Split s (x  : t) (x  : st) where
156c156
< instance Subset '[] t where
---
> instance Subset     t where
159c159
< instance Subset s t => Subset (x ': s) (x ': t) where
---
> instance Subset s t => Subset (x  : s) (x  : t) where
162c162
< instance Subset s t => Subset s (x ': t) where
---
> instance Subset s t => Subset s (x  : t) where
163a164
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE GADTs, DataKinds, KindSignatures, TypeOperators, TypeFamilies,
             MultiParamTypeClasses, FlexibleInstances, PolyKinds, FlexibleContexts,
             UndecidableInstances, IncoherentInstances, ConstraintKinds #-}

module Control.Effect.Helpers.Set (Set(..), Union, Unionable, union, bsort, append, Sort, Sortable,
                                    OrdH(..), Min, Max, Append(..), Split(..),
                                    Nub, Nubable(..),
                                    AsSet, asSet, IsSet,
                                    Subset(..)) where

{- Core Set definition, in terms of lists -}

data Set (n :: [*]) where
    Empty :: Set '[]
    Ext :: e -> Set s -> Set (e ': s)

asSet :: (Sortable s, Nubable (Sort s)) => Set s -> Set (AsSet s)
asSet x = nub (bsort x)

type AsSet s = Nub (Sort s)

type IsSet s = (s ~ Nub (Sort s))

type SetProperties f = (Union f '[] ~ f, Split f '[] f,
                        Union '[] f ~ f, Split '[] f f,
                        Union f f ~ f, Split f f f,
                        Unionable f '[], Unionable '[] f)

{-- Union --}
type Union s t = Nub (Sort (Append s t))

union :: (Unionable s t) => Set s -> Set t -> Set (Union s t)
union s t = nub (bsort (append s t))

type Unionable s t = (Sortable (Append s t), Nubable (Sort (Append s t)))
type Sortable s = Bubbler s s

{- List append (essentially set disjoint union) -}

type family Append s t where
            Append '[] t = t
            Append (x ': xs) ys = x ': (Append xs ys)

append :: Set s -> Set t -> Set (Append s t)
append Empty x = x
append (Ext e xs) ys = Ext e (append xs ys)

{- Remove duplicates-}

type family Nub t where
    Nub '[]           = '[]
    Nub '[e]          = '[e]
    Nub (e ': e ': s) = Nub (e ': s)
    Nub (e ': f ': s) = e ': Nub (f ': s)

class Nubable t where
    nub :: Set t -> Set (Nub t)

instance Nubable '[] where
    nub Empty = Empty

instance Nubable '[e] where
    nub (Ext x Empty) = Ext x Empty

-- The case for equal types is not define here, but should be given
-- per-application

instance (Nub (e ': f ': s) ~ (e ': Nub (f ': s)),
              Nubable (f ': s)) => Nubable (e ': f ': s) where
    nub (Ext e (Ext f s)) = Ext e (nub (Ext f s))

{- Sorting for normalising the representation -}

{- Sort top level -}
type Sort l = Bubble l l

bsort :: (Bubbler s s) => Set s -> Set (Sort s)
bsort x = bubble x x

{- Iteration of the buble sort -}
type family Bubble l l' where
            Bubble l '[] = l
            Bubble l (x ': xs) = Pass (Bubble l xs)

class Bubbler s s' where
    bubble :: Set s -> Set s' -> Set (Bubble s s')

instance Bubbler s '[] where
    bubble s Empty = s

instance (Bubbler s t, Passer (Bubble s t)) => Bubbler s (e ': t) where
    bubble s (Ext _ t) = pass (bubble s t)

{- Single-pass of the bubble sort -}
type family Pass l where
    Pass '[]           = '[]
    Pass '[e]          = '[e]
    Pass (e ': f ': s) = Min e f ': (Pass ((Max e f) ': s))

class Passer s where
    pass :: Set s -> Set (Pass s)

instance Passer '[] where
    pass Empty = Empty

instance Passer '[e] where
    pass (Ext e Empty) = Ext e Empty

instance (Passer ((Max e f) ': s), OrdH e f) => Passer (e ': f ': s) where
    pass (Ext e (Ext f s)) = Ext (minH e f) (pass (Ext (maxH e f) s))

{- Ordering for the sort -}
type family Min a b
type family Max a b

class OrdH e f where
    minH :: e -> f -> Min e f
    maxH :: e -> f -> Max e f

{- Showing a Set -}
instance Show (Set '[]) where
    show Empty = "{}"
instance (Show e, Show' (Set s)) => Show (Set (e ': s)) where
    show (Ext e s) = "{" ++ show e ++ (show' s) ++ "}"

class Show' t where
    show' :: t -> String
instance Show' (Set '[]) where
    show' Empty = ""
instance (Show' (Set s), Show e) => Show' (Set (e ': s)) where
    show' (Ext e s) = ", " ++ show e ++ (show' s)

{- Split a set, given the sets we want to split it into -}
class Split s t st where
   split :: Set st -> (Set s, Set t)

instance Split '[] '[] '[] where
   split Empty = (Empty, Empty)

instance Split s t st => Split (x ': s) (x ': t) (x ': st) where
   split (Ext x st) = let (s, t) = split st
                      in (Ext x s, Ext x t)

instance Split s t st => Split (x ': s) t (x ': st) where
   split (Ext x st) = let (s, t) = split st
                      in  (Ext x s, t)

instance Split s t st => Split s (x ': t) (x ': st) where
   split (Ext x st) = let (s, t) = split st
                      in  (s, Ext x t)

{-- Construct a subsetset 's' from a superset 'st' -}
class Subset s t where
   subset :: Set t -> Set s

instance Subset '[] t where
   subset xs = Empty

instance Subset s t => Subset (x ': s) (x ': t) where
   subset (Ext x xs) = Ext x (subset xs)

instance Subset s t => Subset s (x ': t) where
   subset (Ext _ xs) = subset xs
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE GADTs, DataKinds, KindSignatures, TypeOperators, TypeFamilies,
             MultiParamTypeClasses, FlexibleInstances, PolyKinds, FlexibleContexts,
             UndecidableInstances, IncoherentInstances, ConstraintKinds #-}

module Control.Effect.Helpers.Set (Set(..), Union, Unionable, union, bsort, append, Sort, Sortable,
                                    OrdH(..), Min, Max, Append(..), Split(..),
                                    Nub, Nubable(..),
                                    AsSet, asSet, IsSet,
                                    Subset(..)) where

{- Core Set definition, in terms of lists -}

data Set (n :: [*]) where
    Empty :: Set 
    Ext :: e -> Set s -> Set (e  : s)

asSet :: (Sortable s, Nubable (Sort s)) => Set s -> Set (AsSet s)
asSet x = nub (bsort x)

type AsSet s = Nub (Sort s)

type IsSet s = (s ~ Nub (Sort s))

type SetProperties f = (Union f     ~ f, Split f     f,
                        Union     f ~ f, Split     f f,
                        Union f f ~ f, Split f f f,
                        Unionable f    , Unionable     f)

{-- Union --}
type Union s t = Nub (Sort (Append s t))

union :: (Unionable s t) => Set s -> Set t -> Set (Union s t)
union s t = nub (bsort (append s t))

type Unionable s t = (Sortable (Append s t), Nubable (Sort (Append s t)))
type Sortable s = Bubbler s s

{- List append (essentially set disjoint union) -}

type family Append s t where
            Append     t = t
            Append (x  : xs) ys = x  : (Append xs ys)

append :: Set s -> Set t -> Set (Append s t)
append Empty x = x
append (Ext e xs) ys = Ext e (append xs ys)

{- Remove duplicates-}

type family Nub t where
    Nub               = 
    Nub  '[e]          =  '[e]
    Nub (e  : e  : s) = Nub (e  : s)
    Nub (e  : f  : s) = e  : Nub (f  : s)

class Nubable t where
    nub :: Set t -> Set (Nub t)

instance Nubable     where
    nub Empty = Empty

instance Nubable  '[e] where
    nub (Ext x Empty) = Ext x Empty

-- The case for equal types is not define here, but should be given
-- per-application

instance (Nub (e  : f  : s) ~ (e  : Nub (f  : s)),
              Nubable (f  : s)) => Nubable (e  : f  : s) where
    nub (Ext e (Ext f s)) = Ext e (nub (Ext f s))

{- Sorting for normalising the representation -}

{- Sort top level -}
type Sort l = Bubble l l

bsort :: (Bubbler s s) => Set s -> Set (Sort s)
bsort x = bubble x x

{- Iteration of the buble sort -}
type family Bubble l l' where
            Bubble l     = l
            Bubble l (x  : xs) = Pass (Bubble l xs)

class Bubbler s s' where
    bubble :: Set s -> Set s' -> Set (Bubble s s')

instance Bubbler s     where
    bubble s Empty = s

instance (Bubbler s t, Passer (Bubble s t)) => Bubbler s (e  : t) where
    bubble s (Ext _ t) = pass (bubble s t)

{- Single-pass of the bubble sort -}
type family Pass l where
    Pass               = 
    Pass  '[e]          =  '[e]
    Pass (e  : f  : s) = Min e f  : (Pass ((Max e f)  : s))

class Passer s where
    pass :: Set s -> Set (Pass s)

instance Passer     where
    pass Empty = Empty

instance Passer  '[e] where
    pass (Ext e Empty) = Ext e Empty

instance (Passer ((Max e f)  : s), OrdH e f) => Passer (e  : f  : s) where
    pass (Ext e (Ext f s)) = Ext (minH e f) (pass (Ext (maxH e f) s))

{- Ordering for the sort -}
type family Min a b
type family Max a b

class OrdH e f where
    minH :: e -> f -> Min e f
    maxH :: e -> f -> Max e f

{- Showing a Set -}
instance Show (Set    ) where
    show Empty = "{}"
instance (Show e, Show' (Set s)) => Show (Set (e  : s)) where
    show (Ext e s) = "{" ++ show e ++ (show' s) ++ "}"

class Show' t where
    show' :: t -> String
instance Show' (Set    ) where
    show' Empty = ""
instance (Show' (Set s), Show e) => Show' (Set (e  : s)) where
    show' (Ext e s) = ", " ++ show e ++ (show' s)

{- Split a set, given the sets we want to split it into -}
class Split s t st where
   split :: Set st -> (Set s, Set t)

instance Split             where
   split Empty = (Empty, Empty)

instance Split s t st => Split (x  : s) (x  : t) (x  : st) where
   split (Ext x st) = let (s, t) = split st
                      in (Ext x s, Ext x t)

instance Split s t st => Split (x  : s) t (x  : st) where
   split (Ext x st) = let (s, t) = split st
                      in  (Ext x s, t)

instance Split s t st => Split s (x  : t) (x  : st) where
   split (Ext x st) = let (s, t) = split st
                      in  (s, Ext x t)

{-- Construct a subsetset 's' from a superset 'st' -}
class Subset s t where
   subset :: Set t -> Set s

instance Subset     t where
   subset xs = Empty

instance Subset s t => Subset (x  : s) (x  : t) where
   subset (Ext x xs) = Ext x (subset xs)

instance Subset s t => Subset s (x  : t) where
   subset (Ext _ xs) = subset xs

</pre>