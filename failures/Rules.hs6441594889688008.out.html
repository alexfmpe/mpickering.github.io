<a href="Rules.hs543436550290145159.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Run.hs1073185695316824712.out.html">next</a></br></br><pre>46d45
< import "base" Data.Bool           ( Bool, otherwise )
47d45
< import "base" Data.Function       ( ($), id, const, flip, fix )
48d45
< import "base" Data.List           ( foldr )
49d45
< import "base" Data.Ord            ( Ord, (<), (>) )
50c46
< import "base" Prelude             ( Integral, fromIntegral
---
> import  Data.Bool           ( Bool, otherwise )
50a47
> import  Data.Function       ( ($), id, const, flip, fix )
50a48
> import  Data.List           ( foldr )
50a49
> import  Data.Ord            ( Ord, (<), (>) )
50a50
> import  Prelude             ( Integral, fromIntegral
53d52
< import "base-unicode-symbols" Data.Eq.Unicode       ( (≡) )
54d52
< import "base-unicode-symbols" Data.Function.Unicode ( (∘) )
55d52
< import "base-unicode-symbols" Prelude.Unicode       ( (⋅) )
56d52
< import "this"                 Text.Numeral.Exp.Reified ( Side(L, R) )
57d52
< import "this"                 Text.Numeral.Misc     ( intLog )
58d52
< import qualified "this"       Text.Numeral.Exp as E
59c53
< import qualified "fingertree" Data.IntervalMap.FingerTree as FT
---
> import  Data.Eq.Unicode       ( (≡) )
59a54
> import  Data.Function.Unicode ( (∘) )
59a55
> import  Prelude.Unicode       ( (⋅) )
59a56
> import                  Text.Numeral.Exp.Reified ( Side(L, R) )
59a57
> import                  Text.Numeral.Misc     ( intLog )
59a58
> import qualified        Text.Numeral.Exp as E
59a59
> import qualified  Data.IntervalMap.FingerTree as FT
73c73
< type Rule α β = (α → β) → (α → β)
---
> type Rule α β = (α -> β) -> (α -> β)
84d83
< conditional ∷ (α → Bool) -- ^ Predicate on input value (\"if\").
85d83
<             → Rule α β -- ^ Rule to apply when predicate holds (\"then\").
86d83
<             → Rule α β -- ^ Rule to apply when predicate does not hold (\"else\").
87d83
<             → Rule α β
88c84
< conditional p t e = \f n → if p n
---
> conditional :: (α -> Bool) -- ^ Predicate on input value (\"if\").
88a85
>             -> Rule α β -- ^ Rule to apply when predicate holds (\"then\").
88a86
>             -> Rule α β -- ^ Rule to apply when predicate does not hold (\"else\").
88a87
>             -> Rule α β
88a88
> conditional p t e = \f n -> if p n
94d93
< combine ∷ (E.Unknown β)
95d93
<         ⇒ Rule α β
96d93
<         → Rule α β
97d93
<         → Rule α β
98d93
< combine r1 r2 = \f n → case r1 f n of
99d93
<                          x | E.isUnknown x → r2 f n
100c94
<                            | otherwise     → x
---
> combine :: (E.Unknown β)
100a95
>         => Rule α β
100a96
>         -> Rule α β
100a97
>         -> Rule α β
100a98
> combine r1 r2 = \f n -> case r1 f n of
100a99
>                          x | E.isUnknown x -> r2 f n
100a100
>                            | otherwise     -> x
103d102
< mapRule ∷ (α → α) → Rule α β → Rule α β
104c103
< mapRule g r = \f n → r f (g n)
---
> mapRule :: (α -> α) -> Rule α β -> Rule α β
104a104
> mapRule g r = \f n -> r f (g n)
108d107
< findRule ∷ (Ord α, Num α, E.Unknown β)
109d107
<          ⇒ (α, Rule α β)   -- ^ First interval rule.
110d107
<          → [(α, Rule α β)] -- ^ Interval rule list.
111d107
<          → α               -- ^ Upper bound of the last interval.
112d107
<          → Rule α β
113d107
< findRule x xs end = \f n → case FT.search n xm of
114d107
<                              [] → E.unknown
115c108
<                              (_,r):_ → r f n
---
> findRule :: (Ord α, Num α, E.Unknown β)
115a109
>          => (α, Rule α β)   -- ^ First interval rule.
115a110
>          -> [(α, Rule α β)] -- ^ Interval rule list.
115a111
>          -> α               -- ^ Upper bound of the last interval.
115a112
>          -> Rule α β
115a113
> findRule x xs end = \f n -> case FT.search n xm of
115a114
>                              [] -> E.unknown
115a115
>                              (_,r):_ -> r f n
129c129
< unknown ∷ (E.Unknown β) ⇒ Rule α β
---
> unknown :: (E.Unknown β) => Rule α β
146c146
< lit ∷ (Integral α, E.Lit β) ⇒ Rule α β
---
> lit :: (Integral α, E.Lit β) => Rule α β
155d154
< lit1 ∷ (Integral α, E.Lit β, E.Mul β) ⇒ Rule α β
156c155
< lit1 = const $ \n → E.lit 1 `E.mul` E.lit (fromIntegral n)
---
> lit1 :: (Integral α, E.Lit β, E.Mul β) => Rule α β
156a156
> lit1 = const $ \n -> E.lit 1 `E.mul` E.lit (fromIntegral n)
164c164
< pos ∷ (Ord α, Num α, E.Lit β, E.Neg β) ⇒ Rule α β
---
> pos :: (Ord α, Num α, E.Lit β, E.Neg β) => Rule α β
175c175
< checkPos ∷ (Ord α, Num α, E.Unknown β, E.Lit β) ⇒ Rule α β
---
> checkPos :: (Ord α, Num α, E.Unknown β, E.Lit β) => Rule α β
184c184
< dual ∷ (E.Dual β) ⇒ Rule α β
---
> dual :: (E.Dual β) => Rule α β
191c191
< plural ∷ (E.Plural β) ⇒ Rule α β
---
> plural :: (E.Plural β) => Rule α β
195d194
< inflection ∷ (E.Inflection β) ⇒ (E.Inf β → E.Inf β) → Rule α β
196c195
< inflection changeInf = \f n → E.inflection changeInf $ f n
---
> inflection :: (E.Inflection β) => (E.Inf β -> E.Inf β) -> Rule α β
196a196
> inflection changeInf = \f n -> E.inflection changeInf $ f n
202d201
< add ∷ (Num α, E.Add β) ⇒ α → Side → Rule α β
203c202
< add val s = \f n → (flipIfR s E.add) (f $ n - val) (f val)
---
> add :: (Num α, E.Add β) => α -> Side -> Rule α β
203a203
> add val s = \f n -> (flipIfR s E.add) (f $ n - val) (f val)
209c209
< mul ∷ (Integral α, E.Add β, E.Mul β) ⇒ α → Side → Side → Rule α β
---
> mul :: (Integral α, E.Add β, E.Mul β) => α -> Side -> Side -> Rule α β
211d210
<     \f n → let (m, a) = n `divMod` val
212d210
<                mval = (flipIfR mSide E.mul) (f m) (f val)
213d210
<            in if a ≡ 0
214d210
<               then mval
215c211
<               else (flipIfR aSide E.add) (f a) mval
---
>     \f n -> let (m, a) = n `divMod` val
215a212
>                 mval = (flipIfR mSide E.mul) (f m) (f val)
215a213
>             in if a ≡ 0
215a214
>                then mval
215a215
>                else (flipIfR aSide E.add) (f a) mval
217d216
< mul1 ∷ (Integral α, E.Lit β, E.Add β, E.Mul β)
218c217
<      ⇒ α → Side → Side → Rule α β
---
> mul1 :: (Integral α, E.Lit β, E.Add β, E.Mul β)
218a218
>      => α -> Side -> Side -> Rule α β
220d219
<     \f n → let (m, a) = n `divMod` val
221d219
<                mval = if m ≡ 1
222d219
<                       then E.lit 1 ⊡ E.lit (fromIntegral val)
223d219
<                       else f m ⊡ E.lit (fromIntegral val)
224d219
<            in if a ≡ 0
225d219
<               then mval
226c220
<               else (flipIfR aSide E.add) (f a) mval
---
>     \f n -> let (m, a) = n `divMod` val
226a221
>                 mval = if m ≡ 1
226a222
>                        then E.lit 1 ⊡ E.lit (fromIntegral val)
226a223
>                        else f m ⊡ E.lit (fromIntegral val)
226a224
>             in if a ≡ 0
226a225
>                then mval
226a226
>                else (flipIfR aSide E.add) (f a) mval
234d233
< sub ∷ (Integral α, E.Sub β) ⇒ α → Rule α β
235c234
< sub val = \f n → E.sub (f $ val - n) (f val)
---
> sub :: (Integral α, E.Sub β) => α -> Rule α β
235a235
> sub val = \f n -> E.sub (f $ val - n) (f val)
237d236
< mkStep ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
238d236
<        ⇒ Rule α β                     -- ^ lit rule
239d236
<        → (α → Side → Rule α β)        -- ^ add rule
240d236
<        → (α → Side → Side → Rule α β) -- ^ mul rule
241c237
<        → α → α → Side → Side → Rule α β
---
> mkStep :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
241a238
>        => Rule α β                     -- ^ lit rule
241a239
>        -> (α -> Side -> Rule α β)        -- ^ add rule
241a240
>        -> (α -> Side -> Side -> Rule α β) -- ^ mul rule
241a241
>        -> α -> α -> Side -> Side -> Rule α β
249d248
< step ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
250c249
<      ⇒ α → α → Side → Side → Rule α β
---
> step :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
250a250
>      => α -> α -> Side -> Side -> Rule α β
253d252
< step1 ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
254c253
<       ⇒ α → α → Side → Side → Rule α β
---
> step1 :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
254a254
>       => α -> α -> Side -> Side -> Rule α β
257d256
< mulScale_ ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
258d256
<           ⇒ ( (α → β) -- Parent rule.
259d256
<             → α       -- First multiplication value (not converted).
260c257
<             → β       -- Second multiplication value (scale step,
---
> mulScale_ :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
260a258
>           => ( (α -> β) -- Parent rule.
260a259
>             -> α       -- First multiplication value (not converted).
260a260
>             -> β       -- Second multiplication value (scale step,
262d261
<             → Side    -- Multiplication side.
263c262
<             → β
---
>             -> Side    -- Multiplication side.
263a263
>             -> β
265d264
<           → α        -- ^ Base.
266d264
<           → α        -- ^ Offset.
267d264
<           → Side     -- ^ Add side.
268d264
<           → Side     -- ^ Mul side.
269d264
<           → Rule α β -- ^ Big num rule.
270c265
<           → Rule α β
---
>           -> α        -- ^ Base.
270a266
>           -> α        -- ^ Offset.
270a267
>           -> Side     -- ^ Add side.
270a268
>           -> Side     -- ^ Mul side.
270a269
>           -> Rule α β -- ^ Big num rule.
270a270
>           -> Rule α β
272d271
<     \f n → let rank    = (intLog n - offset) `div` base
273d271
<                base'   = fromIntegral base
274d271
<                offset' = fromIntegral offset
275d271
<                rank'   = fromIntegral rank
276d271
<                rankExp = (fix bigNumRule) rank
277d271
<                (m, a)  = n `divMod` E.scale base' offset' rank'
278d271
<                scale'  = E.scale base' offset' rankExp
279d271
<                mval    = doMul f m scale' mSide
280d271
<            in if E.isUnknown rankExp
281d271
<               then E.unknown
282d271
<               else if a ≡ 0
283d271
<                    then mval
284c272
<                    else (flipIfR aSide E.add) (f a) mval
---
>     \f n -> let rank    = (intLog n - offset) `div` base
284a273
>                 base'   = fromIntegral base
284a274
>                 offset' = fromIntegral offset
284a275
>                 rank'   = fromIntegral rank
284a276
>                 rankExp = (fix bigNumRule) rank
284a277
>                 (m, a)  = n `divMod` E.scale base' offset' rank'
284a278
>                 scale'  = E.scale base' offset' rankExp
284a279
>                 mval    = doMul f m scale' mSide
284a280
>             in if E.isUnknown rankExp
284a281
>                then E.unknown
284a282
>                else if a ≡ 0
284a283
>                     then mval
284a284
>                     else (flipIfR aSide E.add) (f a) mval
286d285
< mulScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
287d285
<          ⇒ α        -- ^ Base.
288d285
<          → α        -- ^ Offset.
289d285
<          → Side     -- ^ Add side.
290d285
<          → Side     -- ^ Mul side.
291d285
<          → Rule α β -- ^ Big num rule.
292d285
<          → Rule α β
293c286
< mulScale = mulScale_ $ \f m scale' mSide →
---
> mulScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
293a287
>          => α        -- ^ Base.
293a288
>          -> α        -- ^ Offset.
293a289
>          -> Side     -- ^ Add side.
293a290
>          -> Side     -- ^ Mul side.
293a291
>          -> Rule α β -- ^ Big num rule.
293a292
>          -> Rule α β
293a293
> mulScale = mulScale_ $ \f m scale' mSide ->
295d294
<                            1 → scale'
296c295
<                            _ → (flipIfR mSide E.mul) (f m) scale'
---
>                            1 -> scale'
296a296
>                            _ -> (flipIfR mSide E.mul) (f m) scale'
298d297
< mulScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
299d297
<           ⇒ α        -- ^ Base.
300d297
<           → α        -- ^ Offset.
301d297
<           → Side     -- ^ Add side.
302d297
<           → Side     -- ^ Mul side.
303d297
<           → Rule α β -- ^ Big num rule.
304d297
<           → Rule α β
305c298
< mulScale1 = mulScale_ $ \f m scale' mSide → (flipIfR mSide E.mul) (f m) scale'
---
> mulScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
305a299
>           => α        -- ^ Base.
305a300
>           -> α        -- ^ Offset.
305a301
>           -> Side     -- ^ Add side.
305a302
>           -> Side     -- ^ Mul side.
305a303
>           -> Rule α β -- ^ Big num rule.
305a304
>           -> Rule α β
305a305
> mulScale1 = mulScale_ $ \f m scale' mSide -> (flipIfR mSide E.mul) (f m) scale'
307d306
< shortScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
308d306
<            ⇒ Side     -- ^ Add side.
309d306
<            → Side     -- ^ Mul side.
310d306
<            → Rule α β -- ^ Big num rule.
311c307
<            → Rule α β
---
> shortScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
311a308
>            => Side     -- ^ Add side.
311a309
>            -> Side     -- ^ Mul side.
311a310
>            -> Rule α β -- ^ Big num rule.
311a311
>            -> Rule α β
314d313
< shortScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
315d313
<             ⇒ Side     -- ^ Add side.
316d313
<             → Side     -- ^ Mul side.
317d313
<             → Rule α β -- ^ Big num rule.
318c314
<             → Rule α β
---
> shortScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
318a315
>             => Side     -- ^ Add side.
318a316
>             -> Side     -- ^ Mul side.
318a317
>             -> Rule α β -- ^ Big num rule.
318a318
>             -> Rule α β
321d320
< longScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
322d320
<           ⇒ Side     -- ^ Add side.
323d320
<           → Side     -- ^ Mul side.
324d320
<           → Rule α β -- ^ Big num rule.
325c321
<           → Rule α β
---
> longScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
325a322
>           => Side     -- ^ Add side.
325a323
>           -> Side     -- ^ Mul side.
325a324
>           -> Rule α β -- ^ Big num rule.
325a325
>           -> Rule α β
328d327
< longScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
329d327
<            ⇒ Side     -- ^ Add side.
330d327
<            → Side     -- ^ Mul side.
331d327
<            → Rule α β -- ^ Big num rule.
332c328
<            → Rule α β
---
> longScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
332a329
>            => Side     -- ^ Add side.
332a330
>            -> Side     -- ^ Mul side.
332a331
>            -> Rule α β -- ^ Big num rule.
332a332
>            -> Rule α β
335d334
< pelletierScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
336d334
<                ⇒ Side     -- ^ Add side.
337d334
<                → Side     -- ^ Mul side.
338d334
<                → Rule α β -- ^ Big num rule.
339c335
<                → Rule α β
---
> pelletierScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
339a336
>                => Side     -- ^ Add side.
339a337
>                -> Side     -- ^ Mul side.
339a338
>                -> Rule α β -- ^ Big num rule.
339a339
>                -> Rule α β
341c341
<     conditional (\n → even $ intLog n `div` 3)
---
>     conditional (\n -> even $ intLog n `div` 3)
345d344
< pelletierScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
346d344
<                 ⇒ Side     -- ^ Add side.
347d344
<                 → Side     -- ^ Mul side.
348d344
<                 → Rule α β -- ^ Big num rule.
349c345
<                 → Rule α β
---
> pelletierScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
349a346
>                 => Side     -- ^ Add side.
349a347
>                 -> Side     -- ^ Mul side.
349a348
>                 -> Rule α β -- ^ Big num rule.
349a349
>                 -> Rule α β
351c351
<     conditional (\n → even $ intLog n `div` 3)
---
>     conditional (\n -> even $ intLog n `div` 3)
360c360
< flipIfR ∷ Side → (α → α → α) → (α → α → α)
---
> flipIfR :: Side -> (α -> α -> α) -> (α -> α -> α)
364c364
< mkIntervalList ∷ (Num a) ⇒ (a, b) → [(a, b)] → a → [((a, a), b)]
---
> mkIntervalList :: (Num a) => (a, b) -> [(a, b)] -> a -> [((a, a), b)]
370c370
< mkIntervalMap ∷ (Ord v) ⇒ [((v, v), α)] → FT.IntervalMap v α
---
> mkIntervalMap :: (Ord v) => [((v, v), α)] -> FT.IntervalMap v α
373a374
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , PackageImports
           , UnicodeSyntax
  #-}

{-|

Rules to convert numbers to an expression language.

-}
module Text.Numeral.Rules
  ( -- * The Rule type
    Rule

    -- * Rule combinators
  , conditional
  , combine
  , mapRule
  , findRule

    -- * Rules
  , unknown

  , lit, lit1

  , pos, checkPos
  , dual, plural
  , inflection

  , add
  , mul, mul1
  , sub

  , mulScale_, mulScale, mulScale1
  , shortScale,  longScale,  pelletierScale
  , shortScale1, longScale1, pelletierScale1

  , mkStep, step, step1
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import "base" Data.Bool           ( Bool, otherwise )
import "base" Data.Function       ( ($), id, const, flip, fix )
import "base" Data.List           ( foldr )
import "base" Data.Ord            ( Ord, (<), (>) )
import "base" Prelude             ( Integral, fromIntegral
                                  , Num, (-), abs, divMod, div, even
                                  )
import "base-unicode-symbols" Data.Eq.Unicode       ( (≡) )
import "base-unicode-symbols" Data.Function.Unicode ( (∘) )
import "base-unicode-symbols" Prelude.Unicode       ( (⋅) )
import "this"                 Text.Numeral.Exp.Reified ( Side(L, R) )
import "this"                 Text.Numeral.Misc     ( intLog )
import qualified "this"       Text.Numeral.Exp as E
import qualified "fingertree" Data.IntervalMap.FingerTree as FT
    ( Interval(Interval)
    , IntervalMap, empty, insert
    , search
    )


--------------------------------------------------------------------------------
-- The Rule type
--------------------------------------------------------------------------------

-- | A rule on how to convert a number into an expression
-- language. Notice how this type is equal to the type of the '$'
-- operator.
type Rule α β = (α → β) → (α → β)


--------------------------------------------------------------------------------
-- Rule combinators
--------------------------------------------------------------------------------


-- | The \'if-then-else\' concept for rules. Applies the first rule if
-- the predicate holds on the input value, otherwise applies the
-- second rule.
conditional ∷ (α → Bool) -- ^ Predicate on input value (\"if\").
            → Rule α β -- ^ Rule to apply when predicate holds (\"then\").
            → Rule α β -- ^ Rule to apply when predicate does not hold (\"else\").
            → Rule α β
conditional p t e = \f n → if p n
                           then t f n
                           else e f n

-- | Tries to apply the first rule, if that produces an 'E.unknown'
-- value it applies the second rule.
combine ∷ (E.Unknown β)
        ⇒ Rule α β
        → Rule α β
        → Rule α β
combine r1 r2 = \f n → case r1 f n of
                         x | E.isUnknown x → r2 f n
                           | otherwise     → x

-- | Transform a value before it is given to a rule.
mapRule ∷ (α → α) → Rule α β → Rule α β
mapRule g r = \f n → r f (g n)

-- | Chooses which rule to apply to an input value based on a interval
-- list of rules.
findRule ∷ (Ord α, Num α, E.Unknown β)
         ⇒ (α, Rule α β)   -- ^ First interval rule.
         → [(α, Rule α β)] -- ^ Interval rule list.
         → α               -- ^ Upper bound of the last interval.
         → Rule α β
findRule x xs end = \f n → case FT.search n xm of
                             [] → E.unknown
                             (_,r):_ → r f n
    where
      xm = mkIntervalMap $ mkIntervalList x xs end


--------------------------------------------------------------------------------
-- Rules
--------------------------------------------------------------------------------

-- | A rule that always fails to convert a value. It constantly
-- produces the 'E.unknown' value.
--
-- >>> (fix unknown) (3 :: Integer) :: Exp
-- Unknown
unknown ∷ (E.Unknown β) ⇒ Rule α β
unknown _ _ = E.unknown

-- | The literal rule. Converts its argument into a 'E.lit'eral
-- expression.
--
-- >>> lit (fix unknown) (3 :: Integer) :: Exp
-- Lit 3
--
-- In this example lit is applied to the nonsense rule \"'fix'
-- 'unknown'\". Lit ignores that function, which is why we can pass it
-- anything we want, including itself.
--
-- >>> lit (fix undefined) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (fix lit) (3 :: Integer) :: Exp
-- Lit 3
lit ∷ (Integral α, E.Lit β) ⇒ Rule α β
lit = const $ E.lit ∘ fromIntegral

-- | A variant on the 'lit' rule which always multiplies its argument
-- with 1. Useful for languages which have numerals of the form \"one
-- hundred and three\" as opposed to \"hundred and three\".
--
-- >>> lit1 (fix unknown) (3 :: Integer) :: Exp
-- Mul (Lit 1) (Lit 3)
lit1 ∷ (Integral α, E.Lit β, E.Mul β) ⇒ Rule α β
lit1 = const $ \n → E.lit 1 `E.mul` E.lit (fromIntegral n)

-- |
--
-- >>> (pos $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (pos $ lit $ fix unknown) (-3 :: Integer) :: Exp
-- Neg (Lit 3)
pos ∷ (Ord α, Num α, E.Lit β, E.Neg β) ⇒ Rule α β
pos f n | n < 0     = E.neg $ f (abs n)
        | n > 0     = f n
        | otherwise = E.lit 0

-- |
--
-- >>> (checkPos $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (checkPos $ lit $ fix unknown) (-3 :: Integer) :: Exp
-- Unknown
checkPos ∷ (Ord α, Num α, E.Unknown β, E.Lit β) ⇒ Rule α β
checkPos f n | n < 0     = E.unknown
             | n > 0     = f n
             | otherwise = E.lit 0

-- |
--
-- >>> (dual $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Dual (Lit 3)
dual ∷ (E.Dual β) ⇒ Rule α β
dual = (∘) E.dual

-- |
--
-- >>> (plural $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Plural (Lit 3)
plural ∷ (E.Plural β) ⇒ Rule α β
plural = (∘) E.plural

-- | Changes the inflection of a subexpression.
inflection ∷ (E.Inflection β) ⇒ (E.Inf β → E.Inf β) → Rule α β
inflection changeInf = \f n → E.inflection changeInf $ f n

-- |
--
-- >>> (add 10 L $ lit $ fix unknown) (13 :: Integer) :: Exp
-- Add (Lit 3) (Lit 10)
add ∷ (Num α, E.Add β) ⇒ α → Side → Rule α β
add val s = \f n → (flipIfR s E.add) (f $ n - val) (f val)

-- |
--
-- >>> (mul 10 R L $ lit $ fix unknown) (42 :: Integer) :: Exp
-- Add (Mul (Lit 4) (Lit 10)) (Lit 2)
mul ∷ (Integral α, E.Add β, E.Mul β) ⇒ α → Side → Side → Rule α β
mul val aSide mSide =
    \f n → let (m, a) = n `divMod` val
               mval = (flipIfR mSide E.mul) (f m) (f val)
           in if a ≡ 0
              then mval
              else (flipIfR aSide E.add) (f a) mval

mul1 ∷ (Integral α, E.Lit β, E.Add β, E.Mul β)
     ⇒ α → Side → Side → Rule α β
mul1 val aSide mSide =
    \f n → let (m, a) = n `divMod` val
               mval = if m ≡ 1
                      then E.lit 1 ⊡ E.lit (fromIntegral val)
                      else f m ⊡ E.lit (fromIntegral val)
           in if a ≡ 0
              then mval
              else (flipIfR aSide E.add) (f a) mval
  where
     (⊡) = flipIfR mSide E.mul

-- |
--
-- >>> (sub 20 $ lit $ fix unknown) (18 :: Integer) :: Exp
-- Sub (Lit 2) (Lit 20)
sub ∷ (Integral α, E.Sub β) ⇒ α → Rule α β
sub val = \f n → E.sub (f $ val - n) (f val)

mkStep ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
       ⇒ Rule α β                     -- ^ lit rule
       → (α → Side → Rule α β)        -- ^ add rule
       → (α → Side → Side → Rule α β) -- ^ mul rule
       → α → α → Side → Side → Rule α β
mkStep lr ar mr val r aSide mSide
       f n | n < val   = E.unknown
           | n ≡ val   = lr                 f n
           | n < val⋅2 = ar val aSide       f n
           | n < val⋅r = mr val aSide mSide f n
           | otherwise = E.unknown

step ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
     ⇒ α → α → Side → Side → Rule α β
step = mkStep lit add mul

step1 ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
      ⇒ α → α → Side → Side → Rule α β
step1 = mkStep lit1 add mul1

mulScale_ ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          ⇒ ( (α → β) -- Parent rule.
            → α       -- First multiplication value (not converted).
            → β       -- Second multiplication value (scale step,
                      -- already converted).
            → Side    -- Multiplication side.
            → β
            )        -- ^ Performs the multiplication.
          → α        -- ^ Base.
          → α        -- ^ Offset.
          → Side     -- ^ Add side.
          → Side     -- ^ Mul side.
          → Rule α β -- ^ Big num rule.
          → Rule α β
mulScale_ doMul base offset aSide mSide bigNumRule =
    \f n → let rank    = (intLog n - offset) `div` base
               base'   = fromIntegral base
               offset' = fromIntegral offset
               rank'   = fromIntegral rank
               rankExp = (fix bigNumRule) rank
               (m, a)  = n `divMod` E.scale base' offset' rank'
               scale'  = E.scale base' offset' rankExp
               mval    = doMul f m scale' mSide
           in if E.isUnknown rankExp
              then E.unknown
              else if a ≡ 0
                   then mval
                   else (flipIfR aSide E.add) (f a) mval

mulScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
         ⇒ α        -- ^ Base.
         → α        -- ^ Offset.
         → Side     -- ^ Add side.
         → Side     -- ^ Mul side.
         → Rule α β -- ^ Big num rule.
         → Rule α β
mulScale = mulScale_ $ \f m scale' mSide →
                         case m of
                           1 → scale'
                           _ → (flipIfR mSide E.mul) (f m) scale'

mulScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          ⇒ α        -- ^ Base.
          → α        -- ^ Offset.
          → Side     -- ^ Add side.
          → Side     -- ^ Mul side.
          → Rule α β -- ^ Big num rule.
          → Rule α β
mulScale1 = mulScale_ $ \f m scale' mSide → (flipIfR mSide E.mul) (f m) scale'

shortScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
           ⇒ Side     -- ^ Add side.
           → Side     -- ^ Mul side.
           → Rule α β -- ^ Big num rule.
           → Rule α β
shortScale = mulScale 3 3

shortScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
            ⇒ Side     -- ^ Add side.
            → Side     -- ^ Mul side.
            → Rule α β -- ^ Big num rule.
            → Rule α β
shortScale1 = mulScale1 3 3

longScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          ⇒ Side     -- ^ Add side.
          → Side     -- ^ Mul side.
          → Rule α β -- ^ Big num rule.
          → Rule α β
longScale = mulScale 6 0

longScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
           ⇒ Side     -- ^ Add side.
           → Side     -- ^ Mul side.
           → Rule α β -- ^ Big num rule.
           → Rule α β
longScale1 = mulScale1 6 0

pelletierScale ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
               ⇒ Side     -- ^ Add side.
               → Side     -- ^ Mul side.
               → Rule α β -- ^ Big num rule.
               → Rule α β
pelletierScale aSide mSide bigNumRule =
    conditional (\n → even $ intLog n `div` 3)
                (mulScale 6 0 aSide mSide bigNumRule)
                (mulScale 6 3 aSide mSide bigNumRule)

pelletierScale1 ∷ (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
                ⇒ Side     -- ^ Add side.
                → Side     -- ^ Mul side.
                → Rule α β -- ^ Big num rule.
                → Rule α β
pelletierScale1 aSide mSide bigNumRule =
    conditional (\n → even $ intLog n `div` 3)
                (mulScale1 6 0 aSide mSide bigNumRule)
                (mulScale1 6 3 aSide mSide bigNumRule)


--------------------------------------------------------------------------------
-- Miscellaneous
--------------------------------------------------------------------------------

flipIfR ∷ Side → (α → α → α) → (α → α → α)
flipIfR L = id
flipIfR R = flip

mkIntervalList ∷ (Num a) ⇒ (a, b) → [(a, b)] → a → [((a, a), b)]
mkIntervalList (k, r) krs end = go k r krs
    where
      go k1 r1 []            = [((k1, end), r1)]
      go k1 r1 ((k2, r2):xs) = ((k1, k2-1), r1) : go k2 r2 xs

mkIntervalMap ∷ (Ord v) ⇒ [((v, v), α)] → FT.IntervalMap v α
mkIntervalMap = foldr ins FT.empty
  where ins ((lo, hi), n) = FT.insert (FT.Interval lo hi) n

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , PackageImports
           , UnicodeSyntax
  #-}

{-|

Rules to convert numbers to an expression language.

-}
module Text.Numeral.Rules
  ( -- * The Rule type
    Rule

    -- * Rule combinators
  , conditional
  , combine
  , mapRule
  , findRule

    -- * Rules
  , unknown

  , lit, lit1

  , pos, checkPos
  , dual, plural
  , inflection

  , add
  , mul, mul1
  , sub

  , mulScale_, mulScale, mulScale1
  , shortScale,  longScale,  pelletierScale
  , shortScale1, longScale1, pelletierScale1

  , mkStep, step, step1
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import  Data.Bool           ( Bool, otherwise )
import  Data.Function       ( ($), id, const, flip, fix )
import  Data.List           ( foldr )
import  Data.Ord            ( Ord, (<), (>) )
import  Prelude             ( Integral, fromIntegral
                                  , Num, (-), abs, divMod, div, even
                                  )
import  Data.Eq.Unicode       ( (≡) )
import  Data.Function.Unicode ( (∘) )
import  Prelude.Unicode       ( (⋅) )
import                  Text.Numeral.Exp.Reified ( Side(L, R) )
import                  Text.Numeral.Misc     ( intLog )
import qualified        Text.Numeral.Exp as E
import qualified  Data.IntervalMap.FingerTree as FT
    ( Interval(Interval)
    , IntervalMap, empty, insert
    , search
    )


--------------------------------------------------------------------------------
-- The Rule type
--------------------------------------------------------------------------------

-- | A rule on how to convert a number into an expression
-- language. Notice how this type is equal to the type of the '$'
-- operator.
type Rule α β = (α -> β) -> (α -> β)


--------------------------------------------------------------------------------
-- Rule combinators
--------------------------------------------------------------------------------


-- | The \'if-then-else\' concept for rules. Applies the first rule if
-- the predicate holds on the input value, otherwise applies the
-- second rule.
conditional :: (α -> Bool) -- ^ Predicate on input value (\"if\").
            -> Rule α β -- ^ Rule to apply when predicate holds (\"then\").
            -> Rule α β -- ^ Rule to apply when predicate does not hold (\"else\").
            -> Rule α β
conditional p t e = \f n -> if p n
                           then t f n
                           else e f n

-- | Tries to apply the first rule, if that produces an 'E.unknown'
-- value it applies the second rule.
combine :: (E.Unknown β)
        => Rule α β
        -> Rule α β
        -> Rule α β
combine r1 r2 = \f n -> case r1 f n of
                         x | E.isUnknown x -> r2 f n
                           | otherwise     -> x

-- | Transform a value before it is given to a rule.
mapRule :: (α -> α) -> Rule α β -> Rule α β
mapRule g r = \f n -> r f (g n)

-- | Chooses which rule to apply to an input value based on a interval
-- list of rules.
findRule :: (Ord α, Num α, E.Unknown β)
         => (α, Rule α β)   -- ^ First interval rule.
         -> [(α, Rule α β)] -- ^ Interval rule list.
         -> α               -- ^ Upper bound of the last interval.
         -> Rule α β
findRule x xs end = \f n -> case FT.search n xm of
                             [] -> E.unknown
                             (_,r):_ -> r f n
    where
      xm = mkIntervalMap $ mkIntervalList x xs end


--------------------------------------------------------------------------------
-- Rules
--------------------------------------------------------------------------------

-- | A rule that always fails to convert a value. It constantly
-- produces the 'E.unknown' value.
--
-- >>> (fix unknown) (3 :: Integer) :: Exp
-- Unknown
unknown :: (E.Unknown β) => Rule α β
unknown _ _ = E.unknown

-- | The literal rule. Converts its argument into a 'E.lit'eral
-- expression.
--
-- >>> lit (fix unknown) (3 :: Integer) :: Exp
-- Lit 3
--
-- In this example lit is applied to the nonsense rule \"'fix'
-- 'unknown'\". Lit ignores that function, which is why we can pass it
-- anything we want, including itself.
--
-- >>> lit (fix undefined) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (fix lit) (3 :: Integer) :: Exp
-- Lit 3
lit :: (Integral α, E.Lit β) => Rule α β
lit = const $ E.lit ∘ fromIntegral

-- | A variant on the 'lit' rule which always multiplies its argument
-- with 1. Useful for languages which have numerals of the form \"one
-- hundred and three\" as opposed to \"hundred and three\".
--
-- >>> lit1 (fix unknown) (3 :: Integer) :: Exp
-- Mul (Lit 1) (Lit 3)
lit1 :: (Integral α, E.Lit β, E.Mul β) => Rule α β
lit1 = const $ \n -> E.lit 1 `E.mul` E.lit (fromIntegral n)

-- |
--
-- >>> (pos $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (pos $ lit $ fix unknown) (-3 :: Integer) :: Exp
-- Neg (Lit 3)
pos :: (Ord α, Num α, E.Lit β, E.Neg β) => Rule α β
pos f n | n < 0     = E.neg $ f (abs n)
        | n > 0     = f n
        | otherwise = E.lit 0

-- |
--
-- >>> (checkPos $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Lit 3
-- >>> (checkPos $ lit $ fix unknown) (-3 :: Integer) :: Exp
-- Unknown
checkPos :: (Ord α, Num α, E.Unknown β, E.Lit β) => Rule α β
checkPos f n | n < 0     = E.unknown
             | n > 0     = f n
             | otherwise = E.lit 0

-- |
--
-- >>> (dual $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Dual (Lit 3)
dual :: (E.Dual β) => Rule α β
dual = (∘) E.dual

-- |
--
-- >>> (plural $ lit $ fix unknown) (3 :: Integer) :: Exp
-- Plural (Lit 3)
plural :: (E.Plural β) => Rule α β
plural = (∘) E.plural

-- | Changes the inflection of a subexpression.
inflection :: (E.Inflection β) => (E.Inf β -> E.Inf β) -> Rule α β
inflection changeInf = \f n -> E.inflection changeInf $ f n

-- |
--
-- >>> (add 10 L $ lit $ fix unknown) (13 :: Integer) :: Exp
-- Add (Lit 3) (Lit 10)
add :: (Num α, E.Add β) => α -> Side -> Rule α β
add val s = \f n -> (flipIfR s E.add) (f $ n - val) (f val)

-- |
--
-- >>> (mul 10 R L $ lit $ fix unknown) (42 :: Integer) :: Exp
-- Add (Mul (Lit 4) (Lit 10)) (Lit 2)
mul :: (Integral α, E.Add β, E.Mul β) => α -> Side -> Side -> Rule α β
mul val aSide mSide =
    \f n -> let (m, a) = n `divMod` val
                mval = (flipIfR mSide E.mul) (f m) (f val)
            in if a ≡ 0
               then mval
               else (flipIfR aSide E.add) (f a) mval

mul1 :: (Integral α, E.Lit β, E.Add β, E.Mul β)
     => α -> Side -> Side -> Rule α β
mul1 val aSide mSide =
    \f n -> let (m, a) = n `divMod` val
                mval = if m ≡ 1
                       then E.lit 1 ⊡ E.lit (fromIntegral val)
                       else f m ⊡ E.lit (fromIntegral val)
            in if a ≡ 0
               then mval
               else (flipIfR aSide E.add) (f a) mval
  where
     (⊡) = flipIfR mSide E.mul

-- |
--
-- >>> (sub 20 $ lit $ fix unknown) (18 :: Integer) :: Exp
-- Sub (Lit 2) (Lit 20)
sub :: (Integral α, E.Sub β) => α -> Rule α β
sub val = \f n -> E.sub (f $ val - n) (f val)

mkStep :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
       => Rule α β                     -- ^ lit rule
       -> (α -> Side -> Rule α β)        -- ^ add rule
       -> (α -> Side -> Side -> Rule α β) -- ^ mul rule
       -> α -> α -> Side -> Side -> Rule α β
mkStep lr ar mr val r aSide mSide
       f n | n < val   = E.unknown
           | n ≡ val   = lr                 f n
           | n < val⋅2 = ar val aSide       f n
           | n < val⋅r = mr val aSide mSide f n
           | otherwise = E.unknown

step :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
     => α -> α -> Side -> Side -> Rule α β
step = mkStep lit add mul

step1 :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β)
      => α -> α -> Side -> Side -> Rule α β
step1 = mkStep lit1 add mul1

mulScale_ :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          => ( (α -> β) -- Parent rule.
            -> α       -- First multiplication value (not converted).
            -> β       -- Second multiplication value (scale step,
                      -- already converted).
            -> Side    -- Multiplication side.
            -> β
            )        -- ^ Performs the multiplication.
          -> α        -- ^ Base.
          -> α        -- ^ Offset.
          -> Side     -- ^ Add side.
          -> Side     -- ^ Mul side.
          -> Rule α β -- ^ Big num rule.
          -> Rule α β
mulScale_ doMul base offset aSide mSide bigNumRule =
    \f n -> let rank    = (intLog n - offset) `div` base
                base'   = fromIntegral base
                offset' = fromIntegral offset
                rank'   = fromIntegral rank
                rankExp = (fix bigNumRule) rank
                (m, a)  = n `divMod` E.scale base' offset' rank'
                scale'  = E.scale base' offset' rankExp
                mval    = doMul f m scale' mSide
            in if E.isUnknown rankExp
               then E.unknown
               else if a ≡ 0
                    then mval
                    else (flipIfR aSide E.add) (f a) mval

mulScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
         => α        -- ^ Base.
         -> α        -- ^ Offset.
         -> Side     -- ^ Add side.
         -> Side     -- ^ Mul side.
         -> Rule α β -- ^ Big num rule.
         -> Rule α β
mulScale = mulScale_ $ \f m scale' mSide ->
                         case m of
                           1 -> scale'
                           _ -> (flipIfR mSide E.mul) (f m) scale'

mulScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          => α        -- ^ Base.
          -> α        -- ^ Offset.
          -> Side     -- ^ Add side.
          -> Side     -- ^ Mul side.
          -> Rule α β -- ^ Big num rule.
          -> Rule α β
mulScale1 = mulScale_ $ \f m scale' mSide -> (flipIfR mSide E.mul) (f m) scale'

shortScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
           => Side     -- ^ Add side.
           -> Side     -- ^ Mul side.
           -> Rule α β -- ^ Big num rule.
           -> Rule α β
shortScale = mulScale 3 3

shortScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
            => Side     -- ^ Add side.
            -> Side     -- ^ Mul side.
            -> Rule α β -- ^ Big num rule.
            -> Rule α β
shortScale1 = mulScale1 3 3

longScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
          => Side     -- ^ Add side.
          -> Side     -- ^ Mul side.
          -> Rule α β -- ^ Big num rule.
          -> Rule α β
longScale = mulScale 6 0

longScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
           => Side     -- ^ Add side.
           -> Side     -- ^ Mul side.
           -> Rule α β -- ^ Big num rule.
           -> Rule α β
longScale1 = mulScale1 6 0

pelletierScale :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
               => Side     -- ^ Add side.
               -> Side     -- ^ Mul side.
               -> Rule α β -- ^ Big num rule.
               -> Rule α β
pelletierScale aSide mSide bigNumRule =
    conditional (\n -> even $ intLog n `div` 3)
                (mulScale 6 0 aSide mSide bigNumRule)
                (mulScale 6 3 aSide mSide bigNumRule)

pelletierScale1 :: (Integral α, E.Scale α, E.Unknown β, E.Add β, E.Mul β, E.Scale β)
                => Side     -- ^ Add side.
                -> Side     -- ^ Mul side.
                -> Rule α β -- ^ Big num rule.
                -> Rule α β
pelletierScale1 aSide mSide bigNumRule =
    conditional (\n -> even $ intLog n `div` 3)
                (mulScale1 6 0 aSide mSide bigNumRule)
                (mulScale1 6 3 aSide mSide bigNumRule)


--------------------------------------------------------------------------------
-- Miscellaneous
--------------------------------------------------------------------------------

flipIfR :: Side -> (α -> α -> α) -> (α -> α -> α)
flipIfR L = id
flipIfR R = flip

mkIntervalList :: (Num a) => (a, b) -> [(a, b)] -> a -> [((a, a), b)]
mkIntervalList (k, r) krs end = go k r krs
    where
      go k1 r1 []            = [((k1, end), r1)]
      go k1 r1 ((k2, r2):xs) = ((k1, k2-1), r1) : go k2 r2 xs

mkIntervalMap :: (Ord v) => [((v, v), α)] -> FT.IntervalMap v α
mkIntervalMap = foldr ins FT.empty
  where ins ((lo, hi), n) = FT.insert (FT.Interval lo hi) n


</pre>