<a href="Memo.hs14377846301360280366.out.html">prev</a></br><a href="failures.html">home</a></br><a href="MemoTable.hs144128232716531729.out.html">next</a></br></br><pre>43d42
< memoize2 ∷ (Memoizable a, Memoizable b) ⇒
44c43
<            (a → b → v) → a → b → v
---
> memoize2 :: (Memoizable a, Memoizable b) =>
44a44
>            (a -> b -> v) -> a -> b -> v
48d47
< memoize3 ∷ (Memoizable a, Memoizable b, Memoizable c) ⇒
49c48
<            (a → b → c → v) → a → b → c → v
---
> memoize3 :: (Memoizable a, Memoizable b, Memoizable c) =>
49a49
>            (a -> b -> c -> v) -> a -> b -> c -> v
53d52
< memoize4 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d) ⇒
54d52
<            (a → b → c → d → v) →
55c53
<            a → b → c → d → v
---
> memoize4 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d) =>
55a54
>            (a -> b -> c -> d -> v) ->
55a55
>            a -> b -> c -> d -> v
59d58
< memoize5 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
60d58
<             Memoizable e) ⇒
61d58
<            (a → b → c → d → e → v) →
62c59
<            a → b → c → d → e → v
---
> memoize5 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
62a60
>             Memoizable e) =>
62a61
>            (a -> b -> c -> d -> e -> v) ->
62a62
>            a -> b -> c -> d -> e -> v
66d65
< memoize6 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
67d65
<             Memoizable e, Memoizable f) ⇒
68d65
<            (a → b → c → d → e → f → v) →
69c66
<            a → b → c → d → e → f → v
---
> memoize6 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
69a67
>             Memoizable e, Memoizable f) =>
69a68
>            (a -> b -> c -> d -> e -> f -> v) ->
69a69
>            a -> b -> c -> d -> e -> f -> v
73d72
< memoize7 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
74d72
<             Memoizable e, Memoizable f, Memoizable g) ⇒
75d72
<            (a → b → c → d → e → f → g → v) →
76c73
<            a → b → c → d → e → f → g → v
---
> memoize7 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
76a74
>             Memoizable e, Memoizable f, Memoizable g) =>
76a75
>            (a -> b -> c -> d -> e -> f -> g -> v) ->
76a76
>            a -> b -> c -> d -> e -> f -> g -> v
82c82
< memoFix ∷ Memoizable a ⇒ ((a → v) → a → v) → a → v
---
> memoFix :: Memoizable a => ((a -> v) -> a -> v) -> a -> v
86d85
< memoFix2 ∷ (Memoizable a, Memoizable b) ⇒
87c86
<            ((a → b → v) → a → b → v) → a → b → v
---
> memoFix2 :: (Memoizable a, Memoizable b) =>
87a87
>            ((a -> b -> v) -> a -> b -> v) -> a -> b -> v
91d90
< memoFix3 ∷ (Memoizable a, Memoizable b, Memoizable c) ⇒
92c91
<            ((a → b → c → v) → a → b → c → v) → a → b → c → v
---
> memoFix3 :: (Memoizable a, Memoizable b, Memoizable c) =>
92a92
>            ((a -> b -> c -> v) -> a -> b -> c -> v) -> a -> b -> c -> v
96d95
< memoFix4 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d) ⇒
97d95
<            ((a → b → c → d → v) → (a → b → c → d → v)) →
98c96
<            a → b → c → d → v
---
> memoFix4 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d) =>
98a97
>            ((a -> b -> c -> d -> v) -> (a -> b -> c -> d -> v)) ->
98a98
>            a -> b -> c -> d -> v
102d101
< memoFix5 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
103d101
<             Memoizable e) ⇒
104d101
<            ((a → b → c → d → e → v) → (a → b → c → d → e → v)) →
105c102
<            a → b → c → d → e → v
---
> memoFix5 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
105a103
>             Memoizable e) =>
105a104
>            ((a -> b -> c -> d -> e -> v) -> (a -> b -> c -> d -> e -> v)) ->
105a105
>            a -> b -> c -> d -> e -> v
109d108
< memoFix6 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
110d108
<             Memoizable e, Memoizable f) ⇒
111d108
<            ((a → b → c → d → e → f → v) → (a → b → c → d → e → f → v)) →
112c109
<            a → b → c → d → e → f → v
---
> memoFix6 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
112a110
>             Memoizable e, Memoizable f) =>
112a111
>            ((a -> b -> c -> d -> e -> f -> v) -> (a -> b -> c -> d -> e -> f -> v)) ->
112a112
>            a -> b -> c -> d -> e -> f -> v
116d115
< memoFix7 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
117d115
<             Memoizable e, Memoizable f, Memoizable g) ⇒
118d115
<            ((a → b → c → d → e → f → g → v) → (a → b → c → d → e → f → g → v)) →
119c116
<            a → b → c → d → e → f → g → v
---
> memoFix7 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
119a117
>             Memoizable e, Memoizable f, Memoizable g) =>
119a118
>            ((a -> b -> c -> d -> e -> f -> g -> v) -> (a -> b -> c -> d -> e -> f -> g -> v)) ->
119a119
>            a -> b -> c -> d -> e -> f -> g -> v
126d125
< traceMemoize ∷ (Memoizable a, Show a) ⇒ (a → b) → a → b
127c126
< traceMemoize f = memoize (\a → traceShow a (f a))
---
> traceMemoize :: (Memoizable a, Show a) => (a -> b) -> a -> b
127a127
> traceMemoize f = memoize (\a -> traceShow a (f a))
160d159
<     btValue         ∷ v,
161c160
<     btLeft, btRight ∷ BinaryTreeCache v
---
>     btValue         :: v,
161a161
>     btLeft, btRight :: BinaryTreeCache v
176d175
<       icZero                 ∷ v,
177c176
<       icNegative, icPositive ∷ PosIntCache v
---
>       icZero                 :: v,
177a177
>       icNegative, icPositive :: PosIntCache v
185c185
< theIntegers ∷ IntegerCache Integer
---
> theIntegers :: IntegerCache Integer
193c193
< thePosInts ∷ PosIntCache Integer
---
> thePosInts :: PosIntCache Integer
201c201
< integerLookup ∷ IntegerCache v → Integer → v
---
> integerLookup :: IntegerCache v -> Integer -> v
204d203
<     EQ → icZero cache
205d203
<     GT → posIntLookup (icPositive cache) n
206c204
<     LT → posIntLookup (icNegative cache) (negate n)
---
>     EQ -> icZero cache
206a205
>     GT -> posIntLookup (icPositive cache) n
206a206
>     LT -> posIntLookup (icNegative cache) (negate n)
209c209
< posIntLookup ∷ PosIntCache v → Integer → v
---
> posIntLookup :: PosIntCache v -> Integer -> v
219c219
< newtype Finite a = ToFinite { fromFinite ∷ a }
---
> newtype Finite a = ToFinite { fromFinite :: a }
222c222
< instance (Bounded a, Enum a) ⇒ Memoizable (Finite a) where
---
> instance (Bounded a, Enum a) => Memoizable (Finite a) where
227c227
< theFinites ∷ (Bounded a, Enum a) ⇒ BinaryTreeCache a
---
> theFinites :: (Bounded a, Enum a) => BinaryTreeCache a
237c237
< finiteLookup ∷ (Bounded a, Enum a) ⇒ BinaryTreeCache v → a → v
---
> finiteLookup :: (Bounded a, Enum a) => BinaryTreeCache v -> a -> v
246d245
<           EQ → btValue cache
247d245
<           LT → loop start (pred mean) (btLeft cache)
248c246
<           GT → loop (succ mean) stop (btRight cache)
---
>           EQ -> btValue cache
248a247
>           LT -> loop start (pred mean) (btLeft cache)
248a248
>           GT -> loop (succ mean) stop (btRight cache)
250c250
< meanFinite     ∷ (Bounded a, Enum a) ⇒ a → a → a
---
> meanFinite     :: (Bounded a, Enum a) => a -> a -> a
269c269
< memoizeFinite   ∷ (Enum a, Bounded a) ⇒ (a → v) → a → v
---
> memoizeFinite   :: (Enum a, Bounded a) => (a -> v) -> a -> v
279c279
< instance (Eq a, Bounded a, Enum a, Memoizable b) ⇒ Memoizable (a → b) where
---
> instance (Eq a, Bounded a, Enum a, Memoizable b) => Memoizable (a -> b) where
282d281
< functionLookup ∷ (Eq a, Bounded a, Enum a, Memoizable b) ⇒
283c282
<                  FunctionCache b v → (a → b) → v
---
> functionLookup :: (Eq a, Bounded a, Enum a, Memoizable b) =>
283a283
>                  FunctionCache b v -> (a -> b) -> v
287d286
< theFunctions ∷ (Eq a, Bounded a, Enum a, Memoizable b) ⇒
288c287
<                ((a → b) → v) → FunctionCache b v
---
> theFunctions :: (Eq a, Bounded a, Enum a, Memoizable b) =>
288a288
>                ((a -> b) -> v) -> FunctionCache b v
292c292
<     fcCons = memoize (\b → theFunctions (f . extend b))
---
>     fcCons = memoize (\b -> theFunctions (f . extend b))
301d300
<       fcNil  ∷ v,
302c301
<       fcCons ∷ b → FunctionCache b v
---
>       fcNil  :: v,
302a302
>       fcCons :: b -> FunctionCache b v
311d310
< _fib ∷ Integer → Integer
312d310
< _fib = memoFix $ \fib n → case n of
313d310
<   0 → 1
314d310
<   1 → 1
315c311
<   _ → fib (n - 1) + fib (n - 2)
---
> _fib :: Integer -> Integer
315a312
> _fib = memoFix $ \fib n -> case n of
315a313
>   0 -> 1
315a314
>   1 -> 1
315a315
>   _ -> fib (n - 1) + fib (n - 2)
319d318
< _isNot       ∷ (Bool → Bool) → Bool
320c319
< _isNot       = memoize $ \f →
---
> _isNot       :: (Bool -> Bool) -> Bool
320a320
> _isNot       = memoize $ \f ->
325d324
< _countTrue ∷ (Bool → Bool → Bool) → Integer
326c325
< _countTrue = memoize $ \f →
---
> _countTrue :: (Bool -> Bool -> Bool) -> Integer
326a326
> _countTrue = memoize $ \f ->
329a330
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
      DeriveFunctor,
      GeneralizedNewtypeDeriving,
      TemplateHaskell,
      UnicodeSyntax
  #-}
{- |
  A function memoization library.

  This includes a class for memoizable argument types and a Template
  Haskell expander for deriving instances of the class.

  Note that most memoization in this style relies on assumptions about
  the implementation of non-strictness (as laziness) that are not
  guaranteed by the semantics. However, it appears to work.
-}
module Data.Function.Memoize (
  -- * Memoization class
  Memoizable(..),
  -- ** Operations
  -- *** Higher-arity memoize
  memoize2, memoize3, memoize4, memoize5, memoize6, memoize7,
  -- *** Memoizing open recursion
  memoFix, memoFix2, memoFix3, memoFix4, memoFix5, memoFix6, memoFix7,
  -- *** Tracing memoization
  traceMemoize,

  -- * For making instances for finite types
  memoizeFinite,

  -- * Deriving 'Memoizable'
  deriveMemoizable, deriveMemoizableParams, deriveMemoize,
) where

import Control.Applicative
import Control.Monad
import Debug.Trace

import Data.Function.Memoize.Class
import Data.Function.Memoize.TH

-- | Memoize a two argument function
memoize2 ∷ (Memoizable a, Memoizable b) ⇒
           (a → b → v) → a → b → v
memoize2 v = memoize (memoize . v)

-- | Memoize a three argument function
memoize3 ∷ (Memoizable a, Memoizable b, Memoizable c) ⇒
           (a → b → c → v) → a → b → c → v
memoize3 v = memoize (memoize2 . v)

-- | Memoize a four argument function
memoize4 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d) ⇒
           (a → b → c → d → v) →
           a → b → c → d → v
memoize4 v = memoize (memoize3 . v)

-- | Memoize a five argument function
memoize5 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e) ⇒
           (a → b → c → d → e → v) →
           a → b → c → d → e → v
memoize5 v = memoize (memoize4 . v)

-- | Memoize a six argument function
memoize6 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f) ⇒
           (a → b → c → d → e → f → v) →
           a → b → c → d → e → f → v
memoize6 v = memoize (memoize5 . v)

-- | Memoize a seven argument function
memoize7 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f, Memoizable g) ⇒
           (a → b → c → d → e → f → g → v) →
           a → b → c → d → e → f → g → v
memoize7 v = memoize (memoize6 . v)

-- | Memoizes the least fixed point of a function. This is like
-- 'Data.Function.fix', but it passes the fixed function a memoized
-- version of itself, so this memoizes using all recursive calls as well.
memoFix ∷ Memoizable a ⇒ ((a → v) → a → v) → a → v
memoFix ff = f where f = memoize (ff f)

-- | Two argument version of 'memoFix'.
memoFix2 ∷ (Memoizable a, Memoizable b) ⇒
           ((a → b → v) → a → b → v) → a → b → v
memoFix2 ff = f where f = memoize2 (ff f)

-- | Three argument version of 'memoFix'.
memoFix3 ∷ (Memoizable a, Memoizable b, Memoizable c) ⇒
           ((a → b → c → v) → a → b → c → v) → a → b → c → v
memoFix3 ff = f where f = memoize3 (ff f)

-- | Four argument version of 'memoFix'.
memoFix4 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d) ⇒
           ((a → b → c → d → v) → (a → b → c → d → v)) →
           a → b → c → d → v
memoFix4 ff = f where f = memoize4 (ff f)

-- | Five argument version of 'memoFix'.
memoFix5 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e) ⇒
           ((a → b → c → d → e → v) → (a → b → c → d → e → v)) →
           a → b → c → d → e → v
memoFix5 ff = f where f = memoize5 (ff f)

-- | Six argument version of 'memoFix'.
memoFix6 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f) ⇒
           ((a → b → c → d → e → f → v) → (a → b → c → d → e → f → v)) →
           a → b → c → d → e → f → v
memoFix6 ff = f where f = memoize6 (ff f)

-- | Seven argument version of 'memoFix'.
memoFix7 ∷ (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f, Memoizable g) ⇒
           ((a → b → c → d → e → f → g → v) → (a → b → c → d → e → f → g → v)) →
           a → b → c → d → e → f → g → v
memoFix7 ff = f where f = memoize7 (ff f)

-- | Give a one-argument function whose argument satisfies 'Show',
--   this memoizes the function such that the argument is shown (using
--   'Debug.Trace.trace') only when the function has to be applied, as
--   opposed to when the answer is available in the memo cache.
traceMemoize ∷ (Memoizable a, Show a) ⇒ (a → b) → a → b
traceMemoize f = memoize (\a → traceShow a (f a))

---
--- Derived instances
---

deriveMemoizable ''()
deriveMemoizable ''Bool
deriveMemoizable ''Ordering
deriveMemoizable ''Maybe
deriveMemoizable ''Either
deriveMemoizable ''[]

deriveMemoizable ''(,)
deriveMemoizable ''(,,)
deriveMemoizable ''(,,,)
deriveMemoizable ''(,,,,)
deriveMemoizable ''(,,,,,)
deriveMemoizable ''(,,,,,,)
deriveMemoizable ''(,,,,,,,)
deriveMemoizable ''(,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,,,)

---
--- Binary-tree based memo caches
---

-- Used for both 'Integer' and arbitrary 'Int'-like types.

data BinaryTreeCache v
 = BinaryTreeCache {
    btValue         ∷ v,
    btLeft, btRight ∷ BinaryTreeCache v
   }
   deriving Functor

---
--- 'Integer' memoization
---

instance Memoizable Integer where
  memoize f = integerLookup (f <$> theIntegers)

-- | An integer cache stores a value for 0 and separate caches for the
--   positive and negative integers.
data IntegerCache v
  = IntegerCache {
      icZero                 ∷ v,
      icNegative, icPositive ∷ PosIntCache v
    }
  deriving Functor

-- | A positive integer cache is represented as a little-ending bitwise
--   trie
type PosIntCache v = BinaryTreeCache v

theIntegers ∷ IntegerCache Integer
theIntegers
  = IntegerCache {
      icZero     = 0,
      icNegative = negate <$> thePosInts,
      icPositive = thePosInts
    }

thePosInts ∷ PosIntCache Integer
thePosInts =
  BinaryTreeCache {
   btValue = 1,
   btLeft  = fmap (* 2) thePosInts,
   btRight = fmap (succ . (* 2)) thePosInts
 }

integerLookup ∷ IntegerCache v → Integer → v
integerLookup cache n =
  case n `compare` 0 of
    EQ → icZero cache
    GT → posIntLookup (icPositive cache) n
    LT → posIntLookup (icNegative cache) (negate n)

-- PRECONDITION: @n@ is a positive 'Integer'
posIntLookup ∷ PosIntCache v → Integer → v
posIntLookup cache 1 = btValue cache
posIntLookup cache n
  | even n    = posIntLookup (btLeft cache) (n `div` 2)
  | otherwise = posIntLookup (btRight cache) (n `div` 2)

---
--- Enumerable types using binary search trees
---

newtype Finite a = ToFinite { fromFinite ∷ a }
  deriving (Eq, Bounded, Enum)

instance (Bounded a, Enum a) ⇒ Memoizable (Finite a) where
  memoize f = finiteLookup (f <$> theFinites)

-- | For finite 'Int'-like types, we use a balanced binary search tree
--   indexed to every element from 'minBound' to 'maxBound'
theFinites ∷ (Bounded a, Enum a) ⇒ BinaryTreeCache a
theFinites = loop minBound maxBound where
  loop start stop =
    BinaryTreeCache {
      btValue = mean,
      btLeft  = loop start (pred mean),
      btRight = loop (succ mean) stop
    }
    where mean = meanFinite start stop

finiteLookup ∷ (Bounded a, Enum a) ⇒ BinaryTreeCache v → a → v
finiteLookup cache0 a0 =
  loop start0 stop0 cache0 where
    start0 = fromEnum (minBound `asTypeOf` a0)
    stop0  = fromEnum (maxBound `asTypeOf` a0)
    a      = fromEnum a0
    loop start stop cache =
      let mean = meanFinite start stop in
        case a `compare` mean of
          EQ → btValue cache
          LT → loop start (pred mean) (btLeft cache)
          GT → loop (succ mean) stop (btRight cache)

meanFinite     ∷ (Bounded a, Enum a) ⇒ a → a → a
meanFinite a b = toEnum (ia `div` 2 + ib `div` 2 +
                           if odd ia && odd ib then 1 else 0)
  where
    ia = fromEnum a
    ib = fromEnum b

-- | Can be used to memoize over any "finite" type satisfying
-- 'Enum' and 'Bounded'.  This builds a binary search tree, treating
-- the memoized type as isomorphic to a range of 'Int', so it will be
-- only as efficient as 'toEnum', 'fromEnum', 'succ', and 'pred'.
--
-- This can be used to make instances for finite types. For example, the
-- instances for 'Int' and 'Char' are declared as:
--
-- @
--   instance Memoizable Int where memoize = memoizeFinite
--   instance Memoizable Char where memoize = memoizeFinite
-- @
memoizeFinite   ∷ (Enum a, Bounded a) ⇒ (a → v) → a → v
memoizeFinite f = memoize (f . fromFinite) . ToFinite

instance Memoizable Int where memoize = memoizeFinite
instance Memoizable Char where memoize = memoizeFinite

---
--- Functions
---

instance (Eq a, Bounded a, Enum a, Memoizable b) ⇒ Memoizable (a → b) where
  memoize = functionLookup . theFunctions

functionLookup ∷ (Eq a, Bounded a, Enum a, Memoizable b) ⇒
                 FunctionCache b v → (a → b) → v
functionLookup cache f =
  fcNil (foldl fcCons cache (f <$> [minBound .. maxBound]))

theFunctions ∷ (Eq a, Bounded a, Enum a, Memoizable b) ⇒
               ((a → b) → v) → FunctionCache b v
theFunctions f =
  FunctionCache {
    fcNil  = f undefined,
    fcCons = memoize (\b → theFunctions (f . extend b))
  }
    where
      extend b g a
        | a == minBound = b
        | otherwise     = g (pred a)

data FunctionCache b v
  = FunctionCache {
      fcNil  ∷ v,
      fcCons ∷ b → FunctionCache b v
    }

---
--- Example functions
---

-- Memoize on 'Integer'. If memoization doesn't work, this will be
-- horribly slow.
_fib ∷ Integer → Integer
_fib = memoFix $ \fib n → case n of
  0 → 1
  1 → 1
  _ → fib (n - 1) + fib (n - 2)

-- Memoize on a function.  The use of 'trace' will indicate when
-- the function is called to fill in the memo cache.
_isNot       ∷ (Bool → Bool) → Bool
_isNot       = memoize $ \f →
  trace "_isNot" $
    f True == False && f False == True

-- Memoize on a curried function!
_countTrue ∷ (Bool → Bool → Bool) → Integer
_countTrue = memoize $ \f →
  trace "_countTrue" $
    toInteger (length (f <$> [False,True] <*> [False,True] >>= guard))

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
      DeriveFunctor,
      GeneralizedNewtypeDeriving,
      TemplateHaskell,
      UnicodeSyntax
  #-}
{- |
  A function memoization library.

  This includes a class for memoizable argument types and a Template
  Haskell expander for deriving instances of the class.

  Note that most memoization in this style relies on assumptions about
  the implementation of non-strictness (as laziness) that are not
  guaranteed by the semantics. However, it appears to work.
-}
module Data.Function.Memoize (
  -- * Memoization class
  Memoizable(..),
  -- ** Operations
  -- *** Higher-arity memoize
  memoize2, memoize3, memoize4, memoize5, memoize6, memoize7,
  -- *** Memoizing open recursion
  memoFix, memoFix2, memoFix3, memoFix4, memoFix5, memoFix6, memoFix7,
  -- *** Tracing memoization
  traceMemoize,

  -- * For making instances for finite types
  memoizeFinite,

  -- * Deriving 'Memoizable'
  deriveMemoizable, deriveMemoizableParams, deriveMemoize,
) where

import Control.Applicative
import Control.Monad
import Debug.Trace

import Data.Function.Memoize.Class
import Data.Function.Memoize.TH

-- | Memoize a two argument function
memoize2 :: (Memoizable a, Memoizable b) =>
           (a -> b -> v) -> a -> b -> v
memoize2 v = memoize (memoize . v)

-- | Memoize a three argument function
memoize3 :: (Memoizable a, Memoizable b, Memoizable c) =>
           (a -> b -> c -> v) -> a -> b -> c -> v
memoize3 v = memoize (memoize2 . v)

-- | Memoize a four argument function
memoize4 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d) =>
           (a -> b -> c -> d -> v) ->
           a -> b -> c -> d -> v
memoize4 v = memoize (memoize3 . v)

-- | Memoize a five argument function
memoize5 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e) =>
           (a -> b -> c -> d -> e -> v) ->
           a -> b -> c -> d -> e -> v
memoize5 v = memoize (memoize4 . v)

-- | Memoize a six argument function
memoize6 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f) =>
           (a -> b -> c -> d -> e -> f -> v) ->
           a -> b -> c -> d -> e -> f -> v
memoize6 v = memoize (memoize5 . v)

-- | Memoize a seven argument function
memoize7 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f, Memoizable g) =>
           (a -> b -> c -> d -> e -> f -> g -> v) ->
           a -> b -> c -> d -> e -> f -> g -> v
memoize7 v = memoize (memoize6 . v)

-- | Memoizes the least fixed point of a function. This is like
-- 'Data.Function.fix', but it passes the fixed function a memoized
-- version of itself, so this memoizes using all recursive calls as well.
memoFix :: Memoizable a => ((a -> v) -> a -> v) -> a -> v
memoFix ff = f where f = memoize (ff f)

-- | Two argument version of 'memoFix'.
memoFix2 :: (Memoizable a, Memoizable b) =>
           ((a -> b -> v) -> a -> b -> v) -> a -> b -> v
memoFix2 ff = f where f = memoize2 (ff f)

-- | Three argument version of 'memoFix'.
memoFix3 :: (Memoizable a, Memoizable b, Memoizable c) =>
           ((a -> b -> c -> v) -> a -> b -> c -> v) -> a -> b -> c -> v
memoFix3 ff = f where f = memoize3 (ff f)

-- | Four argument version of 'memoFix'.
memoFix4 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d) =>
           ((a -> b -> c -> d -> v) -> (a -> b -> c -> d -> v)) ->
           a -> b -> c -> d -> v
memoFix4 ff = f where f = memoize4 (ff f)

-- | Five argument version of 'memoFix'.
memoFix5 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e) =>
           ((a -> b -> c -> d -> e -> v) -> (a -> b -> c -> d -> e -> v)) ->
           a -> b -> c -> d -> e -> v
memoFix5 ff = f where f = memoize5 (ff f)

-- | Six argument version of 'memoFix'.
memoFix6 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f) =>
           ((a -> b -> c -> d -> e -> f -> v) -> (a -> b -> c -> d -> e -> f -> v)) ->
           a -> b -> c -> d -> e -> f -> v
memoFix6 ff = f where f = memoize6 (ff f)

-- | Seven argument version of 'memoFix'.
memoFix7 :: (Memoizable a, Memoizable b, Memoizable c, Memoizable d,
            Memoizable e, Memoizable f, Memoizable g) =>
           ((a -> b -> c -> d -> e -> f -> g -> v) -> (a -> b -> c -> d -> e -> f -> g -> v)) ->
           a -> b -> c -> d -> e -> f -> g -> v
memoFix7 ff = f where f = memoize7 (ff f)

-- | Give a one-argument function whose argument satisfies 'Show',
--   this memoizes the function such that the argument is shown (using
--   'Debug.Trace.trace') only when the function has to be applied, as
--   opposed to when the answer is available in the memo cache.
traceMemoize :: (Memoizable a, Show a) => (a -> b) -> a -> b
traceMemoize f = memoize (\a -> traceShow a (f a))

---
--- Derived instances
---

deriveMemoizable ''()
deriveMemoizable ''Bool
deriveMemoizable ''Ordering
deriveMemoizable ''Maybe
deriveMemoizable ''Either
deriveMemoizable ''[]

deriveMemoizable ''(,)
deriveMemoizable ''(,,)
deriveMemoizable ''(,,,)
deriveMemoizable ''(,,,,)
deriveMemoizable ''(,,,,,)
deriveMemoizable ''(,,,,,,)
deriveMemoizable ''(,,,,,,,)
deriveMemoizable ''(,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,,)
deriveMemoizable ''(,,,,,,,,,,,)

---
--- Binary-tree based memo caches
---

-- Used for both 'Integer' and arbitrary 'Int'-like types.

data BinaryTreeCache v
 = BinaryTreeCache {
    btValue         :: v,
    btLeft, btRight :: BinaryTreeCache v
   }
   deriving Functor

---
--- 'Integer' memoization
---

instance Memoizable Integer where
  memoize f = integerLookup (f <$> theIntegers)

-- | An integer cache stores a value for 0 and separate caches for the
--   positive and negative integers.
data IntegerCache v
  = IntegerCache {
      icZero                 :: v,
      icNegative, icPositive :: PosIntCache v
    }
  deriving Functor

-- | A positive integer cache is represented as a little-ending bitwise
--   trie
type PosIntCache v = BinaryTreeCache v

theIntegers :: IntegerCache Integer
theIntegers
  = IntegerCache {
      icZero     = 0,
      icNegative = negate <$> thePosInts,
      icPositive = thePosInts
    }

thePosInts :: PosIntCache Integer
thePosInts =
  BinaryTreeCache {
   btValue = 1,
   btLeft  = fmap (* 2) thePosInts,
   btRight = fmap (succ . (* 2)) thePosInts
 }

integerLookup :: IntegerCache v -> Integer -> v
integerLookup cache n =
  case n `compare` 0 of
    EQ -> icZero cache
    GT -> posIntLookup (icPositive cache) n
    LT -> posIntLookup (icNegative cache) (negate n)

-- PRECONDITION: @n@ is a positive 'Integer'
posIntLookup :: PosIntCache v -> Integer -> v
posIntLookup cache 1 = btValue cache
posIntLookup cache n
  | even n    = posIntLookup (btLeft cache) (n `div` 2)
  | otherwise = posIntLookup (btRight cache) (n `div` 2)

---
--- Enumerable types using binary search trees
---

newtype Finite a = ToFinite { fromFinite :: a }
  deriving (Eq, Bounded, Enum)

instance (Bounded a, Enum a) => Memoizable (Finite a) where
  memoize f = finiteLookup (f <$> theFinites)

-- | For finite 'Int'-like types, we use a balanced binary search tree
--   indexed to every element from 'minBound' to 'maxBound'
theFinites :: (Bounded a, Enum a) => BinaryTreeCache a
theFinites = loop minBound maxBound where
  loop start stop =
    BinaryTreeCache {
      btValue = mean,
      btLeft  = loop start (pred mean),
      btRight = loop (succ mean) stop
    }
    where mean = meanFinite start stop

finiteLookup :: (Bounded a, Enum a) => BinaryTreeCache v -> a -> v
finiteLookup cache0 a0 =
  loop start0 stop0 cache0 where
    start0 = fromEnum (minBound `asTypeOf` a0)
    stop0  = fromEnum (maxBound `asTypeOf` a0)
    a      = fromEnum a0
    loop start stop cache =
      let mean = meanFinite start stop in
        case a `compare` mean of
          EQ -> btValue cache
          LT -> loop start (pred mean) (btLeft cache)
          GT -> loop (succ mean) stop (btRight cache)

meanFinite     :: (Bounded a, Enum a) => a -> a -> a
meanFinite a b = toEnum (ia `div` 2 + ib `div` 2 +
                           if odd ia && odd ib then 1 else 0)
  where
    ia = fromEnum a
    ib = fromEnum b

-- | Can be used to memoize over any "finite" type satisfying
-- 'Enum' and 'Bounded'.  This builds a binary search tree, treating
-- the memoized type as isomorphic to a range of 'Int', so it will be
-- only as efficient as 'toEnum', 'fromEnum', 'succ', and 'pred'.
--
-- This can be used to make instances for finite types. For example, the
-- instances for 'Int' and 'Char' are declared as:
--
-- @
--   instance Memoizable Int where memoize = memoizeFinite
--   instance Memoizable Char where memoize = memoizeFinite
-- @
memoizeFinite   :: (Enum a, Bounded a) => (a -> v) -> a -> v
memoizeFinite f = memoize (f . fromFinite) . ToFinite

instance Memoizable Int where memoize = memoizeFinite
instance Memoizable Char where memoize = memoizeFinite

---
--- Functions
---

instance (Eq a, Bounded a, Enum a, Memoizable b) => Memoizable (a -> b) where
  memoize = functionLookup . theFunctions

functionLookup :: (Eq a, Bounded a, Enum a, Memoizable b) =>
                 FunctionCache b v -> (a -> b) -> v
functionLookup cache f =
  fcNil (foldl fcCons cache (f <$> [minBound .. maxBound]))

theFunctions :: (Eq a, Bounded a, Enum a, Memoizable b) =>
               ((a -> b) -> v) -> FunctionCache b v
theFunctions f =
  FunctionCache {
    fcNil  = f undefined,
    fcCons = memoize (\b -> theFunctions (f . extend b))
  }
    where
      extend b g a
        | a == minBound = b
        | otherwise     = g (pred a)

data FunctionCache b v
  = FunctionCache {
      fcNil  :: v,
      fcCons :: b -> FunctionCache b v
    }

---
--- Example functions
---

-- Memoize on 'Integer'. If memoization doesn't work, this will be
-- horribly slow.
_fib :: Integer -> Integer
_fib = memoFix $ \fib n -> case n of
  0 -> 1
  1 -> 1
  _ -> fib (n - 1) + fib (n - 2)

-- Memoize on a function.  The use of 'trace' will indicate when
-- the function is called to fill in the memo cache.
_isNot       :: (Bool -> Bool) -> Bool
_isNot       = memoize $ \f ->
  trace "_isNot" $
    f True == False && f False == True

-- Memoize on a curried function!
_countTrue :: (Bool -> Bool -> Bool) -> Integer
_countTrue = memoize $ \f ->
  trace "_countTrue" $
    toInteger (length (f <$> [False,True] <*> [False,True] >>= guard))


</pre>