<a href="BigEndian.hs11477222941070477904.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BigNum.hs19047979421400285365.out.html">next</a></br></br><pre>27d26
< import "base" Data.Bool     ( otherwise )
28d26
< import "base" Data.Function ( ($), const, fix )
29d26
< import "base" Data.Functor  ( (<$>) )
30d26
< import "base" Data.Maybe    ( Maybe(Nothing, Just) )
31d26
< import "base" Prelude       ( Integral, (-) )
32d26
< import "base-unicode-symbols"       Data.Eq.Unicode       ( (≡) )
33d26
< import "base-unicode-symbols"       Data.Function.Unicode ( (∘) )
34d26
< import "base-unicode-symbols"       Data.List.Unicode     ( (∈) )
35d26
< import "base-unicode-symbols"       Data.Monoid.Unicode   ( (⊕) )
36d26
< import "base-unicode-symbols"       Prelude.Unicode       ( ℤ )
37d26
< import "containers-unicode-symbols" Data.Map.Unicode      ( (∪) )
38d26
< import "this"                       Text.Numeral
39d26
< import "this"                       Text.Numeral.Misc     ( dec )
40d26
< import qualified "containers" Data.Map as M ( Map, fromList, lookup )
41d26
< import qualified "this"       Text.Numeral.Exp as E
42c27
< import "text" Data.Text ( Text )
---
> import  Data.Bool     ( otherwise )
42a28
> import  Data.Function ( ($), const, fix )
42a29
> import  Data.Functor  ( (<$>) )
42a30
> import  Data.Maybe    ( Maybe(Nothing, Just) )
42a31
> import  Prelude       ( Integral, (-) )
42a32
> import        Data.Eq.Unicode       ( (≡) )
42a33
> import        Data.Function.Unicode ( (∘) )
42a34
> import        Data.List.Unicode     ( (∈) )
42a35
> import        Data.Monoid.Unicode   ( (⊕) )
42a36
> import        Prelude.Unicode       ( ℤ )
42a37
> import  Data.Map.Unicode      ( (∪) )
42a38
> import                        Text.Numeral
42a39
> import                        Text.Numeral.Misc     ( dec )
42a40
> import qualified  Data.Map as M ( Map, fromList, lookup )
42a41
> import qualified        Text.Numeral.Exp as E
42a42
> import  Data.Text ( Text )
49c49
< cardinal ∷ (Integral α) ⇒ inf → α → Maybe Text
---
> cardinal :: (Integral α) => inf -> α -> Maybe Text
52c52
< rule ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β) ⇒ Rule α β
---
> rule :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β) => Rule α β
65c65
< cardinalRepr ∷ Repr inf
---
> cardinalRepr :: Repr inf
67d66
<     defaultRepr { reprValue = \_ n → M.lookup n symMap
68d66
<                 , reprAdd   = Just $ \_ _ _ → ""
69c67
<                 , reprMul   = Just $ \_ _ _ → ""
---
>     defaultRepr { reprValue = \_ n -> M.lookup n symMap
69a68
>                 , reprAdd   = Just $ \_ _ _ -> ""
69a69
>                 , reprMul   = Just $ \_ _ _ -> ""
72c72
< symMap ∷ (Integral α) ⇒ M.Map α (Ctx (Exp i) → Text)
---
> symMap :: (Integral α) => M.Map α (Ctx (Exp i) -> Text)
83d82
<          , (10, \c → case c of
84d82
<                        CtxAdd _ (Lit 100) _              → "deci"
85d82
<                        CtxMul _ _ (CtxAdd L (Lit 100) _) → "ginta"
86d82
<                        CtxMul {}                         → "gint"
87c83
<                        _                                 → "dec"
---
>          , (10, \c -> case c of
87a84
>                        CtxAdd _ (Lit 100) _              -> "deci"
87a85
>                        CtxMul _ _ (CtxAdd L (Lit 100) _) -> "ginta"
87a86
>                        CtxMul {}                         -> "gint"
87a87
>                        _                                 -> "dec"
89c89
<          , (100, \c → case c of
---
>          , (100, \c -> case c of
91d90
<                             | n ∈ [2,3,6] → "cent"
92d90
<                             | otherwise   → "gent"
93c91
<                         _                 → "cent"
---
>                             | n ∈ [2,3,6] -> "cent"
93a92
>                             | otherwise   -> "gent"
93a93
>                         _                 -> "cent"
98c98
< forms ∷ Text → Text → Text → Text → Text → Ctx (Exp i) → Text
---
> forms :: Text -> Text -> Text -> Text -> Text -> Ctx (Exp i) -> Text
101d100
<       CtxAdd _ (Lit 10)  _ → a1
102d100
<       CtxAdd {}            → a2
103d100
<       CtxMul _ (Lit 10)  _ → m1
104d100
<       CtxMul {}            → m2
105c101
<       _                    → t
---
>       CtxAdd _ (Lit 10)  _ -> a1
105a102
>       CtxAdd {}            -> a2
105a103
>       CtxMul _ (Lit 10)  _ -> m1
105a104
>       CtxMul {}            -> m2
105a105
>       _                    -> t
116d115
<                    → Ctx (Exp i) -- ^ Context.
117c116
<                    → Text        -- ^ Postfix representation.
---
>                    -> Ctx (Exp i) -- ^ Context.
117a117
>                    -> Text        -- ^ Postfix representation.
119d118
< scaleRepr ∷ PostfixRepr i
120d118
<           → [(ℤ, Ctx (Exp i) → Text)] -- ^ Additional symbol map entries.
121c119
<           → ScaleRepr i
---
> scaleRepr :: PostfixRepr i
121a120
>           -> [(ℤ, Ctx (Exp i) -> Text)] -- ^ Additional symbol map entries.
121a121
>           -> ScaleRepr i
124c124
<       repr = cardinalRepr { reprValue = \_ n → M.lookup n syms' }
---
>       repr = cardinalRepr { reprValue = \_ n -> M.lookup n syms' }
127d126
< pelletierRepr ∷ PostfixRepr i -- ^Postfix for offset 0 names.
128d126
<               → PostfixRepr i -- ^Postfix for offset 3 names.
129d126
<               → [(ℤ, Ctx (Exp i) → Text)] -- ^ Additional symbol map entries.
130c127
<               → ScaleRepr i
---
> pelletierRepr :: PostfixRepr i -- ^Postfix for offset 0 names.
130a128
>               -> PostfixRepr i -- ^Postfix for offset 3 names.
130a129
>               -> [(ℤ, Ctx (Exp i) -> Text)] -- ^ Additional symbol map entries.
130a130
>               -> ScaleRepr i
136c136
< quantityName ∷ Text → Text → PostfixRepr i
---
> quantityName :: Text -> Text -> PostfixRepr i
139d138
<       CtxMul _ (Lit 1) _ → s
140d138
<       CtxMul {}          → p
141c139
<       _                  → s
---
>       CtxMul _ (Lit 1) _ -> s
141a140
>       CtxMul {}          -> p
141a141
>       _                  -> s
143c143
< ordQuantityName ∷ Text → Text → Text → Text → PostfixRepr i
---
> ordQuantityName :: Text -> Text -> Text -> Text -> PostfixRepr i
146d145
<       CtxMul _ (Lit 1) _ | outside   → so
147d145
<                          | otherwise → sc
148d145
<       CtxMul {}          | outside   → po
149d145
<                          | otherwise → pc
150d145
<       _                  | outside   → so
151c146
<                          | otherwise → sc
---
>       CtxMul _ (Lit 1) _ | outside   -> so
151a147
>                          | otherwise -> sc
151a148
>       CtxMul {}          | outside   -> po
151a149
>                          | otherwise -> pc
151a150
>       _                  | outside   -> so
151a151
>                          | otherwise -> sc
153a154
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , OverloadedStrings
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.BigNum
  ( cardinal
  , rule
  , cardinalRepr
  , symMap
  , forms

  , PostfixRepr
  , scaleRepr
  , pelletierRepr

  , quantityName
  , ordQuantityName
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import "base" Data.Bool     ( otherwise )
import "base" Data.Function ( ($), const, fix )
import "base" Data.Functor  ( (<$>) )
import "base" Data.Maybe    ( Maybe(Nothing, Just) )
import "base" Prelude       ( Integral, (-) )
import "base-unicode-symbols"       Data.Eq.Unicode       ( (≡) )
import "base-unicode-symbols"       Data.Function.Unicode ( (∘) )
import "base-unicode-symbols"       Data.List.Unicode     ( (∈) )
import "base-unicode-symbols"       Data.Monoid.Unicode   ( (⊕) )
import "base-unicode-symbols"       Prelude.Unicode       ( ℤ )
import "containers-unicode-symbols" Data.Map.Unicode      ( (∪) )
import "this"                       Text.Numeral
import "this"                       Text.Numeral.Misc     ( dec )
import qualified "containers" Data.Map as M ( Map, fromList, lookup )
import qualified "this"       Text.Numeral.Exp as E
import "text" Data.Text ( Text )


--------------------------------------------------------------------------------
-- Language of Big Numbers
--------------------------------------------------------------------------------

cardinal ∷ (Integral α) ⇒ inf → α → Maybe Text
cardinal inf = render cardinalRepr inf ∘ (pos $ fix rule)

rule ∷ (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β) ⇒ Rule α β
rule = findRule (   1, lit         )
              [ (  11, add   10 L  )
              , (  20, mul   10 L L)
              , ( 100, lit         )
              , ( 101, add  100 L  )
              , ( 200, mul  100 R L)
              , (1000, lit         )
              , (1001, add 1000 L  )
              , (2000, mul 1000 R L)
              ]
                (dec 4 - 1)

cardinalRepr ∷ Repr inf
cardinalRepr =
    defaultRepr { reprValue = \_ n → M.lookup n symMap
                , reprAdd   = Just $ \_ _ _ → ""
                , reprMul   = Just $ \_ _ _ → ""
                }

symMap ∷ (Integral α) ⇒ M.Map α (Ctx (Exp i) → Text)
symMap = M.fromList
         [ (1, forms "m"     "un"       "un"       ""        "")
         , (2, forms "b"     "duo"      "duo"      "vi"      "du")
         , (3, forms "tr"    "tre"      "tres"     "tri"     "tre")
         , (4, forms "quadr" "quattuor" "quattuor" "quadra"  "quadri")
         , (5, forms "quint" "quin"     "quinqua"  "quinqua" "quin")
         , (6, forms "sext"  "sex"      "ses"      "sexa"    "ses")
         , (7, forms "sept"  "septen"   "septem"   "septua"  "septin")
         , (8, forms "oct"   "octo"     "octo"     "octo"    "octin")
         , (9, forms "non"   "novem"    "novem"    "nona"    "non")
         , (10, \c → case c of
                       CtxAdd _ (Lit 100) _              → "deci"
                       CtxMul _ _ (CtxAdd L (Lit 100) _) → "ginta"
                       CtxMul {}                         → "gint"
                       _                                 → "dec"
           )
         , (100, \c → case c of
                        CtxMul _ (Lit n) _
                            | n ∈ [2,3,6] → "cent"
                            | otherwise   → "gent"
                        _                 → "cent"
           )
         , (1000, const "millin")
         ]

forms ∷ Text → Text → Text → Text → Text → Ctx (Exp i) → Text
forms t a1 a2 m1 m2 ctx =
    case ctx of
      CtxAdd _ (Lit 10)  _ → a1
      CtxAdd {}            → a2
      CtxMul _ (Lit 10)  _ → m1
      CtxMul {}            → m2
      _                    → t


--------------------------------------------------------------------------------
-- Representations of scales
--------------------------------------------------------------------------------

-- | Function that renders the postfix part of a large number name. Or
-- more simply put, this calculates the \"illion\" part of
-- \"million\", \"billion\", etc.
type PostfixRepr i = i           -- ^ Current inflection.
                   → Ctx (Exp i) -- ^ Context.
                   → Text        -- ^ Postfix representation.

scaleRepr ∷ PostfixRepr i
          → [(ℤ, Ctx (Exp i) → Text)] -- ^ Additional symbol map entries.
          → ScaleRepr i
scaleRepr pf syms inf _ _ e ctx = (⊕ pf inf ctx) <$> render repr inf e
    where
      repr = cardinalRepr { reprValue = \_ n → M.lookup n syms' }
      syms' = M.fromList syms ∪ symMap

pelletierRepr ∷ PostfixRepr i -- ^Postfix for offset 0 names.
              → PostfixRepr i -- ^Postfix for offset 3 names.
              → [(ℤ, Ctx (Exp i) → Text)] -- ^ Additional symbol map entries.
              → ScaleRepr i
pelletierRepr pf0 pf3 syms inf
              b o e ctx | o ≡ 0 = scaleRepr pf0 syms inf b o e ctx
                        | o ≡ 3 = scaleRepr pf3 syms inf b o e ctx
                        | otherwise = Nothing

quantityName ∷ Text → Text → PostfixRepr i
quantityName s p _ ctx =
    case ctx of
      CtxMul _ (Lit 1) _ → s
      CtxMul {}          → p
      _                  → s

ordQuantityName ∷ Text → Text → Text → Text → PostfixRepr i
ordQuantityName sc so pc po _ ctx =
    case ctx of
      CtxMul _ (Lit 1) _ | outside   → so
                         | otherwise → sc
      CtxMul {}          | outside   → po
                         | otherwise → pc
      _                  | outside   → so
                         | otherwise → sc
    where
      outside = isOutside R ctx
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , OverloadedStrings
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.BigNum
  ( cardinal
  , rule
  , cardinalRepr
  , symMap
  , forms

  , PostfixRepr
  , scaleRepr
  , pelletierRepr

  , quantityName
  , ordQuantityName
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import  Data.Bool     ( otherwise )
import  Data.Function ( ($), const, fix )
import  Data.Functor  ( (<$>) )
import  Data.Maybe    ( Maybe(Nothing, Just) )
import  Prelude       ( Integral, (-) )
import        Data.Eq.Unicode       ( (≡) )
import        Data.Function.Unicode ( (∘) )
import        Data.List.Unicode     ( (∈) )
import        Data.Monoid.Unicode   ( (⊕) )
import        Prelude.Unicode       ( ℤ )
import  Data.Map.Unicode      ( (∪) )
import                        Text.Numeral
import                        Text.Numeral.Misc     ( dec )
import qualified  Data.Map as M ( Map, fromList, lookup )
import qualified        Text.Numeral.Exp as E
import  Data.Text ( Text )


--------------------------------------------------------------------------------
-- Language of Big Numbers
--------------------------------------------------------------------------------

cardinal :: (Integral α) => inf -> α -> Maybe Text
cardinal inf = render cardinalRepr inf ∘ (pos $ fix rule)

rule :: (Integral α, E.Unknown β, E.Lit β, E.Add β, E.Mul β) => Rule α β
rule = findRule (   1, lit         )
              [ (  11, add   10 L  )
              , (  20, mul   10 L L)
              , ( 100, lit         )
              , ( 101, add  100 L  )
              , ( 200, mul  100 R L)
              , (1000, lit         )
              , (1001, add 1000 L  )
              , (2000, mul 1000 R L)
              ]
                (dec 4 - 1)

cardinalRepr :: Repr inf
cardinalRepr =
    defaultRepr { reprValue = \_ n -> M.lookup n symMap
                , reprAdd   = Just $ \_ _ _ -> ""
                , reprMul   = Just $ \_ _ _ -> ""
                }

symMap :: (Integral α) => M.Map α (Ctx (Exp i) -> Text)
symMap = M.fromList
         [ (1, forms "m"     "un"       "un"       ""        "")
         , (2, forms "b"     "duo"      "duo"      "vi"      "du")
         , (3, forms "tr"    "tre"      "tres"     "tri"     "tre")
         , (4, forms "quadr" "quattuor" "quattuor" "quadra"  "quadri")
         , (5, forms "quint" "quin"     "quinqua"  "quinqua" "quin")
         , (6, forms "sext"  "sex"      "ses"      "sexa"    "ses")
         , (7, forms "sept"  "septen"   "septem"   "septua"  "septin")
         , (8, forms "oct"   "octo"     "octo"     "octo"    "octin")
         , (9, forms "non"   "novem"    "novem"    "nona"    "non")
         , (10, \c -> case c of
                       CtxAdd _ (Lit 100) _              -> "deci"
                       CtxMul _ _ (CtxAdd L (Lit 100) _) -> "ginta"
                       CtxMul {}                         -> "gint"
                       _                                 -> "dec"
           )
         , (100, \c -> case c of
                        CtxMul _ (Lit n) _
                            | n ∈ [2,3,6] -> "cent"
                            | otherwise   -> "gent"
                        _                 -> "cent"
           )
         , (1000, const "millin")
         ]

forms :: Text -> Text -> Text -> Text -> Text -> Ctx (Exp i) -> Text
forms t a1 a2 m1 m2 ctx =
    case ctx of
      CtxAdd _ (Lit 10)  _ -> a1
      CtxAdd {}            -> a2
      CtxMul _ (Lit 10)  _ -> m1
      CtxMul {}            -> m2
      _                    -> t


--------------------------------------------------------------------------------
-- Representations of scales
--------------------------------------------------------------------------------

-- | Function that renders the postfix part of a large number name. Or
-- more simply put, this calculates the \"illion\" part of
-- \"million\", \"billion\", etc.
type PostfixRepr i = i           -- ^ Current inflection.
                   -> Ctx (Exp i) -- ^ Context.
                   -> Text        -- ^ Postfix representation.

scaleRepr :: PostfixRepr i
          -> [(ℤ, Ctx (Exp i) -> Text)] -- ^ Additional symbol map entries.
          -> ScaleRepr i
scaleRepr pf syms inf _ _ e ctx = (⊕ pf inf ctx) <$> render repr inf e
    where
      repr = cardinalRepr { reprValue = \_ n -> M.lookup n syms' }
      syms' = M.fromList syms ∪ symMap

pelletierRepr :: PostfixRepr i -- ^Postfix for offset 0 names.
              -> PostfixRepr i -- ^Postfix for offset 3 names.
              -> [(ℤ, Ctx (Exp i) -> Text)] -- ^ Additional symbol map entries.
              -> ScaleRepr i
pelletierRepr pf0 pf3 syms inf
              b o e ctx | o ≡ 0 = scaleRepr pf0 syms inf b o e ctx
                        | o ≡ 3 = scaleRepr pf3 syms inf b o e ctx
                        | otherwise = Nothing

quantityName :: Text -> Text -> PostfixRepr i
quantityName s p _ ctx =
    case ctx of
      CtxMul _ (Lit 1) _ -> s
      CtxMul {}          -> p
      _                  -> s

ordQuantityName :: Text -> Text -> Text -> Text -> PostfixRepr i
ordQuantityName sc so pc po _ ctx =
    case ctx of
      CtxMul _ (Lit 1) _ | outside   -> so
                         | otherwise -> sc
      CtxMul {}          | outside   -> po
                         | otherwise -> pc
      _                  | outside   -> so
                         | otherwise -> sc
    where
      outside = isOutside R ctx

</pre>