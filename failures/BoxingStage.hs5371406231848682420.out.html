<a href="Boxing.hs14594134961951894885.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BroadcastChan.hs10120281441086531968.out.html">next</a></br></br><pre>32c32
<             Left _ -> $impossible
---
>             Left _ -> impossible
32a33
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{- | This module wraps the boxing stage. Boxing is performed to ensure that nested lists are
   handled in a separate table in the database.
-}
module Database.Ferry.Compiler.Stages.BoxingStage (boxingPhase) where

import Database.Ferry.Compiler.Types
import Database.Ferry.Compiler.ExecuteStep

import Database.Ferry.TypeSystem.Prelude
import Database.Ferry.TypedCore.Render.Dot
import Database.Ferry.Common.Render.Dot

import Database.Ferry.TypedCore.Data.TypedCore
import Database.Ferry.TypedCore.Boxing.Boxing

import Database.Ferry.Impossible

boxingPhase :: CoreExpr -> PhaseResult CoreExpr
boxingPhase e = executeStep inferStage e

inferStage :: CompilationStep CoreExpr CoreExpr
inferStage = CompilationStep "Boxing" Boxing step artefacts
    where
        step :: CoreExpr -> PhaseResult CoreExpr
        step e = return $ runBoxing primitives e
        artefacts = [(DotBox ,"dot", \s -> return $ makeDot s)]

makeDot :: CoreExpr -> String
makeDot c = case runDot $ toDot c of
            Right s -> s
            Left _ -> $impossible
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{- | This module wraps the boxing stage. Boxing is performed to ensure that nested lists are
   handled in a separate table in the database.
-}
module Database.Ferry.Compiler.Stages.BoxingStage (boxingPhase) where

import Database.Ferry.Compiler.Types
import Database.Ferry.Compiler.ExecuteStep

import Database.Ferry.TypeSystem.Prelude
import Database.Ferry.TypedCore.Render.Dot
import Database.Ferry.Common.Render.Dot

import Database.Ferry.TypedCore.Data.TypedCore
import Database.Ferry.TypedCore.Boxing.Boxing

import Database.Ferry.Impossible

boxingPhase :: CoreExpr -> PhaseResult CoreExpr
boxingPhase e = executeStep inferStage e

inferStage :: CompilationStep CoreExpr CoreExpr
inferStage = CompilationStep "Boxing" Boxing step artefacts
    where
        step :: CoreExpr -> PhaseResult CoreExpr
        step e = return $ runBoxing primitives e
        artefacts = [(DotBox ,"dot", \s -> return $ makeDot s)]

makeDot :: CoreExpr -> String
makeDot c = case runDot $ toDot c of
            Right s -> s
            Left _ -> impossible

</pre>