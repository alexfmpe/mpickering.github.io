<a href="Boxing.hs510616708590357944.out.html">prev</a></br><a href="failures.html">home</a></br><a href="build.hs10447881241927702196.out.html">next</a></br></br><pre>31c31
<   Ctor :: { gadtField :: A } -> GADT A
---
>   Ctor :: { gadtField :: A }    GADT A
37a38
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, FlexibleInstances, GADTs #-}
-- This tests that we are able to extract record selectors for
-- associated types when the type itself is not exported. Making this
-- bug exhibit is very simple: simply mention a record field defined
-- inside of the associated type anywhere in the export list.
--
-- Note: ProblemCtor only shows up when T or A are exported but PolyCtor
-- only shows up when the class is exported as well, since it's polymorphic.
module Bug294 ( A, problemField, problemField', gadtField
              , TP(ProblemCtor), DP(ProblemCtor'), TO'(PolyCtor)) where

data A

class T t where
  data TO t :: *
  data TP t :: *

  t :: t

instance T A where
  data TO A = TA { problemField :: A }
  data TP A = ProblemCtor A

data family DO t :: *
data family DP t :: *

data instance DO A = DA { problemField' :: A }
data instance DP A = ProblemCtor' A

data GADT :: * -> * where
  Ctor :: { gadtField :: A } -> GADT A

class T' t where
  data TO' t :: *

instance T' a where
  data TO' a = PolyCtor
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, FlexibleInstances, GADTs #-}
-- This tests that we are able to extract record selectors for
-- associated types when the type itself is not exported. Making this
-- bug exhibit is very simple: simply mention a record field defined
-- inside of the associated type anywhere in the export list.
--
-- Note: ProblemCtor only shows up when T or A are exported but PolyCtor
-- only shows up when the class is exported as well, since it's polymorphic.
module Bug294 ( A, problemField, problemField', gadtField
              , TP(ProblemCtor), DP(ProblemCtor'), TO'(PolyCtor)) where

data A

class T t where
  data TO t :: *
  data TP t :: *

  t :: t

instance T A where
  data TO A = TA { problemField :: A }
  data TP A = ProblemCtor A

data family DO t :: *
data family DP t :: *

data instance DO A = DA { problemField' :: A }
data instance DP A = ProblemCtor' A

data GADT :: * -> * where
  Ctor :: { gadtField :: A }    GADT A

class T' t where
  data TO' t :: *

instance T' a where
  data TO' a = PolyCtor

</pre>