<a href="Bitstream.hs15519013931617819336.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BitVector.hs159282276141000625.out.html">next</a></br></br><pre>25c25
< main ∷ IO ()
---
> main :: IO ()
28c28
< tests ∷ [Property]
---
> tests :: [Property]
31d30
<           [ property $ B.null      ((B.∅) ∷ BitL)
32d30
<           , property $ B.length    ((B.∅) ∷ BitL) ≡ (0 ∷Int)
33d30
<           , property $ B.pack [] ≡ ((B.∅) ∷ BitL)
34c31
<           , property $ B.empty   ≡ ((B.∅) ∷ BitL)
---
>           [ property $ B.null      ((B.∅) :: BitL)
34a32
>           , property $ B.length    ((B.∅) :: BitL) ≡ (0 ::Int)
34a33
>           , property $ B.pack [] ≡ ((B.∅) :: BitL)
34a34
>           , property $ B.empty   ≡ ((B.∅) :: BitL)
38d37
<           [ property $ B.null      ((B.∅) ∷ BitR)
39d37
<           , property $ B.length    ((B.∅) ∷ BitR) ≡ (0 ∷ Int)
40d37
<           , property $ B.pack [] ≡ ((B.∅) ∷ BitR)
41c38
<           , property $ B.empty   ≡ ((B.∅) ∷ BitR)
---
>           [ property $ B.null      ((B.∅) :: BitR)
41a39
>           , property $ B.length    ((B.∅) :: BitR) ≡ (0 :: Int)
41a40
>           , property $ B.pack [] ≡ ((B.∅) :: BitR)
41a41
>           , property $ B.empty   ≡ ((B.∅) :: BitR)
45d44
<         , property $ \b → B.length (B.singleton b ∷ BitL) ≡ (1 ∷ Int)
46d44
<         , property $ \b → B.head   (B.singleton b ∷ BitL) ≡ b
47c45
<         , property $ \b → B.pack [b] ≡ (B.singleton b ∷ BitL)
---
>         , property $ \b -> B.length (B.singleton b :: BitL) ≡ (1 :: Int)
47a46
>         , property $ \b -> B.head   (B.singleton b :: BitL) ≡ b
47a47
>         , property $ \b -> B.pack [b] ≡ (B.singleton b :: BitL)
49d48
<         , property $ \b → B.length (B.singleton b ∷ BitR) ≡ (1 ∷ Int)
50d48
<         , property $ \b → B.head   (B.singleton b ∷ BitR) ≡ b
51c49
<         , property $ \b → B.pack [b] ≡ (B.singleton b ∷ BitR)
---
>         , property $ \b -> B.length (B.singleton b :: BitR) ≡ (1 :: Int)
51a50
>         , property $ \b -> B.head   (B.singleton b :: BitR) ≡ b
51a51
>         , property $ \b -> B.pack [b] ≡ (B.singleton b :: BitR)
55d54
<           [ property $ B.unpack (B.pack []      ∷ BitL) ≡ []
56d54
<           , property $ B.unpack (B.pack [False] ∷ BitL) ≡ [False]
57c55
<           , property $ B.unpack (B.pack [True ] ∷ BitL) ≡ [True ]
---
>           [ property $ B.unpack (B.pack []      :: BitL) ≡ []
57a56
>           , property $ B.unpack (B.pack [False] :: BitL) ≡ [False]
57a57
>           , property $ B.unpack (B.pack [True ] :: BitL) ≡ [True ]
59d58
<         , property $ \bl → B.unpack (B.pack bl ∷ BitL) ≡ bl
60c59
<         , property $ \bs → B.pack (B.unpack (bs ∷ BitL)) ≡ bs
---
>         , property $ \bl -> B.unpack (B.pack bl :: BitL) ≡ bl
60a60
>         , property $ \bs -> B.pack (B.unpack (bs :: BitL)) ≡ bs
63d62
<           [ property $ B.unpack (B.pack []      ∷ BitR) ≡ []
64d62
<           , property $ B.unpack (B.pack [False] ∷ BitR) ≡ [False]
65c63
<           , property $ B.unpack (B.pack [True ] ∷ BitR) ≡ [True ]
---
>           [ property $ B.unpack (B.pack []      :: BitR) ≡ []
65a64
>           , property $ B.unpack (B.pack [False] :: BitR) ≡ [False]
65a65
>           , property $ B.unpack (B.pack [True ] :: BitR) ≡ [True ]
67d66
<         , property $ \bl → B.unpack (B.pack bl ∷ BitR) ≡ bl
68c67
<         , property $ \bs → B.pack (B.unpack (bs ∷ BitR)) ≡ bs
---
>         , property $ \bl -> B.unpack (B.pack bl :: BitR) ≡ bl
68a68
>         , property $ \bs -> B.pack (B.unpack (bs :: BitR)) ≡ bs
71c71
<         , property $ (B.fromByteString "UNK" ∷ BitL)
---
>         , property $ (B.fromByteString "UNK" :: BitL)
75d74
<         , property $ \str → B.toByteString (B.fromByteString str ∷ BitL) ≡ str
76d74
<         , mapSize (⋅ 8) $ \bs → (B.length bs `rem` 8) ≡ (0 ∷ Int)
77c75
<                                   ⟹ B.fromByteString (B.toByteString (bs ∷ BitL)) ≡ bs
---
>         , property $ \str -> B.toByteString (B.fromByteString str :: BitL) ≡ str
77a76
>         , mapSize (⋅ 8) $ \bs -> (B.length bs `rem` 8) ≡ (0 :: Int)
77a77
>                                   ⟹ B.fromByteString (B.toByteString (bs :: BitL)) ≡ bs
79c79
<         , property $ (B.fromByteString "UNK" ∷ BitR)
---
>         , property $ (B.fromByteString "UNK" :: BitR)
83d82
<         , property $ \str → B.toByteString (B.fromByteString str ∷ BitR) ≡ str
84d82
<         , mapSize (⋅ 8) $ \bs → (B.length bs `rem` 8) ≡ (0 ∷ Int)
85c83
<                                   ⟹ B.fromByteString (B.toByteString (bs ∷ BitR)) ≡ bs
---
>         , property $ \str -> B.toByteString (B.fromByteString str :: BitR) ≡ str
85a84
>         , mapSize (⋅ 8) $ \bs -> (B.length bs `rem` 8) ≡ (0 :: Int)
85a85
>                                   ⟹ B.fromByteString (B.toByteString (bs :: BitR)) ≡ bs
88c88
<         , property $ (B.fromNBits (15 ∷ Int) (0xB1C3 ∷ Int) ∷ BitL)
---
>         , property $ (B.fromNBits (15 :: Int) (0xB1C3 :: Int) :: BitL)
91c91
<         , property $ let bs ∷ BitL
---
>         , property $ let bs :: BitL
95d94
<                        B.toBits bs ≡ (0x31C3 ∷ Int)
96c95
<         , property $ \n → (n ∷ Int) ≡ B.toBits (B.fromBits n ∷ BitL)
---
>                        B.toBits bs ≡ (0x31C3 :: Int)
96a96
>         , property $ \n -> (n :: Int) ≡ B.toBits (B.fromBits n :: BitL)
98c98
<         , property $ (B.fromNBits (15 ∷ Int) (0xB1C3 ∷ Int) ∷ BitR)
---
>         , property $ (B.fromNBits (15 :: Int) (0xB1C3 :: Int) :: BitR)
101c101
<         , property $ let bs ∷ BitR
---
>         , property $ let bs :: BitR
105d104
<                        B.toBits bs ≡ (0x31C3 ∷ Int)
106c105
<         , property $ \n → (n ∷ Int) ≡ B.toBits (B.fromBits n ∷ BitR)
---
>                        B.toBits bs ≡ (0x31C3 :: Int)
106a106
>         , property $ \n -> (n :: Int) ≡ B.toBits (B.fromBits n :: BitR)
109d108
<         , property $ \bl → B.unstream (S.fromList bl) ≡ (B.pack bl ∷ BitL)
110c109
<         , property $ \bs → S.toList   (B.stream bs)   ≡ B.unpack (bs ∷ BitL)
---
>         , property $ \bl -> B.unstream (S.fromList bl) ≡ (B.pack bl :: BitL)
110a110
>         , property $ \bs -> S.toList   (B.stream bs)   ≡ B.unpack (bs :: BitL)
112d111
<         , property $ \bl → B.unstream (S.fromList bl) ≡ (B.pack bl ∷ BitR)
113c112
<         , property $ \bs → S.toList   (B.stream bs)   ≡ B.unpack (bs ∷ BitR)
---
>         , property $ \bl -> B.unstream (S.fromList bl) ≡ (B.pack bl :: BitR)
113a113
>         , property $ \bs -> S.toList   (B.stream bs)   ≡ B.unpack (bs :: BitR)
122d121
<         , property $ \bs → B.directionRToL (B.directionLToR bs) ≡ bs
123c122
<         , property $ \bs → B.directionLToR (B.directionRToL bs) ≡ bs
---
>         , property $ \bs -> B.directionRToL (B.directionLToR bs) ≡ bs
123a123
>         , property $ \bs -> B.directionLToR (B.directionRToL bs) ≡ bs
129c129
<                                     , True , False, True , True, True  ] ∷ BitL)
---
>                                     , True , False, True , True, True  ] :: BitL)
133c133
<                                     , True , False, True , True, True  ] ∷ BitR)
---
>                                     , True , False, True , True, True  ] :: BitR)
138d137
<         , property $ \(bl1, bl2) → ((B.pack bl1 ∷ BitL) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
139c138
<         , property $ \(bl1, bl2) → ((B.pack bl1 ∷ BitR) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
---
>         , property $ \(bl1, bl2) -> ((B.pack bl1 :: BitL) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
139a139
>         , property $ \(bl1, bl2) -> ((B.pack bl1 :: BitR) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
142d141
<         , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitL) `compare` B.pack bl2 ≡ bl1 `compare` bl2
143c142
<         , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitR) `compare` B.pack bl2 ≡ bl1 `compare` bl2
---
>         , property $ \(bl1, bl2) -> (B.pack bl1 :: BitL) `compare` B.pack bl2 ≡ bl1 `compare` bl2
143a143
>         , property $ \(bl1, bl2) -> (B.pack bl1 :: BitR) `compare` B.pack bl2 ≡ bl1 `compare` bl2
147d146
<           [ property $ ((M.∅) ∷ BitL) ≡ B.pack (M.∅)
148c147
<           , property $ ((M.∅) ∷ BitR) ≡ B.pack (M.∅)
---
>           [ property $ ((M.∅) :: BitL) ≡ B.pack (M.∅)
148a148
>           , property $ ((M.∅) :: BitR) ≡ B.pack (M.∅)
151d150
<         , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitL) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
152c151
<         , property $ \bls → M.mconcat (map B.pack bls ∷ [BitL]) ≡ B.pack (M.mconcat bls)
---
>         , property $ \(bl1, bl2) -> (B.pack bl1 :: BitL) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
152a152
>         , property $ \bls -> M.mconcat (map B.pack bls :: [BitL]) ≡ B.pack (M.mconcat bls)
154d153
<         , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitR) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
155c154
<         , property $ \bls → M.mconcat (map B.pack bls ∷ [BitR]) ≡ B.pack (M.mconcat bls)
---
>         , property $ \(bl1, bl2) -> (B.pack bl1 :: BitR) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
155a155
>         , property $ \bls -> M.mconcat (map B.pack bls :: [BitR]) ≡ B.pack (M.mconcat bls)
158d157
<         , property $ \(b, bl) → B.cons b (B.pack bl ∷ BitL) ≡ B.pack (b:bl)
159d157
<         , property $ \(bl, b) → B.snoc (B.pack bl ∷ BitL) b ≡ B.pack (bl ⧺ [b])
160d157
<         , property $ \(x, y) → (B.pack x ∷ BitL) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
161d157
<         , property $ \bl → (¬) (null bl) ⟹ B.head (B.pack bl ∷ BitL) ≡ head bl
162d157
<         , property $ \bl → (¬) (null bl) ⟹ B.last (B.pack bl ∷ BitL) ≡ last bl
163d157
<         , property $ \bl → (¬) (null bl) ⟹ B.tail (B.pack bl ∷ BitL) ≡ B.pack (tail bl)
164d157
<         , property $ \bl → (¬) (null bl) ⟹ B.init (B.pack bl ∷ BitL) ≡ B.pack (init bl)
165d157
<         , property $ \bl → let bs = B.pack bl ∷ BitL
166d157
<                            in case bl of
167d157
<                                 [] → label "null"     $ B.null bs
168d157
<                                 _  → label "non-null" $ (¬) (B.null bs)
169c158
<         , property $ \bl → B.length (B.pack bl ∷ BitL) ≡ length bl
---
>         , property $ \(b, bl) -> B.cons b (B.pack bl :: BitL) ≡ B.pack (b:bl)
169a159
>         , property $ \(bl, b) -> B.snoc (B.pack bl :: BitL) b ≡ B.pack (bl ⧺ [b])
169a160
>         , property $ \(x, y) -> (B.pack x :: BitL) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
169a161
>         , property $ \bl -> (¬) (null bl) ⟹ B.head (B.pack bl :: BitL) ≡ head bl
169a162
>         , property $ \bl -> (¬) (null bl) ⟹ B.last (B.pack bl :: BitL) ≡ last bl
169a163
>         , property $ \bl -> (¬) (null bl) ⟹ B.tail (B.pack bl :: BitL) ≡ B.pack (tail bl)
169a164
>         , property $ \bl -> (¬) (null bl) ⟹ B.init (B.pack bl :: BitL) ≡ B.pack (init bl)
169a165
>         , property $ \bl -> let bs = B.pack bl :: BitL
169a166
>                             in case bl of
169a167
>                                  [] -> label "null"     $ B.null bs
169a168
>                                  _  -> label "non-null" $ (¬) (B.null bs)
169a169
>         , property $ \bl -> B.length (B.pack bl :: BitL) ≡ length bl
171d170
<         , property $ \(b, bl) → B.cons b (B.pack bl ∷ BitR) ≡ B.pack (b:bl)
172d170
<         , property $ \(bl, b) → B.snoc (B.pack bl ∷ BitR) b ≡ B.pack (bl ⧺ [b])
173d170
<         , property $ \(x, y) → (B.pack x ∷ BitR) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
174d170
<         , property $ \bl → (¬) (null bl) ⟹ B.head (B.pack bl ∷ BitR) ≡ head bl
175d170
<         , property $ \bl → (¬) (null bl) ⟹ B.last (B.pack bl ∷ BitR) ≡ last bl
176d170
<         , property $ \bl → (¬) (null bl) ⟹ B.tail (B.pack bl ∷ BitR) ≡ B.pack (tail bl)
177d170
<         , property $ \bl → (¬) (null bl) ⟹ B.init (B.pack bl ∷ BitR) ≡ B.pack (init bl)
178d170
<         , property $ \bl → let bs = B.pack bl ∷ BitR
179d170
<                            in case bl of
180d170
<                                 [] → label "null"     $ B.null bs
181d170
<                                 _  → label "non-null" $ (¬) (B.null bs)
182c171
<         , property $ \bl → B.length (B.pack bl ∷ BitR) ≡ length bl
---
>         , property $ \(b, bl) -> B.cons b (B.pack bl :: BitR) ≡ B.pack (b:bl)
182a172
>         , property $ \(bl, b) -> B.snoc (B.pack bl :: BitR) b ≡ B.pack (bl ⧺ [b])
182a173
>         , property $ \(x, y) -> (B.pack x :: BitR) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
182a174
>         , property $ \bl -> (¬) (null bl) ⟹ B.head (B.pack bl :: BitR) ≡ head bl
182a175
>         , property $ \bl -> (¬) (null bl) ⟹ B.last (B.pack bl :: BitR) ≡ last bl
182a176
>         , property $ \bl -> (¬) (null bl) ⟹ B.tail (B.pack bl :: BitR) ≡ B.pack (tail bl)
182a177
>         , property $ \bl -> (¬) (null bl) ⟹ B.init (B.pack bl :: BitR) ≡ B.pack (init bl)
182a178
>         , property $ \bl -> let bs = B.pack bl :: BitR
182a179
>                             in case bl of
182a180
>                                  [] -> label "null"     $ B.null bs
182a181
>                                  _  -> label "non-null" $ (¬) (B.null bs)
182a182
>         , property $ \bl -> B.length (B.pack bl :: BitR) ≡ length bl
185d184
<         , property $ \bl → B.map (¬) (B.pack bl ∷ BitL) ≡ B.pack (map (¬) bl)
186c185
<         , property $ \bl → B.reverse (B.pack bl ∷ BitL) ≡ B.pack (reverse bl)
---
>         , property $ \bl -> B.map (¬) (B.pack bl :: BitL) ≡ B.pack (map (¬) bl)
186a186
>         , property $ \bl -> B.reverse (B.pack bl :: BitL) ≡ B.pack (reverse bl)
188d187
<         , property $ \bl → B.map (¬) (B.pack bl ∷ BitR) ≡ B.pack (map (¬) bl)
189c188
<         , property $ \bl → B.reverse (B.pack bl ∷ BitL) ≡ B.pack (reverse bl)
---
>         , property $ \bl -> B.map (¬) (B.pack bl :: BitR) ≡ B.pack (map (¬) bl)
189a189
>         , property $ \bl -> B.reverse (B.pack bl :: BitL) ≡ B.pack (reverse bl)
192d191
<         , property $ \(n, bl) → B.foldl doubleIf n (B.pack bl ∷ BitL) ≡ foldl doubleIf n bl
193d191
<         , property $ \(n, bl) → B.foldl' doubleIf n (B.pack bl ∷ BitL) ≡ foldl doubleIf n bl
194d191
<         , property $ \bl → (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl ∷ BitL) ≡ foldl1 xor bl
195d191
<         , property $ \bl → (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl ∷ BitL) ≡ foldl1' xor bl
196d191
<         , property $ \(n, bl) → B.foldr (flip doubleIf) n (B.pack bl ∷ BitL) ≡ foldr (flip doubleIf) n bl
197c192
<         , property $ \bl → (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl ∷ BitL) ≡ foldr1 xor bl
---
>         , property $ \(n, bl) -> B.foldl doubleIf n (B.pack bl :: BitL) ≡ foldl doubleIf n bl
197a193
>         , property $ \(n, bl) -> B.foldl' doubleIf n (B.pack bl :: BitL) ≡ foldl doubleIf n bl
197a194
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl :: BitL) ≡ foldl1 xor bl
197a195
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl :: BitL) ≡ foldl1' xor bl
197a196
>         , property $ \(n, bl) -> B.foldr (flip doubleIf) n (B.pack bl :: BitL) ≡ foldr (flip doubleIf) n bl
197a197
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl :: BitL) ≡ foldr1 xor bl
199d198
<         , property $ \(n, bl) → B.foldl doubleIf n (B.pack bl ∷ BitR) ≡ foldl doubleIf n bl
200d198
<         , property $ \(n, bl) → B.foldl' doubleIf n (B.pack bl ∷ BitR) ≡ foldl doubleIf n bl
201d198
<         , property $ \bl → (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl ∷ BitR) ≡ foldl1 xor bl
202d198
<         , property $ \bl → (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl ∷ BitR) ≡ foldl1' xor bl
203d198
<         , property $ \(n, bl) → B.foldr (flip doubleIf) n (B.pack bl ∷ BitR) ≡ foldr (flip doubleIf) n bl
204c199
<         , property $ \bl → (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl ∷ BitR) ≡ foldr1 xor bl
---
>         , property $ \(n, bl) -> B.foldl doubleIf n (B.pack bl :: BitR) ≡ foldl doubleIf n bl
204a200
>         , property $ \(n, bl) -> B.foldl' doubleIf n (B.pack bl :: BitR) ≡ foldl doubleIf n bl
204a201
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl :: BitR) ≡ foldl1 xor bl
204a202
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl :: BitR) ≡ foldl1' xor bl
204a203
>         , property $ \(n, bl) -> B.foldr (flip doubleIf) n (B.pack bl :: BitR) ≡ foldr (flip doubleIf) n bl
204a204
>         , property $ \bl -> (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl :: BitR) ≡ foldr1 xor bl
207d206
<         , property $ \bls → B.concat (map B.pack bls ∷ [BitL]) ≡ B.pack (concat bls)
208d206
<         , property $ \bl → let f True  = [True , True , True ]
209d206
<                                f False = [False, False, False]
210d206
<                            in B.concatMap (B.pack ∘ f) (B.pack bl ∷ BitL) ≡ B.pack (concatMap f bl)
211d206
<         , property $ \bl → B.and (B.pack bl ∷ BitL) ≡ and bl
212d206
<         , property $ \bl → B.or  (B.pack bl ∷ BitL) ≡ or  bl
213d206
<         , property $ \bl → B.any id (B.pack bl ∷ BitL) ≡ any id bl
214c207
<         , property $ \bl → B.all id (B.pack bl ∷ BitL) ≡ all id bl
---
>         , property $ \bls -> B.concat (map B.pack bls :: [BitL]) ≡ B.pack (concat bls)
214a208
>         , property $ \bl -> let f True  = [True , True , True ]
214a209
>                                 f False = [False, False, False]
214a210
>                             in B.concatMap (B.pack ∘ f) (B.pack bl :: BitL) ≡ B.pack (concatMap f bl)
214a211
>         , property $ \bl -> B.and (B.pack bl :: BitL) ≡ and bl
214a212
>         , property $ \bl -> B.or  (B.pack bl :: BitL) ≡ or  bl
214a213
>         , property $ \bl -> B.any id (B.pack bl :: BitL) ≡ any id bl
214a214
>         , property $ \bl -> B.all id (B.pack bl :: BitL) ≡ all id bl
216d215
<         , property $ \bls → B.concat (map B.pack bls ∷ [BitR]) ≡ B.pack (concat bls)
217d215
<         , property $ \bl → let f True  = [True , True , True ]
218d215
<                                f False = [False, False, False]
219d215
<                            in B.concatMap (B.pack ∘ f) (B.pack bl ∷ BitR) ≡ B.pack (concatMap f bl)
220d215
<         , property $ \bl → B.and (B.pack bl ∷ BitR) ≡ and bl
221d215
<         , property $ \bl → B.or  (B.pack bl ∷ BitR) ≡ or  bl
222d215
<         , property $ \bl → B.any id (B.pack bl ∷ BitR) ≡ any id bl
223c216
<         , property $ \bl → B.all id (B.pack bl ∷ BitR) ≡ all id bl
---
>         , property $ \bls -> B.concat (map B.pack bls :: [BitR]) ≡ B.pack (concat bls)
223a217
>         , property $ \bl -> let f True  = [True , True , True ]
223a218
>                                 f False = [False, False, False]
223a219
>                             in B.concatMap (B.pack ∘ f) (B.pack bl :: BitR) ≡ B.pack (concatMap f bl)
223a220
>         , property $ \bl -> B.and (B.pack bl :: BitR) ≡ and bl
223a221
>         , property $ \bl -> B.or  (B.pack bl :: BitR) ≡ or  bl
223a222
>         , property $ \bl -> B.any id (B.pack bl :: BitR) ≡ any id bl
223a223
>         , property $ \bl -> B.all id (B.pack bl :: BitR) ≡ all id bl
226d225
<         , property $ \(b, bl) → B.scanl xor b (B.pack bl ∷ BitL) ≡ B.pack (scanl xor b bl)
227d225
<         , property $ \bl → B.scanl1 xor (B.pack bl ∷ BitL) ≡ B.pack (scanl1 xor bl)
228d225
<         , property $ \(b, bl) → B.scanr xor b (B.pack bl ∷ BitL) ≡ B.pack (scanr xor b bl)
229c226
<         , property $ \bl → B.scanr1 xor (B.pack bl ∷ BitL) ≡ B.pack (scanr1 xor bl)
---
>         , property $ \(b, bl) -> B.scanl xor b (B.pack bl :: BitL) ≡ B.pack (scanl xor b bl)
229a227
>         , property $ \bl -> B.scanl1 xor (B.pack bl :: BitL) ≡ B.pack (scanl1 xor bl)
229a228
>         , property $ \(b, bl) -> B.scanr xor b (B.pack bl :: BitL) ≡ B.pack (scanr xor b bl)
229a229
>         , property $ \bl -> B.scanr1 xor (B.pack bl :: BitL) ≡ B.pack (scanr1 xor bl)
231d230
<         , property $ \(b, bl) → B.scanl xor b (B.pack bl ∷ BitR) ≡ B.pack (scanl xor b bl)
232d230
<         , property $ \bl → B.scanl1 xor (B.pack bl ∷ BitR) ≡ B.pack (scanl1 xor bl)
233d230
<         , property $ \(b, bl) → B.scanr xor b (B.pack bl ∷ BitR) ≡ B.pack (scanr xor b bl)
234c231
<         , property $ \bl → B.scanr1 xor (B.pack bl ∷ BitR) ≡ B.pack (scanr1 xor bl)
---
>         , property $ \(b, bl) -> B.scanl xor b (B.pack bl :: BitR) ≡ B.pack (scanl xor b bl)
234a232
>         , property $ \bl -> B.scanl1 xor (B.pack bl :: BitR) ≡ B.pack (scanl1 xor bl)
234a233
>         , property $ \(b, bl) -> B.scanr xor b (B.pack bl :: BitR) ≡ B.pack (scanr xor b bl)
234a234
>         , property $ \bl -> B.scanr1 xor (B.pack bl :: BitR) ≡ B.pack (scanr1 xor bl)
237d236
<         , property $ \(n, b) → (B.replicate (n `rem` 800) b ∷ BitL) ≡ B.pack (replicate (n `rem` 800) b)
238c237
<         , property $ \(n, b) → (B.replicate (n `rem` 800) b ∷ BitR) ≡ B.pack (replicate (n `rem` 800) b)
---
>         , property $ \(n, b) -> (B.replicate (n `rem` 800) b :: BitL) ≡ B.pack (replicate (n `rem` 800) b)
238a238
>         , property $ \(n, b) -> (B.replicate (n `rem` 800) b :: BitR) ≡ B.pack (replicate (n `rem` 800) b)
241d240
<         , property $ \n → (B.unfoldr decr (abs (n `rem` 800)) ∷ BitL) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
242d240
<         , property $ \(m, n) → let m'            = m `rem` 800
243d240
<                                    n'            = abs (n `rem` 800)
244d240
<                                    r             = B.unfoldrN m' decr n'
245d240
<                                    p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) ∷ BitL)
246d240
<                                      | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
247d240
<                                      | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
248c241
<                                in p
---
>         , property $ \n -> (B.unfoldr decr (abs (n `rem` 800)) :: BitL) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
248a242
>         , property $ \(m, n) -> let m'            = m `rem` 800
248a243
>                                     n'            = abs (n `rem` 800)
248a244
>                                     r             = B.unfoldrN m' decr n'
248a245
>                                     p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) :: BitL)
248a246
>                                       | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
248a247
>                                       | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
248a248
>                                 in p
250d249
<         , property $ \n → (B.unfoldr decr (abs (n `rem` 800)) ∷ BitR) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
251d249
<         , property $ \(m, n) → let m'            = m `rem` 800
252d249
<                                    n'            = abs (n `rem` 800)
253d249
<                                    r             = B.unfoldrN m' decr n'
254d249
<                                    p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) ∷ BitR)
255d249
<                                      | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
256d249
<                                      | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
257c250
<                                in p
---
>         , property $ \n -> (B.unfoldr decr (abs (n `rem` 800)) :: BitR) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
257a251
>         , property $ \(m, n) -> let m'            = m `rem` 800
257a252
>                                     n'            = abs (n `rem` 800)
257a253
>                                     r             = B.unfoldrN m' decr n'
257a254
>                                     p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) :: BitR)
257a255
>                                       | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
257a256
>                                       | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
257a257
>                                 in p
260d259
<         , property $ \(n, bl) → B.take n (B.pack bl ∷ BitL) ≡ B.pack (take n bl)
261d259
<         , property $ \(n, bl) → B.drop n (B.pack bl ∷ BitL) ≡ B.pack (drop n bl)
262d259
<         , property $ \bl → B.takeWhile id (B.pack bl ∷ BitL) ≡ B.pack (takeWhile id bl)
263d259
<         , property $ \bl → B.dropWhile id (B.pack bl ∷ BitL) ≡ B.pack (dropWhile id bl)
264d259
<         , property $ \bl → B.span id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (span id bl)
265c260
<         , property $ \bl → B.break id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (break id bl)
---
>         , property $ \(n, bl) -> B.take n (B.pack bl :: BitL) ≡ B.pack (take n bl)
265a261
>         , property $ \(n, bl) -> B.drop n (B.pack bl :: BitL) ≡ B.pack (drop n bl)
265a262
>         , property $ \bl -> B.takeWhile id (B.pack bl :: BitL) ≡ B.pack (takeWhile id bl)
265a263
>         , property $ \bl -> B.dropWhile id (B.pack bl :: BitL) ≡ B.pack (dropWhile id bl)
265a264
>         , property $ \bl -> B.span id (B.pack bl :: BitL) ≡ fmapT2 B.pack (span id bl)
265a265
>         , property $ \bl -> B.break id (B.pack bl :: BitL) ≡ fmapT2 B.pack (break id bl)
267d266
<         , property $ \(n, bl) → B.take n (B.pack bl ∷ BitR) ≡ B.pack (take n bl)
268d266
<         , property $ \(n, bl) → B.drop n (B.pack bl ∷ BitR) ≡ B.pack (drop n bl)
269d266
<         , property $ \bl → B.takeWhile id (B.pack bl ∷ BitR) ≡ B.pack (takeWhile id bl)
270d266
<         , property $ \bl → B.dropWhile id (B.pack bl ∷ BitR) ≡ B.pack (dropWhile id bl)
271d266
<         , property $ \bl → B.span id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (span id bl)
272c267
<         , property $ \bl → B.break id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (break id bl)
---
>         , property $ \(n, bl) -> B.take n (B.pack bl :: BitR) ≡ B.pack (take n bl)
272a268
>         , property $ \(n, bl) -> B.drop n (B.pack bl :: BitR) ≡ B.pack (drop n bl)
272a269
>         , property $ \bl -> B.takeWhile id (B.pack bl :: BitR) ≡ B.pack (takeWhile id bl)
272a270
>         , property $ \bl -> B.dropWhile id (B.pack bl :: BitR) ≡ B.pack (dropWhile id bl)
272a271
>         , property $ \bl -> B.span id (B.pack bl :: BitR) ≡ fmapT2 B.pack (span id bl)
272a272
>         , property $ \bl -> B.break id (B.pack bl :: BitR) ≡ fmapT2 B.pack (break id bl)
275d274
<         , property $ \(b, bl) → (b B.∈ (B.pack bl ∷ BitL)) ≡ (b ∈ bl)
276c275
<         , property $ \(b, bl) → (b B.∉ (B.pack bl ∷ BitL)) ≡ (b ∉ bl)
---
>         , property $ \(b, bl) -> (b B.∈ (B.pack bl :: BitL)) ≡ (b ∈ bl)
276a276
>         , property $ \(b, bl) -> (b B.∉ (B.pack bl :: BitL)) ≡ (b ∉ bl)
278d277
<         , property $ \(b, bl) → (b B.∈ (B.pack bl ∷ BitR)) ≡ (b ∈ bl)
279c278
<         , property $ \(b, bl) → (b B.∉ (B.pack bl ∷ BitR)) ≡ (b ∉ bl)
---
>         , property $ \(b, bl) -> (b B.∈ (B.pack bl :: BitR)) ≡ (b ∈ bl)
279a279
>         , property $ \(b, bl) -> (b B.∉ (B.pack bl :: BitR)) ≡ (b ∉ bl)
282d281
<         , property $ \bl → B.find id (B.pack bl ∷ BitL) ≡ find id bl
283d281
<         , property $ \bl → B.filter id (B.pack bl ∷ BitL) ≡ B.pack (filter id bl)
284c282
<         , property $ \bl → B.partition id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (partition id bl)
---
>         , property $ \bl -> B.find id (B.pack bl :: BitL) ≡ find id bl
284a283
>         , property $ \bl -> B.filter id (B.pack bl :: BitL) ≡ B.pack (filter id bl)
284a284
>         , property $ \bl -> B.partition id (B.pack bl :: BitL) ≡ fmapT2 B.pack (partition id bl)
286d285
<         , property $ \bl → B.find id (B.pack bl ∷ BitR) ≡ find id bl
287d285
<         , property $ \bl → B.filter id (B.pack bl ∷ BitR) ≡ B.pack (filter id bl)
288c286
<         , property $ \bl → B.partition id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (partition id bl)
---
>         , property $ \bl -> B.find id (B.pack bl :: BitR) ≡ find id bl
288a287
>         , property $ \bl -> B.filter id (B.pack bl :: BitR) ≡ B.pack (filter id bl)
288a288
>         , property $ \bl -> B.partition id (B.pack bl :: BitR) ≡ fmapT2 B.pack (partition id bl)
291c291
<         , property $ \bl → (¬) (null bl) ⟹
---
>         , property $ \bl -> (¬) (null bl) ⟹
293d292
<                                  bs = B.pack bl ∷ BitL
294d292
<                              in forAll ig $ \ i → bs B.!! i ≡ bl !! i
295d292
<         , property $ \(b, bl) → B.elemIndex b (B.pack bl ∷ BitL) ≡ elemIndex b bl
296c293
<         , property $ \(b, bl) → B.elemIndices b (B.pack bl ∷ BitL) ≡ elemIndices b bl
---
>                                  bs = B.pack bl :: BitL
296a294
>                              in forAll ig $ \ i -> bs B.!! i ≡ bl !! i
296a295
>         , property $ \(b, bl) -> B.elemIndex b (B.pack bl :: BitL) ≡ elemIndex b bl
296a296
>         , property $ \(b, bl) -> B.elemIndices b (B.pack bl :: BitL) ≡ elemIndices b bl
298c298
<         , property $ \bl → (¬) (null bl) ⟹
---
>         , property $ \bl -> (¬) (null bl) ⟹
300d299
<                                    bs = B.pack bl ∷ BitR
301d299
<                                in forAll ig $ \ i → bs B.!! i ≡ bl !! i
302d299
<         , property $ \(b, bl) → B.elemIndex b (B.pack bl ∷ BitR) ≡ elemIndex b bl
303c300
<         , property $ \(b, bl) → B.elemIndices b (B.pack bl ∷ BitR) ≡ elemIndices b bl
---
>                                    bs = B.pack bl :: BitR
303a301
>                                in forAll ig $ \ i -> bs B.!! i ≡ bl !! i
303a302
>         , property $ \(b, bl) -> B.elemIndex b (B.pack bl :: BitR) ≡ elemIndex b bl
303a303
>         , property $ \(b, bl) -> B.elemIndices b (B.pack bl :: BitR) ≡ elemIndices b bl
307c307
<                        → B.zip (B.pack bl1 ∷ BitL) (B.pack bl2)
---
>                        -> B.zip (B.pack bl1 :: BitL) (B.pack bl2)
310c310
<                        → B.zip3 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3)
---
>                        -> B.zip3 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3)
313c313
<                        → B.zip4 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4)
---
>                        -> B.zip4 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4)
316c316
<                        → B.zip5 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
---
>                        -> B.zip5 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
319c319
<                        → B.zip6 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
---
>                        -> B.zip6 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
323c323
<                        → B.zip (B.pack bl1 ∷ BitR) (B.pack bl2)
---
>                        -> B.zip (B.pack bl1 :: BitR) (B.pack bl2)
326c326
<                        → B.zip3 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3)
---
>                        -> B.zip3 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3)
329c329
<                        → B.zip4 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4)
---
>                        -> B.zip4 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4)
332c332
<                        → B.zip5 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
---
>                        -> B.zip5 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
335c335
<                        → B.zip6 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
---
>                        -> B.zip6 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
337a338
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    FlexibleContexts
  , OverloadedStrings
  , ScopedTypeVariables
  , UndecidableInstances
  , UnicodeSyntax
  #-}
module Main (main) where
import Data.Bitstream (Bitstream, Left, Right)
import qualified Data.Bitstream as B
import qualified Data.ByteString as BS
import Data.ByteString.Char8 ()
import Data.List
import Data.List.Unicode
import qualified Data.Monoid as M
import qualified Data.Monoid.Unicode as M
import qualified Data.Vector.Fusion.Stream as S
import Prelude.Unicode
import Test.Bitstream.Utils
import Test.QuickCheck hiding ((.&.))

type BitL = Bitstream Left
type BitR = Bitstream Right

main ∷ IO ()
main = mapM_ runTest tests

tests ∷ [Property]
tests = [ -- ∅
          conjoin
          [ property $ B.null      ((B.∅) ∷ BitL)
          , property $ B.length    ((B.∅) ∷ BitL) ≡ (0 ∷Int)
          , property $ B.pack [] ≡ ((B.∅) ∷ BitL)
          , property $ B.empty   ≡ ((B.∅) ∷ BitL)
          ]

        , conjoin
          [ property $ B.null      ((B.∅) ∷ BitR)
          , property $ B.length    ((B.∅) ∷ BitR) ≡ (0 ∷ Int)
          , property $ B.pack [] ≡ ((B.∅) ∷ BitR)
          , property $ B.empty   ≡ ((B.∅) ∷ BitR)
          ]

          -- singleton
        , property $ \b → B.length (B.singleton b ∷ BitL) ≡ (1 ∷ Int)
        , property $ \b → B.head   (B.singleton b ∷ BitL) ≡ b
        , property $ \b → B.pack [b] ≡ (B.singleton b ∷ BitL)

        , property $ \b → B.length (B.singleton b ∷ BitR) ≡ (1 ∷ Int)
        , property $ \b → B.head   (B.singleton b ∷ BitR) ≡ b
        , property $ \b → B.pack [b] ≡ (B.singleton b ∷ BitR)

          -- pack/unpack
        , conjoin
          [ property $ B.unpack (B.pack []      ∷ BitL) ≡ []
          , property $ B.unpack (B.pack [False] ∷ BitL) ≡ [False]
          , property $ B.unpack (B.pack [True ] ∷ BitL) ≡ [True ]
          ]
        , property $ \bl → B.unpack (B.pack bl ∷ BitL) ≡ bl
        , property $ \bs → B.pack (B.unpack (bs ∷ BitL)) ≡ bs

        , conjoin
          [ property $ B.unpack (B.pack []      ∷ BitR) ≡ []
          , property $ B.unpack (B.pack [False] ∷ BitR) ≡ [False]
          , property $ B.unpack (B.pack [True ] ∷ BitR) ≡ [True ]
          ]
        , property $ \bl → B.unpack (B.pack bl ∷ BitR) ≡ bl
        , property $ \bs → B.pack (B.unpack (bs ∷ BitR)) ≡ bs

          -- from/toByteString
        , property $ (B.fromByteString "UNK" ∷ BitL)
                       ≡ B.pack (map n2b [ 1, 0, 1, 0, 1, 0, 1, 0
                                         , 0, 1, 1, 1, 0, 0, 1, 0
                                         , 1, 1, 0, 1, 0, 0, 1, 0 ])
        , property $ \str → B.toByteString (B.fromByteString str ∷ BitL) ≡ str
        , mapSize (⋅ 8) $ \bs → (B.length bs `rem` 8) ≡ (0 ∷ Int)
                                  ⟹ B.fromByteString (B.toByteString (bs ∷ BitL)) ≡ bs

        , property $ (B.fromByteString "UNK" ∷ BitR)
                       ≡ B.pack (map n2b [ 0, 1, 0, 1, 0, 1, 0, 1
                                         , 0, 1, 0, 0, 1, 1, 1, 0
                                         , 0, 1, 0, 0, 1, 0, 1, 1 ])
        , property $ \str → B.toByteString (B.fromByteString str ∷ BitR) ≡ str
        , mapSize (⋅ 8) $ \bs → (B.length bs `rem` 8) ≡ (0 ∷ Int)
                                  ⟹ B.fromByteString (B.toByteString (bs ∷ BitR)) ≡ bs

          -- from/toBits
        , property $ (B.fromNBits (15 ∷ Int) (0xB1C3 ∷ Int) ∷ BitL)
                       ≡ B.pack (map n2b [ 1, 1, 0, 0, 0, 0, 1, 1
                                         , 1, 0, 0, 0, 1, 1, 0    ])
        , property $ let bs ∷ BitL
                         bs = B.pack (map n2b [ 1, 1, 0, 0, 0, 0, 1, 1
                                              , 1, 0, 0, 0, 1, 1, 0    ])
                     in
                       B.toBits bs ≡ (0x31C3 ∷ Int)
        , property $ \n → (n ∷ Int) ≡ B.toBits (B.fromBits n ∷ BitL)

        , property $ (B.fromNBits (15 ∷ Int) (0xB1C3 ∷ Int) ∷ BitR)
                       ≡ B.pack (map n2b [ 0, 1, 1, 0, 0, 0, 1
                                         , 1, 1, 0, 0, 0, 0, 1, 1 ])
        , property $ let bs ∷ BitR
                         bs = B.pack (map n2b [ 0, 1, 1, 0, 0, 0, 1
                                              , 1, 1, 0, 0, 0, 0, 1, 1 ])
                     in
                       B.toBits bs ≡ (0x31C3 ∷ Int)
        , property $ \n → (n ∷ Int) ≡ B.toBits (B.fromBits n ∷ BitR)

          -- stream/unstream
        , property $ \bl → B.unstream (S.fromList bl) ≡ (B.pack bl ∷ BitL)
        , property $ \bs → S.toList   (B.stream bs)   ≡ B.unpack (bs ∷ BitL)

        , property $ \bl → B.unstream (S.fromList bl) ≡ (B.pack bl ∷ BitR)
        , property $ \bs → S.toList   (B.stream bs)   ≡ B.unpack (bs ∷ BitR)

          -- direction
        , conjoin
          [ property $ B.toByteString (B.directionLToR (B.pack (map n2b [1,1,0,1,0,0,1,0, 1,0,0])))
                         ≡ BS.pack [0xD2, 0x80]
          , property $ B.toByteString (B.directionRToL (B.pack (map n2b [1,1,0,1,0,0,1,0, 1,0,0])))
                         ≡ BS.pack [0x4B, 0x01]
          ]
        , property $ \bs → B.directionRToL (B.directionLToR bs) ≡ bs
        , property $ \bs → B.directionLToR (B.directionRToL bs) ≡ bs

          -- show
        , conjoin
          [ property $ show (B.pack [ True , False, False, True, True
                                    , False, False, False, True, False
                                    , True , False, True , True, True  ] ∷ BitL)
                       ≡ "(S[00011001←][1110101←])"
          , property $ show (B.pack [ True , False, False, True, True
                                    , False, False, False, True, False
                                    , True , False, True , True, True  ] ∷ BitR)
                       ≡ "(S[→10011000][→1010111])"
          ]

          -- equality
        , property $ \(bl1, bl2) → ((B.pack bl1 ∷ BitL) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
        , property $ \(bl1, bl2) → ((B.pack bl1 ∷ BitR) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)

          -- ordering
        , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitL) `compare` B.pack bl2 ≡ bl1 `compare` bl2
        , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitR) `compare` B.pack bl2 ≡ bl1 `compare` bl2

          -- monoid
        , conjoin
          [ property $ ((M.∅) ∷ BitL) ≡ B.pack (M.∅)
          , property $ ((M.∅) ∷ BitR) ≡ B.pack (M.∅)
          ]

        , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitL) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
        , property $ \bls → M.mconcat (map B.pack bls ∷ [BitL]) ≡ B.pack (M.mconcat bls)

        , property $ \(bl1, bl2) → (B.pack bl1 ∷ BitR) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
        , property $ \bls → M.mconcat (map B.pack bls ∷ [BitR]) ≡ B.pack (M.mconcat bls)

          -- basic interface
        , property $ \(b, bl) → B.cons b (B.pack bl ∷ BitL) ≡ B.pack (b:bl)
        , property $ \(bl, b) → B.snoc (B.pack bl ∷ BitL) b ≡ B.pack (bl ⧺ [b])
        , property $ \(x, y) → (B.pack x ∷ BitL) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
        , property $ \bl → (¬) (null bl) ⟹ B.head (B.pack bl ∷ BitL) ≡ head bl
        , property $ \bl → (¬) (null bl) ⟹ B.last (B.pack bl ∷ BitL) ≡ last bl
        , property $ \bl → (¬) (null bl) ⟹ B.tail (B.pack bl ∷ BitL) ≡ B.pack (tail bl)
        , property $ \bl → (¬) (null bl) ⟹ B.init (B.pack bl ∷ BitL) ≡ B.pack (init bl)
        , property $ \bl → let bs = B.pack bl ∷ BitL
                           in case bl of
                                [] → label "null"     $ B.null bs
                                _  → label "non-null" $ (¬) (B.null bs)
        , property $ \bl → B.length (B.pack bl ∷ BitL) ≡ length bl

        , property $ \(b, bl) → B.cons b (B.pack bl ∷ BitR) ≡ B.pack (b:bl)
        , property $ \(bl, b) → B.snoc (B.pack bl ∷ BitR) b ≡ B.pack (bl ⧺ [b])
        , property $ \(x, y) → (B.pack x ∷ BitR) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
        , property $ \bl → (¬) (null bl) ⟹ B.head (B.pack bl ∷ BitR) ≡ head bl
        , property $ \bl → (¬) (null bl) ⟹ B.last (B.pack bl ∷ BitR) ≡ last bl
        , property $ \bl → (¬) (null bl) ⟹ B.tail (B.pack bl ∷ BitR) ≡ B.pack (tail bl)
        , property $ \bl → (¬) (null bl) ⟹ B.init (B.pack bl ∷ BitR) ≡ B.pack (init bl)
        , property $ \bl → let bs = B.pack bl ∷ BitR
                           in case bl of
                                [] → label "null"     $ B.null bs
                                _  → label "non-null" $ (¬) (B.null bs)
        , property $ \bl → B.length (B.pack bl ∷ BitR) ≡ length bl

          -- transformation
        , property $ \bl → B.map (¬) (B.pack bl ∷ BitL) ≡ B.pack (map (¬) bl)
        , property $ \bl → B.reverse (B.pack bl ∷ BitL) ≡ B.pack (reverse bl)

        , property $ \bl → B.map (¬) (B.pack bl ∷ BitR) ≡ B.pack (map (¬) bl)
        , property $ \bl → B.reverse (B.pack bl ∷ BitL) ≡ B.pack (reverse bl)

         -- reduction
        , property $ \(n, bl) → B.foldl doubleIf n (B.pack bl ∷ BitL) ≡ foldl doubleIf n bl
        , property $ \(n, bl) → B.foldl' doubleIf n (B.pack bl ∷ BitL) ≡ foldl doubleIf n bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl ∷ BitL) ≡ foldl1 xor bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl ∷ BitL) ≡ foldl1' xor bl
        , property $ \(n, bl) → B.foldr (flip doubleIf) n (B.pack bl ∷ BitL) ≡ foldr (flip doubleIf) n bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl ∷ BitL) ≡ foldr1 xor bl

        , property $ \(n, bl) → B.foldl doubleIf n (B.pack bl ∷ BitR) ≡ foldl doubleIf n bl
        , property $ \(n, bl) → B.foldl' doubleIf n (B.pack bl ∷ BitR) ≡ foldl doubleIf n bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl ∷ BitR) ≡ foldl1 xor bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl ∷ BitR) ≡ foldl1' xor bl
        , property $ \(n, bl) → B.foldr (flip doubleIf) n (B.pack bl ∷ BitR) ≡ foldr (flip doubleIf) n bl
        , property $ \bl → (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl ∷ BitR) ≡ foldr1 xor bl

          -- special folds
        , property $ \bls → B.concat (map B.pack bls ∷ [BitL]) ≡ B.pack (concat bls)
        , property $ \bl → let f True  = [True , True , True ]
                               f False = [False, False, False]
                           in B.concatMap (B.pack ∘ f) (B.pack bl ∷ BitL) ≡ B.pack (concatMap f bl)
        , property $ \bl → B.and (B.pack bl ∷ BitL) ≡ and bl
        , property $ \bl → B.or  (B.pack bl ∷ BitL) ≡ or  bl
        , property $ \bl → B.any id (B.pack bl ∷ BitL) ≡ any id bl
        , property $ \bl → B.all id (B.pack bl ∷ BitL) ≡ all id bl

        , property $ \bls → B.concat (map B.pack bls ∷ [BitR]) ≡ B.pack (concat bls)
        , property $ \bl → let f True  = [True , True , True ]
                               f False = [False, False, False]
                           in B.concatMap (B.pack ∘ f) (B.pack bl ∷ BitR) ≡ B.pack (concatMap f bl)
        , property $ \bl → B.and (B.pack bl ∷ BitR) ≡ and bl
        , property $ \bl → B.or  (B.pack bl ∷ BitR) ≡ or  bl
        , property $ \bl → B.any id (B.pack bl ∷ BitR) ≡ any id bl
        , property $ \bl → B.all id (B.pack bl ∷ BitR) ≡ all id bl

          -- scans
        , property $ \(b, bl) → B.scanl xor b (B.pack bl ∷ BitL) ≡ B.pack (scanl xor b bl)
        , property $ \bl → B.scanl1 xor (B.pack bl ∷ BitL) ≡ B.pack (scanl1 xor bl)
        , property $ \(b, bl) → B.scanr xor b (B.pack bl ∷ BitL) ≡ B.pack (scanr xor b bl)
        , property $ \bl → B.scanr1 xor (B.pack bl ∷ BitL) ≡ B.pack (scanr1 xor bl)

        , property $ \(b, bl) → B.scanl xor b (B.pack bl ∷ BitR) ≡ B.pack (scanl xor b bl)
        , property $ \bl → B.scanl1 xor (B.pack bl ∷ BitR) ≡ B.pack (scanl1 xor bl)
        , property $ \(b, bl) → B.scanr xor b (B.pack bl ∷ BitR) ≡ B.pack (scanr xor b bl)
        , property $ \bl → B.scanr1 xor (B.pack bl ∷ BitR) ≡ B.pack (scanr1 xor bl)

          -- replication
        , property $ \(n, b) → (B.replicate (n `rem` 800) b ∷ BitL) ≡ B.pack (replicate (n `rem` 800) b)
        , property $ \(n, b) → (B.replicate (n `rem` 800) b ∷ BitR) ≡ B.pack (replicate (n `rem` 800) b)

          -- unfolding
        , property $ \n → (B.unfoldr decr (abs (n `rem` 800)) ∷ BitL) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
        , property $ \(m, n) → let m'            = m `rem` 800
                                   n'            = abs (n `rem` 800)
                                   r             = B.unfoldrN m' decr n'
                                   p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) ∷ BitL)
                                     | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
                                     | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
                               in p

        , property $ \n → (B.unfoldr decr (abs (n `rem` 800)) ∷ BitR) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
        , property $ \(m, n) → let m'            = m `rem` 800
                                   n'            = abs (n `rem` 800)
                                   r             = B.unfoldrN m' decr n'
                                   p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) ∷ BitR)
                                     | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
                                     | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
                               in p

          -- substreams
        , property $ \(n, bl) → B.take n (B.pack bl ∷ BitL) ≡ B.pack (take n bl)
        , property $ \(n, bl) → B.drop n (B.pack bl ∷ BitL) ≡ B.pack (drop n bl)
        , property $ \bl → B.takeWhile id (B.pack bl ∷ BitL) ≡ B.pack (takeWhile id bl)
        , property $ \bl → B.dropWhile id (B.pack bl ∷ BitL) ≡ B.pack (dropWhile id bl)
        , property $ \bl → B.span id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (span id bl)
        , property $ \bl → B.break id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (break id bl)

        , property $ \(n, bl) → B.take n (B.pack bl ∷ BitR) ≡ B.pack (take n bl)
        , property $ \(n, bl) → B.drop n (B.pack bl ∷ BitR) ≡ B.pack (drop n bl)
        , property $ \bl → B.takeWhile id (B.pack bl ∷ BitR) ≡ B.pack (takeWhile id bl)
        , property $ \bl → B.dropWhile id (B.pack bl ∷ BitR) ≡ B.pack (dropWhile id bl)
        , property $ \bl → B.span id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (span id bl)
        , property $ \bl → B.break id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (break id bl)

          -- searching by equality
        , property $ \(b, bl) → (b B.∈ (B.pack bl ∷ BitL)) ≡ (b ∈ bl)
        , property $ \(b, bl) → (b B.∉ (B.pack bl ∷ BitL)) ≡ (b ∉ bl)

        , property $ \(b, bl) → (b B.∈ (B.pack bl ∷ BitR)) ≡ (b ∈ bl)
        , property $ \(b, bl) → (b B.∉ (B.pack bl ∷ BitR)) ≡ (b ∉ bl)

          -- searching with a predicate
        , property $ \bl → B.find id (B.pack bl ∷ BitL) ≡ find id bl
        , property $ \bl → B.filter id (B.pack bl ∷ BitL) ≡ B.pack (filter id bl)
        , property $ \bl → B.partition id (B.pack bl ∷ BitL) ≡ fmapT2 B.pack (partition id bl)

        , property $ \bl → B.find id (B.pack bl ∷ BitR) ≡ find id bl
        , property $ \bl → B.filter id (B.pack bl ∷ BitR) ≡ B.pack (filter id bl)
        , property $ \bl → B.partition id (B.pack bl ∷ BitR) ≡ fmapT2 B.pack (partition id bl)

          -- indexing streams
        , property $ \bl → (¬) (null bl) ⟹
                             let ig = choose (0, length bl - 1)
                                 bs = B.pack bl ∷ BitL
                             in forAll ig $ \ i → bs B.!! i ≡ bl !! i
        , property $ \(b, bl) → B.elemIndex b (B.pack bl ∷ BitL) ≡ elemIndex b bl
        , property $ \(b, bl) → B.elemIndices b (B.pack bl ∷ BitL) ≡ elemIndices b bl

        , property $ \bl → (¬) (null bl) ⟹
                               let ig = choose (0, length bl - 1)
                                   bs = B.pack bl ∷ BitR
                               in forAll ig $ \ i → bs B.!! i ≡ bl !! i
        , property $ \(b, bl) → B.elemIndex b (B.pack bl ∷ BitR) ≡ elemIndex b bl
        , property $ \(b, bl) → B.elemIndices b (B.pack bl ∷ BitR) ≡ elemIndices b bl

          -- zipping and unzipping streams
        , property $ \(bl1, bl2)
                       → B.zip (B.pack bl1 ∷ BitL) (B.pack bl2)
                              ≡ zip bl1 bl2
        , property $ \(bl1, bl2, bl3)
                       → B.zip3 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3)
                              ≡ zip3 bl1 bl2 bl3
        , property $ \(bl1, bl2, bl3, bl4)
                       → B.zip4 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4)
                              ≡ zip4 bl1 bl2 bl3 bl4
        , property $ \(bl1, bl2, bl3, bl4, bl5)
                       → B.zip5 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
                              ≡ zip5 bl1 bl2 bl3 bl4 bl5
        , property $ \(bl1, bl2, bl3, bl4, bl5, bl6)
                       → B.zip6 (B.pack bl1 ∷ BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
                              ≡ zip6 bl1 bl2 bl3 bl4 bl5 bl6

        , property $ \(bl1, bl2)
                       → B.zip (B.pack bl1 ∷ BitR) (B.pack bl2)
                              ≡ zip bl1 bl2
        , property $ \(bl1, bl2, bl3)
                       → B.zip3 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3)
                              ≡ zip3 bl1 bl2 bl3
        , property $ \(bl1, bl2, bl3, bl4)
                       → B.zip4 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4)
                              ≡ zip4 bl1 bl2 bl3 bl4
        , property $ \(bl1, bl2, bl3, bl4, bl5)
                       → B.zip5 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
                              ≡ zip5 bl1 bl2 bl3 bl4 bl5
        , property $ \(bl1, bl2, bl3, bl4, bl5, bl6)
                       → B.zip6 (B.pack bl1 ∷ BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
                              ≡ zip6 bl1 bl2 bl3 bl4 bl5 bl6
        ]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    FlexibleContexts
  , OverloadedStrings
  , ScopedTypeVariables
  , UndecidableInstances
  , UnicodeSyntax
  #-}
module Main (main) where
import Data.Bitstream (Bitstream, Left, Right)
import qualified Data.Bitstream as B
import qualified Data.ByteString as BS
import Data.ByteString.Char8 ()
import Data.List
import Data.List.Unicode
import qualified Data.Monoid as M
import qualified Data.Monoid.Unicode as M
import qualified Data.Vector.Fusion.Stream as S
import Prelude.Unicode
import Test.Bitstream.Utils
import Test.QuickCheck hiding ((.&.))

type BitL = Bitstream Left
type BitR = Bitstream Right

main :: IO ()
main = mapM_ runTest tests

tests :: [Property]
tests = [ -- ∅
          conjoin
          [ property $ B.null      ((B.∅) :: BitL)
          , property $ B.length    ((B.∅) :: BitL) ≡ (0 ::Int)
          , property $ B.pack [] ≡ ((B.∅) :: BitL)
          , property $ B.empty   ≡ ((B.∅) :: BitL)
          ]

        , conjoin
          [ property $ B.null      ((B.∅) :: BitR)
          , property $ B.length    ((B.∅) :: BitR) ≡ (0 :: Int)
          , property $ B.pack [] ≡ ((B.∅) :: BitR)
          , property $ B.empty   ≡ ((B.∅) :: BitR)
          ]

          -- singleton
        , property $ \b -> B.length (B.singleton b :: BitL) ≡ (1 :: Int)
        , property $ \b -> B.head   (B.singleton b :: BitL) ≡ b
        , property $ \b -> B.pack [b] ≡ (B.singleton b :: BitL)

        , property $ \b -> B.length (B.singleton b :: BitR) ≡ (1 :: Int)
        , property $ \b -> B.head   (B.singleton b :: BitR) ≡ b
        , property $ \b -> B.pack [b] ≡ (B.singleton b :: BitR)

          -- pack/unpack
        , conjoin
          [ property $ B.unpack (B.pack []      :: BitL) ≡ []
          , property $ B.unpack (B.pack [False] :: BitL) ≡ [False]
          , property $ B.unpack (B.pack [True ] :: BitL) ≡ [True ]
          ]
        , property $ \bl -> B.unpack (B.pack bl :: BitL) ≡ bl
        , property $ \bs -> B.pack (B.unpack (bs :: BitL)) ≡ bs

        , conjoin
          [ property $ B.unpack (B.pack []      :: BitR) ≡ []
          , property $ B.unpack (B.pack [False] :: BitR) ≡ [False]
          , property $ B.unpack (B.pack [True ] :: BitR) ≡ [True ]
          ]
        , property $ \bl -> B.unpack (B.pack bl :: BitR) ≡ bl
        , property $ \bs -> B.pack (B.unpack (bs :: BitR)) ≡ bs

          -- from/toByteString
        , property $ (B.fromByteString "UNK" :: BitL)
                       ≡ B.pack (map n2b [ 1, 0, 1, 0, 1, 0, 1, 0
                                         , 0, 1, 1, 1, 0, 0, 1, 0
                                         , 1, 1, 0, 1, 0, 0, 1, 0 ])
        , property $ \str -> B.toByteString (B.fromByteString str :: BitL) ≡ str
        , mapSize (⋅ 8) $ \bs -> (B.length bs `rem` 8) ≡ (0 :: Int)
                                  ⟹ B.fromByteString (B.toByteString (bs :: BitL)) ≡ bs

        , property $ (B.fromByteString "UNK" :: BitR)
                       ≡ B.pack (map n2b [ 0, 1, 0, 1, 0, 1, 0, 1
                                         , 0, 1, 0, 0, 1, 1, 1, 0
                                         , 0, 1, 0, 0, 1, 0, 1, 1 ])
        , property $ \str -> B.toByteString (B.fromByteString str :: BitR) ≡ str
        , mapSize (⋅ 8) $ \bs -> (B.length bs `rem` 8) ≡ (0 :: Int)
                                  ⟹ B.fromByteString (B.toByteString (bs :: BitR)) ≡ bs

          -- from/toBits
        , property $ (B.fromNBits (15 :: Int) (0xB1C3 :: Int) :: BitL)
                       ≡ B.pack (map n2b [ 1, 1, 0, 0, 0, 0, 1, 1
                                         , 1, 0, 0, 0, 1, 1, 0    ])
        , property $ let bs :: BitL
                         bs = B.pack (map n2b [ 1, 1, 0, 0, 0, 0, 1, 1
                                              , 1, 0, 0, 0, 1, 1, 0    ])
                     in
                       B.toBits bs ≡ (0x31C3 :: Int)
        , property $ \n -> (n :: Int) ≡ B.toBits (B.fromBits n :: BitL)

        , property $ (B.fromNBits (15 :: Int) (0xB1C3 :: Int) :: BitR)
                       ≡ B.pack (map n2b [ 0, 1, 1, 0, 0, 0, 1
                                         , 1, 1, 0, 0, 0, 0, 1, 1 ])
        , property $ let bs :: BitR
                         bs = B.pack (map n2b [ 0, 1, 1, 0, 0, 0, 1
                                              , 1, 1, 0, 0, 0, 0, 1, 1 ])
                     in
                       B.toBits bs ≡ (0x31C3 :: Int)
        , property $ \n -> (n :: Int) ≡ B.toBits (B.fromBits n :: BitR)

          -- stream/unstream
        , property $ \bl -> B.unstream (S.fromList bl) ≡ (B.pack bl :: BitL)
        , property $ \bs -> S.toList   (B.stream bs)   ≡ B.unpack (bs :: BitL)

        , property $ \bl -> B.unstream (S.fromList bl) ≡ (B.pack bl :: BitR)
        , property $ \bs -> S.toList   (B.stream bs)   ≡ B.unpack (bs :: BitR)

          -- direction
        , conjoin
          [ property $ B.toByteString (B.directionLToR (B.pack (map n2b [1,1,0,1,0,0,1,0, 1,0,0])))
                         ≡ BS.pack [0xD2, 0x80]
          , property $ B.toByteString (B.directionRToL (B.pack (map n2b [1,1,0,1,0,0,1,0, 1,0,0])))
                         ≡ BS.pack [0x4B, 0x01]
          ]
        , property $ \bs -> B.directionRToL (B.directionLToR bs) ≡ bs
        , property $ \bs -> B.directionLToR (B.directionRToL bs) ≡ bs

          -- show
        , conjoin
          [ property $ show (B.pack [ True , False, False, True, True
                                    , False, False, False, True, False
                                    , True , False, True , True, True  ] :: BitL)
                       ≡ "(S[00011001←][1110101←])"
          , property $ show (B.pack [ True , False, False, True, True
                                    , False, False, False, True, False
                                    , True , False, True , True, True  ] :: BitR)
                       ≡ "(S[→10011000][→1010111])"
          ]

          -- equality
        , property $ \(bl1, bl2) -> ((B.pack bl1 :: BitL) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)
        , property $ \(bl1, bl2) -> ((B.pack bl1 :: BitR) ≡ B.pack bl2) ≡ (bl1 ≡ bl2)

          -- ordering
        , property $ \(bl1, bl2) -> (B.pack bl1 :: BitL) `compare` B.pack bl2 ≡ bl1 `compare` bl2
        , property $ \(bl1, bl2) -> (B.pack bl1 :: BitR) `compare` B.pack bl2 ≡ bl1 `compare` bl2

          -- monoid
        , conjoin
          [ property $ ((M.∅) :: BitL) ≡ B.pack (M.∅)
          , property $ ((M.∅) :: BitR) ≡ B.pack (M.∅)
          ]

        , property $ \(bl1, bl2) -> (B.pack bl1 :: BitL) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
        , property $ \bls -> M.mconcat (map B.pack bls :: [BitL]) ≡ B.pack (M.mconcat bls)

        , property $ \(bl1, bl2) -> (B.pack bl1 :: BitR) M.⊕ B.pack bl2 ≡ B.pack (bl1 M.⊕ bl2)
        , property $ \bls -> M.mconcat (map B.pack bls :: [BitR]) ≡ B.pack (M.mconcat bls)

          -- basic interface
        , property $ \(b, bl) -> B.cons b (B.pack bl :: BitL) ≡ B.pack (b:bl)
        , property $ \(bl, b) -> B.snoc (B.pack bl :: BitL) b ≡ B.pack (bl ⧺ [b])
        , property $ \(x, y) -> (B.pack x :: BitL) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
        , property $ \bl -> (¬) (null bl) ⟹ B.head (B.pack bl :: BitL) ≡ head bl
        , property $ \bl -> (¬) (null bl) ⟹ B.last (B.pack bl :: BitL) ≡ last bl
        , property $ \bl -> (¬) (null bl) ⟹ B.tail (B.pack bl :: BitL) ≡ B.pack (tail bl)
        , property $ \bl -> (¬) (null bl) ⟹ B.init (B.pack bl :: BitL) ≡ B.pack (init bl)
        , property $ \bl -> let bs = B.pack bl :: BitL
                            in case bl of
                                 [] -> label "null"     $ B.null bs
                                 _  -> label "non-null" $ (¬) (B.null bs)
        , property $ \bl -> B.length (B.pack bl :: BitL) ≡ length bl

        , property $ \(b, bl) -> B.cons b (B.pack bl :: BitR) ≡ B.pack (b:bl)
        , property $ \(bl, b) -> B.snoc (B.pack bl :: BitR) b ≡ B.pack (bl ⧺ [b])
        , property $ \(x, y) -> (B.pack x :: BitR) B.⧺ B.pack y ≡ B.pack (x ⧺ y)
        , property $ \bl -> (¬) (null bl) ⟹ B.head (B.pack bl :: BitR) ≡ head bl
        , property $ \bl -> (¬) (null bl) ⟹ B.last (B.pack bl :: BitR) ≡ last bl
        , property $ \bl -> (¬) (null bl) ⟹ B.tail (B.pack bl :: BitR) ≡ B.pack (tail bl)
        , property $ \bl -> (¬) (null bl) ⟹ B.init (B.pack bl :: BitR) ≡ B.pack (init bl)
        , property $ \bl -> let bs = B.pack bl :: BitR
                            in case bl of
                                 [] -> label "null"     $ B.null bs
                                 _  -> label "non-null" $ (¬) (B.null bs)
        , property $ \bl -> B.length (B.pack bl :: BitR) ≡ length bl

          -- transformation
        , property $ \bl -> B.map (¬) (B.pack bl :: BitL) ≡ B.pack (map (¬) bl)
        , property $ \bl -> B.reverse (B.pack bl :: BitL) ≡ B.pack (reverse bl)

        , property $ \bl -> B.map (¬) (B.pack bl :: BitR) ≡ B.pack (map (¬) bl)
        , property $ \bl -> B.reverse (B.pack bl :: BitL) ≡ B.pack (reverse bl)

         -- reduction
        , property $ \(n, bl) -> B.foldl doubleIf n (B.pack bl :: BitL) ≡ foldl doubleIf n bl
        , property $ \(n, bl) -> B.foldl' doubleIf n (B.pack bl :: BitL) ≡ foldl doubleIf n bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl :: BitL) ≡ foldl1 xor bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl :: BitL) ≡ foldl1' xor bl
        , property $ \(n, bl) -> B.foldr (flip doubleIf) n (B.pack bl :: BitL) ≡ foldr (flip doubleIf) n bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl :: BitL) ≡ foldr1 xor bl

        , property $ \(n, bl) -> B.foldl doubleIf n (B.pack bl :: BitR) ≡ foldl doubleIf n bl
        , property $ \(n, bl) -> B.foldl' doubleIf n (B.pack bl :: BitR) ≡ foldl doubleIf n bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldl1 xor (B.pack bl :: BitR) ≡ foldl1 xor bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldl1' xor (B.pack bl :: BitR) ≡ foldl1' xor bl
        , property $ \(n, bl) -> B.foldr (flip doubleIf) n (B.pack bl :: BitR) ≡ foldr (flip doubleIf) n bl
        , property $ \bl -> (¬) (null bl) ⟹ B.foldr1 xor (B.pack bl :: BitR) ≡ foldr1 xor bl

          -- special folds
        , property $ \bls -> B.concat (map B.pack bls :: [BitL]) ≡ B.pack (concat bls)
        , property $ \bl -> let f True  = [True , True , True ]
                                f False = [False, False, False]
                            in B.concatMap (B.pack ∘ f) (B.pack bl :: BitL) ≡ B.pack (concatMap f bl)
        , property $ \bl -> B.and (B.pack bl :: BitL) ≡ and bl
        , property $ \bl -> B.or  (B.pack bl :: BitL) ≡ or  bl
        , property $ \bl -> B.any id (B.pack bl :: BitL) ≡ any id bl
        , property $ \bl -> B.all id (B.pack bl :: BitL) ≡ all id bl

        , property $ \bls -> B.concat (map B.pack bls :: [BitR]) ≡ B.pack (concat bls)
        , property $ \bl -> let f True  = [True , True , True ]
                                f False = [False, False, False]
                            in B.concatMap (B.pack ∘ f) (B.pack bl :: BitR) ≡ B.pack (concatMap f bl)
        , property $ \bl -> B.and (B.pack bl :: BitR) ≡ and bl
        , property $ \bl -> B.or  (B.pack bl :: BitR) ≡ or  bl
        , property $ \bl -> B.any id (B.pack bl :: BitR) ≡ any id bl
        , property $ \bl -> B.all id (B.pack bl :: BitR) ≡ all id bl

          -- scans
        , property $ \(b, bl) -> B.scanl xor b (B.pack bl :: BitL) ≡ B.pack (scanl xor b bl)
        , property $ \bl -> B.scanl1 xor (B.pack bl :: BitL) ≡ B.pack (scanl1 xor bl)
        , property $ \(b, bl) -> B.scanr xor b (B.pack bl :: BitL) ≡ B.pack (scanr xor b bl)
        , property $ \bl -> B.scanr1 xor (B.pack bl :: BitL) ≡ B.pack (scanr1 xor bl)

        , property $ \(b, bl) -> B.scanl xor b (B.pack bl :: BitR) ≡ B.pack (scanl xor b bl)
        , property $ \bl -> B.scanl1 xor (B.pack bl :: BitR) ≡ B.pack (scanl1 xor bl)
        , property $ \(b, bl) -> B.scanr xor b (B.pack bl :: BitR) ≡ B.pack (scanr xor b bl)
        , property $ \bl -> B.scanr1 xor (B.pack bl :: BitR) ≡ B.pack (scanr1 xor bl)

          -- replication
        , property $ \(n, b) -> (B.replicate (n `rem` 800) b :: BitL) ≡ B.pack (replicate (n `rem` 800) b)
        , property $ \(n, b) -> (B.replicate (n `rem` 800) b :: BitR) ≡ B.pack (replicate (n `rem` 800) b)

          -- unfolding
        , property $ \n -> (B.unfoldr decr (abs (n `rem` 800)) :: BitL) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
        , property $ \(m, n) -> let m'            = m `rem` 800
                                    n'            = abs (n `rem` 800)
                                    r             = B.unfoldrN m' decr n'
                                    p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) :: BitL)
                                      | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
                                      | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
                                in p

        , property $ \n -> (B.unfoldr decr (abs (n `rem` 800)) :: BitR) ≡ B.pack (unfoldr decr (abs (n `rem` 800)))
        , property $ \(m, n) -> let m'            = m `rem` 800
                                    n'            = abs (n `rem` 800)
                                    r             = B.unfoldrN m' decr n'
                                    p | m' ≤ 0    = label "m ≤ 0"     $ r ≡ ((B.∅) :: BitR)
                                      | m' ≤ n'   = label "m ≤ n'"    $ r ≡ B.pack (take m' (unfoldr decr n'))
                                      | otherwise = label "otherwise" $ r ≡ B.pack (unfoldr decr n')
                                in p

          -- substreams
        , property $ \(n, bl) -> B.take n (B.pack bl :: BitL) ≡ B.pack (take n bl)
        , property $ \(n, bl) -> B.drop n (B.pack bl :: BitL) ≡ B.pack (drop n bl)
        , property $ \bl -> B.takeWhile id (B.pack bl :: BitL) ≡ B.pack (takeWhile id bl)
        , property $ \bl -> B.dropWhile id (B.pack bl :: BitL) ≡ B.pack (dropWhile id bl)
        , property $ \bl -> B.span id (B.pack bl :: BitL) ≡ fmapT2 B.pack (span id bl)
        , property $ \bl -> B.break id (B.pack bl :: BitL) ≡ fmapT2 B.pack (break id bl)

        , property $ \(n, bl) -> B.take n (B.pack bl :: BitR) ≡ B.pack (take n bl)
        , property $ \(n, bl) -> B.drop n (B.pack bl :: BitR) ≡ B.pack (drop n bl)
        , property $ \bl -> B.takeWhile id (B.pack bl :: BitR) ≡ B.pack (takeWhile id bl)
        , property $ \bl -> B.dropWhile id (B.pack bl :: BitR) ≡ B.pack (dropWhile id bl)
        , property $ \bl -> B.span id (B.pack bl :: BitR) ≡ fmapT2 B.pack (span id bl)
        , property $ \bl -> B.break id (B.pack bl :: BitR) ≡ fmapT2 B.pack (break id bl)

          -- searching by equality
        , property $ \(b, bl) -> (b B.∈ (B.pack bl :: BitL)) ≡ (b ∈ bl)
        , property $ \(b, bl) -> (b B.∉ (B.pack bl :: BitL)) ≡ (b ∉ bl)

        , property $ \(b, bl) -> (b B.∈ (B.pack bl :: BitR)) ≡ (b ∈ bl)
        , property $ \(b, bl) -> (b B.∉ (B.pack bl :: BitR)) ≡ (b ∉ bl)

          -- searching with a predicate
        , property $ \bl -> B.find id (B.pack bl :: BitL) ≡ find id bl
        , property $ \bl -> B.filter id (B.pack bl :: BitL) ≡ B.pack (filter id bl)
        , property $ \bl -> B.partition id (B.pack bl :: BitL) ≡ fmapT2 B.pack (partition id bl)

        , property $ \bl -> B.find id (B.pack bl :: BitR) ≡ find id bl
        , property $ \bl -> B.filter id (B.pack bl :: BitR) ≡ B.pack (filter id bl)
        , property $ \bl -> B.partition id (B.pack bl :: BitR) ≡ fmapT2 B.pack (partition id bl)

          -- indexing streams
        , property $ \bl -> (¬) (null bl) ⟹
                             let ig = choose (0, length bl - 1)
                                 bs = B.pack bl :: BitL
                             in forAll ig $ \ i -> bs B.!! i ≡ bl !! i
        , property $ \(b, bl) -> B.elemIndex b (B.pack bl :: BitL) ≡ elemIndex b bl
        , property $ \(b, bl) -> B.elemIndices b (B.pack bl :: BitL) ≡ elemIndices b bl

        , property $ \bl -> (¬) (null bl) ⟹
                               let ig = choose (0, length bl - 1)
                                   bs = B.pack bl :: BitR
                               in forAll ig $ \ i -> bs B.!! i ≡ bl !! i
        , property $ \(b, bl) -> B.elemIndex b (B.pack bl :: BitR) ≡ elemIndex b bl
        , property $ \(b, bl) -> B.elemIndices b (B.pack bl :: BitR) ≡ elemIndices b bl

          -- zipping and unzipping streams
        , property $ \(bl1, bl2)
                       -> B.zip (B.pack bl1 :: BitL) (B.pack bl2)
                              ≡ zip bl1 bl2
        , property $ \(bl1, bl2, bl3)
                       -> B.zip3 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3)
                              ≡ zip3 bl1 bl2 bl3
        , property $ \(bl1, bl2, bl3, bl4)
                       -> B.zip4 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4)
                              ≡ zip4 bl1 bl2 bl3 bl4
        , property $ \(bl1, bl2, bl3, bl4, bl5)
                       -> B.zip5 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
                              ≡ zip5 bl1 bl2 bl3 bl4 bl5
        , property $ \(bl1, bl2, bl3, bl4, bl5, bl6)
                       -> B.zip6 (B.pack bl1 :: BitL) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
                              ≡ zip6 bl1 bl2 bl3 bl4 bl5 bl6

        , property $ \(bl1, bl2)
                       -> B.zip (B.pack bl1 :: BitR) (B.pack bl2)
                              ≡ zip bl1 bl2
        , property $ \(bl1, bl2, bl3)
                       -> B.zip3 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3)
                              ≡ zip3 bl1 bl2 bl3
        , property $ \(bl1, bl2, bl3, bl4)
                       -> B.zip4 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4)
                              ≡ zip4 bl1 bl2 bl3 bl4
        , property $ \(bl1, bl2, bl3, bl4, bl5)
                       -> B.zip5 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5)
                              ≡ zip5 bl1 bl2 bl3 bl4 bl5
        , property $ \(bl1, bl2, bl3, bl4, bl5, bl6)
                       -> B.zip6 (B.pack bl1 :: BitR) (B.pack bl2) (B.pack bl3) (B.pack bl4) (B.pack bl5) (B.pack bl6)
                              ≡ zip6 bl1 bl2 bl3 bl4 bl5 bl6
        ]

</pre>