<a href="Resize.hs488068132104836584.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Resource.hs1326012361688431513.out.html">next</a></br></br><pre>3d2
< 
4d2
< module ResolveLocals where
5d2
< {-# LINE 2 "src-ag/Expression.ag" #-}
6d2
< 
7d2
< import UU.Scanner.Position(Pos)
8d2
< import HsToken
9d2
< {-# LINE 10 "dist/build/ResolveLocals.hs" #-}
10d2
< 
11d2
< {-# LINE 2 "src-ag/Patterns.ag" #-}
12d2
< 
13d2
< -- Patterns.ag imports
14d2
< import UU.Scanner.Position(Pos)
15d2
< import CommonTypes (ConstructorIdent,Identifier)
16d2
< {-# LINE 17 "dist/build/ResolveLocals.hs" #-}
17d2
< 
18d2
< {-# LINE 2 "src-ag/AbstractSyntax.ag" #-}
19d2
< 
20d2
< -- AbstractSyntax.ag imports
21c3
< import Data.Set(Set)
---
> -- AbstractSyntax.ag imports-- Patterns.ag imports
21a4
> module ResolveLocals where UU.Scanner.Position(Pos)
21a5
> import HsToken UU.Scanner.Position(Pos)
21a6
> import CommonTypes (ConstructorIdent,Identifier) Data.Set(Set)
28d12
< {-# LINE 29 "dist/build/ResolveLocals.hs" #-}
30d13
< {-# LINE 15 "src-ag/ResolveLocals.ag" #-}
31a15
> 
31a16
> 
31a17
> 
46c32
< {-# LINE 47 "dist/build/ResolveLocals.hs" #-}
---
> 
46a33
> 
46a34
> 
46a35
> 
46a36
> 
46a37
> 
46a38
> 
46a39
> 
46a40
> 
46a41
> 
46a42
> 
46a43
> 
46a44
> 
46a45
> 
46a46
> 
46a47
> 
46a48
> 
100d101
<    {-# LINE 19 "src-ag/DistChildAttr.ag" #-}
101d101
<    rule0 = \ name_ tp_ ->
102d101
<                        {-# LINE 19 "src-ag/DistChildAttr.ag" #-}
103d101
<                        case tp_ of
104d101
<                          NT nt _ _ -> nt
105d101
<                          Self      -> error ("The type of child " ++ show name_ ++ " should not be a Self type.")
106d101
<                          Haskell t -> identifier ""
107c102
<                        {-# LINE 108 "dist/build/ResolveLocals.hs"#-}
---
> 
107a103
> 
107a104
> 
107a105
> 
107a106
> 
107a107
> 
107a108
> 
107a109
> 
109d110
<    {-# LINE 23 "src-ag/DistChildAttr.ag" #-}
110d110
<    rule1 = \ _chnt ((_lhsIinhMap) :: Map Identifier Attributes) ->
111d110
<                       {-# LINE 23 "src-ag/DistChildAttr.ag" #-}
112d110
<                       Map.findWithDefault Map.empty _chnt     _lhsIinhMap
113c111
<                       {-# LINE 114 "dist/build/ResolveLocals.hs"#-}
---
> 
113a112
> 
113a113
> 
113a114
> 
113a115
> 
115d116
<    {-# LINE 24 "src-ag/DistChildAttr.ag" #-}
116d116
<    rule2 = \ _chnt ((_lhsIsynMap) :: Map Identifier Attributes) ->
117d116
<                       {-# LINE 24 "src-ag/DistChildAttr.ag" #-}
118d116
<                       Map.findWithDefault Map.empty _chnt     _lhsIsynMap
119c117
<                       {-# LINE 120 "dist/build/ResolveLocals.hs"#-}
---
> 
119a118
> 
119a119
> 
119a120
> 
119a121
> 
121d122
<    {-# LINE 83 "src-ag/ResolveLocals.ag" #-}
122d122
<    rule3 = \ _inh _syn name_ ->
123d122
<                              {-# LINE 83 "src-ag/ResolveLocals.ag" #-}
124d122
<                              [(name_, _inh    , _syn    )]
125c123
<                              {-# LINE 126 "dist/build/ResolveLocals.hs"#-}
---
> 
125a124
> 
125a125
> 
125a126
> 
125a127
> 
127d128
<    {-# LINE 86 "src-ag/ResolveLocals.ag" #-}
128d128
<    rule4 = \ kind_ name_ tp_ ->
129d128
<                         {-# LINE 86 "src-ag/ResolveLocals.ag" #-}
130d128
<                         (name_, tp_, kind_)
131c129
<                         {-# LINE 132 "dist/build/ResolveLocals.hs"#-}
---
> 
131a130
> 
131a131
> 
131a132
> 
131a133
> 
137c139
<      _output
---
>      _output = \ name_ tp_ -> tp_ of
137a140
>                              NT nt _ _ -> nt
137a141
>                              Self      -> error ("The type of child " ++ show name_ ++ " should not be a Self type.")
137a142
>                              Haskell t -> identifier ""
137a143
>    rule1 = \ _chnt ((_lhsIinhMap) :: Map Identifier Attributes) -> Map.empty _chnt     _lhsIinhMap
137a144
>    rule2 = \ _chnt ((_lhsIsynMap) :: Map Identifier Attributes) -> Map.empty _chnt     _lhsIsynMap
138a146
> 
138a147
> 
138a148
> 
138a149
> 
138a150
> 
138a151
> 
138a152
> 
138a153
> 
138a154
> 
138a155
> 
138a156
> 
138a157
> 
138a158
> 
138a159
> 
138a160
> 
138a161
> 
138a162
> 
138a163
> 
138a164
> 
138a165
> 
138a166
> 
138a167
> 
138a168
> 
138a169
> 
138a170
> 
138a171
> 
138a172
> 
138a173
> 
138a174
> 
138a175
> 
138a176
> 
138a177
> 
138a178
> 
138a179
> 
138a180
> 
138a181
> 
138a182
> 
138a183
> 
138a184
> 
138a185
> 
138a186
> 
138a187
> 
138a188
> 
138a189
> 
138a190
> 
138a191
> 
138a192
> 
138a193
> 
138a194
> 
138a195
> 
138a196
> 
138a197
> 
138a198
> 
138a199
> 
138a200
> 
138a201
> 
138a202
> 
138a203
>    rule3 = \ _inh _syn name_ ->(name_, _inh    , _syn    )]
138a204
> 
138a205
> 
138a206
>    rule4 = \ kind_ name_ tp_ ->name_, tp_, kind_)
138a207
> 
138a208
> 
138a209
> 
138a210
> 
138a211
> 
138a212
> 
138a213
> 
138a214
> 
138a215
> 
138a216
> 
138a217
> 
138a218
> 
138a219
> 
138a220
> 
138a221
> 
138a222
> 
138a223
> 
138a224
> 
138a225
> 
138a226
> 
138a227
> 
138a228
> 
138a229
> 
138a230
> 
138a231
> 
138a232
> 
138a233
> 
138a234
> 
138a235
> 
138a236
> 
138a237
> 
138a238
> 
138a239
> 
138a240
> 
138a241
> 
138a242
> 
138a243
> 
138a244
> 
138a245
> 
138a246
> 
138a247
> 
138a248
> 
138a249
> 
138a250
> 
138a251
> 
138a252
> 
138a253
> 
138a254
> 
138a255
> 
138a256
> 
138a257
> 
138a258
> 
211d330
<    {-# LINE 89 "src-ag/ResolveLocals.ag" #-}
212d330
<    rule7 = \ ((_hdIfield) :: (Identifier,Type,ChildKind)) ((_tlIfields) :: [(Identifier,Type,ChildKind)]) ->
213d330
<                          {-# LINE 89 "src-ag/ResolveLocals.ag" #-}
214d330
<                          _hdIfield : _tlIfields
215c331
<                          {-# LINE 216 "dist/build/ResolveLocals.hs"#-}
---
> 
215a332
> 
215a333
> 
215a334
> 
215a335
> 
284c404
<      _lhsIsynMap
---
>      _lhsIsynMap = \ ((_hdIfield) :: (Identifier,Type,ChildKind)) ((_tlIfields) :: [(Identifier,Type,ChildKind)]) -> : _tlIfields
284a405
> 
284a406
> 
284a407
> 
284a408
> 
284a409
> 
284a410
> 
284a411
> 
284a412
> 
284a413
> 
284a414
> 
284a415
> 
284a416
> 
284a417
> 
284a418
> 
284a419
> 
284a420
> 
284a421
> 
284a422
> 
284a423
> 
284a424
> 
284a425
> 
284a426
> 
284a427
> 
284a428
> 
284a429
> 
284a430
> 
284a431
> 
284a432
> 
284a433
> 
284a434
> 
284a435
> 
284a436
> 
284a437
> 
284a438
> 
284a439
> 
284a440
> 
284a441
> 
284a442
> 
284a443
> 
284a444
> 
284a445
> 
284a446
> 
284a447
> 
284a448
> 
284a449
> 
284a450
> 
284a451
> 
284a452
> 
284a453
> 
284a454
> 
284a455
> 
284a456
> 
284a457
> 
284a458
> 
284a459
> 
284a460
> 
284a461
> 
284a462
> 
284a463
> 
284a464
> 
284a465
> 
284a466
> 
284a467
> 
284a468
> 
284a469
> 
284a470
> 
284a471
> 
284a472
> 
284a473
> 
284a474
> 
284a475
> 
284a476
> 
284a477
> 
284a478
> 
284a479
> 
284a480
> 
284a481
> 
284a482
> 
284a483
> 
284a484
> 
284a485
> 
284a486
> 
284a487
> 
284a488
> 
284a489
> 
284a490
> 
284a491
> 
284a492
> 
284a493
> 
284a494
> 
284a495
> 
284a496
> 
284a497
> 
284a498
> 
284a499
> 
284a500
> 
284a501
> 
284a502
> 
284a503
> 
284a504
> 
284a505
> 
284a506
> 
284a507
> 
284a508
> 
284a509
> 
284a510
> 
284a511
> 
284a512
> 
284a513
> 
284a514
> 
284a515
> 
284a516
> 
284a517
> 
284a518
> 
284a519
> 
284a520
> 
284a521
> 
284a522
> 
284a523
> 
284a524
> 
284a525
> 
284a526
> 
284a527
> 
284a528
> 
284a529
> 
284a530
> 
284a531
> 
284a532
> 
284a533
> 
284a534
> 
284a535
> 
284a536
> 
284a537
> 
284a538
> 
284a539
> 
284a540
> 
284a541
> 
284a542
> 
284a543
> 
284a544
> 
284a545
> 
284a546
> 
284a547
> 
284a548
> 
284a549
> 
284a550
> 
284a551
> 
284a552
> 
284a553
> 
284a554
> 
284a555
> 
284a556
> 
284a557
> 
284a558
> 
284a559
> 
284a560
> 
284a561
> 
284a562
> 
284a563
> 
284a564
> 
284a565
> 
284a566
> 
284a567
> 
284a568
> 
284a569
> 
284a570
> 
284a571
> 
284a572
> 
284a573
> 
284a574
> 
284a575
> 
284a576
> 
284a577
> 
284a578
> 
284a579
> 
284a580
> 
284a581
> 
284a582
> 
284a583
> 
284a584
> 
284a585
> 
284a586
> 
284a587
> 
284a588
> 
284a589
> 
284a590
> 
284a591
> 
284a592
> 
284a593
> 
284a594
> 
284a595
> 
284a596
> 
284a597
> 
284a598
> 
284a599
> 
303d617
<    {-# LINE 90 "src-ag/ResolveLocals.ag" #-}
304d617
<    rule31 = \  (_ :: ()) ->
305d617
<                          {-# LINE 90 "src-ag/ResolveLocals.ag" #-}
306d617
<                          []
307c618
<                          {-# LINE 308 "dist/build/ResolveLocals.hs"#-}
---
> 
307a619
> 
307a620
> 
307a621
> 
307a622
> 
316c631
<      _output
---
>      _output = \  (_ :: ()) ->]
317a633
> 
317a634
> 
317a635
> 
317a636
> 
317a637
> 
317a638
> 
317a639
> 
317a640
> 
317a641
> 
317a642
> 
317a643
> 
317a644
> 
317a645
> 
317a646
> 
317a647
> 
317a648
> 
317a649
> 
317a650
> 
317a651
> 
317a652
> 
317a653
> 
317a654
> 
317a655
> 
317a656
> 
317a657
> 
317a658
> 
317a659
> 
317a660
> 
317a661
> 
317a662
> 
317a663
> 
317a664
> 
317a665
> 
317a666
> 
317a667
> 
317a668
> 
317a669
> 
317a670
> 
317a671
> 
317a672
> 
317a673
> 
317a674
> 
317a675
> 
317a676
> 
317a677
> 
317a678
> 
317a679
> 
317a680
> 
317a681
> 
317a682
> 
317a683
> 
317a684
> 
317a685
> 
317a686
> 
317a687
> 
317a688
> 
317a689
> 
317a690
> 
317a691
> 
317a692
> 
317a693
> 
317a694
> 
317a695
> 
317a696
> 
317a697
> 
317a698
> 
317a699
> 
317a700
> 
317a701
> 
317a702
> 
317a703
> 
317a704
> 
317a705
> 
317a706
> 
317a707
> 
317a708
> 
317a709
> 
317a710
> 
317a711
> 
317a712
> 
317a713
> 
317a714
> 
317a715
> 
317a716
> 
317a717
> 
317a718
> 
317a719
> 
317a720
> 
317a721
> 
317a722
> 
317a723
> 
317a724
> 
317a725
> 
317a726
> 
317a727
> 
317a728
> 
317a729
> 
317a730
> 
317a731
> 
317a732
> 
317a733
> 
317a734
> 
317a735
> 
317a736
> 
317a737
> 
317a738
> 
317a739
> 
317a740
> 
317a741
> 
317a742
> 
317a743
> 
317a744
> 
317a745
> 
317a746
> 
317a747
> 
317a748
> 
317a749
> 
317a750
> 
317a751
> 
317a752
> 
317a753
> 
317a754
> 
317a755
> 
317a756
> 
317a757
> 
317a758
> 
317a759
> 
317a760
> 
317a761
> 
317a762
> 
317a763
> 
317a764
> 
317a765
> 
317a766
> 
317a767
> 
317a768
> 
317a769
> 
317a770
> 
317a771
> 
317a772
> 
317a773
> 
317a774
> 
317a775
> 
317a776
> 
317a777
> 
317a778
> 
317a779
> 
317a780
> 
317a781
> 
317a782
> 
317a783
> 
317a784
> 
317a785
> 
317a786
> 
317a787
> 
317a788
> 
317a789
> 
317a790
> 
317a791
> 
317a792
> 
317a793
> 
317a794
> 
317a795
> 
317a796
> 
317a797
> 
317a798
> 
317a799
> 
317a800
> 
317a801
> 
317a802
> 
317a803
> 
317a804
> 
317a805
> 
317a806
> 
317a807
> 
317a808
> 
317a809
> 
317a810
> 
317a811
> 
317a812
> 
317a813
> 
317a814
> 
317a815
> 
317a816
> 
317a817
> 
317a818
> 
317a819
> 
317a820
> 
317a821
> 
317a822
> 
317a823
> 
317a824
> 
317a825
> 
317a826
> 
317a827
> 
317a828
> 
317a829
> 
317a830
> 
317a831
> 
317a832
> 
317a833
> 
317a834
> 
317a835
> 
317a836
> 
317a837
> 
317a838
> 
317a839
> 
317a840
> 
317a841
> 
317a842
> 
317a843
> 
317a844
> 
317a845
> 
317a846
> 
317a847
> 
317a848
> 
317a849
> 
317a850
> 
317a851
> 
317a852
> 
317a853
> 
317a854
> 
317a855
> 
317a856
> 
317a857
> 
317a858
> 
365d905
<    {-# LINE 145 "src-ag/ResolveLocals.ag" #-}
366d905
<    rule35 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ((_lhsIallnts) :: [Identifier]) ((_lhsIattrs) :: [(Identifier,Identifier)]) ((_lhsIcon) :: Identifier) ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ((_lhsInt) :: Identifier) ((_lhsIoptions) :: Options) tks_ ->
367d905
<                                 {-# LINE 145 "src-ag/ResolveLocals.ag" #-}
368d905
<                                 let mergedChildren = [ x | (_,xs) <- Map.elems _lhsImergeMap, x <- xs ]
369d905
<                                     attrsIn = filter (\(fld,_) -> not (fld `elem` mergedChildren)) _lhsIattrs
370d905
<                                     inherited = Inh_HsTokensRoot
371d905
<                                                 { attrs_Inh_HsTokensRoot      = attrsIn
372d905
<                                                 , con_Inh_HsTokensRoot        = _lhsIcon
373d905
<                                                 , allfields_Inh_HsTokensRoot  = _lhsIallfields
374d905
<                                                 , allnts_Inh_HsTokensRoot     = _lhsIallnts
375d905
<                                                 , nt_Inh_HsTokensRoot         = _lhsInt
376d905
<                                                 , options_Inh_HsTokensRoot    = _lhsIoptions
377d905
<                                                 }
378d905
<                                     synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot tks_)) inherited
379d905
<                                 in (errors_Syn_HsTokensRoot synthesized, output_Syn_HsTokensRoot synthesized)
380c906
<                                 {-# LINE 381 "dist/build/ResolveLocals.hs"#-}
---
> 
380a907
> 
380a908
> 
380a909
> 
380a910
> 
380a911
> 
380a912
> 
380a913
> 
380a914
> 
380a915
> 
380a916
> 
380a917
> 
380a918
> 
380a919
> 
380a920
> 
380a921
> 
382d922
<    {-# LINE 157 "src-ag/ResolveLocals.ag" #-}
383d922
<    rule36 = \ _newTks pos_ ->
384d922
<                                {-# LINE 157 "src-ag/ResolveLocals.ag" #-}
385d922
<                                Expression pos_ _newTks
386c923
<                                {-# LINE 387 "dist/build/ResolveLocals.hs"#-}
---
> 
386a924
> 
386a925
> 
386a926
> 
386a927
> 
392c933
<      Expression pos_ tks_
---
>      Expression pos_ tks_ = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ((_lhsIallnts) :: [Identifier]) ((_lhsIattrs) :: [(Identifier,Identifier)]) ((_lhsIcon) :: Identifier) ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ((_lhsInt) :: Identifier) ((_lhsIoptions) :: Options) tks_ -> mergedChildren = [ x | (_,xs) <- Map.elems _lhsImergeMap, x <- xs ]
392a934
>                                                                                                                                                                                                                                                                                                                      attrsIn = filter (\(fld,_) -> not (fld `elem` mergedChildren)) _lhsIattrs
392a935
>                                                                                                                                                                                                                                                                                                                      inherited = Inh_HsTokensRoot
392a936
>                                                                                                                                                                                                                                                                                                                                  { attrs_Inh_HsTokensRoot      = attrsIn
392a937
>                                                                                                                                                                                                                                                                                                                                  , con_Inh_HsTokensRoot        = _lhsIcon
392a938
>                                                                                                                                                                                                                                                                                                                                  , allfields_Inh_HsTokensRoot  = _lhsIallfields
392a939
>                                                                                                                                                                                                                                                                                                                                  , allnts_Inh_HsTokensRoot     = _lhsIallnts
392a940
>                                                                                                                                                                                                                                                                                                                                  , nt_Inh_HsTokensRoot         = _lhsInt
392a941
>                                                                                                                                                                                                                                                                                                                                  , options_Inh_HsTokensRoot    = _lhsIoptions
392a942
>                                                                                                                                                                                                                                                                                                                                  }
392a943
>                                                                                                                                                                                                                                                                                                                      synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot tks_)) inherited
392a944
>                                                                                                                                                                                                                                                                                                                     in (errors_Syn_HsTokensRoot synthesized, output_Syn_HsTokensRoot synthesized)
392a945
>    rule36 = \ _newTks pos_ ->  Expression pos_ _newTks
393a947
> 
393a948
> 
393a949
> 
393a950
> 
393a951
> 
393a952
> 
393a953
> 
393a954
> 
393a955
> 
393a956
> 
393a957
> 
393a958
> 
393a959
> 
393a960
> 
393a961
> 
393a962
> 
393a963
> 
393a964
> 
393a965
> 
393a966
> 
393a967
> 
393a968
> 
393a969
> 
393a970
> 
393a971
> 
393a972
> 
393a973
> 
393a974
> 
393a975
> 
393a976
> 
393a977
> 
393a978
> 
393a979
> 
393a980
> 
393a981
> 
393a982
> 
393a983
> 
393a984
> 
393a985
> 
393a986
> 
393a987
> 
393a988
> 
393a989
> 
393a990
> 
393a991
> 
393a992
> 
393a993
> 
393a994
> 
393a995
> 
393a996
> 
393a997
> 
393a998
> 
393a999
> 
393a1000
> 
393a1001
> 
393a1002
> 
393a1003
> 
393a1004
> 
393a1005
> 
393a1006
> 
393a1007
> 
393a1008
> 
393a1009
> 
393a1010
> 
393a1011
> 
393a1012
> 
393a1013
> 
393a1014
> 
393a1015
> 
393a1016
> 
393a1017
> 
393a1018
> 
393a1019
> 
393a1020
> 
393a1021
> 
393a1022
> 
393a1023
> 
393a1024
> 
393a1025
> 
393a1026
> 
393a1027
> 
393a1028
> 
393a1029
> 
393a1030
> 
393a1031
> 
393a1032
> 
393a1033
> 
393a1034
> 
393a1035
> 
393a1036
> 
393a1037
> 
393a1038
> 
393a1039
> 
393a1040
> 
393a1041
> 
393a1042
> 
393a1043
> 
393a1044
> 
393a1045
> 
393a1046
> 
393a1047
> 
393a1048
> 
393a1049
> 
393a1050
> 
393a1051
> 
393a1052
> 
393a1053
> 
393a1054
> 
393a1055
> 
393a1056
> 
393a1057
> 
393a1058
> 
393a1059
> 
393a1060
> 
393a1061
> 
393a1062
> 
393a1063
> 
393a1064
> 
393a1065
> 
393a1066
> 
393a1067
> 
393a1068
> 
393a1069
> 
393a1070
> 
393a1071
> 
393a1072
> 
393a1073
> 
393a1074
> 
393a1075
> 
393a1076
> 
393a1077
> 
393a1078
> 
393a1079
> 
393a1080
> 
393a1081
> 
393a1082
> 
393a1083
> 
393a1084
> 
393a1085
> 
393a1086
> 
393a1087
> 
393a1088
> 
393a1089
> 
393a1090
> 
393a1091
> 
393a1092
> 
393a1093
> 
393a1094
> 
393a1095
> 
393a1096
> 
393a1097
> 
393a1098
> 
393a1099
> 
393a1100
> 
393a1101
> 
393a1102
> 
393a1103
> 
393a1104
> 
393a1105
> 
393a1106
> 
393a1107
> 
393a1108
> 
393a1109
> 
393a1110
> 
393a1111
> 
393a1112
> 
393a1113
> 
393a1114
> 
393a1115
> 
393a1116
> 
393a1117
> 
393a1118
> 
393a1119
> 
393a1120
> 
393a1121
> 
393a1122
> 
393a1123
> 
393a1124
> 
393a1125
> 
393a1126
> 
393a1127
> 
393a1128
> 
393a1129
> 
393a1130
> 
393a1131
> 
393a1132
> 
393a1133
> 
393a1134
> 
393a1135
> 
393a1136
> 
393a1137
> 
393a1138
> 
393a1139
> 
393a1140
> 
393a1141
> 
393a1142
> 
393a1143
> 
393a1144
> 
393a1145
> 
393a1146
> 
393a1147
> 
393a1148
> 
393a1149
> 
393a1150
> 
393a1151
> 
393a1152
> 
393a1153
> 
393a1154
> 
393a1155
> 
393a1156
> 
393a1157
> 
393a1158
> 
393a1159
> 
393a1160
> 
393a1161
> 
393a1162
> 
393a1163
> 
393a1164
> 
393a1165
> 
393a1166
> 
393a1167
> 
393a1168
> 
393a1169
> 
393a1170
> 
393a1171
> 
393a1172
> 
393a1173
> 
393a1174
> 
393a1175
> 
393a1176
> 
393a1177
> 
393a1178
> 
393a1179
> 
393a1180
> 
393a1181
> 
447d1234
<    {-# LINE 15 "src-ag/DistChildAttr.ag" #-}
448d1234
<    rule39 = \ ((_nontsIinhMap') :: Map Identifier Attributes) ->
449d1234
<                              {-# LINE 15 "src-ag/DistChildAttr.ag" #-}
450d1234
<                              _nontsIinhMap'
451c1235
<                              {-# LINE 452 "dist/build/ResolveLocals.hs"#-}
---
> 
451a1236
> 
451a1237
> 
451a1238
> 
451a1239
> 
453d1240
<    {-# LINE 16 "src-ag/DistChildAttr.ag" #-}
454d1240
<    rule40 = \ ((_nontsIsynMap') :: Map Identifier Attributes) ->
455d1240
<                              {-# LINE 16 "src-ag/DistChildAttr.ag" #-}
456d1240
<                              _nontsIsynMap'
457c1241
<                              {-# LINE 458 "dist/build/ResolveLocals.hs"#-}
---
> 
457a1242
> 
457a1243
> 
457a1244
> 
457a1245
> 
459d1246
<    {-# LINE 59 "src-ag/ResolveLocals.ag" #-}
460d1246
<    rule41 = \ ((_nontsInonts) :: [(NontermIdent,[ConstructorIdent])]) ->
461d1246
<                              {-# LINE 59 "src-ag/ResolveLocals.ag" #-}
462d1246
<                              map fst (_nontsInonts)
463c1247
<                              {-# LINE 464 "dist/build/ResolveLocals.hs"#-}
---
> 
463a1248
> 
463a1249
> 
463a1250
> 
463a1251
> 
465d1252
<    {-# LINE 119 "src-ag/ResolveLocals.ag" #-}
466d1252
<    rule42 = \ mergeMap_ ->
467d1252
<                                  {-# LINE 119 "src-ag/ResolveLocals.ag" #-}
468d1252
<                                  Map.map (Map.map (Map.map (\(nt,srcs,_) -> (nt,srcs)))) mergeMap_
469c1253
<                                  {-# LINE 470 "dist/build/ResolveLocals.hs"#-}
---
> 
469a1254
> 
469a1255
> 
469a1256
> 
469a1257
> 
481c1269
<      _lhsIoptions
---
>      _lhsIoptions = \ ((_nontsIinhMap') :: Map Identifier Attributes) ->
481a1270
>    rule40 = \ ((_nontsIsynMap') :: Map Identifier Attributes) ->
482a1272
> 
482a1273
> 
482a1274
> 
482a1275
> 
482a1276
> 
482a1277
> 
482a1278
> 
482a1279
> 
482a1280
> 
482a1281
> 
482a1282
> 
482a1283
> 
482a1284
> 
482a1285
> 
482a1286
> 
482a1287
> 
482a1288
> 
482a1289
> 
482a1290
> 
482a1291
> 
482a1292
> 
482a1293
> 
482a1294
> 
482a1295
> 
482a1296
> 
482a1297
> 
482a1298
> 
482a1299
> 
482a1300
> 
482a1301
> 
482a1302
> 
482a1303
> 
482a1304
> 
482a1305
> 
482a1306
> 
482a1307
> 
482a1308
> 
482a1309
> 
482a1310
> 
482a1311
> 
482a1312
> 
482a1313
>    rule41 = \ ((_nontsInonts) :: [(NontermIdent,[ConstructorIdent])]) -> fst (_nontsInonts)
482a1314
> 
482a1315
> 
482a1316
> 
482a1317
> 
482a1318
> 
482a1319
> 
482a1320
> 
482a1321
> 
482a1322
> 
482a1323
> 
482a1324
> 
482a1325
> 
482a1326
> 
482a1327
> 
482a1328
> 
482a1329
> 
482a1330
> 
482a1331
> 
482a1332
> 
482a1333
> 
482a1334
> 
482a1335
> 
482a1336
> 
482a1337
> 
482a1338
> 
482a1339
> 
482a1340
> 
482a1341
> 
482a1342
> 
482a1343
> 
482a1344
> 
482a1345
> 
482a1346
> 
482a1347
> 
482a1348
> 
482a1349
> 
482a1350
> 
482a1351
> 
482a1352
> 
482a1353
> 
482a1354
> 
482a1355
> 
482a1356
> 
482a1357
> 
482a1358
> 
482a1359
> 
482a1360
> 
482a1361
> 
482a1362
> 
482a1363
> 
482a1364
> 
482a1365
> 
482a1366
> 
482a1367
> 
482a1368
> 
482a1369
> 
482a1370
> 
482a1371
> 
482a1372
> 
482a1373
>    rule42 = \ mergeMap_ ->       Map.map (Map.map (Map.map (\(nt,srcs,_) -> (nt,srcs)))) mergeMap_
482a1374
> 
482a1375
> 
482a1376
> 
482a1377
> 
482a1378
> 
482a1379
> 
482a1380
> 
482a1381
> 
482a1382
> 
482a1383
> 
482a1384
> 
482a1385
> 
482a1386
> 
482a1387
> 
482a1388
> 
482a1389
> 
482a1390
> 
482a1391
> 
482a1392
> 
482a1393
> 
482a1394
> 
482a1395
> 
482a1396
> 
482a1397
> 
482a1398
> 
482a1399
> 
482a1400
> 
482a1401
> 
482a1402
> 
482a1403
> 
482a1404
> 
482a1405
> 
482a1406
> 
482a1407
> 
482a1408
> 
482a1409
> 
482a1410
> 
482a1411
> 
482a1412
> 
482a1413
> 
482a1414
> 
482a1415
> 
482a1416
> 
482a1417
> 
482a1418
> 
482a1419
> 
482a1420
> 
482a1421
> 
482a1422
> 
482a1423
> 
482a1424
> 
482a1425
> 
482a1426
> 
482a1427
> 
482a1428
> 
482a1429
> 
482a1430
> 
482a1431
> 
482a1432
> 
482a1433
> 
482a1434
> 
482a1435
> 
482a1436
> 
482a1437
> 
482a1438
> 
482a1439
> 
482a1440
> 
482a1441
> 
482a1442
> 
482a1443
> 
482a1444
> 
482a1445
> 
482a1446
> 
482a1447
> 
482a1448
> 
482a1449
> 
482a1450
> 
482a1451
> 
482a1452
> 
482a1453
> 
482a1454
> 
482a1455
> 
482a1456
> 
482a1457
> 
482a1458
> 
482a1459
> 
482a1460
> 
482a1461
> 
482a1462
> 
482a1463
> 
482a1464
> 
482a1465
> 
482a1466
> 
482a1467
> 
482a1468
> 
482a1469
> 
482a1470
> 
482a1471
> 
482a1472
> 
482a1473
> 
482a1474
> 
482a1475
> 
482a1476
> 
482a1477
> 
482a1478
> 
482a1479
> 
482a1480
> 
482a1481
> 
482a1482
> 
482a1483
> 
482a1484
> 
482a1485
> 
482a1486
> 
482a1487
> 
482a1488
> 
482a1489
> 
482a1490
> 
482a1491
> 
482a1492
> 
482a1493
> 
482a1494
> 
482a1495
> 
482a1496
> 
482a1497
> 
482a1498
> 
482a1499
> 
482a1500
> 
482a1501
> 
482a1502
> 
482a1503
> 
482a1504
> 
482a1505
> 
482a1506
> 
482a1507
> 
482a1508
> 
482a1509
> 
482a1510
> 
482a1511
> 
482a1512
> 
482a1513
> 
482a1514
> 
482a1515
> 
482a1516
> 
482a1517
> 
482a1518
> 
482a1519
> 
482a1520
> 
482a1521
> 
482a1522
> 
482a1523
> 
482a1524
> 
482a1525
> 
482a1526
> 
482a1527
> 
482a1528
> 
482a1529
> 
482a1530
> 
482a1531
> 
482a1532
> 
482a1533
> 
482a1534
> 
482a1535
> 
482a1536
> 
482a1537
> 
482a1538
> 
482a1539
> 
482a1540
> 
482a1541
> 
482a1542
> 
482a1543
> 
482a1544
> 
482a1545
> 
482a1546
> 
482a1547
> 
482a1548
> 
482a1549
> 
482a1550
> 
482a1551
> 
482a1552
> 
482a1553
> 
482a1554
> 
482a1555
> 
482a1556
> 
482a1557
> 
482a1558
> 
482a1559
> 
482a1560
> 
482a1561
> 
482a1562
> 
482a1563
> 
482a1564
> 
482a1565
> 
482a1566
> 
482a1567
> 
482a1568
> 
482a1569
> 
482a1570
> 
482a1571
> 
482a1572
> 
482a1573
> 
482a1574
> 
482a1575
> 
482a1576
> 
482a1577
> 
482a1578
> 
482a1579
> 
482a1580
> 
482a1581
> 
482a1582
> 
482a1583
> 
482a1584
> 
482a1585
> 
482a1586
> 
482a1587
> 
482a1588
> 
482a1589
> 
482a1590
> 
482a1591
> 
482a1592
> 
482a1593
> 
482a1594
> 
482a1595
> 
482a1596
> 
482a1597
> 
482a1598
> 
482a1599
> 
482a1600
> 
482a1601
> 
482a1602
> 
482a1603
> 
482a1604
> 
482a1605
> 
482a1606
> 
482a1607
> 
482a1608
> 
482a1609
> 
482a1610
> 
482a1611
> 
482a1612
> 
482a1613
> 
482a1614
> 
482a1615
> 
482a1616
> 
482a1617
> 
482a1618
> 
482a1619
> 
482a1620
> 
482a1621
> 
482a1622
> 
482a1623
> 
482a1624
> 
482a1625
> 
482a1626
> 
482a1627
> 
482a1628
> 
482a1629
> 
482a1630
> 
482a1631
> 
482a1632
> 
482a1633
> 
482a1634
> 
482a1635
> 
482a1636
> 
482a1637
> 
482a1638
> 
482a1639
> 
482a1640
> 
482a1641
> 
482a1642
> 
482a1643
> 
482a1644
> 
482a1645
> 
482a1646
> 
482a1647
> 
482a1648
> 
482a1649
> 
482a1650
> 
482a1651
> 
482a1652
> 
482a1653
> 
482a1654
> 
482a1655
> 
482a1656
> 
482a1657
> 
482a1658
> 
482a1659
> 
482a1660
> 
482a1661
> 
482a1662
> 
482a1663
> 
482a1664
> 
482a1665
> 
482a1666
> 
482a1667
> 
482a1668
> 
482a1669
> 
482a1670
> 
482a1671
> 
482a1672
> 
482a1673
> 
482a1674
> 
482a1675
> 
482a1676
> 
482a1677
> 
482a1678
> 
482a1679
> 
482a1680
> 
482a1681
> 
482a1682
> 
482a1683
> 
482a1684
> 
482a1685
> 
482a1686
> 
482a1687
> 
482a1688
> 
482a1689
> 
482a1690
> 
482a1691
> 
482a1692
> 
482a1693
> 
482a1694
> 
482a1695
> 
482a1696
> 
482a1697
> 
482a1698
> 
482a1699
> 
482a1700
> 
482a1701
> 
482a1702
> 
482a1703
> 
482a1704
> 
482a1705
> 
482a1706
> 
482a1707
> 
482a1708
> 
482a1709
> 
482a1710
> 
482a1711
> 
482a1712
> 
482a1713
> 
482a1714
> 
482a1715
> 
482a1716
> 
482a1717
> 
482a1718
> 
482a1719
> 
482a1720
> 
482a1721
> 
482a1722
> 
482a1723
> 
482a1724
> 
482a1725
> 
482a1726
> 
482a1727
> 
482a1728
> 
482a1729
> 
482a1730
> 
482a1731
> 
482a1732
> 
482a1733
> 
482a1734
> 
482a1735
> 
482a1736
> 
546d1799
<    {-# LINE 7 "src-ag/DistChildAttr.ag" #-}
547d1799
<    rule47 = \ inh_ nt_ ->
548d1799
<                                  {-# LINE 7 "src-ag/DistChildAttr.ag" #-}
549d1799
<                                  Map.singleton nt_ inh_
550c1800
<                                  {-# LINE 551 "dist/build/ResolveLocals.hs"#-}
---
> 
550a1801
> 
550a1802
> 
550a1803
> 
550a1804
> 
552d1805
<    {-# LINE 8 "src-ag/DistChildAttr.ag" #-}
553d1805
<    rule48 = \ nt_ syn_ ->
554d1805
<                                  {-# LINE 8 "src-ag/DistChildAttr.ag" #-}
555d1805
<                                  Map.singleton nt_ syn_
556c1806
<                                  {-# LINE 557 "dist/build/ResolveLocals.hs"#-}
---
> 
556a1807
> 
556a1808
> 
556a1809
> 
556a1810
> 
558d1811
<    {-# LINE 63 "src-ag/ResolveLocals.ag" #-}
559d1811
<    rule49 = \ ((_prodsIcons) :: [ConstructorIdent]) nt_ ->
560d1811
<                                 {-# LINE 63 "src-ag/ResolveLocals.ag" #-}
561d1811
<                                 [(nt_,_prodsIcons)]
562c1812
<                                 {-# LINE 563 "dist/build/ResolveLocals.hs"#-}
---
> 
562a1813
> 
562a1814
> 
562a1815
> 
562a1816
> 
564d1817
<    {-# LINE 111 "src-ag/ResolveLocals.ag" #-}
565d1817
<    rule50 = \ nt_ ->
566d1817
<                                {-# LINE 111 "src-ag/ResolveLocals.ag" #-}
567d1817
<                                nt_
568c1818
<                                {-# LINE 569 "dist/build/ResolveLocals.hs"#-}
---
> 
568a1819
> 
568a1820
> 
568a1821
> 
568a1822
> 
570d1823
<    {-# LINE 114 "src-ag/ResolveLocals.ag" #-}
571d1823
<    rule51 = \ inh_ ->
572d1823
<                                {-# LINE 114 "src-ag/ResolveLocals.ag" #-}
573d1823
<                                inh_
574c1824
<                                {-# LINE 575 "dist/build/ResolveLocals.hs"#-}
---
> 
574a1825
> 
574a1826
> 
574a1827
> 
574a1828
> 
576d1829
<    {-# LINE 115 "src-ag/ResolveLocals.ag" #-}
577d1829
<    rule52 = \ syn_ ->
578d1829
<                                {-# LINE 115 "src-ag/ResolveLocals.ag" #-}
579d1829
<                                syn_
580c1830
<                                {-# LINE 581 "dist/build/ResolveLocals.hs"#-}
---
> 
580a1831
> 
580a1832
> 
580a1833
> 
580a1834
> 
582d1835
<    {-# LINE 127 "src-ag/ResolveLocals.ag" #-}
583d1835
<    rule53 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) nt_ ->
584d1835
<                                                 {-# LINE 127 "src-ag/ResolveLocals.ag" #-}
585d1835
<                                                 Map.findWithDefault Map.empty nt_ _lhsImergeMap
586c1836
<                                                 {-# LINE 587 "dist/build/ResolveLocals.hs"#-}
---
> 
586a1837
> 
586a1838
> 
586a1839
> 
586a1840
> 
610c1864
<      _lhsIsynMap
---
>      _lhsIsynMap = \ inh_ nt_ ->        Map.singleton nt_ inh_
610a1865
>    rule48 = \ nt_ syn_ ->        Map.singleton nt_ syn_
611a1867
> 
611a1868
> 
611a1869
> 
611a1870
> 
611a1871
> 
611a1872
> 
611a1873
> 
611a1874
> 
611a1875
> 
611a1876
> 
611a1877
> 
611a1878
> 
611a1879
> 
611a1880
> 
611a1881
> 
611a1882
> 
611a1883
> 
611a1884
> 
611a1885
> 
611a1886
> 
611a1887
> 
611a1888
> 
611a1889
> 
611a1890
> 
611a1891
> 
611a1892
> 
611a1893
> 
611a1894
> 
611a1895
> 
611a1896
> 
611a1897
> 
611a1898
> 
611a1899
> 
611a1900
> 
611a1901
> 
611a1902
> 
611a1903
> 
611a1904
> 
611a1905
> 
611a1906
> 
611a1907
> 
611a1908
> 
611a1909
> 
611a1910
> 
611a1911
> 
611a1912
> 
611a1913
> 
611a1914
> 
611a1915
> 
611a1916
> 
611a1917
> 
611a1918
> 
611a1919
> 
611a1920
>    rule49 = \ ((_prodsIcons) :: [ConstructorIdent]) nt_ ->(nt_,_prodsIcons)]
611a1921
> 
611a1922
> 
611a1923
> 
611a1924
> 
611a1925
> 
611a1926
> 
611a1927
> 
611a1928
> 
611a1929
> 
611a1930
> 
611a1931
> 
611a1932
> 
611a1933
> 
611a1934
> 
611a1935
> 
611a1936
> 
611a1937
> 
611a1938
> 
611a1939
> 
611a1940
> 
611a1941
> 
611a1942
> 
611a1943
> 
611a1944
> 
611a1945
> 
611a1946
> 
611a1947
> 
611a1948
> 
611a1949
> 
611a1950
> 
611a1951
> 
611a1952
> 
611a1953
> 
611a1954
> 
611a1955
> 
611a1956
> 
611a1957
> 
611a1958
> 
611a1959
> 
611a1960
> 
611a1961
> 
611a1962
> 
611a1963
> 
611a1964
> 
611a1965
> 
611a1966
> 
611a1967
> 
611a1968
>    rule50 = \ nt_ ->           nt_
611a1969
> 
611a1970
> 
611a1971
>    rule51 = \ inh_ ->          inh_
611a1972
>    rule52 = \ syn_ ->          syn_
611a1973
> 
611a1974
> 
611a1975
> 
611a1976
> 
611a1977
> 
611a1978
> 
611a1979
> 
611a1980
> 
611a1981
> 
611a1982
> 
611a1983
> 
611a1984
>    rule53 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) nt_ -> Map.empty nt_ _lhsImergeMap
611a1985
> 
611a1986
> 
611a1987
> 
611a1988
> 
611a1989
> 
611a1990
> 
611a1991
> 
611a1992
> 
611a1993
> 
611a1994
> 
611a1995
> 
611a1996
> 
611a1997
> 
611a1998
> 
611a1999
> 
611a2000
> 
611a2001
> 
611a2002
> 
611a2003
> 
611a2004
> 
611a2005
> 
611a2006
> 
611a2007
> 
611a2008
> 
611a2009
> 
611a2010
> 
611a2011
> 
611a2012
> 
611a2013
> 
611a2014
> 
611a2015
> 
611a2016
> 
611a2017
> 
611a2018
> 
611a2019
> 
611a2020
> 
611a2021
> 
611a2022
> 
611a2023
> 
611a2024
> 
611a2025
> 
611a2026
> 
611a2027
> 
611a2028
> 
611a2029
> 
611a2030
> 
611a2031
> 
611a2032
> 
611a2033
> 
611a2034
> 
611a2035
> 
611a2036
> 
611a2037
> 
611a2038
> 
611a2039
> 
611a2040
> 
611a2041
> 
611a2042
> 
611a2043
> 
611a2044
> 
611a2045
> 
611a2046
> 
611a2047
> 
611a2048
> 
611a2049
> 
611a2050
> 
611a2051
> 
611a2052
> 
611a2053
> 
611a2054
> 
611a2055
> 
611a2056
> 
611a2057
> 
611a2058
> 
611a2059
> 
611a2060
> 
611a2061
> 
611a2062
> 
611a2063
> 
611a2064
> 
611a2065
> 
611a2066
> 
611a2067
> 
611a2068
> 
611a2069
> 
611a2070
> 
611a2071
> 
611a2072
> 
611a2073
> 
611a2074
> 
611a2075
> 
611a2076
> 
611a2077
> 
611a2078
> 
611a2079
> 
611a2080
> 
611a2081
> 
611a2082
> 
611a2083
> 
611a2084
> 
611a2085
> 
611a2086
> 
611a2087
> 
611a2088
> 
611a2089
> 
611a2090
> 
611a2091
> 
611a2092
> 
611a2093
> 
611a2094
> 
611a2095
> 
611a2096
> 
611a2097
> 
611a2098
> 
611a2099
> 
611a2100
> 
611a2101
> 
611a2102
> 
611a2103
> 
611a2104
> 
611a2105
> 
611a2106
> 
611a2107
> 
611a2108
> 
611a2109
> 
611a2110
> 
611a2111
> 
611a2112
> 
611a2113
> 
611a2114
> 
611a2115
> 
611a2116
> 
611a2117
> 
611a2118
> 
611a2119
> 
611a2120
> 
611a2121
> 
611a2122
> 
611a2123
> 
611a2124
> 
611a2125
> 
611a2126
> 
611a2127
> 
611a2128
> 
611a2129
> 
611a2130
> 
611a2131
> 
611a2132
> 
611a2133
> 
611a2134
> 
611a2135
> 
611a2136
> 
611a2137
> 
611a2138
> 
611a2139
> 
611a2140
> 
611a2141
> 
611a2142
> 
611a2143
> 
611a2144
> 
611a2145
> 
611a2146
> 
611a2147
> 
611a2148
> 
611a2149
> 
611a2150
> 
611a2151
> 
611a2152
> 
611a2153
> 
611a2154
> 
611a2155
> 
611a2156
> 
611a2157
> 
611a2158
> 
611a2159
> 
611a2160
> 
611a2161
> 
611a2162
> 
611a2163
> 
611a2164
> 
611a2165
> 
611a2166
> 
611a2167
> 
611a2168
> 
611a2169
> 
611a2170
> 
611a2171
> 
611a2172
> 
611a2173
> 
611a2174
> 
611a2175
> 
611a2176
> 
611a2177
> 
611a2178
> 
611a2179
> 
611a2180
> 
611a2181
> 
611a2182
> 
611a2183
> 
611a2184
> 
611a2185
> 
611a2186
> 
611a2187
> 
611a2188
> 
611a2189
> 
611a2190
> 
611a2191
> 
611a2192
> 
611a2193
> 
611a2194
> 
611a2195
> 
611a2196
> 
611a2197
> 
611a2198
> 
611a2199
> 
611a2200
> 
611a2201
> 
611a2202
> 
611a2203
> 
611a2204
> 
611a2205
> 
611a2206
> 
611a2207
> 
611a2208
> 
611a2209
> 
611a2210
> 
611a2211
> 
611a2212
> 
611a2213
> 
611a2214
> 
611a2215
> 
611a2216
> 
611a2217
> 
611a2218
> 
611a2219
> 
611a2220
> 
611a2221
> 
611a2222
> 
611a2223
> 
611a2224
> 
611a2225
> 
611a2226
> 
611a2227
> 
611a2228
> 
611a2229
> 
611a2230
> 
611a2231
> 
611a2232
> 
611a2233
> 
611a2234
> 
611a2235
> 
611a2236
> 
611a2237
> 
611a2238
> 
611a2239
> 
611a2240
> 
611a2241
> 
611a2242
> 
611a2243
> 
611a2244
> 
611a2245
> 
611a2246
> 
611a2247
> 
611a2248
> 
611a2249
> 
611a2250
> 
611a2251
> 
611a2252
> 
611a2253
> 
611a2254
> 
611a2255
> 
611a2256
> 
611a2257
> 
611a2258
> 
611a2259
> 
611a2260
> 
611a2261
> 
611a2262
> 
611a2263
> 
611a2264
> 
611a2265
> 
611a2266
> 
611a2267
> 
611a2268
> 
611a2269
> 
611a2270
> 
611a2271
> 
611a2272
> 
611a2273
> 
611a2274
> 
611a2275
> 
611a2276
> 
611a2277
> 
611a2278
> 
611a2279
> 
611a2280
> 
611a2281
> 
611a2282
> 
611a2283
> 
611a2284
> 
611a2285
> 
611a2286
> 
611a2287
> 
611a2288
> 
611a2289
> 
611a2290
> 
611a2291
> 
611a2292
> 
611a2293
> 
611a2294
> 
611a2295
> 
611a2296
> 
611a2297
> 
611a2298
> 
611a2299
> 
611a2300
> 
611a2301
> 
611a2302
> 
611a2303
> 
611a2304
> 
611a2305
> 
611a2306
> 
611a2307
> 
611a2308
> 
611a2309
> 
611a2310
> 
611a2311
> 
611a2312
> 
611a2313
> 
611a2314
> 
611a2315
> 
611a2316
> 
611a2317
> 
611a2318
> 
611a2319
> 
611a2320
> 
611a2321
> 
611a2322
> 
611a2323
> 
611a2324
> 
611a2325
> 
611a2326
> 
611a2327
> 
611a2328
> 
611a2329
> 
611a2330
> 
611a2331
> 
611a2332
> 
611a2333
> 
611a2334
> 
611a2335
> 
611a2336
> 
611a2337
> 
611a2338
> 
611a2339
> 
611a2340
> 
611a2341
> 
611a2342
> 
611a2343
> 
611a2344
> 
611a2345
> 
611a2346
> 
611a2347
> 
611a2348
> 
611a2349
> 
611a2350
> 
611a2351
> 
611a2352
> 
611a2353
> 
611a2354
> 
611a2355
> 
611a2356
> 
611a2357
> 
611a2358
> 
611a2359
> 
611a2360
> 
611a2361
> 
611a2362
> 
611a2363
> 
611a2364
> 
611a2365
> 
611a2366
> 
611a2367
> 
611a2368
> 
611a2369
> 
611a2370
> 
611a2371
> 
611a2372
> 
611a2373
> 
611a2374
> 
611a2375
> 
611a2376
> 
611a2377
> 
611a2378
> 
611a2379
> 
611a2380
> 
611a2381
> 
611a2382
> 
611a2383
> 
611a2384
> 
611a2385
> 
611a2386
> 
611a2387
> 
611a2388
> 
611a2389
> 
611a2390
> 
611a2391
> 
611a2392
> 
611a2393
> 
611a2394
> 
611a2395
> 
611a2396
> 
611a2397
> 
611a2398
> 
611a2399
> 
611a2400
> 
611a2401
> 
611a2402
> 
611a2403
> 
611a2404
> 
611a2405
> 
611a2406
> 
611a2407
> 
611a2408
> 
611a2409
> 
611a2410
> 
611a2411
> 
611a2412
> 
611a2413
> 
611a2414
> 
611a2415
> 
611a2416
> 
611a2417
> 
611a2418
> 
611a2419
> 
611a2420
> 
611a2421
> 
611a2422
> 
611a2423
> 
611a2424
> 
611a2425
> 
611a2426
> 
611a2427
> 
611a2428
> 
611a2429
> 
611a2430
> 
611a2431
> 
611a2432
> 
611a2433
> 
611a2434
> 
611a2435
> 
611a2436
> 
611a2437
> 
611a2438
> 
611a2439
> 
611a2440
> 
611a2441
> 
611a2442
> 
611a2443
> 
611a2444
> 
611a2445
> 
611a2446
> 
611a2447
> 
611a2448
> 
611a2449
> 
611a2450
> 
611a2451
> 
611a2452
> 
611a2453
> 
611a2454
> 
611a2455
> 
611a2456
> 
611a2457
> 
611a2458
> 
611a2459
> 
611a2460
> 
611a2461
> 
611a2462
> 
611a2463
> 
611a2464
> 
611a2465
> 
611a2466
> 
611a2467
> 
611a2468
> 
950d2806
<    {-# LINE 95 "src-ag/ResolveLocals.ag" #-}
951d2806
<    rule106 = \ attr_ field_ ->
952d2806
<                                {-# LINE 95 "src-ag/ResolveLocals.ag" #-}
953d2806
<                                if field_ == _LOC
954d2806
<                                   then [attr_]
955d2806
<                                   else []
956c2807
<                                {-# LINE 957 "dist/build/ResolveLocals.hs"#-}
---
> 
956a2808
> 
956a2809
> 
956a2810
> 
956a2811
> 
956a2812
> 
956a2813
> 
958d2814
<    {-# LINE 98 "src-ag/ResolveLocals.ag" #-}
959d2814
<    rule107 = \ attr_ field_ ->
960d2814
<                                {-# LINE 98 "src-ag/ResolveLocals.ag" #-}
961d2814
<                                if field_ == _INST
962d2814
<                                   then [attr_]
963d2814
<                                   else []
964c2815
<                                {-# LINE 965 "dist/build/ResolveLocals.hs"#-}
---
> 
964a2816
> 
964a2817
> 
964a2818
> 
964a2819
> 
964a2820
> 
964a2821
> 
991c2848
<      _lhsIsyn
---
>      _lhsIsyn = \ attr_ field_ -> if field_ == _LOC
991a2849
>                                      then [attr_]
991a2850
>                                      else []
991a2851
>    rule107 = \ attr_ field_ -> if field_ == _INST
991a2852
>                                   then [attr_]
991a2853
>                                   else []
991a2854
> 
991a2855
> 
991a2856
> 
991a2857
> 
991a2858
> 
991a2859
> 
991a2860
> 
991a2861
> 
991a2862
> 
991a2863
> 
991a2864
> 
991a2865
> 
991a2866
> 
991a2867
> 
991a2868
> 
991a2869
> 
991a2870
> 
991a2871
> 
991a2872
> 
991a2873
> 
991a2874
> 
991a2875
> 
991a2876
> 
991a2877
> 
991a2878
> 
991a2879
> 
991a2880
> 
991a2881
> 
991a2882
> 
991a2883
> 
991a2884
> 
991a2885
> 
991a2886
> 
991a2887
> 
991a2888
> 
991a2889
> 
991a2890
> 
991a2891
> 
991a2892
> 
991a2893
> 
991a2894
> 
991a2895
> 
991a2896
> 
991a2897
> 
991a2898
> 
991a2899
> 
991a2900
> 
991a2901
> 
991a2902
> 
991a2903
> 
991a2904
> 
991a2905
> 
991a2906
> 
991a2907
> 
991a2908
> 
991a2909
> 
991a2910
> 
991a2911
> 
991a2912
> 
991a2913
> 
991a2914
> 
991a2915
> 
991a2916
> 
991a2917
> 
991a2918
> 
991a2919
> 
991a2920
> 
991a2921
> 
991a2922
> 
991a2923
> 
991a2924
> 
991a2925
> 
991a2926
> 
991a2927
> 
991a2928
> 
991a2929
> 
991a2930
> 
991a2931
> 
991a2932
> 
991a2933
> 
991a2934
> 
991a2935
> 
991a2936
> 
991a2937
> 
991a2938
> 
991a2939
> 
991a2940
> 
991a2941
> 
991a2942
> 
991a2943
> 
991a2944
> 
991a2945
> 
991a2946
> 
991a2947
> 
991a2948
> 
991a2949
> 
991a2950
> 
991a2951
> 
991a2952
> 
991a2953
> 
991a2954
> 
991a2955
> 
991a2956
> 
991a2957
> 
991a2958
> 
991a2959
> 
991a2960
> 
991a2961
> 
991a2962
> 
991a2963
> 
991a2964
> 
991a2965
> 
991a2966
> 
991a2967
> 
991a2968
> 
991a2969
> 
991a2970
> 
991a2971
> 
991a2972
> 
991a2973
> 
991a2974
> 
991a2975
> 
991a2976
> 
991a2977
> 
991a2978
> 
991a2979
> 
991a2980
> 
991a2981
> 
991a2982
> 
991a2983
> 
991a2984
> 
991a2985
> 
991a2986
> 
991a2987
> 
991a2988
> 
991a2989
> 
991a2990
> 
991a2991
> 
991a2992
> 
991a2993
> 
991a2994
> 
991a2995
> 
991a2996
> 
991a2997
> 
991a2998
> 
991a2999
> 
991a3000
> 
991a3001
> 
991a3002
> 
991a3003
> 
991a3004
> 
991a3005
> 
991a3006
> 
991a3007
> 
991a3008
> 
991a3009
> 
991a3010
> 
991a3011
> 
991a3012
> 
991a3013
> 
991a3014
> 
991a3015
> 
991a3016
> 
991a3017
> 
991a3018
> 
991a3019
> 
991a3020
> 
991a3021
> 
991a3022
> 
991a3023
> 
991a3024
> 
991a3025
> 
991a3026
> 
991a3027
> 
991a3028
> 
991a3029
> 
991a3030
> 
991a3031
> 
991a3032
> 
991a3033
> 
991a3034
> 
991a3035
> 
991a3036
> 
991a3037
> 
991a3038
> 
991a3039
> 
991a3040
> 
991a3041
> 
991a3042
> 
991a3043
> 
991a3044
> 
991a3045
> 
991a3046
> 
991a3047
> 
991a3048
> 
991a3049
> 
991a3050
> 
991a3051
> 
991a3052
> 
991a3053
> 
991a3054
> 
991a3055
> 
991a3056
> 
991a3057
> 
991a3058
> 
991a3059
> 
991a3060
> 
991a3061
> 
991a3062
> 
991a3063
> 
991a3064
> 
991a3065
> 
991a3066
> 
991a3067
> 
991a3068
> 
991a3069
> 
991a3070
> 
991a3071
> 
991a3072
> 
991a3073
> 
991a3074
> 
991a3075
> 
991a3076
> 
991a3077
> 
991a3078
> 
991a3079
> 
991a3080
> 
991a3081
> 
991a3082
> 
991a3083
> 
991a3084
> 
991a3085
> 
991a3086
> 
991a3087
> 
991a3088
> 
991a3089
> 
991a3090
> 
991a3091
> 
991a3092
> 
991a3093
> 
991a3094
> 
991a3095
> 
991a3096
> 
991a3097
> 
991a3098
> 
991a3099
> 
991a3100
> 
991a3101
> 
991a3102
> 
991a3103
> 
991a3104
> 
991a3105
> 
991a3106
> 
991a3107
> 
991a3108
> 
991a3109
> 
991a3110
> 
991a3111
> 
991a3112
> 
991a3113
> 
991a3114
> 
991a3115
> 
991a3116
> 
991a3117
> 
991a3118
> 
991a3119
> 
991a3120
> 
991a3121
> 
991a3122
> 
991a3123
> 
991a3124
> 
991a3125
> 
991a3126
> 
991a3127
> 
991a3128
> 
991a3129
> 
991a3130
> 
991a3131
> 
991a3132
> 
991a3133
> 
991a3134
> 
991a3135
> 
991a3136
> 
991a3137
> 
991a3138
> 
991a3139
> 
991a3140
> 
991a3141
> 
991a3142
> 
991a3143
> 
991a3144
> 
991a3145
> 
991a3146
> 
991a3147
> 
991a3148
> 
991a3149
> 
991a3150
> 
991a3151
> 
991a3152
> 
991a3153
> 
991a3154
> 
991a3155
> 
991a3156
> 
991a3157
> 
991a3158
> 
991a3159
> 
991a3160
> 
991a3161
> 
991a3162
> 
991a3163
> 
991a3164
> 
991a3165
> 
991a3166
> 
991a3167
> 
991a3168
> 
991a3169
> 
991a3170
> 
991a3171
> 
991a3172
> 
991a3173
> 
991a3174
> 
991a3175
> 
991a3176
> 
991a3177
> 
991a3178
> 
991a3179
> 
991a3180
> 
991a3181
> 
991a3182
> 
991a3183
> 
991a3184
> 
991a3185
> 
991a3186
> 
991a3187
> 
991a3188
> 
991a3189
> 
991a3190
> 
991a3191
> 
991a3192
> 
991a3193
> 
991a3194
> 
991a3195
> 
991a3196
> 
991a3197
> 
991a3198
> 
991a3199
> 
991a3200
> 
991a3201
> 
991a3202
> 
991a3203
> 
991a3204
> 
991a3205
> 
991a3206
> 
991a3207
> 
991a3208
> 
991a3209
> 
991a3210
> 
991a3211
> 
991a3212
> 
991a3213
> 
991a3214
> 
991a3215
> 
991a3216
> 
991a3217
> 
991a3218
> 
991a3219
> 
991a3220
> 
991a3221
> 
991a3222
> 
991a3223
> 
991a3224
> 
991a3225
> 
991a3226
> 
991a3227
> 
991a3228
> 
991a3229
> 
991a3230
> 
991a3231
> 
991a3232
> 
991a3233
> 
991a3234
> 
991a3235
> 
991a3236
> 
991a3237
> 
991a3238
> 
991a3239
> 
991a3240
> 
991a3241
> 
991a3242
> 
991a3243
> 
991a3244
> 
991a3245
> 
991a3246
> 
991a3247
> 
991a3248
> 
991a3249
> 
991a3250
> 
991a3251
> 
991a3252
> 
991a3253
> 
991a3254
> 
991a3255
> 
991a3256
> 
991a3257
> 
991a3258
> 
991a3259
> 
991a3260
> 
991a3261
> 
991a3262
> 
991a3263
> 
991a3264
> 
991a3265
> 
991a3266
> 
991a3267
> 
991a3268
> 
991a3269
> 
991a3270
> 
991a3271
> 
991a3272
> 
991a3273
> 
991a3274
> 
991a3275
> 
991a3276
> 
991a3277
> 
991a3278
> 
991a3279
> 
991a3280
> 
991a3281
> 
991a3282
> 
991a3283
> 
991a3284
> 
991a3285
> 
991a3286
> 
991a3287
> 
991a3288
> 
991a3289
> 
991a3290
> 
991a3291
> 
991a3292
> 
991a3293
> 
991a3294
> 
991a3295
> 
991a3296
> 
991a3297
> 
991a3298
> 
991a3299
> 
991a3300
> 
991a3301
> 
991a3302
> 
991a3303
> 
991a3304
> 
991a3305
> 
991a3306
> 
991a3307
> 
991a3308
> 
991a3309
> 
991a3310
> 
991a3311
> 
991a3312
> 
991a3313
> 
991a3314
> 
991a3315
> 
991a3316
> 
991a3317
> 
991a3318
> 
991a3319
> 
991a3320
> 
991a3321
> 
991a3322
> 
991a3323
> 
991a3324
> 
991a3325
> 
991a3326
> 
991a3327
> 
991a3328
> 
991a3329
> 
991a3330
> 
991a3331
> 
991a3332
> 
991a3333
> 
991a3334
> 
991a3335
> 
991a3336
> 
991a3337
> 
991a3338
> 
991a3339
> 
991a3340
> 
991a3341
> 
991a3342
> 
991a3343
> 
991a3344
> 
991a3345
> 
991a3346
> 
991a3347
> 
991a3348
> 
991a3349
> 
991a3350
> 
991a3351
> 
991a3352
> 
991a3353
> 
991a3354
> 
991a3355
> 
991a3356
> 
991a3357
> 
991a3358
> 
991a3359
> 
991a3360
> 
991a3361
> 
991a3362
> 
991a3363
> 
991a3364
> 
991a3365
> 
991a3366
> 
991a3367
> 
991a3368
> 
991a3369
> 
991a3370
> 
991a3371
> 
991a3372
> 
991a3373
> 
991a3374
> 
991a3375
> 
991a3376
> 
991a3377
> 
991a3378
> 
991a3379
> 
991a3380
> 
991a3381
> 
991a3382
> 
991a3383
> 
991a3384
> 
991a3385
> 
991a3386
> 
991a3387
> 
991a3388
> 
991a3389
> 
991a3390
> 
991a3391
> 
991a3392
> 
991a3393
> 
991a3394
> 
991a3395
> 
991a3396
> 
991a3397
> 
991a3398
> 
991a3399
> 
991a3400
> 
991a3401
> 
991a3402
> 
991a3403
> 
991a3404
> 
991a3405
> 
991a3406
> 
991a3407
> 
991a3408
> 
991a3409
> 
991a3410
> 
991a3411
> 
991a3412
> 
991a3413
> 
991a3414
> 
991a3415
> 
991a3416
> 
991a3417
> 
991a3418
> 
991a3419
> 
991a3420
> 
991a3421
> 
991a3422
> 
991a3423
> 
991a3424
> 
991a3425
> 
991a3426
> 
991a3427
> 
991a3428
> 
991a3429
> 
991a3430
> 
991a3431
> 
991a3432
> 
991a3433
> 
991a3434
> 
991a3435
> 
991a3436
> 
991a3437
> 
991a3438
> 
991a3439
> 
991a3440
> 
991a3441
> 
991a3442
> 
991a3443
> 
991a3444
> 
991a3445
> 
991a3446
> 
991a3447
> 
991a3448
> 
991a3449
> 
991a3450
> 
991a3451
> 
991a3452
> 
991a3453
> 
991a3454
> 
991a3455
> 
991a3456
> 
991a3457
> 
991a3458
> 
991a3459
> 
991a3460
> 
991a3461
> 
991a3462
> 
991a3463
> 
991a3464
> 
991a3465
> 
991a3466
> 
991a3467
> 
991a3468
> 
991a3469
> 
991a3470
> 
991a3471
> 
991a3472
> 
991a3473
> 
991a3474
> 
991a3475
> 
991a3476
> 
991a3477
> 
991a3478
> 
991a3479
> 
991a3480
> 
991a3481
> 
991a3482
> 
991a3483
> 
991a3484
> 
991a3485
> 
991a3486
> 
991a3487
> 
991a3488
> 
991a3489
> 
991a3490
> 
991a3491
> 
991a3492
> 
991a3493
> 
991a3494
> 
991a3495
> 
991a3496
> 
991a3497
> 
991a3498
> 
991a3499
> 
991a3500
> 
991a3501
> 
991a3502
> 
991a3503
> 
991a3504
> 
991a3505
> 
991a3506
> 
991a3507
> 
991a3508
> 
991a3509
> 
991a3510
> 
991a3511
> 
991a3512
> 
991a3513
> 
991a3514
> 
991a3515
> 
991a3516
> 
991a3517
> 
991a3518
> 
991a3519
> 
991a3520
> 
991a3521
> 
991a3522
> 
991a3523
> 
991a3524
> 
991a3525
> 
991a3526
> 
991a3527
> 
991a3528
> 
991a3529
> 
991a3530
> 
991a3531
> 
991a3532
> 
991a3533
> 
991a3534
> 
991a3535
> 
991a3536
> 
991a3537
> 
991a3538
> 
991a3539
> 
991a3540
> 
991a3541
> 
991a3542
> 
991a3543
> 
991a3544
> 
991a3545
> 
991a3546
> 
991a3547
> 
991a3548
> 
991a3549
> 
991a3550
> 
991a3551
> 
991a3552
> 
991a3553
> 
991a3554
> 
991a3555
> 
991a3556
> 
991a3557
> 
991a3558
> 
991a3559
> 
991a3560
> 
991a3561
> 
991a3562
> 
991a3563
> 
991a3564
> 
991a3565
> 
991a3566
> 
991a3567
> 
991a3568
> 
991a3569
> 
991a3570
> 
991a3571
> 
991a3572
> 
991a3573
> 
991a3574
> 
991a3575
> 
991a3576
> 
991a3577
> 
991a3578
> 
991a3579
> 
991a3580
> 
991a3581
> 
991a3582
> 
991a3583
> 
991a3584
> 
991a3585
> 
991a3586
> 
991a3587
> 
991a3588
> 
991a3589
> 
991a3590
> 
991a3591
> 
991a3592
> 
991a3593
> 
991a3594
> 
991a3595
> 
991a3596
> 
991a3597
> 
991a3598
> 
991a3599
> 
991a3600
> 
991a3601
> 
991a3602
> 
991a3603
> 
991a3604
> 
991a3605
> 
991a3606
> 
991a3607
> 
991a3608
> 
991a3609
> 
991a3610
> 
991a3611
> 
991a3612
> 
991a3613
> 
991a3614
> 
991a3615
> 
991a3616
> 
991a3617
> 
991a3618
> 
991a3619
> 
991a3620
> 
991a3621
> 
991a3622
> 
991a3623
> 
991a3624
> 
991a3625
> 
991a3626
> 
991a3627
> 
991a3628
> 
991a3629
> 
991a3630
> 
991a3631
> 
991a3632
> 
991a3633
> 
991a3634
> 
991a3635
> 
991a3636
> 
991a3637
> 
991a3638
> 
991a3639
> 
991a3640
> 
991a3641
> 
991a3642
> 
991a3643
> 
991a3644
> 
991a3645
> 
991a3646
> 
991a3647
> 
991a3648
> 
991a3649
> 
991a3650
> 
991a3651
> 
991a3652
> 
991a3653
> 
991a3654
> 
991a3655
> 
991a3656
> 
991a3657
> 
991a3658
> 
991a3659
> 
991a3660
> 
991a3661
> 
991a3662
> 
991a3663
> 
991a3664
> 
991a3665
> 
991a3666
> 
991a3667
> 
991a3668
> 
991a3669
> 
991a3670
> 
991a3671
> 
991a3672
> 
991a3673
> 
991a3674
> 
991a3675
> 
991a3676
> 
991a3677
> 
991a3678
> 
991a3679
> 
991a3680
> 
991a3681
> 
991a3682
> 
991a3683
> 
991a3684
> 
991a3685
> 
991a3686
> 
991a3687
> 
991a3688
> 
991a3689
> 
991a3690
> 
991a3691
> 
991a3692
> 
991a3693
> 
991a3694
> 
991a3695
> 
991a3696
> 
991a3697
> 
991a3698
> 
991a3699
> 
991a3700
> 
991a3701
> 
991a3702
> 
991a3703
> 
991a3704
> 
991a3705
> 
991a3706
> 
991a3707
> 
991a3708
> 
991a3709
> 
991a3710
> 
991a3711
> 
991a3712
> 
991a3713
> 
991a3714
> 
991a3715
> 
991a3716
> 
991a3717
> 
991a3718
> 
991a3719
> 
991a3720
> 
991a3721
> 
991a3722
> 
991a3723
> 
991a3724
> 
991a3725
> 
991a3726
> 
991a3727
> 
991a3728
> 
991a3729
> 
991a3730
> 
991a3731
> 
991a3732
> 
991a3733
> 
991a3734
> 
991a3735
> 
991a3736
> 
991a3737
> 
991a3738
> 
991a3739
> 
991a3740
> 
991a3741
> 
991a3742
> 
991a3743
> 
991a3744
> 
1328d4080
<    {-# LINE 66 "src-ag/ResolveLocals.ag" #-}
1329d4080
<    rule157 = \ con_ ->
1330d4080
<                               {-# LINE 66 "src-ag/ResolveLocals.ag" #-}
1331d4080
<                               [con_]
1332c4081
<                               {-# LINE 1333 "dist/build/ResolveLocals.hs"#-}
---
> 
1332a4082
> 
1332a4083
> 
1332a4084
> 
1332a4085
> 
1334d4086
<    {-# LINE 73 "src-ag/ResolveLocals.ag" #-}
1335d4086
<    rule158 = \ ((_childrenIfields) :: [(Identifier,Type,ChildKind)]) ->
1336d4086
<                                   {-# LINE 73 "src-ag/ResolveLocals.ag" #-}
1337d4086
<                                   _childrenIfields
1338c4087
<                                   {-# LINE 1339 "dist/build/ResolveLocals.hs"#-}
---
> 
1338a4088
> 
1338a4089
> 
1338a4090
> 
1338a4091
> 
1340d4092
<    {-# LINE 74 "src-ag/ResolveLocals.ag" #-}
1341d4092
<    rule159 = \ ((_childrenIattributes) :: [(Identifier,Attributes,Attributes)]) _inhnames ((_rulesIinstVars) :: [Identifier]) ((_rulesIlocVars) :: [Identifier]) ->
1342d4092
<                                    {-# LINE 74 "src-ag/ResolveLocals.ag" #-}
1343d4092
<                                    map ((,) _LOC)  _rulesIlocVars ++
1344d4092
<                                    map ((,) _INST) _rulesIinstVars ++
1345d4092
<                                    map ((,) _LHS)  _inhnames ++
1346d4092
<                                    concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- _childrenIattributes]
1347c4093
<                                    {-# LINE 1348 "dist/build/ResolveLocals.hs"#-}
---
> 
1347a4094
> 
1347a4095
> 
1347a4096
> 
1347a4097
> 
1347a4098
> 
1347a4099
> 
1347a4100
> 
1349d4101
<    {-# LINE 78 "src-ag/ResolveLocals.ag" #-}
1350d4101
<    rule160 = \ ((_lhsIinh) :: Attributes) ->
1351d4101
<                                    {-# LINE 78 "src-ag/ResolveLocals.ag" #-}
1352d4101
<                                    Map.keys _lhsIinh
1353c4102
<                                    {-# LINE 1354 "dist/build/ResolveLocals.hs"#-}
---
> 
1353a4103
> 
1353a4104
> 
1353a4105
> 
1353a4106
> 
1355d4107
<    {-# LINE 79 "src-ag/ResolveLocals.ag" #-}
1356d4107
<    rule161 = \ ((_lhsIsyn) :: Attributes) ->
1357d4107
<                                    {-# LINE 79 "src-ag/ResolveLocals.ag" #-}
1358d4107
<                                    Map.keys _lhsIsyn
1359c4108
<                                    {-# LINE 1360 "dist/build/ResolveLocals.hs"#-}
---
> 
1359a4109
> 
1359a4110
> 
1359a4111
> 
1359a4112
> 
1361d4113
<    {-# LINE 107 "src-ag/ResolveLocals.ag" #-}
1362d4113
<    rule162 = \ con_ ->
1363d4113
<                                   {-# LINE 107 "src-ag/ResolveLocals.ag" #-}
1364d4113
<                                   con_
1365c4114
<                                   {-# LINE 1366 "dist/build/ResolveLocals.hs"#-}
---
> 
1365a4115
> 
1365a4116
> 
1365a4117
> 
1365a4118
> 
1367d4119
<    {-# LINE 109 "src-ag/ResolveLocals.ag" #-}
1368d4119
<    rule163 = \ con_ ->
1369d4119
<                                {-# LINE 109 "src-ag/ResolveLocals.ag" #-}
1370d4119
<                                con_
1371c4120
<                                {-# LINE 1372 "dist/build/ResolveLocals.hs"#-}
---
> 
1371a4121
> 
1371a4122
> 
1371a4123
> 
1371a4124
> 
1373d4125
<    {-# LINE 128 "src-ag/ResolveLocals.ag" #-}
1374d4125
<    rule164 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) con_ ->
1375d4125
<                                                 {-# LINE 128 "src-ag/ResolveLocals.ag" #-}
1376d4125
<                                                 Map.findWithDefault Map.empty con_ _lhsImergeMap
1377c4126
<                                                 {-# LINE 1378 "dist/build/ResolveLocals.hs"#-}
---
> 
1377a4127
> 
1377a4128
> 
1377a4129
> 
1377a4130
> 
1437c4190
<      _lhsIsyn
---
>      _lhsIsyn = \ con_ ->        [con_]
1438a4192
> 
1438a4193
> 
1438a4194
> 
1438a4195
> 
1438a4196
> 
1438a4197
>    rule158 = \ ((_childrenIfields) :: [(Identifier,Type,ChildKind)]) ->
1438a4198
>    rule159 = \ ((_childrenIattributes) :: [(Identifier,Attributes,Attributes)]) _inhnames ((_rulesIinstVars) :: [Identifier]) ((_rulesIlocVars) :: [Identifier]) -> ((,) _LOC)  _rulesIlocVars ++
1438a4199
>                                    map ((,) _INST) _rulesIinstVars ++
1438a4200
>                                    map ((,) _LHS)  _inhnames ++
1438a4201
>                                    concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- _childrenIattributes]
1438a4202
>    rule160 = \ ((_lhsIinh) :: Attributes) -> _lhsIinh
1438a4203
>    rule161 = \ ((_lhsIsyn) :: Attributes) -> _lhsIsyn
1438a4204
> 
1438a4205
> 
1438a4206
> 
1438a4207
> 
1438a4208
> 
1438a4209
> 
1438a4210
> 
1438a4211
> 
1438a4212
> 
1438a4213
> 
1438a4214
> 
1438a4215
> 
1438a4216
> 
1438a4217
> 
1438a4218
> 
1438a4219
> 
1438a4220
> 
1438a4221
> 
1438a4222
> 
1438a4223
> 
1438a4224
> 
1438a4225
> 
1438a4226
> 
1438a4227
> 
1438a4228
> 
1438a4229
> 
1438a4230
> 
1438a4231
>    rule162 = \ con_ ->            con_
1438a4232
> 
1438a4233
>    rule163 = \ con_ ->         con_
1438a4234
> 
1438a4235
> 
1438a4236
> 
1438a4237
> 
1438a4238
> 
1438a4239
> 
1438a4240
> 
1438a4241
> 
1438a4242
> 
1438a4243
> 
1438a4244
> 
1438a4245
> 
1438a4246
> 
1438a4247
> 
1438a4248
> 
1438a4249
> 
1438a4250
> 
1438a4251
> 
1438a4252
>    rule164 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) con_ -> Map.empty con_ _lhsImergeMap
1438a4253
> 
1438a4254
> 
1438a4255
> 
1438a4256
> 
1438a4257
> 
1438a4258
> 
1438a4259
> 
1438a4260
> 
1438a4261
> 
1438a4262
> 
1438a4263
> 
1438a4264
> 
1438a4265
> 
1438a4266
> 
1438a4267
> 
1438a4268
> 
1438a4269
> 
1438a4270
> 
1438a4271
> 
1438a4272
> 
1438a4273
> 
1438a4274
> 
1438a4275
> 
1438a4276
> 
1438a4277
> 
1438a4278
> 
1438a4279
> 
1438a4280
> 
1438a4281
> 
1438a4282
> 
1438a4283
> 
1438a4284
> 
1438a4285
> 
1438a4286
> 
1438a4287
> 
1438a4288
> 
1438a4289
> 
1438a4290
> 
1438a4291
> 
1438a4292
> 
1438a4293
> 
1438a4294
> 
1438a4295
> 
1438a4296
> 
1438a4297
> 
1438a4298
> 
1438a4299
> 
1438a4300
> 
1438a4301
> 
1438a4302
> 
1438a4303
> 
1438a4304
> 
1438a4305
> 
1438a4306
> 
1438a4307
> 
1438a4308
> 
1438a4309
> 
1438a4310
> 
1438a4311
> 
1438a4312
> 
1438a4313
> 
1438a4314
> 
1438a4315
> 
1438a4316
> 
1438a4317
> 
1438a4318
> 
1438a4319
> 
1438a4320
> 
1438a4321
> 
1438a4322
> 
1438a4323
> 
1438a4324
> 
1438a4325
> 
1438a4326
> 
1438a4327
> 
1438a4328
> 
1438a4329
> 
1438a4330
> 
1438a4331
> 
1438a4332
> 
1438a4333
> 
1438a4334
> 
1438a4335
> 
1438a4336
> 
1438a4337
> 
1438a4338
> 
1438a4339
> 
1438a4340
> 
1438a4341
> 
1438a4342
> 
1438a4343
> 
1438a4344
> 
1438a4345
> 
1438a4346
> 
1438a4347
> 
1438a4348
> 
1438a4349
> 
1438a4350
> 
1438a4351
> 
1438a4352
> 
1438a4353
> 
1438a4354
> 
1438a4355
> 
1438a4356
> 
1438a4357
> 
1438a4358
> 
1438a4359
> 
1438a4360
> 
1438a4361
> 
1438a4362
> 
1438a4363
> 
1438a4364
> 
1438a4365
> 
1438a4366
> 
1438a4367
> 
1438a4368
> 
1438a4369
> 
1438a4370
> 
1438a4371
> 
1438a4372
> 
1438a4373
> 
1438a4374
> 
1438a4375
> 
1438a4376
> 
1438a4377
> 
1438a4378
> 
1438a4379
> 
1438a4380
> 
1438a4381
> 
1438a4382
> 
1438a4383
> 
1438a4384
> 
1438a4385
> 
1438a4386
> 
1438a4387
> 
1438a4388
> 
1438a4389
> 
1438a4390
> 
1438a4391
> 
1438a4392
> 
1438a4393
> 
1438a4394
> 
1438a4395
> 
1438a4396
> 
1438a4397
> 
1438a4398
> 
1438a4399
> 
1438a4400
> 
1438a4401
> 
1438a4402
> 
1438a4403
> 
1438a4404
> 
1438a4405
> 
1438a4406
> 
1438a4407
> 
1438a4408
> 
1438a4409
> 
1438a4410
> 
1438a4411
> 
1438a4412
> 
1438a4413
> 
1438a4414
> 
1438a4415
> 
1438a4416
> 
1438a4417
> 
1438a4418
> 
1438a4419
> 
1438a4420
> 
1438a4421
> 
1438a4422
> 
1438a4423
> 
1438a4424
> 
1438a4425
> 
1438a4426
> 
1438a4427
> 
1438a4428
> 
1438a4429
> 
1438a4430
> 
1438a4431
> 
1438a4432
> 
1438a4433
> 
1438a4434
> 
1438a4435
> 
1438a4436
> 
1438a4437
> 
1438a4438
> 
1438a4439
> 
1438a4440
> 
1438a4441
> 
1438a4442
> 
1438a4443
> 
1438a4444
> 
1438a4445
> 
1438a4446
> 
1438a4447
> 
1438a4448
> 
1438a4449
> 
1438a4450
> 
1438a4451
> 
1438a4452
> 
1438a4453
> 
1438a4454
> 
1438a4455
> 
1438a4456
> 
1438a4457
> 
1438a4458
> 
1438a4459
> 
1438a4460
> 
1438a4461
> 
1438a4462
> 
1438a4463
> 
1438a4464
> 
1438a4465
> 
1438a4466
> 
1438a4467
> 
1438a4468
> 
1438a4469
> 
1438a4470
> 
1438a4471
> 
1438a4472
> 
1438a4473
> 
1438a4474
> 
1438a4475
> 
1438a4476
> 
1438a4477
> 
1438a4478
> 
1438a4479
> 
1438a4480
> 
1438a4481
> 
1438a4482
> 
1438a4483
> 
1438a4484
> 
1438a4485
> 
1438a4486
> 
1438a4487
> 
1438a4488
> 
1438a4489
> 
1438a4490
> 
1438a4491
> 
1438a4492
> 
1438a4493
> 
1438a4494
> 
1438a4495
> 
1438a4496
> 
1438a4497
> 
1438a4498
> 
1438a4499
> 
1438a4500
> 
1438a4501
> 
1438a4502
> 
1438a4503
> 
1438a4504
> 
1438a4505
> 
1438a4506
> 
1438a4507
> 
1438a4508
> 
1438a4509
> 
1438a4510
> 
1438a4511
> 
1438a4512
> 
1438a4513
> 
1438a4514
> 
1438a4515
> 
1438a4516
> 
1438a4517
> 
1438a4518
> 
1438a4519
> 
1438a4520
> 
1438a4521
> 
1438a4522
> 
1438a4523
> 
1438a4524
> 
1438a4525
> 
1438a4526
> 
1438a4527
> 
1438a4528
> 
1438a4529
> 
1438a4530
> 
1438a4531
> 
1438a4532
> 
1438a4533
> 
1438a4534
> 
1438a4535
> 
1438a4536
> 
1438a4537
> 
1438a4538
> 
1438a4539
> 
1438a4540
> 
1438a4541
> 
1438a4542
> 
1438a4543
> 
1438a4544
> 
1438a4545
> 
1438a4546
> 
1438a4547
> 
1438a4548
> 
1438a4549
> 
1438a4550
> 
1438a4551
> 
1438a4552
> 
1438a4553
> 
1438a4554
> 
1438a4555
> 
1438a4556
> 
1438a4557
> 
1438a4558
> 
1438a4559
> 
1438a4560
> 
1438a4561
> 
1438a4562
> 
1438a4563
> 
1438a4564
> 
1438a4565
> 
1438a4566
> 
1438a4567
> 
1438a4568
> 
1438a4569
> 
1438a4570
> 
1438a4571
> 
1438a4572
> 
1438a4573
> 
1438a4574
> 
1438a4575
> 
1438a4576
> 
1438a4577
> 
1438a4578
> 
1438a4579
> 
1438a4580
> 
1438a4581
> 
1438a4582
> 
1438a4583
> 
1438a4584
> 
1438a4585
> 
1438a4586
> 
1438a4587
> 
1438a4588
> 
1438a4589
> 
1438a4590
> 
1438a4591
> 
1438a4592
> 
1438a4593
> 
1438a4594
> 
1438a4595
> 
1438a4596
> 
1438a4597
> 
1438a4598
> 
1438a4599
> 
1438a4600
> 
1438a4601
> 
1438a4602
> 
1438a4603
> 
1438a4604
> 
1438a4605
> 
1438a4606
> 
1438a4607
> 
1438a4608
> 
1438a4609
> 
1438a4610
> 
1438a4611
> 
1438a4612
> 
1438a4613
> 
1438a4614
> 
1438a4615
> 
1438a4616
> 
1438a4617
> 
1438a4618
> 
1438a4619
> 
1438a4620
> 
1438a4621
> 
1438a4622
> 
1438a4623
> 
1438a4624
> 
1438a4625
> 
1438a4626
> 
1438a4627
> 
1438a4628
> 
1438a4629
> 
1438a4630
> 
1438a4631
> 
1438a4632
> 
1438a4633
> 
1438a4634
> 
1438a4635
> 
1438a4636
> 
1438a4637
> 
1438a4638
> 
1438a4639
> 
1438a4640
> 
1438a4641
> 
1438a4642
> 
1438a4643
> 
1438a4644
> 
1438a4645
> 
1438a4646
> 
1438a4647
> 
1438a4648
> 
1438a4649
> 
1438a4650
> 
1438a4651
> 
1438a4652
> 
1438a4653
> 
1438a4654
> 
1438a4655
> 
1438a4656
> 
1438a4657
> 
1438a4658
> 
1438a4659
> 
1438a4660
> 
1438a4661
> 
1438a4662
> 
1438a4663
> 
1438a4664
> 
1438a4665
> 
1438a4666
> 
1438a4667
> 
1438a4668
> 
1438a4669
> 
1438a4670
> 
1438a4671
> 
1438a4672
> 
1438a4673
> 
1438a4674
> 
1438a4675
> 
1438a4676
> 
1438a4677
> 
1438a4678
> 
1438a4679
> 
1438a4680
> 
1438a4681
> 
1438a4682
> 
1438a4683
> 
1438a4684
> 
1438a4685
> 
1438a4686
> 
1438a4687
> 
1438a4688
> 
1438a4689
> 
1438a4690
> 
1438a4691
> 
1438a4692
> 
1438a4693
> 
1438a4694
> 
1438a4695
> 
1438a4696
> 
1438a4697
> 
1438a4698
> 
1438a4699
> 
1438a4700
> 
1438a4701
> 
1438a4702
> 
1438a4703
> 
1438a4704
> 
1438a4705
> 
1438a4706
> 
1438a4707
> 
1438a4708
> 
1438a4709
> 
1438a4710
> 
1438a4711
> 
1438a4712
> 
1438a4713
> 
1438a4714
> 
1438a4715
> 
1438a4716
> 
1438a4717
> 
1438a4718
> 
1438a4719
> 
1438a4720
> 
1438a4721
> 
1438a4722
> 
1438a4723
> 
1438a4724
> 
1438a4725
> 
1438a4726
> 
1438a4727
> 
1438a4728
> 
1438a4729
> 
1438a4730
> 
1438a4731
> 
1438a4732
> 
1438a4733
> 
1438a4734
> 
1438a4735
> 
1438a4736
> 
1438a4737
> 
1438a4738
> 
1438a4739
> 
1438a4740
> 
1438a4741
> 
1438a4742
> 
1438a4743
> 
1438a4744
> 
1438a4745
> 
1438a4746
> 
1438a4747
> 
1438a4748
> 
1438a4749
> 
1438a4750
> 
1438a4751
> 
1438a4752
> 
1438a4753
> 
1438a4754
> 
1438a4755
> 
1438a4756
> 
1438a4757
> 
1438a4758
> 
1438a4759
> 
1438a4760
> 
1438a4761
> 
1438a4762
> 
1438a4763
> 
1438a4764
> 
1438a4765
> 
1438a4766
> 
1438a4767
> 
1438a4768
> 
1438a4769
> 
1438a4770
> 
1438a4771
> 
1438a4772
> 
1438a4773
> 
1438a4774
> 
1438a4775
> 
1438a4776
> 
1438a4777
> 
1438a4778
> 
1438a4779
> 
1438a4780
> 
1438a4781
> 
1438a4782
> 
1438a4783
> 
1438a4784
> 
1438a4785
> 
1438a4786
> 
1438a4787
> 
1438a4788
> 
1438a4789
> 
1438a4790
> 
1438a4791
> 
1438a4792
> 
1438a4793
> 
1438a4794
> 
1438a4795
> 
1438a4796
> 
1438a4797
> 
1438a4798
> 
1438a4799
> 
1438a4800
> 
1438a4801
> 
1438a4802
> 
1438a4803
> 
1438a4804
> 
1438a4805
> 
1438a4806
> 
1438a4807
> 
1438a4808
> 
1438a4809
> 
1438a4810
> 
1438a4811
> 
1438a4812
> 
1438a4813
> 
1438a4814
> 
1438a4815
> 
1438a4816
> 
1438a4817
> 
1438a4818
> 
1438a4819
> 
1438a4820
> 
1438a4821
> 
1438a4822
> 
1438a4823
> 
1438a4824
> 
1438a4825
> 
1438a4826
> 
1438a4827
> 
1438a4828
> 
1438a4829
> 
1438a4830
> 
1438a4831
> 
1438a4832
> 
1438a4833
> 
1438a4834
> 
1438a4835
> 
1438a4836
> 
1438a4837
> 
1438a4838
> 
1438a4839
> 
1438a4840
> 
1438a4841
> 
1438a4842
> 
1438a4843
> 
1438a4844
> 
1438a4845
> 
1438a4846
> 
1438a4847
> 
1438a4848
> 
1438a4849
> 
1438a4850
> 
1438a4851
> 
1438a4852
> 
1438a4853
> 
1438a4854
> 
1438a4855
> 
1438a4856
> 
1438a4857
> 
1438a4858
> 
1438a4859
> 
1438a4860
> 
1438a4861
> 
1438a4862
> 
1438a4863
> 
1438a4864
> 
1438a4865
> 
1438a4866
> 
1438a4867
> 
1438a4868
> 
1438a4869
> 
1438a4870
> 
1438a4871
> 
1438a4872
> 
1438a4873
> 
1438a4874
> 
1438a4875
> 
1438a4876
> 
1438a4877
> 
1438a4878
> 
1438a4879
> 
1438a4880
> 
1438a4881
> 
1438a4882
> 
1438a4883
> 
1438a4884
> 
1438a4885
> 
1438a4886
> 
1438a4887
> 
1438a4888
> 
1438a4889
> 
1438a4890
> 
1438a4891
> 
1438a4892
> 
1438a4893
> 
1438a4894
> 
1438a4895
> 
1438a4896
> 
1438a4897
> 
1438a4898
> 
1438a4899
> 
1438a4900
> 
1438a4901
> 
1438a4902
> 
1438a4903
> 
1438a4904
> 
1438a4905
> 
1438a4906
> 
1438a4907
> 
1438a4908
> 
1438a4909
> 
1438a4910
> 
1438a4911
> 
1438a4912
> 
1438a4913
> 
1438a4914
> 
1438a4915
> 
1438a4916
> 
1438a4917
> 
1438a4918
> 
1438a4919
> 
1438a4920
> 
1438a4921
> 
1438a4922
> 
1438a4923
> 
1438a4924
> 
1438a4925
> 
1438a4926
> 
1438a4927
> 
1438a4928
> 
1438a4929
> 
1438a4930
> 
1438a4931
> 
1438a4932
> 
1438a4933
> 
1438a4934
> 
1438a4935
> 
1438a4936
> 
1438a4937
> 
1438a4938
> 
1438a4939
> 
1438a4940
> 
1438a4941
> 
1438a4942
> 
1438a4943
> 
1438a4944
> 
1438a4945
> 
1438a4946
> 
1438a4947
> 
1438a4948
> 
1438a4949
> 
1438a4950
> 
1438a4951
> 
1438a4952
> 
1438a4953
> 
1438a4954
> 
1438a4955
> 
1438a4956
> 
1438a4957
> 
1438a4958
> 
1438a4959
> 
1438a4960
> 
1438a4961
> 
1438a4962
> 
1438a4963
> 
1438a4964
> 
1438a4965
> 
1438a4966
> 
1438a4967
> 
1438a4968
> 
1438a4969
> 
1438a4970
> 
1438a4971
> 
1438a4972
> 
1438a4973
> 
1438a4974
> 
1438a4975
> 
1438a4976
> 
1438a4977
> 
1438a4978
> 
1438a4979
> 
1438a4980
> 
1438a4981
> 
1438a4982
> 
1438a4983
> 
1438a4984
> 
1438a4985
> 
1438a4986
> 
1438a4987
> 
1438a4988
> 
1438a4989
> 
1438a4990
> 
1438a4991
> 
1438a4992
> 
1438a4993
> 
1438a4994
> 
1438a4995
> 
1438a4996
> 
1438a4997
> 
1438a4998
> 
1438a4999
> 
1438a5000
> 
1438a5001
> 
1438a5002
> 
1438a5003
> 
1438a5004
> 
1438a5005
> 
1438a5006
> 
1438a5007
> 
1438a5008
> 
1438a5009
> 
1438a5010
> 
1438a5011
> 
1438a5012
> 
1438a5013
> 
1438a5014
> 
1438a5015
> 
1438a5016
> 
1438a5017
> 
1438a5018
> 
1438a5019
> 
1438a5020
> 
1438a5021
> 
1438a5022
> 
1438a5023
> 
1438a5024
> 
1438a5025
> 
1438a5026
> 
1438a5027
> 
1438a5028
> 
1438a5029
> 
1438a5030
> 
1438a5031
> 
1438a5032
> 
1438a5033
> 
1438a5034
> 
1438a5035
> 
1438a5036
> 
1438a5037
> 
1438a5038
> 
1438a5039
> 
1438a5040
> 
1438a5041
> 
1438a5042
> 
1438a5043
> 
1438a5044
> 
1438a5045
> 
1438a5046
> 
1438a5047
> 
1438a5048
> 
1438a5049
> 
1438a5050
> 
1438a5051
> 
1438a5052
> 
1438a5053
> 
1438a5054
> 
1438a5055
> 
1438a5056
> 
1438a5057
> 
1438a5058
> 
1438a5059
> 
1438a5060
> 
1438a5061
> 
1438a5062
> 
1438a5063
> 
1438a5064
> 
1438a5065
> 
1438a5066
> 
1438a5067
> 
1438a5068
> 
1438a5069
> 
1438a5070
> 
1438a5071
> 
1438a5072
> 
1438a5073
> 
1438a5074
> 
1438a5075
> 
1438a5076
> 
1438a5077
> 
1438a5078
> 
1438a5079
> 
1438a5080
> 
1438a5081
> 
1438a5082
> 
1438a5083
> 
1438a5084
> 
1438a5085
> 
1438a5086
> 
1438a5087
> 
1438a5088
> 
1438a5089
> 
1438a5090
> 
1438a5091
> 
1438a5092
> 
1438a5093
> 
1438a5094
> 
1438a5095
> 
1438a5096
> 
1438a5097
> 
1438a5098
> 
1438a5099
> 
1438a5100
> 
1438a5101
> 
1438a5102
> 
1438a5103
> 
1438a5104
> 
1438a5105
> 
1438a5106
> 
1438a5107
> 
1438a5108
> 
1438a5109
> 
1438a5110
> 
1438a5111
> 
1438a5112
> 
1438a5113
> 
1438a5114
> 
1438a5115
> 
1438a5116
> 
1438a5117
> 
1438a5118
> 
1438a5119
> 
1438a5120
> 
1438a5121
> 
1438a5122
> 
1438a5123
> 
1438a5124
> 
1438a5125
> 
1438a5126
> 
1438a5127
> 
1438a5128
> 
1438a5129
> 
1438a5130
> 
1438a5131
> 
1438a5132
> 
1438a5133
> 
1438a5134
> 
1438a5135
> 
1438a5136
> 
1438a5137
> 
1438a5138
> 
1438a5139
> 
1438a5140
> 
1438a5141
> 
1438a5142
> 
1438a5143
> 
1438a5144
> 
1438a5145
> 
1438a5146
> 
1438a5147
> 
1438a5148
> 
1438a5149
> 
1438a5150
> 
1438a5151
> 
1438a5152
> 
1438a5153
> 
1438a5154
> 
1438a5155
> 
1438a5156
> 
1438a5157
> 
1438a5158
> 
1438a5159
> 
1438a5160
> 
1438a5161
> 
1438a5162
> 
1438a5163
> 
1438a5164
> 
1438a5165
> 
1438a5166
> 
1438a5167
> 
1438a5168
> 
1438a5169
> 
1438a5170
> 
1438a5171
> 
1438a5172
> 
1438a5173
> 
1438a5174
> 
1438a5175
> 
1438a5176
> 
1438a5177
> 
1438a5178
> 
1438a5179
> 
1438a5180
> 
1438a5181
> 
1438a5182
> 
1438a5183
> 
1438a5184
> 
1438a5185
> 
1438a5186
> 
1438a5187
> 
1438a5188
> 
1438a5189
> 
1438a5190
> 
1438a5191
> 
1438a5192
> 
1438a5193
> 
1438a5194
> 
1438a5195
> 
1438a5196
> 
1438a5197
> 
1438a5198
> 
1438a5199
> 
1438a5200
> 
1438a5201
> 
1438a5202
> 
1438a5203
> 
1438a5204
> 
1438a5205
> 
1438a5206
> 
1438a5207
> 
1438a5208
> 
1438a5209
> 
1438a5210
> 
1438a5211
> 
1438a5212
> 
1438a5213
> 
1438a5214
> 
1438a5215
> 
1438a5216
> 
1438a5217
> 
1438a5218
> 
1438a5219
> 
1438a5220
> 
1438a5221
> 
1438a5222
> 
1438a5223
> 
1438a5224
> 
1438a5225
> 
1438a5226
> 
1438a5227
> 
1438a5228
> 
1438a5229
> 
1438a5230
> 
1438a5231
> 
1438a5232
> 
1438a5233
> 
1438a5234
> 
1438a5235
> 
1438a5236
> 
1438a5237
> 
1438a5238
> 
1438a5239
> 
1438a5240
> 
1438a5241
> 
1438a5242
> 
1438a5243
> 
1438a5244
> 
1438a5245
> 
1438a5246
> 
1438a5247
> 
1438a5248
> 
1438a5249
> 
1438a5250
> 
1438a5251
> 
1438a5252
> 
1438a5253
> 
1438a5254
> 
1438a5255
> 
1438a5256
> 
1438a5257
> 
1438a5258
> 
1438a5259
> 
1438a5260
> 
1438a5261
> 
1438a5262
> 
1438a5263
> 
1438a5264
> 
1438a5265
> 
1438a5266
> 
1438a5267
> 
1438a5268
> 
1438a5269
> 
1438a5270
> 
1438a5271
> 
1438a5272
> 
1438a5273
> 
1438a5274
> 
1438a5275
> 
1438a5276
> 
1438a5277
> 
1438a5278
> 
1438a5279
> 
1438a5280
> 
1438a5281
> 
1438a5282
> 
1438a5283
> 
1438a5284
> 
1438a5285
> 
1438a5286
> 
1438a5287
> 
1438a5288
> 
1438a5289
> 
1438a5290
> 
1438a5291
> 
1438a5292
> 
1438a5293
> 
1438a5294
> 
1438a5295
> 
1438a5296
> 
1438a5297
> 
1438a5298
> 
1438a5299
> 
1438a5300
> 
1438a5301
> 
1438a5302
> 
1438a5303
> 
1438a5304
> 
1438a5305
> 
1438a5306
> 
1438a5307
> 
1438a5308
> 
1438a5309
> 
1438a5310
> 
1438a5311
> 
1438a5312
> 
1438a5313
> 
1438a5314
> 
1438a5315
> 
1438a5316
> 
1438a5317
> 
1438a5318
> 
1438a5319
> 
1438a5320
> 
1438a5321
> 
1438a5322
> 
1438a5323
> 
1438a5324
> 
1438a5325
> 
1438a5326
> 
1438a5327
> 
1438a5328
> 
1438a5329
> 
1438a5330
> 
1438a5331
> 
1438a5332
> 
1438a5333
> 
1438a5334
> 
1438a5335
> 
1438a5336
> 
1438a5337
> 
1438a5338
> 
1438a5339
> 
1438a5340
> 
1438a5341
> 
1438a5342
> 
1438a5343
> 
1438a5344
> 
1438a5345
> 
1438a5346
> 
1438a5347
> 
1438a5348
> 
1438a5349
> 
1438a5350
> 
1438a5351
> 
1438a5352
> 
1438a5353
> 
1438a5354
> 
1438a5355
> 
1438a5356
> 
1438a5357
> 
1438a5358
> 
1438a5359
> 
1438a5360
> 
1438a5361
> 
1438a5362
> 
1438a5363
> 
1438a5364
> 
1438a5365
> 
1438a5366
> 
1438a5367
> 
1438a5368
> 
1438a5369
> 
1438a5370
> 
1438a5371
> 
1438a5372
> 
1438a5373
> 
1438a5374
> 
1438a5375
> 
1438a5376
> 
1438a5377
> 
1438a5378
> 
1438a5379
> 
1438a5380
> 
1438a5381
> 
1438a5382
> 
1438a5383
> 
1438a5384
> 
1438a5385
> 
1438a5386
> 
1438a5387
> 
1438a5388
> 
1438a5389
> 
1438a5390
> 
1438a5391
> 
1438a5392
> 
1438a5393
> 
1438a5394
> 
1438a5395
> 
1438a5396
> 
1438a5397
> 
1438a5398
> 
1438a5399
> 
1438a5400
> 
1438a5401
> 
1438a5402
> 
1438a5403
> 
1438a5404
> 
1438a5405
> 
1438a5406
> 
1438a5407
> 
1438a5408
> 
1438a5409
> 
1438a5410
> 
1438a5411
> 
1438a5412
> 
1438a5413
> 
1438a5414
> 
1438a5415
> 
1438a5416
> 
1438a5417
> 
1438a5418
> 
1438a5419
> 
1438a5420
> 
1438a5421
> 
1438a5422
> 
1438a5423
> 
1438a5424
> 
1438a5425
> 
1438a5426
> 
1438a5427
> 
1438a5428
> 
1438a5429
> 
1438a5430
> 
1438a5431
> 
1438a5432
> 
1438a5433
> 
1438a5434
> 
1438a5435
> 
1438a5436
> 
1438a5437
> 
1438a5438
> 
1438a5439
> 
1438a5440
> 
1438a5441
> 
1438a5442
> 
1438a5443
> 
1438a5444
> 
1438a5445
> 
1438a5446
> 
1438a5447
> 
1438a5448
> 
1438a5449
> 
1438a5450
> 
1438a5451
> 
1438a5452
> 
1438a5453
> 
1438a5454
> 
1438a5455
> 
1438a5456
> 
1438a5457
> 
1438a5458
> 
1438a5459
> 
1438a5460
> 
1438a5461
> 
1438a5462
> 
1438a5463
> 
1438a5464
> 
1438a5465
> 
1438a5466
> 
1438a5467
> 
1438a5468
> 
1438a5469
> 
1438a5470
> 
1438a5471
> 
1438a5472
> 
1438a5473
> 
1438a5474
> 
1438a5475
> 
1438a5476
> 
1438a5477
> 
1438a5478
> 
1438a5479
> 
1438a5480
> 
1438a5481
> 
1438a5482
> 
1438a5483
> 
1438a5484
> 
1438a5485
> 
1438a5486
> 
1438a5487
> 
1438a5488
> 
1438a5489
> 
1438a5490
> 
1438a5491
> 
1438a5492
> 
1438a5493
> 
1438a5494
> 
1438a5495
> 
1438a5496
> 
1438a5497
> 
1438a5498
> 
1438a5499
> 
1438a5500
> 
1438a5501
> 
1438a5502
> 
1438a5503
> 
1438a5504
> 
1438a5505
> 
1438a5506
> 
1438a5507
> 
1438a5508
> 
1438a5509
> 
1438a5510
> 
1438a5511
> 
1438a5512
> 
1438a5513
> 
1438a5514
> 
1438a5515
> 
1438a5516
> 
1438a5517
> 
1438a5518
> 
1438a5519
> 
1438a5520
> 
1438a5521
> 
1438a5522
> 
1438a5523
> 
1438a5524
> 
1438a5525
> 
1438a5526
> 
1438a5527
> 
1438a5528
> 
1438a5529
> 
1438a5530
> 
1438a5531
> 
1438a5532
> 
1438a5533
> 
1438a5534
> 
1438a5535
> 
1438a5536
> 
1438a5537
> 
1438a5538
> 
1438a5539
> 
1438a5540
> 
1438a5541
> 
1438a5542
> 
1438a5543
> 
1438a5544
> 
1438a5545
> 
1438a5546
> 
1438a5547
> 
1438a5548
> 
1438a5549
> 
1438a5550
> 
1438a5551
> 
1438a5552
> 
1438a5553
> 
1438a5554
> 
1438a5555
> 
1438a5556
> 
1438a5557
> 
1438a5558
> 
1438a5559
> 
1438a5560
> 
1438a5561
> 
1438a5562
> 
2005a6130
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Rank2Types, GADTs #-}
{-# LANGUAGE ScopedTypeVariables #-}

module ResolveLocals where
{-# LINE 2 "src-ag/Expression.ag" #-}

import UU.Scanner.Position(Pos)
import HsToken
{-# LINE 10 "dist/build/ResolveLocals.hs" #-}

{-# LINE 2 "src-ag/Patterns.ag" #-}

-- Patterns.ag imports
import UU.Scanner.Position(Pos)
import CommonTypes (ConstructorIdent,Identifier)
{-# LINE 17 "dist/build/ResolveLocals.hs" #-}

{-# LINE 2 "src-ag/AbstractSyntax.ag" #-}

-- AbstractSyntax.ag imports
import Data.Set(Set)
import Data.Map(Map)
import Patterns    (Pattern(..),Patterns)
import Expression  (Expression(..))
import Macro --marcos
import CommonTypes
import ErrorMessages
{-# LINE 29 "dist/build/ResolveLocals.hs" #-}

{-# LINE 15 "src-ag/ResolveLocals.ag" #-}

import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Map(Map)
import qualified Data.Sequence as Seq
import Data.Sequence(Seq,(><))
import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Expression
import Options
import HsToken(HsTokensRoot(HsTokensRoot))
import SemHsTokens(sem_HsTokensRoot,wrap_HsTokensRoot, Syn_HsTokensRoot(..),Inh_HsTokensRoot(..))
import Data.Maybe
{-# LINE 47 "dist/build/ResolveLocals.hs" #-}
import Control.Monad.Identity (Identity)
import qualified Control.Monad.Identity
-- Child -------------------------------------------------------
-- wrapper
data Inh_Child  = Inh_Child { allfields_Inh_Child :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Child :: ([Identifier]), attrs_Inh_Child :: ([(Identifier,Identifier)]), con_Inh_Child :: (Identifier), inh_Inh_Child :: (Attributes), inhMap_Inh_Child :: (Map Identifier Attributes), mergeMap_Inh_Child :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Child :: (Identifier), syn_Inh_Child :: (Attributes), synMap_Inh_Child :: (Map Identifier Attributes) }
data Syn_Child  = Syn_Child { attributes_Syn_Child :: ([(Identifier,Attributes,Attributes)]), field_Syn_Child :: ((Identifier,Type,ChildKind)), output_Syn_Child :: (Child) }
{-# INLINABLE wrap_Child #-}
wrap_Child :: T_Child  -> Inh_Child  -> (Syn_Child )
wrap_Child (T_Child act) (Inh_Child _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg1 = T_Child_vIn1 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap
        (T_Child_vOut1 _lhsOattributes _lhsOfield _lhsOoutput) <- return (inv_Child_s2 sem arg1)
        return (Syn_Child _lhsOattributes _lhsOfield _lhsOoutput)
   )

-- cata
{-# INLINE sem_Child #-}
sem_Child :: Child  -> T_Child
sem_Child ( Child name_ tp_ kind_ ) = sem_Child_Child name_ tp_ kind_

-- semantic domain
newtype T_Child  = T_Child {
                           attach_T_Child :: Identity (T_Child_s2 )
                           }
newtype T_Child_s2  = C_Child_s2 {
                                 inv_Child_s2 :: (T_Child_v1 )
                                 }
data T_Child_s3  = C_Child_s3
type T_Child_v1  = (T_Child_vIn1 ) -> (T_Child_vOut1 )
data T_Child_vIn1  = T_Child_vIn1 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Attributes) (Map Identifier Attributes)
data T_Child_vOut1  = T_Child_vOut1 ([(Identifier,Attributes,Attributes)]) ((Identifier,Type,ChildKind)) (Child)
{-# NOINLINE sem_Child_Child #-}
sem_Child_Child :: (Identifier) -> (Type) -> (ChildKind) -> T_Child
sem_Child_Child arg_name_ arg_tp_ arg_kind_ = T_Child (return st2) where
   {-# NOINLINE st2 #-}
   st2 = let
      v1 :: T_Child_v1
      v1 = \ (T_Child_vIn1 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _chnt = rule0 arg_name_ arg_tp_
         _inh = rule1 _chnt _lhsIinhMap
         _syn = rule2 _chnt _lhsIsynMap
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule3 _inh _syn arg_name_
         _lhsOfield :: (Identifier,Type,ChildKind)
         _lhsOfield = rule4 arg_kind_ arg_name_ arg_tp_
         _output = rule5 arg_kind_ arg_name_ arg_tp_
         _lhsOoutput :: Child
         _lhsOoutput = rule6 _output
         __result_ = T_Child_vOut1 _lhsOattributes _lhsOfield _lhsOoutput
         in __result_ )
     in C_Child_s2 v1
   {-# INLINE rule0 #-}
   {-# LINE 19 "src-ag/DistChildAttr.ag" #-}
   rule0 = \ name_ tp_ ->
                       {-# LINE 19 "src-ag/DistChildAttr.ag" #-}
                       case tp_ of
                         NT nt _ _ -> nt
                         Self      -> error ("The type of child " ++ show name_ ++ " should not be a Self type.")
                         Haskell t -> identifier ""
                       {-# LINE 108 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule1 #-}
   {-# LINE 23 "src-ag/DistChildAttr.ag" #-}
   rule1 = \ _chnt ((_lhsIinhMap) :: Map Identifier Attributes) ->
                      {-# LINE 23 "src-ag/DistChildAttr.ag" #-}
                      Map.findWithDefault Map.empty _chnt     _lhsIinhMap
                      {-# LINE 114 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule2 #-}
   {-# LINE 24 "src-ag/DistChildAttr.ag" #-}
   rule2 = \ _chnt ((_lhsIsynMap) :: Map Identifier Attributes) ->
                      {-# LINE 24 "src-ag/DistChildAttr.ag" #-}
                      Map.findWithDefault Map.empty _chnt     _lhsIsynMap
                      {-# LINE 120 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule3 #-}
   {-# LINE 83 "src-ag/ResolveLocals.ag" #-}
   rule3 = \ _inh _syn name_ ->
                             {-# LINE 83 "src-ag/ResolveLocals.ag" #-}
                             [(name_, _inh    , _syn    )]
                             {-# LINE 126 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule4 #-}
   {-# LINE 86 "src-ag/ResolveLocals.ag" #-}
   rule4 = \ kind_ name_ tp_ ->
                        {-# LINE 86 "src-ag/ResolveLocals.ag" #-}
                        (name_, tp_, kind_)
                        {-# LINE 132 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule5 #-}
   rule5 = \ kind_ name_ tp_ ->
     Child name_ tp_ kind_
   {-# INLINE rule6 #-}
   rule6 = \ _output ->
     _output

-- Children ----------------------------------------------------
-- wrapper
data Inh_Children  = Inh_Children { allfields_Inh_Children :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Children :: ([Identifier]), attrs_Inh_Children :: ([(Identifier,Identifier)]), con_Inh_Children :: (Identifier), inh_Inh_Children :: (Attributes), inhMap_Inh_Children :: (Map Identifier Attributes), mergeMap_Inh_Children :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Children :: (Identifier), syn_Inh_Children :: (Attributes), synMap_Inh_Children :: (Map Identifier Attributes) }
data Syn_Children  = Syn_Children { attributes_Syn_Children :: ([(Identifier,Attributes,Attributes)]), fields_Syn_Children :: ([(Identifier,Type,ChildKind)]), output_Syn_Children :: (Children) }
{-# INLINABLE wrap_Children #-}
wrap_Children :: T_Children  -> Inh_Children  -> (Syn_Children )
wrap_Children (T_Children act) (Inh_Children _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg4 = T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap
        (T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput) <- return (inv_Children_s5 sem arg4)
        return (Syn_Children _lhsOattributes _lhsOfields _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Children #-}
sem_Children :: Children  -> T_Children
sem_Children list = Prelude.foldr sem_Children_Cons sem_Children_Nil (Prelude.map sem_Child list)

-- semantic domain
newtype T_Children  = T_Children {
                                 attach_T_Children :: Identity (T_Children_s5 )
                                 }
newtype T_Children_s5  = C_Children_s5 {
                                       inv_Children_s5 :: (T_Children_v4 )
                                       }
data T_Children_s6  = C_Children_s6
type T_Children_v4  = (T_Children_vIn4 ) -> (T_Children_vOut4 )
data T_Children_vIn4  = T_Children_vIn4 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Attributes) (Map Identifier Attributes)
data T_Children_vOut4  = T_Children_vOut4 ([(Identifier,Attributes,Attributes)]) ([(Identifier,Type,ChildKind)]) (Children)
{-# NOINLINE sem_Children_Cons #-}
sem_Children_Cons :: T_Child  -> T_Children  -> T_Children
sem_Children_Cons arg_hd_ arg_tl_ = T_Children (return st5) where
   {-# NOINLINE st5 #-}
   st5 = let
      v4 :: T_Children_v4
      v4 = \ (T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _hdX2 = Control.Monad.Identity.runIdentity (attach_T_Child (arg_hd_))
         _tlX5 = Control.Monad.Identity.runIdentity (attach_T_Children (arg_tl_))
         (T_Child_vOut1 _hdIattributes _hdIfield _hdIoutput) = inv_Child_s2 _hdX2 (T_Child_vIn1 _hdOallfields _hdOallnts _hdOattrs _hdOcon _hdOinh _hdOinhMap _hdOmergeMap _hdOnt _hdOsyn _hdOsynMap)
         (T_Children_vOut4 _tlIattributes _tlIfields _tlIoutput) = inv_Children_s5 _tlX5 (T_Children_vIn4 _tlOallfields _tlOallnts _tlOattrs _tlOcon _tlOinh _tlOinhMap _tlOmergeMap _tlOnt _tlOsyn _tlOsynMap)
         _lhsOfields :: [(Identifier,Type,ChildKind)]
         _lhsOfields = rule7 _hdIfield _tlIfields
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule8 _hdIattributes _tlIattributes
         _output = rule9 _hdIoutput _tlIoutput
         _lhsOoutput :: Children
         _lhsOoutput = rule10 _output
         _hdOallfields = rule11 _lhsIallfields
         _hdOallnts = rule12 _lhsIallnts
         _hdOattrs = rule13 _lhsIattrs
         _hdOcon = rule14 _lhsIcon
         _hdOinh = rule15 _lhsIinh
         _hdOinhMap = rule16 _lhsIinhMap
         _hdOmergeMap = rule17 _lhsImergeMap
         _hdOnt = rule18 _lhsInt
         _hdOsyn = rule19 _lhsIsyn
         _hdOsynMap = rule20 _lhsIsynMap
         _tlOallfields = rule21 _lhsIallfields
         _tlOallnts = rule22 _lhsIallnts
         _tlOattrs = rule23 _lhsIattrs
         _tlOcon = rule24 _lhsIcon
         _tlOinh = rule25 _lhsIinh
         _tlOinhMap = rule26 _lhsIinhMap
         _tlOmergeMap = rule27 _lhsImergeMap
         _tlOnt = rule28 _lhsInt
         _tlOsyn = rule29 _lhsIsyn
         _tlOsynMap = rule30 _lhsIsynMap
         __result_ = T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput
         in __result_ )
     in C_Children_s5 v4
   {-# INLINE rule7 #-}
   {-# LINE 89 "src-ag/ResolveLocals.ag" #-}
   rule7 = \ ((_hdIfield) :: (Identifier,Type,ChildKind)) ((_tlIfields) :: [(Identifier,Type,ChildKind)]) ->
                         {-# LINE 89 "src-ag/ResolveLocals.ag" #-}
                         _hdIfield : _tlIfields
                         {-# LINE 216 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule8 #-}
   rule8 = \ ((_hdIattributes) :: [(Identifier,Attributes,Attributes)]) ((_tlIattributes) :: [(Identifier,Attributes,Attributes)]) ->
     _hdIattributes ++ _tlIattributes
   {-# INLINE rule9 #-}
   rule9 = \ ((_hdIoutput) :: Child) ((_tlIoutput) :: Children) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule10 #-}
   rule10 = \ _output ->
     _output
   {-# INLINE rule11 #-}
   rule11 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule12 #-}
   rule12 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule13 #-}
   rule13 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule14 #-}
   rule14 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule15 #-}
   rule15 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule16 #-}
   rule16 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule17 #-}
   rule17 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule18 #-}
   rule18 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule19 #-}
   rule19 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule20 #-}
   rule20 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule21 #-}
   rule21 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule22 #-}
   rule22 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule23 #-}
   rule23 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule24 #-}
   rule24 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule25 #-}
   rule25 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule26 #-}
   rule26 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule27 #-}
   rule27 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule28 #-}
   rule28 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule29 #-}
   rule29 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule30 #-}
   rule30 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
{-# NOINLINE sem_Children_Nil #-}
sem_Children_Nil ::  T_Children
sem_Children_Nil  = T_Children (return st5) where
   {-# NOINLINE st5 #-}
   st5 = let
      v4 :: T_Children_v4
      v4 = \ (T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _lhsOfields :: [(Identifier,Type,ChildKind)]
         _lhsOfields = rule31  ()
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule32  ()
         _output = rule33  ()
         _lhsOoutput :: Children
         _lhsOoutput = rule34 _output
         __result_ = T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput
         in __result_ )
     in C_Children_s5 v4
   {-# INLINE rule31 #-}
   {-# LINE 90 "src-ag/ResolveLocals.ag" #-}
   rule31 = \  (_ :: ()) ->
                         {-# LINE 90 "src-ag/ResolveLocals.ag" #-}
                         []
                         {-# LINE 308 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule32 #-}
   rule32 = \  (_ :: ()) ->
     []
   {-# INLINE rule33 #-}
   rule33 = \  (_ :: ()) ->
     []
   {-# INLINE rule34 #-}
   rule34 = \ _output ->
     _output

-- Expression --------------------------------------------------
-- wrapper
data Inh_Expression  = Inh_Expression { allfields_Inh_Expression :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Expression :: ([Identifier]), attrs_Inh_Expression :: ([(Identifier,Identifier)]), con_Inh_Expression :: (Identifier), mergeMap_Inh_Expression :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Expression :: (Identifier), options_Inh_Expression :: (Options) }
data Syn_Expression  = Syn_Expression { errors_Syn_Expression :: (Seq Error), output_Syn_Expression :: (Expression) }
{-# INLINABLE wrap_Expression #-}
wrap_Expression :: T_Expression  -> Inh_Expression  -> (Syn_Expression )
wrap_Expression (T_Expression act) (Inh_Expression _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg7 = T_Expression_vIn7 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions
        (T_Expression_vOut7 _lhsOerrors _lhsOoutput) <- return (inv_Expression_s8 sem arg7)
        return (Syn_Expression _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Expression #-}
sem_Expression :: Expression  -> T_Expression
sem_Expression ( Expression pos_ tks_ ) = sem_Expression_Expression pos_ tks_

-- semantic domain
newtype T_Expression  = T_Expression {
                                     attach_T_Expression :: Identity (T_Expression_s8 )
                                     }
newtype T_Expression_s8  = C_Expression_s8 {
                                           inv_Expression_s8 :: (T_Expression_v7 )
                                           }
data T_Expression_s9  = C_Expression_s9
type T_Expression_v7  = (T_Expression_vIn7 ) -> (T_Expression_vOut7 )
data T_Expression_vIn7  = T_Expression_vIn7 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options)
data T_Expression_vOut7  = T_Expression_vOut7 (Seq Error) (Expression)
{-# NOINLINE sem_Expression_Expression #-}
sem_Expression_Expression :: (Pos) -> ([HsToken]) -> T_Expression
sem_Expression_Expression arg_pos_ arg_tks_ = T_Expression (return st8) where
   {-# NOINLINE st8 #-}
   st8 = let
      v7 :: T_Expression_v7
      v7 = \ (T_Expression_vIn7 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions) -> ( let
         (_errors,_newTks) = rule35 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions arg_tks_
         _lhsOoutput :: Expression
         _lhsOoutput = rule36 _newTks arg_pos_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule37 _errors
         _output = rule38 arg_pos_ arg_tks_
         __result_ = T_Expression_vOut7 _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Expression_s8 v7
   {-# INLINE rule35 #-}
   {-# LINE 145 "src-ag/ResolveLocals.ag" #-}
   rule35 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ((_lhsIallnts) :: [Identifier]) ((_lhsIattrs) :: [(Identifier,Identifier)]) ((_lhsIcon) :: Identifier) ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ((_lhsInt) :: Identifier) ((_lhsIoptions) :: Options) tks_ ->
                                {-# LINE 145 "src-ag/ResolveLocals.ag" #-}
                                let mergedChildren = [ x | (_,xs) <- Map.elems _lhsImergeMap, x <- xs ]
                                    attrsIn = filter (\(fld,_) -> not (fld `elem` mergedChildren)) _lhsIattrs
                                    inherited = Inh_HsTokensRoot
                                                { attrs_Inh_HsTokensRoot      = attrsIn
                                                , con_Inh_HsTokensRoot        = _lhsIcon
                                                , allfields_Inh_HsTokensRoot  = _lhsIallfields
                                                , allnts_Inh_HsTokensRoot     = _lhsIallnts
                                                , nt_Inh_HsTokensRoot         = _lhsInt
                                                , options_Inh_HsTokensRoot    = _lhsIoptions
                                                }
                                    synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot tks_)) inherited
                                in (errors_Syn_HsTokensRoot synthesized, output_Syn_HsTokensRoot synthesized)
                                {-# LINE 381 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule36 #-}
   {-# LINE 157 "src-ag/ResolveLocals.ag" #-}
   rule36 = \ _newTks pos_ ->
                               {-# LINE 157 "src-ag/ResolveLocals.ag" #-}
                               Expression pos_ _newTks
                               {-# LINE 387 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule37 #-}
   rule37 = \ _errors ->
     _errors
   {-# INLINE rule38 #-}
   rule38 = \ pos_ tks_ ->
     Expression pos_ tks_

-- Grammar -----------------------------------------------------
-- wrapper
data Inh_Grammar  = Inh_Grammar { options_Inh_Grammar :: (Options) }
data Syn_Grammar  = Syn_Grammar { errors_Syn_Grammar :: (Seq Error), output_Syn_Grammar :: (Grammar) }
{-# INLINABLE wrap_Grammar #-}
wrap_Grammar :: T_Grammar  -> Inh_Grammar  -> (Syn_Grammar )
wrap_Grammar (T_Grammar act) (Inh_Grammar _lhsIoptions) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg10 = T_Grammar_vIn10 _lhsIoptions
        (T_Grammar_vOut10 _lhsOerrors _lhsOoutput) <- return (inv_Grammar_s11 sem arg10)
        return (Syn_Grammar _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Grammar #-}
sem_Grammar :: Grammar  -> T_Grammar
sem_Grammar ( Grammar typeSyns_ useMap_ derivings_ wrappers_ nonts_ pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_ ) = sem_Grammar_Grammar typeSyns_ useMap_ derivings_ wrappers_ ( sem_Nonterminals nonts_ ) pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_

-- semantic domain
newtype T_Grammar  = T_Grammar {
                               attach_T_Grammar :: Identity (T_Grammar_s11 )
                               }
newtype T_Grammar_s11  = C_Grammar_s11 {
                                       inv_Grammar_s11 :: (T_Grammar_v10 )
                                       }
data T_Grammar_s12  = C_Grammar_s12
type T_Grammar_v10  = (T_Grammar_vIn10 ) -> (T_Grammar_vOut10 )
data T_Grammar_vIn10  = T_Grammar_vIn10 (Options)
data T_Grammar_vOut10  = T_Grammar_vOut10 (Seq Error) (Grammar)
{-# NOINLINE sem_Grammar_Grammar #-}
sem_Grammar_Grammar :: (TypeSyns) -> (UseMap) -> (Derivings) -> (Set NontermIdent) -> T_Nonterminals  -> (PragmaMap) -> (AttrOrderMap) -> (ParamMap) -> (ContextMap) -> (QuantMap) -> (UniqueMap) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier [Expression]))) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier [Expression]))) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier, [Identifier], Expression)))) -> T_Grammar
sem_Grammar_Grammar arg_typeSyns_ arg_useMap_ arg_derivings_ arg_wrappers_ arg_nonts_ arg_pragmas_ arg_manualAttrOrderMap_ arg_paramMap_ arg_contextMap_ arg_quantMap_ arg_uniqueMap_ arg_augmentsMap_ arg_aroundsMap_ arg_mergeMap_ = T_Grammar (return st11) where
   {-# NOINLINE st11 #-}
   st11 = let
      v10 :: T_Grammar_v10
      v10 = \ (T_Grammar_vIn10 _lhsIoptions) -> ( let
         _nontsX17 = Control.Monad.Identity.runIdentity (attach_T_Nonterminals (arg_nonts_))
         (T_Nonterminals_vOut16 _nontsIerrors _nontsIinhMap' _nontsInonts _nontsIoutput _nontsIsynMap') = inv_Nonterminals_s17 _nontsX17 (T_Nonterminals_vIn16 _nontsOallnts _nontsOinhMap _nontsOmergeMap _nontsOoptions _nontsOsynMap)
         _nontsOinhMap = rule39 _nontsIinhMap'
         _nontsOsynMap = rule40 _nontsIsynMap'
         _nontsOallnts = rule41 _nontsInonts
         _nontsOmergeMap = rule42 arg_mergeMap_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule43 _nontsIerrors
         _output = rule44 _nontsIoutput arg_aroundsMap_ arg_augmentsMap_ arg_contextMap_ arg_derivings_ arg_manualAttrOrderMap_ arg_mergeMap_ arg_paramMap_ arg_pragmas_ arg_quantMap_ arg_typeSyns_ arg_uniqueMap_ arg_useMap_ arg_wrappers_
         _lhsOoutput :: Grammar
         _lhsOoutput = rule45 _output
         _nontsOoptions = rule46 _lhsIoptions
         __result_ = T_Grammar_vOut10 _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Grammar_s11 v10
   {-# INLINE rule39 #-}
   {-# LINE 15 "src-ag/DistChildAttr.ag" #-}
   rule39 = \ ((_nontsIinhMap') :: Map Identifier Attributes) ->
                             {-# LINE 15 "src-ag/DistChildAttr.ag" #-}
                             _nontsIinhMap'
                             {-# LINE 452 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule40 #-}
   {-# LINE 16 "src-ag/DistChildAttr.ag" #-}
   rule40 = \ ((_nontsIsynMap') :: Map Identifier Attributes) ->
                             {-# LINE 16 "src-ag/DistChildAttr.ag" #-}
                             _nontsIsynMap'
                             {-# LINE 458 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule41 #-}
   {-# LINE 59 "src-ag/ResolveLocals.ag" #-}
   rule41 = \ ((_nontsInonts) :: [(NontermIdent,[ConstructorIdent])]) ->
                             {-# LINE 59 "src-ag/ResolveLocals.ag" #-}
                             map fst (_nontsInonts)
                             {-# LINE 464 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule42 #-}
   {-# LINE 119 "src-ag/ResolveLocals.ag" #-}
   rule42 = \ mergeMap_ ->
                                 {-# LINE 119 "src-ag/ResolveLocals.ag" #-}
                                 Map.map (Map.map (Map.map (\(nt,srcs,_) -> (nt,srcs)))) mergeMap_
                                 {-# LINE 470 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule43 #-}
   rule43 = \ ((_nontsIerrors) :: Seq Error) ->
     _nontsIerrors
   {-# INLINE rule44 #-}
   rule44 = \ ((_nontsIoutput) :: Nonterminals) aroundsMap_ augmentsMap_ contextMap_ derivings_ manualAttrOrderMap_ mergeMap_ paramMap_ pragmas_ quantMap_ typeSyns_ uniqueMap_ useMap_ wrappers_ ->
     Grammar typeSyns_ useMap_ derivings_ wrappers_ _nontsIoutput pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_
   {-# INLINE rule45 #-}
   rule45 = \ _output ->
     _output
   {-# INLINE rule46 #-}
   rule46 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions

-- Nonterminal -------------------------------------------------
-- wrapper
data Inh_Nonterminal  = Inh_Nonterminal { allnts_Inh_Nonterminal :: ([Identifier]), inhMap_Inh_Nonterminal :: (Map Identifier Attributes), mergeMap_Inh_Nonterminal :: (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))), options_Inh_Nonterminal :: (Options), synMap_Inh_Nonterminal :: (Map Identifier Attributes) }
data Syn_Nonterminal  = Syn_Nonterminal { errors_Syn_Nonterminal :: (Seq Error), inhMap'_Syn_Nonterminal :: (Map Identifier Attributes), nonts_Syn_Nonterminal :: ([(NontermIdent,[ConstructorIdent])]), output_Syn_Nonterminal :: (Nonterminal), synMap'_Syn_Nonterminal :: (Map Identifier Attributes) }
{-# INLINABLE wrap_Nonterminal #-}
wrap_Nonterminal :: T_Nonterminal  -> Inh_Nonterminal  -> (Syn_Nonterminal )
wrap_Nonterminal (T_Nonterminal act) (Inh_Nonterminal _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg13 = T_Nonterminal_vIn13 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap
        (T_Nonterminal_vOut13 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap') <- return (inv_Nonterminal_s14 sem arg13)
        return (Syn_Nonterminal _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap')
   )

-- cata
{-# INLINE sem_Nonterminal #-}
sem_Nonterminal :: Nonterminal  -> T_Nonterminal
sem_Nonterminal ( Nonterminal nt_ params_ inh_ syn_ prods_ ) = sem_Nonterminal_Nonterminal nt_ params_ inh_ syn_ ( sem_Productions prods_ )

-- semantic domain
newtype T_Nonterminal  = T_Nonterminal {
                                       attach_T_Nonterminal :: Identity (T_Nonterminal_s14 )
                                       }
newtype T_Nonterminal_s14  = C_Nonterminal_s14 {
                                               inv_Nonterminal_s14 :: (T_Nonterminal_v13 )
                                               }
data T_Nonterminal_s15  = C_Nonterminal_s15
type T_Nonterminal_v13  = (T_Nonterminal_vIn13 ) -> (T_Nonterminal_vOut13 )
data T_Nonterminal_vIn13  = T_Nonterminal_vIn13 ([Identifier]) (Map Identifier Attributes) (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) (Options) (Map Identifier Attributes)
data T_Nonterminal_vOut13  = T_Nonterminal_vOut13 (Seq Error) (Map Identifier Attributes) ([(NontermIdent,[ConstructorIdent])]) (Nonterminal) (Map Identifier Attributes)
{-# NOINLINE sem_Nonterminal_Nonterminal #-}
sem_Nonterminal_Nonterminal :: (NontermIdent) -> ([Identifier]) -> (Attributes) -> (Attributes) -> T_Productions  -> T_Nonterminal
sem_Nonterminal_Nonterminal arg_nt_ arg_params_ arg_inh_ arg_syn_ arg_prods_ = T_Nonterminal (return st14) where
   {-# NOINLINE st14 #-}
   st14 = let
      v13 :: T_Nonterminal_v13
      v13 = \ (T_Nonterminal_vIn13 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _prodsX29 = Control.Monad.Identity.runIdentity (attach_T_Productions (arg_prods_))
         (T_Productions_vOut28 _prodsIcons _prodsIerrors _prodsIoutput) = inv_Productions_s29 _prodsX29 (T_Productions_vIn28 _prodsOallnts _prodsOinh _prodsOinhMap _prodsOmergeMap _prodsOnt _prodsOoptions _prodsOsyn _prodsOsynMap)
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule47 arg_inh_ arg_nt_
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule48 arg_nt_ arg_syn_
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule49 _prodsIcons arg_nt_
         _prodsOnt = rule50 arg_nt_
         _prodsOinh = rule51 arg_inh_
         _prodsOsyn = rule52 arg_syn_
         _mergeMap = rule53 _lhsImergeMap arg_nt_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule54 _prodsIerrors
         _output = rule55 _prodsIoutput arg_inh_ arg_nt_ arg_params_ arg_syn_
         _lhsOoutput :: Nonterminal
         _lhsOoutput = rule56 _output
         _prodsOallnts = rule57 _lhsIallnts
         _prodsOinhMap = rule58 _lhsIinhMap
         _prodsOmergeMap = rule59 _mergeMap
         _prodsOoptions = rule60 _lhsIoptions
         _prodsOsynMap = rule61 _lhsIsynMap
         __result_ = T_Nonterminal_vOut13 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminal_s14 v13
   {-# INLINE rule47 #-}
   {-# LINE 7 "src-ag/DistChildAttr.ag" #-}
   rule47 = \ inh_ nt_ ->
                                 {-# LINE 7 "src-ag/DistChildAttr.ag" #-}
                                 Map.singleton nt_ inh_
                                 {-# LINE 551 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule48 #-}
   {-# LINE 8 "src-ag/DistChildAttr.ag" #-}
   rule48 = \ nt_ syn_ ->
                                 {-# LINE 8 "src-ag/DistChildAttr.ag" #-}
                                 Map.singleton nt_ syn_
                                 {-# LINE 557 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule49 #-}
   {-# LINE 63 "src-ag/ResolveLocals.ag" #-}
   rule49 = \ ((_prodsIcons) :: [ConstructorIdent]) nt_ ->
                                {-# LINE 63 "src-ag/ResolveLocals.ag" #-}
                                [(nt_,_prodsIcons)]
                                {-# LINE 563 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule50 #-}
   {-# LINE 111 "src-ag/ResolveLocals.ag" #-}
   rule50 = \ nt_ ->
                               {-# LINE 111 "src-ag/ResolveLocals.ag" #-}
                               nt_
                               {-# LINE 569 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule51 #-}
   {-# LINE 114 "src-ag/ResolveLocals.ag" #-}
   rule51 = \ inh_ ->
                               {-# LINE 114 "src-ag/ResolveLocals.ag" #-}
                               inh_
                               {-# LINE 575 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule52 #-}
   {-# LINE 115 "src-ag/ResolveLocals.ag" #-}
   rule52 = \ syn_ ->
                               {-# LINE 115 "src-ag/ResolveLocals.ag" #-}
                               syn_
                               {-# LINE 581 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule53 #-}
   {-# LINE 127 "src-ag/ResolveLocals.ag" #-}
   rule53 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) nt_ ->
                                                {-# LINE 127 "src-ag/ResolveLocals.ag" #-}
                                                Map.findWithDefault Map.empty nt_ _lhsImergeMap
                                                {-# LINE 587 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule54 #-}
   rule54 = \ ((_prodsIerrors) :: Seq Error) ->
     _prodsIerrors
   {-# INLINE rule55 #-}
   rule55 = \ ((_prodsIoutput) :: Productions) inh_ nt_ params_ syn_ ->
     Nonterminal nt_ params_ inh_ syn_ _prodsIoutput
   {-# INLINE rule56 #-}
   rule56 = \ _output ->
     _output
   {-# INLINE rule57 #-}
   rule57 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule58 #-}
   rule58 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule59 #-}
   rule59 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule60 #-}
   rule60 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule61 #-}
   rule61 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap

-- Nonterminals ------------------------------------------------
-- wrapper
data Inh_Nonterminals  = Inh_Nonterminals { allnts_Inh_Nonterminals :: ([Identifier]), inhMap_Inh_Nonterminals :: (Map Identifier Attributes), mergeMap_Inh_Nonterminals :: (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))), options_Inh_Nonterminals :: (Options), synMap_Inh_Nonterminals :: (Map Identifier Attributes) }
data Syn_Nonterminals  = Syn_Nonterminals { errors_Syn_Nonterminals :: (Seq Error), inhMap'_Syn_Nonterminals :: (Map Identifier Attributes), nonts_Syn_Nonterminals :: ([(NontermIdent,[ConstructorIdent])]), output_Syn_Nonterminals :: (Nonterminals), synMap'_Syn_Nonterminals :: (Map Identifier Attributes) }
{-# INLINABLE wrap_Nonterminals #-}
wrap_Nonterminals :: T_Nonterminals  -> Inh_Nonterminals  -> (Syn_Nonterminals )
wrap_Nonterminals (T_Nonterminals act) (Inh_Nonterminals _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg16 = T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap
        (T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap') <- return (inv_Nonterminals_s17 sem arg16)
        return (Syn_Nonterminals _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap')
   )

-- cata
{-# NOINLINE sem_Nonterminals #-}
sem_Nonterminals :: Nonterminals  -> T_Nonterminals
sem_Nonterminals list = Prelude.foldr sem_Nonterminals_Cons sem_Nonterminals_Nil (Prelude.map sem_Nonterminal list)

-- semantic domain
newtype T_Nonterminals  = T_Nonterminals {
                                         attach_T_Nonterminals :: Identity (T_Nonterminals_s17 )
                                         }
newtype T_Nonterminals_s17  = C_Nonterminals_s17 {
                                                 inv_Nonterminals_s17 :: (T_Nonterminals_v16 )
                                                 }
data T_Nonterminals_s18  = C_Nonterminals_s18
type T_Nonterminals_v16  = (T_Nonterminals_vIn16 ) -> (T_Nonterminals_vOut16 )
data T_Nonterminals_vIn16  = T_Nonterminals_vIn16 ([Identifier]) (Map Identifier Attributes) (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) (Options) (Map Identifier Attributes)
data T_Nonterminals_vOut16  = T_Nonterminals_vOut16 (Seq Error) (Map Identifier Attributes) ([(NontermIdent,[ConstructorIdent])]) (Nonterminals) (Map Identifier Attributes)
{-# NOINLINE sem_Nonterminals_Cons #-}
sem_Nonterminals_Cons :: T_Nonterminal  -> T_Nonterminals  -> T_Nonterminals
sem_Nonterminals_Cons arg_hd_ arg_tl_ = T_Nonterminals (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_Nonterminals_v16
      v16 = \ (T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _hdX14 = Control.Monad.Identity.runIdentity (attach_T_Nonterminal (arg_hd_))
         _tlX17 = Control.Monad.Identity.runIdentity (attach_T_Nonterminals (arg_tl_))
         (T_Nonterminal_vOut13 _hdIerrors _hdIinhMap' _hdInonts _hdIoutput _hdIsynMap') = inv_Nonterminal_s14 _hdX14 (T_Nonterminal_vIn13 _hdOallnts _hdOinhMap _hdOmergeMap _hdOoptions _hdOsynMap)
         (T_Nonterminals_vOut16 _tlIerrors _tlIinhMap' _tlInonts _tlIoutput _tlIsynMap') = inv_Nonterminals_s17 _tlX17 (T_Nonterminals_vIn16 _tlOallnts _tlOinhMap _tlOmergeMap _tlOoptions _tlOsynMap)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule62 _hdIerrors _tlIerrors
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule63 _hdIinhMap' _tlIinhMap'
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule64 _hdInonts _tlInonts
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule65 _hdIsynMap' _tlIsynMap'
         _output = rule66 _hdIoutput _tlIoutput
         _lhsOoutput :: Nonterminals
         _lhsOoutput = rule67 _output
         _hdOallnts = rule68 _lhsIallnts
         _hdOinhMap = rule69 _lhsIinhMap
         _hdOmergeMap = rule70 _lhsImergeMap
         _hdOoptions = rule71 _lhsIoptions
         _hdOsynMap = rule72 _lhsIsynMap
         _tlOallnts = rule73 _lhsIallnts
         _tlOinhMap = rule74 _lhsIinhMap
         _tlOmergeMap = rule75 _lhsImergeMap
         _tlOoptions = rule76 _lhsIoptions
         _tlOsynMap = rule77 _lhsIsynMap
         __result_ = T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminals_s17 v16
   {-# INLINE rule62 #-}
   rule62 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule63 #-}
   rule63 = \ ((_hdIinhMap') :: Map Identifier Attributes) ((_tlIinhMap') :: Map Identifier Attributes) ->
     _hdIinhMap' `Map.union` _tlIinhMap'
   {-# INLINE rule64 #-}
   rule64 = \ ((_hdInonts) :: [(NontermIdent,[ConstructorIdent])]) ((_tlInonts) :: [(NontermIdent,[ConstructorIdent])]) ->
     _hdInonts ++ _tlInonts
   {-# INLINE rule65 #-}
   rule65 = \ ((_hdIsynMap') :: Map Identifier Attributes) ((_tlIsynMap') :: Map Identifier Attributes) ->
     _hdIsynMap' `Map.union` _tlIsynMap'
   {-# INLINE rule66 #-}
   rule66 = \ ((_hdIoutput) :: Nonterminal) ((_tlIoutput) :: Nonterminals) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule67 #-}
   rule67 = \ _output ->
     _output
   {-# INLINE rule68 #-}
   rule68 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule69 #-}
   rule69 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule70 #-}
   rule70 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) ->
     _lhsImergeMap
   {-# INLINE rule71 #-}
   rule71 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule72 #-}
   rule72 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule73 #-}
   rule73 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule74 #-}
   rule74 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule75 #-}
   rule75 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) ->
     _lhsImergeMap
   {-# INLINE rule76 #-}
   rule76 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule77 #-}
   rule77 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
{-# NOINLINE sem_Nonterminals_Nil #-}
sem_Nonterminals_Nil ::  T_Nonterminals
sem_Nonterminals_Nil  = T_Nonterminals (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_Nonterminals_v16
      v16 = \ (T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule78  ()
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule79  ()
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule80  ()
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule81  ()
         _output = rule82  ()
         _lhsOoutput :: Nonterminals
         _lhsOoutput = rule83 _output
         __result_ = T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminals_s17 v16
   {-# INLINE rule78 #-}
   rule78 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule79 #-}
   rule79 = \  (_ :: ()) ->
     Map.empty
   {-# INLINE rule80 #-}
   rule80 = \  (_ :: ()) ->
     []
   {-# INLINE rule81 #-}
   rule81 = \  (_ :: ()) ->
     Map.empty
   {-# INLINE rule82 #-}
   rule82 = \  (_ :: ()) ->
     []
   {-# INLINE rule83 #-}
   rule83 = \ _output ->
     _output

-- Pattern -----------------------------------------------------
-- wrapper
data Inh_Pattern  = Inh_Pattern { con_Inh_Pattern :: (Identifier), inh_Inh_Pattern :: (Attributes), nt_Inh_Pattern :: (Identifier), syn_Inh_Pattern :: (Attributes) }
data Syn_Pattern  = Syn_Pattern { copy_Syn_Pattern :: (Pattern), errors_Syn_Pattern :: (Seq Error), instVars_Syn_Pattern :: ([Identifier]), locVars_Syn_Pattern :: ([Identifier]), output_Syn_Pattern :: (Pattern) }
{-# INLINABLE wrap_Pattern #-}
wrap_Pattern :: T_Pattern  -> Inh_Pattern  -> (Syn_Pattern )
wrap_Pattern (T_Pattern act) (Inh_Pattern _lhsIcon _lhsIinh _lhsInt _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg19 = T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn
        (T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Pattern_s20 sem arg19)
        return (Syn_Pattern _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Pattern #-}
sem_Pattern :: Pattern  -> T_Pattern
sem_Pattern ( Constr name_ pats_ ) = sem_Pattern_Constr name_ ( sem_Patterns pats_ )
sem_Pattern ( Product pos_ pats_ ) = sem_Pattern_Product pos_ ( sem_Patterns pats_ )
sem_Pattern ( Alias field_ attr_ pat_ ) = sem_Pattern_Alias field_ attr_ ( sem_Pattern pat_ )
sem_Pattern ( Irrefutable pat_ ) = sem_Pattern_Irrefutable ( sem_Pattern pat_ )
sem_Pattern ( Underscore pos_ ) = sem_Pattern_Underscore pos_

-- semantic domain
newtype T_Pattern  = T_Pattern {
                               attach_T_Pattern :: Identity (T_Pattern_s20 )
                               }
newtype T_Pattern_s20  = C_Pattern_s20 {
                                       inv_Pattern_s20 :: (T_Pattern_v19 )
                                       }
data T_Pattern_s21  = C_Pattern_s21
type T_Pattern_v19  = (T_Pattern_vIn19 ) -> (T_Pattern_vOut19 )
data T_Pattern_vIn19  = T_Pattern_vIn19 (Identifier) (Attributes) (Identifier) (Attributes)
data T_Pattern_vOut19  = T_Pattern_vOut19 (Pattern) (Seq Error) ([Identifier]) ([Identifier]) (Pattern)
{-# NOINLINE sem_Pattern_Constr #-}
sem_Pattern_Constr :: (ConstructorIdent) -> T_Patterns  -> T_Pattern
sem_Pattern_Constr arg_name_ arg_pats_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patsX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_pats_))
         (T_Patterns_vOut22 _patsIcopy _patsIerrors _patsIinstVars _patsIlocVars _patsIoutput) = inv_Patterns_s23 _patsX23 (T_Patterns_vIn22 _patsOcon _patsOinh _patsOnt _patsOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule84 _patsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule85 _patsIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule86 _patsIlocVars
         _copy = rule87 _patsIcopy arg_name_
         _output = rule88 _patsIoutput arg_name_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule89 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule90 _output
         _patsOcon = rule91 _lhsIcon
         _patsOinh = rule92 _lhsIinh
         _patsOnt = rule93 _lhsInt
         _patsOsyn = rule94 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule84 #-}
   rule84 = \ ((_patsIerrors) :: Seq Error) ->
     _patsIerrors
   {-# INLINE rule85 #-}
   rule85 = \ ((_patsIinstVars) :: [Identifier]) ->
     _patsIinstVars
   {-# INLINE rule86 #-}
   rule86 = \ ((_patsIlocVars) :: [Identifier]) ->
     _patsIlocVars
   {-# INLINE rule87 #-}
   rule87 = \ ((_patsIcopy) :: Patterns) name_ ->
     Constr name_ _patsIcopy
   {-# INLINE rule88 #-}
   rule88 = \ ((_patsIoutput) :: Patterns) name_ ->
     Constr name_ _patsIoutput
   {-# INLINE rule89 #-}
   rule89 = \ _copy ->
     _copy
   {-# INLINE rule90 #-}
   rule90 = \ _output ->
     _output
   {-# INLINE rule91 #-}
   rule91 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule92 #-}
   rule92 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule93 #-}
   rule93 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule94 #-}
   rule94 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Product #-}
sem_Pattern_Product :: (Pos) -> T_Patterns  -> T_Pattern
sem_Pattern_Product arg_pos_ arg_pats_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patsX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_pats_))
         (T_Patterns_vOut22 _patsIcopy _patsIerrors _patsIinstVars _patsIlocVars _patsIoutput) = inv_Patterns_s23 _patsX23 (T_Patterns_vIn22 _patsOcon _patsOinh _patsOnt _patsOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule95 _patsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule96 _patsIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule97 _patsIlocVars
         _copy = rule98 _patsIcopy arg_pos_
         _output = rule99 _patsIoutput arg_pos_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule100 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule101 _output
         _patsOcon = rule102 _lhsIcon
         _patsOinh = rule103 _lhsIinh
         _patsOnt = rule104 _lhsInt
         _patsOsyn = rule105 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule95 #-}
   rule95 = \ ((_patsIerrors) :: Seq Error) ->
     _patsIerrors
   {-# INLINE rule96 #-}
   rule96 = \ ((_patsIinstVars) :: [Identifier]) ->
     _patsIinstVars
   {-# INLINE rule97 #-}
   rule97 = \ ((_patsIlocVars) :: [Identifier]) ->
     _patsIlocVars
   {-# INLINE rule98 #-}
   rule98 = \ ((_patsIcopy) :: Patterns) pos_ ->
     Product pos_ _patsIcopy
   {-# INLINE rule99 #-}
   rule99 = \ ((_patsIoutput) :: Patterns) pos_ ->
     Product pos_ _patsIoutput
   {-# INLINE rule100 #-}
   rule100 = \ _copy ->
     _copy
   {-# INLINE rule101 #-}
   rule101 = \ _output ->
     _output
   {-# INLINE rule102 #-}
   rule102 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule103 #-}
   rule103 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule104 #-}
   rule104 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule105 #-}
   rule105 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Alias #-}
sem_Pattern_Alias :: (Identifier) -> (Identifier) -> T_Pattern  -> T_Pattern
sem_Pattern_Alias arg_field_ arg_attr_ arg_pat_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pat_))
         (T_Pattern_vOut19 _patIcopy _patIerrors _patIinstVars _patIlocVars _patIoutput) = inv_Pattern_s20 _patX20 (T_Pattern_vIn19 _patOcon _patOinh _patOnt _patOsyn)
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule106 arg_attr_ arg_field_
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule107 arg_attr_ arg_field_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule108 _patIerrors
         _copy = rule109 _patIcopy arg_attr_ arg_field_
         _output = rule110 _patIoutput arg_attr_ arg_field_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule111 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule112 _output
         _patOcon = rule113 _lhsIcon
         _patOinh = rule114 _lhsIinh
         _patOnt = rule115 _lhsInt
         _patOsyn = rule116 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule106 #-}
   {-# LINE 95 "src-ag/ResolveLocals.ag" #-}
   rule106 = \ attr_ field_ ->
                               {-# LINE 95 "src-ag/ResolveLocals.ag" #-}
                               if field_ == _LOC
                                  then [attr_]
                                  else []
                               {-# LINE 957 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule107 #-}
   {-# LINE 98 "src-ag/ResolveLocals.ag" #-}
   rule107 = \ attr_ field_ ->
                               {-# LINE 98 "src-ag/ResolveLocals.ag" #-}
                               if field_ == _INST
                                  then [attr_]
                                  else []
                               {-# LINE 965 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule108 #-}
   rule108 = \ ((_patIerrors) :: Seq Error) ->
     _patIerrors
   {-# INLINE rule109 #-}
   rule109 = \ ((_patIcopy) :: Pattern) attr_ field_ ->
     Alias field_ attr_ _patIcopy
   {-# INLINE rule110 #-}
   rule110 = \ ((_patIoutput) :: Pattern) attr_ field_ ->
     Alias field_ attr_ _patIoutput
   {-# INLINE rule111 #-}
   rule111 = \ _copy ->
     _copy
   {-# INLINE rule112 #-}
   rule112 = \ _output ->
     _output
   {-# INLINE rule113 #-}
   rule113 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule114 #-}
   rule114 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule115 #-}
   rule115 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule116 #-}
   rule116 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Irrefutable #-}
sem_Pattern_Irrefutable :: T_Pattern  -> T_Pattern
sem_Pattern_Irrefutable arg_pat_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pat_))
         (T_Pattern_vOut19 _patIcopy _patIerrors _patIinstVars _patIlocVars _patIoutput) = inv_Pattern_s20 _patX20 (T_Pattern_vIn19 _patOcon _patOinh _patOnt _patOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule117 _patIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule118 _patIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule119 _patIlocVars
         _copy = rule120 _patIcopy
         _output = rule121 _patIoutput
         _lhsOcopy :: Pattern
         _lhsOcopy = rule122 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule123 _output
         _patOcon = rule124 _lhsIcon
         _patOinh = rule125 _lhsIinh
         _patOnt = rule126 _lhsInt
         _patOsyn = rule127 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule117 #-}
   rule117 = \ ((_patIerrors) :: Seq Error) ->
     _patIerrors
   {-# INLINE rule118 #-}
   rule118 = \ ((_patIinstVars) :: [Identifier]) ->
     _patIinstVars
   {-# INLINE rule119 #-}
   rule119 = \ ((_patIlocVars) :: [Identifier]) ->
     _patIlocVars
   {-# INLINE rule120 #-}
   rule120 = \ ((_patIcopy) :: Pattern) ->
     Irrefutable _patIcopy
   {-# INLINE rule121 #-}
   rule121 = \ ((_patIoutput) :: Pattern) ->
     Irrefutable _patIoutput
   {-# INLINE rule122 #-}
   rule122 = \ _copy ->
     _copy
   {-# INLINE rule123 #-}
   rule123 = \ _output ->
     _output
   {-# INLINE rule124 #-}
   rule124 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule125 #-}
   rule125 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule126 #-}
   rule126 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule127 #-}
   rule127 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Underscore #-}
sem_Pattern_Underscore :: (Pos) -> T_Pattern
sem_Pattern_Underscore arg_pos_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule128  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule129  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule130  ()
         _copy = rule131 arg_pos_
         _output = rule132 arg_pos_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule133 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule134 _output
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule128 #-}
   rule128 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule129 #-}
   rule129 = \  (_ :: ()) ->
     []
   {-# INLINE rule130 #-}
   rule130 = \  (_ :: ()) ->
     []
   {-# INLINE rule131 #-}
   rule131 = \ pos_ ->
     Underscore pos_
   {-# INLINE rule132 #-}
   rule132 = \ pos_ ->
     Underscore pos_
   {-# INLINE rule133 #-}
   rule133 = \ _copy ->
     _copy
   {-# INLINE rule134 #-}
   rule134 = \ _output ->
     _output

-- Patterns ----------------------------------------------------
-- wrapper
data Inh_Patterns  = Inh_Patterns { con_Inh_Patterns :: (Identifier), inh_Inh_Patterns :: (Attributes), nt_Inh_Patterns :: (Identifier), syn_Inh_Patterns :: (Attributes) }
data Syn_Patterns  = Syn_Patterns { copy_Syn_Patterns :: (Patterns), errors_Syn_Patterns :: (Seq Error), instVars_Syn_Patterns :: ([Identifier]), locVars_Syn_Patterns :: ([Identifier]), output_Syn_Patterns :: (Patterns) }
{-# INLINABLE wrap_Patterns #-}
wrap_Patterns :: T_Patterns  -> Inh_Patterns  -> (Syn_Patterns )
wrap_Patterns (T_Patterns act) (Inh_Patterns _lhsIcon _lhsIinh _lhsInt _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg22 = T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn
        (T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Patterns_s23 sem arg22)
        return (Syn_Patterns _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Patterns #-}
sem_Patterns :: Patterns  -> T_Patterns
sem_Patterns list = Prelude.foldr sem_Patterns_Cons sem_Patterns_Nil (Prelude.map sem_Pattern list)

-- semantic domain
newtype T_Patterns  = T_Patterns {
                                 attach_T_Patterns :: Identity (T_Patterns_s23 )
                                 }
newtype T_Patterns_s23  = C_Patterns_s23 {
                                         inv_Patterns_s23 :: (T_Patterns_v22 )
                                         }
data T_Patterns_s24  = C_Patterns_s24
type T_Patterns_v22  = (T_Patterns_vIn22 ) -> (T_Patterns_vOut22 )
data T_Patterns_vIn22  = T_Patterns_vIn22 (Identifier) (Attributes) (Identifier) (Attributes)
data T_Patterns_vOut22  = T_Patterns_vOut22 (Patterns) (Seq Error) ([Identifier]) ([Identifier]) (Patterns)
{-# NOINLINE sem_Patterns_Cons #-}
sem_Patterns_Cons :: T_Pattern  -> T_Patterns  -> T_Patterns
sem_Patterns_Cons arg_hd_ arg_tl_ = T_Patterns (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_Patterns_v22
      v22 = \ (T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _hdX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_hd_))
         _tlX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_tl_))
         (T_Pattern_vOut19 _hdIcopy _hdIerrors _hdIinstVars _hdIlocVars _hdIoutput) = inv_Pattern_s20 _hdX20 (T_Pattern_vIn19 _hdOcon _hdOinh _hdOnt _hdOsyn)
         (T_Patterns_vOut22 _tlIcopy _tlIerrors _tlIinstVars _tlIlocVars _tlIoutput) = inv_Patterns_s23 _tlX23 (T_Patterns_vIn22 _tlOcon _tlOinh _tlOnt _tlOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule135 _hdIerrors _tlIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule136 _hdIinstVars _tlIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule137 _hdIlocVars _tlIlocVars
         _copy = rule138 _hdIcopy _tlIcopy
         _output = rule139 _hdIoutput _tlIoutput
         _lhsOcopy :: Patterns
         _lhsOcopy = rule140 _copy
         _lhsOoutput :: Patterns
         _lhsOoutput = rule141 _output
         _hdOcon = rule142 _lhsIcon
         _hdOinh = rule143 _lhsIinh
         _hdOnt = rule144 _lhsInt
         _hdOsyn = rule145 _lhsIsyn
         _tlOcon = rule146 _lhsIcon
         _tlOinh = rule147 _lhsIinh
         _tlOnt = rule148 _lhsInt
         _tlOsyn = rule149 _lhsIsyn
         __result_ = T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Patterns_s23 v22
   {-# INLINE rule135 #-}
   rule135 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule136 #-}
   rule136 = \ ((_hdIinstVars) :: [Identifier]) ((_tlIinstVars) :: [Identifier]) ->
     _hdIinstVars ++ _tlIinstVars
   {-# INLINE rule137 #-}
   rule137 = \ ((_hdIlocVars) :: [Identifier]) ((_tlIlocVars) :: [Identifier]) ->
     _hdIlocVars ++ _tlIlocVars
   {-# INLINE rule138 #-}
   rule138 = \ ((_hdIcopy) :: Pattern) ((_tlIcopy) :: Patterns) ->
     (:) _hdIcopy _tlIcopy
   {-# INLINE rule139 #-}
   rule139 = \ ((_hdIoutput) :: Pattern) ((_tlIoutput) :: Patterns) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule140 #-}
   rule140 = \ _copy ->
     _copy
   {-# INLINE rule141 #-}
   rule141 = \ _output ->
     _output
   {-# INLINE rule142 #-}
   rule142 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule143 #-}
   rule143 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule144 #-}
   rule144 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule145 #-}
   rule145 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule146 #-}
   rule146 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule147 #-}
   rule147 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule148 #-}
   rule148 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule149 #-}
   rule149 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Patterns_Nil #-}
sem_Patterns_Nil ::  T_Patterns
sem_Patterns_Nil  = T_Patterns (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_Patterns_v22
      v22 = \ (T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule150  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule151  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule152  ()
         _copy = rule153  ()
         _output = rule154  ()
         _lhsOcopy :: Patterns
         _lhsOcopy = rule155 _copy
         _lhsOoutput :: Patterns
         _lhsOoutput = rule156 _output
         __result_ = T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Patterns_s23 v22
   {-# INLINE rule150 #-}
   rule150 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule151 #-}
   rule151 = \  (_ :: ()) ->
     []
   {-# INLINE rule152 #-}
   rule152 = \  (_ :: ()) ->
     []
   {-# INLINE rule153 #-}
   rule153 = \  (_ :: ()) ->
     []
   {-# INLINE rule154 #-}
   rule154 = \  (_ :: ()) ->
     []
   {-# INLINE rule155 #-}
   rule155 = \ _copy ->
     _copy
   {-# INLINE rule156 #-}
   rule156 = \ _output ->
     _output

-- Production --------------------------------------------------
-- wrapper
data Inh_Production  = Inh_Production { allnts_Inh_Production :: ([Identifier]), inh_Inh_Production :: (Attributes), inhMap_Inh_Production :: (Map Identifier Attributes), mergeMap_Inh_Production :: (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))), nt_Inh_Production :: (Identifier), options_Inh_Production :: (Options), syn_Inh_Production :: (Attributes), synMap_Inh_Production :: (Map Identifier Attributes) }
data Syn_Production  = Syn_Production { cons_Syn_Production :: ([ConstructorIdent]), errors_Syn_Production :: (Seq Error), output_Syn_Production :: (Production) }
{-# INLINABLE wrap_Production #-}
wrap_Production :: T_Production  -> Inh_Production  -> (Syn_Production )
wrap_Production (T_Production act) (Inh_Production _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg25 = T_Production_vIn25 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap
        (T_Production_vOut25 _lhsOcons _lhsOerrors _lhsOoutput) <- return (inv_Production_s26 sem arg25)
        return (Syn_Production _lhsOcons _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Production #-}
sem_Production :: Production  -> T_Production
sem_Production ( Production con_ params_ constraints_ children_ rules_ typeSigs_ macro_ ) = sem_Production_Production con_ params_ constraints_ ( sem_Children children_ ) ( sem_Rules rules_ ) ( sem_TypeSigs typeSigs_ ) macro_

-- semantic domain
newtype T_Production  = T_Production {
                                     attach_T_Production :: Identity (T_Production_s26 )
                                     }
newtype T_Production_s26  = C_Production_s26 {
                                             inv_Production_s26 :: (T_Production_v25 )
                                             }
data T_Production_s27  = C_Production_s27
type T_Production_v25  = (T_Production_vIn25 ) -> (T_Production_vOut25 )
data T_Production_vIn25  = T_Production_vIn25 ([Identifier]) (Attributes) (Map Identifier Attributes) (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) (Identifier) (Options) (Attributes) (Map Identifier Attributes)
data T_Production_vOut25  = T_Production_vOut25 ([ConstructorIdent]) (Seq Error) (Production)
{-# NOINLINE sem_Production_Production #-}
sem_Production_Production :: (ConstructorIdent) -> ([Identifier]) -> ([Type]) -> T_Children  -> T_Rules  -> T_TypeSigs  -> (MaybeMacro) -> T_Production
sem_Production_Production arg_con_ arg_params_ arg_constraints_ arg_children_ arg_rules_ arg_typeSigs_ arg_macro_ = T_Production (return st26) where
   {-# NOINLINE st26 #-}
   st26 = let
      v25 :: T_Production_v25
      v25 = \ (T_Production_vIn25 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _childrenX5 = Control.Monad.Identity.runIdentity (attach_T_Children (arg_children_))
         _rulesX35 = Control.Monad.Identity.runIdentity (attach_T_Rules (arg_rules_))
         _typeSigsX41 = Control.Monad.Identity.runIdentity (attach_T_TypeSigs (arg_typeSigs_))
         (T_Children_vOut4 _childrenIattributes _childrenIfields _childrenIoutput) = inv_Children_s5 _childrenX5 (T_Children_vIn4 _childrenOallfields _childrenOallnts _childrenOattrs _childrenOcon _childrenOinh _childrenOinhMap _childrenOmergeMap _childrenOnt _childrenOsyn _childrenOsynMap)
         (T_Rules_vOut34 _rulesIerrors _rulesIinstVars _rulesIlocVars _rulesIoutput) = inv_Rules_s35 _rulesX35 (T_Rules_vIn34 _rulesOallfields _rulesOallnts _rulesOattrs _rulesOcon _rulesOinh _rulesOmergeMap _rulesOnt _rulesOoptions _rulesOsyn)
         (T_TypeSigs_vOut40 _typeSigsIoutput) = inv_TypeSigs_s41 _typeSigsX41 (T_TypeSigs_vIn40 )
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule157 arg_con_
         _allfields = rule158 _childrenIfields
         _attrs = rule159 _childrenIattributes _inhnames _rulesIinstVars _rulesIlocVars
         _inhnames = rule160 _lhsIinh
         _synnames = rule161 _lhsIsyn
         _childrenOcon = rule162 arg_con_
         _rulesOcon = rule163 arg_con_
         _mergeMap = rule164 _lhsImergeMap arg_con_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule165 _rulesIerrors
         _output = rule166 _childrenIoutput _rulesIoutput _typeSigsIoutput arg_con_ arg_constraints_ arg_macro_ arg_params_
         _lhsOoutput :: Production
         _lhsOoutput = rule167 _output
         _childrenOallfields = rule168 _allfields
         _childrenOallnts = rule169 _lhsIallnts
         _childrenOattrs = rule170 _attrs
         _childrenOinh = rule171 _lhsIinh
         _childrenOinhMap = rule172 _lhsIinhMap
         _childrenOmergeMap = rule173 _mergeMap
         _childrenOnt = rule174 _lhsInt
         _childrenOsyn = rule175 _lhsIsyn
         _childrenOsynMap = rule176 _lhsIsynMap
         _rulesOallfields = rule177 _allfields
         _rulesOallnts = rule178 _lhsIallnts
         _rulesOattrs = rule179 _attrs
         _rulesOinh = rule180 _lhsIinh
         _rulesOmergeMap = rule181 _mergeMap
         _rulesOnt = rule182 _lhsInt
         _rulesOoptions = rule183 _lhsIoptions
         _rulesOsyn = rule184 _lhsIsyn
         __result_ = T_Production_vOut25 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Production_s26 v25
   {-# INLINE rule157 #-}
   {-# LINE 66 "src-ag/ResolveLocals.ag" #-}
   rule157 = \ con_ ->
                              {-# LINE 66 "src-ag/ResolveLocals.ag" #-}
                              [con_]
                              {-# LINE 1333 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule158 #-}
   {-# LINE 73 "src-ag/ResolveLocals.ag" #-}
   rule158 = \ ((_childrenIfields) :: [(Identifier,Type,ChildKind)]) ->
                                  {-# LINE 73 "src-ag/ResolveLocals.ag" #-}
                                  _childrenIfields
                                  {-# LINE 1339 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule159 #-}
   {-# LINE 74 "src-ag/ResolveLocals.ag" #-}
   rule159 = \ ((_childrenIattributes) :: [(Identifier,Attributes,Attributes)]) _inhnames ((_rulesIinstVars) :: [Identifier]) ((_rulesIlocVars) :: [Identifier]) ->
                                   {-# LINE 74 "src-ag/ResolveLocals.ag" #-}
                                   map ((,) _LOC)  _rulesIlocVars ++
                                   map ((,) _INST) _rulesIinstVars ++
                                   map ((,) _LHS)  _inhnames ++
                                   concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- _childrenIattributes]
                                   {-# LINE 1348 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule160 #-}
   {-# LINE 78 "src-ag/ResolveLocals.ag" #-}
   rule160 = \ ((_lhsIinh) :: Attributes) ->
                                   {-# LINE 78 "src-ag/ResolveLocals.ag" #-}
                                   Map.keys _lhsIinh
                                   {-# LINE 1354 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule161 #-}
   {-# LINE 79 "src-ag/ResolveLocals.ag" #-}
   rule161 = \ ((_lhsIsyn) :: Attributes) ->
                                   {-# LINE 79 "src-ag/ResolveLocals.ag" #-}
                                   Map.keys _lhsIsyn
                                   {-# LINE 1360 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule162 #-}
   {-# LINE 107 "src-ag/ResolveLocals.ag" #-}
   rule162 = \ con_ ->
                                  {-# LINE 107 "src-ag/ResolveLocals.ag" #-}
                                  con_
                                  {-# LINE 1366 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule163 #-}
   {-# LINE 109 "src-ag/ResolveLocals.ag" #-}
   rule163 = \ con_ ->
                               {-# LINE 109 "src-ag/ResolveLocals.ag" #-}
                               con_
                               {-# LINE 1372 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule164 #-}
   {-# LINE 128 "src-ag/ResolveLocals.ag" #-}
   rule164 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) con_ ->
                                                {-# LINE 128 "src-ag/ResolveLocals.ag" #-}
                                                Map.findWithDefault Map.empty con_ _lhsImergeMap
                                                {-# LINE 1378 "dist/build/ResolveLocals.hs"#-}
   {-# INLINE rule165 #-}
   rule165 = \ ((_rulesIerrors) :: Seq Error) ->
     _rulesIerrors
   {-# INLINE rule166 #-}
   rule166 = \ ((_childrenIoutput) :: Children) ((_rulesIoutput) :: Rules) ((_typeSigsIoutput) :: TypeSigs) con_ constraints_ macro_ params_ ->
     Production con_ params_ constraints_ _childrenIoutput _rulesIoutput _typeSigsIoutput macro_
   {-# INLINE rule167 #-}
   rule167 = \ _output ->
     _output
   {-# INLINE rule168 #-}
   rule168 = \ _allfields ->
     _allfields
   {-# INLINE rule169 #-}
   rule169 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule170 #-}
   rule170 = \ _attrs ->
     _attrs
   {-# INLINE rule171 #-}
   rule171 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule172 #-}
   rule172 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule173 #-}
   rule173 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule174 #-}
   rule174 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule175 #-}
   rule175 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule176 #-}
   rule176 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule177 #-}
   rule177 = \ _allfields ->
     _allfields
   {-# INLINE rule178 #-}
   rule178 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule179 #-}
   rule179 = \ _attrs ->
     _attrs
   {-# INLINE rule180 #-}
   rule180 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule181 #-}
   rule181 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule182 #-}
   rule182 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule183 #-}
   rule183 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule184 #-}
   rule184 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn

-- Productions -------------------------------------------------
-- wrapper
data Inh_Productions  = Inh_Productions { allnts_Inh_Productions :: ([Identifier]), inh_Inh_Productions :: (Attributes), inhMap_Inh_Productions :: (Map Identifier Attributes), mergeMap_Inh_Productions :: (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))), nt_Inh_Productions :: (Identifier), options_Inh_Productions :: (Options), syn_Inh_Productions :: (Attributes), synMap_Inh_Productions :: (Map Identifier Attributes) }
data Syn_Productions  = Syn_Productions { cons_Syn_Productions :: ([ConstructorIdent]), errors_Syn_Productions :: (Seq Error), output_Syn_Productions :: (Productions) }
{-# INLINABLE wrap_Productions #-}
wrap_Productions :: T_Productions  -> Inh_Productions  -> (Syn_Productions )
wrap_Productions (T_Productions act) (Inh_Productions _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg28 = T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap
        (T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput) <- return (inv_Productions_s29 sem arg28)
        return (Syn_Productions _lhsOcons _lhsOerrors _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Productions #-}
sem_Productions :: Productions  -> T_Productions
sem_Productions list = Prelude.foldr sem_Productions_Cons sem_Productions_Nil (Prelude.map sem_Production list)

-- semantic domain
newtype T_Productions  = T_Productions {
                                       attach_T_Productions :: Identity (T_Productions_s29 )
                                       }
newtype T_Productions_s29  = C_Productions_s29 {
                                               inv_Productions_s29 :: (T_Productions_v28 )
                                               }
data T_Productions_s30  = C_Productions_s30
type T_Productions_v28  = (T_Productions_vIn28 ) -> (T_Productions_vOut28 )
data T_Productions_vIn28  = T_Productions_vIn28 ([Identifier]) (Attributes) (Map Identifier Attributes) (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) (Identifier) (Options) (Attributes) (Map Identifier Attributes)
data T_Productions_vOut28  = T_Productions_vOut28 ([ConstructorIdent]) (Seq Error) (Productions)
{-# NOINLINE sem_Productions_Cons #-}
sem_Productions_Cons :: T_Production  -> T_Productions  -> T_Productions
sem_Productions_Cons arg_hd_ arg_tl_ = T_Productions (return st29) where
   {-# NOINLINE st29 #-}
   st29 = let
      v28 :: T_Productions_v28
      v28 = \ (T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _hdX26 = Control.Monad.Identity.runIdentity (attach_T_Production (arg_hd_))
         _tlX29 = Control.Monad.Identity.runIdentity (attach_T_Productions (arg_tl_))
         (T_Production_vOut25 _hdIcons _hdIerrors _hdIoutput) = inv_Production_s26 _hdX26 (T_Production_vIn25 _hdOallnts _hdOinh _hdOinhMap _hdOmergeMap _hdOnt _hdOoptions _hdOsyn _hdOsynMap)
         (T_Productions_vOut28 _tlIcons _tlIerrors _tlIoutput) = inv_Productions_s29 _tlX29 (T_Productions_vIn28 _tlOallnts _tlOinh _tlOinhMap _tlOmergeMap _tlOnt _tlOoptions _tlOsyn _tlOsynMap)
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule185 _hdIcons _tlIcons
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule186 _hdIerrors _tlIerrors
         _output = rule187 _hdIoutput _tlIoutput
         _lhsOoutput :: Productions
         _lhsOoutput = rule188 _output
         _hdOallnts = rule189 _lhsIallnts
         _hdOinh = rule190 _lhsIinh
         _hdOinhMap = rule191 _lhsIinhMap
         _hdOmergeMap = rule192 _lhsImergeMap
         _hdOnt = rule193 _lhsInt
         _hdOoptions = rule194 _lhsIoptions
         _hdOsyn = rule195 _lhsIsyn
         _hdOsynMap = rule196 _lhsIsynMap
         _tlOallnts = rule197 _lhsIallnts
         _tlOinh = rule198 _lhsIinh
         _tlOinhMap = rule199 _lhsIinhMap
         _tlOmergeMap = rule200 _lhsImergeMap
         _tlOnt = rule201 _lhsInt
         _tlOoptions = rule202 _lhsIoptions
         _tlOsyn = rule203 _lhsIsyn
         _tlOsynMap = rule204 _lhsIsynMap
         __result_ = T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Productions_s29 v28
   {-# INLINE rule185 #-}
   rule185 = \ ((_hdIcons) :: [ConstructorIdent]) ((_tlIcons) :: [ConstructorIdent]) ->
     _hdIcons ++ _tlIcons
   {-# INLINE rule186 #-}
   rule186 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule187 #-}
   rule187 = \ ((_hdIoutput) :: Production) ((_tlIoutput) :: Productions) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule188 #-}
   rule188 = \ _output ->
     _output
   {-# INLINE rule189 #-}
   rule189 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule190 #-}
   rule190 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule191 #-}
   rule191 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule192 #-}
   rule192 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) ->
     _lhsImergeMap
   {-# INLINE rule193 #-}
   rule193 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule194 #-}
   rule194 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule195 #-}
   rule195 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule196 #-}
   rule196 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule197 #-}
   rule197 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule198 #-}
   rule198 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule199 #-}
   rule199 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule200 #-}
   rule200 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) ->
     _lhsImergeMap
   {-# INLINE rule201 #-}
   rule201 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule202 #-}
   rule202 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule203 #-}
   rule203 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule204 #-}
   rule204 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
{-# NOINLINE sem_Productions_Nil #-}
sem_Productions_Nil ::  T_Productions
sem_Productions_Nil  = T_Productions (return st29) where
   {-# NOINLINE st29 #-}
   st29 = let
      v28 :: T_Productions_v28
      v28 = \ (T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule205  ()
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule206  ()
         _output = rule207  ()
         _lhsOoutput :: Productions
         _lhsOoutput = rule208 _output
         __result_ = T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Productions_s29 v28
   {-# INLINE rule205 #-}
   rule205 = \  (_ :: ()) ->
     []
   {-# INLINE rule206 #-}
   rule206 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule207 #-}
   rule207 = \  (_ :: ()) ->
     []
   {-# INLINE rule208 #-}
   rule208 = \ _output ->
     _output

-- Rule --------------------------------------------------------
-- wrapper
data Inh_Rule  = Inh_Rule { allfields_Inh_Rule :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Rule :: ([Identifier]), attrs_Inh_Rule :: ([(Identifier,Identifier)]), con_Inh_Rule :: (Identifier), inh_Inh_Rule :: (Attributes), mergeMap_Inh_Rule :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Rule :: (Identifier), options_Inh_Rule :: (Options), syn_Inh_Rule :: (Attributes) }
data Syn_Rule  = Syn_Rule { errors_Syn_Rule :: (Seq Error), instVars_Syn_Rule :: ([Identifier]), locVars_Syn_Rule :: ([Identifier]), output_Syn_Rule :: (Rule) }
{-# INLINABLE wrap_Rule #-}
wrap_Rule :: T_Rule  -> Inh_Rule  -> (Syn_Rule )
wrap_Rule (T_Rule act) (Inh_Rule _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg31 = T_Rule_vIn31 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn
        (T_Rule_vOut31 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Rule_s32 sem arg31)
        return (Syn_Rule _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# INLINE sem_Rule #-}
sem_Rule :: Rule  -> T_Rule
sem_Rule ( Rule mbName_ pattern_ rhs_ owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_ ) = sem_Rule_Rule mbName_ ( sem_Pattern pattern_ ) ( sem_Expression rhs_ ) owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_

-- semantic domain
newtype T_Rule  = T_Rule {
                         attach_T_Rule :: Identity (T_Rule_s32 )
                         }
newtype T_Rule_s32  = C_Rule_s32 {
                                 inv_Rule_s32 :: (T_Rule_v31 )
                                 }
data T_Rule_s33  = C_Rule_s33
type T_Rule_v31  = (T_Rule_vIn31 ) -> (T_Rule_vOut31 )
data T_Rule_vIn31  = T_Rule_vIn31 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options) (Attributes)
data T_Rule_vOut31  = T_Rule_vOut31 (Seq Error) ([Identifier]) ([Identifier]) (Rule)
{-# NOINLINE sem_Rule_Rule #-}
sem_Rule_Rule :: (Maybe Identifier) -> T_Pattern  -> T_Expression  -> (Bool) -> (String) -> (Bool) -> (Bool) -> (Bool) -> (Maybe Error) -> (Bool) -> T_Rule
sem_Rule_Rule arg_mbName_ arg_pattern_ arg_rhs_ arg_owrt_ arg_origin_ arg_explicit_ arg_pure_ arg_identity_ arg_mbError_ arg_eager_ = T_Rule (return st32) where
   {-# NOINLINE st32 #-}
   st32 = let
      v31 :: T_Rule_v31
      v31 = \ (T_Rule_vIn31 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _patternX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _rhsX8 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_rhs_))
         (T_Pattern_vOut19 _patternIcopy _patternIerrors _patternIinstVars _patternIlocVars _patternIoutput) = inv_Pattern_s20 _patternX20 (T_Pattern_vIn19 _patternOcon _patternOinh _patternOnt _patternOsyn)
         (T_Expression_vOut7 _rhsIerrors _rhsIoutput) = inv_Expression_s8 _rhsX8 (T_Expression_vIn7 _rhsOallfields _rhsOallnts _rhsOattrs _rhsOcon _rhsOmergeMap _rhsOnt _rhsOoptions)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule209 _patternIerrors _rhsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule210 _patternIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule211 _patternIlocVars
         _output = rule212 _patternIoutput _rhsIoutput arg_eager_ arg_explicit_ arg_identity_ arg_mbError_ arg_mbName_ arg_origin_ arg_owrt_ arg_pure_
         _lhsOoutput :: Rule
         _lhsOoutput = rule213 _output
         _patternOcon = rule214 _lhsIcon
         _patternOinh = rule215 _lhsIinh
         _patternOnt = rule216 _lhsInt
         _patternOsyn = rule217 _lhsIsyn
         _rhsOallfields = rule218 _lhsIallfields
         _rhsOallnts = rule219 _lhsIallnts
         _rhsOattrs = rule220 _lhsIattrs
         _rhsOcon = rule221 _lhsIcon
         _rhsOmergeMap = rule222 _lhsImergeMap
         _rhsOnt = rule223 _lhsInt
         _rhsOoptions = rule224 _lhsIoptions
         __result_ = T_Rule_vOut31 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rule_s32 v31
   {-# INLINE rule209 #-}
   rule209 = \ ((_patternIerrors) :: Seq Error) ((_rhsIerrors) :: Seq Error) ->
     _patternIerrors Seq.>< _rhsIerrors
   {-# INLINE rule210 #-}
   rule210 = \ ((_patternIinstVars) :: [Identifier]) ->
     _patternIinstVars
   {-# INLINE rule211 #-}
   rule211 = \ ((_patternIlocVars) :: [Identifier]) ->
     _patternIlocVars
   {-# INLINE rule212 #-}
   rule212 = \ ((_patternIoutput) :: Pattern) ((_rhsIoutput) :: Expression) eager_ explicit_ identity_ mbError_ mbName_ origin_ owrt_ pure_ ->
     Rule mbName_ _patternIoutput _rhsIoutput owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_
   {-# INLINE rule213 #-}
   rule213 = \ _output ->
     _output
   {-# INLINE rule214 #-}
   rule214 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule215 #-}
   rule215 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule216 #-}
   rule216 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule217 #-}
   rule217 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule218 #-}
   rule218 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule219 #-}
   rule219 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule220 #-}
   rule220 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule221 #-}
   rule221 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule222 #-}
   rule222 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule223 #-}
   rule223 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule224 #-}
   rule224 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions

-- Rules -------------------------------------------------------
-- wrapper
data Inh_Rules  = Inh_Rules { allfields_Inh_Rules :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Rules :: ([Identifier]), attrs_Inh_Rules :: ([(Identifier,Identifier)]), con_Inh_Rules :: (Identifier), inh_Inh_Rules :: (Attributes), mergeMap_Inh_Rules :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Rules :: (Identifier), options_Inh_Rules :: (Options), syn_Inh_Rules :: (Attributes) }
data Syn_Rules  = Syn_Rules { errors_Syn_Rules :: (Seq Error), instVars_Syn_Rules :: ([Identifier]), locVars_Syn_Rules :: ([Identifier]), output_Syn_Rules :: (Rules) }
{-# INLINABLE wrap_Rules #-}
wrap_Rules :: T_Rules  -> Inh_Rules  -> (Syn_Rules )
wrap_Rules (T_Rules act) (Inh_Rules _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg34 = T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn
        (T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Rules_s35 sem arg34)
        return (Syn_Rules _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Rules #-}
sem_Rules :: Rules  -> T_Rules
sem_Rules list = Prelude.foldr sem_Rules_Cons sem_Rules_Nil (Prelude.map sem_Rule list)

-- semantic domain
newtype T_Rules  = T_Rules {
                           attach_T_Rules :: Identity (T_Rules_s35 )
                           }
newtype T_Rules_s35  = C_Rules_s35 {
                                   inv_Rules_s35 :: (T_Rules_v34 )
                                   }
data T_Rules_s36  = C_Rules_s36
type T_Rules_v34  = (T_Rules_vIn34 ) -> (T_Rules_vOut34 )
data T_Rules_vIn34  = T_Rules_vIn34 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options) (Attributes)
data T_Rules_vOut34  = T_Rules_vOut34 (Seq Error) ([Identifier]) ([Identifier]) (Rules)
{-# NOINLINE sem_Rules_Cons #-}
sem_Rules_Cons :: T_Rule  -> T_Rules  -> T_Rules
sem_Rules_Cons arg_hd_ arg_tl_ = T_Rules (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_Rules_v34
      v34 = \ (T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _hdX32 = Control.Monad.Identity.runIdentity (attach_T_Rule (arg_hd_))
         _tlX35 = Control.Monad.Identity.runIdentity (attach_T_Rules (arg_tl_))
         (T_Rule_vOut31 _hdIerrors _hdIinstVars _hdIlocVars _hdIoutput) = inv_Rule_s32 _hdX32 (T_Rule_vIn31 _hdOallfields _hdOallnts _hdOattrs _hdOcon _hdOinh _hdOmergeMap _hdOnt _hdOoptions _hdOsyn)
         (T_Rules_vOut34 _tlIerrors _tlIinstVars _tlIlocVars _tlIoutput) = inv_Rules_s35 _tlX35 (T_Rules_vIn34 _tlOallfields _tlOallnts _tlOattrs _tlOcon _tlOinh _tlOmergeMap _tlOnt _tlOoptions _tlOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule225 _hdIerrors _tlIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule226 _hdIinstVars _tlIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule227 _hdIlocVars _tlIlocVars
         _output = rule228 _hdIoutput _tlIoutput
         _lhsOoutput :: Rules
         _lhsOoutput = rule229 _output
         _hdOallfields = rule230 _lhsIallfields
         _hdOallnts = rule231 _lhsIallnts
         _hdOattrs = rule232 _lhsIattrs
         _hdOcon = rule233 _lhsIcon
         _hdOinh = rule234 _lhsIinh
         _hdOmergeMap = rule235 _lhsImergeMap
         _hdOnt = rule236 _lhsInt
         _hdOoptions = rule237 _lhsIoptions
         _hdOsyn = rule238 _lhsIsyn
         _tlOallfields = rule239 _lhsIallfields
         _tlOallnts = rule240 _lhsIallnts
         _tlOattrs = rule241 _lhsIattrs
         _tlOcon = rule242 _lhsIcon
         _tlOinh = rule243 _lhsIinh
         _tlOmergeMap = rule244 _lhsImergeMap
         _tlOnt = rule245 _lhsInt
         _tlOoptions = rule246 _lhsIoptions
         _tlOsyn = rule247 _lhsIsyn
         __result_ = T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rules_s35 v34
   {-# INLINE rule225 #-}
   rule225 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule226 #-}
   rule226 = \ ((_hdIinstVars) :: [Identifier]) ((_tlIinstVars) :: [Identifier]) ->
     _hdIinstVars ++ _tlIinstVars
   {-# INLINE rule227 #-}
   rule227 = \ ((_hdIlocVars) :: [Identifier]) ((_tlIlocVars) :: [Identifier]) ->
     _hdIlocVars ++ _tlIlocVars
   {-# INLINE rule228 #-}
   rule228 = \ ((_hdIoutput) :: Rule) ((_tlIoutput) :: Rules) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule229 #-}
   rule229 = \ _output ->
     _output
   {-# INLINE rule230 #-}
   rule230 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule231 #-}
   rule231 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule232 #-}
   rule232 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule233 #-}
   rule233 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule234 #-}
   rule234 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule235 #-}
   rule235 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule236 #-}
   rule236 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule237 #-}
   rule237 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule238 #-}
   rule238 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule239 #-}
   rule239 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule240 #-}
   rule240 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule241 #-}
   rule241 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule242 #-}
   rule242 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule243 #-}
   rule243 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule244 #-}
   rule244 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule245 #-}
   rule245 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule246 #-}
   rule246 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule247 #-}
   rule247 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Rules_Nil #-}
sem_Rules_Nil ::  T_Rules
sem_Rules_Nil  = T_Rules (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_Rules_v34
      v34 = \ (T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule248  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule249  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule250  ()
         _output = rule251  ()
         _lhsOoutput :: Rules
         _lhsOoutput = rule252 _output
         __result_ = T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rules_s35 v34
   {-# INLINE rule248 #-}
   rule248 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule249 #-}
   rule249 = \  (_ :: ()) ->
     []
   {-# INLINE rule250 #-}
   rule250 = \  (_ :: ()) ->
     []
   {-# INLINE rule251 #-}
   rule251 = \  (_ :: ()) ->
     []
   {-# INLINE rule252 #-}
   rule252 = \ _output ->
     _output

-- TypeSig -----------------------------------------------------
-- wrapper
data Inh_TypeSig  = Inh_TypeSig {  }
data Syn_TypeSig  = Syn_TypeSig { output_Syn_TypeSig :: (TypeSig) }
{-# INLINABLE wrap_TypeSig #-}
wrap_TypeSig :: T_TypeSig  -> Inh_TypeSig  -> (Syn_TypeSig )
wrap_TypeSig (T_TypeSig act) (Inh_TypeSig ) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg37 = T_TypeSig_vIn37
        (T_TypeSig_vOut37 _lhsOoutput) <- return (inv_TypeSig_s38 sem arg37)
        return (Syn_TypeSig _lhsOoutput)
   )

-- cata
{-# INLINE sem_TypeSig #-}
sem_TypeSig :: TypeSig  -> T_TypeSig
sem_TypeSig ( TypeSig name_ tp_ ) = sem_TypeSig_TypeSig name_ tp_

-- semantic domain
newtype T_TypeSig  = T_TypeSig {
                               attach_T_TypeSig :: Identity (T_TypeSig_s38 )
                               }
newtype T_TypeSig_s38  = C_TypeSig_s38 {
                                       inv_TypeSig_s38 :: (T_TypeSig_v37 )
                                       }
data T_TypeSig_s39  = C_TypeSig_s39
type T_TypeSig_v37  = (T_TypeSig_vIn37 ) -> (T_TypeSig_vOut37 )
data T_TypeSig_vIn37  = T_TypeSig_vIn37
data T_TypeSig_vOut37  = T_TypeSig_vOut37 (TypeSig)
{-# NOINLINE sem_TypeSig_TypeSig #-}
sem_TypeSig_TypeSig :: (Identifier) -> (Type) -> T_TypeSig
sem_TypeSig_TypeSig arg_name_ arg_tp_ = T_TypeSig (return st38) where
   {-# NOINLINE st38 #-}
   st38 = let
      v37 :: T_TypeSig_v37
      v37 = \ (T_TypeSig_vIn37 ) -> ( let
         _output = rule253 arg_name_ arg_tp_
         _lhsOoutput :: TypeSig
         _lhsOoutput = rule254 _output
         __result_ = T_TypeSig_vOut37 _lhsOoutput
         in __result_ )
     in C_TypeSig_s38 v37
   {-# INLINE rule253 #-}
   rule253 = \ name_ tp_ ->
     TypeSig name_ tp_
   {-# INLINE rule254 #-}
   rule254 = \ _output ->
     _output

-- TypeSigs ----------------------------------------------------
-- wrapper
data Inh_TypeSigs  = Inh_TypeSigs {  }
data Syn_TypeSigs  = Syn_TypeSigs { output_Syn_TypeSigs :: (TypeSigs) }
{-# INLINABLE wrap_TypeSigs #-}
wrap_TypeSigs :: T_TypeSigs  -> Inh_TypeSigs  -> (Syn_TypeSigs )
wrap_TypeSigs (T_TypeSigs act) (Inh_TypeSigs ) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg40 = T_TypeSigs_vIn40
        (T_TypeSigs_vOut40 _lhsOoutput) <- return (inv_TypeSigs_s41 sem arg40)
        return (Syn_TypeSigs _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_TypeSigs #-}
sem_TypeSigs :: TypeSigs  -> T_TypeSigs
sem_TypeSigs list = Prelude.foldr sem_TypeSigs_Cons sem_TypeSigs_Nil (Prelude.map sem_TypeSig list)

-- semantic domain
newtype T_TypeSigs  = T_TypeSigs {
                                 attach_T_TypeSigs :: Identity (T_TypeSigs_s41 )
                                 }
newtype T_TypeSigs_s41  = C_TypeSigs_s41 {
                                         inv_TypeSigs_s41 :: (T_TypeSigs_v40 )
                                         }
data T_TypeSigs_s42  = C_TypeSigs_s42
type T_TypeSigs_v40  = (T_TypeSigs_vIn40 ) -> (T_TypeSigs_vOut40 )
data T_TypeSigs_vIn40  = T_TypeSigs_vIn40
data T_TypeSigs_vOut40  = T_TypeSigs_vOut40 (TypeSigs)
{-# NOINLINE sem_TypeSigs_Cons #-}
sem_TypeSigs_Cons :: T_TypeSig  -> T_TypeSigs  -> T_TypeSigs
sem_TypeSigs_Cons arg_hd_ arg_tl_ = T_TypeSigs (return st41) where
   {-# NOINLINE st41 #-}
   st41 = let
      v40 :: T_TypeSigs_v40
      v40 = \ (T_TypeSigs_vIn40 ) -> ( let
         _hdX38 = Control.Monad.Identity.runIdentity (attach_T_TypeSig (arg_hd_))
         _tlX41 = Control.Monad.Identity.runIdentity (attach_T_TypeSigs (arg_tl_))
         (T_TypeSig_vOut37 _hdIoutput) = inv_TypeSig_s38 _hdX38 (T_TypeSig_vIn37 )
         (T_TypeSigs_vOut40 _tlIoutput) = inv_TypeSigs_s41 _tlX41 (T_TypeSigs_vIn40 )
         _output = rule255 _hdIoutput _tlIoutput
         _lhsOoutput :: TypeSigs
         _lhsOoutput = rule256 _output
         __result_ = T_TypeSigs_vOut40 _lhsOoutput
         in __result_ )
     in C_TypeSigs_s41 v40
   {-# INLINE rule255 #-}
   rule255 = \ ((_hdIoutput) :: TypeSig) ((_tlIoutput) :: TypeSigs) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule256 #-}
   rule256 = \ _output ->
     _output
{-# NOINLINE sem_TypeSigs_Nil #-}
sem_TypeSigs_Nil ::  T_TypeSigs
sem_TypeSigs_Nil  = T_TypeSigs (return st41) where
   {-# NOINLINE st41 #-}
   st41 = let
      v40 :: T_TypeSigs_v40
      v40 = \ (T_TypeSigs_vIn40 ) -> ( let
         _output = rule257  ()
         _lhsOoutput :: TypeSigs
         _lhsOoutput = rule258 _output
         __result_ = T_TypeSigs_vOut40 _lhsOoutput
         in __result_ )
     in C_TypeSigs_s41 v40
   {-# INLINE rule257 #-}
   rule257 = \  (_ :: ()) ->
     []
   {-# INLINE rule258 #-}
   rule258 = \ _output ->
     _output
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Rank2Types, GADTs #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- AbstractSyntax.ag imports-- Patterns.ag imports
module ResolveLocals where UU.Scanner.Position(Pos)
import HsToken UU.Scanner.Position(Pos)
import CommonTypes (ConstructorIdent,Identifier) Data.Set(Set)
import Data.Map(Map)
import Patterns    (Pattern(..),Patterns)
import Expression  (Expression(..))
import Macro --marcos
import CommonTypes
import ErrorMessages





import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Map(Map)
import qualified Data.Sequence as Seq
import Data.Sequence(Seq,(><))
import CommonTypes
import Patterns
import ErrorMessages
import AbstractSyntax
import Expression
import Options
import HsToken(HsTokensRoot(HsTokensRoot))
import SemHsTokens(sem_HsTokensRoot,wrap_HsTokensRoot, Syn_HsTokensRoot(..),Inh_HsTokensRoot(..))
import Data.Maybe

















import Control.Monad.Identity (Identity)
import qualified Control.Monad.Identity
-- Child -------------------------------------------------------
-- wrapper
data Inh_Child  = Inh_Child { allfields_Inh_Child :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Child :: ([Identifier]), attrs_Inh_Child :: ([(Identifier,Identifier)]), con_Inh_Child :: (Identifier), inh_Inh_Child :: (Attributes), inhMap_Inh_Child :: (Map Identifier Attributes), mergeMap_Inh_Child :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Child :: (Identifier), syn_Inh_Child :: (Attributes), synMap_Inh_Child :: (Map Identifier Attributes) }
data Syn_Child  = Syn_Child { attributes_Syn_Child :: ([(Identifier,Attributes,Attributes)]), field_Syn_Child :: ((Identifier,Type,ChildKind)), output_Syn_Child :: (Child) }
{-# INLINABLE wrap_Child #-}
wrap_Child :: T_Child  -> Inh_Child  -> (Syn_Child )
wrap_Child (T_Child act) (Inh_Child _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg1 = T_Child_vIn1 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap
        (T_Child_vOut1 _lhsOattributes _lhsOfield _lhsOoutput) <- return (inv_Child_s2 sem arg1)
        return (Syn_Child _lhsOattributes _lhsOfield _lhsOoutput)
   )

-- cata
{-# INLINE sem_Child #-}
sem_Child :: Child  -> T_Child
sem_Child ( Child name_ tp_ kind_ ) = sem_Child_Child name_ tp_ kind_

-- semantic domain
newtype T_Child  = T_Child {
                           attach_T_Child :: Identity (T_Child_s2 )
                           }
newtype T_Child_s2  = C_Child_s2 {
                                 inv_Child_s2 :: (T_Child_v1 )
                                 }
data T_Child_s3  = C_Child_s3
type T_Child_v1  = (T_Child_vIn1 ) -> (T_Child_vOut1 )
data T_Child_vIn1  = T_Child_vIn1 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Attributes) (Map Identifier Attributes)
data T_Child_vOut1  = T_Child_vOut1 ([(Identifier,Attributes,Attributes)]) ((Identifier,Type,ChildKind)) (Child)
{-# NOINLINE sem_Child_Child #-}
sem_Child_Child :: (Identifier) -> (Type) -> (ChildKind) -> T_Child
sem_Child_Child arg_name_ arg_tp_ arg_kind_ = T_Child (return st2) where
   {-# NOINLINE st2 #-}
   st2 = let
      v1 :: T_Child_v1
      v1 = \ (T_Child_vIn1 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _chnt = rule0 arg_name_ arg_tp_
         _inh = rule1 _chnt _lhsIinhMap
         _syn = rule2 _chnt _lhsIsynMap
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule3 _inh _syn arg_name_
         _lhsOfield :: (Identifier,Type,ChildKind)
         _lhsOfield = rule4 arg_kind_ arg_name_ arg_tp_
         _output = rule5 arg_kind_ arg_name_ arg_tp_
         _lhsOoutput :: Child
         _lhsOoutput = rule6 _output
         __result_ = T_Child_vOut1 _lhsOattributes _lhsOfield _lhsOoutput
         in __result_ )
     in C_Child_s2 v1
   {-# INLINE rule0 #-}








   {-# INLINE rule1 #-}





   {-# INLINE rule2 #-}





   {-# INLINE rule3 #-}





   {-# INLINE rule4 #-}





   {-# INLINE rule5 #-}
   rule5 = \ kind_ name_ tp_ ->
     Child name_ tp_ kind_
   {-# INLINE rule6 #-}
   rule6 = \ _output ->
     _output = \ name_ tp_ -> tp_ of
                             NT nt _ _ -> nt
                             Self      -> error ("The type of child " ++ show name_ ++ " should not be a Self type.")
                             Haskell t -> identifier ""
   rule1 = \ _chnt ((_lhsIinhMap) :: Map Identifier Attributes) -> Map.empty _chnt     _lhsIinhMap
   rule2 = \ _chnt ((_lhsIsynMap) :: Map Identifier Attributes) -> Map.empty _chnt     _lhsIsynMap


























































   rule3 = \ _inh _syn name_ ->(name_, _inh    , _syn    )]


   rule4 = \ kind_ name_ tp_ ->name_, tp_, kind_)




















































-- Children ----------------------------------------------------
-- wrapper
data Inh_Children  = Inh_Children { allfields_Inh_Children :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Children :: ([Identifier]), attrs_Inh_Children :: ([(Identifier,Identifier)]), con_Inh_Children :: (Identifier), inh_Inh_Children :: (Attributes), inhMap_Inh_Children :: (Map Identifier Attributes), mergeMap_Inh_Children :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Children :: (Identifier), syn_Inh_Children :: (Attributes), synMap_Inh_Children :: (Map Identifier Attributes) }
data Syn_Children  = Syn_Children { attributes_Syn_Children :: ([(Identifier,Attributes,Attributes)]), fields_Syn_Children :: ([(Identifier,Type,ChildKind)]), output_Syn_Children :: (Children) }
{-# INLINABLE wrap_Children #-}
wrap_Children :: T_Children  -> Inh_Children  -> (Syn_Children )
wrap_Children (T_Children act) (Inh_Children _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg4 = T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap
        (T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput) <- return (inv_Children_s5 sem arg4)
        return (Syn_Children _lhsOattributes _lhsOfields _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Children #-}
sem_Children :: Children  -> T_Children
sem_Children list = Prelude.foldr sem_Children_Cons sem_Children_Nil (Prelude.map sem_Child list)

-- semantic domain
newtype T_Children  = T_Children {
                                 attach_T_Children :: Identity (T_Children_s5 )
                                 }
newtype T_Children_s5  = C_Children_s5 {
                                       inv_Children_s5 :: (T_Children_v4 )
                                       }
data T_Children_s6  = C_Children_s6
type T_Children_v4  = (T_Children_vIn4 ) -> (T_Children_vOut4 )
data T_Children_vIn4  = T_Children_vIn4 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Attributes) (Map Identifier Attributes)
data T_Children_vOut4  = T_Children_vOut4 ([(Identifier,Attributes,Attributes)]) ([(Identifier,Type,ChildKind)]) (Children)
{-# NOINLINE sem_Children_Cons #-}
sem_Children_Cons :: T_Child  -> T_Children  -> T_Children
sem_Children_Cons arg_hd_ arg_tl_ = T_Children (return st5) where
   {-# NOINLINE st5 #-}
   st5 = let
      v4 :: T_Children_v4
      v4 = \ (T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _hdX2 = Control.Monad.Identity.runIdentity (attach_T_Child (arg_hd_))
         _tlX5 = Control.Monad.Identity.runIdentity (attach_T_Children (arg_tl_))
         (T_Child_vOut1 _hdIattributes _hdIfield _hdIoutput) = inv_Child_s2 _hdX2 (T_Child_vIn1 _hdOallfields _hdOallnts _hdOattrs _hdOcon _hdOinh _hdOinhMap _hdOmergeMap _hdOnt _hdOsyn _hdOsynMap)
         (T_Children_vOut4 _tlIattributes _tlIfields _tlIoutput) = inv_Children_s5 _tlX5 (T_Children_vIn4 _tlOallfields _tlOallnts _tlOattrs _tlOcon _tlOinh _tlOinhMap _tlOmergeMap _tlOnt _tlOsyn _tlOsynMap)
         _lhsOfields :: [(Identifier,Type,ChildKind)]
         _lhsOfields = rule7 _hdIfield _tlIfields
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule8 _hdIattributes _tlIattributes
         _output = rule9 _hdIoutput _tlIoutput
         _lhsOoutput :: Children
         _lhsOoutput = rule10 _output
         _hdOallfields = rule11 _lhsIallfields
         _hdOallnts = rule12 _lhsIallnts
         _hdOattrs = rule13 _lhsIattrs
         _hdOcon = rule14 _lhsIcon
         _hdOinh = rule15 _lhsIinh
         _hdOinhMap = rule16 _lhsIinhMap
         _hdOmergeMap = rule17 _lhsImergeMap
         _hdOnt = rule18 _lhsInt
         _hdOsyn = rule19 _lhsIsyn
         _hdOsynMap = rule20 _lhsIsynMap
         _tlOallfields = rule21 _lhsIallfields
         _tlOallnts = rule22 _lhsIallnts
         _tlOattrs = rule23 _lhsIattrs
         _tlOcon = rule24 _lhsIcon
         _tlOinh = rule25 _lhsIinh
         _tlOinhMap = rule26 _lhsIinhMap
         _tlOmergeMap = rule27 _lhsImergeMap
         _tlOnt = rule28 _lhsInt
         _tlOsyn = rule29 _lhsIsyn
         _tlOsynMap = rule30 _lhsIsynMap
         __result_ = T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput
         in __result_ )
     in C_Children_s5 v4
   {-# INLINE rule7 #-}





   {-# INLINE rule8 #-}
   rule8 = \ ((_hdIattributes) :: [(Identifier,Attributes,Attributes)]) ((_tlIattributes) :: [(Identifier,Attributes,Attributes)]) ->
     _hdIattributes ++ _tlIattributes
   {-# INLINE rule9 #-}
   rule9 = \ ((_hdIoutput) :: Child) ((_tlIoutput) :: Children) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule10 #-}
   rule10 = \ _output ->
     _output
   {-# INLINE rule11 #-}
   rule11 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule12 #-}
   rule12 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule13 #-}
   rule13 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule14 #-}
   rule14 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule15 #-}
   rule15 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule16 #-}
   rule16 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule17 #-}
   rule17 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule18 #-}
   rule18 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule19 #-}
   rule19 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule20 #-}
   rule20 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule21 #-}
   rule21 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule22 #-}
   rule22 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule23 #-}
   rule23 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule24 #-}
   rule24 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule25 #-}
   rule25 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule26 #-}
   rule26 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule27 #-}
   rule27 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule28 #-}
   rule28 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule29 #-}
   rule29 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule30 #-}
   rule30 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap = \ ((_hdIfield) :: (Identifier,Type,ChildKind)) ((_tlIfields) :: [(Identifier,Type,ChildKind)]) -> : _tlIfields



































































































































































































{-# NOINLINE sem_Children_Nil #-}
sem_Children_Nil ::  T_Children
sem_Children_Nil  = T_Children (return st5) where
   {-# NOINLINE st5 #-}
   st5 = let
      v4 :: T_Children_v4
      v4 = \ (T_Children_vIn4 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIsyn _lhsIsynMap) -> ( let
         _lhsOfields :: [(Identifier,Type,ChildKind)]
         _lhsOfields = rule31  ()
         _lhsOattributes :: [(Identifier,Attributes,Attributes)]
         _lhsOattributes = rule32  ()
         _output = rule33  ()
         _lhsOoutput :: Children
         _lhsOoutput = rule34 _output
         __result_ = T_Children_vOut4 _lhsOattributes _lhsOfields _lhsOoutput
         in __result_ )
     in C_Children_s5 v4
   {-# INLINE rule31 #-}





   {-# INLINE rule32 #-}
   rule32 = \  (_ :: ()) ->
     []
   {-# INLINE rule33 #-}
   rule33 = \  (_ :: ()) ->
     []
   {-# INLINE rule34 #-}
   rule34 = \ _output ->
     _output = \  (_ :: ()) ->]



































































































































































































































-- Expression --------------------------------------------------
-- wrapper
data Inh_Expression  = Inh_Expression { allfields_Inh_Expression :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Expression :: ([Identifier]), attrs_Inh_Expression :: ([(Identifier,Identifier)]), con_Inh_Expression :: (Identifier), mergeMap_Inh_Expression :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Expression :: (Identifier), options_Inh_Expression :: (Options) }
data Syn_Expression  = Syn_Expression { errors_Syn_Expression :: (Seq Error), output_Syn_Expression :: (Expression) }
{-# INLINABLE wrap_Expression #-}
wrap_Expression :: T_Expression  -> Inh_Expression  -> (Syn_Expression )
wrap_Expression (T_Expression act) (Inh_Expression _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg7 = T_Expression_vIn7 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions
        (T_Expression_vOut7 _lhsOerrors _lhsOoutput) <- return (inv_Expression_s8 sem arg7)
        return (Syn_Expression _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Expression #-}
sem_Expression :: Expression  -> T_Expression
sem_Expression ( Expression pos_ tks_ ) = sem_Expression_Expression pos_ tks_

-- semantic domain
newtype T_Expression  = T_Expression {
                                     attach_T_Expression :: Identity (T_Expression_s8 )
                                     }
newtype T_Expression_s8  = C_Expression_s8 {
                                           inv_Expression_s8 :: (T_Expression_v7 )
                                           }
data T_Expression_s9  = C_Expression_s9
type T_Expression_v7  = (T_Expression_vIn7 ) -> (T_Expression_vOut7 )
data T_Expression_vIn7  = T_Expression_vIn7 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options)
data T_Expression_vOut7  = T_Expression_vOut7 (Seq Error) (Expression)
{-# NOINLINE sem_Expression_Expression #-}
sem_Expression_Expression :: (Pos) -> ([HsToken]) -> T_Expression
sem_Expression_Expression arg_pos_ arg_tks_ = T_Expression (return st8) where
   {-# NOINLINE st8 #-}
   st8 = let
      v7 :: T_Expression_v7
      v7 = \ (T_Expression_vIn7 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions) -> ( let
         (_errors,_newTks) = rule35 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsImergeMap _lhsInt _lhsIoptions arg_tks_
         _lhsOoutput :: Expression
         _lhsOoutput = rule36 _newTks arg_pos_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule37 _errors
         _output = rule38 arg_pos_ arg_tks_
         __result_ = T_Expression_vOut7 _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Expression_s8 v7
   {-# INLINE rule35 #-}
















   {-# INLINE rule36 #-}





   {-# INLINE rule37 #-}
   rule37 = \ _errors ->
     _errors
   {-# INLINE rule38 #-}
   rule38 = \ pos_ tks_ ->
     Expression pos_ tks_ = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ((_lhsIallnts) :: [Identifier]) ((_lhsIattrs) :: [(Identifier,Identifier)]) ((_lhsIcon) :: Identifier) ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ((_lhsInt) :: Identifier) ((_lhsIoptions) :: Options) tks_ -> mergedChildren = [ x | (_,xs) <- Map.elems _lhsImergeMap, x <- xs ]
                                                                                                                                                                                                                                                                                                                     attrsIn = filter (\(fld,_) -> not (fld `elem` mergedChildren)) _lhsIattrs
                                                                                                                                                                                                                                                                                                                     inherited = Inh_HsTokensRoot
                                                                                                                                                                                                                                                                                                                                 { attrs_Inh_HsTokensRoot      = attrsIn
                                                                                                                                                                                                                                                                                                                                 , con_Inh_HsTokensRoot        = _lhsIcon
                                                                                                                                                                                                                                                                                                                                 , allfields_Inh_HsTokensRoot  = _lhsIallfields
                                                                                                                                                                                                                                                                                                                                 , allnts_Inh_HsTokensRoot     = _lhsIallnts
                                                                                                                                                                                                                                                                                                                                 , nt_Inh_HsTokensRoot         = _lhsInt
                                                                                                                                                                                                                                                                                                                                 , options_Inh_HsTokensRoot    = _lhsIoptions
                                                                                                                                                                                                                                                                                                                                 }
                                                                                                                                                                                                                                                                                                                     synthesized = wrap_HsTokensRoot (sem_HsTokensRoot (HsTokensRoot tks_)) inherited
                                                                                                                                                                                                                                                                                                                    in (errors_Syn_HsTokensRoot synthesized, output_Syn_HsTokensRoot synthesized)
   rule36 = \ _newTks pos_ ->  Expression pos_ _newTks












































































































































































































































-- Grammar -----------------------------------------------------
-- wrapper
data Inh_Grammar  = Inh_Grammar { options_Inh_Grammar :: (Options) }
data Syn_Grammar  = Syn_Grammar { errors_Syn_Grammar :: (Seq Error), output_Syn_Grammar :: (Grammar) }
{-# INLINABLE wrap_Grammar #-}
wrap_Grammar :: T_Grammar  -> Inh_Grammar  -> (Syn_Grammar )
wrap_Grammar (T_Grammar act) (Inh_Grammar _lhsIoptions) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg10 = T_Grammar_vIn10 _lhsIoptions
        (T_Grammar_vOut10 _lhsOerrors _lhsOoutput) <- return (inv_Grammar_s11 sem arg10)
        return (Syn_Grammar _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Grammar #-}
sem_Grammar :: Grammar  -> T_Grammar
sem_Grammar ( Grammar typeSyns_ useMap_ derivings_ wrappers_ nonts_ pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_ ) = sem_Grammar_Grammar typeSyns_ useMap_ derivings_ wrappers_ ( sem_Nonterminals nonts_ ) pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_

-- semantic domain
newtype T_Grammar  = T_Grammar {
                               attach_T_Grammar :: Identity (T_Grammar_s11 )
                               }
newtype T_Grammar_s11  = C_Grammar_s11 {
                                       inv_Grammar_s11 :: (T_Grammar_v10 )
                                       }
data T_Grammar_s12  = C_Grammar_s12
type T_Grammar_v10  = (T_Grammar_vIn10 ) -> (T_Grammar_vOut10 )
data T_Grammar_vIn10  = T_Grammar_vIn10 (Options)
data T_Grammar_vOut10  = T_Grammar_vOut10 (Seq Error) (Grammar)
{-# NOINLINE sem_Grammar_Grammar #-}
sem_Grammar_Grammar :: (TypeSyns) -> (UseMap) -> (Derivings) -> (Set NontermIdent) -> T_Nonterminals  -> (PragmaMap) -> (AttrOrderMap) -> (ParamMap) -> (ContextMap) -> (QuantMap) -> (UniqueMap) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier [Expression]))) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier [Expression]))) -> (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier, [Identifier], Expression)))) -> T_Grammar
sem_Grammar_Grammar arg_typeSyns_ arg_useMap_ arg_derivings_ arg_wrappers_ arg_nonts_ arg_pragmas_ arg_manualAttrOrderMap_ arg_paramMap_ arg_contextMap_ arg_quantMap_ arg_uniqueMap_ arg_augmentsMap_ arg_aroundsMap_ arg_mergeMap_ = T_Grammar (return st11) where
   {-# NOINLINE st11 #-}
   st11 = let
      v10 :: T_Grammar_v10
      v10 = \ (T_Grammar_vIn10 _lhsIoptions) -> ( let
         _nontsX17 = Control.Monad.Identity.runIdentity (attach_T_Nonterminals (arg_nonts_))
         (T_Nonterminals_vOut16 _nontsIerrors _nontsIinhMap' _nontsInonts _nontsIoutput _nontsIsynMap') = inv_Nonterminals_s17 _nontsX17 (T_Nonterminals_vIn16 _nontsOallnts _nontsOinhMap _nontsOmergeMap _nontsOoptions _nontsOsynMap)
         _nontsOinhMap = rule39 _nontsIinhMap'
         _nontsOsynMap = rule40 _nontsIsynMap'
         _nontsOallnts = rule41 _nontsInonts
         _nontsOmergeMap = rule42 arg_mergeMap_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule43 _nontsIerrors
         _output = rule44 _nontsIoutput arg_aroundsMap_ arg_augmentsMap_ arg_contextMap_ arg_derivings_ arg_manualAttrOrderMap_ arg_mergeMap_ arg_paramMap_ arg_pragmas_ arg_quantMap_ arg_typeSyns_ arg_uniqueMap_ arg_useMap_ arg_wrappers_
         _lhsOoutput :: Grammar
         _lhsOoutput = rule45 _output
         _nontsOoptions = rule46 _lhsIoptions
         __result_ = T_Grammar_vOut10 _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Grammar_s11 v10
   {-# INLINE rule39 #-}





   {-# INLINE rule40 #-}





   {-# INLINE rule41 #-}





   {-# INLINE rule42 #-}





   {-# INLINE rule43 #-}
   rule43 = \ ((_nontsIerrors) :: Seq Error) ->
     _nontsIerrors
   {-# INLINE rule44 #-}
   rule44 = \ ((_nontsIoutput) :: Nonterminals) aroundsMap_ augmentsMap_ contextMap_ derivings_ manualAttrOrderMap_ mergeMap_ paramMap_ pragmas_ quantMap_ typeSyns_ uniqueMap_ useMap_ wrappers_ ->
     Grammar typeSyns_ useMap_ derivings_ wrappers_ _nontsIoutput pragmas_ manualAttrOrderMap_ paramMap_ contextMap_ quantMap_ uniqueMap_ augmentsMap_ aroundsMap_ mergeMap_
   {-# INLINE rule45 #-}
   rule45 = \ _output ->
     _output
   {-# INLINE rule46 #-}
   rule46 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions = \ ((_nontsIinhMap') :: Map Identifier Attributes) ->
   rule40 = \ ((_nontsIsynMap') :: Map Identifier Attributes) ->










































   rule41 = \ ((_nontsInonts) :: [(NontermIdent,[ConstructorIdent])]) -> fst (_nontsInonts)



























































   rule42 = \ mergeMap_ ->       Map.map (Map.map (Map.map (\(nt,srcs,_) -> (nt,srcs)))) mergeMap_











































































































































































































































































































































































-- Nonterminal -------------------------------------------------
-- wrapper
data Inh_Nonterminal  = Inh_Nonterminal { allnts_Inh_Nonterminal :: ([Identifier]), inhMap_Inh_Nonterminal :: (Map Identifier Attributes), mergeMap_Inh_Nonterminal :: (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))), options_Inh_Nonterminal :: (Options), synMap_Inh_Nonterminal :: (Map Identifier Attributes) }
data Syn_Nonterminal  = Syn_Nonterminal { errors_Syn_Nonterminal :: (Seq Error), inhMap'_Syn_Nonterminal :: (Map Identifier Attributes), nonts_Syn_Nonterminal :: ([(NontermIdent,[ConstructorIdent])]), output_Syn_Nonterminal :: (Nonterminal), synMap'_Syn_Nonterminal :: (Map Identifier Attributes) }
{-# INLINABLE wrap_Nonterminal #-}
wrap_Nonterminal :: T_Nonterminal  -> Inh_Nonterminal  -> (Syn_Nonterminal )
wrap_Nonterminal (T_Nonterminal act) (Inh_Nonterminal _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg13 = T_Nonterminal_vIn13 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap
        (T_Nonterminal_vOut13 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap') <- return (inv_Nonterminal_s14 sem arg13)
        return (Syn_Nonterminal _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap')
   )

-- cata
{-# INLINE sem_Nonterminal #-}
sem_Nonterminal :: Nonterminal  -> T_Nonterminal
sem_Nonterminal ( Nonterminal nt_ params_ inh_ syn_ prods_ ) = sem_Nonterminal_Nonterminal nt_ params_ inh_ syn_ ( sem_Productions prods_ )

-- semantic domain
newtype T_Nonterminal  = T_Nonterminal {
                                       attach_T_Nonterminal :: Identity (T_Nonterminal_s14 )
                                       }
newtype T_Nonterminal_s14  = C_Nonterminal_s14 {
                                               inv_Nonterminal_s14 :: (T_Nonterminal_v13 )
                                               }
data T_Nonterminal_s15  = C_Nonterminal_s15
type T_Nonterminal_v13  = (T_Nonterminal_vIn13 ) -> (T_Nonterminal_vOut13 )
data T_Nonterminal_vIn13  = T_Nonterminal_vIn13 ([Identifier]) (Map Identifier Attributes) (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) (Options) (Map Identifier Attributes)
data T_Nonterminal_vOut13  = T_Nonterminal_vOut13 (Seq Error) (Map Identifier Attributes) ([(NontermIdent,[ConstructorIdent])]) (Nonterminal) (Map Identifier Attributes)
{-# NOINLINE sem_Nonterminal_Nonterminal #-}
sem_Nonterminal_Nonterminal :: (NontermIdent) -> ([Identifier]) -> (Attributes) -> (Attributes) -> T_Productions  -> T_Nonterminal
sem_Nonterminal_Nonterminal arg_nt_ arg_params_ arg_inh_ arg_syn_ arg_prods_ = T_Nonterminal (return st14) where
   {-# NOINLINE st14 #-}
   st14 = let
      v13 :: T_Nonterminal_v13
      v13 = \ (T_Nonterminal_vIn13 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _prodsX29 = Control.Monad.Identity.runIdentity (attach_T_Productions (arg_prods_))
         (T_Productions_vOut28 _prodsIcons _prodsIerrors _prodsIoutput) = inv_Productions_s29 _prodsX29 (T_Productions_vIn28 _prodsOallnts _prodsOinh _prodsOinhMap _prodsOmergeMap _prodsOnt _prodsOoptions _prodsOsyn _prodsOsynMap)
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule47 arg_inh_ arg_nt_
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule48 arg_nt_ arg_syn_
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule49 _prodsIcons arg_nt_
         _prodsOnt = rule50 arg_nt_
         _prodsOinh = rule51 arg_inh_
         _prodsOsyn = rule52 arg_syn_
         _mergeMap = rule53 _lhsImergeMap arg_nt_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule54 _prodsIerrors
         _output = rule55 _prodsIoutput arg_inh_ arg_nt_ arg_params_ arg_syn_
         _lhsOoutput :: Nonterminal
         _lhsOoutput = rule56 _output
         _prodsOallnts = rule57 _lhsIallnts
         _prodsOinhMap = rule58 _lhsIinhMap
         _prodsOmergeMap = rule59 _mergeMap
         _prodsOoptions = rule60 _lhsIoptions
         _prodsOsynMap = rule61 _lhsIsynMap
         __result_ = T_Nonterminal_vOut13 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminal_s14 v13
   {-# INLINE rule47 #-}





   {-# INLINE rule48 #-}





   {-# INLINE rule49 #-}





   {-# INLINE rule50 #-}





   {-# INLINE rule51 #-}





   {-# INLINE rule52 #-}





   {-# INLINE rule53 #-}





   {-# INLINE rule54 #-}
   rule54 = \ ((_prodsIerrors) :: Seq Error) ->
     _prodsIerrors
   {-# INLINE rule55 #-}
   rule55 = \ ((_prodsIoutput) :: Productions) inh_ nt_ params_ syn_ ->
     Nonterminal nt_ params_ inh_ syn_ _prodsIoutput
   {-# INLINE rule56 #-}
   rule56 = \ _output ->
     _output
   {-# INLINE rule57 #-}
   rule57 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule58 #-}
   rule58 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule59 #-}
   rule59 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule60 #-}
   rule60 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule61 #-}
   rule61 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap = \ inh_ nt_ ->        Map.singleton nt_ inh_
   rule48 = \ nt_ syn_ ->        Map.singleton nt_ syn_






















































   rule49 = \ ((_prodsIcons) :: [ConstructorIdent]) nt_ ->(nt_,_prodsIcons)]















































   rule50 = \ nt_ ->           nt_


   rule51 = \ inh_ ->          inh_
   rule52 = \ syn_ ->          syn_











   rule53 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) nt_ -> Map.empty nt_ _lhsImergeMap




































































































































































































































































































































































































































































































-- Nonterminals ------------------------------------------------
-- wrapper
data Inh_Nonterminals  = Inh_Nonterminals { allnts_Inh_Nonterminals :: ([Identifier]), inhMap_Inh_Nonterminals :: (Map Identifier Attributes), mergeMap_Inh_Nonterminals :: (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))), options_Inh_Nonterminals :: (Options), synMap_Inh_Nonterminals :: (Map Identifier Attributes) }
data Syn_Nonterminals  = Syn_Nonterminals { errors_Syn_Nonterminals :: (Seq Error), inhMap'_Syn_Nonterminals :: (Map Identifier Attributes), nonts_Syn_Nonterminals :: ([(NontermIdent,[ConstructorIdent])]), output_Syn_Nonterminals :: (Nonterminals), synMap'_Syn_Nonterminals :: (Map Identifier Attributes) }
{-# INLINABLE wrap_Nonterminals #-}
wrap_Nonterminals :: T_Nonterminals  -> Inh_Nonterminals  -> (Syn_Nonterminals )
wrap_Nonterminals (T_Nonterminals act) (Inh_Nonterminals _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg16 = T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap
        (T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap') <- return (inv_Nonterminals_s17 sem arg16)
        return (Syn_Nonterminals _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap')
   )

-- cata
{-# NOINLINE sem_Nonterminals #-}
sem_Nonterminals :: Nonterminals  -> T_Nonterminals
sem_Nonterminals list = Prelude.foldr sem_Nonterminals_Cons sem_Nonterminals_Nil (Prelude.map sem_Nonterminal list)

-- semantic domain
newtype T_Nonterminals  = T_Nonterminals {
                                         attach_T_Nonterminals :: Identity (T_Nonterminals_s17 )
                                         }
newtype T_Nonterminals_s17  = C_Nonterminals_s17 {
                                                 inv_Nonterminals_s17 :: (T_Nonterminals_v16 )
                                                 }
data T_Nonterminals_s18  = C_Nonterminals_s18
type T_Nonterminals_v16  = (T_Nonterminals_vIn16 ) -> (T_Nonterminals_vOut16 )
data T_Nonterminals_vIn16  = T_Nonterminals_vIn16 ([Identifier]) (Map Identifier Attributes) (Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) (Options) (Map Identifier Attributes)
data T_Nonterminals_vOut16  = T_Nonterminals_vOut16 (Seq Error) (Map Identifier Attributes) ([(NontermIdent,[ConstructorIdent])]) (Nonterminals) (Map Identifier Attributes)
{-# NOINLINE sem_Nonterminals_Cons #-}
sem_Nonterminals_Cons :: T_Nonterminal  -> T_Nonterminals  -> T_Nonterminals
sem_Nonterminals_Cons arg_hd_ arg_tl_ = T_Nonterminals (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_Nonterminals_v16
      v16 = \ (T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _hdX14 = Control.Monad.Identity.runIdentity (attach_T_Nonterminal (arg_hd_))
         _tlX17 = Control.Monad.Identity.runIdentity (attach_T_Nonterminals (arg_tl_))
         (T_Nonterminal_vOut13 _hdIerrors _hdIinhMap' _hdInonts _hdIoutput _hdIsynMap') = inv_Nonterminal_s14 _hdX14 (T_Nonterminal_vIn13 _hdOallnts _hdOinhMap _hdOmergeMap _hdOoptions _hdOsynMap)
         (T_Nonterminals_vOut16 _tlIerrors _tlIinhMap' _tlInonts _tlIoutput _tlIsynMap') = inv_Nonterminals_s17 _tlX17 (T_Nonterminals_vIn16 _tlOallnts _tlOinhMap _tlOmergeMap _tlOoptions _tlOsynMap)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule62 _hdIerrors _tlIerrors
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule63 _hdIinhMap' _tlIinhMap'
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule64 _hdInonts _tlInonts
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule65 _hdIsynMap' _tlIsynMap'
         _output = rule66 _hdIoutput _tlIoutput
         _lhsOoutput :: Nonterminals
         _lhsOoutput = rule67 _output
         _hdOallnts = rule68 _lhsIallnts
         _hdOinhMap = rule69 _lhsIinhMap
         _hdOmergeMap = rule70 _lhsImergeMap
         _hdOoptions = rule71 _lhsIoptions
         _hdOsynMap = rule72 _lhsIsynMap
         _tlOallnts = rule73 _lhsIallnts
         _tlOinhMap = rule74 _lhsIinhMap
         _tlOmergeMap = rule75 _lhsImergeMap
         _tlOoptions = rule76 _lhsIoptions
         _tlOsynMap = rule77 _lhsIsynMap
         __result_ = T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminals_s17 v16
   {-# INLINE rule62 #-}
   rule62 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule63 #-}
   rule63 = \ ((_hdIinhMap') :: Map Identifier Attributes) ((_tlIinhMap') :: Map Identifier Attributes) ->
     _hdIinhMap' `Map.union` _tlIinhMap'
   {-# INLINE rule64 #-}
   rule64 = \ ((_hdInonts) :: [(NontermIdent,[ConstructorIdent])]) ((_tlInonts) :: [(NontermIdent,[ConstructorIdent])]) ->
     _hdInonts ++ _tlInonts
   {-# INLINE rule65 #-}
   rule65 = \ ((_hdIsynMap') :: Map Identifier Attributes) ((_tlIsynMap') :: Map Identifier Attributes) ->
     _hdIsynMap' `Map.union` _tlIsynMap'
   {-# INLINE rule66 #-}
   rule66 = \ ((_hdIoutput) :: Nonterminal) ((_tlIoutput) :: Nonterminals) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule67 #-}
   rule67 = \ _output ->
     _output
   {-# INLINE rule68 #-}
   rule68 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule69 #-}
   rule69 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule70 #-}
   rule70 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) ->
     _lhsImergeMap
   {-# INLINE rule71 #-}
   rule71 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule72 #-}
   rule72 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule73 #-}
   rule73 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule74 #-}
   rule74 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule75 #-}
   rule75 = \ ((_lhsImergeMap) :: Map NontermIdent (Map ConstructorIdent (Map Identifier (Identifier,[Identifier])))) ->
     _lhsImergeMap
   {-# INLINE rule76 #-}
   rule76 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule77 #-}
   rule77 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
{-# NOINLINE sem_Nonterminals_Nil #-}
sem_Nonterminals_Nil ::  T_Nonterminals
sem_Nonterminals_Nil  = T_Nonterminals (return st17) where
   {-# NOINLINE st17 #-}
   st17 = let
      v16 :: T_Nonterminals_v16
      v16 = \ (T_Nonterminals_vIn16 _lhsIallnts _lhsIinhMap _lhsImergeMap _lhsIoptions _lhsIsynMap) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule78  ()
         _lhsOinhMap' :: Map Identifier Attributes
         _lhsOinhMap' = rule79  ()
         _lhsOnonts :: [(NontermIdent,[ConstructorIdent])]
         _lhsOnonts = rule80  ()
         _lhsOsynMap' :: Map Identifier Attributes
         _lhsOsynMap' = rule81  ()
         _output = rule82  ()
         _lhsOoutput :: Nonterminals
         _lhsOoutput = rule83 _output
         __result_ = T_Nonterminals_vOut16 _lhsOerrors _lhsOinhMap' _lhsOnonts _lhsOoutput _lhsOsynMap'
         in __result_ )
     in C_Nonterminals_s17 v16
   {-# INLINE rule78 #-}
   rule78 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule79 #-}
   rule79 = \  (_ :: ()) ->
     Map.empty
   {-# INLINE rule80 #-}
   rule80 = \  (_ :: ()) ->
     []
   {-# INLINE rule81 #-}
   rule81 = \  (_ :: ()) ->
     Map.empty
   {-# INLINE rule82 #-}
   rule82 = \  (_ :: ()) ->
     []
   {-# INLINE rule83 #-}
   rule83 = \ _output ->
     _output

-- Pattern -----------------------------------------------------
-- wrapper
data Inh_Pattern  = Inh_Pattern { con_Inh_Pattern :: (Identifier), inh_Inh_Pattern :: (Attributes), nt_Inh_Pattern :: (Identifier), syn_Inh_Pattern :: (Attributes) }
data Syn_Pattern  = Syn_Pattern { copy_Syn_Pattern :: (Pattern), errors_Syn_Pattern :: (Seq Error), instVars_Syn_Pattern :: ([Identifier]), locVars_Syn_Pattern :: ([Identifier]), output_Syn_Pattern :: (Pattern) }
{-# INLINABLE wrap_Pattern #-}
wrap_Pattern :: T_Pattern  -> Inh_Pattern  -> (Syn_Pattern )
wrap_Pattern (T_Pattern act) (Inh_Pattern _lhsIcon _lhsIinh _lhsInt _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg19 = T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn
        (T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Pattern_s20 sem arg19)
        return (Syn_Pattern _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Pattern #-}
sem_Pattern :: Pattern  -> T_Pattern
sem_Pattern ( Constr name_ pats_ ) = sem_Pattern_Constr name_ ( sem_Patterns pats_ )
sem_Pattern ( Product pos_ pats_ ) = sem_Pattern_Product pos_ ( sem_Patterns pats_ )
sem_Pattern ( Alias field_ attr_ pat_ ) = sem_Pattern_Alias field_ attr_ ( sem_Pattern pat_ )
sem_Pattern ( Irrefutable pat_ ) = sem_Pattern_Irrefutable ( sem_Pattern pat_ )
sem_Pattern ( Underscore pos_ ) = sem_Pattern_Underscore pos_

-- semantic domain
newtype T_Pattern  = T_Pattern {
                               attach_T_Pattern :: Identity (T_Pattern_s20 )
                               }
newtype T_Pattern_s20  = C_Pattern_s20 {
                                       inv_Pattern_s20 :: (T_Pattern_v19 )
                                       }
data T_Pattern_s21  = C_Pattern_s21
type T_Pattern_v19  = (T_Pattern_vIn19 ) -> (T_Pattern_vOut19 )
data T_Pattern_vIn19  = T_Pattern_vIn19 (Identifier) (Attributes) (Identifier) (Attributes)
data T_Pattern_vOut19  = T_Pattern_vOut19 (Pattern) (Seq Error) ([Identifier]) ([Identifier]) (Pattern)
{-# NOINLINE sem_Pattern_Constr #-}
sem_Pattern_Constr :: (ConstructorIdent) -> T_Patterns  -> T_Pattern
sem_Pattern_Constr arg_name_ arg_pats_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patsX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_pats_))
         (T_Patterns_vOut22 _patsIcopy _patsIerrors _patsIinstVars _patsIlocVars _patsIoutput) = inv_Patterns_s23 _patsX23 (T_Patterns_vIn22 _patsOcon _patsOinh _patsOnt _patsOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule84 _patsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule85 _patsIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule86 _patsIlocVars
         _copy = rule87 _patsIcopy arg_name_
         _output = rule88 _patsIoutput arg_name_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule89 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule90 _output
         _patsOcon = rule91 _lhsIcon
         _patsOinh = rule92 _lhsIinh
         _patsOnt = rule93 _lhsInt
         _patsOsyn = rule94 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule84 #-}
   rule84 = \ ((_patsIerrors) :: Seq Error) ->
     _patsIerrors
   {-# INLINE rule85 #-}
   rule85 = \ ((_patsIinstVars) :: [Identifier]) ->
     _patsIinstVars
   {-# INLINE rule86 #-}
   rule86 = \ ((_patsIlocVars) :: [Identifier]) ->
     _patsIlocVars
   {-# INLINE rule87 #-}
   rule87 = \ ((_patsIcopy) :: Patterns) name_ ->
     Constr name_ _patsIcopy
   {-# INLINE rule88 #-}
   rule88 = \ ((_patsIoutput) :: Patterns) name_ ->
     Constr name_ _patsIoutput
   {-# INLINE rule89 #-}
   rule89 = \ _copy ->
     _copy
   {-# INLINE rule90 #-}
   rule90 = \ _output ->
     _output
   {-# INLINE rule91 #-}
   rule91 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule92 #-}
   rule92 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule93 #-}
   rule93 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule94 #-}
   rule94 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Product #-}
sem_Pattern_Product :: (Pos) -> T_Patterns  -> T_Pattern
sem_Pattern_Product arg_pos_ arg_pats_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patsX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_pats_))
         (T_Patterns_vOut22 _patsIcopy _patsIerrors _patsIinstVars _patsIlocVars _patsIoutput) = inv_Patterns_s23 _patsX23 (T_Patterns_vIn22 _patsOcon _patsOinh _patsOnt _patsOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule95 _patsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule96 _patsIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule97 _patsIlocVars
         _copy = rule98 _patsIcopy arg_pos_
         _output = rule99 _patsIoutput arg_pos_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule100 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule101 _output
         _patsOcon = rule102 _lhsIcon
         _patsOinh = rule103 _lhsIinh
         _patsOnt = rule104 _lhsInt
         _patsOsyn = rule105 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule95 #-}
   rule95 = \ ((_patsIerrors) :: Seq Error) ->
     _patsIerrors
   {-# INLINE rule96 #-}
   rule96 = \ ((_patsIinstVars) :: [Identifier]) ->
     _patsIinstVars
   {-# INLINE rule97 #-}
   rule97 = \ ((_patsIlocVars) :: [Identifier]) ->
     _patsIlocVars
   {-# INLINE rule98 #-}
   rule98 = \ ((_patsIcopy) :: Patterns) pos_ ->
     Product pos_ _patsIcopy
   {-# INLINE rule99 #-}
   rule99 = \ ((_patsIoutput) :: Patterns) pos_ ->
     Product pos_ _patsIoutput
   {-# INLINE rule100 #-}
   rule100 = \ _copy ->
     _copy
   {-# INLINE rule101 #-}
   rule101 = \ _output ->
     _output
   {-# INLINE rule102 #-}
   rule102 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule103 #-}
   rule103 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule104 #-}
   rule104 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule105 #-}
   rule105 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Alias #-}
sem_Pattern_Alias :: (Identifier) -> (Identifier) -> T_Pattern  -> T_Pattern
sem_Pattern_Alias arg_field_ arg_attr_ arg_pat_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pat_))
         (T_Pattern_vOut19 _patIcopy _patIerrors _patIinstVars _patIlocVars _patIoutput) = inv_Pattern_s20 _patX20 (T_Pattern_vIn19 _patOcon _patOinh _patOnt _patOsyn)
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule106 arg_attr_ arg_field_
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule107 arg_attr_ arg_field_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule108 _patIerrors
         _copy = rule109 _patIcopy arg_attr_ arg_field_
         _output = rule110 _patIoutput arg_attr_ arg_field_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule111 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule112 _output
         _patOcon = rule113 _lhsIcon
         _patOinh = rule114 _lhsIinh
         _patOnt = rule115 _lhsInt
         _patOsyn = rule116 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule106 #-}







   {-# INLINE rule107 #-}







   {-# INLINE rule108 #-}
   rule108 = \ ((_patIerrors) :: Seq Error) ->
     _patIerrors
   {-# INLINE rule109 #-}
   rule109 = \ ((_patIcopy) :: Pattern) attr_ field_ ->
     Alias field_ attr_ _patIcopy
   {-# INLINE rule110 #-}
   rule110 = \ ((_patIoutput) :: Pattern) attr_ field_ ->
     Alias field_ attr_ _patIoutput
   {-# INLINE rule111 #-}
   rule111 = \ _copy ->
     _copy
   {-# INLINE rule112 #-}
   rule112 = \ _output ->
     _output
   {-# INLINE rule113 #-}
   rule113 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule114 #-}
   rule114 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule115 #-}
   rule115 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule116 #-}
   rule116 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn = \ attr_ field_ -> if field_ == _LOC
                                     then [attr_]
                                     else []
   rule107 = \ attr_ field_ -> if field_ == _INST
                                  then [attr_]
                                  else []



























































































































































































































































































































































































































































































































































































































































































































































































































































































































{-# NOINLINE sem_Pattern_Irrefutable #-}
sem_Pattern_Irrefutable :: T_Pattern  -> T_Pattern
sem_Pattern_Irrefutable arg_pat_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _patX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pat_))
         (T_Pattern_vOut19 _patIcopy _patIerrors _patIinstVars _patIlocVars _patIoutput) = inv_Pattern_s20 _patX20 (T_Pattern_vIn19 _patOcon _patOinh _patOnt _patOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule117 _patIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule118 _patIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule119 _patIlocVars
         _copy = rule120 _patIcopy
         _output = rule121 _patIoutput
         _lhsOcopy :: Pattern
         _lhsOcopy = rule122 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule123 _output
         _patOcon = rule124 _lhsIcon
         _patOinh = rule125 _lhsIinh
         _patOnt = rule126 _lhsInt
         _patOsyn = rule127 _lhsIsyn
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule117 #-}
   rule117 = \ ((_patIerrors) :: Seq Error) ->
     _patIerrors
   {-# INLINE rule118 #-}
   rule118 = \ ((_patIinstVars) :: [Identifier]) ->
     _patIinstVars
   {-# INLINE rule119 #-}
   rule119 = \ ((_patIlocVars) :: [Identifier]) ->
     _patIlocVars
   {-# INLINE rule120 #-}
   rule120 = \ ((_patIcopy) :: Pattern) ->
     Irrefutable _patIcopy
   {-# INLINE rule121 #-}
   rule121 = \ ((_patIoutput) :: Pattern) ->
     Irrefutable _patIoutput
   {-# INLINE rule122 #-}
   rule122 = \ _copy ->
     _copy
   {-# INLINE rule123 #-}
   rule123 = \ _output ->
     _output
   {-# INLINE rule124 #-}
   rule124 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule125 #-}
   rule125 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule126 #-}
   rule126 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule127 #-}
   rule127 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Pattern_Underscore #-}
sem_Pattern_Underscore :: (Pos) -> T_Pattern
sem_Pattern_Underscore arg_pos_ = T_Pattern (return st20) where
   {-# NOINLINE st20 #-}
   st20 = let
      v19 :: T_Pattern_v19
      v19 = \ (T_Pattern_vIn19 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule128  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule129  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule130  ()
         _copy = rule131 arg_pos_
         _output = rule132 arg_pos_
         _lhsOcopy :: Pattern
         _lhsOcopy = rule133 _copy
         _lhsOoutput :: Pattern
         _lhsOoutput = rule134 _output
         __result_ = T_Pattern_vOut19 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Pattern_s20 v19
   {-# INLINE rule128 #-}
   rule128 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule129 #-}
   rule129 = \  (_ :: ()) ->
     []
   {-# INLINE rule130 #-}
   rule130 = \  (_ :: ()) ->
     []
   {-# INLINE rule131 #-}
   rule131 = \ pos_ ->
     Underscore pos_
   {-# INLINE rule132 #-}
   rule132 = \ pos_ ->
     Underscore pos_
   {-# INLINE rule133 #-}
   rule133 = \ _copy ->
     _copy
   {-# INLINE rule134 #-}
   rule134 = \ _output ->
     _output

-- Patterns ----------------------------------------------------
-- wrapper
data Inh_Patterns  = Inh_Patterns { con_Inh_Patterns :: (Identifier), inh_Inh_Patterns :: (Attributes), nt_Inh_Patterns :: (Identifier), syn_Inh_Patterns :: (Attributes) }
data Syn_Patterns  = Syn_Patterns { copy_Syn_Patterns :: (Patterns), errors_Syn_Patterns :: (Seq Error), instVars_Syn_Patterns :: ([Identifier]), locVars_Syn_Patterns :: ([Identifier]), output_Syn_Patterns :: (Patterns) }
{-# INLINABLE wrap_Patterns #-}
wrap_Patterns :: T_Patterns  -> Inh_Patterns  -> (Syn_Patterns )
wrap_Patterns (T_Patterns act) (Inh_Patterns _lhsIcon _lhsIinh _lhsInt _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg22 = T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn
        (T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Patterns_s23 sem arg22)
        return (Syn_Patterns _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Patterns #-}
sem_Patterns :: Patterns  -> T_Patterns
sem_Patterns list = Prelude.foldr sem_Patterns_Cons sem_Patterns_Nil (Prelude.map sem_Pattern list)

-- semantic domain
newtype T_Patterns  = T_Patterns {
                                 attach_T_Patterns :: Identity (T_Patterns_s23 )
                                 }
newtype T_Patterns_s23  = C_Patterns_s23 {
                                         inv_Patterns_s23 :: (T_Patterns_v22 )
                                         }
data T_Patterns_s24  = C_Patterns_s24
type T_Patterns_v22  = (T_Patterns_vIn22 ) -> (T_Patterns_vOut22 )
data T_Patterns_vIn22  = T_Patterns_vIn22 (Identifier) (Attributes) (Identifier) (Attributes)
data T_Patterns_vOut22  = T_Patterns_vOut22 (Patterns) (Seq Error) ([Identifier]) ([Identifier]) (Patterns)
{-# NOINLINE sem_Patterns_Cons #-}
sem_Patterns_Cons :: T_Pattern  -> T_Patterns  -> T_Patterns
sem_Patterns_Cons arg_hd_ arg_tl_ = T_Patterns (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_Patterns_v22
      v22 = \ (T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _hdX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_hd_))
         _tlX23 = Control.Monad.Identity.runIdentity (attach_T_Patterns (arg_tl_))
         (T_Pattern_vOut19 _hdIcopy _hdIerrors _hdIinstVars _hdIlocVars _hdIoutput) = inv_Pattern_s20 _hdX20 (T_Pattern_vIn19 _hdOcon _hdOinh _hdOnt _hdOsyn)
         (T_Patterns_vOut22 _tlIcopy _tlIerrors _tlIinstVars _tlIlocVars _tlIoutput) = inv_Patterns_s23 _tlX23 (T_Patterns_vIn22 _tlOcon _tlOinh _tlOnt _tlOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule135 _hdIerrors _tlIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule136 _hdIinstVars _tlIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule137 _hdIlocVars _tlIlocVars
         _copy = rule138 _hdIcopy _tlIcopy
         _output = rule139 _hdIoutput _tlIoutput
         _lhsOcopy :: Patterns
         _lhsOcopy = rule140 _copy
         _lhsOoutput :: Patterns
         _lhsOoutput = rule141 _output
         _hdOcon = rule142 _lhsIcon
         _hdOinh = rule143 _lhsIinh
         _hdOnt = rule144 _lhsInt
         _hdOsyn = rule145 _lhsIsyn
         _tlOcon = rule146 _lhsIcon
         _tlOinh = rule147 _lhsIinh
         _tlOnt = rule148 _lhsInt
         _tlOsyn = rule149 _lhsIsyn
         __result_ = T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Patterns_s23 v22
   {-# INLINE rule135 #-}
   rule135 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule136 #-}
   rule136 = \ ((_hdIinstVars) :: [Identifier]) ((_tlIinstVars) :: [Identifier]) ->
     _hdIinstVars ++ _tlIinstVars
   {-# INLINE rule137 #-}
   rule137 = \ ((_hdIlocVars) :: [Identifier]) ((_tlIlocVars) :: [Identifier]) ->
     _hdIlocVars ++ _tlIlocVars
   {-# INLINE rule138 #-}
   rule138 = \ ((_hdIcopy) :: Pattern) ((_tlIcopy) :: Patterns) ->
     (:) _hdIcopy _tlIcopy
   {-# INLINE rule139 #-}
   rule139 = \ ((_hdIoutput) :: Pattern) ((_tlIoutput) :: Patterns) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule140 #-}
   rule140 = \ _copy ->
     _copy
   {-# INLINE rule141 #-}
   rule141 = \ _output ->
     _output
   {-# INLINE rule142 #-}
   rule142 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule143 #-}
   rule143 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule144 #-}
   rule144 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule145 #-}
   rule145 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule146 #-}
   rule146 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule147 #-}
   rule147 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule148 #-}
   rule148 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule149 #-}
   rule149 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Patterns_Nil #-}
sem_Patterns_Nil ::  T_Patterns
sem_Patterns_Nil  = T_Patterns (return st23) where
   {-# NOINLINE st23 #-}
   st23 = let
      v22 :: T_Patterns_v22
      v22 = \ (T_Patterns_vIn22 _lhsIcon _lhsIinh _lhsInt _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule150  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule151  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule152  ()
         _copy = rule153  ()
         _output = rule154  ()
         _lhsOcopy :: Patterns
         _lhsOcopy = rule155 _copy
         _lhsOoutput :: Patterns
         _lhsOoutput = rule156 _output
         __result_ = T_Patterns_vOut22 _lhsOcopy _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Patterns_s23 v22
   {-# INLINE rule150 #-}
   rule150 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule151 #-}
   rule151 = \  (_ :: ()) ->
     []
   {-# INLINE rule152 #-}
   rule152 = \  (_ :: ()) ->
     []
   {-# INLINE rule153 #-}
   rule153 = \  (_ :: ()) ->
     []
   {-# INLINE rule154 #-}
   rule154 = \  (_ :: ()) ->
     []
   {-# INLINE rule155 #-}
   rule155 = \ _copy ->
     _copy
   {-# INLINE rule156 #-}
   rule156 = \ _output ->
     _output

-- Production --------------------------------------------------
-- wrapper
data Inh_Production  = Inh_Production { allnts_Inh_Production :: ([Identifier]), inh_Inh_Production :: (Attributes), inhMap_Inh_Production :: (Map Identifier Attributes), mergeMap_Inh_Production :: (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))), nt_Inh_Production :: (Identifier), options_Inh_Production :: (Options), syn_Inh_Production :: (Attributes), synMap_Inh_Production :: (Map Identifier Attributes) }
data Syn_Production  = Syn_Production { cons_Syn_Production :: ([ConstructorIdent]), errors_Syn_Production :: (Seq Error), output_Syn_Production :: (Production) }
{-# INLINABLE wrap_Production #-}
wrap_Production :: T_Production  -> Inh_Production  -> (Syn_Production )
wrap_Production (T_Production act) (Inh_Production _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg25 = T_Production_vIn25 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap
        (T_Production_vOut25 _lhsOcons _lhsOerrors _lhsOoutput) <- return (inv_Production_s26 sem arg25)
        return (Syn_Production _lhsOcons _lhsOerrors _lhsOoutput)
   )

-- cata
{-# INLINE sem_Production #-}
sem_Production :: Production  -> T_Production
sem_Production ( Production con_ params_ constraints_ children_ rules_ typeSigs_ macro_ ) = sem_Production_Production con_ params_ constraints_ ( sem_Children children_ ) ( sem_Rules rules_ ) ( sem_TypeSigs typeSigs_ ) macro_

-- semantic domain
newtype T_Production  = T_Production {
                                     attach_T_Production :: Identity (T_Production_s26 )
                                     }
newtype T_Production_s26  = C_Production_s26 {
                                             inv_Production_s26 :: (T_Production_v25 )
                                             }
data T_Production_s27  = C_Production_s27
type T_Production_v25  = (T_Production_vIn25 ) -> (T_Production_vOut25 )
data T_Production_vIn25  = T_Production_vIn25 ([Identifier]) (Attributes) (Map Identifier Attributes) (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) (Identifier) (Options) (Attributes) (Map Identifier Attributes)
data T_Production_vOut25  = T_Production_vOut25 ([ConstructorIdent]) (Seq Error) (Production)
{-# NOINLINE sem_Production_Production #-}
sem_Production_Production :: (ConstructorIdent) -> ([Identifier]) -> ([Type]) -> T_Children  -> T_Rules  -> T_TypeSigs  -> (MaybeMacro) -> T_Production
sem_Production_Production arg_con_ arg_params_ arg_constraints_ arg_children_ arg_rules_ arg_typeSigs_ arg_macro_ = T_Production (return st26) where
   {-# NOINLINE st26 #-}
   st26 = let
      v25 :: T_Production_v25
      v25 = \ (T_Production_vIn25 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _childrenX5 = Control.Monad.Identity.runIdentity (attach_T_Children (arg_children_))
         _rulesX35 = Control.Monad.Identity.runIdentity (attach_T_Rules (arg_rules_))
         _typeSigsX41 = Control.Monad.Identity.runIdentity (attach_T_TypeSigs (arg_typeSigs_))
         (T_Children_vOut4 _childrenIattributes _childrenIfields _childrenIoutput) = inv_Children_s5 _childrenX5 (T_Children_vIn4 _childrenOallfields _childrenOallnts _childrenOattrs _childrenOcon _childrenOinh _childrenOinhMap _childrenOmergeMap _childrenOnt _childrenOsyn _childrenOsynMap)
         (T_Rules_vOut34 _rulesIerrors _rulesIinstVars _rulesIlocVars _rulesIoutput) = inv_Rules_s35 _rulesX35 (T_Rules_vIn34 _rulesOallfields _rulesOallnts _rulesOattrs _rulesOcon _rulesOinh _rulesOmergeMap _rulesOnt _rulesOoptions _rulesOsyn)
         (T_TypeSigs_vOut40 _typeSigsIoutput) = inv_TypeSigs_s41 _typeSigsX41 (T_TypeSigs_vIn40 )
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule157 arg_con_
         _allfields = rule158 _childrenIfields
         _attrs = rule159 _childrenIattributes _inhnames _rulesIinstVars _rulesIlocVars
         _inhnames = rule160 _lhsIinh
         _synnames = rule161 _lhsIsyn
         _childrenOcon = rule162 arg_con_
         _rulesOcon = rule163 arg_con_
         _mergeMap = rule164 _lhsImergeMap arg_con_
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule165 _rulesIerrors
         _output = rule166 _childrenIoutput _rulesIoutput _typeSigsIoutput arg_con_ arg_constraints_ arg_macro_ arg_params_
         _lhsOoutput :: Production
         _lhsOoutput = rule167 _output
         _childrenOallfields = rule168 _allfields
         _childrenOallnts = rule169 _lhsIallnts
         _childrenOattrs = rule170 _attrs
         _childrenOinh = rule171 _lhsIinh
         _childrenOinhMap = rule172 _lhsIinhMap
         _childrenOmergeMap = rule173 _mergeMap
         _childrenOnt = rule174 _lhsInt
         _childrenOsyn = rule175 _lhsIsyn
         _childrenOsynMap = rule176 _lhsIsynMap
         _rulesOallfields = rule177 _allfields
         _rulesOallnts = rule178 _lhsIallnts
         _rulesOattrs = rule179 _attrs
         _rulesOinh = rule180 _lhsIinh
         _rulesOmergeMap = rule181 _mergeMap
         _rulesOnt = rule182 _lhsInt
         _rulesOoptions = rule183 _lhsIoptions
         _rulesOsyn = rule184 _lhsIsyn
         __result_ = T_Production_vOut25 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Production_s26 v25
   {-# INLINE rule157 #-}





   {-# INLINE rule158 #-}





   {-# INLINE rule159 #-}








   {-# INLINE rule160 #-}





   {-# INLINE rule161 #-}





   {-# INLINE rule162 #-}





   {-# INLINE rule163 #-}





   {-# INLINE rule164 #-}





   {-# INLINE rule165 #-}
   rule165 = \ ((_rulesIerrors) :: Seq Error) ->
     _rulesIerrors
   {-# INLINE rule166 #-}
   rule166 = \ ((_childrenIoutput) :: Children) ((_rulesIoutput) :: Rules) ((_typeSigsIoutput) :: TypeSigs) con_ constraints_ macro_ params_ ->
     Production con_ params_ constraints_ _childrenIoutput _rulesIoutput _typeSigsIoutput macro_
   {-# INLINE rule167 #-}
   rule167 = \ _output ->
     _output
   {-# INLINE rule168 #-}
   rule168 = \ _allfields ->
     _allfields
   {-# INLINE rule169 #-}
   rule169 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule170 #-}
   rule170 = \ _attrs ->
     _attrs
   {-# INLINE rule171 #-}
   rule171 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule172 #-}
   rule172 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule173 #-}
   rule173 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule174 #-}
   rule174 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule175 #-}
   rule175 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule176 #-}
   rule176 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule177 #-}
   rule177 = \ _allfields ->
     _allfields
   {-# INLINE rule178 #-}
   rule178 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule179 #-}
   rule179 = \ _attrs ->
     _attrs
   {-# INLINE rule180 #-}
   rule180 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule181 #-}
   rule181 = \ _mergeMap ->
     _mergeMap
   {-# INLINE rule182 #-}
   rule182 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule183 #-}
   rule183 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule184 #-}
   rule184 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn = \ con_ ->        [con_]






   rule158 = \ ((_childrenIfields) :: [(Identifier,Type,ChildKind)]) ->
   rule159 = \ ((_childrenIattributes) :: [(Identifier,Attributes,Attributes)]) _inhnames ((_rulesIinstVars) :: [Identifier]) ((_rulesIlocVars) :: [Identifier]) -> ((,) _LOC)  _rulesIlocVars ++
                                   map ((,) _INST) _rulesIinstVars ++
                                   map ((,) _LHS)  _inhnames ++
                                   concat [map ((,) nm) (Map.keys as) | (nm,_,as) <- _childrenIattributes]
   rule160 = \ ((_lhsIinh) :: Attributes) -> _lhsIinh
   rule161 = \ ((_lhsIsyn) :: Attributes) -> _lhsIsyn



























   rule162 = \ con_ ->            con_

   rule163 = \ con_ ->         con_


















   rule164 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) con_ -> Map.empty con_ _lhsImergeMap






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































-- Productions -------------------------------------------------
-- wrapper
data Inh_Productions  = Inh_Productions { allnts_Inh_Productions :: ([Identifier]), inh_Inh_Productions :: (Attributes), inhMap_Inh_Productions :: (Map Identifier Attributes), mergeMap_Inh_Productions :: (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))), nt_Inh_Productions :: (Identifier), options_Inh_Productions :: (Options), syn_Inh_Productions :: (Attributes), synMap_Inh_Productions :: (Map Identifier Attributes) }
data Syn_Productions  = Syn_Productions { cons_Syn_Productions :: ([ConstructorIdent]), errors_Syn_Productions :: (Seq Error), output_Syn_Productions :: (Productions) }
{-# INLINABLE wrap_Productions #-}
wrap_Productions :: T_Productions  -> Inh_Productions  -> (Syn_Productions )
wrap_Productions (T_Productions act) (Inh_Productions _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg28 = T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap
        (T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput) <- return (inv_Productions_s29 sem arg28)
        return (Syn_Productions _lhsOcons _lhsOerrors _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Productions #-}
sem_Productions :: Productions  -> T_Productions
sem_Productions list = Prelude.foldr sem_Productions_Cons sem_Productions_Nil (Prelude.map sem_Production list)

-- semantic domain
newtype T_Productions  = T_Productions {
                                       attach_T_Productions :: Identity (T_Productions_s29 )
                                       }
newtype T_Productions_s29  = C_Productions_s29 {
                                               inv_Productions_s29 :: (T_Productions_v28 )
                                               }
data T_Productions_s30  = C_Productions_s30
type T_Productions_v28  = (T_Productions_vIn28 ) -> (T_Productions_vOut28 )
data T_Productions_vIn28  = T_Productions_vIn28 ([Identifier]) (Attributes) (Map Identifier Attributes) (Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) (Identifier) (Options) (Attributes) (Map Identifier Attributes)
data T_Productions_vOut28  = T_Productions_vOut28 ([ConstructorIdent]) (Seq Error) (Productions)
{-# NOINLINE sem_Productions_Cons #-}
sem_Productions_Cons :: T_Production  -> T_Productions  -> T_Productions
sem_Productions_Cons arg_hd_ arg_tl_ = T_Productions (return st29) where
   {-# NOINLINE st29 #-}
   st29 = let
      v28 :: T_Productions_v28
      v28 = \ (T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _hdX26 = Control.Monad.Identity.runIdentity (attach_T_Production (arg_hd_))
         _tlX29 = Control.Monad.Identity.runIdentity (attach_T_Productions (arg_tl_))
         (T_Production_vOut25 _hdIcons _hdIerrors _hdIoutput) = inv_Production_s26 _hdX26 (T_Production_vIn25 _hdOallnts _hdOinh _hdOinhMap _hdOmergeMap _hdOnt _hdOoptions _hdOsyn _hdOsynMap)
         (T_Productions_vOut28 _tlIcons _tlIerrors _tlIoutput) = inv_Productions_s29 _tlX29 (T_Productions_vIn28 _tlOallnts _tlOinh _tlOinhMap _tlOmergeMap _tlOnt _tlOoptions _tlOsyn _tlOsynMap)
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule185 _hdIcons _tlIcons
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule186 _hdIerrors _tlIerrors
         _output = rule187 _hdIoutput _tlIoutput
         _lhsOoutput :: Productions
         _lhsOoutput = rule188 _output
         _hdOallnts = rule189 _lhsIallnts
         _hdOinh = rule190 _lhsIinh
         _hdOinhMap = rule191 _lhsIinhMap
         _hdOmergeMap = rule192 _lhsImergeMap
         _hdOnt = rule193 _lhsInt
         _hdOoptions = rule194 _lhsIoptions
         _hdOsyn = rule195 _lhsIsyn
         _hdOsynMap = rule196 _lhsIsynMap
         _tlOallnts = rule197 _lhsIallnts
         _tlOinh = rule198 _lhsIinh
         _tlOinhMap = rule199 _lhsIinhMap
         _tlOmergeMap = rule200 _lhsImergeMap
         _tlOnt = rule201 _lhsInt
         _tlOoptions = rule202 _lhsIoptions
         _tlOsyn = rule203 _lhsIsyn
         _tlOsynMap = rule204 _lhsIsynMap
         __result_ = T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Productions_s29 v28
   {-# INLINE rule185 #-}
   rule185 = \ ((_hdIcons) :: [ConstructorIdent]) ((_tlIcons) :: [ConstructorIdent]) ->
     _hdIcons ++ _tlIcons
   {-# INLINE rule186 #-}
   rule186 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule187 #-}
   rule187 = \ ((_hdIoutput) :: Production) ((_tlIoutput) :: Productions) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule188 #-}
   rule188 = \ _output ->
     _output
   {-# INLINE rule189 #-}
   rule189 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule190 #-}
   rule190 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule191 #-}
   rule191 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule192 #-}
   rule192 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) ->
     _lhsImergeMap
   {-# INLINE rule193 #-}
   rule193 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule194 #-}
   rule194 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule195 #-}
   rule195 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule196 #-}
   rule196 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
   {-# INLINE rule197 #-}
   rule197 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule198 #-}
   rule198 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule199 #-}
   rule199 = \ ((_lhsIinhMap) :: Map Identifier Attributes) ->
     _lhsIinhMap
   {-# INLINE rule200 #-}
   rule200 = \ ((_lhsImergeMap) :: Map ConstructorIdent (Map Identifier (Identifier,[Identifier]))) ->
     _lhsImergeMap
   {-# INLINE rule201 #-}
   rule201 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule202 #-}
   rule202 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule203 #-}
   rule203 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule204 #-}
   rule204 = \ ((_lhsIsynMap) :: Map Identifier Attributes) ->
     _lhsIsynMap
{-# NOINLINE sem_Productions_Nil #-}
sem_Productions_Nil ::  T_Productions
sem_Productions_Nil  = T_Productions (return st29) where
   {-# NOINLINE st29 #-}
   st29 = let
      v28 :: T_Productions_v28
      v28 = \ (T_Productions_vIn28 _lhsIallnts _lhsIinh _lhsIinhMap _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn _lhsIsynMap) -> ( let
         _lhsOcons :: [ConstructorIdent]
         _lhsOcons = rule205  ()
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule206  ()
         _output = rule207  ()
         _lhsOoutput :: Productions
         _lhsOoutput = rule208 _output
         __result_ = T_Productions_vOut28 _lhsOcons _lhsOerrors _lhsOoutput
         in __result_ )
     in C_Productions_s29 v28
   {-# INLINE rule205 #-}
   rule205 = \  (_ :: ()) ->
     []
   {-# INLINE rule206 #-}
   rule206 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule207 #-}
   rule207 = \  (_ :: ()) ->
     []
   {-# INLINE rule208 #-}
   rule208 = \ _output ->
     _output

-- Rule --------------------------------------------------------
-- wrapper
data Inh_Rule  = Inh_Rule { allfields_Inh_Rule :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Rule :: ([Identifier]), attrs_Inh_Rule :: ([(Identifier,Identifier)]), con_Inh_Rule :: (Identifier), inh_Inh_Rule :: (Attributes), mergeMap_Inh_Rule :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Rule :: (Identifier), options_Inh_Rule :: (Options), syn_Inh_Rule :: (Attributes) }
data Syn_Rule  = Syn_Rule { errors_Syn_Rule :: (Seq Error), instVars_Syn_Rule :: ([Identifier]), locVars_Syn_Rule :: ([Identifier]), output_Syn_Rule :: (Rule) }
{-# INLINABLE wrap_Rule #-}
wrap_Rule :: T_Rule  -> Inh_Rule  -> (Syn_Rule )
wrap_Rule (T_Rule act) (Inh_Rule _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg31 = T_Rule_vIn31 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn
        (T_Rule_vOut31 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Rule_s32 sem arg31)
        return (Syn_Rule _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# INLINE sem_Rule #-}
sem_Rule :: Rule  -> T_Rule
sem_Rule ( Rule mbName_ pattern_ rhs_ owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_ ) = sem_Rule_Rule mbName_ ( sem_Pattern pattern_ ) ( sem_Expression rhs_ ) owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_

-- semantic domain
newtype T_Rule  = T_Rule {
                         attach_T_Rule :: Identity (T_Rule_s32 )
                         }
newtype T_Rule_s32  = C_Rule_s32 {
                                 inv_Rule_s32 :: (T_Rule_v31 )
                                 }
data T_Rule_s33  = C_Rule_s33
type T_Rule_v31  = (T_Rule_vIn31 ) -> (T_Rule_vOut31 )
data T_Rule_vIn31  = T_Rule_vIn31 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options) (Attributes)
data T_Rule_vOut31  = T_Rule_vOut31 (Seq Error) ([Identifier]) ([Identifier]) (Rule)
{-# NOINLINE sem_Rule_Rule #-}
sem_Rule_Rule :: (Maybe Identifier) -> T_Pattern  -> T_Expression  -> (Bool) -> (String) -> (Bool) -> (Bool) -> (Bool) -> (Maybe Error) -> (Bool) -> T_Rule
sem_Rule_Rule arg_mbName_ arg_pattern_ arg_rhs_ arg_owrt_ arg_origin_ arg_explicit_ arg_pure_ arg_identity_ arg_mbError_ arg_eager_ = T_Rule (return st32) where
   {-# NOINLINE st32 #-}
   st32 = let
      v31 :: T_Rule_v31
      v31 = \ (T_Rule_vIn31 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _patternX20 = Control.Monad.Identity.runIdentity (attach_T_Pattern (arg_pattern_))
         _rhsX8 = Control.Monad.Identity.runIdentity (attach_T_Expression (arg_rhs_))
         (T_Pattern_vOut19 _patternIcopy _patternIerrors _patternIinstVars _patternIlocVars _patternIoutput) = inv_Pattern_s20 _patternX20 (T_Pattern_vIn19 _patternOcon _patternOinh _patternOnt _patternOsyn)
         (T_Expression_vOut7 _rhsIerrors _rhsIoutput) = inv_Expression_s8 _rhsX8 (T_Expression_vIn7 _rhsOallfields _rhsOallnts _rhsOattrs _rhsOcon _rhsOmergeMap _rhsOnt _rhsOoptions)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule209 _patternIerrors _rhsIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule210 _patternIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule211 _patternIlocVars
         _output = rule212 _patternIoutput _rhsIoutput arg_eager_ arg_explicit_ arg_identity_ arg_mbError_ arg_mbName_ arg_origin_ arg_owrt_ arg_pure_
         _lhsOoutput :: Rule
         _lhsOoutput = rule213 _output
         _patternOcon = rule214 _lhsIcon
         _patternOinh = rule215 _lhsIinh
         _patternOnt = rule216 _lhsInt
         _patternOsyn = rule217 _lhsIsyn
         _rhsOallfields = rule218 _lhsIallfields
         _rhsOallnts = rule219 _lhsIallnts
         _rhsOattrs = rule220 _lhsIattrs
         _rhsOcon = rule221 _lhsIcon
         _rhsOmergeMap = rule222 _lhsImergeMap
         _rhsOnt = rule223 _lhsInt
         _rhsOoptions = rule224 _lhsIoptions
         __result_ = T_Rule_vOut31 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rule_s32 v31
   {-# INLINE rule209 #-}
   rule209 = \ ((_patternIerrors) :: Seq Error) ((_rhsIerrors) :: Seq Error) ->
     _patternIerrors Seq.>< _rhsIerrors
   {-# INLINE rule210 #-}
   rule210 = \ ((_patternIinstVars) :: [Identifier]) ->
     _patternIinstVars
   {-# INLINE rule211 #-}
   rule211 = \ ((_patternIlocVars) :: [Identifier]) ->
     _patternIlocVars
   {-# INLINE rule212 #-}
   rule212 = \ ((_patternIoutput) :: Pattern) ((_rhsIoutput) :: Expression) eager_ explicit_ identity_ mbError_ mbName_ origin_ owrt_ pure_ ->
     Rule mbName_ _patternIoutput _rhsIoutput owrt_ origin_ explicit_ pure_ identity_ mbError_ eager_
   {-# INLINE rule213 #-}
   rule213 = \ _output ->
     _output
   {-# INLINE rule214 #-}
   rule214 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule215 #-}
   rule215 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule216 #-}
   rule216 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule217 #-}
   rule217 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule218 #-}
   rule218 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule219 #-}
   rule219 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule220 #-}
   rule220 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule221 #-}
   rule221 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule222 #-}
   rule222 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule223 #-}
   rule223 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule224 #-}
   rule224 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions

-- Rules -------------------------------------------------------
-- wrapper
data Inh_Rules  = Inh_Rules { allfields_Inh_Rules :: ([(Identifier,Type,ChildKind)]), allnts_Inh_Rules :: ([Identifier]), attrs_Inh_Rules :: ([(Identifier,Identifier)]), con_Inh_Rules :: (Identifier), inh_Inh_Rules :: (Attributes), mergeMap_Inh_Rules :: (Map Identifier (Identifier,[Identifier])), nt_Inh_Rules :: (Identifier), options_Inh_Rules :: (Options), syn_Inh_Rules :: (Attributes) }
data Syn_Rules  = Syn_Rules { errors_Syn_Rules :: (Seq Error), instVars_Syn_Rules :: ([Identifier]), locVars_Syn_Rules :: ([Identifier]), output_Syn_Rules :: (Rules) }
{-# INLINABLE wrap_Rules #-}
wrap_Rules :: T_Rules  -> Inh_Rules  -> (Syn_Rules )
wrap_Rules (T_Rules act) (Inh_Rules _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg34 = T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn
        (T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput) <- return (inv_Rules_s35 sem arg34)
        return (Syn_Rules _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_Rules #-}
sem_Rules :: Rules  -> T_Rules
sem_Rules list = Prelude.foldr sem_Rules_Cons sem_Rules_Nil (Prelude.map sem_Rule list)

-- semantic domain
newtype T_Rules  = T_Rules {
                           attach_T_Rules :: Identity (T_Rules_s35 )
                           }
newtype T_Rules_s35  = C_Rules_s35 {
                                   inv_Rules_s35 :: (T_Rules_v34 )
                                   }
data T_Rules_s36  = C_Rules_s36
type T_Rules_v34  = (T_Rules_vIn34 ) -> (T_Rules_vOut34 )
data T_Rules_vIn34  = T_Rules_vIn34 ([(Identifier,Type,ChildKind)]) ([Identifier]) ([(Identifier,Identifier)]) (Identifier) (Attributes) (Map Identifier (Identifier,[Identifier])) (Identifier) (Options) (Attributes)
data T_Rules_vOut34  = T_Rules_vOut34 (Seq Error) ([Identifier]) ([Identifier]) (Rules)
{-# NOINLINE sem_Rules_Cons #-}
sem_Rules_Cons :: T_Rule  -> T_Rules  -> T_Rules
sem_Rules_Cons arg_hd_ arg_tl_ = T_Rules (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_Rules_v34
      v34 = \ (T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _hdX32 = Control.Monad.Identity.runIdentity (attach_T_Rule (arg_hd_))
         _tlX35 = Control.Monad.Identity.runIdentity (attach_T_Rules (arg_tl_))
         (T_Rule_vOut31 _hdIerrors _hdIinstVars _hdIlocVars _hdIoutput) = inv_Rule_s32 _hdX32 (T_Rule_vIn31 _hdOallfields _hdOallnts _hdOattrs _hdOcon _hdOinh _hdOmergeMap _hdOnt _hdOoptions _hdOsyn)
         (T_Rules_vOut34 _tlIerrors _tlIinstVars _tlIlocVars _tlIoutput) = inv_Rules_s35 _tlX35 (T_Rules_vIn34 _tlOallfields _tlOallnts _tlOattrs _tlOcon _tlOinh _tlOmergeMap _tlOnt _tlOoptions _tlOsyn)
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule225 _hdIerrors _tlIerrors
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule226 _hdIinstVars _tlIinstVars
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule227 _hdIlocVars _tlIlocVars
         _output = rule228 _hdIoutput _tlIoutput
         _lhsOoutput :: Rules
         _lhsOoutput = rule229 _output
         _hdOallfields = rule230 _lhsIallfields
         _hdOallnts = rule231 _lhsIallnts
         _hdOattrs = rule232 _lhsIattrs
         _hdOcon = rule233 _lhsIcon
         _hdOinh = rule234 _lhsIinh
         _hdOmergeMap = rule235 _lhsImergeMap
         _hdOnt = rule236 _lhsInt
         _hdOoptions = rule237 _lhsIoptions
         _hdOsyn = rule238 _lhsIsyn
         _tlOallfields = rule239 _lhsIallfields
         _tlOallnts = rule240 _lhsIallnts
         _tlOattrs = rule241 _lhsIattrs
         _tlOcon = rule242 _lhsIcon
         _tlOinh = rule243 _lhsIinh
         _tlOmergeMap = rule244 _lhsImergeMap
         _tlOnt = rule245 _lhsInt
         _tlOoptions = rule246 _lhsIoptions
         _tlOsyn = rule247 _lhsIsyn
         __result_ = T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rules_s35 v34
   {-# INLINE rule225 #-}
   rule225 = \ ((_hdIerrors) :: Seq Error) ((_tlIerrors) :: Seq Error) ->
     _hdIerrors Seq.>< _tlIerrors
   {-# INLINE rule226 #-}
   rule226 = \ ((_hdIinstVars) :: [Identifier]) ((_tlIinstVars) :: [Identifier]) ->
     _hdIinstVars ++ _tlIinstVars
   {-# INLINE rule227 #-}
   rule227 = \ ((_hdIlocVars) :: [Identifier]) ((_tlIlocVars) :: [Identifier]) ->
     _hdIlocVars ++ _tlIlocVars
   {-# INLINE rule228 #-}
   rule228 = \ ((_hdIoutput) :: Rule) ((_tlIoutput) :: Rules) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule229 #-}
   rule229 = \ _output ->
     _output
   {-# INLINE rule230 #-}
   rule230 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule231 #-}
   rule231 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule232 #-}
   rule232 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule233 #-}
   rule233 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule234 #-}
   rule234 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule235 #-}
   rule235 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule236 #-}
   rule236 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule237 #-}
   rule237 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule238 #-}
   rule238 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
   {-# INLINE rule239 #-}
   rule239 = \ ((_lhsIallfields) :: [(Identifier,Type,ChildKind)]) ->
     _lhsIallfields
   {-# INLINE rule240 #-}
   rule240 = \ ((_lhsIallnts) :: [Identifier]) ->
     _lhsIallnts
   {-# INLINE rule241 #-}
   rule241 = \ ((_lhsIattrs) :: [(Identifier,Identifier)]) ->
     _lhsIattrs
   {-# INLINE rule242 #-}
   rule242 = \ ((_lhsIcon) :: Identifier) ->
     _lhsIcon
   {-# INLINE rule243 #-}
   rule243 = \ ((_lhsIinh) :: Attributes) ->
     _lhsIinh
   {-# INLINE rule244 #-}
   rule244 = \ ((_lhsImergeMap) :: Map Identifier (Identifier,[Identifier])) ->
     _lhsImergeMap
   {-# INLINE rule245 #-}
   rule245 = \ ((_lhsInt) :: Identifier) ->
     _lhsInt
   {-# INLINE rule246 #-}
   rule246 = \ ((_lhsIoptions) :: Options) ->
     _lhsIoptions
   {-# INLINE rule247 #-}
   rule247 = \ ((_lhsIsyn) :: Attributes) ->
     _lhsIsyn
{-# NOINLINE sem_Rules_Nil #-}
sem_Rules_Nil ::  T_Rules
sem_Rules_Nil  = T_Rules (return st35) where
   {-# NOINLINE st35 #-}
   st35 = let
      v34 :: T_Rules_v34
      v34 = \ (T_Rules_vIn34 _lhsIallfields _lhsIallnts _lhsIattrs _lhsIcon _lhsIinh _lhsImergeMap _lhsInt _lhsIoptions _lhsIsyn) -> ( let
         _lhsOerrors :: Seq Error
         _lhsOerrors = rule248  ()
         _lhsOinstVars :: [Identifier]
         _lhsOinstVars = rule249  ()
         _lhsOlocVars :: [Identifier]
         _lhsOlocVars = rule250  ()
         _output = rule251  ()
         _lhsOoutput :: Rules
         _lhsOoutput = rule252 _output
         __result_ = T_Rules_vOut34 _lhsOerrors _lhsOinstVars _lhsOlocVars _lhsOoutput
         in __result_ )
     in C_Rules_s35 v34
   {-# INLINE rule248 #-}
   rule248 = \  (_ :: ()) ->
     Seq.empty
   {-# INLINE rule249 #-}
   rule249 = \  (_ :: ()) ->
     []
   {-# INLINE rule250 #-}
   rule250 = \  (_ :: ()) ->
     []
   {-# INLINE rule251 #-}
   rule251 = \  (_ :: ()) ->
     []
   {-# INLINE rule252 #-}
   rule252 = \ _output ->
     _output

-- TypeSig -----------------------------------------------------
-- wrapper
data Inh_TypeSig  = Inh_TypeSig {  }
data Syn_TypeSig  = Syn_TypeSig { output_Syn_TypeSig :: (TypeSig) }
{-# INLINABLE wrap_TypeSig #-}
wrap_TypeSig :: T_TypeSig  -> Inh_TypeSig  -> (Syn_TypeSig )
wrap_TypeSig (T_TypeSig act) (Inh_TypeSig ) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg37 = T_TypeSig_vIn37
        (T_TypeSig_vOut37 _lhsOoutput) <- return (inv_TypeSig_s38 sem arg37)
        return (Syn_TypeSig _lhsOoutput)
   )

-- cata
{-# INLINE sem_TypeSig #-}
sem_TypeSig :: TypeSig  -> T_TypeSig
sem_TypeSig ( TypeSig name_ tp_ ) = sem_TypeSig_TypeSig name_ tp_

-- semantic domain
newtype T_TypeSig  = T_TypeSig {
                               attach_T_TypeSig :: Identity (T_TypeSig_s38 )
                               }
newtype T_TypeSig_s38  = C_TypeSig_s38 {
                                       inv_TypeSig_s38 :: (T_TypeSig_v37 )
                                       }
data T_TypeSig_s39  = C_TypeSig_s39
type T_TypeSig_v37  = (T_TypeSig_vIn37 ) -> (T_TypeSig_vOut37 )
data T_TypeSig_vIn37  = T_TypeSig_vIn37
data T_TypeSig_vOut37  = T_TypeSig_vOut37 (TypeSig)
{-# NOINLINE sem_TypeSig_TypeSig #-}
sem_TypeSig_TypeSig :: (Identifier) -> (Type) -> T_TypeSig
sem_TypeSig_TypeSig arg_name_ arg_tp_ = T_TypeSig (return st38) where
   {-# NOINLINE st38 #-}
   st38 = let
      v37 :: T_TypeSig_v37
      v37 = \ (T_TypeSig_vIn37 ) -> ( let
         _output = rule253 arg_name_ arg_tp_
         _lhsOoutput :: TypeSig
         _lhsOoutput = rule254 _output
         __result_ = T_TypeSig_vOut37 _lhsOoutput
         in __result_ )
     in C_TypeSig_s38 v37
   {-# INLINE rule253 #-}
   rule253 = \ name_ tp_ ->
     TypeSig name_ tp_
   {-# INLINE rule254 #-}
   rule254 = \ _output ->
     _output

-- TypeSigs ----------------------------------------------------
-- wrapper
data Inh_TypeSigs  = Inh_TypeSigs {  }
data Syn_TypeSigs  = Syn_TypeSigs { output_Syn_TypeSigs :: (TypeSigs) }
{-# INLINABLE wrap_TypeSigs #-}
wrap_TypeSigs :: T_TypeSigs  -> Inh_TypeSigs  -> (Syn_TypeSigs )
wrap_TypeSigs (T_TypeSigs act) (Inh_TypeSigs ) =
   Control.Monad.Identity.runIdentity (
     do sem <- act
        let arg40 = T_TypeSigs_vIn40
        (T_TypeSigs_vOut40 _lhsOoutput) <- return (inv_TypeSigs_s41 sem arg40)
        return (Syn_TypeSigs _lhsOoutput)
   )

-- cata
{-# NOINLINE sem_TypeSigs #-}
sem_TypeSigs :: TypeSigs  -> T_TypeSigs
sem_TypeSigs list = Prelude.foldr sem_TypeSigs_Cons sem_TypeSigs_Nil (Prelude.map sem_TypeSig list)

-- semantic domain
newtype T_TypeSigs  = T_TypeSigs {
                                 attach_T_TypeSigs :: Identity (T_TypeSigs_s41 )
                                 }
newtype T_TypeSigs_s41  = C_TypeSigs_s41 {
                                         inv_TypeSigs_s41 :: (T_TypeSigs_v40 )
                                         }
data T_TypeSigs_s42  = C_TypeSigs_s42
type T_TypeSigs_v40  = (T_TypeSigs_vIn40 ) -> (T_TypeSigs_vOut40 )
data T_TypeSigs_vIn40  = T_TypeSigs_vIn40
data T_TypeSigs_vOut40  = T_TypeSigs_vOut40 (TypeSigs)
{-# NOINLINE sem_TypeSigs_Cons #-}
sem_TypeSigs_Cons :: T_TypeSig  -> T_TypeSigs  -> T_TypeSigs
sem_TypeSigs_Cons arg_hd_ arg_tl_ = T_TypeSigs (return st41) where
   {-# NOINLINE st41 #-}
   st41 = let
      v40 :: T_TypeSigs_v40
      v40 = \ (T_TypeSigs_vIn40 ) -> ( let
         _hdX38 = Control.Monad.Identity.runIdentity (attach_T_TypeSig (arg_hd_))
         _tlX41 = Control.Monad.Identity.runIdentity (attach_T_TypeSigs (arg_tl_))
         (T_TypeSig_vOut37 _hdIoutput) = inv_TypeSig_s38 _hdX38 (T_TypeSig_vIn37 )
         (T_TypeSigs_vOut40 _tlIoutput) = inv_TypeSigs_s41 _tlX41 (T_TypeSigs_vIn40 )
         _output = rule255 _hdIoutput _tlIoutput
         _lhsOoutput :: TypeSigs
         _lhsOoutput = rule256 _output
         __result_ = T_TypeSigs_vOut40 _lhsOoutput
         in __result_ )
     in C_TypeSigs_s41 v40
   {-# INLINE rule255 #-}
   rule255 = \ ((_hdIoutput) :: TypeSig) ((_tlIoutput) :: TypeSigs) ->
     (:) _hdIoutput _tlIoutput
   {-# INLINE rule256 #-}
   rule256 = \ _output ->
     _output
{-# NOINLINE sem_TypeSigs_Nil #-}
sem_TypeSigs_Nil ::  T_TypeSigs
sem_TypeSigs_Nil  = T_TypeSigs (return st41) where
   {-# NOINLINE st41 #-}
   st41 = let
      v40 :: T_TypeSigs_v40
      v40 = \ (T_TypeSigs_vIn40 ) -> ( let
         _output = rule257  ()
         _lhsOoutput :: TypeSigs
         _lhsOoutput = rule258 _output
         __result_ = T_TypeSigs_vOut40 _lhsOoutput
         in __result_ )
     in C_TypeSigs_s41 v40
   {-# INLINE rule257 #-}
   rule257 = \  (_ :: ()) ->
     []
   {-# INLINE rule258 #-}
   rule258 = \ _output ->
     _output

</pre>