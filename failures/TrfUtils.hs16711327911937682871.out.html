<a href="Trf.hs20209497541501154526.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Trie.hs843998877959637304.out.html">next</a></br></br><pre>20c20
< {-# LINE 24 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
20a21
> 
20a22
> 
20a23
> 
47c50
< {-# LINE 52 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
47a51
> 
54c58
< {-# LINE 64 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
54a59
> 
54a60
> 
54a61
> 
54a62
> 
54a63
> 
68c77
< {-# LINE 83 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
68a78
> 
68a79
> 
68a80
> 
68a81
> 
68a82
> 
79c93
< {-# LINE 95 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
79a94
> 
90c105
< {-# LINE 107 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
90a106
> 
101c117
< {-# LINE 119 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
101a118
> 
112c129
< {-# LINE 131 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
112a130
> 
135c153
< {-# LINE 159 "src/ehc/CodeGen/TrfUtils.chs" #-}
---
> 
135a154
> 
135a155
> 
135a156
> 
135a157
> 
135a158
> 
144a168
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.CodeGen.TrfUtils
( TrfState (..), mkEmptyTrfState
, runTrf
, liftTrfModPlain
, liftCheckMod
, liftTrfModWithState
, liftTrfModWithStateExtra
, liftTrfWithExtraInfo
, modifyGets )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import Control.Monad.State.Strict
import Control.Monad.Reader
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common

{-# LINE 24 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Environmental info for transformations. TBD 20140409: sort out what is really necessary
data TrfReader
  = TrfReader
      { trfrdMustDump           :: EHCOpts -> Bool              -- ^ must dump?
      , trfrdCanDoOptScope      :: [OptimizationScope] -> Bool  -- ^ trf must be done for this optimization scope?
      , trfrdOpts               :: EHCOpts                      -- ^ global options
      , trfrdModNm              :: HsName                       -- ^ module name
      }

-- | State info for transformations
data TrfState
        mod     -- module structure
        extra   -- extra state info, extension
  = TrfState
      { trfstMod                :: !mod                         -- ^ most recent transformed module
      , trfstModStages          :: [(String,Maybe mod,ErrL)]    -- ^ intermediate stages with errors, if dumping also with module
      , trfstUniq               :: !UID                         -- ^ unique counter, threaded in/out
      , trfstExtra              :: extra                        -- ^ optional extension of state info
      }

mkEmptyTrfState :: mod -> extra -> TrfState mod extra
mkEmptyTrfState m e = TrfState m [] uidStart e

-- | The monad for transformations
type TrfM mod extra = ReaderT TrfReader (State (TrfState mod extra))

{-# LINE 52 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Freshness
instance MonadFreshUID (TrfM mod extra) where
  freshInfUID = modifyGets $ \s@(TrfState{trfstUniq=u}) ->
    let (n,h) = mkNewLevUID u
    in  (h,s {trfstUniq = n})

{-# LINE 64 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Run transformations.
--   The 'optimScope' tells at which compilation phase (per module, whole program) the transformations are done, default only per module
runTrf
  :: EHCOpts
     -> HsName
     -> (EHCOpts -> Bool)                               -- ^ need to dump?
     -> ([OptimizationScope] -> Bool)                   -- ^ can run for optimization scope?
     -> TrfState mod extra
     -> (TrfM mod extra ())
     -> TrfState mod extra
runTrf opts modNm mustDump canDoWRTOptScope trfst trf
  = execState (runReaderT trf (TrfReader mustDump canDoWRTOptScope opts modNm)) trfst

{-# LINE 83 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Lift a module transformation function to the state monad
liftTrfModPlain
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                            -- ^ only when in this optimization scope, ie limiting the run
     -> String                                      -- ^ name of trf
     -> (mod -> mod)                                -- ^ trf
     -> m ()
liftTrfModPlain os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\_ c -> (Just $ t c,(),[]))

{-# LINE 95 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Only check
liftCheckMod
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (TrfState mod extra -> mod -> ErrL)             -- ^ check
     -> m ()
liftCheckMod os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\s c -> let e = t s c in (Nothing,(),e))

{-# LINE 107 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Lift a module transformation function taking also state to the state monad
liftTrfModWithState
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (TrfState mod extra -> mod -> mod)              -- ^ trf
     -> m ()
liftTrfModWithState os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\s c -> (Just $ t s c,(),[]))

{-# LINE 119 "src/ehc/CodeGen/TrfUtils.chs" #-}
liftTrfModWithStateExtra
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (t -> TrfState mod extra -> TrfState mod extra) -- ^ state update with extra info
     -> (TrfState mod extra -> mod -> (mod,t))          -- ^ trf
     -> m ()
liftTrfModWithStateExtra os nm update2 t
  = liftTrfWithExtraInfo os nm update2 (\s c -> let (c',e) = t s c in (Just c',e,[]))

{-# LINE 131 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Lift a module transformation function dealing with some arbitrary extra info to the state monad, factoring out yes/no dumping and error gathering
liftTrfWithExtraInfo
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (t -> TrfState mod extra -> TrfState mod extra)             -- ^ state update with extra info
     -> (TrfState mod extra -> mod -> (Maybe mod, t, ErrL)) -- ^ trf, dealing with extra info as well
     -> m ()
liftTrfWithExtraInfo os nm update2 t = do
  canDoWRTOptScope <- asks trfrdCanDoOptScope
  opts <- asks trfrdOpts
  if canDoWRTOptScope os
    then do
      mustDump <- asks trfrdMustDump
      modify $ \s@(TrfState{trfstMod=c, trfstModStages=stages}) ->
        let (c',extra,errl) = t s c
        in  update2 extra
            $ s { trfstMod           = maybe c id c'
                , trfstModStages     = stages ++ [(nm,if mustDump opts then c' else Nothing,errl)]
                }
    else return ()

{-# LINE 159 "src/ehc/CodeGen/TrfUtils.chs" #-}
-- | Combi of modify and get: modify and also return newly set value. TBD 20140409: get rid of this...?
modifyGets :: MonadState s m => (s -> (a,s)) -> m a
modifyGets update
  = do { s <- get
       ; let (x,s') = update s
       ; put s'
       ; return x
       }

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.CodeGen.TrfUtils
( TrfState (..), mkEmptyTrfState
, runTrf
, liftTrfModPlain
, liftCheckMod
, liftTrfModWithState
, liftTrfModWithStateExtra
, liftTrfWithExtraInfo
, modifyGets )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import Control.Monad.State.Strict
import Control.Monad.Reader
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common





-- | Environmental info for transformations. TBD 20140409: sort out what is really necessary
data TrfReader
  = TrfReader
      { trfrdMustDump           :: EHCOpts -> Bool              -- ^ must dump?
      , trfrdCanDoOptScope      :: [OptimizationScope] -> Bool  -- ^ trf must be done for this optimization scope?
      , trfrdOpts               :: EHCOpts                      -- ^ global options
      , trfrdModNm              :: HsName                       -- ^ module name
      }

-- | State info for transformations
data TrfState
        mod     -- module structure
        extra   -- extra state info, extension
  = TrfState
      { trfstMod                :: !mod                         -- ^ most recent transformed module
      , trfstModStages          :: [(String,Maybe mod,ErrL)]    -- ^ intermediate stages with errors, if dumping also with module
      , trfstUniq               :: !UID                         -- ^ unique counter, threaded in/out
      , trfstExtra              :: extra                        -- ^ optional extension of state info
      }

mkEmptyTrfState :: mod -> extra -> TrfState mod extra
mkEmptyTrfState m e = TrfState m [] uidStart e

-- | The monad for transformations
type TrfM mod extra = ReaderT TrfReader (State (TrfState mod extra))



-- | Freshness
instance MonadFreshUID (TrfM mod extra) where
  freshInfUID = modifyGets $ \s@(TrfState{trfstUniq=u}) ->
    let (n,h) = mkNewLevUID u
    in  (h,s {trfstUniq = n})







-- | Run transformations.
--   The 'optimScope' tells at which compilation phase (per module, whole program) the transformations are done, default only per module
runTrf
  :: EHCOpts
     -> HsName
     -> (EHCOpts -> Bool)                               -- ^ need to dump?
     -> ([OptimizationScope] -> Bool)                   -- ^ can run for optimization scope?
     -> TrfState mod extra
     -> (TrfM mod extra ())
     -> TrfState mod extra
runTrf opts modNm mustDump canDoWRTOptScope trfst trf
  = execState (runReaderT trf (TrfReader mustDump canDoWRTOptScope opts modNm)) trfst







-- | Lift a module transformation function to the state monad
liftTrfModPlain
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                            -- ^ only when in this optimization scope, ie limiting the run
     -> String                                      -- ^ name of trf
     -> (mod -> mod)                                -- ^ trf
     -> m ()
liftTrfModPlain os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\_ c -> (Just $ t c,(),[]))



-- | Only check
liftCheckMod
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (TrfState mod extra -> mod -> ErrL)             -- ^ check
     -> m ()
liftCheckMod os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\s c -> let e = t s c in (Nothing,(),e))



-- | Lift a module transformation function taking also state to the state monad
liftTrfModWithState
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (TrfState mod extra -> mod -> mod)              -- ^ trf
     -> m ()
liftTrfModWithState os nm t
  = liftTrfWithExtraInfo os nm (flip const) (\s c -> (Just $ t s c,(),[]))



liftTrfModWithStateExtra
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (t -> TrfState mod extra -> TrfState mod extra) -- ^ state update with extra info
     -> (TrfState mod extra -> mod -> (mod,t))          -- ^ trf
     -> m ()
liftTrfModWithStateExtra os nm update2 t
  = liftTrfWithExtraInfo os nm update2 (\s c -> let (c',e) = t s c in (Just c',e,[]))



-- | Lift a module transformation function dealing with some arbitrary extra info to the state monad, factoring out yes/no dumping and error gathering
liftTrfWithExtraInfo
  :: (MonadState (TrfState mod extra) m, MonadReader TrfReader m) =>
     [OptimizationScope]                                -- ^ only when in this optimization scope
     -> String                                          -- ^ name of trf
     -> (t -> TrfState mod extra -> TrfState mod extra)             -- ^ state update with extra info
     -> (TrfState mod extra -> mod -> (Maybe mod, t, ErrL)) -- ^ trf, dealing with extra info as well
     -> m ()
liftTrfWithExtraInfo os nm update2 t = do
  canDoWRTOptScope <- asks trfrdCanDoOptScope
  opts <- asks trfrdOpts
  if canDoWRTOptScope os
    then do
      mustDump <- asks trfrdMustDump
      modify $ \s@(TrfState{trfstMod=c, trfstModStages=stages}) ->
        let (c',extra,errl) = t s c
        in  update2 extra
            $ s { trfstMod           = maybe c id c'
                , trfstModStages     = stages ++ [(nm,if mustDump opts then c' else Nothing,errl)]
                }
    else return ()







-- | Combi of modify and get: modify and also return newly set value. TBD 20140409: get rid of this...?
modifyGets :: MonadState s m => (s -> (a,s)) -> m a
modifyGets update
  = do { s <- get
       ; let (x,s') = update s
       ; put s'
       ; return x
       }


</pre>