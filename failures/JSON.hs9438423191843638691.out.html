<a href="JSON.hs21414207211179617774.out.html">prev</a></br><a href="failures.html">home</a></br><a href="JSONTests.hs2668985141817469862.out.html">next</a></br></br><pre>27c27
< instance FromJSON (PlainRec '[]) where
---
> instance FromJSON (PlainRec    ) where
32d31
<         FromJSON (PlainRec ((sym ::: a) ': (fields :: [*]))) where
33c32
<     parseJSON (Object v) = ((<+>) :: PlainRec '[sym ::: a]
---
>         FromJSON (PlainRec ((sym ::: a)  : (fields :: [*]))) where
33a33
>     parseJSON (Object v) = ((<+>) :: PlainRec  '[sym ::: a]
35c35
<                                   -> PlainRec  ((sym ::: a) ': fields))
---
>                                   -> PlainRec  ((sym ::: a)  : fields))
46a47
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds
   , TypeOperators
   , OverloadedStrings
   , FlexibleInstances
   , ScopedTypeVariables
   , KindSignatures
   , FlexibleContexts
   #-}
{-| This adds and instance of FromJSON to SimpleRecords
 -
 -}
module Data.Vinyl.JSON where

import Control.Applicative
import Control.Monad

import Data.Vinyl

-- import Data.ByteString as L
import Data.Aeson

import Data.Text as T

import GHC.TypeLits
-- import Data.Proxy

instance FromJSON (PlainRec '[]) where
    parseJSON (Object v) = pure RNil
    parseJSON _ = mzero

instance (KnownSymbol sym, FromJSON a, FromJSON (PlainRec fields)) =>
        FromJSON (PlainRec ((sym ::: a) ': (fields :: [*]))) where
    parseJSON (Object v) = ((<+>) :: PlainRec '[sym ::: a]
                                  -> PlainRec fields
                                  -> PlainRec  ((sym ::: a) ': fields))
                                <$> ((field =:) <$> (v .: json_name))
                                <*> rest_rec
        where field = Field :: (sym ::: a)
              json_name = T.pack $ show field
              rest_rec = parseJSON (Object v)
              -- I had to type (<+>) because I can't say the type of rest_rec,
              -- as it uses an internal type
              -- rest_rec :: Data.Aeson.Types.Internal.Parser (PlainRec (fields))
              -- but I needed to type rest_rec's result record to have it parse


</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds
   , TypeOperators
   , OverloadedStrings
   , FlexibleInstances
   , ScopedTypeVariables
   , KindSignatures
   , FlexibleContexts
   #-}
{-| This adds and instance of FromJSON to SimpleRecords
 -
 -}
module Data.Vinyl.JSON where

import Control.Applicative
import Control.Monad

import Data.Vinyl

-- import Data.ByteString as L
import Data.Aeson

import Data.Text as T

import GHC.TypeLits
-- import Data.Proxy

instance FromJSON (PlainRec    ) where
    parseJSON (Object v) = pure RNil
    parseJSON _ = mzero

instance (KnownSymbol sym, FromJSON a, FromJSON (PlainRec fields)) =>
        FromJSON (PlainRec ((sym ::: a)  : (fields :: [*]))) where
    parseJSON (Object v) = ((<+>) :: PlainRec  '[sym ::: a]
                                  -> PlainRec fields
                                  -> PlainRec  ((sym ::: a)  : fields))
                                <$> ((field =:) <$> (v .: json_name))
                                <*> rest_rec
        where field = Field :: (sym ::: a)
              json_name = T.pack $ show field
              rest_rec = parseJSON (Object v)
              -- I had to type (<+>) because I can't say the type of rest_rec,
              -- as it uses an internal type
              -- rest_rec :: Data.Aeson.Types.Internal.Parser (PlainRec (fields))
              -- but I needed to type rest_rec's result record to have it parse



</pre>