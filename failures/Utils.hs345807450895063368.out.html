<a href="Utils.hs261433719164973471.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Utils.hs771761420192958060.out.html">next</a></br></br><pre>21c21
< {-# LINE 66 "src/ehc/Gam/Utils.chs" #-}
---
> 
21a22
> 
21a23
> 
21a24
> 
21a25
> 
21a26
> 
21a27
> 
21a28
> 
21a29
> 
21a30
> 
21a31
> 
21a32
> 
21a33
> 
21a34
> 
21a35
> 
21a36
> 
21a37
> 
21a38
> 
21a39
> 
21a40
> 
21a41
> 
21a42
> 
21a43
> 
21a44
> 
21a45
> 
21a46
> 
21a47
> 
21a48
> 
21a49
> 
21a50
> 
21a51
> 
21a52
> 
21a53
> 
21a54
> 
21a55
> 
21a56
> 
21a57
> 
21a58
> 
21a59
> 
21a60
> 
21a61
> 
21a62
> 
21a63
> 
21a64
> 
21a65
> 
31a76
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Gam.Utils
( mentrelFilterMpExtendViaValGam )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty.FitsIn
import UHC.Light.Compiler.Error
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import qualified Data.Map as Map
import qualified Data.Set as Set
import UHC.Light.Compiler.Ty.UsedNames
import UHC.Light.Compiler.Module.ImportExport
import UHC.Light.Compiler.Gam.ValGam


{-# LINE 66 "src/ehc/Gam/Utils.chs" #-}
-- | Lookup indirectly used identifiers, type constants from types of value bindings.
mentrelFilterMpExtendViaValGam :: HsName -> ValGam -> ModEntRelFilterMp -> ModEntRelFilterMp
mentrelFilterMpExtendViaValGam moduleNm valGam mentrelFilterMp
  = mentrelFilterMpUnions
      (   [ mentrelFilterMp ]
       ++ [ maybe Map.empty (tyUsedNames moduleNm . vgiTy) $ valGamLookup n valGam
          | n <- Set.toList $ Map.findWithDefault Set.empty IdOcc_Val mentrelFilterMp
          ]
      )

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Gam.Utils
( mentrelFilterMpExtendViaValGam )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty.FitsIn
import UHC.Light.Compiler.Error
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Substitutable
import qualified Data.Map as Map
import qualified Data.Set as Set
import UHC.Light.Compiler.Ty.UsedNames
import UHC.Light.Compiler.Module.ImportExport
import UHC.Light.Compiler.Gam.ValGam















































-- | Lookup indirectly used identifiers, type constants from types of value bindings.
mentrelFilterMpExtendViaValGam :: HsName -> ValGam -> ModEntRelFilterMp -> ModEntRelFilterMp
mentrelFilterMpExtendViaValGam moduleNm valGam mentrelFilterMp
  = mentrelFilterMpUnions
      (   [ mentrelFilterMp ]
       ++ [ maybe Map.empty (tyUsedNames moduleNm . vgiTy) $ valGamLookup n valGam
          | n <- Set.toList $ Map.findWithDefault Set.empty IdOcc_Val mentrelFilterMp
          ]
      )


</pre>