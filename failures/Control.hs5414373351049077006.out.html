<a href="ContextStack.hs10447881241927702196.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Controlled.hs11477222941070477904.out.html">next</a></br></br><pre>11c11
< data Control = Control {stack ∷ [Node]} | NoControl
---
> data Control = Control {stack :: [Node]} | NoControl
17c17
< instance View v n ⇒ View v (Wrapper n) where
---
> instance View v n => View v (Wrapper n) where
27c27
<         newNodeMap = Map.update (\x → Just $ x {control = Control []}) rootNodeId (nodeMap controlgraph)
---
>         newNodeMap = Map.update (\x -> Just $ x {control = Control []}) rootNodeId (nodeMap controlgraph)
27a28
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, OverlappingInstances #-}
module GraphRewriting.Strategies.Control where

import Data.View
import GraphRewriting.Graph
--import GraphRewriting.Layout.PortSpec
import qualified Data.IntMap as Map

data Wrapper n = Wrapper {control :: Control, wrapped :: n}

data Control = Control {stack ∷ [Node]} | NoControl

instance View Control (Wrapper n) where
    inspect = control
    update c n = n {control = c}

instance View v n ⇒ View v (Wrapper n) where
    inspect = inspect . wrapped
    update v n = n {wrapped = update v $ wrapped n}

-- | Wraps the nodes of a graph, augmenting them with control information
wrapGraph :: Graph n -> Graph (Wrapper n)
wrapGraph graph = graph {nodeMap = newNodeMap} where
        wrapNode n = Wrapper {control = NoControl, wrapped = n}
        rootNodeId = minimum (Map.keys $ nodeMap graph)
        controlgraph = unsafeMapNodes wrapNode graph
        newNodeMap = Map.update (\x → Just $ x {control = Control []}) rootNodeId (nodeMap controlgraph)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, OverlappingInstances #-}
module GraphRewriting.Strategies.Control where

import Data.View
import GraphRewriting.Graph
--import GraphRewriting.Layout.PortSpec
import qualified Data.IntMap as Map

data Wrapper n = Wrapper {control :: Control, wrapped :: n}

data Control = Control {stack :: [Node]} | NoControl

instance View Control (Wrapper n) where
    inspect = control
    update c n = n {control = c}

instance View v n => View v (Wrapper n) where
    inspect = inspect . wrapped
    update v n = n {wrapped = update v $ wrapped n}

-- | Wraps the nodes of a graph, augmenting them with control information
wrapGraph :: Graph n -> Graph (Wrapper n)
wrapGraph graph = graph {nodeMap = newNodeMap} where
        wrapNode n = Wrapper {control = NoControl, wrapped = n}
        rootNodeId = minimum (Map.keys $ nodeMap graph)
        controlgraph = unsafeMapNodes wrapNode graph
        newNodeMap = Map.update (\x -> Just $ x {control = Control []}) rootNodeId (nodeMap controlgraph)

</pre>