<a href="DnaProteinAlignment.hs10397696271333685350.out.html">prev</a></br><a href="failures.html">home</a></br><a href="docidx.hs196285371138535563.out.html">next</a></br></br><pre>83c83
<                         hostName ∷ ByteString
---
>                         hostName :: ByteString
88c88
< aHostName ∷ Proxy HostName
---
> aHostName :: Proxy HostName
100c100
<     TR.Ident "fromJust" ← TR.lexP
---
>     TR.Ident "fromJust" <- TR.lexP
102d101
<       TR.Ident "fromString" ← TR.lexP
103d101
<       TR.String s ← TR.lexP
104c102
<       Just n ← return $ T.fromString s
---
>       TR.Ident "fromString" <- TR.lexP
104a103
>       TR.String s <- TR.lexP
104a104
>       Just n <- return $ T.fromString s
114c114
<   textual = go [] (0 ∷ Int) False [] (0 ∷ Int) <?> "host name"
---
>   textual = go [] (0 :: Int) False [] (0 :: Int) <?> "host name"
117d116
<             optional (P.satisfy A.isAlpha) >>= \case
118c117
<               Just c  → if ncs == 255
---
>             optional (P.satisfy A.isAlpha) >>= 
118a118
>               Just c  -> if ncs == 255
121c121
<               Nothing → P.unexpected "A letter expected"
---
>               Nothing -> P.unexpected "A letter expected"
123d122
<             optional (P.satisfy alphaNumOrDashOrDot) >>= \case
124c123
<               Just '.' → if dash
---
>             optional (P.satisfy alphaNumOrDashOrDot) >>= 
124a124
>               Just '.' -> if dash
130c130
<               Just c   → if nlcs == 63
---
>               Just c   -> if nlcs == 63
136c136
<               Nothing  → return $ HN $ BS.pack $ concat
---
>               Nothing  -> return $ HN $ BS.pack $ concat
150c150
< hostNameLabels ∷ HostName → [ByteString]
---
> hostNameLabels :: HostName -> [ByteString]
159c159
< arpaHostName ∷ IP → HostName
---
> arpaHostName :: IP -> HostName
175c175
<   StateT { runStateT ∷ Map k v → Maybe Word16 → μ (Map k v, Maybe Word16, α) }
---
>   StateT { runStateT :: Map k v -> Maybe Word16 -> μ (Map k v, Maybe Word16, α) }
180c180
< compress ∷ Monad μ ⇒ Word16 → CompT μ α → μ α
---
> compress :: Monad μ => Word16 -> CompT μ α -> μ α
182c182
<   (_, _, x) ← runStateT m Map.empty $ Just i
---
>   (_, _, x) <- runStateT m Map.empty $ Just i
186c186
< decompress ∷ Monad μ ⇒ Word16 → DecompT μ α → μ α
---
> decompress :: Monad μ => Word16 -> DecompT μ α -> μ α
188c188
<   (_, _, x) ← runStateT m Map.empty $ Just i
---
>   (_, _, x) <- runStateT m Map.empty $ Just i
192d191
< instance Monad μ ⇒ Functor (StateT k v μ) where
193d191
<   fmap f m = StateT $ \ptrs offset → do
194c192
<                (ptrs', offset', x) ← runStateT m ptrs offset
---
> instance Monad μ => Functor (StateT k v μ) where
194a193
>   fmap f m = StateT $ \ptrs offset -> do
194a194
>                (ptrs', offset', x) <- runStateT m ptrs offset
198c198
< instance Monad μ ⇒ Applicative (StateT k v μ) where
---
> instance Monad μ => Applicative (StateT k v μ) where
204c204
< instance Monad μ ⇒ Monad (StateT k v μ) where
---
> instance Monad μ => Monad (StateT k v μ) where
207d206
<   m >>= f = StateT $ \ptrs offset → do
208c207
<               (ptrs', offset', x) ← runStateT m ptrs offset
---
>   m >>= f = StateT $ \ptrs offset -> do
208a208
>               (ptrs', offset', x) <- runStateT m ptrs offset
214d213
< lift ∷ Monad μ ⇒ μ α → StateT k v μ α
215d213
< lift m = StateT $ \ptrs offset → do
216c214
<            x ← m
---
> lift :: Monad μ => μ α -> StateT k v μ α
216a215
> lift m = StateT $ \ptrs offset -> do
216a216
>            x <- m
220d219
< getOffset ∷ Monad μ ⇒ StateT k v μ (Maybe Word16)
221c220
< getOffset = StateT $ \ptrs offset → return (ptrs, offset, offset)
---
> getOffset :: Monad μ => StateT k v μ (Maybe Word16)
221a221
> getOffset = StateT $ \ptrs offset -> return (ptrs, offset, offset)
224d223
< incOffset ∷ Monad μ ⇒ Word16 → StateT k v μ ()
225c224
< incOffset n = StateT $ \ptrs offset → do
---
> incOffset :: Monad μ => Word16 -> StateT k v μ ()
225a225
> incOffset n = StateT $ \ptrs offset -> do
227d226
<         Just i | i' ← i + n, i' >= i && i' <= 0x3FFF → Just i'
228c227
<         _ → Nothing
---
>         Just i | i' <- i + n, i' >= i && i' <= 0x3FFF -> Just i'
228a228
>         _ -> Nothing
232d231
< getEntries ∷ Monad μ ⇒ StateT k v μ (Map k v)
233c232
< getEntries = StateT $ \ptrs offset → return (ptrs, offset, ptrs)
---
> getEntries :: Monad μ => StateT k v μ (Map k v)
233a233
> getEntries = StateT $ \ptrs offset -> return (ptrs, offset, ptrs)
236d235
< getEntry ∷ (Ord k, Monad μ) ⇒ k → StateT k v μ (Maybe v)
237c236
< getEntry key = StateT $ \ptrs offset → do
---
> getEntry :: (Ord k, Monad μ) => k -> StateT k v μ (Maybe v)
237a237
> getEntry key = StateT $ \ptrs offset -> do
241d240
< putEntry ∷ (Ord k, Monad μ) ⇒ k → v → StateT k v μ ()
242c241
< putEntry key value = StateT $ \ptrs offset → do
---
> putEntry :: (Ord k, Monad μ) => k -> v -> StateT k v μ ()
242a242
> putEntry key value = StateT $ \ptrs offset -> do
246d245
< evalComp ∷ Monad μ
247d245
<          ⇒ (∀ α . μ α → (α, ByteString)) → CompT μ ()
248d245
<          → CompT μ ByteString
249c246
< evalComp run m = StateT $ \ptrs offset → do
---
> evalComp :: Monad μ
249a247
>          => (forall α . μ α -> (α, ByteString)) -> CompT μ ()
249a248
>          -> CompT μ ByteString
249a249
> evalComp run m = StateT $ \ptrs offset -> do
254d253
< threadDecomp ∷ (∀ β . μ β → μ β) → DecompT μ α → DecompT μ α
255c254
< threadDecomp f m = StateT $ \ptrs offset →
---
> threadDecomp :: (forall β . μ β -> μ β) -> DecompT μ α -> DecompT μ α
255a255
> threadDecomp f m = StateT $ \ptrs offset ->
260d259
<       ⇒ Serializer s where
261d259
<   type GetM s ∷ ★ → ★
262d259
<   type PutM s ∷ ★ → ★
263d259
<   putWord8 ∷ s → Word8 → PutM s ()
264d259
<   putWord16be ∷ s → Word16 → PutM s ()
265d259
<   putWord32be ∷ s → Word32 → PutM s ()
266d259
<   putIP4 ∷ s → IP4 → PutM s ()
267d259
<   putIP6 ∷ s → IP6 → PutM s ()
268d259
<   putByteString ∷ s → ByteString → PutM s ()
269d259
<   runPutM ∷ s → PutM s α → (α, ByteString)
270d259
<   getWord8 ∷ s → GetM s Word8
271d259
<   getWord16be ∷ s → GetM s Word16
272d259
<   getWord32be ∷ s → GetM s Word32
273d259
<   getIP4 ∷ s → GetM s IP4
274d259
<   getIP6 ∷ s → GetM s IP6
275d259
<   getByteString ∷ s → Int → GetM s ByteString
276c260
<   isolate ∷ s → Int → GetM s α → GetM s α
---
>       => Serializer s where
276a261
>   type GetM s :: * -> *
276a262
>   type PutM s :: * -> *
276a263
>   putWord8 :: s -> Word8 -> PutM s ()
276a264
>   putWord16be :: s -> Word16 -> PutM s ()
276a265
>   putWord32be :: s -> Word32 -> PutM s ()
276a266
>   putIP4 :: s -> IP4 -> PutM s ()
276a267
>   putIP6 :: s -> IP6 -> PutM s ()
276a268
>   putByteString :: s -> ByteString -> PutM s ()
276a269
>   runPutM :: s -> PutM s α -> (α, ByteString)
276a270
>   getWord8 :: s -> GetM s Word8
276a271
>   getWord16be :: s -> GetM s Word16
276a272
>   getWord32be :: s -> GetM s Word32
276a273
>   getIP4 :: s -> GetM s IP4
276a274
>   getIP6 :: s -> GetM s IP6
276a275
>   getByteString :: s -> Int -> GetM s ByteString
276a276
>   isolate :: s -> Int -> GetM s α -> GetM s α
318c318
< serializeHostName ∷ Serializer s ⇒ s → HostName → CompT (PutM s) ()
---
> serializeHostName :: Serializer s => s -> HostName -> CompT (PutM s) ()
325c325
<       entry ← getEntry labels
---
>       entry <- getEntry labels
327c327
<         Nothing → do
---
>         Nothing -> do
329c329
<           offset ← getOffset
---
>           offset <- getOffset
335c335
<         Just ptr → do
---
>         Just ptr -> do
339c339
< guard' ∷ Monad μ ⇒ String → Bool → μ ()
---
> guard' :: Monad μ => String -> Bool -> μ ()
343c343
< deserializeHostName ∷ Serializer s ⇒ s → DecompT (GetM s) HostName
---
> deserializeHostName :: Serializer s => s -> DecompT (GetM s) HostName
347c347
<         forM_ offset $ \i → putEntry i (HN suffix')
---
>         forM_ offset $ \i -> putEntry i (HN suffix')
351d350
<       offset ← getOffset
352c351
<       w ← lift $ getWord8 s
---
>       offset <- getOffset
352a352
>       w <- lift $ getWord8 s
356c356
<         w' ← lift $ getWord8 s
---
>         w' <- lift $ getWord8 s
359c359
<         entry ← getEntry ptr
---
>         entry <- getEntry ptr
361d360
<           Nothing → do
362c361
<             entries ← getEntries
---
>           Nothing -> do
362a362
>             entries <- getEntries
365c365
<           Just (HN suffix1) → HN <$> foldM folder suffix1 labels
---
>           Just (HN suffix1) -> HN <$> foldM folder suffix1 labels
371c371
<           forM_ lastOffset $ \i → putEntry i (HN lastLabel)
---
>           forM_ lastOffset $ \i -> putEntry i (HN lastLabel)
375c375
<           label ← lift $ getByteString s $ fromIntegral w
---
>           label <- lift $ getByteString s $ fromIntegral w
388c388
< aHostAddr ∷ Proxy HostAddr
---
> aHostAddr :: Proxy HostAddr
392c392
< aHostAddrOf ∷ Proxy a → Proxy (HostAddr a)
---
> aHostAddrOf :: Proxy a -> Proxy (HostAddr a)
396c396
< aHost4Addr ∷ Proxy Host4Addr
---
> aHost4Addr :: Proxy Host4Addr
400c400
< aHost6Addr ∷ Proxy Host6Addr
---
> aHost6Addr :: Proxy Host6Addr
404c404
< aHostAddrIP ∷ Proxy (HostAddr IP)
---
> aHostAddrIP :: Proxy (HostAddr IP)
407c407
< instance Printable a ⇒ Printable (HostAddr a) where
---
> instance Printable a => Printable (HostAddr a) where
411c411
< instance Textual a ⇒ Textual (HostAddr a) where
---
> instance Textual a => Textual (HostAddr a) where
415c415
< instance Printable (InetAddr a) ⇒ Printable (InetAddr (HostAddr a)) where
---
> instance Printable (InetAddr a) => Printable (InetAddr (HostAddr a)) where
419c419
< instance Textual (InetAddr a) ⇒ Textual (InetAddr (HostAddr a)) where
---
> instance Textual (InetAddr a) => Textual (InetAddr (HostAddr a)) where
430c430
<   AddrDnsType  ∷ DnsType IP4
---
>   AddrDnsType  :: DnsType IP4
432c432
<   Addr6DnsType ∷ DnsType IP6
---
>   Addr6DnsType :: DnsType IP6
434c434
<   NsDnsType    ∷ DnsType HostName
---
>   NsDnsType    :: DnsType HostName
436c436
<   CNameDnsType ∷ DnsType HostName
---
>   CNameDnsType :: DnsType HostName
438c438
<   PtrDnsType   ∷ DnsType HostName
---
>   PtrDnsType   :: DnsType HostName
440c440
<   MxDnsType    ∷ DnsType (Word16, HostName)
---
>   MxDnsType    :: DnsType (Word16, HostName)
454c454
< dnsTypeCode ∷ DnsType α → Word16
---
> dnsTypeCode :: DnsType α -> Word16
463d462
< data DnsData = ∀ α . DnsData { dnsType ∷ !(DnsType α) -- ^ The type
464c463
<                              , dnsData ∷ α            -- ^ The data
---
> data DnsData = forall α . DnsData { dnsType :: !(DnsType α) -- ^ The type
464a464
>                              , dnsData :: α            -- ^ The data
474d473
<           AddrDnsType  → showsPrec p' dnsData
475d473
<           Addr6DnsType → showsPrec p' dnsData
476d473
<           NsDnsType    → showsPrec p' dnsData
477d473
<           CNameDnsType → showsPrec p' dnsData
478d473
<           PtrDnsType   → showsPrec p' dnsData
479c474
<           MxDnsType    → showsPrec p' dnsData
---
>           AddrDnsType  -> showsPrec p' dnsData
479a475
>           Addr6DnsType -> showsPrec p' dnsData
479a476
>           NsDnsType    -> showsPrec p' dnsData
479a477
>           CNameDnsType -> showsPrec p' dnsData
479a478
>           PtrDnsType   -> showsPrec p' dnsData
479a479
>           MxDnsType    -> showsPrec p' dnsData
481c481
<     where p' = 10 ∷ Int
---
>     where p' = 10 :: Int
485c485
<                              dnsRecOwner ∷ {-# UNPACK #-} !HostName
---
>                              dnsRecOwner :: {-# UNPACK #-} !HostName
487c487
<                              dnsRecTtl   ∷ {-# UNPACK #-} !Word32
---
>                              dnsRecTtl   :: {-# UNPACK #-} !Word32
489c489
<                              dnsRecData  ∷ !DnsData
---
>                              dnsRecData  :: !DnsData
493d492
< serializeDnsRecord ∷ Serializer s ⇒ s → DnsRecord → CompT (PutM s) ()
494c493
< serializeDnsRecord s (DnsRecord {..}) | DnsData tp dt ← dnsRecData = do
---
> serializeDnsRecord :: Serializer s => s -> DnsRecord -> CompT (PutM s) ()
494a494
> serializeDnsRecord s (DnsRecord {..}) | DnsData tp dt <- dnsRecData = do
500d499
<   d ← evalComp (runPutM s) $ case tp of
501d499
<     AddrDnsType  → lift (putIP4 s dt) >> incOffset 4
502d499
<     Addr6DnsType → lift (putIP6 s dt) >> incOffset 16
503d499
<     NsDnsType    → serializeHostName s dt
504d499
<     CNameDnsType → serializeHostName s dt
505d499
<     PtrDnsType   → serializeHostName s dt
506c500
<     MxDnsType    → do
---
>   d <- evalComp (runPutM s) $ case tp of
506a501
>     AddrDnsType  -> lift (putIP4 s dt) >> incOffset 4
506a502
>     Addr6DnsType -> lift (putIP6 s dt) >> incOffset 16
506a503
>     NsDnsType    -> serializeHostName s dt
506a504
>     CNameDnsType -> serializeHostName s dt
506a505
>     PtrDnsType   -> serializeHostName s dt
506a506
>     MxDnsType    -> do
513c513
< deserializeDnsRecord ∷ Serializer s ⇒ s → DecompT (GetM s) DnsRecord
---
> deserializeDnsRecord :: Serializer s => s -> DecompT (GetM s) DnsRecord
515d514
<   owner ← deserializeHostName s
516c515
<   code  ← lift $ getWord16be s
---
>   owner <- deserializeHostName s
516a516
>   code  <- lift $ getWord16be s
518d517
<   ttl   ← lift $ getWord32be s
519c518
<   len   ← lift $ fromIntegral <$> getWord16be s
---
>   ttl   <- lift $ getWord32be s
519a519
>   len   <- lift $ fromIntegral <$> getWord16be s
521d520
<   dd    ← threadDecomp (isolate s len) $ case code of
522d520
<     1  → fmap (DnsData AddrDnsType) $ incOffset 4 >> lift (getIP4 s)
523d520
<     2  → DnsData NsDnsType    <$> deserializeHostName s
524d520
<     5  → DnsData CNameDnsType <$> deserializeHostName s
525d520
<     12 → DnsData PtrDnsType   <$> deserializeHostName s
526d520
<     28 → fmap (DnsData Addr6DnsType) $ incOffset 16 >> lift (getIP6 s)
527c521
<     _  → fail "Unsupported type"
---
>   dd    <- threadDecomp (isolate s len) $ case code of
527a522
>     1  -> fmap (DnsData AddrDnsType) $ incOffset 4 >> lift (getIP4 s)
527a523
>     2  -> DnsData NsDnsType    <$> deserializeHostName s
527a524
>     5  -> DnsData CNameDnsType <$> deserializeHostName s
527a525
>     12 -> DnsData PtrDnsType   <$> deserializeHostName s
527a526
>     28 -> fmap (DnsData Addr6DnsType) $ incOffset 16 >> lift (getIP6 s)
527a527
>     _  -> fail "Unsupported type"
531c531
< data DnsQType = ∀ α . StdDnsType (DnsType α) -- ^ Record type
---
> data DnsQType = forall α . StdDnsType (DnsType α) -- ^ Record type
542c542
< dnsQTypeCode ∷ DnsQType → Word16
---
> dnsQTypeCode :: DnsQType -> Word16
552c552
< putDnsQType ∷ Serializer s ⇒ s → DnsQType → PutM s ()
---
> putDnsQType :: Serializer s => s -> DnsQType -> PutM s ()
555d554
< getDnsQType ∷ Serializer s ⇒ s → GetM s DnsQType
556d554
< getDnsQType s = getWord16be s >>= \case
557d554
<   1   → return $ StdDnsType AddrDnsType
558d554
<   2   → return $ StdDnsType NsDnsType
559d554
<   5   → return $ StdDnsType CNameDnsType
560d554
<   12  → return $ StdDnsType PtrDnsType
561d554
<   28  → return $ StdDnsType Addr6DnsType
562d554
<   255 → return AllDnsType
563c555
<   _   → fail "Unsupported query type"
---
> getDnsQType :: Serializer s => s -> GetM s DnsQType
563a556
> getDnsQType s = getWord16be s >>= 
563a557
>   1   -> return $ StdDnsType AddrDnsType
563a558
>   2   -> return $ StdDnsType NsDnsType
563a559
>   5   -> return $ StdDnsType CNameDnsType
563a560
>   12  -> return $ StdDnsType PtrDnsType
563a561
>   28  -> return $ StdDnsType Addr6DnsType
563a562
>   255 -> return AllDnsType
563a563
>   _   -> fail "Unsupported query type"
575c575
<                                  dnsQName ∷ {-# UNPACK #-} !HostName
---
>                                  dnsQName :: {-# UNPACK #-} !HostName
577c577
<                                  dnsQType ∷ !DnsQType
---
>                                  dnsQType :: !DnsQType
581c581
< serializeDnsQuestion ∷ Serializer s ⇒ s → DnsQuestion → CompT (PutM s) ()
---
> serializeDnsQuestion :: Serializer s => s -> DnsQuestion -> CompT (PutM s) ()
589c589
< deserializeDnsQuestion ∷ Serializer s ⇒ s → DecompT (GetM s) DnsQuestion
---
> deserializeDnsQuestion :: Serializer s => s -> DecompT (GetM s) DnsQuestion
591d590
<   q ← DnsQuestion <$> deserializeHostName s <*> lift (getDnsQType s)
592c591
<   c ← lift $ getWord16be s
---
>   q <- DnsQuestion <$> deserializeHostName s <*> lift (getDnsQType s)
592a592
>   c <- lift $ getWord16be s
600c600
<                        dnsReqId       ∷ {-# UNPACK #-} !DnsId
---
>                        dnsReqId       :: {-# UNPACK #-} !DnsId
602c602
<                        dnsReqTruncd   ∷ !Bool
---
>                        dnsReqTruncd   :: !Bool
604c604
<                        dnsReqRec      ∷ !Bool
---
>                        dnsReqRec      :: !Bool
606c606
<                        dnsReqQuestion ∷ {-# UNPACK #-} !DnsQuestion
---
>                        dnsReqQuestion :: {-# UNPACK #-} !DnsQuestion
609c609
<             | DnsInvReq { dnsReqId  ∷ {-# UNPACK #-} !DnsId
---
>             | DnsInvReq { dnsReqId  :: {-# UNPACK #-} !DnsId
611c611
<                           dnsReqInv ∷ !IP
---
>                           dnsReqInv :: !IP
615c615
< anyHostName ∷ HostName
---
> anyHostName :: HostName
618c618
< putDnsReq ∷ Serializer s ⇒ s → DnsReq → PutM s ()
---
> putDnsReq :: Serializer s => s -> DnsReq -> PutM s ()
641d640
<                   IPv4 a → DnsData AddrDnsType a
642c641
<                   IPv6 a → DnsData Addr6DnsType a }
---
>                   IPv4 a -> DnsData AddrDnsType a
642a642
>                   IPv6 a -> DnsData Addr6DnsType a }
644c644
< getDnsReq ∷ Serializer s ⇒ s → GetM s DnsReq
---
> getDnsReq :: Serializer s => s -> GetM s DnsReq
646d645
<   i ← getWord16be s
647c646
<   w ← getWord8 s
---
>   i <- getWord16be s
647a647
>   w <- getWord8 s
654c654
<     0 → do
---
>     0 -> do
660c660
<         q ← deserializeDnsQuestion s
---
>         q <- deserializeDnsQuestion s
665c665
<     1 → do
---
>     1 -> do
670c670
<       DnsRecord {dnsRecData} ← decompress 12 $ deserializeDnsRecord s
---
>       DnsRecord {dnsRecData} <- decompress 12 $ deserializeDnsRecord s
672c672
<         DnsData AddrDnsType a →
---
>         DnsData AddrDnsType a ->
674c674
<         DnsData Addr6DnsType a →
---
>         DnsData Addr6DnsType a ->
676d675
<         _ → fail "Invalid answer RR in inverse query"
677c676
<     _ → fail "Invalid opcode in request"
---
>         _ -> fail "Invalid answer RR in inverse query"
677a677
>     _ -> fail "Invalid opcode in request"
701c701
< dnsErrorCode ∷ DnsError → Word8
---
> dnsErrorCode :: DnsError -> Word8
716c716
<                          dnsRespId       ∷ {-# UNPACK #-} !DnsId
---
>                          dnsRespId       :: {-# UNPACK #-} !DnsId
718c718
<                          dnsRespTruncd   ∷ !Bool
---
>                          dnsRespTruncd   :: !Bool
720c720
<                          dnsRespAuthd    ∷ !Bool
---
>                          dnsRespAuthd    :: !Bool
722c722
<                          dnsRespRec      ∷ !Bool
---
>                          dnsRespRec      :: !Bool
724c724
<                          dnsRespQuestion ∷ {-# UNPACK #-} !DnsQuestion
---
>                          dnsRespQuestion :: {-# UNPACK #-} !DnsQuestion
726c726
<                          dnsRespAnswers  ∷ [DnsRecord]
---
>                          dnsRespAnswers  :: [DnsRecord]
728c728
<                          dnsRespAuths    ∷ [DnsRecord]
---
>                          dnsRespAuths    :: [DnsRecord]
730c730
<                          dnsRespExtras   ∷ [DnsRecord]
---
>                          dnsRespExtras   :: [DnsRecord]
733c733
<              | DnsErrResp { dnsRespId    ∷ {-# UNPACK #-} !DnsId
---
>              | DnsErrResp { dnsRespId    :: {-# UNPACK #-} !DnsId
735c735
<                             dnsRespError ∷ !DnsError
---
>                             dnsRespError :: !DnsError
739c739
< putDnsResp ∷ Serializer s ⇒ s → DnsResp → PutM s ()
---
> putDnsResp :: Serializer s => s -> DnsResp -> PutM s ()
764c764
< getDnsResp ∷ Serializer s ⇒ s → GetM s DnsResp
---
> getDnsResp :: Serializer s => s -> GetM s DnsResp
766d765
<   i ← getWord16be s
767c766
<   w ← getWord8 s
---
>   i <- getWord16be s
767a767
>   w <- getWord8 s
769c769
<   w' ← getWord8 s
---
>   w' <- getWord8 s
775c775
<     0 → do
---
>     0 -> do
777d776
<       anc ← getWord16be s
778d776
<       nsc ← getWord16be s
779c777
<       arc ← getWord16be s
---
>       anc <- getWord16be s
779a778
>       nsc <- getWord16be s
779a779
>       arc <- getWord16be s
781d780
<         q   ← deserializeDnsQuestion s
782d780
<         ans ← mapM (const $ deserializeDnsRecord s) [1 .. anc]
783d780
<         nss ← mapM (const $ deserializeDnsRecord s) [1 .. nsc]
784c781
<         ars ← mapM (const $ deserializeDnsRecord s) [1 .. arc]
---
>         q   <- deserializeDnsQuestion s
784a782
>         ans <- mapM (const $ deserializeDnsRecord s) [1 .. anc]
784a783
>         nss <- mapM (const $ deserializeDnsRecord s) [1 .. nsc]
784a784
>         ars <- mapM (const $ deserializeDnsRecord s) [1 .. arc]
793c793
<     _ → do
---
>     _ -> do
799d798
<         1  → return FormatDnsError
800d798
<         2  → return FailureDnsError
801d798
<         3  → return NoNameDnsError
802d798
<         4  → return NotImplDnsError
803d798
<         5  → return RefusedDnsError
804d798
<         6  → return NameExistsDnsError
805d798
<         7  → return RsExistsDnsError
806d798
<         8  → return NoRsDnsError
807d798
<         9  → return NotAuthDnsError
808d798
<         10 → return NotInZoneDnsError
809c799
<         _  → fail "Unknown error code in a response"
---
>         1  -> return FormatDnsError
809a800
>         2  -> return FailureDnsError
809a801
>         3  -> return NoNameDnsError
809a802
>         4  -> return NotImplDnsError
809a803
>         5  -> return RefusedDnsError
809a804
>         6  -> return NameExistsDnsError
809a805
>         7  -> return RsExistsDnsError
809a806
>         8  -> return NoRsDnsError
809a807
>         9  -> return NotAuthDnsError
809a808
>         10 -> return NotInZoneDnsError
809a809
>         _  -> fail "Unknown error code in a response"
818a819
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TypeFamilies #-}

-- | This module provides Domain Name System data structures and
--   (de)serialization routines.
module Network.DNS
  ( HostName
  , aHostName
  , hostName
  , hostNameLabels
  , arpaHostName
  , HostAddr(..)
  , Host4Addr
  , Host6Addr
  , aHostAddr
  , aHostAddrOf
  , aHost4Addr
  , aHost6Addr
  , aHostAddrIP
  , DnsId
  , DnsType(..)
  , dnsTypeCode
  , DnsData(..)
  , DnsRecord(..)
  , DnsQType(..)
  , dnsQTypeCode
  , DnsQuestion(..)
  , DnsReq(..)
  , DnsError(..)
  , DnsResp(..)
  ) where

import Data.Typeable
import Data.Proxy (Proxy(..))
import Data.Foldable (forM_)
import Data.Hashable
import Data.Word
import Data.Bits
import Data.Char (chr, ord)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BS8
import qualified Data.ByteString.Lazy as BSL
import Data.Binary (Binary)
import qualified Data.Binary as B
import qualified Data.Binary.Put as B
import qualified Data.Binary.Get as B
import Data.Serialize (Serialize)
import qualified Data.Serialize as S
import Text.Parser.Combinators as P
import Text.Parser.Char as P
import Text.Printer ((<>))
import qualified Text.Printer as T
import Data.Textual (Printable, toAscii, toUtf8, Textual)
import qualified Data.Textual as T
import qualified Text.Ascii as A
import Text.Printf
import qualified Text.Read as TR
import Network.IP.Addr
import Control.Applicative ((<$>), Applicative(..), (<|>))
import Control.Monad (void, unless, ap, foldM)

-- | Host name.
newtype HostName = HN { -- | Host name as a 'ByteString'.
                        hostName ∷ ByteString
                      }
                   deriving (Typeable, Eq, Ord, Hashable)

-- | 'HostName' proxy value.
aHostName ∷ Proxy HostName
aHostName = Proxy

instance Show HostName where
  showsPrec p (HN bs) = showParen (p > 10)
                      $ showString "fromJust "
                      . (showParen True $
                           showString "fromString "
                           . showsPrec 10 (BS8.unpack bs))

instance Read HostName where
  readPrec = TR.parens $ TR.prec 10 $ do
    TR.Ident "fromJust" ← TR.lexP
    TR.step $ TR.parens $ TR.prec 10 $ do
      TR.Ident "fromString" ← TR.lexP
      TR.String s ← TR.lexP
      Just n ← return $ T.fromString s
      return n

instance Printable HostName where
  print (HN bs) = T.ascii bs

{-# RULES "toAscii/HostName" toAscii = hostName #-}
{-# RULES "toUtf8/HostName"  toUtf8  = hostName #-}

instance Textual HostName where
  textual = go [] (0 ∷ Int) False [] (0 ∷ Int) <?> "host name"
    where alphaNumOrDashOrDot c = A.isAlphaNum c || c == '-' || c == '.'
          go !ls !ncs _ _ 0 =
            optional (P.satisfy A.isAlpha) >>= \case
              Just c  → if ncs == 255
                        then P.unexpected "Host name is too long"
                        else go ls (ncs + 1) False [A.ascii c] 1
              Nothing → P.unexpected "A letter expected"
          go !ls !ncs !dash !lcs !nlcs =
            optional (P.satisfy alphaNumOrDashOrDot) >>= \case
              Just '.' → if dash
                         then P.unexpected "Label ends with a dash"
                         else if ncs == 255
                              then P.unexpected "Host name is too long"
                              else go (reverse (A.ascii '.' : lcs) : ls)
                                      (ncs + 1) False [] 0
              Just c   → if nlcs == 63
                         then P.unexpected "Label is too long"
                         else if ncs == 255
                              then P.unexpected "Host name is too long"
                              else go ls (ncs + 1) (c == '-')
                                         (A.ascii c : lcs) (nlcs + 1)
              Nothing  → return $ HN $ BS.pack $ concat
                                $ reverse $ reverse lcs : ls

instance Printable (InetAddr HostName) where
  print (InetAddr n p) = T.print n <> T.char7 ':' <> T.print p

instance Textual (InetAddr HostName) where
  textual = InetAddr <$> T.textual <*> (P.char ':' *> T.textual)

-- | List the 'HostName' labels:
--
-- @
--   'hostNameLabels' ('Data.Maybe.fromJust' ('Data.Textual.fromString' /"www.google.com"/)) = [/"www"/, /"google"/, /"com"/]
-- @
hostNameLabels ∷ HostName → [ByteString]
hostNameLabels = BS.split (A.ascii '.') . hostName

-- | Host name for reverse DNS lookups.
--
-- @
--   'Text.Printer.toString' ('arpaHostName' ('IPv4' ('ip4FromOctets' /1/ /2/ /3/ /4/))) = /"4.3.2.1.in-addr.arpa"/
--   'Text.Printer.toString' ('arpaHostName' ('IPv6' ('ip6FromWords' /1/ /2/ /3/ /4/ /5/ /6/ /7/ /8/))) = /"8.0.0.0.7.0.0.0.6.0.0.0.5.0.0.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.ip6.arpa"/
-- @
arpaHostName ∷ IP → HostName
arpaHostName (IPv4 a) =
    HN $ BS8.pack $ printf "%i.%i.%i.%i.in-addr.arpa" o4 o3 o2 o1
  where (o1, o2, o3, o4) = ip4ToOctets a
arpaHostName (IPv6 a) =
    HN $ BS8.pack $ digits (reverse $ ip6ToWordList a) ++ "ip6.arpa"
  where digits (w : ws) = [d4, '.', d3, '.', d2, '.', d1, '.'] ++ digits ws
          where d1 = toDigit $ w `shiftR` 12
                d2 = toDigit $ w `shiftR` 8 .&. 0xF
                d3 = toDigit $ w `shiftR` 4 .&. 0xF
                d4 = toDigit $ w .&. 0xF
                toDigit n | n < 10    = chr $ ord '0' + fromIntegral n
                          | otherwise = chr $ ord 'a' + fromIntegral n - 10
        digits [] = []

newtype StateT k v μ α =
  StateT { runStateT ∷ Map k v → Maybe Word16 → μ (Map k v, Maybe Word16, α) }

type CompT μ α   = StateT [ByteString] Word16 μ α
type DecompT μ α = StateT Word16 HostName μ α

compress ∷ Monad μ ⇒ Word16 → CompT μ α → μ α
compress i m = do
  (_, _, x) ← runStateT m Map.empty $ Just i
  return x
{-# INLINE compress #-}

decompress ∷ Monad μ ⇒ Word16 → DecompT μ α → μ α
decompress i m = do
  (_, _, x) ← runStateT m Map.empty $ Just i
  return x
{-# INLINE decompress #-}

instance Monad μ ⇒ Functor (StateT k v μ) where
  fmap f m = StateT $ \ptrs offset → do
               (ptrs', offset', x) ← runStateT m ptrs offset
               return (ptrs', offset', f x)
  {-# INLINE fmap #-}

instance Monad μ ⇒ Applicative (StateT k v μ) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}

instance Monad μ ⇒ Monad (StateT k v μ) where
  return = lift . return
  {-# INLINE return #-}
  m >>= f = StateT $ \ptrs offset → do
              (ptrs', offset', x) ← runStateT m ptrs offset
              runStateT (f x) ptrs' offset'
  {-# INLINE (>>=) #-}
  fail msg = lift $ fail msg
  {-# INLINE fail #-}

lift ∷ Monad μ ⇒ μ α → StateT k v μ α
lift m = StateT $ \ptrs offset → do
           x ← m
           return (ptrs, offset, x)
{-# INLINE lift #-}

getOffset ∷ Monad μ ⇒ StateT k v μ (Maybe Word16)
getOffset = StateT $ \ptrs offset → return (ptrs, offset, offset)
{-# INLINE getOffset #-}

incOffset ∷ Monad μ ⇒ Word16 → StateT k v μ ()
incOffset n = StateT $ \ptrs offset → do
  let offset' = case offset of
        Just i | i' ← i + n, i' >= i && i' <= 0x3FFF → Just i'
        _ → Nothing
  return (ptrs, offset', ())
{-# INLINE incOffset #-}

getEntries ∷ Monad μ ⇒ StateT k v μ (Map k v)
getEntries = StateT $ \ptrs offset → return (ptrs, offset, ptrs)
{-# INLINE getEntries #-}

getEntry ∷ (Ord k, Monad μ) ⇒ k → StateT k v μ (Maybe v)
getEntry key = StateT $ \ptrs offset → do
  return (ptrs, offset, Map.lookup key ptrs)
{-# INLINE getEntry #-}

putEntry ∷ (Ord k, Monad μ) ⇒ k → v → StateT k v μ ()
putEntry key value = StateT $ \ptrs offset → do
  return (Map.insert key value ptrs, offset, ())
{-# INLINE putEntry #-}

evalComp ∷ Monad μ
         ⇒ (∀ α . μ α → (α, ByteString)) → CompT μ ()
         → CompT μ ByteString
evalComp run m = StateT $ \ptrs offset → do
  let ((ptrs', offset', _), bs) = run $ runStateT m ptrs offset
  return (ptrs', offset', bs)
{-# INLINE evalComp #-}

threadDecomp ∷ (∀ β . μ β → μ β) → DecompT μ α → DecompT μ α
threadDecomp f m = StateT $ \ptrs offset →
  f $ runStateT m ptrs offset
{-# INLINE threadDecomp #-}

class (Functor (GetM s), Monad (GetM s), Functor (PutM s), Monad (PutM s))
      ⇒ Serializer s where
  type GetM s ∷ ★ → ★
  type PutM s ∷ ★ → ★
  putWord8 ∷ s → Word8 → PutM s ()
  putWord16be ∷ s → Word16 → PutM s ()
  putWord32be ∷ s → Word32 → PutM s ()
  putIP4 ∷ s → IP4 → PutM s ()
  putIP6 ∷ s → IP6 → PutM s ()
  putByteString ∷ s → ByteString → PutM s ()
  runPutM ∷ s → PutM s α → (α, ByteString)
  getWord8 ∷ s → GetM s Word8
  getWord16be ∷ s → GetM s Word16
  getWord32be ∷ s → GetM s Word32
  getIP4 ∷ s → GetM s IP4
  getIP6 ∷ s → GetM s IP6
  getByteString ∷ s → Int → GetM s ByteString
  isolate ∷ s → Int → GetM s α → GetM s α

data BinarySerializer = BinarySerializer

instance Serializer BinarySerializer where
  type GetM BinarySerializer = B.Get
  type PutM BinarySerializer = B.PutM
  putWord8 _ = B.putWord8
  putWord16be _ = B.putWord16be
  putWord32be _ = B.putWord32be
  putIP4 _ = B.put
  putIP6 _ = B.put
  putByteString _ = B.putByteString
  runPutM _ p = (r, BSL.toStrict bs) where (r, bs) = B.runPutM p
  getWord8 _ = B.getWord8
  getWord16be _ = B.getWord16be
  getWord32be _ = B.getWord32be
  getIP4 _ = B.get
  getIP6 _ = B.get
  getByteString _ = B.getBytes
  isolate _ = undefined

data CerealSerializer = CerealSerializer

instance Serializer CerealSerializer where
  type GetM CerealSerializer = S.Get
  type PutM CerealSerializer = S.PutM
  putWord8 _ = S.putWord8
  putWord16be _ = S.putWord16be
  putWord32be _ = S.putWord32be
  putIP4 _ = S.put
  putIP6 _ = S.put
  putByteString _ = S.putByteString
  runPutM _ = S.runPutM
  getWord8 _ = S.getWord8
  getWord16be _ = S.getWord16be
  getWord32be _ = S.getWord32be
  getIP4 _ = S.get
  getIP6 _ = S.get
  getByteString _ = S.getBytes
  isolate _ = S.isolate

serializeHostName ∷ Serializer s ⇒ s → HostName → CompT (PutM s) ()
serializeHostName s = go . hostNameLabels
  where
    go [] = do
      lift $ putWord8 s 0
      incOffset 1
    go labels@(label : labels') = do
      entry ← getEntry labels
      case entry of
        Nothing → do
          let ll = BS.length label
          offset ← getOffset
          lift $ putWord8 s $ fromIntegral ll
          lift $ putByteString s label
          incOffset $ 1 + fromIntegral ll
          forM_ offset $ putEntry labels
          go labels'
        Just ptr → do
          lift $ putWord16be s $ 0xC000 .|. ptr
          incOffset 2

guard' ∷ Monad μ ⇒ String → Bool → μ ()
guard' msg test = unless test $ fail msg
{-# INLINE guard' #-}

deserializeHostName ∷ Serializer s ⇒ s → DecompT (GetM s) HostName
deserializeHostName s = go []
  where
    folder suffix (label, offset) = do
        forM_ offset $ \i → putEntry i (HN suffix')
        return suffix'
      where suffix' = BS.append label $ BS.cons (A.ascii '.') suffix
    go labels = do
      offset ← getOffset
      w ← lift $ getWord8 s
      incOffset 1
      if w .&. 0xC0 == 0xC0
      then do
        w' ← lift $ getWord8 s
        incOffset 1
        let ptr = fromIntegral (w .&. 0x3F) `shiftL` 8 .|. fromIntegral w'
        entry ← getEntry ptr
        case entry of
          Nothing → do
            entries ← getEntries
            fail $ "Invalid pointer " ++ show ptr ++ ": pointer map is " ++
                   show (Map.elems entries)
          Just (HN suffix1) → HN <$> foldM folder suffix1 labels
      else
        if w == 0
        then do
          guard' "Hostname with zero labels" $ not $ null labels
          let (lastLabel, lastOffset) : labels' = labels
          forM_ lastOffset $ \i → putEntry i (HN lastLabel)
          HN <$> foldM folder lastLabel labels'
        else do
          guard' "Label is too long" $ w <= 63
          label ← lift $ getByteString s $ fromIntegral w
          incOffset $ fromIntegral w
          go ((BS.map A.toLower8 label, offset) : labels)

-- | Host address. Either a host name or an IP address.
data HostAddr a = HostName {-# UNPACK #-} !HostName
                | HostAddr !a
                deriving (Typeable, Show, Read, Eq, Ord)

type Host4Addr = HostAddr IP4
type Host6Addr = HostAddr IP6

-- | 'HostAddr' proxy value.
aHostAddr ∷ Proxy HostAddr
aHostAddr = Proxy

-- | 'HostAddr' /a/ proxy value.
aHostAddrOf ∷ Proxy a → Proxy (HostAddr a)
aHostAddrOf _ = Proxy

-- | 'Host4Addr' proxy value.
aHost4Addr ∷ Proxy Host4Addr
aHost4Addr = Proxy

-- | 'Host6Addr' proxy value.
aHost6Addr ∷ Proxy Host6Addr
aHost6Addr = Proxy

-- | 'HostAddr' 'IP' proxy value.
aHostAddrIP ∷ Proxy (HostAddr IP)
aHostAddrIP = Proxy

instance Printable a ⇒ Printable (HostAddr a) where
  print (HostName name) = T.print name
  print (HostAddr addr) = T.print addr

instance Textual a ⇒ Textual (HostAddr a) where
  textual  =  P.try (HostName <$> T.textual)
          <|> (HostAddr <$> T.textual)

instance Printable (InetAddr a) ⇒ Printable (InetAddr (HostAddr a)) where
  print (InetAddr (HostName n) p) = T.print $ InetAddr n p
  print (InetAddr (HostAddr a) p) = T.print $ InetAddr a p

instance Textual (InetAddr a) ⇒ Textual (InetAddr (HostAddr a)) where
  textual  =  P.try (InetAddr <$> (HostName <$> T.textual)
                              <*> (P.char ':' *> T.textual))
          <|> T.textual

-- | Message identifier.
type DnsId = Word16

-- | Resource Record type.
data DnsType α where
  -- IPv4 address record (/A/)
  AddrDnsType  ∷ DnsType IP4
  -- IPv6 address record (/AAAA/)
  Addr6DnsType ∷ DnsType IP6
  -- Name server record (/NS/)
  NsDnsType    ∷ DnsType HostName
  -- Canonical name record (/CNAME/)
  CNameDnsType ∷ DnsType HostName
  -- Pointer record (/PTR/)
  PtrDnsType   ∷ DnsType HostName
  -- Mail exchange record (/MX/)
  MxDnsType    ∷ DnsType (Word16, HostName)

deriving instance Typeable1 DnsType
deriving instance Eq (DnsType α)

instance Show (DnsType α) where
  showsPrec _ AddrDnsType  = showString "AddrDnsType"
  showsPrec _ Addr6DnsType = showString "Addr6DnsType"
  showsPrec _ NsDnsType    = showString "NsDnsType"
  showsPrec _ CNameDnsType = showString "CNameDnsType"
  showsPrec _ PtrDnsType   = showString "PtrDnsType"
  showsPrec _ MxDnsType    = showString "MxDnsType"

-- | Numeric representation of a Resource Record type.
dnsTypeCode ∷ DnsType α → Word16
dnsTypeCode AddrDnsType  = 1
dnsTypeCode Addr6DnsType = 28
dnsTypeCode NsDnsType    = 2
dnsTypeCode CNameDnsType = 5
dnsTypeCode PtrDnsType   = 12
dnsTypeCode MxDnsType    = 15

-- | Resource Record data.
data DnsData = ∀ α . DnsData { dnsType ∷ !(DnsType α) -- ^ The type
                             , dnsData ∷ α            -- ^ The data
                             }
               deriving Typeable

instance Show DnsData where
  showsPrec p (DnsData {..}) = showParen (p > 10)
      $ showString "DnsData {dnsType = "
      . showsPrec (p + 1) dnsType
      . showString ", dnsData = "
      . case dnsType of
          AddrDnsType  → showsPrec p' dnsData
          Addr6DnsType → showsPrec p' dnsData
          NsDnsType    → showsPrec p' dnsData
          CNameDnsType → showsPrec p' dnsData
          PtrDnsType   → showsPrec p' dnsData
          MxDnsType    → showsPrec p' dnsData
      . showString "}"
    where p' = 10 ∷ Int

-- | Resource Record.
data DnsRecord = DnsRecord { -- | Record owner
                             dnsRecOwner ∷ {-# UNPACK #-} !HostName
                           , -- | Maximum caching time in secords
                             dnsRecTtl   ∷ {-# UNPACK #-} !Word32
                           , -- | Record data
                             dnsRecData  ∷ !DnsData
                           }
                 deriving (Typeable, Show)

serializeDnsRecord ∷ Serializer s ⇒ s → DnsRecord → CompT (PutM s) ()
serializeDnsRecord s (DnsRecord {..}) | DnsData tp dt ← dnsRecData = do
  serializeHostName s dnsRecOwner
  lift $ putWord16be s $ dnsTypeCode tp
  lift $ putWord16be s 1
  lift $ putWord32be s dnsRecTtl
  incOffset 10
  d ← evalComp (runPutM s) $ case tp of
    AddrDnsType  → lift (putIP4 s dt) >> incOffset 4
    Addr6DnsType → lift (putIP6 s dt) >> incOffset 16
    NsDnsType    → serializeHostName s dt
    CNameDnsType → serializeHostName s dt
    PtrDnsType   → serializeHostName s dt
    MxDnsType    → do
      lift $ putWord16be s $ fst dt
      incOffset 2
      serializeHostName s $ snd dt
  lift $ putWord16be s $ fromIntegral $ BS.length d
  lift $ putByteString s d

deserializeDnsRecord ∷ Serializer s ⇒ s → DecompT (GetM s) DnsRecord
deserializeDnsRecord s = do
  owner ← deserializeHostName s
  code  ← lift $ getWord16be s
  void $ lift $ getWord16be s
  ttl   ← lift $ getWord32be s
  len   ← lift $ fromIntegral <$> getWord16be s
  incOffset 10
  dd    ← threadDecomp (isolate s len) $ case code of
    1  → fmap (DnsData AddrDnsType) $ incOffset 4 >> lift (getIP4 s)
    2  → DnsData NsDnsType    <$> deserializeHostName s
    5  → DnsData CNameDnsType <$> deserializeHostName s
    12 → DnsData PtrDnsType   <$> deserializeHostName s
    28 → fmap (DnsData Addr6DnsType) $ incOffset 16 >> lift (getIP6 s)
    _  → fail "Unsupported type"
  return $ DnsRecord owner ttl dd

-- | DNS query type.
data DnsQType = ∀ α . StdDnsType (DnsType α) -- ^ Record type
              | AllDnsType -- ^ All record types
              deriving Typeable

instance Show DnsQType where
  showsPrec p (StdDnsType t) = showParen (p > 10)
                             $ showString "StdDnsType "
                             . showsPrec (p + 1) t
  showsPrec _ AllDnsType = showString "AllDnsType"

-- | Numeric representation of a DNS query type.
dnsQTypeCode ∷ DnsQType → Word16
dnsQTypeCode (StdDnsType t) = dnsTypeCode t
dnsQTypeCode AllDnsType     = 255

instance Eq DnsQType where
  t1 == t2 = dnsQTypeCode t1 == dnsQTypeCode t2

instance Ord DnsQType where
  t1 `compare` t2 = dnsQTypeCode t1 `compare` dnsQTypeCode t2

putDnsQType ∷ Serializer s ⇒ s → DnsQType → PutM s ()
putDnsQType s = putWord16be s . dnsQTypeCode

getDnsQType ∷ Serializer s ⇒ s → GetM s DnsQType
getDnsQType s = getWord16be s >>= \case
  1   → return $ StdDnsType AddrDnsType
  2   → return $ StdDnsType NsDnsType
  5   → return $ StdDnsType CNameDnsType
  12  → return $ StdDnsType PtrDnsType
  28  → return $ StdDnsType Addr6DnsType
  255 → return AllDnsType
  _   → fail "Unsupported query type"

instance Binary DnsQType where
  put = putDnsQType BinarySerializer
  get = getDnsQType BinarySerializer

instance Serialize DnsQType where
  put = putDnsQType CerealSerializer
  get = getDnsQType CerealSerializer

-- | DNS question.
data DnsQuestion = DnsQuestion { -- | Ask about the specified host name
                                 dnsQName ∷ {-# UNPACK #-} !HostName
                               , -- | Query type
                                 dnsQType ∷ !DnsQType
                               }
                   deriving (Typeable, Show, Eq, Ord)

serializeDnsQuestion ∷ Serializer s ⇒ s → DnsQuestion → CompT (PutM s) ()
serializeDnsQuestion s (DnsQuestion {..}) = do
  serializeHostName s dnsQName
  lift $ do
    putDnsQType s dnsQType
    putWord16be s 1
  incOffset 4

deserializeDnsQuestion ∷ Serializer s ⇒ s → DecompT (GetM s) DnsQuestion
deserializeDnsQuestion s = do
  q ← DnsQuestion <$> deserializeHostName s <*> lift (getDnsQType s)
  c ← lift $ getWord16be s
  guard' "Unsupported class in a question" $ c == 1
  incOffset 4
  return q

-- | Request message.
data DnsReq -- | Standard query
            = DnsReq { -- | Message identifier
                       dnsReqId       ∷ {-# UNPACK #-} !DnsId
                     , -- | Truncation flag
                       dnsReqTruncd   ∷ !Bool
                     , -- | Recursion flag
                       dnsReqRec      ∷ !Bool
                     , -- | Question
                       dnsReqQuestion ∷ {-# UNPACK #-} !DnsQuestion
                     }
            -- | Inverse query
            | DnsInvReq { dnsReqId  ∷ {-# UNPACK #-} !DnsId
                        , -- | IP address
                          dnsReqInv ∷ !IP
                        }
            deriving (Typeable, Show)

anyHostName ∷ HostName
anyHostName = HN "any"

putDnsReq ∷ Serializer s ⇒ s → DnsReq → PutM s ()
putDnsReq s (DnsReq {..}) = do
  putWord16be s dnsReqId
  putWord8 s  $  if dnsReqRec then 1 else 0
             .|. if dnsReqTruncd then 2 else 0
  putWord8 s 0
  putWord16be s 1
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0
  compress 12 $ serializeDnsQuestion s dnsReqQuestion
putDnsReq s (DnsInvReq {..}) = do
  putWord16be s dnsReqId
  putWord8 s 8
  putWord8 s 0
  putWord16be s 0
  putWord16be s 1
  putWord16be s 0
  putWord16be s 0
  compress 12 $ serializeDnsRecord s $
    DnsRecord { dnsRecOwner = anyHostName
              , dnsRecTtl   = 0
              , dnsRecData  = case dnsReqInv of
                  IPv4 a → DnsData AddrDnsType a
                  IPv6 a → DnsData Addr6DnsType a }

getDnsReq ∷ Serializer s ⇒ s → GetM s DnsReq
getDnsReq s = do
  i ← getWord16be s
  w ← getWord8 s
  void $ getWord8 s
  guard' "Not a request" $ w .&. 128 == 0
  let rec    = w .&. 1 /= 0
      truncd = w .&. 2 /= 0
      opcode = w `shiftR` 3 .&. 0xF
  case opcode of
    0 → do
      getWord16be s >>= guard' "No questions in query" . (== 1)
      getWord16be s >>= guard' "Answers in query" . (== 0)
      getWord16be s >>= guard' "Authorities in query" . (== 0)
      getWord16be s >>= guard' "Extras in query" . (== 0)
      decompress 12 $ do
        q ← deserializeDnsQuestion s
        return $ DnsReq { dnsReqId       = i
                        , dnsReqTruncd   = truncd
                        , dnsReqRec      = rec
                        , dnsReqQuestion = q }
    1 → do
      getWord16be s >>= guard' "Questions in inverse query" . (== 0)
      getWord16be s >>= guard' "No answers in inverse query" . (== 1)
      getWord16be s >>= guard' "Authorities in inverse query" . (== 0)
      getWord16be s >>= guard' "Extras in inverse query" . (== 0)
      DnsRecord {dnsRecData} ← decompress 12 $ deserializeDnsRecord s
      case dnsRecData of
        DnsData AddrDnsType a →
          return $ DnsInvReq { dnsReqId  = i, dnsReqInv = IPv4 a }
        DnsData Addr6DnsType a →
          return $ DnsInvReq { dnsReqId  = i, dnsReqInv = IPv6 a }
        _ → fail "Invalid answer RR in inverse query"
    _ → fail "Invalid opcode in request"

instance Binary DnsReq where
  put = putDnsReq BinarySerializer
  get = getDnsReq BinarySerializer

instance Serialize DnsReq where
  put = putDnsReq CerealSerializer
  get = getDnsReq CerealSerializer

-- | Errors returned in responses.
data DnsError = FormatDnsError
              | FailureDnsError
              | NoNameDnsError
              | NotImplDnsError
              | RefusedDnsError
              | NameExistsDnsError
              | RsExistsDnsError
              | NoRsDnsError
              | NotAuthDnsError
              | NotInZoneDnsError
              deriving (Typeable, Show, Read, Eq, Ord, Enum)

-- | Numerical representation of an error.
dnsErrorCode ∷ DnsError → Word8
dnsErrorCode FormatDnsError     = 1
dnsErrorCode FailureDnsError    = 2
dnsErrorCode NoNameDnsError     = 3
dnsErrorCode NotImplDnsError    = 4
dnsErrorCode RefusedDnsError    = 5
dnsErrorCode NameExistsDnsError = 6
dnsErrorCode RsExistsDnsError   = 7
dnsErrorCode NoRsDnsError       = 8
dnsErrorCode NotAuthDnsError    = 9
dnsErrorCode NotInZoneDnsError  = 10

-- | Response message.
data DnsResp -- | Normal response.
             = DnsResp { -- | Request identifer
                         dnsRespId       ∷ {-# UNPACK #-} !DnsId
                       , -- | Truncation flag
                         dnsRespTruncd   ∷ !Bool
                       , -- | Authoritative answer flag
                         dnsRespAuthd    ∷ !Bool
                       , -- | Recursive query support flag
                         dnsRespRec      ∷ !Bool
                       , -- | Request question
                         dnsRespQuestion ∷ {-# UNPACK #-} !DnsQuestion
                       , -- | Answer records
                         dnsRespAnswers  ∷ [DnsRecord]
                       , -- | Authority records
                         dnsRespAuths    ∷ [DnsRecord]
                       , -- | Additional records
                         dnsRespExtras   ∷ [DnsRecord]
                       }
             -- | Error response.
             | DnsErrResp { dnsRespId    ∷ {-# UNPACK #-} !DnsId
                          , -- | Error
                            dnsRespError ∷ !DnsError
                          }
             deriving (Typeable, Show)

putDnsResp ∷ Serializer s ⇒ s → DnsResp → PutM s ()
putDnsResp s (DnsResp {..}) = do
  putWord16be s dnsRespId
  putWord8 s  $  128
             .|. if dnsRespTruncd then 2 else 0
             .|. if dnsRespAuthd then 4 else 0
  putWord8 s $ if dnsRespRec then 128 else 0
  putWord16be s 1
  putWord16be s $ fromIntegral $ length dnsRespAnswers
  putWord16be s $ fromIntegral $ length dnsRespAuths
  putWord16be s $ fromIntegral $ length dnsRespExtras
  compress 12 $ do
    serializeDnsQuestion s dnsRespQuestion
    forM_ dnsRespAnswers (serializeDnsRecord s)
    forM_ dnsRespAuths   (serializeDnsRecord s)
    forM_ dnsRespExtras  (serializeDnsRecord s)
putDnsResp s (DnsErrResp {..}) = do
  putWord16be s dnsRespId
  putWord8 s 8
  putWord8 s $ dnsErrorCode dnsRespError
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0

getDnsResp ∷ Serializer s ⇒ s → GetM s DnsResp
getDnsResp s = do
  i ← getWord16be s
  w ← getWord8 s
  guard' "Not a response" $ w .&. 128 /= 0
  w' ← getWord8 s
  let truncd = w .&. 2 /= 0
      authd  = w .&. 4 /= 0
      rec    = w' .&. 128 /= 0
      ec     = w' .&. 0xF
  case ec of
    0 → do
      getWord16be s >>= guard' "No question in a response" . (== 1)
      anc ← getWord16be s
      nsc ← getWord16be s
      arc ← getWord16be s
      decompress 12 $ do
        q   ← deserializeDnsQuestion s
        ans ← mapM (const $ deserializeDnsRecord s) [1 .. anc]
        nss ← mapM (const $ deserializeDnsRecord s) [1 .. nsc]
        ars ← mapM (const $ deserializeDnsRecord s) [1 .. arc]
        return $ DnsResp { dnsRespId       = i
                         , dnsRespTruncd   = truncd
                         , dnsRespAuthd    = authd
                         , dnsRespRec      = rec
                         , dnsRespQuestion = q
                         , dnsRespAnswers  = ans
                         , dnsRespAuths    = nss
                         , dnsRespExtras   = ars }
    _ → do
      void $ getWord16be s
      void $ getWord16be s
      void $ getWord16be s
      void $ getWord16be s
      DnsErrResp i <$> case ec of
        1  → return FormatDnsError
        2  → return FailureDnsError
        3  → return NoNameDnsError
        4  → return NotImplDnsError
        5  → return RefusedDnsError
        6  → return NameExistsDnsError
        7  → return RsExistsDnsError
        8  → return NoRsDnsError
        9  → return NotAuthDnsError
        10 → return NotInZoneDnsError
        _  → fail "Unknown error code in a response"

instance Binary DnsResp where
  put = putDnsResp BinarySerializer
  get = getDnsResp BinarySerializer

instance Serialize DnsResp where
  put = putDnsResp CerealSerializer
  get = getDnsResp CerealSerializer

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE PatternGuards #-}
{-# LANGUAGE DoAndIfThenElse #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TypeFamilies #-}

-- | This module provides Domain Name System data structures and
--   (de)serialization routines.
module Network.DNS
  ( HostName
  , aHostName
  , hostName
  , hostNameLabels
  , arpaHostName
  , HostAddr(..)
  , Host4Addr
  , Host6Addr
  , aHostAddr
  , aHostAddrOf
  , aHost4Addr
  , aHost6Addr
  , aHostAddrIP
  , DnsId
  , DnsType(..)
  , dnsTypeCode
  , DnsData(..)
  , DnsRecord(..)
  , DnsQType(..)
  , dnsQTypeCode
  , DnsQuestion(..)
  , DnsReq(..)
  , DnsError(..)
  , DnsResp(..)
  ) where

import Data.Typeable
import Data.Proxy (Proxy(..))
import Data.Foldable (forM_)
import Data.Hashable
import Data.Word
import Data.Bits
import Data.Char (chr, ord)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BS8
import qualified Data.ByteString.Lazy as BSL
import Data.Binary (Binary)
import qualified Data.Binary as B
import qualified Data.Binary.Put as B
import qualified Data.Binary.Get as B
import Data.Serialize (Serialize)
import qualified Data.Serialize as S
import Text.Parser.Combinators as P
import Text.Parser.Char as P
import Text.Printer ((<>))
import qualified Text.Printer as T
import Data.Textual (Printable, toAscii, toUtf8, Textual)
import qualified Data.Textual as T
import qualified Text.Ascii as A
import Text.Printf
import qualified Text.Read as TR
import Network.IP.Addr
import Control.Applicative ((<$>), Applicative(..), (<|>))
import Control.Monad (void, unless, ap, foldM)

-- | Host name.
newtype HostName = HN { -- | Host name as a 'ByteString'.
                        hostName :: ByteString
                      }
                   deriving (Typeable, Eq, Ord, Hashable)

-- | 'HostName' proxy value.
aHostName :: Proxy HostName
aHostName = Proxy

instance Show HostName where
  showsPrec p (HN bs) = showParen (p > 10)
                      $ showString "fromJust "
                      . (showParen True $
                           showString "fromString "
                           . showsPrec 10 (BS8.unpack bs))

instance Read HostName where
  readPrec = TR.parens $ TR.prec 10 $ do
    TR.Ident "fromJust" <- TR.lexP
    TR.step $ TR.parens $ TR.prec 10 $ do
      TR.Ident "fromString" <- TR.lexP
      TR.String s <- TR.lexP
      Just n <- return $ T.fromString s
      return n

instance Printable HostName where
  print (HN bs) = T.ascii bs

{-# RULES "toAscii/HostName" toAscii = hostName #-}
{-# RULES "toUtf8/HostName"  toUtf8  = hostName #-}

instance Textual HostName where
  textual = go [] (0 :: Int) False [] (0 :: Int) <?> "host name"
    where alphaNumOrDashOrDot c = A.isAlphaNum c || c == '-' || c == '.'
          go !ls !ncs _ _ 0 =
            optional (P.satisfy A.isAlpha) >>= 
              Just c  -> if ncs == 255
                        then P.unexpected "Host name is too long"
                        else go ls (ncs + 1) False [A.ascii c] 1
              Nothing -> P.unexpected "A letter expected"
          go !ls !ncs !dash !lcs !nlcs =
            optional (P.satisfy alphaNumOrDashOrDot) >>= 
              Just '.' -> if dash
                         then P.unexpected "Label ends with a dash"
                         else if ncs == 255
                              then P.unexpected "Host name is too long"
                              else go (reverse (A.ascii '.' : lcs) : ls)
                                      (ncs + 1) False [] 0
              Just c   -> if nlcs == 63
                         then P.unexpected "Label is too long"
                         else if ncs == 255
                              then P.unexpected "Host name is too long"
                              else go ls (ncs + 1) (c == '-')
                                         (A.ascii c : lcs) (nlcs + 1)
              Nothing  -> return $ HN $ BS.pack $ concat
                                $ reverse $ reverse lcs : ls

instance Printable (InetAddr HostName) where
  print (InetAddr n p) = T.print n <> T.char7 ':' <> T.print p

instance Textual (InetAddr HostName) where
  textual = InetAddr <$> T.textual <*> (P.char ':' *> T.textual)

-- | List the 'HostName' labels:
--
-- @
--   'hostNameLabels' ('Data.Maybe.fromJust' ('Data.Textual.fromString' /"www.google.com"/)) = [/"www"/, /"google"/, /"com"/]
-- @
hostNameLabels :: HostName -> [ByteString]
hostNameLabels = BS.split (A.ascii '.') . hostName

-- | Host name for reverse DNS lookups.
--
-- @
--   'Text.Printer.toString' ('arpaHostName' ('IPv4' ('ip4FromOctets' /1/ /2/ /3/ /4/))) = /"4.3.2.1.in-addr.arpa"/
--   'Text.Printer.toString' ('arpaHostName' ('IPv6' ('ip6FromWords' /1/ /2/ /3/ /4/ /5/ /6/ /7/ /8/))) = /"8.0.0.0.7.0.0.0.6.0.0.0.5.0.0.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.ip6.arpa"/
-- @
arpaHostName :: IP -> HostName
arpaHostName (IPv4 a) =
    HN $ BS8.pack $ printf "%i.%i.%i.%i.in-addr.arpa" o4 o3 o2 o1
  where (o1, o2, o3, o4) = ip4ToOctets a
arpaHostName (IPv6 a) =
    HN $ BS8.pack $ digits (reverse $ ip6ToWordList a) ++ "ip6.arpa"
  where digits (w : ws) = [d4, '.', d3, '.', d2, '.', d1, '.'] ++ digits ws
          where d1 = toDigit $ w `shiftR` 12
                d2 = toDigit $ w `shiftR` 8 .&. 0xF
                d3 = toDigit $ w `shiftR` 4 .&. 0xF
                d4 = toDigit $ w .&. 0xF
                toDigit n | n < 10    = chr $ ord '0' + fromIntegral n
                          | otherwise = chr $ ord 'a' + fromIntegral n - 10
        digits [] = []

newtype StateT k v μ α =
  StateT { runStateT :: Map k v -> Maybe Word16 -> μ (Map k v, Maybe Word16, α) }

type CompT μ α   = StateT [ByteString] Word16 μ α
type DecompT μ α = StateT Word16 HostName μ α

compress :: Monad μ => Word16 -> CompT μ α -> μ α
compress i m = do
  (_, _, x) <- runStateT m Map.empty $ Just i
  return x
{-# INLINE compress #-}

decompress :: Monad μ => Word16 -> DecompT μ α -> μ α
decompress i m = do
  (_, _, x) <- runStateT m Map.empty $ Just i
  return x
{-# INLINE decompress #-}

instance Monad μ => Functor (StateT k v μ) where
  fmap f m = StateT $ \ptrs offset -> do
               (ptrs', offset', x) <- runStateT m ptrs offset
               return (ptrs', offset', f x)
  {-# INLINE fmap #-}

instance Monad μ => Applicative (StateT k v μ) where
  pure = return
  {-# INLINE pure #-}
  (<*>) = ap
  {-# INLINE (<*>) #-}

instance Monad μ => Monad (StateT k v μ) where
  return = lift . return
  {-# INLINE return #-}
  m >>= f = StateT $ \ptrs offset -> do
              (ptrs', offset', x) <- runStateT m ptrs offset
              runStateT (f x) ptrs' offset'
  {-# INLINE (>>=) #-}
  fail msg = lift $ fail msg
  {-# INLINE fail #-}

lift :: Monad μ => μ α -> StateT k v μ α
lift m = StateT $ \ptrs offset -> do
           x <- m
           return (ptrs, offset, x)
{-# INLINE lift #-}

getOffset :: Monad μ => StateT k v μ (Maybe Word16)
getOffset = StateT $ \ptrs offset -> return (ptrs, offset, offset)
{-# INLINE getOffset #-}

incOffset :: Monad μ => Word16 -> StateT k v μ ()
incOffset n = StateT $ \ptrs offset -> do
  let offset' = case offset of
        Just i | i' <- i + n, i' >= i && i' <= 0x3FFF -> Just i'
        _ -> Nothing
  return (ptrs, offset', ())
{-# INLINE incOffset #-}

getEntries :: Monad μ => StateT k v μ (Map k v)
getEntries = StateT $ \ptrs offset -> return (ptrs, offset, ptrs)
{-# INLINE getEntries #-}

getEntry :: (Ord k, Monad μ) => k -> StateT k v μ (Maybe v)
getEntry key = StateT $ \ptrs offset -> do
  return (ptrs, offset, Map.lookup key ptrs)
{-# INLINE getEntry #-}

putEntry :: (Ord k, Monad μ) => k -> v -> StateT k v μ ()
putEntry key value = StateT $ \ptrs offset -> do
  return (Map.insert key value ptrs, offset, ())
{-# INLINE putEntry #-}

evalComp :: Monad μ
         => (forall α . μ α -> (α, ByteString)) -> CompT μ ()
         -> CompT μ ByteString
evalComp run m = StateT $ \ptrs offset -> do
  let ((ptrs', offset', _), bs) = run $ runStateT m ptrs offset
  return (ptrs', offset', bs)
{-# INLINE evalComp #-}

threadDecomp :: (forall β . μ β -> μ β) -> DecompT μ α -> DecompT μ α
threadDecomp f m = StateT $ \ptrs offset ->
  f $ runStateT m ptrs offset
{-# INLINE threadDecomp #-}

class (Functor (GetM s), Monad (GetM s), Functor (PutM s), Monad (PutM s))
      => Serializer s where
  type GetM s :: * -> *
  type PutM s :: * -> *
  putWord8 :: s -> Word8 -> PutM s ()
  putWord16be :: s -> Word16 -> PutM s ()
  putWord32be :: s -> Word32 -> PutM s ()
  putIP4 :: s -> IP4 -> PutM s ()
  putIP6 :: s -> IP6 -> PutM s ()
  putByteString :: s -> ByteString -> PutM s ()
  runPutM :: s -> PutM s α -> (α, ByteString)
  getWord8 :: s -> GetM s Word8
  getWord16be :: s -> GetM s Word16
  getWord32be :: s -> GetM s Word32
  getIP4 :: s -> GetM s IP4
  getIP6 :: s -> GetM s IP6
  getByteString :: s -> Int -> GetM s ByteString
  isolate :: s -> Int -> GetM s α -> GetM s α

data BinarySerializer = BinarySerializer

instance Serializer BinarySerializer where
  type GetM BinarySerializer = B.Get
  type PutM BinarySerializer = B.PutM
  putWord8 _ = B.putWord8
  putWord16be _ = B.putWord16be
  putWord32be _ = B.putWord32be
  putIP4 _ = B.put
  putIP6 _ = B.put
  putByteString _ = B.putByteString
  runPutM _ p = (r, BSL.toStrict bs) where (r, bs) = B.runPutM p
  getWord8 _ = B.getWord8
  getWord16be _ = B.getWord16be
  getWord32be _ = B.getWord32be
  getIP4 _ = B.get
  getIP6 _ = B.get
  getByteString _ = B.getBytes
  isolate _ = undefined

data CerealSerializer = CerealSerializer

instance Serializer CerealSerializer where
  type GetM CerealSerializer = S.Get
  type PutM CerealSerializer = S.PutM
  putWord8 _ = S.putWord8
  putWord16be _ = S.putWord16be
  putWord32be _ = S.putWord32be
  putIP4 _ = S.put
  putIP6 _ = S.put
  putByteString _ = S.putByteString
  runPutM _ = S.runPutM
  getWord8 _ = S.getWord8
  getWord16be _ = S.getWord16be
  getWord32be _ = S.getWord32be
  getIP4 _ = S.get
  getIP6 _ = S.get
  getByteString _ = S.getBytes
  isolate _ = S.isolate

serializeHostName :: Serializer s => s -> HostName -> CompT (PutM s) ()
serializeHostName s = go . hostNameLabels
  where
    go [] = do
      lift $ putWord8 s 0
      incOffset 1
    go labels@(label : labels') = do
      entry <- getEntry labels
      case entry of
        Nothing -> do
          let ll = BS.length label
          offset <- getOffset
          lift $ putWord8 s $ fromIntegral ll
          lift $ putByteString s label
          incOffset $ 1 + fromIntegral ll
          forM_ offset $ putEntry labels
          go labels'
        Just ptr -> do
          lift $ putWord16be s $ 0xC000 .|. ptr
          incOffset 2

guard' :: Monad μ => String -> Bool -> μ ()
guard' msg test = unless test $ fail msg
{-# INLINE guard' #-}

deserializeHostName :: Serializer s => s -> DecompT (GetM s) HostName
deserializeHostName s = go []
  where
    folder suffix (label, offset) = do
        forM_ offset $ \i -> putEntry i (HN suffix')
        return suffix'
      where suffix' = BS.append label $ BS.cons (A.ascii '.') suffix
    go labels = do
      offset <- getOffset
      w <- lift $ getWord8 s
      incOffset 1
      if w .&. 0xC0 == 0xC0
      then do
        w' <- lift $ getWord8 s
        incOffset 1
        let ptr = fromIntegral (w .&. 0x3F) `shiftL` 8 .|. fromIntegral w'
        entry <- getEntry ptr
        case entry of
          Nothing -> do
            entries <- getEntries
            fail $ "Invalid pointer " ++ show ptr ++ ": pointer map is " ++
                   show (Map.elems entries)
          Just (HN suffix1) -> HN <$> foldM folder suffix1 labels
      else
        if w == 0
        then do
          guard' "Hostname with zero labels" $ not $ null labels
          let (lastLabel, lastOffset) : labels' = labels
          forM_ lastOffset $ \i -> putEntry i (HN lastLabel)
          HN <$> foldM folder lastLabel labels'
        else do
          guard' "Label is too long" $ w <= 63
          label <- lift $ getByteString s $ fromIntegral w
          incOffset $ fromIntegral w
          go ((BS.map A.toLower8 label, offset) : labels)

-- | Host address. Either a host name or an IP address.
data HostAddr a = HostName {-# UNPACK #-} !HostName
                | HostAddr !a
                deriving (Typeable, Show, Read, Eq, Ord)

type Host4Addr = HostAddr IP4
type Host6Addr = HostAddr IP6

-- | 'HostAddr' proxy value.
aHostAddr :: Proxy HostAddr
aHostAddr = Proxy

-- | 'HostAddr' /a/ proxy value.
aHostAddrOf :: Proxy a -> Proxy (HostAddr a)
aHostAddrOf _ = Proxy

-- | 'Host4Addr' proxy value.
aHost4Addr :: Proxy Host4Addr
aHost4Addr = Proxy

-- | 'Host6Addr' proxy value.
aHost6Addr :: Proxy Host6Addr
aHost6Addr = Proxy

-- | 'HostAddr' 'IP' proxy value.
aHostAddrIP :: Proxy (HostAddr IP)
aHostAddrIP = Proxy

instance Printable a => Printable (HostAddr a) where
  print (HostName name) = T.print name
  print (HostAddr addr) = T.print addr

instance Textual a => Textual (HostAddr a) where
  textual  =  P.try (HostName <$> T.textual)
          <|> (HostAddr <$> T.textual)

instance Printable (InetAddr a) => Printable (InetAddr (HostAddr a)) where
  print (InetAddr (HostName n) p) = T.print $ InetAddr n p
  print (InetAddr (HostAddr a) p) = T.print $ InetAddr a p

instance Textual (InetAddr a) => Textual (InetAddr (HostAddr a)) where
  textual  =  P.try (InetAddr <$> (HostName <$> T.textual)
                              <*> (P.char ':' *> T.textual))
          <|> T.textual

-- | Message identifier.
type DnsId = Word16

-- | Resource Record type.
data DnsType α where
  -- IPv4 address record (/A/)
  AddrDnsType  :: DnsType IP4
  -- IPv6 address record (/AAAA/)
  Addr6DnsType :: DnsType IP6
  -- Name server record (/NS/)
  NsDnsType    :: DnsType HostName
  -- Canonical name record (/CNAME/)
  CNameDnsType :: DnsType HostName
  -- Pointer record (/PTR/)
  PtrDnsType   :: DnsType HostName
  -- Mail exchange record (/MX/)
  MxDnsType    :: DnsType (Word16, HostName)

deriving instance Typeable1 DnsType
deriving instance Eq (DnsType α)

instance Show (DnsType α) where
  showsPrec _ AddrDnsType  = showString "AddrDnsType"
  showsPrec _ Addr6DnsType = showString "Addr6DnsType"
  showsPrec _ NsDnsType    = showString "NsDnsType"
  showsPrec _ CNameDnsType = showString "CNameDnsType"
  showsPrec _ PtrDnsType   = showString "PtrDnsType"
  showsPrec _ MxDnsType    = showString "MxDnsType"

-- | Numeric representation of a Resource Record type.
dnsTypeCode :: DnsType α -> Word16
dnsTypeCode AddrDnsType  = 1
dnsTypeCode Addr6DnsType = 28
dnsTypeCode NsDnsType    = 2
dnsTypeCode CNameDnsType = 5
dnsTypeCode PtrDnsType   = 12
dnsTypeCode MxDnsType    = 15

-- | Resource Record data.
data DnsData = forall α . DnsData { dnsType :: !(DnsType α) -- ^ The type
                             , dnsData :: α            -- ^ The data
                             }
               deriving Typeable

instance Show DnsData where
  showsPrec p (DnsData {..}) = showParen (p > 10)
      $ showString "DnsData {dnsType = "
      . showsPrec (p + 1) dnsType
      . showString ", dnsData = "
      . case dnsType of
          AddrDnsType  -> showsPrec p' dnsData
          Addr6DnsType -> showsPrec p' dnsData
          NsDnsType    -> showsPrec p' dnsData
          CNameDnsType -> showsPrec p' dnsData
          PtrDnsType   -> showsPrec p' dnsData
          MxDnsType    -> showsPrec p' dnsData
      . showString "}"
    where p' = 10 :: Int

-- | Resource Record.
data DnsRecord = DnsRecord { -- | Record owner
                             dnsRecOwner :: {-# UNPACK #-} !HostName
                           , -- | Maximum caching time in secords
                             dnsRecTtl   :: {-# UNPACK #-} !Word32
                           , -- | Record data
                             dnsRecData  :: !DnsData
                           }
                 deriving (Typeable, Show)

serializeDnsRecord :: Serializer s => s -> DnsRecord -> CompT (PutM s) ()
serializeDnsRecord s (DnsRecord {..}) | DnsData tp dt <- dnsRecData = do
  serializeHostName s dnsRecOwner
  lift $ putWord16be s $ dnsTypeCode tp
  lift $ putWord16be s 1
  lift $ putWord32be s dnsRecTtl
  incOffset 10
  d <- evalComp (runPutM s) $ case tp of
    AddrDnsType  -> lift (putIP4 s dt) >> incOffset 4
    Addr6DnsType -> lift (putIP6 s dt) >> incOffset 16
    NsDnsType    -> serializeHostName s dt
    CNameDnsType -> serializeHostName s dt
    PtrDnsType   -> serializeHostName s dt
    MxDnsType    -> do
      lift $ putWord16be s $ fst dt
      incOffset 2
      serializeHostName s $ snd dt
  lift $ putWord16be s $ fromIntegral $ BS.length d
  lift $ putByteString s d

deserializeDnsRecord :: Serializer s => s -> DecompT (GetM s) DnsRecord
deserializeDnsRecord s = do
  owner <- deserializeHostName s
  code  <- lift $ getWord16be s
  void $ lift $ getWord16be s
  ttl   <- lift $ getWord32be s
  len   <- lift $ fromIntegral <$> getWord16be s
  incOffset 10
  dd    <- threadDecomp (isolate s len) $ case code of
    1  -> fmap (DnsData AddrDnsType) $ incOffset 4 >> lift (getIP4 s)
    2  -> DnsData NsDnsType    <$> deserializeHostName s
    5  -> DnsData CNameDnsType <$> deserializeHostName s
    12 -> DnsData PtrDnsType   <$> deserializeHostName s
    28 -> fmap (DnsData Addr6DnsType) $ incOffset 16 >> lift (getIP6 s)
    _  -> fail "Unsupported type"
  return $ DnsRecord owner ttl dd

-- | DNS query type.
data DnsQType = forall α . StdDnsType (DnsType α) -- ^ Record type
              | AllDnsType -- ^ All record types
              deriving Typeable

instance Show DnsQType where
  showsPrec p (StdDnsType t) = showParen (p > 10)
                             $ showString "StdDnsType "
                             . showsPrec (p + 1) t
  showsPrec _ AllDnsType = showString "AllDnsType"

-- | Numeric representation of a DNS query type.
dnsQTypeCode :: DnsQType -> Word16
dnsQTypeCode (StdDnsType t) = dnsTypeCode t
dnsQTypeCode AllDnsType     = 255

instance Eq DnsQType where
  t1 == t2 = dnsQTypeCode t1 == dnsQTypeCode t2

instance Ord DnsQType where
  t1 `compare` t2 = dnsQTypeCode t1 `compare` dnsQTypeCode t2

putDnsQType :: Serializer s => s -> DnsQType -> PutM s ()
putDnsQType s = putWord16be s . dnsQTypeCode

getDnsQType :: Serializer s => s -> GetM s DnsQType
getDnsQType s = getWord16be s >>= 
  1   -> return $ StdDnsType AddrDnsType
  2   -> return $ StdDnsType NsDnsType
  5   -> return $ StdDnsType CNameDnsType
  12  -> return $ StdDnsType PtrDnsType
  28  -> return $ StdDnsType Addr6DnsType
  255 -> return AllDnsType
  _   -> fail "Unsupported query type"

instance Binary DnsQType where
  put = putDnsQType BinarySerializer
  get = getDnsQType BinarySerializer

instance Serialize DnsQType where
  put = putDnsQType CerealSerializer
  get = getDnsQType CerealSerializer

-- | DNS question.
data DnsQuestion = DnsQuestion { -- | Ask about the specified host name
                                 dnsQName :: {-# UNPACK #-} !HostName
                               , -- | Query type
                                 dnsQType :: !DnsQType
                               }
                   deriving (Typeable, Show, Eq, Ord)

serializeDnsQuestion :: Serializer s => s -> DnsQuestion -> CompT (PutM s) ()
serializeDnsQuestion s (DnsQuestion {..}) = do
  serializeHostName s dnsQName
  lift $ do
    putDnsQType s dnsQType
    putWord16be s 1
  incOffset 4

deserializeDnsQuestion :: Serializer s => s -> DecompT (GetM s) DnsQuestion
deserializeDnsQuestion s = do
  q <- DnsQuestion <$> deserializeHostName s <*> lift (getDnsQType s)
  c <- lift $ getWord16be s
  guard' "Unsupported class in a question" $ c == 1
  incOffset 4
  return q

-- | Request message.
data DnsReq -- | Standard query
            = DnsReq { -- | Message identifier
                       dnsReqId       :: {-# UNPACK #-} !DnsId
                     , -- | Truncation flag
                       dnsReqTruncd   :: !Bool
                     , -- | Recursion flag
                       dnsReqRec      :: !Bool
                     , -- | Question
                       dnsReqQuestion :: {-# UNPACK #-} !DnsQuestion
                     }
            -- | Inverse query
            | DnsInvReq { dnsReqId  :: {-# UNPACK #-} !DnsId
                        , -- | IP address
                          dnsReqInv :: !IP
                        }
            deriving (Typeable, Show)

anyHostName :: HostName
anyHostName = HN "any"

putDnsReq :: Serializer s => s -> DnsReq -> PutM s ()
putDnsReq s (DnsReq {..}) = do
  putWord16be s dnsReqId
  putWord8 s  $  if dnsReqRec then 1 else 0
             .|. if dnsReqTruncd then 2 else 0
  putWord8 s 0
  putWord16be s 1
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0
  compress 12 $ serializeDnsQuestion s dnsReqQuestion
putDnsReq s (DnsInvReq {..}) = do
  putWord16be s dnsReqId
  putWord8 s 8
  putWord8 s 0
  putWord16be s 0
  putWord16be s 1
  putWord16be s 0
  putWord16be s 0
  compress 12 $ serializeDnsRecord s $
    DnsRecord { dnsRecOwner = anyHostName
              , dnsRecTtl   = 0
              , dnsRecData  = case dnsReqInv of
                  IPv4 a -> DnsData AddrDnsType a
                  IPv6 a -> DnsData Addr6DnsType a }

getDnsReq :: Serializer s => s -> GetM s DnsReq
getDnsReq s = do
  i <- getWord16be s
  w <- getWord8 s
  void $ getWord8 s
  guard' "Not a request" $ w .&. 128 == 0
  let rec    = w .&. 1 /= 0
      truncd = w .&. 2 /= 0
      opcode = w `shiftR` 3 .&. 0xF
  case opcode of
    0 -> do
      getWord16be s >>= guard' "No questions in query" . (== 1)
      getWord16be s >>= guard' "Answers in query" . (== 0)
      getWord16be s >>= guard' "Authorities in query" . (== 0)
      getWord16be s >>= guard' "Extras in query" . (== 0)
      decompress 12 $ do
        q <- deserializeDnsQuestion s
        return $ DnsReq { dnsReqId       = i
                        , dnsReqTruncd   = truncd
                        , dnsReqRec      = rec
                        , dnsReqQuestion = q }
    1 -> do
      getWord16be s >>= guard' "Questions in inverse query" . (== 0)
      getWord16be s >>= guard' "No answers in inverse query" . (== 1)
      getWord16be s >>= guard' "Authorities in inverse query" . (== 0)
      getWord16be s >>= guard' "Extras in inverse query" . (== 0)
      DnsRecord {dnsRecData} <- decompress 12 $ deserializeDnsRecord s
      case dnsRecData of
        DnsData AddrDnsType a ->
          return $ DnsInvReq { dnsReqId  = i, dnsReqInv = IPv4 a }
        DnsData Addr6DnsType a ->
          return $ DnsInvReq { dnsReqId  = i, dnsReqInv = IPv6 a }
        _ -> fail "Invalid answer RR in inverse query"
    _ -> fail "Invalid opcode in request"

instance Binary DnsReq where
  put = putDnsReq BinarySerializer
  get = getDnsReq BinarySerializer

instance Serialize DnsReq where
  put = putDnsReq CerealSerializer
  get = getDnsReq CerealSerializer

-- | Errors returned in responses.
data DnsError = FormatDnsError
              | FailureDnsError
              | NoNameDnsError
              | NotImplDnsError
              | RefusedDnsError
              | NameExistsDnsError
              | RsExistsDnsError
              | NoRsDnsError
              | NotAuthDnsError
              | NotInZoneDnsError
              deriving (Typeable, Show, Read, Eq, Ord, Enum)

-- | Numerical representation of an error.
dnsErrorCode :: DnsError -> Word8
dnsErrorCode FormatDnsError     = 1
dnsErrorCode FailureDnsError    = 2
dnsErrorCode NoNameDnsError     = 3
dnsErrorCode NotImplDnsError    = 4
dnsErrorCode RefusedDnsError    = 5
dnsErrorCode NameExistsDnsError = 6
dnsErrorCode RsExistsDnsError   = 7
dnsErrorCode NoRsDnsError       = 8
dnsErrorCode NotAuthDnsError    = 9
dnsErrorCode NotInZoneDnsError  = 10

-- | Response message.
data DnsResp -- | Normal response.
             = DnsResp { -- | Request identifer
                         dnsRespId       :: {-# UNPACK #-} !DnsId
                       , -- | Truncation flag
                         dnsRespTruncd   :: !Bool
                       , -- | Authoritative answer flag
                         dnsRespAuthd    :: !Bool
                       , -- | Recursive query support flag
                         dnsRespRec      :: !Bool
                       , -- | Request question
                         dnsRespQuestion :: {-# UNPACK #-} !DnsQuestion
                       , -- | Answer records
                         dnsRespAnswers  :: [DnsRecord]
                       , -- | Authority records
                         dnsRespAuths    :: [DnsRecord]
                       , -- | Additional records
                         dnsRespExtras   :: [DnsRecord]
                       }
             -- | Error response.
             | DnsErrResp { dnsRespId    :: {-# UNPACK #-} !DnsId
                          , -- | Error
                            dnsRespError :: !DnsError
                          }
             deriving (Typeable, Show)

putDnsResp :: Serializer s => s -> DnsResp -> PutM s ()
putDnsResp s (DnsResp {..}) = do
  putWord16be s dnsRespId
  putWord8 s  $  128
             .|. if dnsRespTruncd then 2 else 0
             .|. if dnsRespAuthd then 4 else 0
  putWord8 s $ if dnsRespRec then 128 else 0
  putWord16be s 1
  putWord16be s $ fromIntegral $ length dnsRespAnswers
  putWord16be s $ fromIntegral $ length dnsRespAuths
  putWord16be s $ fromIntegral $ length dnsRespExtras
  compress 12 $ do
    serializeDnsQuestion s dnsRespQuestion
    forM_ dnsRespAnswers (serializeDnsRecord s)
    forM_ dnsRespAuths   (serializeDnsRecord s)
    forM_ dnsRespExtras  (serializeDnsRecord s)
putDnsResp s (DnsErrResp {..}) = do
  putWord16be s dnsRespId
  putWord8 s 8
  putWord8 s $ dnsErrorCode dnsRespError
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0
  putWord16be s 0

getDnsResp :: Serializer s => s -> GetM s DnsResp
getDnsResp s = do
  i <- getWord16be s
  w <- getWord8 s
  guard' "Not a response" $ w .&. 128 /= 0
  w' <- getWord8 s
  let truncd = w .&. 2 /= 0
      authd  = w .&. 4 /= 0
      rec    = w' .&. 128 /= 0
      ec     = w' .&. 0xF
  case ec of
    0 -> do
      getWord16be s >>= guard' "No question in a response" . (== 1)
      anc <- getWord16be s
      nsc <- getWord16be s
      arc <- getWord16be s
      decompress 12 $ do
        q   <- deserializeDnsQuestion s
        ans <- mapM (const $ deserializeDnsRecord s) [1 .. anc]
        nss <- mapM (const $ deserializeDnsRecord s) [1 .. nsc]
        ars <- mapM (const $ deserializeDnsRecord s) [1 .. arc]
        return $ DnsResp { dnsRespId       = i
                         , dnsRespTruncd   = truncd
                         , dnsRespAuthd    = authd
                         , dnsRespRec      = rec
                         , dnsRespQuestion = q
                         , dnsRespAnswers  = ans
                         , dnsRespAuths    = nss
                         , dnsRespExtras   = ars }
    _ -> do
      void $ getWord16be s
      void $ getWord16be s
      void $ getWord16be s
      void $ getWord16be s
      DnsErrResp i <$> case ec of
        1  -> return FormatDnsError
        2  -> return FailureDnsError
        3  -> return NoNameDnsError
        4  -> return NotImplDnsError
        5  -> return RefusedDnsError
        6  -> return NameExistsDnsError
        7  -> return RsExistsDnsError
        8  -> return NoRsDnsError
        9  -> return NotAuthDnsError
        10 -> return NotInZoneDnsError
        _  -> fail "Unknown error code in a response"

instance Binary DnsResp where
  put = putDnsResp BinarySerializer
  get = getDnsResp BinarySerializer

instance Serialize DnsResp where
  put = putDnsResp CerealSerializer
  get = getDnsResp CerealSerializer


</pre>