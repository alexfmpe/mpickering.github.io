<a href="VarLookup.hs564552520851451194.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Vector.hs17700249701866192546.out.html">next</a></br></br><pre>56c56
< {-# LINE 84 "src/ehc/VarMp.chs" #-}
---
> 
56a57
> 
56a58
> 
56a59
> 
56a60
> 
56a61
> 
56a62
> 
56a63
> 
56a64
> 
56a65
> 
56a66
> 
56a67
> 
56a68
> 
56a69
> 
56a70
> 
56a71
> 
56a72
> 
56a73
> 
56a74
> 
56a75
> 
56a76
> 
56a77
> 
56a78
> 
56a79
> 
56a80
> 
56a81
> 
56a82
> 
56a83
> 
60c87
< {-# LINE 163 "src/ehc/VarMp.chs" #-}
---
> 
60a88
> 
60a89
> 
60a90
> 
60a91
> 
60a92
> 
60a93
> 
60a94
> 
60a95
> 
60a96
> 
60a97
> 
60a98
> 
60a99
> 
60a100
> 
60a101
> 
60a102
> 
60a103
> 
60a104
> 
60a105
> 
60a106
> 
60a107
> 
60a108
> 
60a109
> 
60a110
> 
60a111
> 
60a112
> 
60a113
> 
60a114
> 
60a115
> 
60a116
> 
60a117
> 
60a118
> 
60a119
> 
60a120
> 
60a121
> 
60a122
> 
60a123
> 
60a124
> 
60a125
> 
60a126
> 
60a127
> 
60a128
> 
60a129
> 
60a130
> 
60a131
> 
60a132
> 
60a133
> 
60a134
> 
60a135
> 
60a136
> 
60a137
> 
60a138
> 
60a139
> 
60a140
> 
60a141
> 
60a142
> 
60a143
> 
60a144
> 
60a145
> 
60a146
> 
60a147
> 
60a148
> 
60a149
> 
60a150
> 
60a151
> 
60a152
> 
60a153
> 
60a154
> 
60a155
> 
60a156
> 
60a157
> 
60a158
> 
60a159
> 
60a160
> 
60a161
> 
60a162
> 
71c173
< {-# LINE 206 "src/ehc/VarMp.chs" #-}
---
> 
71a174
> 
71a175
> 
71a176
> 
71a177
> 
71a178
> 
71a179
> 
71a180
> 
71a181
> 
71a182
> 
71a183
> 
71a184
> 
71a185
> 
71a186
> 
71a187
> 
71a188
> 
71a189
> 
71a190
> 
71a191
> 
71a192
> 
71a193
> 
71a194
> 
71a195
> 
71a196
> 
71a197
> 
71a198
> 
71a199
> 
71a200
> 
71a201
> 
71a202
> 
71a203
> 
71a204
> 
71a205
> 
75c209
< {-# LINE 215 "src/ehc/VarMp.chs" #-}
---
> 
75a210
> 
75a211
> 
75a212
> 
75a213
> 
75a214
> 
91c230
< {-# LINE 244 "src/ehc/VarMp.chs" #-}
---
> 
91a231
> 
91a232
> 
91a233
> 
91a234
> 
91a235
> 
91a236
> 
91a237
> 
91a238
> 
91a239
> 
91a240
> 
91a241
> 
91a242
> 
91a243
> 
94c246
< {-# LINE 254 "src/ehc/VarMp.chs" #-}
---
> 
94a247
> 
94a248
> 
94a249
> 
94a250
> 
94a251
> 
94a252
> 
94a253
> 
99c258
< {-# LINE 260 "src/ehc/VarMp.chs" #-}
---
> 
99a259
> 
102c262
< {-# LINE 264 "src/ehc/VarMp.chs" #-}
---
> 
102a263
> 
105c266
< {-# LINE 278 "src/ehc/VarMp.chs" #-}
---
> 
105a267
> 
105a268
> 
105a269
> 
105a270
> 
105a271
> 
105a272
> 
105a273
> 
105a274
> 
105a275
> 
105a276
> 
105a277
> 
108c280
< {-# LINE 287 "src/ehc/VarMp.chs" #-}
---
> 
108a281
> 
108a282
> 
108a283
> 
108a284
> 
108a285
> 
108a286
> 
114c292
< {-# LINE 298 "src/ehc/VarMp.chs" #-}
---
> 
114a293
> 
114a294
> 
114a295
> 
114a296
> 
114a297
> 
120c303
< {-# LINE 309 "src/ehc/VarMp.chs" #-}
---
> 
120a304
> 
120a305
> 
120a306
> 
120a307
> 
120a308
> 
150c338
< {-# LINE 351 "src/ehc/VarMp.chs" #-}
---
> 
150a339
> 
150a340
> 
150a341
> 
150a342
> 
150a343
> 
150a344
> 
150a345
> 
150a346
> 
150a347
> 
150a348
> 
150a349
> 
150a350
> 
158c358
< {-# LINE 369 "src/ehc/VarMp.chs" #-}
---
> 
158a359
> 
158a360
> 
158a361
> 
158a362
> 
158a363
> 
158a364
> 
158a365
> 
158a366
> 
158a367
> 
158a368
> 
165c375
< {-# LINE 382 "src/ehc/VarMp.chs" #-}
---
> 
165a376
> 
165a377
> 
165a378
> 
165a379
> 
165a380
> 
165a381
> 
181c397
< {-# LINE 400 "src/ehc/VarMp.chs" #-}
---
> 
181a398
> 
181a399
> 
189c407
< {-# LINE 411 "src/ehc/VarMp.chs" #-}
---
> 
189a408
> 
189a409
> 
189a410
> 
193c414
< {-# LINE 416 "src/ehc/VarMp.chs" #-}
---
> 
193a415
> 
198c420
< {-# LINE 426 "src/ehc/VarMp.chs" #-}
---
> 
198a421
> 
198a422
> 
198a423
> 
198a424
> 
198a425
> 
211c438
< {-# LINE 451 "src/ehc/VarMp.chs" #-}
---
> 
211a439
> 
211a440
> 
211a441
> 
211a442
> 
211a443
> 
211a444
> 
211a445
> 
211a446
> 
211a447
> 
211a448
> 
211a449
> 
211a450
> 
215c454
< {-# LINE 456 "src/ehc/VarMp.chs" #-}
---
> 
215a455
> 
228c468
< {-# LINE 470 "src/ehc/VarMp.chs" #-}
---
> 
228a469
> 
235c476
< {-# LINE 478 "src/ehc/VarMp.chs" #-}
---
> 
235a477
> 
239c481
< {-# LINE 487 "src/ehc/VarMp.chs" #-}
---
> 
239a482
> 
239a483
> 
239a484
> 
239a485
> 
239a486
> 
243c490
< {-# LINE 496 "src/ehc/VarMp.chs" #-}
---
> 
243a491
> 
243a492
> 
243a493
> 
243a494
> 
243a495
> 
256c508
< {-# LINE 510 "src/ehc/VarMp.chs" #-}
---
> 
256a509
> 
263c516
< {-# LINE 522 "src/ehc/VarMp.chs" #-}
---
> 
263a517
> 
263a518
> 
263a519
> 
263a520
> 
263a521
> 
267c525
< {-# LINE 527 "src/ehc/VarMp.chs" #-}
---
> 
267a526
> 
283c542
< {-# LINE 544 "src/ehc/VarMp.chs" #-}
---
> 
283a543
> 
288c548
< {-# LINE 572 "src/ehc/VarMp.chs" #-}
---
> 
288a549
> 
288a550
> 
288a551
> 
288a552
> 
288a553
> 
288a554
> 
288a555
> 
288a556
> 
288a557
> 
288a558
> 
288a559
> 
288a560
> 
288a561
> 
288a562
> 
288a563
> 
288a564
> 
288a565
> 
288a566
> 
288a567
> 
288a568
> 
288a569
> 
288a570
> 
288a571
> 
303c586
< {-# LINE 588 "src/ehc/VarMp.chs" #-}
---
> 
303a587
> 
314c598
< {-# LINE 610 "src/ehc/VarMp.chs" #-}
---
> 
314a599
> 
314a600
> 
314a601
> 
314a602
> 
314a603
> 
314a604
> 
314a605
> 
314a606
> 
314a607
> 
314a608
> 
314a609
> 
335a631
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.VarMp
( vmiMbTy
, tyAsVarMp', tyAsVarMp
, varmpTyLookupCyc
, varmpTyLookupCyc2
, module UHC.Util.VarMp
, module UHC.Light.Compiler.VarLookup
, assocMetaLevTyLToVarMp, assocTyLToVarMp, varmpToAssocTyL
, instToL1VarMp
, VarMpInfo (..)
, VarMp
, varmpFilterTy
, varmpMetaLevTyUnit, varmpTyUnit
, tyRestrictKiVarMp
, varmpTyLookup
, vmiMbImpls, vmiMbScope, vmiMbPred, vmiMbAssNm
, varmpTailAddOcc
, varmpMapThr, varmpMapThrTy
, varmpImplsUnit, assocImplsLToVarMp, varmpScopeUnit, varmpPredUnit, varmpAssNmUnit
, varmpImplsLookup, varmpScopeLookup, varmpPredLookup
, varmpImplsLookupImplsCyc, varmpImplsLookupCyc, varmpScopeLookupScopeCyc, varmpAssNmLookupAssNmCyc
, varmpPredLookup2, varmpScopeLookup2, varmpAssNmLookup2, varmpImplsLookupCyc2
, vmiMbLabel, vmiMbOffset
, varmpLabelUnit, varmpOffsetUnit
, varmpLabelLookup, varmpOffsetLookup
, varmpLabelLookupCyc, varmpLabelLookupLabelCyc
, vmiMbPredSeq
, varmpPredSeqUnit
, varmpPredSeqLookup
, varmpinfoMkVar
, ppVarMpInfoCfgTy, ppVarMpInfoDt )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty.Pretty
import UHC.Light.Compiler.Error
import UHC.Util.VarMp
import UHC.Light.Compiler.VarLookup
import UHC.Light.Compiler.Base.Debug
import UHC.Util.Utils
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize







{-# LINE 84 "src/ehc/VarMp.chs" #-}
-- moved to package uhc-util


{-# LINE 163 "src/ehc/VarMp.chs" #-}
assocMetaLevTyLToVarMp :: Ord k => AssocL k (MetaLev,Ty) -> VarMp' k VarMpInfo
assocMetaLevTyLToVarMp = assocMetaLevLToVarMp . assocLMapElt (\(ml,t) -> (ml, VMITy t)) -- varmpUnions [ varmpMetaLevTyUnit lev v t | (v,(lev,t)) <- l ]

assocTyLToVarMp :: Ord k => AssocL k Ty -> VarMp' k VarMpInfo
assocTyLToVarMp = assocLToVarMp . assocLMapElt VMITy

varmpToAssocTyL :: VarMp' k VarMpInfo -> AssocL k Ty
varmpToAssocTyL c = [ (v,t) | (v,VMITy t) <- varmpToAssocL c ]


{-# LINE 206 "src/ehc/VarMp.chs" #-}
instToL1VarMp :: [InstTo] -> VarMp
instToL1VarMp = varmpIncMetaLev . assocMetaLevTyLToVarMp . instToL1AssocL

{-# LINE 215 "src/ehc/VarMp.chs" #-}
data VarMpInfo
  = VMITy      !Ty
  | VMIImpls   !Impls
  | VMIScope   !PredScope
  | VMIPred    !Pred
  | VMIAssNm   !VarUIDHsName
  | VMILabel   !Label
  | VMIOffset  !LabelOffset
--  | VMIExts    !RowExts
  | VMIPredSeq !PredSeq
  deriving
    ( Eq, Ord, Show
    , Typeable, Data
    )

{-# LINE 244 "src/ehc/VarMp.chs" #-}
vmiMbTy      i = case i of {VMITy      x -> Just x; _ -> Nothing}

{-# LINE 254 "src/ehc/VarMp.chs" #-}
vmiMbImpls   i = case i of {VMIImpls   x -> Just x; _ -> Nothing}
vmiMbScope   i = case i of {VMIScope   x -> Just x; _ -> Nothing}
vmiMbPred    i = case i of {VMIPred    x -> Just x; _ -> Nothing}
vmiMbAssNm   i = case i of {VMIAssNm   x -> Just x; _ -> Nothing}
{-# LINE 260 "src/ehc/VarMp.chs" #-}
vmiMbLabel   i = case i of {VMILabel   x -> Just x; _ -> Nothing}
vmiMbOffset  i = case i of {VMIOffset  x -> Just x; _ -> Nothing}
{-# LINE 264 "src/ehc/VarMp.chs" #-}
vmiMbPredSeq i = case i of {VMIPredSeq x -> Just x; _ -> Nothing}

{-# LINE 278 "src/ehc/VarMp.chs" #-}
type VarMp  = VarMp' VarId VarMpInfo

{-# LINE 287 "src/ehc/VarMp.chs" #-}
varmpFilterTy :: Ord k => (k -> Ty -> Bool) -> VarMp' k VarMpInfo -> VarMp' k VarMpInfo
varmpFilterTy f
  = varmpFilter
        (\v i -> case i of {VMITy t -> f v t ; _ -> True})

{-# LINE 298 "src/ehc/VarMp.chs" #-}
varmpTailAddOcc :: ImplsProveOcc -> Impls -> (Impls,VarMp)
varmpTailAddOcc o (Impls_Tail i os) = (t, varmpImplsUnit i t)
                                    where t = Impls_Tail i (o:os)
varmpTailAddOcc _ x                 = (x,emptyVarMp)

{-# LINE 309 "src/ehc/VarMp.chs" #-}
varmpMapThr :: (MetaLev -> TyVarId -> VarMpInfo -> thr -> (VarMpInfo,thr)) -> thr -> VarMp -> (VarMp,thr)
varmpMapThr f thr (VarMp l ms)
  = (VarMp l ms',thr')
  where (ms',thr') = foldMlev thr ms
        foldMp mlev thr fm
          = Map.foldrWithKey
              (\v i (fm,thr)
                 -> let  (i',thr') = f mlev v i thr
                    in   (Map.insert v i' fm,thr')
              )
              (Map.empty,thr) fm
        foldMlev thr ms
          = foldr
              (\(mlev,m) (ms,thr)
                -> let (m',thr') = foldMp mlev thr m
                   in  (m':ms,thr')
              )
              ([],thr) (zip [0..] ms)

varmpMapThrTy :: (MetaLev -> TyVarId -> Ty -> thr -> (Ty,thr)) -> thr -> VarMp -> (VarMp,thr)
varmpMapThrTy f
  = varmpMapThr
      (\mlev v i thr
         -> case i of
              VMITy t -> (VMITy t,thr')
                      where (t',thr') = f mlev v t thr
              _       -> (i,thr)
      )

{-# LINE 351 "src/ehc/VarMp.chs" #-}
varmpinfoMkVar :: TyVarId -> VarMpInfo -> Ty
varmpinfoMkVar v i
  = case i of
      VMITy       t -> mkTyVar v
      VMIImpls    i -> mkImplsVar v
      _             -> mkTyVar v                    -- rest incomplete

{-# LINE 369 "src/ehc/VarMp.chs" #-}
varmpMetaLevTyUnit :: Ord k => MetaLev -> k -> Ty -> VarMp' k VarMpInfo
varmpMetaLevTyUnit mlev v t = varmpMetaLevSingleton mlev v (VMITy t)

varmpTyUnit :: Ord k => k -> Ty -> VarMp' k VarMpInfo
varmpTyUnit = varmpMetaLevTyUnit metaLevVal

{-# LINE 382 "src/ehc/VarMp.chs" #-}
varmpImplsUnit :: ImplsVarId -> Impls -> VarMp
varmpImplsUnit v i = mkVarMp (Map.fromList [(v,VMIImpls i)])

varmpScopeUnit :: TyVarId -> PredScope -> VarMp
varmpScopeUnit v sc = mkVarMp (Map.fromList [(v,VMIScope sc)])

varmpPredUnit :: TyVarId -> Pred -> VarMp
varmpPredUnit v p = mkVarMp (Map.fromList [(v,VMIPred p)])

varmpAssNmUnit :: TyVarId -> VarUIDHsName -> VarMp
varmpAssNmUnit v p = mkVarMp (Map.fromList [(v,VMIAssNm p)])

assocImplsLToVarMp :: AssocL ImplsVarId Impls -> VarMp
assocImplsLToVarMp = mkVarMp . Map.fromList . assocLMapElt VMIImpls

{-# LINE 400 "src/ehc/VarMp.chs" #-}
varmpLabelUnit :: LabelVarId -> Label -> VarMp
varmpLabelUnit v l = mkVarMp (Map.fromList [(v,VMILabel l)])

varmpOffsetUnit :: UID -> LabelOffset -> VarMp
varmpOffsetUnit v l = mkVarMp (Map.fromList [(v,VMIOffset l)])


{-# LINE 411 "src/ehc/VarMp.chs" #-}
varmpPredSeqUnit :: TyVarId -> PredSeq -> VarMp
varmpPredSeqUnit v l = mkVarMp (Map.fromList [(v,VMIPredSeq l)])

{-# LINE 416 "src/ehc/VarMp.chs" #-}
-- restrict the kinds of tvars bound to value identifiers to kind *
tyRestrictKiVarMp :: [Ty] -> VarMp
tyRestrictKiVarMp ts = varmpIncMetaLev $ assocTyLToVarMp [ (v,kiStar) | t <- ts, v <- maybeToList $ tyMbVar t ]

{-# LINE 426 "src/ehc/VarMp.chs" #-}
-- | Encode 'ty' as a tvar + VarMp, with additional initial construction
tyAsVarMp' :: (UID -> Ty -> Ty) -> UID -> Ty -> (Ty,VarMp)
tyAsVarMp' f u t
  = case f v1 t of
      t | tyIsVar t -> (t, emptyVarMp)
        | otherwise -> (mkTyVar v2, varmpTyUnit v2 t)
  where [v1,v2] = mkNewLevUIDL 2 u

-- | Encode 'ty' as a tvar + VarMp
tyAsVarMp :: UID -> Ty -> (Ty,VarMp)
tyAsVarMp = tyAsVarMp' (flip const)

{-# LINE 451 "src/ehc/VarMp.chs" #-}
varmpTyLookup :: (VarLookup m k VarMpInfo,Ord k) => k -> m -> Maybe Ty
varmpTyLookup = varlookupMap vmiMbTy

{-# LINE 456 "src/ehc/VarMp.chs" #-}
varmpImplsLookup :: VarLookup m ImplsVarId VarMpInfo => ImplsVarId -> m -> Maybe Impls
varmpImplsLookup = varlookupMap vmiMbImpls

varmpScopeLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe PredScope
varmpScopeLookup = varlookupMap vmiMbScope

varmpPredLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe Pred
varmpPredLookup = varlookupMap vmiMbPred

varmpAssNmLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe VarUIDHsName
varmpAssNmLookup = varlookupMap vmiMbAssNm

{-# LINE 470 "src/ehc/VarMp.chs" #-}
varmpLabelLookup :: VarLookup m LabelVarId VarMpInfo => LabelVarId -> m -> Maybe Label
varmpLabelLookup = varlookupMap vmiMbLabel

varmpOffsetLookup :: VarLookup m UID VarMpInfo => UID -> m -> Maybe LabelOffset
varmpOffsetLookup = varlookupMap vmiMbOffset

{-# LINE 478 "src/ehc/VarMp.chs" #-}
varmpPredSeqLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe PredSeq
varmpPredSeqLookup = varlookupMap vmiMbPredSeq

{-# LINE 487 "src/ehc/VarMp.chs" #-}
varmpTyLookupCyc :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe Ty
varmpTyLookupCyc x m = lookupLiftCycMb2 tyMbVar (flip varmpTyLookup m) x

{-# LINE 496 "src/ehc/VarMp.chs" #-}
varmpImplsLookupImplsCyc :: VarLookup m ImplsVarId VarMpInfo => Impls -> m -> Maybe Impls
varmpImplsLookupImplsCyc x m = lookupLiftCycMb1 implsMbVar (flip varmpImplsLookup m) x

varmpImplsLookupCyc :: VarLookup m ImplsVarId VarMpInfo => TyVarId -> m -> Maybe Impls
varmpImplsLookupCyc x m = lookupLiftCycMb2 implsMbVar (flip varmpImplsLookup m) x

varmpScopeLookupScopeCyc :: VarLookup m ImplsVarId VarMpInfo => PredScope -> m -> Maybe PredScope
varmpScopeLookupScopeCyc x m = lookupLiftCycMb1 pscpMbVar (flip varmpScopeLookup m) x

varmpAssNmLookupAssNmCyc :: VarLookup m ImplsVarId VarMpInfo => VarUIDHsName -> m -> Maybe VarUIDHsName
varmpAssNmLookupAssNmCyc x m = lookupLiftCycMb1 vunmMbVar (flip varmpAssNmLookup m) x

{-# LINE 510 "src/ehc/VarMp.chs" #-}
varmpLabelLookupLabelCyc :: VarLookup m ImplsVarId VarMpInfo => Label -> m -> Maybe Label
varmpLabelLookupLabelCyc x m = lookupLiftCycMb1 labelMbVar (flip varmpLabelLookup m) x

varmpLabelLookupCyc :: VarLookup m ImplsVarId VarMpInfo => TyVarId -> m -> Maybe Label
varmpLabelLookupCyc x m = lookupLiftCycMb2 labelMbVar (flip varmpLabelLookup m) x

{-# LINE 522 "src/ehc/VarMp.chs" #-}
varmpTyLookupCyc2 :: VarMp -> TyVarId -> Maybe Ty
varmpTyLookupCyc2 x m = varmpTyLookupCyc m x

{-# LINE 527 "src/ehc/VarMp.chs" #-}
varmpScopeLookup2 :: VarMp -> TyVarId -> Maybe PredScope
varmpScopeLookup2 m v = varmpScopeLookup v m

varmpImplsLookup2 :: VarMp -> ImplsVarId -> Maybe Impls
varmpImplsLookup2 m v = varmpImplsLookup v m

varmpImplsLookupCyc2 :: VarMp -> ImplsVarId -> Maybe Impls
varmpImplsLookupCyc2 m v = varmpImplsLookupCyc v m

varmpPredLookup2 :: VarMp -> TyVarId -> Maybe Pred
varmpPredLookup2 m v = varmpPredLookup v m

varmpAssNmLookup2 :: VarMp -> TyVarId -> Maybe VarUIDHsName
varmpAssNmLookup2 m v = varmpAssNmLookup v m

{-# LINE 544 "src/ehc/VarMp.chs" #-}
varmpLabelLookup2 :: VarMp -> LabelVarId -> Maybe Label
varmpLabelLookup2 m v = varmpLabelLookup v m


{-# LINE 572 "src/ehc/VarMp.chs" #-}
ppVarMpInfoCfgTy :: CfgPPTy -> VarMpInfo -> PP_Doc
ppVarMpInfoCfgTy c i
  = case i of
      VMITy       t -> ppTyWithCfg    c t
      VMIImpls    i -> ppImplsWithCfg c i
      VMIScope    s -> pp s                     -- rest incomplete
      VMIPred     p -> pp p
      VMILabel    x -> pp x
      VMIOffset   x -> pp x
      VMIPredSeq  x -> pp "predseq" -- pp x

ppVarMpInfoDt :: VarMpInfo -> PP_Doc
ppVarMpInfoDt = ppVarMpInfoCfgTy cfgPPTyDT

{-# LINE 588 "src/ehc/VarMp.chs" #-}
instance PP VarMpInfo where
  pp (VMITy       t) = pp t
  pp (VMIImpls    i) = pp i
  pp (VMIScope    s) = pp s
  pp (VMIPred     p) = pp p
  pp (VMILabel    x) = pp x
  pp (VMIOffset   x) = pp x
  -- pp (VMIExts     x) = pp "exts" -- pp x
  pp (VMIPredSeq  x) = pp "predseq" -- pp x

{-# LINE 610 "src/ehc/VarMp.chs" #-}
instance Serialize VarMpInfo where
  sput (VMITy      a) = sputWord8 0  >> sput a
  sput (VMIImpls   a) = sputWord8 1  >> sput a
  sput (VMIScope   a) = sputWord8 2  >> sput a
  sput (VMIPred    a) = sputWord8 3  >> sput a
  sput (VMIAssNm   a) = sputWord8 4  >> sput a
  sput (VMILabel   a) = sputWord8 5  >> sput a
  sput (VMIOffset  a) = sputWord8 6  >> sput a
  sput (VMIPredSeq a) = sputWord8 7  >> sput a
  sget = do t <- sgetWord8
            case t of
              0 -> liftM VMITy      sget
              1 -> liftM VMIImpls   sget
              2 -> liftM VMIScope   sget
              3 -> liftM VMIPred    sget
              4 -> liftM VMIAssNm   sget
              5 -> liftM VMILabel   sget
              6 -> liftM VMIOffset  sget
              7 -> liftM VMIPredSeq sget


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.VarMp
( vmiMbTy
, tyAsVarMp', tyAsVarMp
, varmpTyLookupCyc
, varmpTyLookupCyc2
, module UHC.Util.VarMp
, module UHC.Light.Compiler.VarLookup
, assocMetaLevTyLToVarMp, assocTyLToVarMp, varmpToAssocTyL
, instToL1VarMp
, VarMpInfo (..)
, VarMp
, varmpFilterTy
, varmpMetaLevTyUnit, varmpTyUnit
, tyRestrictKiVarMp
, varmpTyLookup
, vmiMbImpls, vmiMbScope, vmiMbPred, vmiMbAssNm
, varmpTailAddOcc
, varmpMapThr, varmpMapThrTy
, varmpImplsUnit, assocImplsLToVarMp, varmpScopeUnit, varmpPredUnit, varmpAssNmUnit
, varmpImplsLookup, varmpScopeLookup, varmpPredLookup
, varmpImplsLookupImplsCyc, varmpImplsLookupCyc, varmpScopeLookupScopeCyc, varmpAssNmLookupAssNmCyc
, varmpPredLookup2, varmpScopeLookup2, varmpAssNmLookup2, varmpImplsLookupCyc2
, vmiMbLabel, vmiMbOffset
, varmpLabelUnit, varmpOffsetUnit
, varmpLabelLookup, varmpOffsetLookup
, varmpLabelLookupCyc, varmpLabelLookupLabelCyc
, vmiMbPredSeq
, varmpPredSeqUnit
, varmpPredSeqLookup
, varmpinfoMkVar
, ppVarMpInfoCfgTy, ppVarMpInfoDt )
where
import Data.List
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Maybe
import UHC.Util.Pretty
import UHC.Light.Compiler.Ty.Pretty
import UHC.Light.Compiler.Error
import UHC.Util.VarMp
import UHC.Light.Compiler.VarLookup
import UHC.Light.Compiler.Base.Debug
import UHC.Util.Utils
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize



































-- moved to package uhc-util














































































assocMetaLevTyLToVarMp :: Ord k => AssocL k (MetaLev,Ty) -> VarMp' k VarMpInfo
assocMetaLevTyLToVarMp = assocMetaLevLToVarMp . assocLMapElt (\(ml,t) -> (ml, VMITy t)) -- varmpUnions [ varmpMetaLevTyUnit lev v t | (v,(lev,t)) <- l ]

assocTyLToVarMp :: Ord k => AssocL k Ty -> VarMp' k VarMpInfo
assocTyLToVarMp = assocLToVarMp . assocLMapElt VMITy

varmpToAssocTyL :: VarMp' k VarMpInfo -> AssocL k Ty
varmpToAssocTyL c = [ (v,t) | (v,VMITy t) <- varmpToAssocL c ]



































instToL1VarMp :: [InstTo] -> VarMp
instToL1VarMp = varmpIncMetaLev . assocMetaLevTyLToVarMp . instToL1AssocL







data VarMpInfo
  = VMITy      !Ty
  | VMIImpls   !Impls
  | VMIScope   !PredScope
  | VMIPred    !Pred
  | VMIAssNm   !VarUIDHsName
  | VMILabel   !Label
  | VMIOffset  !LabelOffset
--  | VMIExts    !RowExts
  | VMIPredSeq !PredSeq
  deriving
    ( Eq, Ord, Show
    , Typeable, Data
    )















vmiMbTy      i = case i of {VMITy      x -> Just x; _ -> Nothing}









vmiMbImpls   i = case i of {VMIImpls   x -> Just x; _ -> Nothing}
vmiMbScope   i = case i of {VMIScope   x -> Just x; _ -> Nothing}
vmiMbPred    i = case i of {VMIPred    x -> Just x; _ -> Nothing}
vmiMbAssNm   i = case i of {VMIAssNm   x -> Just x; _ -> Nothing}


vmiMbLabel   i = case i of {VMILabel   x -> Just x; _ -> Nothing}
vmiMbOffset  i = case i of {VMIOffset  x -> Just x; _ -> Nothing}


vmiMbPredSeq i = case i of {VMIPredSeq x -> Just x; _ -> Nothing}













type VarMp  = VarMp' VarId VarMpInfo








varmpFilterTy :: Ord k => (k -> Ty -> Bool) -> VarMp' k VarMpInfo -> VarMp' k VarMpInfo
varmpFilterTy f
  = varmpFilter
        (\v i -> case i of {VMITy t -> f v t ; _ -> True})







varmpTailAddOcc :: ImplsProveOcc -> Impls -> (Impls,VarMp)
varmpTailAddOcc o (Impls_Tail i os) = (t, varmpImplsUnit i t)
                                    where t = Impls_Tail i (o:os)
varmpTailAddOcc _ x                 = (x,emptyVarMp)







varmpMapThr :: (MetaLev -> TyVarId -> VarMpInfo -> thr -> (VarMpInfo,thr)) -> thr -> VarMp -> (VarMp,thr)
varmpMapThr f thr (VarMp l ms)
  = (VarMp l ms',thr')
  where (ms',thr') = foldMlev thr ms
        foldMp mlev thr fm
          = Map.foldrWithKey
              (\v i (fm,thr)
                 -> let  (i',thr') = f mlev v i thr
                    in   (Map.insert v i' fm,thr')
              )
              (Map.empty,thr) fm
        foldMlev thr ms
          = foldr
              (\(mlev,m) (ms,thr)
                -> let (m',thr') = foldMp mlev thr m
                   in  (m':ms,thr')
              )
              ([],thr) (zip [0..] ms)

varmpMapThrTy :: (MetaLev -> TyVarId -> Ty -> thr -> (Ty,thr)) -> thr -> VarMp -> (VarMp,thr)
varmpMapThrTy f
  = varmpMapThr
      (\mlev v i thr
         -> case i of
              VMITy t -> (VMITy t,thr')
                      where (t',thr') = f mlev v t thr
              _       -> (i,thr)
      )














varmpinfoMkVar :: TyVarId -> VarMpInfo -> Ty
varmpinfoMkVar v i
  = case i of
      VMITy       t -> mkTyVar v
      VMIImpls    i -> mkImplsVar v
      _             -> mkTyVar v                    -- rest incomplete












varmpMetaLevTyUnit :: Ord k => MetaLev -> k -> Ty -> VarMp' k VarMpInfo
varmpMetaLevTyUnit mlev v t = varmpMetaLevSingleton mlev v (VMITy t)

varmpTyUnit :: Ord k => k -> Ty -> VarMp' k VarMpInfo
varmpTyUnit = varmpMetaLevTyUnit metaLevVal








varmpImplsUnit :: ImplsVarId -> Impls -> VarMp
varmpImplsUnit v i = mkVarMp (Map.fromList [(v,VMIImpls i)])

varmpScopeUnit :: TyVarId -> PredScope -> VarMp
varmpScopeUnit v sc = mkVarMp (Map.fromList [(v,VMIScope sc)])

varmpPredUnit :: TyVarId -> Pred -> VarMp
varmpPredUnit v p = mkVarMp (Map.fromList [(v,VMIPred p)])

varmpAssNmUnit :: TyVarId -> VarUIDHsName -> VarMp
varmpAssNmUnit v p = mkVarMp (Map.fromList [(v,VMIAssNm p)])

assocImplsLToVarMp :: AssocL ImplsVarId Impls -> VarMp
assocImplsLToVarMp = mkVarMp . Map.fromList . assocLMapElt VMIImpls




varmpLabelUnit :: LabelVarId -> Label -> VarMp
varmpLabelUnit v l = mkVarMp (Map.fromList [(v,VMILabel l)])

varmpOffsetUnit :: UID -> LabelOffset -> VarMp
varmpOffsetUnit v l = mkVarMp (Map.fromList [(v,VMIOffset l)])






varmpPredSeqUnit :: TyVarId -> PredSeq -> VarMp
varmpPredSeqUnit v l = mkVarMp (Map.fromList [(v,VMIPredSeq l)])



-- restrict the kinds of tvars bound to value identifiers to kind *
tyRestrictKiVarMp :: [Ty] -> VarMp
tyRestrictKiVarMp ts = varmpIncMetaLev $ assocTyLToVarMp [ (v,kiStar) | t <- ts, v <- maybeToList $ tyMbVar t ]







-- | Encode 'ty' as a tvar + VarMp, with additional initial construction
tyAsVarMp' :: (UID -> Ty -> Ty) -> UID -> Ty -> (Ty,VarMp)
tyAsVarMp' f u t
  = case f v1 t of
      t | tyIsVar t -> (t, emptyVarMp)
        | otherwise -> (mkTyVar v2, varmpTyUnit v2 t)
  where [v1,v2] = mkNewLevUIDL 2 u

-- | Encode 'ty' as a tvar + VarMp
tyAsVarMp :: UID -> Ty -> (Ty,VarMp)
tyAsVarMp = tyAsVarMp' (flip const)














varmpTyLookup :: (VarLookup m k VarMpInfo,Ord k) => k -> m -> Maybe Ty
varmpTyLookup = varlookupMap vmiMbTy



varmpImplsLookup :: VarLookup m ImplsVarId VarMpInfo => ImplsVarId -> m -> Maybe Impls
varmpImplsLookup = varlookupMap vmiMbImpls

varmpScopeLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe PredScope
varmpScopeLookup = varlookupMap vmiMbScope

varmpPredLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe Pred
varmpPredLookup = varlookupMap vmiMbPred

varmpAssNmLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe VarUIDHsName
varmpAssNmLookup = varlookupMap vmiMbAssNm



varmpLabelLookup :: VarLookup m LabelVarId VarMpInfo => LabelVarId -> m -> Maybe Label
varmpLabelLookup = varlookupMap vmiMbLabel

varmpOffsetLookup :: VarLookup m UID VarMpInfo => UID -> m -> Maybe LabelOffset
varmpOffsetLookup = varlookupMap vmiMbOffset



varmpPredSeqLookup :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe PredSeq
varmpPredSeqLookup = varlookupMap vmiMbPredSeq







varmpTyLookupCyc :: VarLookup m TyVarId VarMpInfo => TyVarId -> m -> Maybe Ty
varmpTyLookupCyc x m = lookupLiftCycMb2 tyMbVar (flip varmpTyLookup m) x







varmpImplsLookupImplsCyc :: VarLookup m ImplsVarId VarMpInfo => Impls -> m -> Maybe Impls
varmpImplsLookupImplsCyc x m = lookupLiftCycMb1 implsMbVar (flip varmpImplsLookup m) x

varmpImplsLookupCyc :: VarLookup m ImplsVarId VarMpInfo => TyVarId -> m -> Maybe Impls
varmpImplsLookupCyc x m = lookupLiftCycMb2 implsMbVar (flip varmpImplsLookup m) x

varmpScopeLookupScopeCyc :: VarLookup m ImplsVarId VarMpInfo => PredScope -> m -> Maybe PredScope
varmpScopeLookupScopeCyc x m = lookupLiftCycMb1 pscpMbVar (flip varmpScopeLookup m) x

varmpAssNmLookupAssNmCyc :: VarLookup m ImplsVarId VarMpInfo => VarUIDHsName -> m -> Maybe VarUIDHsName
varmpAssNmLookupAssNmCyc x m = lookupLiftCycMb1 vunmMbVar (flip varmpAssNmLookup m) x



varmpLabelLookupLabelCyc :: VarLookup m ImplsVarId VarMpInfo => Label -> m -> Maybe Label
varmpLabelLookupLabelCyc x m = lookupLiftCycMb1 labelMbVar (flip varmpLabelLookup m) x

varmpLabelLookupCyc :: VarLookup m ImplsVarId VarMpInfo => TyVarId -> m -> Maybe Label
varmpLabelLookupCyc x m = lookupLiftCycMb2 labelMbVar (flip varmpLabelLookup m) x







varmpTyLookupCyc2 :: VarMp -> TyVarId -> Maybe Ty
varmpTyLookupCyc2 x m = varmpTyLookupCyc m x



varmpScopeLookup2 :: VarMp -> TyVarId -> Maybe PredScope
varmpScopeLookup2 m v = varmpScopeLookup v m

varmpImplsLookup2 :: VarMp -> ImplsVarId -> Maybe Impls
varmpImplsLookup2 m v = varmpImplsLookup v m

varmpImplsLookupCyc2 :: VarMp -> ImplsVarId -> Maybe Impls
varmpImplsLookupCyc2 m v = varmpImplsLookupCyc v m

varmpPredLookup2 :: VarMp -> TyVarId -> Maybe Pred
varmpPredLookup2 m v = varmpPredLookup v m

varmpAssNmLookup2 :: VarMp -> TyVarId -> Maybe VarUIDHsName
varmpAssNmLookup2 m v = varmpAssNmLookup v m



varmpLabelLookup2 :: VarMp -> LabelVarId -> Maybe Label
varmpLabelLookup2 m v = varmpLabelLookup v m


























ppVarMpInfoCfgTy :: CfgPPTy -> VarMpInfo -> PP_Doc
ppVarMpInfoCfgTy c i
  = case i of
      VMITy       t -> ppTyWithCfg    c t
      VMIImpls    i -> ppImplsWithCfg c i
      VMIScope    s -> pp s                     -- rest incomplete
      VMIPred     p -> pp p
      VMILabel    x -> pp x
      VMIOffset   x -> pp x
      VMIPredSeq  x -> pp "predseq" -- pp x

ppVarMpInfoDt :: VarMpInfo -> PP_Doc
ppVarMpInfoDt = ppVarMpInfoCfgTy cfgPPTyDT



instance PP VarMpInfo where
  pp (VMITy       t) = pp t
  pp (VMIImpls    i) = pp i
  pp (VMIScope    s) = pp s
  pp (VMIPred     p) = pp p
  pp (VMILabel    x) = pp x
  pp (VMIOffset   x) = pp x
  -- pp (VMIExts     x) = pp "exts" -- pp x
  pp (VMIPredSeq  x) = pp "predseq" -- pp x













instance Serialize VarMpInfo where
  sput (VMITy      a) = sputWord8 0  >> sput a
  sput (VMIImpls   a) = sputWord8 1  >> sput a
  sput (VMIScope   a) = sputWord8 2  >> sput a
  sput (VMIPred    a) = sputWord8 3  >> sput a
  sput (VMIAssNm   a) = sputWord8 4  >> sput a
  sput (VMILabel   a) = sputWord8 5  >> sput a
  sput (VMIOffset  a) = sputWord8 6  >> sput a
  sput (VMIPredSeq a) = sputWord8 7  >> sput a
  sget = do t <- sgetWord8
            case t of
              0 -> liftM VMITy      sget
              1 -> liftM VMIImpls   sget
              2 -> liftM VMIScope   sget
              3 -> liftM VMIPred    sget
              4 -> liftM VMIAssNm   sget
              5 -> liftM VMILabel   sget
              6 -> liftM VMIOffset  sget
              7 -> liftM VMIPredSeq sget



</pre>