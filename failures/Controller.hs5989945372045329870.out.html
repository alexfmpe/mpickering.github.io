<a href="ControlledProcess.hs144128232716531729.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Controls.hs2034712366881140534.out.html">next</a></br></br><pre>67c67
< data Controller (r ∷ ★ → ★)
---
> data Controller (r :: * -> *)
69d68
<         coSocket ∷ !Fd
70c69
<       , coCloseH ∷ !(FinalizerHandle r)
---
>         coSocket :: !Fd
70a70
>       , coCloseH :: !(FinalizerHandle r)
74c74
<     dup co = do ch' ← dup (coCloseH co)
---
>     dup co = do ch' <- dup (coCloseH co)
78d77
< openController ∷ MonadControlIO pr
79d77
<                ⇒ Maybe HostName -- ^ host to connect to.
80c78
<                → RegionT s pr (Controller (RegionT s pr))
---
> openController :: MonadControlIO pr
80a79
>                => Maybe HostName -- ^ host to connect to.
80a80
>                -> RegionT s pr (Controller (RegionT s pr))
83d82
<       do s  ← liftIO openSocket
84c83
<          ch ← onExit $ closeSocket' s
---
>       do s  <- liftIO openSocket
84a84
>          ch <- onExit $ closeSocket' s
90d89
<       openSocket ∷ IO Fd
91c90
<       openSocket = withCStrOrNull host $ \hostPtr →
---
>       openSocket :: IO Fd
91a91
>       openSocket = withCStrOrNull host $ \hostPtr ->
95c95
<       wrapSocket' ∷ Monad m ⇒ CInt → m Fd
---
>       wrapSocket' :: Monad m => CInt -> m Fd
101c101
<       closeSocket' ∷ Fd → IO ()
---
>       closeSocket' :: Fd -> IO ()
103c103
<           = do _ ← c'esd_close $ fdToCInt fd
---
>           = do _ <- c'esd_close $ fdToCInt fd
106c106
< fdToCInt ∷ Fd → CInt
---
> fdToCInt :: Fd -> CInt
111c111
< lock ∷ ( AncestorRegion pr cr
---
> lock :: ( AncestorRegion pr cr
114d113
<      ⇒ Controller pr
115c114
<      → cr ()
---
>      => Controller pr
115a115
>      -> cr ()
124c124
< unlock ∷ ( AncestorRegion pr cr
---
> unlock :: ( AncestorRegion pr cr
127d126
<        ⇒ Controller pr
128c127
<        → cr ()
---
>        => Controller pr
128a128
>        -> cr ()
137c137
< standby ∷ ( AncestorRegion pr cr
---
> standby :: ( AncestorRegion pr cr
140d139
<         ⇒ Controller pr
141c140
<         → cr ()
---
>         => Controller pr
141a141
>         -> cr ()
150c150
< resume ∷ ( AncestorRegion pr cr
---
> resume :: ( AncestorRegion pr cr
153d152
<        ⇒ Controller pr
154c153
<        → cr ()
---
>        => Controller pr
154a154
>        -> cr ()
162c162
< data Sample (r ∷ ★ → ★)
---
> data Sample (r :: * -> *)
164d163
<         saID     ∷ !CInt
165d163
<       , saCtrl   ∷ !(Controller r)
166c164
<       , saCloseH ∷ !(FinalizerHandle r)
---
>         saID     :: !CInt
166a165
>       , saCtrl   :: !(Controller r)
166a166
>       , saCloseH :: !(FinalizerHandle r)
170d169
<     dup sa = do ctrl' ← dup (saCtrl   sa)
171c170
<                 ch'   ← dup (saCloseH sa)
---
>     dup sa = do ctrl' <- dup (saCtrl   sa)
171a171
>                 ch'   <- dup (saCloseH sa)
177c177
< class (Frame fr, Channels ch) ⇒ SampleSource fr ch dvec where
---
> class (Frame fr, Channels ch) => SampleSource fr ch dvec where
179d178
<     cacheSample ∷ (MonadControlIO pr)
180d178
<                 ⇒ Controller (RegionT s pr)
181d178
<                 → Maybe String  -- ^ name used to identify this sample to
182d178
<                 → Int           -- ^ sample rate
183d178
<                 → dvec          -- ^ frames in deinterleaved vectors
184c179
<                 → RegionT s pr (Sample (RegionT s pr))
---
>     cacheSample :: (MonadControlIO pr)
184a180
>                 => Controller (RegionT s pr)
184a181
>                 -> Maybe String  -- ^ name used to identify this sample to
184a182
>                 -> Int           -- ^ sample rate
184a183
>                 -> dvec          -- ^ frames in deinterleaved vectors
184a184
>                 -> RegionT s pr (Sample (RegionT s pr))
186c186
< instance Frame fr ⇒ SampleSource fr Mono (L.Vector fr) where
---
> instance Frame fr => SampleSource fr Mono (L.Vector fr) where
189c189
<           do sa ← createSample
---
>           do sa <- createSample
193d192
<                    ((⊥) ∷ fr  )
194c193
<                    ((⊥) ∷ Mono)
---
>                    ((⊥) :: fr  )
194a194
>                    ((⊥) :: Mono)
196c196
<              _  ← liftIO $
---
>              _  <- liftIO $
198d197
<                    do h       ← fdToHandle $ coSocket co
199d197
<                       _       ← L.hPut h v
200c198
<                       (Fd fd) ← handleToFd h
---
>                    do h       <- fdToHandle $ coSocket co
200a199
>                       _       <- L.hPut h v
200a200
>                       (Fd fd) <- handleToFd h
205c205
< instance Frame fr ⇒ SampleSource fr Stereo (L.Vector fr, L.Vector fr) where
---
> instance Frame fr => SampleSource fr Stereo (L.Vector fr, L.Vector fr) where
208c208
<           do sa ← createSample
---
>           do sa <- createSample
212d211
<                    ((⊥) ∷ fr    )
213c212
<                    ((⊥) ∷ Stereo)
---
>                    ((⊥) :: fr    )
213a213
>                    ((⊥) :: Stereo)
215c215
<              _  ← liftIO $
---
>              _  <- liftIO $
217d216
<                    do h       ← fdToHandle $ coSocket co
218d216
<                       _       ← L.hPut h (interleave l r)
219c217
<                       (Fd fd) ← handleToFd h
---
>                    do h       <- fdToHandle $ coSocket co
219a218
>                       _       <- L.hPut h (interleave l r)
219a219
>                       (Fd fd) <- handleToFd h
224c224
< createSample ∷ ∀fr ch s pr.
---
> createSample :: forallfr ch s pr.
229d228
<              ⇒ Controller (RegionT s pr)
230d228
<              → Maybe String
231d228
<              → Int
232d228
<              → fr
233d228
<              → ch
234d228
<              → Int
235c229
<              → RegionT s pr (Sample (RegionT s pr))
---
>              => Controller (RegionT s pr)
235a230
>              -> Maybe String
235a231
>              -> Int
235a232
>              -> fr
235a233
>              -> ch
235a234
>              -> Int
235a235
>              -> RegionT s pr (Sample (RegionT s pr))
238d237
<       do sid ← liftIO newCache
239c238
<          ch  ← onExit $ deleteCache sid
---
>       do sid <- liftIO newCache
239a239
>          ch  <- onExit $ deleteCache sid
246d245
<       fmt ∷ C'esd_format_t
247d245
<       fmt = frameFmt   ((⊥) ∷ fr) .|.
248c246
<             channelFmt ((⊥) ∷ ch) .|.
---
>       fmt :: C'esd_format_t
248a247
>       fmt = frameFmt   ((⊥) :: fr) .|.
248a248
>             channelFmt ((⊥) :: ch) .|.
251c251
<       sampleSize ∷ Int
---
>       sampleSize :: Int
253d252
<                    ⋅ frameSize   ((⊥) ∷ fr)
254c253
<                    ⋅ numChannels ((⊥) ∷ ch)
---
>                    ⋅ frameSize   ((⊥) :: fr)
254a254
>                    ⋅ numChannels ((⊥) :: ch)
256d255
<       newCache ∷ IO CInt
257c256
<       newCache = withCStrOrNull name $ \namePtr →
---
>       newCache :: IO CInt
257a257
>       newCache = withCStrOrNull name $ \namePtr ->
272c272
<       deleteCache ∷ CInt → IO ()
---
>       deleteCache :: CInt -> IO ()
282c282
< playSample ∷ ( AncestorRegion pr cr
---
> playSample :: ( AncestorRegion pr cr
285d284
<            ⇒ Sample pr
286c285
<            → cr ()
---
>            => Sample pr
286a286
>            -> cr ()
297c297
< loopSample ∷ ( AncestorRegion pr cr
---
> loopSample :: ( AncestorRegion pr cr
300d299
<            ⇒ Sample pr
301c300
<            → cr ()
---
>            => Sample pr
301a301
>            -> cr ()
312c312
< stopSample ∷ ( AncestorRegion pr cr
---
> stopSample :: ( AncestorRegion pr cr
315d314
<            ⇒ Sample pr
316c315
<            → cr ()
---
>            => Sample pr
316a316
>            -> cr ()
327c327
< killSample ∷ ( AncestorRegion pr cr
---
> killSample :: ( AncestorRegion pr cr
330d329
<            ⇒ Sample pr
331c330
<            → cr ()
---
>            => Sample pr
331a331
>            -> cr ()
352d351
<         serverVersion    ∷ !Int
353d351
<       , serverFrameType  ∷ !FrameType
354d351
<       , serverChannels   ∷ !NumChannels
355c352
<       , serverSampleRate ∷ !Int
---
>         serverVersion    :: !Int
355a353
>       , serverFrameType  :: !FrameType
355a354
>       , serverChannels   :: !NumChannels
355a355
>       , serverSampleRate :: !Int
359c359
< extractServerInfo ∷ Ptr C'esd_server_info → IO ServerInfo
---
> extractServerInfo :: Ptr C'esd_server_info -> IO ServerInfo
361c361
<     = do si ← peek siPtr
---
>     = do si <- peek siPtr
373c373
< extractFrameType ∷ C'esd_format_t → FrameType
---
> extractFrameType :: C'esd_format_t -> FrameType
379c379
< extractNumChannels ∷ C'esd_format_t → NumChannels
---
> extractNumChannels :: C'esd_format_t -> NumChannels
386c386
< getServerInfo ∷ ( AncestorRegion pr cr
---
> getServerInfo :: ( AncestorRegion pr cr
389d388
<               ⇒ Controller pr
390c389
<               → cr ServerInfo
---
>               => Controller pr
390a390
>               -> cr ServerInfo
395c395
<       retrieve ∷ IO (Ptr C'esd_server_info)
---
>       retrieve :: IO (Ptr C'esd_server_info)
399c399
<       dispose ∷ Ptr C'esd_server_info → IO ()
---
>       dispose :: Ptr C'esd_server_info -> IO ()
405d404
<         playerID               ∷ !Int
406d404
<       , playerName             ∷ !String
407d404
<       , playerSampleRate       ∷ !Int
408d404
<       , playerFrameType        ∷ !FrameType
409d404
<       , playerChannels         ∷ !NumChannels
410d404
<       , playerLeftVolumeScale  ∷ !Double -- ^ 0 <= scale <= 1
411c405
<       , playerRightVolumeScale ∷ !Double -- ^ 0 <= scale <= 1
---
>         playerID               :: !Int
411a406
>       , playerName             :: !String
411a407
>       , playerSampleRate       :: !Int
411a408
>       , playerFrameType        :: !FrameType
411a409
>       , playerChannels         :: !NumChannels
411a410
>       , playerLeftVolumeScale  :: !Double -- ^ 0 <= scale <= 1
411a411
>       , playerRightVolumeScale :: !Double -- ^ 0 <= scale <= 1
415c415
< extractPlayerInfo ∷ Ptr C'esd_player_info → IO [PlayerInfo]
---
> extractPlayerInfo :: Ptr C'esd_player_info -> IO [PlayerInfo]
419c419
<         = do pi ← peek piPtr
---
>         = do pi <- peek piPtr
441c441
<              pi'' ← extractPlayerInfo next
---
>              pi'' <- extractPlayerInfo next
447d446
<         sampleID               ∷ !Int
448d446
<       , sampleName             ∷ !String
449d446
<       , sampleSampleRate       ∷ !Int
450d446
<       , sampleFrameType        ∷ !FrameType
451d446
<       , sampleChannels         ∷ !NumChannels
452d446
<       , sampleLength           ∷ !Int
453d446
<       , sampleLeftVolumeScale  ∷ !Double -- ^ 0 <= scale <= 1
454c447
<       , sampleRightVolumeScale ∷ !Double -- ^ 0 <= scale <= 1
---
>         sampleID               :: !Int
454a448
>       , sampleName             :: !String
454a449
>       , sampleSampleRate       :: !Int
454a450
>       , sampleFrameType        :: !FrameType
454a451
>       , sampleChannels         :: !NumChannels
454a452
>       , sampleLength           :: !Int
454a453
>       , sampleLeftVolumeScale  :: !Double -- ^ 0 <= scale <= 1
454a454
>       , sampleRightVolumeScale :: !Double -- ^ 0 <= scale <= 1
458c458
< extractSampleLength ∷ FrameType → NumChannels → Int → Int
---
> extractSampleLength :: FrameType -> NumChannels -> Int -> Int
463d462
<         Int8  → 1
464c463
<         Int16 → 2
---
>         Int8  -> 1
464a464
>         Int16 -> 2
467d466
<         Mono   → 1
468c467
<         Stereo → 2
---
>         Mono   -> 1
468a468
>         Stereo -> 2
470c470
< extractSampleInfo ∷ Ptr C'esd_sample_info → IO [SampleInfo]
---
> extractSampleInfo :: Ptr C'esd_sample_info -> IO [SampleInfo]
474c474
<         = do pi ← peek piPtr
---
>         = do pi <- peek piPtr
501c501
<              pi'' ← extractSampleInfo next
---
>              pi'' <- extractSampleInfo next
507d506
<         serverInfo  ∷ !ServerInfo
508d506
<       , playersInfo ∷ ![PlayerInfo]
509c507
<       , samplesInfo ∷ ![SampleInfo]
---
>         serverInfo  :: !ServerInfo
509a508
>       , playersInfo :: ![PlayerInfo]
509a509
>       , samplesInfo :: ![SampleInfo]
513c513
< extractAllInfo ∷ Ptr C'esd_info → IO AllInfo
---
> extractAllInfo :: Ptr C'esd_info -> IO AllInfo
515d514
<     = do ei  ← peek eiPtr
516d514
<          srv ← extractServerInfo $ c'esd_info'server      ei
517d514
<          pis ← extractPlayerInfo $ c'esd_info'player_list ei
518c515
<          sis ← extractSampleInfo $ c'esd_info'sample_list ei
---
>     = do ei  <- peek eiPtr
518a516
>          srv <- extractServerInfo $ c'esd_info'server      ei
518a517
>          pis <- extractPlayerInfo $ c'esd_info'player_list ei
518a518
>          sis <- extractSampleInfo $ c'esd_info'sample_list ei
526c526
< getAllInfo ∷ ( AncestorRegion pr cr
---
> getAllInfo :: ( AncestorRegion pr cr
529d528
<            ⇒ Controller pr
530c529
<            → cr AllInfo
---
>            => Controller pr
530a530
>            -> cr AllInfo
535c535
<       retrieve ∷ IO (Ptr C'esd_info)
---
>       retrieve :: IO (Ptr C'esd_info)
539c539
<       dispose ∷ Ptr C'esd_info → IO ()
---
>       dispose :: Ptr C'esd_info -> IO ()
543c543
< setStreamPan ∷ ( AncestorRegion pr cr
---
> setStreamPan :: ( AncestorRegion pr cr
546d545
<              ⇒ Controller pr
547d545
<              → Int    -- ^ Stream ID
548d545
<              → Double -- ^ left volume: 0 <= scale <= 1
549d545
<              → Double -- ^ right volume: 0 <= scale <= 1
550c546
<              → cr ()
---
>              => Controller pr
550a547
>              -> Int    -- ^ Stream ID
550a548
>              -> Double -- ^ left volume: 0 <= scale <= 1
550a549
>              -> Double -- ^ right volume: 0 <= scale <= 1
550a550
>              -> cr ()
566c566
< setDefaultSamplePan ∷ ( AncestorRegion pr cr
---
> setDefaultSamplePan :: ( AncestorRegion pr cr
569d568
<                     ⇒ Controller pr
570d568
<                     → Int    -- ^ Sample ID
571d568
<                     → Double -- ^ left volume: 0 <= scale <= 1
572d568
<                     → Double -- ^ right volume: 0 <= scale <= 1
573c569
<                     → cr ()
---
>                     => Controller pr
573a570
>                     -> Int    -- ^ Sample ID
573a571
>                     -> Double -- ^ left volume: 0 <= scale <= 1
573a572
>                     -> Double -- ^ right volume: 0 <= scale <= 1
573a573
>                     -> cr ()
595c595
< extractServerState ∷ C'esd_standby_mode_t → ServerState
---
> extractServerState :: C'esd_standby_mode_t -> ServerState
603c603
< getServerState ∷ ( AncestorRegion pr cr
---
> getServerState :: ( AncestorRegion pr cr
606d605
<                ⇒ Controller pr
607c606
<                → cr ServerState
---
>                => Controller pr
607a607
>                -> cr ServerState
612a613
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    FlexibleContexts
  , FlexibleInstances
  , KindSignatures
  , MultiParamTypeClasses
  , UnicodeSyntax
  , ScopedTypeVariables
  #-}
-- | EsounD controlling handles.
module Sound.EsounD.Controller
    ( Controller
    , openController

    , lock
    , unlock

    , standby
    , resume

    , Sample
    , SampleSource(..)
    , playSample
    , loopSample
    , stopSample
    , killSample

    , ServerInfo(..)
    , FrameType(..)
    , NumChannels(..)
    , getServerInfo

    , PlayerInfo(..)
    , SampleInfo(..)
    , AllInfo(..)
    , getAllInfo

    , setStreamPan
    , setDefaultSamplePan

    , ServerState(..)
    , getServerState
    )
    where
import Bindings.EsounD
import Control.Exception.Control
import Control.Monad.IO.Class
import Control.Monad.IO.Control
import Control.Monad.Trans.Region
import Control.Monad.Trans.Region.OnExit
import Control.Monad.Unicode
import Data.Bits
import Data.Char
import qualified Data.StorableVector.Lazy as L
import Foreign.C.Types
import Foreign.Ptr
import Foreign.Storable
import Network
import Prelude hiding (pi)
import Prelude.Unicode
import Sound.EsounD.Internals
import System.IO.SaferFileHandles.Unsafe
import System.Posix.IO hiding (dup)
import System.Posix.Types
import Text.Printf

-- ^ An opaque ESD handle for controlling ESD.
data Controller (r ∷ ★ → ★)
    = Controller {
        coSocket ∷ !Fd
      , coCloseH ∷ !(FinalizerHandle r)
      }

instance Dup Controller where
    dup co = do ch' ← dup (coCloseH co)
                return co { coCloseH = ch' }

-- | Open an ESD handle for controlling ESD.
openController ∷ MonadControlIO pr
               ⇒ Maybe HostName -- ^ host to connect to.
               → RegionT s pr (Controller (RegionT s pr))
openController host
    = mask_ $
      do s  ← liftIO openSocket
         ch ← onExit $ closeSocket' s
         return Controller {
                      coSocket = s
                    , coCloseH = ch
                    }
    where
      openSocket ∷ IO Fd
      openSocket = withCStrOrNull host $ \hostPtr →
                       c'esd_open_sound hostPtr
                       ≫= wrapSocket'

      wrapSocket' ∷ Monad m ⇒ CInt → m Fd
      wrapSocket' (-1) = fail ( printf "esd_open_sound(%s) returned an error"
                                       (show host)
                              )
      wrapSocket' fd   = return $ Fd fd

      closeSocket' ∷ Fd → IO ()
      closeSocket' fd
          = do _ ← c'esd_close $ fdToCInt fd
               return ()

fdToCInt ∷ Fd → CInt
fdToCInt (Fd fd) = fromIntegral fd

-- | Lock the ESD so that it won't accept connections from remote
-- hosts.
lock ∷ ( AncestorRegion pr cr
        , MonadIO cr
        )
     ⇒ Controller pr
     → cr ()
lock co
    = liftIO $
      c'esd_lock (fdToCInt $ coSocket co)
          ≫= failOnError "esd_lock(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Unlock the ESD so that it will accept connections from remote
-- hosts.
unlock ∷ ( AncestorRegion pr cr
          , MonadIO cr
          )
       ⇒ Controller pr
       → cr ()
unlock co
    = liftIO $
      c'esd_unlock (fdToCInt $ coSocket co)
          ≫= failOnError "esd_unlock(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Let ESD stop playing sounds and release its connection to the
-- audio device so that other processes may use it.
standby ∷ ( AncestorRegion pr cr
           , MonadIO cr
           )
        ⇒ Controller pr
        → cr ()
standby co
    = liftIO $
      c'esd_standby (fdToCInt $ coSocket co)
          ≫= failOnError "esd_standby(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Let ESD attempt to reconnect to the audio device and start
-- playing sounds again.
resume ∷ ( AncestorRegion pr cr
          , MonadIO cr
          )
       ⇒ Controller pr
       → cr ()
resume co
    = liftIO $
      c'esd_resume (fdToCInt $ coSocket co)
          ≫= failOnError "esd_resume(fd) returned an error" (≤ 0)
          ≫  return ()

-- | An opaque ESD sample handle.
data Sample (r ∷ ★ → ★)
    = Sample {
        saID     ∷ !CInt
      , saCtrl   ∷ !(Controller r)
      , saCloseH ∷ !(FinalizerHandle r)
      }

instance Dup Sample where
    dup sa = do ctrl' ← dup (saCtrl   sa)
                ch'   ← dup (saCloseH sa)
                return sa {
                         saCtrl   = ctrl'
                       , saCloseH = ch'
                       }

class (Frame fr, Channels ch) ⇒ SampleSource fr ch dvec where
    -- | Cache a sample in the server.
    cacheSample ∷ (MonadControlIO pr)
                ⇒ Controller (RegionT s pr)
                → Maybe String  -- ^ name used to identify this sample to
                → Int           -- ^ sample rate
                → dvec          -- ^ frames in deinterleaved vectors
                → RegionT s pr (Sample (RegionT s pr))

instance Frame fr ⇒ SampleSource fr Mono (L.Vector fr) where
    cacheSample co name rate v
        = mask_ $
          do sa ← createSample
                   co
                   name
                   rate
                   ((⊥) ∷ fr  )
                   ((⊥) ∷ Mono)
                   (L.length v)
             _  ← liftIO $
                   sanitizeIOError $
                   do h       ← fdToHandle $ coSocket co
                      _       ← L.hPut h v
                      (Fd fd) ← handleToFd h
                      c'esd_confirm_sample_cache fd
                          ≫= failOnError "esd_confirm_sample_cache(fd) returned an error" (< 0)
             return sa

instance Frame fr ⇒ SampleSource fr Stereo (L.Vector fr, L.Vector fr) where
    cacheSample co name rate (l, r)
        = mask_ $
          do sa ← createSample
                   co
                   name
                   rate
                   ((⊥) ∷ fr    )
                   ((⊥) ∷ Stereo)
                   (L.length l)
             _  ← liftIO $
                   sanitizeIOError $
                   do h       ← fdToHandle $ coSocket co
                      _       ← L.hPut h (interleave l r)
                      (Fd fd) ← handleToFd h
                      c'esd_confirm_sample_cache fd
                          ≫= failOnError "esd_confirm_sample_cache(fd) returned an error" (< 0)
             return sa

createSample ∷ ∀fr ch s pr.
                ( Frame fr
                , Channels ch
                , MonadControlIO pr
                )
             ⇒ Controller (RegionT s pr)
             → Maybe String
             → Int
             → fr
             → ch
             → Int
             → RegionT s pr (Sample (RegionT s pr))
createSample co name rate _ _ len
    = mask_ $
      do sid ← liftIO newCache
         ch  ← onExit $ deleteCache sid
         return Sample {
                      saID     = sid
                    , saCtrl   = co
                    , saCloseH = ch
                    }
    where
      fmt ∷ C'esd_format_t
      fmt = frameFmt   ((⊥) ∷ fr) .|.
            channelFmt ((⊥) ∷ ch) .|.
            c'ESD_SAMPLE

      sampleSize ∷ Int
      sampleSize = len
                   ⋅ frameSize   ((⊥) ∷ fr)
                   ⋅ numChannels ((⊥) ∷ ch)

      newCache ∷ IO CInt
      newCache = withCStrOrNull name $ \namePtr →
                     c'esd_sample_cache
                     (fdToCInt $ coSocket co)
                     fmt
                     (fromIntegral rate)
                     (fromIntegral sampleSize)
                     namePtr
                     ≫= failOnError ( printf "esd_sample_cache(%s, %s, %s, %s, %s) returned an error"
                                              (show $ coSocket co)
                                              (show fmt)
                                              (show rate)
                                              (show sampleSize)
                                              (show name)
                                     ) (< 0)

      deleteCache ∷ CInt → IO ()
      deleteCache sid
          = c'esd_sample_free (fdToCInt $ coSocket co) sid
            ≫= failOnError ( printf "esd_sample_free(%s) returned an error"
                                     (show $ coSocket co)
                                     (show sid)
                            ) (< 0)
            ≫  return ()

-- | Play a cached sample once.
playSample ∷ ( AncestorRegion pr cr
              , MonadIO cr
              )
           ⇒ Sample pr
           → cr ()
playSample sa
    = liftIO $
      c'esd_sample_play (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_play(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Play a cached sample repeatedly.
loopSample ∷ ( AncestorRegion pr cr
              , MonadIO cr
              )
           ⇒ Sample pr
           → cr ()
loopSample sa
    = liftIO $
      c'esd_sample_loop (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_loop(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Stop a looping sample at end.
stopSample ∷ ( AncestorRegion pr cr
              , MonadIO cr
              )
           ⇒ Sample pr
           → cr ()
stopSample sa
    = liftIO $
      c'esd_sample_stop (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_stop(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Stop a playing sample immediately.
killSample ∷ ( AncestorRegion pr cr
              , MonadIO cr
              )
           ⇒ Sample pr
           → cr ()
killSample sa
    = liftIO $
      c'esd_sample_kill (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_kill(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

data FrameType
    = Int8 | Int16
    deriving (Show, Eq)

data NumChannels
    = Mono | Stereo
    deriving (Show, Eq)

-- | A data type to represent the server info.
data ServerInfo
    = ServerInfo {
        serverVersion    ∷ !Int
      , serverFrameType  ∷ !FrameType
      , serverChannels   ∷ !NumChannels
      , serverSampleRate ∷ !Int
      }
    deriving (Show, Eq)

extractServerInfo ∷ Ptr C'esd_server_info → IO ServerInfo
extractServerInfo siPtr
    = do si ← peek siPtr
         return ServerInfo {
                      serverVersion
                        = fromIntegral $ c'esd_server_info'version si
                    , serverFrameType
                        = extractFrameType $ c'esd_server_info'format si
                    , serverChannels
                        = extractNumChannels $ c'esd_server_info'format si
                    , serverSampleRate
                        = fromIntegral $ c'esd_server_info'rate si
                    }

extractFrameType ∷ C'esd_format_t → FrameType
extractFrameType fmt
    | fmt .&. c'ESD_BITS8  ≢ 0 = Int8
    | fmt .&. c'ESD_BITS16 ≢ 0 = Int16
    | otherwise                = error ("Unknown format: " ⧺ show fmt)

extractNumChannels ∷ C'esd_format_t → NumChannels
extractNumChannels fmt
    | fmt .&. c'ESD_MONO   ≢ 0 = Mono
    | fmt .&. c'ESD_STEREO ≢ 0 = Stereo
    | otherwise                = error ("Unknown format: " ⧺ show fmt)

-- | Retrieve server properties.
getServerInfo ∷ ( AncestorRegion pr cr
                 , MonadIO cr
                 )
              ⇒ Controller pr
              → cr ServerInfo
getServerInfo co
    = liftIO $
      bracket retrieve dispose extractServerInfo
    where
      retrieve ∷ IO (Ptr C'esd_server_info)
      retrieve = c'esd_get_server_info (fdToCInt $ coSocket co)
                 ≫= failOnError "esd_get_server_info(fd) returned an error" (≡ nullPtr)

      dispose ∷ Ptr C'esd_server_info → IO ()
      dispose = c'esd_free_server_info

-- | A data type to represent a player stream info.
data PlayerInfo
    = PlayerInfo {
        playerID               ∷ !Int
      , playerName             ∷ !String
      , playerSampleRate       ∷ !Int
      , playerFrameType        ∷ !FrameType
      , playerChannels         ∷ !NumChannels
      , playerLeftVolumeScale  ∷ !Double -- ^ 0 <= scale <= 1
      , playerRightVolumeScale ∷ !Double -- ^ 0 <= scale <= 1
      }
    deriving (Show, Eq)

extractPlayerInfo ∷ Ptr C'esd_player_info → IO [PlayerInfo]
extractPlayerInfo piPtr
    | piPtr ≡ nullPtr = return []
    | otherwise
        = do pi ← peek piPtr
             let next = c'esd_player_info'next pi
                 pi'  = PlayerInfo {
                          playerID
                            = fromIntegral $ c'esd_player_info'source_id pi
                        , playerName
                            = map (chr ∘ fromIntegral) $ c'esd_player_info'name pi
                        , playerSampleRate
                            = fromIntegral $ c'esd_player_info'rate pi
                        , playerFrameType
                            = extractFrameType $ c'esd_player_info'format pi
                        , playerChannels
                            = extractNumChannels $ c'esd_player_info'format pi
                        , playerLeftVolumeScale
                            = (fromIntegral $ c'esd_player_info'left_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        , playerRightVolumeScale
                            = (fromIntegral $ c'esd_player_info'right_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        }
             pi'' ← extractPlayerInfo next
             return (pi' : pi'')

-- | A data type to represent a cached sample info.
data SampleInfo
    = SampleInfo {
        sampleID               ∷ !Int
      , sampleName             ∷ !String
      , sampleSampleRate       ∷ !Int
      , sampleFrameType        ∷ !FrameType
      , sampleChannels         ∷ !NumChannels
      , sampleLength           ∷ !Int
      , sampleLeftVolumeScale  ∷ !Double -- ^ 0 <= scale <= 1
      , sampleRightVolumeScale ∷ !Double -- ^ 0 <= scale <= 1
      }
    deriving (Show, Eq)

extractSampleLength ∷ FrameType → NumChannels → Int → Int
extractSampleLength fr ch bufLen
    = bufLen
      `div`
      case fr of
        Int8  → 1
        Int16 → 2
      `div`
      case ch of
        Mono   → 1
        Stereo → 2

extractSampleInfo ∷ Ptr C'esd_sample_info → IO [SampleInfo]
extractSampleInfo piPtr
    | piPtr ≡ nullPtr = return []
    | otherwise
        = do pi ← peek piPtr
             let next = c'esd_sample_info'next pi
                 fr   = extractFrameType $ c'esd_sample_info'format pi
                 ch   = extractNumChannels $ c'esd_sample_info'format pi
                 pi'  = SampleInfo {
                          sampleID
                            = fromIntegral $ c'esd_sample_info'sample_id pi
                        , sampleName
                            = map (chr ∘ fromIntegral) $ c'esd_sample_info'name pi
                        , sampleSampleRate
                            = fromIntegral $ c'esd_sample_info'rate pi
                        , sampleFrameType
                            = fr
                        , sampleChannels
                            = ch
                        , sampleLength
                            = extractSampleLength fr ch $
                              fromIntegral $ c'esd_sample_info'length pi
                        , sampleLeftVolumeScale
                            = (fromIntegral $ c'esd_sample_info'left_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        , sampleRightVolumeScale
                            = (fromIntegral $ c'esd_sample_info'right_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        }
             pi'' ← extractSampleInfo next
             return (pi' : pi'')

-- | A data type to represent all info in the ESD server.
data AllInfo
    = AllInfo {
        serverInfo  ∷ !ServerInfo
      , playersInfo ∷ ![PlayerInfo]
      , samplesInfo ∷ ![SampleInfo]
      }
    deriving (Show, Eq)

extractAllInfo ∷ Ptr C'esd_info → IO AllInfo
extractAllInfo eiPtr
    = do ei  ← peek eiPtr
         srv ← extractServerInfo $ c'esd_info'server      ei
         pis ← extractPlayerInfo $ c'esd_info'player_list ei
         sis ← extractSampleInfo $ c'esd_info'sample_list ei
         return AllInfo {
                      serverInfo  = srv
                    , playersInfo = pis
                    , samplesInfo = sis
                    }

-- | Retrieve all info in the ESD server.
getAllInfo ∷ ( AncestorRegion pr cr
              , MonadIO cr
              )
           ⇒ Controller pr
           → cr AllInfo
getAllInfo co
    = liftIO $
      bracket retrieve dispose extractAllInfo
    where
      retrieve ∷ IO (Ptr C'esd_info)
      retrieve = c'esd_get_all_info (fdToCInt $ coSocket co)
                 ≫= failOnError "esd_get_all_info(fd) returned an error" (≡ nullPtr)

      dispose ∷ Ptr C'esd_info → IO ()
      dispose = c'esd_free_all_info

-- | Reset the volume panning for a stream.
setStreamPan ∷ ( AncestorRegion pr cr
                , MonadIO cr
                )
             ⇒ Controller pr
             → Int    -- ^ Stream ID
             → Double -- ^ left volume: 0 <= scale <= 1
             → Double -- ^ right volume: 0 <= scale <= 1
             → cr ()
setStreamPan co sid l r
    = liftIO $
      c'esd_set_stream_pan (fdToCInt $ coSocket co)
                           (fromIntegral sid)
                           (floor $ l ⋅ c'ESD_VOLUME_BASE)
                           (floor $ r ⋅ c'ESD_VOLUME_BASE)
          ≫= failOnError ( printf "esd_set_stream_pan(%s, %s, %s, %s) returned an error"
                                   (show $ coSocket co)
                                   (show sid)
                                   (show l  )
                                   (show r  )
                          ) (≤ 0)
          ≫  return ()

-- | Reset the default volume panning for a sample.
setDefaultSamplePan ∷ ( AncestorRegion pr cr
                       , MonadIO cr
                       )
                    ⇒ Controller pr
                    → Int    -- ^ Sample ID
                    → Double -- ^ left volume: 0 <= scale <= 1
                    → Double -- ^ right volume: 0 <= scale <= 1
                    → cr ()
setDefaultSamplePan co sid l r
    = liftIO $
      c'esd_set_default_sample_pan (fdToCInt $ coSocket co)
                                   (fromIntegral sid)
                                   (floor $ l ⋅ c'ESD_VOLUME_BASE)
                                   (floor $ r ⋅ c'ESD_VOLUME_BASE)
          ≫= failOnError ( printf "esd_set_default_sample_pan(%s, %s, %s, %s) returned an error"
                                   (show $ coSocket co)
                                   (show sid)
                                   (show l  )
                                   (show r  )
                          ) (≤ 0)
          ≫  return ()

-- | A data type to represent server's state.
data ServerState
    = Standby
    | AutoStandby
    | Running
    deriving (Eq, Show)

extractServerState ∷ C'esd_standby_mode_t → ServerState
extractServerState st
    | st ≡ c'ESM_ON_STANDBY     = Standby
    | st ≡ c'ESM_ON_AUTOSTANDBY = AutoStandby
    | st ≡ c'ESM_RUNNING        = Running
    | otherwise                  = error ("unknown state: " ⧺ show st)

-- | Retrieve the server's state.
getServerState ∷ ( AncestorRegion pr cr
                  , MonadIO cr
                  )
               ⇒ Controller pr
               → cr ServerState
getServerState co
    = liftIO $
      fmap extractServerState $
      c'esd_get_standby_mode (fdToCInt $ coSocket co)
          ≫= failOnError "esd_get_standby_mode(fd) returned an error" (≡ c'ESM_ERROR)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    FlexibleContexts
  , FlexibleInstances
  , KindSignatures
  , MultiParamTypeClasses
  , UnicodeSyntax
  , ScopedTypeVariables
  #-}
-- | EsounD controlling handles.
module Sound.EsounD.Controller
    ( Controller
    , openController

    , lock
    , unlock

    , standby
    , resume

    , Sample
    , SampleSource(..)
    , playSample
    , loopSample
    , stopSample
    , killSample

    , ServerInfo(..)
    , FrameType(..)
    , NumChannels(..)
    , getServerInfo

    , PlayerInfo(..)
    , SampleInfo(..)
    , AllInfo(..)
    , getAllInfo

    , setStreamPan
    , setDefaultSamplePan

    , ServerState(..)
    , getServerState
    )
    where
import Bindings.EsounD
import Control.Exception.Control
import Control.Monad.IO.Class
import Control.Monad.IO.Control
import Control.Monad.Trans.Region
import Control.Monad.Trans.Region.OnExit
import Control.Monad.Unicode
import Data.Bits
import Data.Char
import qualified Data.StorableVector.Lazy as L
import Foreign.C.Types
import Foreign.Ptr
import Foreign.Storable
import Network
import Prelude hiding (pi)
import Prelude.Unicode
import Sound.EsounD.Internals
import System.IO.SaferFileHandles.Unsafe
import System.Posix.IO hiding (dup)
import System.Posix.Types
import Text.Printf

-- ^ An opaque ESD handle for controlling ESD.
data Controller (r :: * -> *)
    = Controller {
        coSocket :: !Fd
      , coCloseH :: !(FinalizerHandle r)
      }

instance Dup Controller where
    dup co = do ch' <- dup (coCloseH co)
                return co { coCloseH = ch' }

-- | Open an ESD handle for controlling ESD.
openController :: MonadControlIO pr
               => Maybe HostName -- ^ host to connect to.
               -> RegionT s pr (Controller (RegionT s pr))
openController host
    = mask_ $
      do s  <- liftIO openSocket
         ch <- onExit $ closeSocket' s
         return Controller {
                      coSocket = s
                    , coCloseH = ch
                    }
    where
      openSocket :: IO Fd
      openSocket = withCStrOrNull host $ \hostPtr ->
                       c'esd_open_sound hostPtr
                       ≫= wrapSocket'

      wrapSocket' :: Monad m => CInt -> m Fd
      wrapSocket' (-1) = fail ( printf "esd_open_sound(%s) returned an error"
                                       (show host)
                              )
      wrapSocket' fd   = return $ Fd fd

      closeSocket' :: Fd -> IO ()
      closeSocket' fd
          = do _ <- c'esd_close $ fdToCInt fd
               return ()

fdToCInt :: Fd -> CInt
fdToCInt (Fd fd) = fromIntegral fd

-- | Lock the ESD so that it won't accept connections from remote
-- hosts.
lock :: ( AncestorRegion pr cr
        , MonadIO cr
        )
     => Controller pr
     -> cr ()
lock co
    = liftIO $
      c'esd_lock (fdToCInt $ coSocket co)
          ≫= failOnError "esd_lock(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Unlock the ESD so that it will accept connections from remote
-- hosts.
unlock :: ( AncestorRegion pr cr
          , MonadIO cr
          )
       => Controller pr
       -> cr ()
unlock co
    = liftIO $
      c'esd_unlock (fdToCInt $ coSocket co)
          ≫= failOnError "esd_unlock(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Let ESD stop playing sounds and release its connection to the
-- audio device so that other processes may use it.
standby :: ( AncestorRegion pr cr
           , MonadIO cr
           )
        => Controller pr
        -> cr ()
standby co
    = liftIO $
      c'esd_standby (fdToCInt $ coSocket co)
          ≫= failOnError "esd_standby(fd) returned an error" (≤ 0)
          ≫  return ()

-- | Let ESD attempt to reconnect to the audio device and start
-- playing sounds again.
resume :: ( AncestorRegion pr cr
          , MonadIO cr
          )
       => Controller pr
       -> cr ()
resume co
    = liftIO $
      c'esd_resume (fdToCInt $ coSocket co)
          ≫= failOnError "esd_resume(fd) returned an error" (≤ 0)
          ≫  return ()

-- | An opaque ESD sample handle.
data Sample (r :: * -> *)
    = Sample {
        saID     :: !CInt
      , saCtrl   :: !(Controller r)
      , saCloseH :: !(FinalizerHandle r)
      }

instance Dup Sample where
    dup sa = do ctrl' <- dup (saCtrl   sa)
                ch'   <- dup (saCloseH sa)
                return sa {
                         saCtrl   = ctrl'
                       , saCloseH = ch'
                       }

class (Frame fr, Channels ch) => SampleSource fr ch dvec where
    -- | Cache a sample in the server.
    cacheSample :: (MonadControlIO pr)
                => Controller (RegionT s pr)
                -> Maybe String  -- ^ name used to identify this sample to
                -> Int           -- ^ sample rate
                -> dvec          -- ^ frames in deinterleaved vectors
                -> RegionT s pr (Sample (RegionT s pr))

instance Frame fr => SampleSource fr Mono (L.Vector fr) where
    cacheSample co name rate v
        = mask_ $
          do sa <- createSample
                   co
                   name
                   rate
                   ((⊥) :: fr  )
                   ((⊥) :: Mono)
                   (L.length v)
             _  <- liftIO $
                   sanitizeIOError $
                   do h       <- fdToHandle $ coSocket co
                      _       <- L.hPut h v
                      (Fd fd) <- handleToFd h
                      c'esd_confirm_sample_cache fd
                          ≫= failOnError "esd_confirm_sample_cache(fd) returned an error" (< 0)
             return sa

instance Frame fr => SampleSource fr Stereo (L.Vector fr, L.Vector fr) where
    cacheSample co name rate (l, r)
        = mask_ $
          do sa <- createSample
                   co
                   name
                   rate
                   ((⊥) :: fr    )
                   ((⊥) :: Stereo)
                   (L.length l)
             _  <- liftIO $
                   sanitizeIOError $
                   do h       <- fdToHandle $ coSocket co
                      _       <- L.hPut h (interleave l r)
                      (Fd fd) <- handleToFd h
                      c'esd_confirm_sample_cache fd
                          ≫= failOnError "esd_confirm_sample_cache(fd) returned an error" (< 0)
             return sa

createSample :: forallfr ch s pr.
                ( Frame fr
                , Channels ch
                , MonadControlIO pr
                )
             => Controller (RegionT s pr)
             -> Maybe String
             -> Int
             -> fr
             -> ch
             -> Int
             -> RegionT s pr (Sample (RegionT s pr))
createSample co name rate _ _ len
    = mask_ $
      do sid <- liftIO newCache
         ch  <- onExit $ deleteCache sid
         return Sample {
                      saID     = sid
                    , saCtrl   = co
                    , saCloseH = ch
                    }
    where
      fmt :: C'esd_format_t
      fmt = frameFmt   ((⊥) :: fr) .|.
            channelFmt ((⊥) :: ch) .|.
            c'ESD_SAMPLE

      sampleSize :: Int
      sampleSize = len
                   ⋅ frameSize   ((⊥) :: fr)
                   ⋅ numChannels ((⊥) :: ch)

      newCache :: IO CInt
      newCache = withCStrOrNull name $ \namePtr ->
                     c'esd_sample_cache
                     (fdToCInt $ coSocket co)
                     fmt
                     (fromIntegral rate)
                     (fromIntegral sampleSize)
                     namePtr
                     ≫= failOnError ( printf "esd_sample_cache(%s, %s, %s, %s, %s) returned an error"
                                              (show $ coSocket co)
                                              (show fmt)
                                              (show rate)
                                              (show sampleSize)
                                              (show name)
                                     ) (< 0)

      deleteCache :: CInt -> IO ()
      deleteCache sid
          = c'esd_sample_free (fdToCInt $ coSocket co) sid
            ≫= failOnError ( printf "esd_sample_free(%s) returned an error"
                                     (show $ coSocket co)
                                     (show sid)
                            ) (< 0)
            ≫  return ()

-- | Play a cached sample once.
playSample :: ( AncestorRegion pr cr
              , MonadIO cr
              )
           => Sample pr
           -> cr ()
playSample sa
    = liftIO $
      c'esd_sample_play (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_play(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Play a cached sample repeatedly.
loopSample :: ( AncestorRegion pr cr
              , MonadIO cr
              )
           => Sample pr
           -> cr ()
loopSample sa
    = liftIO $
      c'esd_sample_loop (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_loop(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Stop a looping sample at end.
stopSample :: ( AncestorRegion pr cr
              , MonadIO cr
              )
           => Sample pr
           -> cr ()
stopSample sa
    = liftIO $
      c'esd_sample_stop (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_stop(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

-- | Stop a playing sample immediately.
killSample :: ( AncestorRegion pr cr
              , MonadIO cr
              )
           => Sample pr
           -> cr ()
killSample sa
    = liftIO $
      c'esd_sample_kill (fdToCInt $ coSocket $ saCtrl sa) (saID sa)
          ≫= failOnError ( printf "esd_sample_kill(%s, %s) returned an error"
                                   (show $ coSocket $ saCtrl sa)
                                   (show $ saID sa)
                          ) (≤ 0)
          ≫  return ()

data FrameType
    = Int8 | Int16
    deriving (Show, Eq)

data NumChannels
    = Mono | Stereo
    deriving (Show, Eq)

-- | A data type to represent the server info.
data ServerInfo
    = ServerInfo {
        serverVersion    :: !Int
      , serverFrameType  :: !FrameType
      , serverChannels   :: !NumChannels
      , serverSampleRate :: !Int
      }
    deriving (Show, Eq)

extractServerInfo :: Ptr C'esd_server_info -> IO ServerInfo
extractServerInfo siPtr
    = do si <- peek siPtr
         return ServerInfo {
                      serverVersion
                        = fromIntegral $ c'esd_server_info'version si
                    , serverFrameType
                        = extractFrameType $ c'esd_server_info'format si
                    , serverChannels
                        = extractNumChannels $ c'esd_server_info'format si
                    , serverSampleRate
                        = fromIntegral $ c'esd_server_info'rate si
                    }

extractFrameType :: C'esd_format_t -> FrameType
extractFrameType fmt
    | fmt .&. c'ESD_BITS8  ≢ 0 = Int8
    | fmt .&. c'ESD_BITS16 ≢ 0 = Int16
    | otherwise                = error ("Unknown format: " ⧺ show fmt)

extractNumChannels :: C'esd_format_t -> NumChannels
extractNumChannels fmt
    | fmt .&. c'ESD_MONO   ≢ 0 = Mono
    | fmt .&. c'ESD_STEREO ≢ 0 = Stereo
    | otherwise                = error ("Unknown format: " ⧺ show fmt)

-- | Retrieve server properties.
getServerInfo :: ( AncestorRegion pr cr
                 , MonadIO cr
                 )
              => Controller pr
              -> cr ServerInfo
getServerInfo co
    = liftIO $
      bracket retrieve dispose extractServerInfo
    where
      retrieve :: IO (Ptr C'esd_server_info)
      retrieve = c'esd_get_server_info (fdToCInt $ coSocket co)
                 ≫= failOnError "esd_get_server_info(fd) returned an error" (≡ nullPtr)

      dispose :: Ptr C'esd_server_info -> IO ()
      dispose = c'esd_free_server_info

-- | A data type to represent a player stream info.
data PlayerInfo
    = PlayerInfo {
        playerID               :: !Int
      , playerName             :: !String
      , playerSampleRate       :: !Int
      , playerFrameType        :: !FrameType
      , playerChannels         :: !NumChannels
      , playerLeftVolumeScale  :: !Double -- ^ 0 <= scale <= 1
      , playerRightVolumeScale :: !Double -- ^ 0 <= scale <= 1
      }
    deriving (Show, Eq)

extractPlayerInfo :: Ptr C'esd_player_info -> IO [PlayerInfo]
extractPlayerInfo piPtr
    | piPtr ≡ nullPtr = return []
    | otherwise
        = do pi <- peek piPtr
             let next = c'esd_player_info'next pi
                 pi'  = PlayerInfo {
                          playerID
                            = fromIntegral $ c'esd_player_info'source_id pi
                        , playerName
                            = map (chr ∘ fromIntegral) $ c'esd_player_info'name pi
                        , playerSampleRate
                            = fromIntegral $ c'esd_player_info'rate pi
                        , playerFrameType
                            = extractFrameType $ c'esd_player_info'format pi
                        , playerChannels
                            = extractNumChannels $ c'esd_player_info'format pi
                        , playerLeftVolumeScale
                            = (fromIntegral $ c'esd_player_info'left_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        , playerRightVolumeScale
                            = (fromIntegral $ c'esd_player_info'right_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        }
             pi'' <- extractPlayerInfo next
             return (pi' : pi'')

-- | A data type to represent a cached sample info.
data SampleInfo
    = SampleInfo {
        sampleID               :: !Int
      , sampleName             :: !String
      , sampleSampleRate       :: !Int
      , sampleFrameType        :: !FrameType
      , sampleChannels         :: !NumChannels
      , sampleLength           :: !Int
      , sampleLeftVolumeScale  :: !Double -- ^ 0 <= scale <= 1
      , sampleRightVolumeScale :: !Double -- ^ 0 <= scale <= 1
      }
    deriving (Show, Eq)

extractSampleLength :: FrameType -> NumChannels -> Int -> Int
extractSampleLength fr ch bufLen
    = bufLen
      `div`
      case fr of
        Int8  -> 1
        Int16 -> 2
      `div`
      case ch of
        Mono   -> 1
        Stereo -> 2

extractSampleInfo :: Ptr C'esd_sample_info -> IO [SampleInfo]
extractSampleInfo piPtr
    | piPtr ≡ nullPtr = return []
    | otherwise
        = do pi <- peek piPtr
             let next = c'esd_sample_info'next pi
                 fr   = extractFrameType $ c'esd_sample_info'format pi
                 ch   = extractNumChannels $ c'esd_sample_info'format pi
                 pi'  = SampleInfo {
                          sampleID
                            = fromIntegral $ c'esd_sample_info'sample_id pi
                        , sampleName
                            = map (chr ∘ fromIntegral) $ c'esd_sample_info'name pi
                        , sampleSampleRate
                            = fromIntegral $ c'esd_sample_info'rate pi
                        , sampleFrameType
                            = fr
                        , sampleChannels
                            = ch
                        , sampleLength
                            = extractSampleLength fr ch $
                              fromIntegral $ c'esd_sample_info'length pi
                        , sampleLeftVolumeScale
                            = (fromIntegral $ c'esd_sample_info'left_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        , sampleRightVolumeScale
                            = (fromIntegral $ c'esd_sample_info'right_vol_scale pi)
                              ÷
                              c'ESD_VOLUME_BASE
                        }
             pi'' <- extractSampleInfo next
             return (pi' : pi'')

-- | A data type to represent all info in the ESD server.
data AllInfo
    = AllInfo {
        serverInfo  :: !ServerInfo
      , playersInfo :: ![PlayerInfo]
      , samplesInfo :: ![SampleInfo]
      }
    deriving (Show, Eq)

extractAllInfo :: Ptr C'esd_info -> IO AllInfo
extractAllInfo eiPtr
    = do ei  <- peek eiPtr
         srv <- extractServerInfo $ c'esd_info'server      ei
         pis <- extractPlayerInfo $ c'esd_info'player_list ei
         sis <- extractSampleInfo $ c'esd_info'sample_list ei
         return AllInfo {
                      serverInfo  = srv
                    , playersInfo = pis
                    , samplesInfo = sis
                    }

-- | Retrieve all info in the ESD server.
getAllInfo :: ( AncestorRegion pr cr
              , MonadIO cr
              )
           => Controller pr
           -> cr AllInfo
getAllInfo co
    = liftIO $
      bracket retrieve dispose extractAllInfo
    where
      retrieve :: IO (Ptr C'esd_info)
      retrieve = c'esd_get_all_info (fdToCInt $ coSocket co)
                 ≫= failOnError "esd_get_all_info(fd) returned an error" (≡ nullPtr)

      dispose :: Ptr C'esd_info -> IO ()
      dispose = c'esd_free_all_info

-- | Reset the volume panning for a stream.
setStreamPan :: ( AncestorRegion pr cr
                , MonadIO cr
                )
             => Controller pr
             -> Int    -- ^ Stream ID
             -> Double -- ^ left volume: 0 <= scale <= 1
             -> Double -- ^ right volume: 0 <= scale <= 1
             -> cr ()
setStreamPan co sid l r
    = liftIO $
      c'esd_set_stream_pan (fdToCInt $ coSocket co)
                           (fromIntegral sid)
                           (floor $ l ⋅ c'ESD_VOLUME_BASE)
                           (floor $ r ⋅ c'ESD_VOLUME_BASE)
          ≫= failOnError ( printf "esd_set_stream_pan(%s, %s, %s, %s) returned an error"
                                   (show $ coSocket co)
                                   (show sid)
                                   (show l  )
                                   (show r  )
                          ) (≤ 0)
          ≫  return ()

-- | Reset the default volume panning for a sample.
setDefaultSamplePan :: ( AncestorRegion pr cr
                       , MonadIO cr
                       )
                    => Controller pr
                    -> Int    -- ^ Sample ID
                    -> Double -- ^ left volume: 0 <= scale <= 1
                    -> Double -- ^ right volume: 0 <= scale <= 1
                    -> cr ()
setDefaultSamplePan co sid l r
    = liftIO $
      c'esd_set_default_sample_pan (fdToCInt $ coSocket co)
                                   (fromIntegral sid)
                                   (floor $ l ⋅ c'ESD_VOLUME_BASE)
                                   (floor $ r ⋅ c'ESD_VOLUME_BASE)
          ≫= failOnError ( printf "esd_set_default_sample_pan(%s, %s, %s, %s) returned an error"
                                   (show $ coSocket co)
                                   (show sid)
                                   (show l  )
                                   (show r  )
                          ) (≤ 0)
          ≫  return ()

-- | A data type to represent server's state.
data ServerState
    = Standby
    | AutoStandby
    | Running
    deriving (Eq, Show)

extractServerState :: C'esd_standby_mode_t -> ServerState
extractServerState st
    | st ≡ c'ESM_ON_STANDBY     = Standby
    | st ≡ c'ESM_ON_AUTOSTANDBY = AutoStandby
    | st ≡ c'ESM_RUNNING        = Running
    | otherwise                  = error ("unknown state: " ⧺ show st)

-- | Retrieve the server's state.
getServerState :: ( AncestorRegion pr cr
                  , MonadIO cr
                  )
               => Controller pr
               -> cr ServerState
getServerState co
    = liftIO $
      fmap extractServerState $
      c'esd_get_standby_mode (fdToCInt $ coSocket co)
          ≫= failOnError "esd_get_standby_mode(fd) returned an error" (≡ c'ESM_ERROR)

</pre>