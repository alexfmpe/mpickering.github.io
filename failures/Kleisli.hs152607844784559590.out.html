<a href="KISSmetrics.hs5725477472083245269.out.html">prev</a></br><a href="failures.html">home</a></br><a href="KnobTests.hs577163951524325968.out.html">next</a></br></br><pre>43c43
<   type KleisliAdjF m :% a = a
---
>   type               :% m    a = a
50c50
<   type KleisliAdjG m :% a = m :% a
---
>   type               :% m    a = m :% a
57a58
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, TypeOperators, GADTs, FlexibleInstances, FlexibleContexts, RankNTypes, ScopedTypeVariables, UndecidableInstances, NoImplicitPrelude  #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Category.Kleisli
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  sjoerd@w3future.com
-- Stability   :  experimental
-- Portability :  non-portable
--
-- This is an attempt at the Kleisli category, and the construction
-- of an adjunction for each monad.
-----------------------------------------------------------------------------
module Data.Category.Kleisli where

import Data.Category
import Data.Category.Functor
import Data.Category.NaturalTransformation
import Data.Category.Monoidal
import qualified Data.Category.Adjunction as A


data Kleisli m a b where
  Kleisli :: (Functor m, Dom m ~ k, Cod m ~ k) => Monad m -> Obj k b -> k a (m :% b) -> Kleisli m a b

kleisliId :: (Functor m, Dom m ~ k, Cod m ~ k) => Monad m -> Obj k a -> Kleisli m a a
kleisliId m a = Kleisli m a (unit m ! a)

-- | The category of Kleisli arrows.
instance Category (Kleisli m) where

  src (Kleisli m _ f) = kleisliId m (src f)
  tgt (Kleisli m b _) = kleisliId m b

  (Kleisli m c f) . (Kleisli _ _ g) = Kleisli m c ((multiply m ! c) . (monadFunctor m % f) . g)



data KleisliAdjF m = KleisliAdjF (Monad m)
instance (Functor m, Dom m ~ k, Cod m ~ k) => Functor (KleisliAdjF m) where
  type Dom (KleisliAdjF m) = Dom m
  type Cod (KleisliAdjF m) = Kleisli m
  type KleisliAdjF m :% a = a
  KleisliAdjF m % f = Kleisli m (tgt f) ((unit m ! tgt f) . f)

data KleisliAdjG m = KleisliAdjG (Monad m)
instance (Functor m, Dom m ~ k, Cod m ~ k) => Functor (KleisliAdjG m) where
  type Dom (KleisliAdjG m) = Kleisli m
  type Cod (KleisliAdjG m) = Dom m
  type KleisliAdjG m :% a = m :% a
  KleisliAdjG m % Kleisli _ b f = (multiply m ! b) . (monadFunctor m % f)

kleisliAdj :: (Functor m, Dom m ~ k, Cod m ~ k)
  => Monad m -> A.Adjunction (Kleisli m) k (KleisliAdjF m) (KleisliAdjG m)
kleisliAdj m = A.mkAdjunction (KleisliAdjF m) (KleisliAdjG m)
  (\x -> unit m ! x)
  (\(Kleisli _ x _) -> Kleisli m x (monadFunctor m % x))
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, TypeOperators, GADTs, FlexibleInstances, FlexibleContexts, RankNTypes, ScopedTypeVariables, UndecidableInstances, NoImplicitPrelude  #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Category.Kleisli
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  sjoerd@w3future.com
-- Stability   :  experimental
-- Portability :  non-portable
--
-- This is an attempt at the Kleisli category, and the construction
-- of an adjunction for each monad.
-----------------------------------------------------------------------------
module Data.Category.Kleisli where

import Data.Category
import Data.Category.Functor
import Data.Category.NaturalTransformation
import Data.Category.Monoidal
import qualified Data.Category.Adjunction as A


data Kleisli m a b where
  Kleisli :: (Functor m, Dom m ~ k, Cod m ~ k) => Monad m -> Obj k b -> k a (m :% b) -> Kleisli m a b

kleisliId :: (Functor m, Dom m ~ k, Cod m ~ k) => Monad m -> Obj k a -> Kleisli m a a
kleisliId m a = Kleisli m a (unit m ! a)

-- | The category of Kleisli arrows.
instance Category (Kleisli m) where

  src (Kleisli m _ f) = kleisliId m (src f)
  tgt (Kleisli m b _) = kleisliId m b

  (Kleisli m c f) . (Kleisli _ _ g) = Kleisli m c ((multiply m ! c) . (monadFunctor m % f) . g)



data KleisliAdjF m = KleisliAdjF (Monad m)
instance (Functor m, Dom m ~ k, Cod m ~ k) => Functor (KleisliAdjF m) where
  type Dom (KleisliAdjF m) = Dom m
  type Cod (KleisliAdjF m) = Kleisli m
  type               :% m    a = a
  KleisliAdjF m % f = Kleisli m (tgt f) ((unit m ! tgt f) . f)

data KleisliAdjG m = KleisliAdjG (Monad m)
instance (Functor m, Dom m ~ k, Cod m ~ k) => Functor (KleisliAdjG m) where
  type Dom (KleisliAdjG m) = Kleisli m
  type Cod (KleisliAdjG m) = Dom m
  type               :% m    a = m :% a
  KleisliAdjG m % Kleisli _ b f = (multiply m ! b) . (monadFunctor m % f)

kleisliAdj :: (Functor m, Dom m ~ k, Cod m ~ k)
  => Monad m -> A.Adjunction (Kleisli m) k (KleisliAdjF m) (KleisliAdjG m)
kleisliAdj m = A.mkAdjunction (KleisliAdjF m) (KleisliAdjG m)
  (\x -> unit m ! x)
  (\(Kleisli _ x _) -> Kleisli m x (monadFunctor m % x))

</pre>