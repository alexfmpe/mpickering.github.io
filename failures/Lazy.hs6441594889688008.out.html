<a href="Lazy.hs270649095428975319.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Linear.hs555860589795054873.out.html">next</a></br></br><pre>932c932
<     STRICT2(go)
---
>     go a b | a `seq` b `seq` False = undefined
1032d1031
< 
1044d1042
< 
1046d1043
< -- the pair of ByteStrings with elements which do and do not satisfy the
1047d1043
< -- predicate, respectively; i.e.,
1048d1043
< --
1049d1043
< -- > partition p bs == (filter p xs, filter (not . p) xs)
1050d1043
< --
1051d1043
< partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1052c1044
< partition f p = (filter f p, filter (not . f) p)
---
> -- the pair of ByteStrings with elements which do and do not satisfy the-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1052a1045
> -- predicate, respectively; i.e.,-- the pair of ByteStrings with elements which do and do not satisfy the
1052a1046
> ---- predicate, respectively; i.e.,
1052a1047
> ---- > partition p bs == (filter p xs, filter (not . p) xs)
1052a1048
> ---- > partition p bs == (filter p xs, filter (not . p) xs)
1052a1049
> --partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1052a1050
> partition ::f p(Word8= (filter-> Boolf p) ->filter(not . ->f) (ByteString)         , ByteString)
1052a1051
> partition--TODO: use a better implementation p = (filter f p, filter (not . f) p)
1054d1052
< 
1055a1054
> -- Searching for substrings-- ---------------------------------------------------------------------
1057d1055
< 
1059d1056
< -- iff the first is a prefix of the second.
1060d1056
< isPrefixOf :: ByteString -> ByteString -> Bool
1061d1056
< isPrefixOf Empty _  = True
1062d1056
< isPrefixOf _ Empty  = False
1063d1056
< isPrefixOf (Chunk x xs) (Chunk y ys)
1064d1056
<     | S.length x == S.length y = x == y  && isPrefixOf xs ys
1065d1056
<     | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
1066c1057
<     | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
---
> -- iff the first is a prefix of the second.-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
1066a1058
> isPrefixOf-- iff the first is a prefix of the second.:: ByteString -> ByteString -> Bool
1066a1059
> isPrefixOf ::Empty_  = True-> ByteString -> Bool
1066a1060
> isPrefixOf Empty_ Empty  = TrueFalse
1066a1061
> isPrefixOf _Chunkx =xsFalse) (Chunk y ys)
1066a1062
> isPrefixOf| S.lengthChunkx == xsS.length) (Chunky y ysx )== y  && isPrefixOf xs ys
1066a1063
>     | S.length x ==<  S.length y = x == yyh && isPrefixOf xs ys(Chunk yt ys)
1066a1064
>     | S.lengthotherwisex <  S.length y = xxh====yhy && isPrefixOf xs(ChunkChunkxt yt)ysys)
1066a1065
>   where otherwise(xh,xt) = S.splitAt (S.length= xh ==yy &&x  isPrefixOf (Chunk xt xs) ys
1069d1067
< 
1071d1068
< -- iff the first is a suffix of the second.
1072d1068
< --
1073d1068
< -- The following holds:
1074d1068
< --
1075d1068
< -- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
1076d1068
< --
1077d1068
< isSuffixOf :: ByteString -> ByteString -> Bool
1078c1069
< isSuffixOf x y = reverse x `isPrefixOf` reverse y
---
> -- iff the first is a suffix of the second.-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
1078a1070
> ---- iff the first is a suffix of the second.
1078a1071
> ---- The following holds:
1078a1072
> ---- The following holds:
1078a1073
> ---- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
1078a1074
> ---- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
1078a1075
> --isSuffixOf :: ByteString -> ByteString -> Bool
1078a1076
> isSuffixOf ::x yByteString= reverse ->x `ByteString`->reverse  y
1078a1077
> isSuffixOf--TODO: a better implementation y = reverse x `isPrefixOf` reverse y
1080d1078
< 
1081a1080
> -- Zipping-- ---------------------------------------------------------------------
1083d1081
< 
1084a1083
> -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- corresponding pairs of bytes. If one input ByteString is short,
1086d1084
< -- excess elements of the longer ByteString are discarded. This is
1087d1084
< -- equivalent to a pair of 'unpack' operations.
1088c1085
< zip :: ByteString -> ByteString -> [(Word8,Word8)]
---
> -- equivalent to a pair of 'unpack' operations.-- excess elements of the longer ByteString are discarded. This is
1088a1086
> zip-- equivalent to a pair of 'unpack' operations.:: ByteString -> ByteString -> [(Word8,Word8)]
1088a1087
> zip ::= zipWith(,) -> ByteString -> [(Word8,Word8)]
1090d1088
< 
1092d1089
< -- the first argument, instead of a tupling function.  For example,
1093d1089
< -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1094d1089
< -- corresponding sums.
1095d1089
< zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
1096d1089
< zipWith _ Empty     _  = []
1097d1089
< zipWith _ _      Empty = []
1098d1089
< zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
1099d1089
<   where
1100c1090
<     go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
---
> -- the first argument, instead of a tupling function.  For example,-- | 'zipWith' generalises 'zip' by zipping with the function given as
1100a1091
> -- the first argument, instead of a tupling function.  For example,-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1100a1092
> -- corresponding sums.-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1100a1093
> zipWith-- corresponding sums.:: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
1100a1094
> zipWith ::_ EmptyWord8 ->_Word8= []-> a) -> ByteString -> ByteString -> [a]
1100a1095
> zipWith _ Empty_      Empty  = []
1100a1096
> zipWith _ _Chunk Emptya as) =Chunk]   b bs) = go a as b bs
1100a1097
> zipWithwhere f (Chunk a as) (Chunk b bs) = go a as b bs
1100a1098
>   wherego x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
1100a1099
>     go x xs y ys = fto(S.unsafeHead(S.unsafeTailx))(S.unsafeHeadxs (S.unsafeTail)  y) ys
1102d1100
< 
1104d1101
<     to _ _             y Empty         | S.null y       = []
1105d1101
<     to x xs            y ys            | not (S.null x)
1106d1101
<                                       && not (S.null y) = go x  xs y  ys
1107d1101
<     to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
1108c1102
<     to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
---
>     to x Empty_             _ _Empty         | S.null x       = []
1108a1103
>     to _ _xs            y Emptyys            | S.nullnot (S.null    x) = []
1108a1104
>     to x xs            y ys           && not (S.null x) = go x  xs y  ys
1108a1105
>     to x xs            _ (Chunk y' ys)&&| not (S.null y) = go x  xs yy' ys
1108a1106
>     to x xs(Chunk x' xs) _ (ysChunk y' ys) | not (S.null x) = go xx' xs y'y  ys
1108a1107
>     to _ (Chunk x' xs) y ys(Chunk y' ys) | not (S.null y) = go x' xs yy' ys
1110d1108
< 
1112d1109
< -- ByteStrings. Note that this performs two 'pack' operations.
1113d1109
< unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
1114c1110
< unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
---
> -- ByteStrings. Note that this performs two 'pack' operations.-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
1114a1111
> unzip-- ByteStrings. Note that this performs two 'pack' operations.:: [(Word8,Word8)] -> (ByteString,ByteString)
1114a1112
> unzip :: [(Word8(pack,Word8(L.map)]fst-> (lsByteString), pack (,L.mapByteStringsnd ls)))
1114a1113
> unzip{-# INLINE = (unzippack (#-}L.map fst ls), pack (L.map snd ls))
1116d1114
< 
1117a1116
> -- Special lists-- ---------------------------------------------------------------------
1119d1117
< 
1121d1118
< inits :: ByteString -> [ByteString]
1122d1118
< inits = (Empty :) . inits'
1123d1118
<   where inits' Empty        = []
1124c1119
<         inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
---
> inits-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.:: ByteString -> [ByteString]
1124a1120
> inits ::= (ByteStringEmpty :) . ->inits'ByteString]
1124a1121
> initswhere= (inits'Empty :Empty) . inits'  = []
1124a1122
>   where inits' Empty(Chunk c cs) = [L.map]    (\c' -> Chunk c' Empty) (L.tail (S.inits c))
1124a1123
>         inits' (Chunk c cs)++= L.map (\Chunkc' ->cChunk) (inits' Emptycs) ) (L.tail (S.inits c))
1126d1124
< 
1128d1125
< tails :: ByteString -> [ByteString]
1129d1125
< tails Empty         = Empty : []
1130d1125
< tails cs@(Chunk c cs')
1131c1126
<   | S.length c == 1 = cs : tails cs'
---
> tails-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.:: ByteString -> [ByteString]
1131a1127
> tails ::Empty ->= EmptyByteString: []  ]
1131a1128
> tails Emptycs@(Chunk c cs'=)Empty : []
1131a1129
> tails| S.length@(Chunkc == cs'1 =)cs : tails cs'
1131a1130
>   | S.lengthotherwisec == 1 = cs : tails cs'(Chunk (S.unsafeTail c) cs')
1133d1131
< 
1134a1133
> -- Low level constructors-- ---------------------------------------------------------------------
1136d1134
< 
1137a1136
> --   This is mainly useful to allow the rest of the data pointed-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
1139d1137
< --   to by the 'ByteString' to be garbage collected, for example
1140d1137
< --   if a large string has been read in, and only a small part of it
1141d1137
< --   is needed in the rest of the program.
1142d1137
< copy :: ByteString -> ByteString
1143d1137
< copy cs = foldrChunks (Chunk . S.copy) Empty cs
1144d1137
< --TODO, we could coalese small blocks here
1145c1138
< --FIXME: probably not strict enough, if we're doing this to avoid retaining
---
> --   to by the 'ByteString' to be garbage collected, for example--   if a large string has been read in, and only a small part of it
1145a1139
> --   is needed in the rest of the program.--   if a large string has been read in, and only a small part of it
1145a1140
> copy--   is needed in the rest of the program.:: ByteString -> ByteString
1145a1141
> copy :: ByteString= foldrChunks-> ByteString(Chunk . S.copy) Empty cs
1145a1142
> copy--TODO, we could coalese small blocks here = foldrChunks (Chunk . S.copy) Empty cs
1145a1143
> --TODO, we could coalese small blocks here--FIXME: probably not strict enough, if we're doing this to avoid retaining
1145a1144
> -- the parent blocks then we'd better copy strictly.--FIXME: probably not strict enough, if we're doing this to avoid retaining
1147d1145
< 
1149c1147
< 
---
> -- ---------------------------------------------------------------------
1150a1149
> -- defrag :: ByteString -> ByteString-- TODO defrag func that concatenates block together that are below a threshold
1152d1150
< 
1154d1151
< -- Lazy ByteString IO
1155d1151
< --
1156d1151
< -- Rule for when to close: is it expected to read the whole file?
1157c1152
< -- If so, close when done.
---
> -- Lazy ByteString IO-- ---------------------------------------------------------------------
1157a1153
> ---- Lazy ByteString IO
1157a1154
> ---- Rule for when to close: is it expected to read the whole file?
1157a1155
> -- If so, close when done.-- Rule for when to close: is it expected to read the whole file?
1157a1156
> ---- If so, close when done.
1159d1157
< 
1160a1159
> -- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
1162d1160
< -- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
1163d1160
< -- available then they will be returned immediately as a smaller chunk.
1164d1160
< --
1165d1160
< -- The handle is closed on EOF.
1166d1160
< --
1167d1160
< -- Note: the 'Handle' should be placed in binary mode with
1168d1160
< -- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
1169d1160
< -- work correctly.
1170d1160
< --
1171d1160
< hGetContentsN :: Int -> Handle -> IO ByteString
1172d1160
< hGetContentsN k h = lazyRead -- TODO close on exceptions
1173c1161
<   where
---
> -- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are-- available then they will be returned immediately as a smaller chunk.
1173a1162
> ---- available then they will be returned immediately as a smaller chunk.
1173a1163
> ---- The handle is closed on EOF.
1173a1164
> ---- The handle is closed on EOF.
1173a1165
> ---- Note: the 'Handle' should be placed in binary mode with
1173a1166
> -- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to-- Note: the 'Handle' should be placed in binary mode with
1173a1167
> -- work correctly.-- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
1173a1168
> ---- work correctly.
1173a1169
> --hGetContentsN :: Int -> Handle -> IO ByteString
1173a1170
> hGetContentsN ::k hInt= lazyRead-> Handle-- TODO close on exceptions-> IO ByteString
1173a1171
> hGetContentsNwhere       k h = lazyRead -- TODO close on exceptions
1173a1172
>   wherelazyRead = unsafeInterleaveIO loop
1175d1173
< 
1177d1174
<         c <- S.hGetSome h k -- only blocks if there is no data available
1178d1174
<         if S.null c
1179d1174
<           then do hClose h >> return Empty
1180c1175
<           else do cs <- lazyRead
---
>     loopc=<-S.hGetSome h k -- only blocks if there is no data available
1180a1176
>         cif<-S.nullc     h k -- only blocks if there is no data available
1180a1177
>         ifthendo chClose h >> return Empty
1180a1178
>           then     do hClosecs <- lazyRead >> return Empty
1180a1179
>           else do csreturn<- lazyRead(Chunk c cs)
1182d1180
< 
1184d1181
< -- specified 'Handle', in chunks of size @k@.
1185d1181
< --
1186d1181
< hGetN :: Int -> Handle -> Int -> IO ByteString
1187d1181
< hGetN k h n | n > 0 = readChunks n
1188d1181
<   where
1189d1181
<     STRICT1(readChunks)
1190d1181
<     readChunks i = do
1191d1181
<         c <- S.hGet h (min k i)
1192d1181
<         case S.length c of
1193d1181
<             0 -> return Empty
1194c1182
<             m -> do cs <- readChunks (i - m)
---
> -- specified 'Handle', in chunks of size @k@.-- | Read @n@ bytes into a 'ByteString', directly from the
1194a1183
> ---- specified 'Handle', in chunks of size @k@.
1194a1184
> --hGetN :: Int -> Handle -> Int -> IO ByteString
1194a1185
> hGetN ::k hIntn |->n Handle> 0 = readChunks-> Int -> IOn  ByteString
1194a1186
> hGetNwhere h n | n > 0 = readChunks n
1194a1187
>   whereSTRICT1(readChunks)
1194a1188
>     readChunks a | ado`seq` False = undefined
1194a1189
>     readChunksc <- S.hGet = doh (min k i)
1194a1190
>         ccase<- S.hGetS.length (minof k i)
1194a1191
>         case0S.length-> return ofEmpty
1194a1192
>             0 -> returndo cs <-readChunks (i - m)
1194a1193
>             m -> do csreturn<- readChunks(Chunk c csi - m)
1196d1194
< 
1197a1196
> hGetN _ _ 0 = returnillegalBufferSize      h "hGet" n
1199d1197
< 
1201d1198
< -- waiting for data to become available, instead it returns only whatever data
1202d1198
< -- is available. Chunks are read on demand, in @k@-sized chunks.
1203d1198
< --
1204d1198
< hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
1205c1199
< #if defined(__GLASGOW_HASKELL__)
---
> -- waiting for data to become available, instead it returns only whatever data-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
1205a1200
> -- is available. Chunks are read on demand, in @k@-sized chunks.-- waiting for data to become available, instead it returns only whatever data
1205a1201
> ---- is available. Chunks are read on demand, in @k@-sized chunks.
1205a1202
> --hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
1205a1203
> hGetNonBlockingN#if defined(__GLASGOW_HASKELL__):: Int -> Handle -> Int -> IO ByteString
1207d1204
<   where
1208d1204
<     STRICT1(readChunks)
1209d1204
<     readChunks i = do
1210d1204
<         c <- S.hGetNonBlocking h (min k i)
1211d1204
<         case S.length c of
1212d1204
<             0 -> return Empty
1213c1205
<             m -> do cs <- readChunks (i - m)
---
> hGetNonBlockingNwhere          k h n | n > 0= readChunks n
1213a1206
>   whereSTRICT1(readChunks)
1213a1207
>     readChunks a | ado`seq` False = undefined
1213a1208
>     readChunksc <- S.hGetNonBlocking = do          h (min k i)
1213a1209
>         ccase<- S.hGetNonBlockingS.length c of     h (min k i)
1213a1210
>         case0S.length-> return ofEmpty
1213a1211
>             0 -> returndo cs <-readChunks (i - m)
1213a1212
>             m -> do csreturn<- readChunks(Chunk c csi - m)
1215d1213
< 
1217d1214
< hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
1218c1215
< #else
---
> hGetNonBlockingN _ _ 0 = returnillegalBufferSize      h "hGetNonBlocking" n
1218a1216
> hGetNonBlockingN#else             _ h n = illegalBufferSize h "hGetNonBlocking" n
1223d1220
< illegalBufferSize handle fn sz =
1224d1220
<     ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1225d1220
<     --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
1226c1221
<     where
---
> illegalBufferSize ::handlefn -> String=      -> Int -> IO a
1226a1222
> illegalBufferSizeioError (mkIOErrorillegalOperationErrorType sz =                 msg (Just handle) Nothing)
1226a1223
>     ioError--TODO: System.IO uses InvalidArgument here, but it's not exported :-(mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1226a1224
>     where--TODO: System.IO uses InvalidArgument here, but it's not exported :-(
1226a1225
>     wheremsg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1228d1226
< 
1230d1227
< -- are read on demand, using the default chunk size.
1231d1227
< --
1232d1227
< -- Once EOF is encountered, the Handle is closed.
1233d1227
< --
1234d1227
< -- Note: the 'Handle' should be placed in binary mode with
1235d1227
< -- 'System.IO.hSetBinaryMode' for 'hGetContents' to
1236d1227
< -- work correctly.
1237d1227
< --
1238c1228
< hGetContents :: Handle -> IO ByteString
---
> -- are read on demand, using the default chunk size.-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
1238a1229
> ---- are read on demand, using the default chunk size.
1238a1230
> ---- Once EOF is encountered, the Handle is closed.
1238a1231
> ---- Once EOF is encountered, the Handle is closed.
1238a1232
> ---- Note: the 'Handle' should be placed in binary mode with
1238a1233
> -- 'System.IO.hSetBinaryMode' for 'hGetContents' to-- Note: the 'Handle' should be placed in binary mode with
1238a1234
> -- work correctly.-- 'System.IO.hSetBinaryMode' for 'hGetContents' to
1238a1235
> ---- work correctly.
1238a1236
> --hGetContents :: Handle -> IO ByteString
1238a1237
> hGetContents ::= hGetContentsN -> IO ByteStringdefaultChunkSize
1240d1238
< 
1242d1239
< --
1243c1240
< hGet :: Handle -> Int -> IO ByteString
---
> ---- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
1243a1241
> --hGet :: Handle -> Int -> IO ByteString
1243a1242
> hGet ::= hGetNdefaultChunkSize-> Int -> IO ByteString
1245d1243
< 
1247d1244
< -- waiting for data to become available, instead it returns only whatever data
1248d1244
< -- is available.  If there is no data available to be read, 'hGetNonBlocking'
1249d1244
< -- returns 'empty'.
1250d1244
< --
1251d1244
< -- Note: on Windows and with Haskell implementation other than GHC, this
1252d1244
< -- function does not work correctly; it behaves identically to 'hGet'.
1253d1244
< --
1254c1245
< #if defined(__GLASGOW_HASKELL__)
---
> -- | hGetNonBlocking is similar to 'hGet', except that it will never block-- waiting for data to become available, instead it returns only whatever data
1254a1246
> -- is available.  If there is no data available to be read, 'hGetNonBlocking'-- waiting for data to become available, instead it returns only whatever data
1254a1247
> -- returns 'empty'.-- is available.  If there is no data available to be read, 'hGetNonBlocking'
1254a1248
> ---- returns 'empty'.
1254a1249
> ---- Note: on Windows and with Haskell implementation other than GHC, this
1254a1250
> -- function does not work correctly; it behaves identically to 'hGet'.-- Note: on Windows and with Haskell implementation other than GHC, this
1254a1251
> ---- function does not work correctly; it behaves identically to 'hGet'.
1254a1252
> --#if defined(__GLASGOW_HASKELL__)
1256d1253
< hGetNonBlocking = hGetNonBlockingN defaultChunkSize
1257c1254
< #else
---
> hGetNonBlocking ::= hGetNonBlockingN -> Int ->defaultChunkSize ByteString
1257a1255
> hGetNonBlocking#else            = hGetNonBlockingN defaultChunkSize
1262d1259
< -- The Handle will be held open until EOF is encountered.
1263d1259
< --
1264c1260
< readFile :: FilePath -> IO ByteString
---
> -- | Read an entire file /lazily/ into a 'ByteString'.-- The Handle will be held open until EOF is encountered.
1264a1261
> ---- The Handle will be held open until EOF is encountered.
1264a1262
> --readFile :: FilePath -> IO ByteString
1264a1263
> readFile ::f =FilePathopenBinaryFile-> IO ByteStringf ReadMode >>= hGetContents
1266d1264
< 
1268d1265
< --
1269d1265
< writeFile :: FilePath -> ByteString -> IO ()
1270c1266
< writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
---
> ---- | Write a 'ByteString' to a file.
1270a1267
> --writeFile :: FilePath -> ByteString -> IO ()
1270a1268
> writeFile ::f txt= bracket-> ByteString(openBinaryFile-> IO ()WriteMode) hClose
1270a1269
> writeFile(\hdl f->txthPut= brackethdl txt)(openBinaryFile f WriteMode) hClose
1272d1270
< 
1274d1271
< --
1275d1271
< appendFile :: FilePath -> ByteString -> IO ()
1276c1272
< appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
---
> ---- | Append a 'ByteString' to a file.
1276a1273
> --appendFile :: FilePath -> ByteString -> IO ()
1276a1274
> appendFile ::f txt= bracket-> ByteString(openBinaryFile-> IO ()AppendMode) hClose
1276a1275
> appendFile(\hdl -> txthPut=hdltxt) (openBinaryFile f AppendMode) hClose
1278d1276
< 
1280d1277
< --
1281c1278
< getContents :: IO ByteString
---
> ---- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
1281a1279
> --getContents :: IO ByteString
1281a1280
> getContents ::= hGetContents ByteStringstdin
1283d1281
< 
1285d1282
< --
1286c1283
< hPut :: Handle -> ByteString -> IO ()
---
> ---- | Outputs a 'ByteString' to the specified 'Handle'.
1286a1284
> --hPut :: Handle -> ByteString -> IO ()
1286a1285
> hPut ::h cs= foldrChunks-> ByteString(\c rest-> IO->()S.hPut h c >> rest) (return ()) cs
1288d1286
< 
1290d1287
< -- any tail that did not get written. This tail may be 'empty' in the case that
1291d1287
< -- the whole string was written, or the whole original string if nothing was
1292d1287
< -- written. Partial writes are also possible.
1293d1287
< --
1294d1287
< -- Note: on Windows and with Haskell implementation other than GHC, this
1295d1287
< -- function does not work correctly; it behaves identically to 'hPut'.
1296d1287
< --
1297d1287
< hPutNonBlocking :: Handle -> ByteString -> IO ByteString
1298d1287
< hPutNonBlocking _ Empty           = return Empty
1299d1287
< hPutNonBlocking h bs@(Chunk c cs) = do
1300d1287
<   c' <- S.hPutNonBlocking h c
1301d1287
<   case S.length c' of
1302d1287
<     l' | l' == S.length c -> hPutNonBlocking h cs
1303c1288
<     0                     -> return bs
---
> -- | Similar to 'hPut' except that it will never block. Instead it returns-- any tail that did not get written. This tail may be 'empty' in the case that
1303a1289
> -- the whole string was written, or the whole original string if nothing was-- any tail that did not get written. This tail may be 'empty' in the case that
1303a1290
> -- written. Partial writes are also possible.-- the whole string was written, or the whole original string if nothing was
1303a1291
> ---- written. Partial writes are also possible.
1303a1292
> ---- Note: on Windows and with Haskell implementation other than GHC, this
1303a1293
> -- function does not work correctly; it behaves identically to 'hPut'.-- Note: on Windows and with Haskell implementation other than GHC, this
1303a1294
> ---- function does not work correctly; it behaves identically to 'hPut'.
1303a1295
> --hPutNonBlocking :: Handle -> ByteString -> IO ByteString
1303a1296
> hPutNonBlocking ::_ Empty -> ByteString= return-> IOEmpty
1303a1297
> hPutNonBlocking _ Emptybs@(Chunk c cs) = returndo     Empty
1303a1298
> hPutNonBlockingc' <- S.hPutNonBlocking bs@(Chunkh c cs) = do
1303a1299
>   c'case<-S.lengthc' of     h c
1303a1300
>   casel' S.length| l' == S.length of   c -> hPutNonBlocking h cs
1303a1301
>     l'0  | l' == S.length c -> hPutNonBlockingreturn bs       h cs
1303a1302
>     0                     -> return bs(Chunk c' cs)
1305d1303
< 
1307d1304
< --
1308c1305
< hPutStr :: Handle -> ByteString -> IO ()
---
> ---- | A synonym for @hPut@, for compatibility
1308a1306
> --hPutStr :: Handle -> ByteString -> IO ()
1308a1307
> hPutStr ::= hPut -> ByteString -> IO ()
1310d1308
< 
1312c1310
< putStr :: ByteString -> IO ()
---
> putStr-- | Write a ByteString to stdout:: ByteString -> IO ()
1312a1311
> putStr ::= hPutstdout -> IO ()
1314d1312
< 
1316d1313
< --
1317c1314
< putStrLn :: ByteString -> IO ()
---
> ---- | Write a ByteString to stdout, appending a newline byte
1317a1315
> --putStrLn :: ByteString -> IO ()
1317a1316
> putStrLn :: ByteString= hPut stdout-> IO (>>) hPut stdout (singleton 0x0a)
1319d1317
< 
1321c1319
<     "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
---
> {-# DEPRECATED"Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
1323c1321
< 
---
>   #-}
1326d1323
< -- to this function as its argument, and the resulting string is output on the
1327d1323
< -- standard output device.
1328c1324
< --
---
> -- | The interact function takes a function of type @ByteString -> ByteString@
1328a1325
> -- standard output device.-- as its argument. The entire input from the standard input device is passed
1328a1326
> ---- to this function as its argument, and the resulting string is output on the
1328a1327
> interact-- standard output device.:: (ByteString -> ByteString) -> IO ()
1328a1328
> --interact transformer = putStr . transformer =<< getContents
1330d1329
< interact transformer = putStr . transformer =<< getContents
1331d1329
< 
1332c1330
< -- ---------------------------------------------------------------------
---
> interact-- --------------------------------------------------------------------- = putStr . transformer =<< getContents
1334d1331
< 
1335c1332
< -- Common up near identical calls to `error' to reduce the number
---
> -- ---------------------------------------------------------------------
1335a1333
> -- Internal utilities-- Common up near identical calls to `error' to reduce the number
1337c1335
< errorEmptyList :: String -> a
---
> errorEmptyList-- Common up near identical calls to `error' to reduce the number:: String -> a
1337a1336
> errorEmptyList-- constant strings created when compiled:fun = moduleError fun "empty ByteString"
1337a1337
> errorEmptyList{-# NOINLINE errorEmptyList:: String -> a#-}
1339d1338
< {-# NOINLINE errorEmptyList #-}
1340d1338
< 
1341c1339
< moduleError :: String -> String -> a
---
> {-# NOINLINEmoduleError ::String -> String#-} -> a
1342a1341
> moduleError{-# NOINLINE::moduleError -> String#-}    -> a
1342a1342
> moduleError fun msg = error ("Data.ByteString.Lazy." ++ fun ++ ':':' ':msg)
1344d1343
< 
1345d1343
< 
1348d1345
< revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs
1349d1345
< 
1350c1346
< -- reverse a list of possibly-empty chunks into a lazy ByteString
---
> revNonEmptyChunks-- reverse a list of non-empty chunks into a lazy ByteStringcs = L.foldl' (flip Chunk) Empty cs
1350a1347
> revNonEmptyChunks :: [P.ByteString] -> ByteString
1350a1348
> revNonEmptyChunks-- reverse a list of possibly-empty chunks into a lazy ByteString = L.foldl' (flip Chunk) Empty cs
1352d1349
< revChunks cs = L.foldl' (flip chunk) Empty cs
1353d1349
< 
1354c1350
< -- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
---
> revChunks-- reverse a list of possibly-empty chunks into a lazy ByteStringcs = L.foldl' (flip chunk) Empty cs
1354a1351
> revChunks :: [P.ByteString] -> ByteString
1354a1352
> revChunks-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length = L.foldl' (flip chunk) Empty cs
1356d1353
< findIndexOrEnd :: (Word8 -> Bool) -> P.ByteString -> Int
1357d1353
< findIndexOrEnd k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
1358d1353
<   where
1359d1353
<     STRICT2(go)
1360d1353
<     go ptr n | n >= l    = return l
1361d1353
<              | otherwise = do w <- peek ptr
1362d1353
<                               if k w
1363c1354
<                                 then return n
---
> findIndexOrEnd-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length:: (Word8 -> Bool) -> P.ByteString -> Int
1363a1355
> findIndexOrEnd-- of the string if no element is found, rather than Nothing.k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
1363a1356
> findIndexOrEndwhere        :: (Word8 -> Bool) -> P.ByteString -> Int
1363a1357
> findIndexOrEndSTRICT2(go)k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
1363a1358
>   wherego ptr n | n >= l    = return l
1363a1359
>     go a b | a `otherwiseseq` b `seq= `doFalsew <- =peekptr
1363a1360
>     go ptr n | n >= l    = returnif klw
1363a1361
>              | otherwise = do w <-thenreturn n
1363a1362
>                               ifelse w go (ptr `plusPtr` 1) (n+1)
1363a1363
> {-# INLINE findIndexOrEnd #-}   then return n
1365a1366
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
{-# OPTIONS_HADDOCK prune #-}
#if __GLASGOW_HASKELL__ >= 701
{-# LANGUAGE Trustworthy #-}
#endif

-- |
-- Module      : Data.ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006
--               (c) Duncan Coutts 2006-2011
-- License     : BSD-style
--
-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org
-- Stability   : stable
-- Portability : portable
--
-- A time and space-efficient implementation of lazy byte vectors
-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed
-- requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks
-- of bytes.
--
-- A key feature of lazy ByteStrings is the means to manipulate large or
-- unbounded streams of data without requiring the entire sequence to be
-- resident in memory. To take advantage of this you have to write your
-- functions in a lazy streaming style, e.g. classic pipeline composition. The
-- default I\/O chunk size is 32k, which should be good in most circumstances.
--
-- Some operations, such as 'concat', 'append', 'reverse' and 'cons', have
-- better complexity than their "Data.ByteString" equivalents, due to
-- optimisations resulting from the list spine structure. For other
-- operations lazy ByteStrings are usually within a few percent of
-- strict ones.
--
-- The recomended way to assemble lazy ByteStrings from smaller parts
-- is to use the builder monoid from "Data.ByteString.Builder".
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Lazy as B
--
-- Original GHC implementation by Bryan O\'Sullivan.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
-- by David Roundy.
-- Rewritten again and extended by Don Stewart and Duncan Coutts.
-- Lazy variant by Duncan Coutts and Don Stewart.
--

module Data.ByteString.Lazy (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]
        fromStrict,             -- :: Strict.ByteString -> ByteString
        toStrict,               -- :: ByteString -> Strict.ByteString
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]
        foldrChunks,            -- :: (S.ByteString -> a -> a) -> a -> ByteString -> a
        foldlChunks,            -- :: (a -> S.ByteString -> a) -> a -> ByteString -> a

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        cons',                  -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)
        unsnoc,                 -- :: ByteString -> Maybe (ByteString, Word8)
        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transforming ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Infinite ByteStrings
        repeat,                 -- :: Word8 -> ByteString
        replicate,              -- :: Int64 -> Word8 -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Word8 -> Word8) -> Word8 -> ByteString

        -- ** Unfolding ByteStrings
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
--        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
--        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
--        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int64
        elemIndices,            -- :: Word8 -> ByteString -> [Int64]
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Word8 -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString
--        defrag,                -- :: ByteString -> ByteString

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()

  ) where

import Prelude hiding
    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)

import qualified Data.List              as L  -- L for list/lazy
import qualified Data.ByteString        as P  (ByteString) -- type name only
import qualified Data.ByteString        as S  -- S for strict (hmm...)
import qualified Data.ByteString.Internal as S
import qualified Data.ByteString.Unsafe as S
import Data.ByteString.Lazy.Internal

import Data.Monoid              (Monoid(..))

import Data.Word                (Word8)
import Data.Int                 (Int64)
import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
                                ,hClose)
import System.IO.Error          (mkIOError, illegalOperationErrorType)
import System.IO.Unsafe
#ifndef __NHC__
import Control.Exception        (bracket)
#else
import IO               (bracket)
#endif

import Foreign.ForeignPtr       (withForeignPtr)
import Foreign.Ptr
import Foreign.Storable

-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--

#define STRICT1(f) f a | a `seq` False = undefined
#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined

-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = Empty
{-# INLINE empty #-}

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton w = Chunk (S.singleton w) Empty
{-# INLINE singleton #-}

-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.
pack :: [Word8] -> ByteString
pack = packBytes

-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack :: ByteString -> [Word8]
unpack = unpackBytes

-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString'
fromChunks :: [P.ByteString] -> ByteString
fromChunks cs = L.foldr chunk Empty cs

-- | /O(c)/ Convert a lazy 'ByteString' into a list of strict 'ByteString'
toChunks :: ByteString -> [P.ByteString]
toChunks cs = foldrChunks (:) [] cs

-- |/O(1)/ Convert a strict 'ByteString' into a lazy 'ByteString'.
fromStrict :: P.ByteString -> ByteString
fromStrict bs | S.null bs = Empty
              | otherwise = Chunk bs Empty

-- |/O(n)/ Convert a lazy 'ByteString' into a strict 'ByteString'.
--
-- Note that this is an /expensive/ operation that forces the whole lazy
-- ByteString into memory and then copies all the data. If possible, try to
-- avoid converting back and forth between strict and lazy bytestrings.
--
toStrict :: ByteString -> S.ByteString
toStrict Empty           = S.empty
toStrict (Chunk c Empty) = c
toStrict cs0 = S.unsafeCreate totalLen $ \ptr -> go cs0 ptr
  where
    totalLen = checkedSum "Lazy.toStrict" . L.map S.length . toChunks $ cs0

    go Empty                        !_       = return ()
    go (Chunk (S.PS fp off len) cs) !destptr =
      withForeignPtr fp $ \p -> do
        S.memcpy destptr (p `plusPtr` off) len
        go cs (destptr `plusPtr` len)

-- just here in 0.10.4.x, in later version it's exported from .Internal
checkedSum :: String -> [Int] -> Int
checkedSum fun = go 0
  where go !a (x:xs)
            | ax >= 0   = go ax xs
            | otherwise = overflowError fun
          where ax = a + x
        go a  _         = a

overflowError :: String -> a
overflowError fun = error $ "Data.ByteString." ++ fun ++ ": size overflow"

------------------------------------------------------------------------

{-
-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}
-}

-- ---------------------------------------------------------------------
-- Basic interface

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null Empty = True
null _     = False
{-# INLINE null #-}

-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64'
length :: ByteString -> Int64
length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
{-# INLINE length #-}

infixr 5 `cons`, `cons'` --same as list (:)
infixl 5 `snoc`

-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
--
cons :: Word8 -> ByteString -> ByteString
cons c cs = Chunk (S.singleton c) cs
{-# INLINE cons #-}

-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons\' c xs in xs
--
-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.
--
cons' :: Word8 -> ByteString -> ByteString
cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
cons' w cs                             = Chunk (S.singleton w) cs
{-# INLINE cons' #-}

-- | /O(n\/c)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc cs w = foldrChunks Chunk (singleton w) cs
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Word8
head Empty       = errorEmptyList "head"
head (Chunk c _) = S.unsafeHead c
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)
uncons Empty = Nothing
uncons (Chunk c cs)
    = Just (S.unsafeHead c,
            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
{-# INLINE uncons #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
-- non-empty.
tail :: ByteString -> ByteString
tail Empty          = errorEmptyList "tail"
tail (Chunk c cs)
  | S.length c == 1 = cs
  | otherwise       = Chunk (S.unsafeTail c) cs
{-# INLINE tail #-}

-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
-- and non-empty.
last :: ByteString -> Word8
last Empty          = errorEmptyList "last"
last (Chunk c0 cs0) = go c0 cs0
  where go c Empty        = S.unsafeLast c
        go _ (Chunk c cs) = go c cs
-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)

-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.
init :: ByteString -> ByteString
init Empty          = errorEmptyList "init"
init (Chunk c0 cs0) = go c0 cs0
  where go c Empty | S.length c == 1 = Empty
                   | otherwise       = Chunk (S.unsafeInit c) Empty
        go c (Chunk c' cs)           = Chunk c (go c' cs)

-- | /O(n\/c)/ Extract the 'init' and 'last' of a ByteString, returning Nothing
-- if it is empty.
--
-- * It is no faster than using 'init' and 'last'
unsnoc :: ByteString -> Maybe (ByteString, Word8)
unsnoc Empty        = Nothing
unsnoc (Chunk c cs) = Just (init (Chunk c cs), last (Chunk c cs))

-- | /O(n\/c)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append = mappend
{-# INLINE append #-}

-- ---------------------------------------------------------------------
-- Transformations

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@.
map :: (Word8 -> Word8) -> ByteString -> ByteString
map f s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = Chunk y ys
            where
                y  = S.map f x
                ys = go xs
{-# INLINE map #-}

-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse cs0 = rev Empty cs0
  where rev a Empty        = a
        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
{-# INLINE reverse #-}

-- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and
-- \`intersperses\' that byte between the elements of the 'ByteString'.
-- It is analogous to the intersperse function on Lists.
intersperse :: Word8 -> ByteString -> ByteString
intersperse _ Empty        = Empty
intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
                                   (foldrChunks (Chunk . intersperse') Empty cs)
  where intersperse' :: P.ByteString -> P.ByteString
        intersperse' (S.PS fp o l) =
          S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
            poke p' w
            S.c_intersperse (p' `plusPtr` 1) (p `plusPtr` o) (fromIntegral l) w

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
                      (L.transpose (L.map unpack css))
--TODO: make this fast

-- ---------------------------------------------------------------------
-- Reducing 'ByteString's

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl f z = go z
  where go a Empty        = a
        go a (Chunk c cs) = go (S.foldl f a c) cs
{-# INLINE foldl #-}

-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' f z = go z
  where go a _ | a `seq` False = undefined
        go a Empty        = a
        go a (Chunk c cs) = go (S.foldl' f a c) cs
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a ByteString,
-- reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 _ Empty        = errorEmptyList "foldl1"
foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' _ Empty        = errorEmptyList "foldl1'"
foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 _ Empty          = errorEmptyList "foldr1"
foldr1 f (Chunk c0 cs0) = go c0 cs0
  where go c Empty         = S.foldr1 f c
        go c (Chunk c' cs) = S.foldr  f (go c' cs) c

-- ---------------------------------------------------------------------
-- Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat = mconcat

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap _ Empty        = Empty
concatMap f (Chunk c0 cs0) = to c0 cs0
  where
    go :: ByteString -> P.ByteString -> ByteString -> ByteString
    go Empty        c' cs' = to c' cs'
    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')

    to :: P.ByteString -> ByteString -> ByteString
    to c cs | S.null c  = case cs of
        Empty          -> Empty
        (Chunk c' cs') -> to c' cs'
            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
{-# INLINE any #-}
-- todo fuse

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
{-# INLINE all #-}
-- todo fuse

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Word8
maximum Empty        = errorEmptyList "maximum"
maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
                                   (S.maximum c) cs
{-# INLINE maximum #-}

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Word8
minimum Empty        = errorEmptyList "minimum"
minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
                                     (S.minimum c) cs
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s',  c')  = S.mapAccumL f s c
              (s'', cs') = go s' cs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s'', c') = S.mapAccumR f s' c
              (s', cs') = go s cs

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl f z = snd . foldl k (z,singleton z)
 where
    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
{-# INLINE scanl #-}

-- ---------------------------------------------------------------------
-- Unfolds and replicates

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Word8 -> Word8) -> Word8 -> ByteString
iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Word8 -> ByteString
repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Word8 -> ByteString
replicate n w
    | n <= 0             = Empty
    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
    | r == 0             = cs -- preserve invariant
    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
 where
    c      = S.replicate smallChunkSize w
    cs     = nChunks q
    (q, r) = quotRem n (fromIntegral smallChunkSize)
    nChunks 0 = Empty
    nChunks m = Chunk c (nChunks (m-1))

-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
-- the infinite repetition of the original ByteString.
--
cycle :: ByteString -> ByteString
cycle Empty = errorEmptyList "cycle"
cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr f s0 = unfoldChunk 32 s0
  where unfoldChunk n s =
          case S.unfoldrN n f s of
            (c, Nothing)
              | S.null c  -> Empty
              | otherwise -> Chunk c Empty
            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')

-- ---------------------------------------------------------------------
-- Substrings

-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int64 -> ByteString -> ByteString
take i _ | i <= 0 = Empty
take i cs0         = take' i cs0
  where take' 0 _            = Empty
        take' _ Empty        = Empty
        take' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.take (fromIntegral n) c) Empty
            else Chunk c (take' (n - fromIntegral (S.length c)) cs)

-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int64 -> ByteString -> ByteString
drop i p | i <= 0 = p
drop i cs0 = drop' i cs0
  where drop' 0 cs           = cs
        drop' _ Empty        = Empty
        drop' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.drop (fromIntegral n) c) cs
            else drop' (n - fromIntegral (S.length c)) cs

-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
splitAt i cs0 | i <= 0 = (Empty, cs0)
splitAt i cs0 = splitAt' i cs0
  where splitAt' 0 cs           = (Empty, cs)
        splitAt' _ Empty        = (Empty, Empty)
        splitAt' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then (Chunk (S.take (fromIntegral n) c) Empty
                 ,Chunk (S.drop (fromIntegral n) c) cs)
            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
                   in (Chunk c cs', cs'')


-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f cs0 = takeWhile' cs0
  where takeWhile' Empty        = Empty
        takeWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            0                  -> Empty
            n | n < S.length c -> Chunk (S.take n c) Empty
              | otherwise      -> Chunk c (takeWhile' cs)

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f cs0 = dropWhile' cs0
  where dropWhile' Empty        = Empty
        dropWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            n | n < S.length c -> Chunk (S.drop n c) cs
              | otherwise      -> dropWhile' cs

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break f cs0 = break' cs0
  where break' Empty        = (Empty, Empty)
        break' (Chunk c cs) =
          case findIndexOrEnd f c of
            0                  -> (Empty, Chunk c cs)
            n | n < S.length c -> (Chunk (S.take n c) Empty
                                  ,Chunk (S.drop n c) cs)
              | otherwise      -> let (cs', cs'') = break' cs
                                   in (Chunk c cs', cs'')

--
-- TODO
--
-- Add rules
--

{-
-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
  where breakByte' []     = ([], [])
        breakByte' (x:xs) =
          case P.elemIndex c x of
            Just 0  -> ([], x : xs)
            Just n  -> (P.take n x : [], P.drop n x : xs)
            Nothing -> let (xs', xs'') = breakByte' xs
                        in (x : xs', xs'')

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
  where spanByte' []     = ([], [])
        spanByte' (x:xs) =
          case P.spanByte c x of
            (x', x'') | P.null x'  -> ([], x : xs)
                      | P.null x'' -> let (xs', xs'') = spanByte' xs
                                       in (x : xs', xs'')
                      | otherwise  -> (x' : [], x'' : xs)
-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span p = break (not . p)

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith _ Empty          = []
splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs

{-# INLINE splitWith #-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split _ Empty     = []
split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
{-# INLINE split #-}

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = L.filter (not.null) . splitWith f
-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test.
group :: ByteString -> [ByteString]
group = go
  where
    go Empty        = []
    go (Chunk c cs)
      | S.length c == 1  = to [c] (S.unsafeHead c) cs
      | otherwise        = to [S.unsafeTake 1 c] (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

    to acc !_ Empty        = revNonEmptyChunks acc : []
    to acc !w (Chunk c cs) =
      case findIndexOrEnd (/= w) c of
        0                    -> revNonEmptyChunks acc
                              : go (Chunk c cs)
        n | n == S.length c  -> to (S.unsafeTake n c : acc) w cs
          | otherwise        -> revNonEmptyChunks (S.unsafeTake n c : acc)
                              : go (Chunk (S.unsafeDrop n c) cs)

-- | The 'groupBy' function is the non-overloaded version of 'group'.
--
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k = go
  where
    go Empty        = []
    go (Chunk c cs)
      | S.length c == 1  = to [c] (S.unsafeHead c) cs
      | otherwise        = to [S.unsafeTake 1 c] (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

    to acc !_ Empty        = revNonEmptyChunks acc : []
    to acc !w (Chunk c cs) =
      case findIndexOrEnd (not . k w) c of
        0                    -> revNonEmptyChunks acc
                              : go (Chunk c cs)
        n | n == S.length c  -> to (S.unsafeTake n c : acc) w cs
          | otherwise        -> revNonEmptyChunks (S.unsafeTake n c : acc)
                              : go (Chunk (S.unsafeDrop n c) cs)

-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString
intercalate s = concat . (L.intersperse s)

-- ---------------------------------------------------------------------
-- Indexing ByteStrings

-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Word8
index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
index cs0 i         = index' cs0 i
  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
        index' (Chunk c cs) n
          | n >= fromIntegral (S.length c) =
              index' cs (n - fromIntegral (S.length c))
          | otherwise       = S.unsafeIndex c (fromIntegral n)

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element.
-- This implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int64
elemIndex w cs0 = elemIndex' 0 cs0
  where elemIndex' _ Empty        = Nothing
        elemIndex' n (Chunk c cs) =
          case S.elemIndex w c of
            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)

{-
-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    STRICT2(go)
    go p i | i < 0     = return Nothing
           | otherwise = do ch' <- peekByteOff p i
                            if ch == ch'
                                then return $ Just i
                                else go p (i-1)
-}
-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int64]
elemIndices w cs0 = elemIndices' 0 cs0
  where elemIndices' _ Empty        = []
        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
                             ++ elemIndices' (n + fromIntegral (S.length c)) cs

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int64
count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndex k cs0 = findIndex' 0 cs0
  where findIndex' _ Empty        = Nothing
        findIndex' n (Chunk c cs) =
          case S.findIndex k c of
            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)
{-# INLINE findIndex #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find f cs0 = find' cs0
  where find' Empty        = Nothing
        find' (Chunk c cs) = case S.find f c of
            Nothing -> find' cs
            Just w  -> Just w
{-# INLINE find #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
findIndices k cs0 = findIndices' 0 cs0
  where findIndices' _ Empty        = []
        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
                             ++ findIndices' (n + fromIntegral (S.length c)) cs

-- ---------------------------------------------------------------------
-- Searching ByteStrings

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem w cs = not (elem w cs)

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString
filter p s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = chunk (S.filter p x) (go xs)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single byte. It is more
-- efficient to use /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
{-# INLINE filterByte #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
  filter ((==) x) = filterByte x

"ByteString specialise filter (== x)" forall x.
 filter (== x) = filterByte x
  #-}
-}

{-
-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
-}

-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- the pair of ByteStrings with elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p bs == (filter p xs, filter (not . p) xs)
--
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition f p = (filter f p, filter (not . f) p)
--TODO: use a better implementation

-- ---------------------------------------------------------------------
-- Searching for substrings

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool
isPrefixOf Empty _  = True
isPrefixOf _ Empty  = False
isPrefixOf (Chunk x xs) (Chunk y ys)
    | S.length x == S.length y = x == y  && isPrefixOf xs ys
    | S.length x <  S.length y = x == yh && isPrefixOf xs (Chunk yt ys)
    | otherwise                = xh == y && isPrefixOf (Chunk xt xs) ys
  where (xh,xt) = S.splitAt (S.length y) x
        (yh,yt) = S.splitAt (S.length x) y

-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.
--
-- The following holds:
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf x y = reverse x `isPrefixOf` reverse y
--TODO: a better implementation

-- ---------------------------------------------------------------------
-- Zipping

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip = zipWith (,)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith _ Empty     _  = []
zipWith _ _      Empty = []
zipWith f (Chunk a as) (Chunk b bs) = go a as b bs
  where
    go x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys

    to x Empty         _ _             | S.null x       = []
    to _ _             y Empty         | S.null y       = []
    to x xs            y ys            | not (S.null x)
                                      && not (S.null y) = go x  xs y  ys
    to x xs            _ (Chunk y' ys) | not (S.null x) = go x  xs y' ys
    to _ (Chunk x' xs) y ys            | not (S.null y) = go x' xs y  ys
    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys

-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Word8,Word8)] -> (ByteString,ByteString)
unzip ls = (pack (L.map fst ls), pack (L.map snd ls))
{-# INLINE unzip #-}

-- ---------------------------------------------------------------------
-- Special lists

-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits = (Empty :) . inits'
  where inits' Empty        = []
        inits' (Chunk c cs) = L.map (\c' -> Chunk c' Empty) (L.tail (S.inits c))
                           ++ L.map (Chunk c) (inits' cs)

-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails :: ByteString -> [ByteString]
tails Empty         = Empty : []
tails cs@(Chunk c cs')
  | S.length c == 1 = cs : tails cs'
  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')

-- ---------------------------------------------------------------------
-- Low level constructors

-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example
--   if a large string has been read in, and only a small part of it
--   is needed in the rest of the program.
copy :: ByteString -> ByteString
copy cs = foldrChunks (Chunk . S.copy) Empty cs
--TODO, we could coalese small blocks here
--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.

-- ---------------------------------------------------------------------

-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString

-- ---------------------------------------------------------------------
-- Lazy ByteString IO
--
-- Rule for when to close: is it expected to read the whole file?
-- If so, close when done.
--

-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block
-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are
-- available then they will be returned immediately as a smaller chunk.
--
-- The handle is closed on EOF.
--
-- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
-- work correctly.
--
hGetContentsN :: Int -> Handle -> IO ByteString
hGetContentsN k h = lazyRead -- TODO close on exceptions
  where
    lazyRead = unsafeInterleaveIO loop

    loop = do
        c <- S.hGetSome h k -- only blocks if there is no data available
        if S.null c
          then do hClose h >> return Empty
          else do cs <- lazyRead
                  return (Chunk c cs)

-- | Read @n@ bytes into a 'ByteString', directly from the
-- specified 'Handle', in chunks of size @k@.
--
hGetN :: Int -> Handle -> Int -> IO ByteString
hGetN k h n | n > 0 = readChunks n
  where
    STRICT1(readChunks)
    readChunks i = do
        c <- S.hGet h (min k i)
        case S.length c of
            0 -> return Empty
            m -> do cs <- readChunks (i - m)
                    return (Chunk c cs)

hGetN _ _ 0 = return Empty
hGetN _ h n = illegalBufferSize h "hGet" n

-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available. Chunks are read on demand, in @k@-sized chunks.
--
hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
#if defined(__GLASGOW_HASKELL__)
hGetNonBlockingN k h n | n > 0= readChunks n
  where
    STRICT1(readChunks)
    readChunks i = do
        c <- S.hGetNonBlocking h (min k i)
        case S.length c of
            0 -> return Empty
            m -> do cs <- readChunks (i - m)
                    return (Chunk c cs)

hGetNonBlockingN _ _ 0 = return Empty
hGetNonBlockingN _ h n = illegalBufferSize h "hGetNonBlocking" n
#else
hGetNonBlockingN = hGetN
#endif

illegalBufferSize :: Handle -> String -> Int -> IO a
illegalBufferSize handle fn sz =
    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
    where
      msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []

-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, using the default chunk size.
--
-- Once EOF is encountered, the Handle is closed.
--
-- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContents' to
-- work correctly.
--
hGetContents :: Handle -> IO ByteString
hGetContents = hGetContentsN defaultChunkSize

-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
--
hGet :: Handle -> Int -> IO ByteString
hGet = hGetN defaultChunkSize

-- | hGetNonBlocking is similar to 'hGet', except that it will never block
-- waiting for data to become available, instead it returns only whatever data
-- is available.  If there is no data available to be read, 'hGetNonBlocking'
-- returns 'empty'.
--
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hGet'.
--
#if defined(__GLASGOW_HASKELL__)
hGetNonBlocking :: Handle -> Int -> IO ByteString
hGetNonBlocking = hGetNonBlockingN defaultChunkSize
#else
hGetNonBlocking = hGet
#endif

-- | Read an entire file /lazily/ into a 'ByteString'.
-- The Handle will be held open until EOF is encountered.
--
readFile :: FilePath -> IO ByteString
readFile f = openBinaryFile f ReadMode >>= hGetContents

-- | Write a 'ByteString' to a file.
--
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)

-- | Append a 'ByteString' to a file.
--
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)

-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
--
getContents :: IO ByteString
getContents = hGetContents stdin

-- | Outputs a 'ByteString' to the specified 'Handle'.
--
hPut :: Handle -> ByteString -> IO ()
hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs

-- | Similar to 'hPut' except that it will never block. Instead it returns
-- any tail that did not get written. This tail may be 'empty' in the case that
-- the whole string was written, or the whole original string if nothing was
-- written. Partial writes are also possible.
--
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hPut'.
--
hPutNonBlocking :: Handle -> ByteString -> IO ByteString
hPutNonBlocking _ Empty           = return Empty
hPutNonBlocking h bs@(Chunk c cs) = do
  c' <- S.hPutNonBlocking h c
  case S.length c' of
    l' | l' == S.length c -> hPutNonBlocking h cs
    0                     -> return bs
    _                     -> return (Chunk c' cs)

-- | A synonym for @hPut@, for compatibility
--
hPutStr :: Handle -> ByteString -> IO ()
hPutStr = hPut

-- | Write a ByteString to stdout
putStr :: ByteString -> IO ()
putStr = hPut stdout

-- | Write a ByteString to stdout, appending a newline byte
--
putStrLn :: ByteString -> IO ()
putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)

{-# DEPRECATED putStrLn
    "Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
  #-}

-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device.
--
interact :: (ByteString -> ByteString) -> IO ()
interact transformer = putStr . transformer =<< getContents

-- ---------------------------------------------------------------------
-- Internal utilities

-- Common up near identical calls to `error' to reduce the number
-- constant strings created when compiled:
errorEmptyList :: String -> a
errorEmptyList fun = moduleError fun "empty ByteString"
{-# NOINLINE errorEmptyList #-}

moduleError :: String -> String -> a
moduleError fun msg = error ("Data.ByteString.Lazy." ++ fun ++ ':':' ':msg)
{-# NOINLINE moduleError #-}


-- reverse a list of non-empty chunks into a lazy ByteString
revNonEmptyChunks :: [P.ByteString] -> ByteString
revNonEmptyChunks cs = L.foldl' (flip Chunk) Empty cs

-- reverse a list of possibly-empty chunks into a lazy ByteString
revChunks :: [P.ByteString] -> ByteString
revChunks cs = L.foldl' (flip chunk) Empty cs

-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd :: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEnd k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
  where
    STRICT2(go)
    go ptr n | n >= l    = return l
             | otherwise = do w <- peek ptr
                              if k w
                                then return n
                                else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, BangPatterns #-}
{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
{-# OPTIONS_HADDOCK prune #-}
#if __GLASGOW_HASKELL__ >= 701
{-# LANGUAGE Trustworthy #-}
#endif

-- |
-- Module      : Data.ByteString.Lazy
-- Copyright   : (c) Don Stewart 2006
--               (c) Duncan Coutts 2006-2011
-- License     : BSD-style
--
-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org
-- Stability   : stable
-- Portability : portable
--
-- A time and space-efficient implementation of lazy byte vectors
-- using lists of packed 'Word8' arrays, suitable for high performance
-- use, both in terms of large data quantities, or high speed
-- requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks
-- of bytes.
--
-- A key feature of lazy ByteStrings is the means to manipulate large or
-- unbounded streams of data without requiring the entire sequence to be
-- resident in memory. To take advantage of this you have to write your
-- functions in a lazy streaming style, e.g. classic pipeline composition. The
-- default I\/O chunk size is 32k, which should be good in most circumstances.
--
-- Some operations, such as 'concat', 'append', 'reverse' and 'cons', have
-- better complexity than their "Data.ByteString" equivalents, due to
-- optimisations resulting from the list spine structure. For other
-- operations lazy ByteStrings are usually within a few percent of
-- strict ones.
--
-- The recomended way to assemble lazy ByteStrings from smaller parts
-- is to use the builder monoid from "Data.ByteString.Builder".
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Lazy as B
--
-- Original GHC implementation by Bryan O\'Sullivan.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to support slices and use 'Foreign.ForeignPtr.ForeignPtr'
-- by David Roundy.
-- Rewritten again and extended by Don Stewart and Duncan Coutts.
-- Lazy variant by Duncan Coutts and Don Stewart.
--

module Data.ByteString.Lazy (

        -- * The @ByteString@ type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]
        fromStrict,             -- :: Strict.ByteString -> ByteString
        toStrict,               -- :: ByteString -> Strict.ByteString
        fromChunks,             -- :: [Strict.ByteString] -> ByteString
        toChunks,               -- :: ByteString -> [Strict.ByteString]
        foldrChunks,            -- :: (S.ByteString -> a -> a) -> a -> ByteString -> a
        foldlChunks,            -- :: (a -> S.ByteString -> a) -> a -> ByteString -> a

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        cons',                  -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)
        unsnoc,                 -- :: ByteString -> Maybe (ByteString, Word8)
        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int64

        -- * Transforming ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
--        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Infinite ByteStrings
        repeat,                 -- :: Word8 -> ByteString
        replicate,              -- :: Int64 -> Word8 -> ByteString
        cycle,                  -- :: ByteString -> ByteString
        iterate,                -- :: (Word8 -> Word8) -> Word8 -> ByteString

        -- ** Unfolding ByteStrings
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int64 -> ByteString -> ByteString
        drop,                   -- :: Int64 -> ByteString -> ByteString
        splitAt,                -- :: Int64 -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
--        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
--        isSubstringOf,          -- :: ByteString -> ByteString -> Bool
--        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
--        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int64 -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int64
        elemIndices,            -- :: Word8 -> ByteString -> [Int64]
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int64
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int64]
        count,                  -- :: Word8 -> ByteString -> Int64

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
--        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString
--        defrag,                -- :: ByteString -> ByteString

        -- * I\/O with 'ByteString's

        -- ** Standard input and output
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()

  ) where

import Prelude hiding
    (reverse,head,tail,last,init,null,length,map,lines,foldl,foldr,unlines
    ,concat,any,take,drop,splitAt,takeWhile,dropWhile,span,break,elem,filter,maximum
    ,minimum,all,concatMap,foldl1,foldr1,scanl, scanl1, scanr, scanr1
    ,repeat, cycle, interact, iterate,readFile,writeFile,appendFile,replicate
    ,getContents,getLine,putStr,putStrLn ,zip,zipWith,unzip,notElem)

import qualified Data.List              as L  -- L for list/lazy
import qualified Data.ByteString        as P  (ByteString) -- type name only
import qualified Data.ByteString        as S  -- S for strict (hmm...)
import qualified Data.ByteString.Internal as S
import qualified Data.ByteString.Unsafe as S
import Data.ByteString.Lazy.Internal

import Data.Monoid              (Monoid(..))

import Data.Word                (Word8)
import Data.Int                 (Int64)
import System.IO                (Handle,stdin,stdout,openBinaryFile,IOMode(..)
                                ,hClose)
import System.IO.Error          (mkIOError, illegalOperationErrorType)
import System.IO.Unsafe
#ifndef __NHC__
import Control.Exception        (bracket)
#else
import IO               (bracket)
#endif

import Foreign.ForeignPtr       (withForeignPtr)
import Foreign.Ptr
import Foreign.Storable

-- -----------------------------------------------------------------------------
--
-- Useful macros, until we have bang patterns
--

#define STRICT1(f) f a | a `seq` False = undefined
#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined
#define STRICT5(f) f a b c d e | a `seq` b `seq` c `seq` d `seq` e `seq` False = undefined

-- -----------------------------------------------------------------------------
-- Introducing and eliminating 'ByteString's

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = Empty
{-# INLINE empty #-}

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton w = Chunk (S.singleton w) Empty
{-# INLINE singleton #-}

-- | /O(n)/ Convert a '[Word8]' into a 'ByteString'.
pack :: [Word8] -> ByteString
pack = packBytes

-- | /O(n)/ Converts a 'ByteString' to a '[Word8]'.
unpack :: ByteString -> [Word8]
unpack = unpackBytes

-- | /O(c)/ Convert a list of strict 'ByteString' into a lazy 'ByteString'
fromChunks :: [P.ByteString] -> ByteString
fromChunks cs = L.foldr chunk Empty cs

-- | /O(c)/ Convert a lazy 'ByteString' into a list of strict 'ByteString'
toChunks :: ByteString -> [P.ByteString]
toChunks cs = foldrChunks (:) [] cs

-- |/O(1)/ Convert a strict 'ByteString' into a lazy 'ByteString'.
fromStrict :: P.ByteString -> ByteString
fromStrict bs | S.null bs = Empty
              | otherwise = Chunk bs Empty

-- |/O(n)/ Convert a lazy 'ByteString' into a strict 'ByteString'.
--
-- Note that this is an /expensive/ operation that forces the whole lazy
-- ByteString into memory and then copies all the data. If possible, try to
-- avoid converting back and forth between strict and lazy bytestrings.
--
toStrict :: ByteString -> S.ByteString
toStrict Empty           = S.empty
toStrict (Chunk c Empty) = c
toStrict cs0 = S.unsafeCreate totalLen $ \ptr -> go cs0 ptr
  where
    totalLen = checkedSum "Lazy.toStrict" . L.map S.length . toChunks $ cs0

    go Empty                        !_       = return ()
    go (Chunk (S.PS fp off len) cs) !destptr =
      withForeignPtr fp $ \p -> do
        S.memcpy destptr (p `plusPtr` off) len
        go cs (destptr `plusPtr` len)

-- just here in 0.10.4.x, in later version it's exported from .Internal
checkedSum :: String -> [Int] -> Int
checkedSum fun = go 0
  where go !a (x:xs)
            | ax >= 0   = go ax xs
            | otherwise = overflowError fun
          where ax = a + x
        go a  _         = a

overflowError :: String -> a
overflowError fun = error $ "Data.ByteString." ++ fun ++ ": size overflow"

------------------------------------------------------------------------

{-
-- | /O(n)/ Convert a '[a]' into a 'ByteString' using some
-- conversion function
packWith :: (a -> Word8) -> [a] -> ByteString
packWith k str = LPS $ L.map (P.packWith k) (chunk defaultChunkSize str)
{-# INLINE packWith #-}
{-# SPECIALIZE packWith :: (Char -> Word8) -> [Char] -> ByteString #-}

-- | /O(n)/ Converts a 'ByteString' to a '[a]', using a conversion function.
unpackWith :: (Word8 -> a) -> ByteString -> [a]
unpackWith k (LPS ss) = L.concatMap (S.unpackWith k) ss
{-# INLINE unpackWith #-}
{-# SPECIALIZE unpackWith :: (Word8 -> Char) -> ByteString -> [Char] #-}
-}

-- ---------------------------------------------------------------------
-- Basic interface

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null Empty = True
null _     = False
{-# INLINE null #-}

-- | /O(n\/c)/ 'length' returns the length of a ByteString as an 'Int64'
length :: ByteString -> Int64
length cs = foldlChunks (\n c -> n + fromIntegral (S.length c)) 0 cs
{-# INLINE length #-}

infixr 5 `cons`, `cons'` --same as list (:)
infixl 5 `snoc`

-- | /O(1)/ 'cons' is analogous to '(:)' for lists.
--
cons :: Word8 -> ByteString -> ByteString
cons c cs = Chunk (S.singleton c) cs
{-# INLINE cons #-}

-- | /O(1)/ Unlike 'cons', 'cons\'' is
-- strict in the ByteString that we are consing onto. More precisely, it forces
-- the head and the first chunk. It does this because, for space efficiency, it
-- may coalesce the new byte onto the first \'chunk\' rather than starting a
-- new \'chunk\'.
--
-- So that means you can't use a lazy recursive contruction like this:
--
-- > let xs = cons\' c xs in xs
--
-- You can however use 'cons', as well as 'repeat' and 'cycle', to build
-- infinite lazy ByteStrings.
--
cons' :: Word8 -> ByteString -> ByteString
cons' w (Chunk c cs) | S.length c < 16 = Chunk (S.cons w c) cs
cons' w cs                             = Chunk (S.singleton w) cs
{-# INLINE cons' #-}

-- | /O(n\/c)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc cs w = foldrChunks Chunk (singleton w) cs
{-# INLINE snoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Word8
head Empty       = errorEmptyList "head"
head (Chunk c _) = S.unsafeHead c
{-# INLINE head #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)
uncons Empty = Nothing
uncons (Chunk c cs)
    = Just (S.unsafeHead c,
            if S.length c == 1 then cs else Chunk (S.unsafeTail c) cs)
{-# INLINE uncons #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be
-- non-empty.
tail :: ByteString -> ByteString
tail Empty          = errorEmptyList "tail"
tail (Chunk c cs)
  | S.length c == 1 = cs
  | otherwise       = Chunk (S.unsafeTail c) cs
{-# INLINE tail #-}

-- | /O(n\/c)/ Extract the last element of a ByteString, which must be finite
-- and non-empty.
last :: ByteString -> Word8
last Empty          = errorEmptyList "last"
last (Chunk c0 cs0) = go c0 cs0
  where go c Empty        = S.unsafeLast c
        go _ (Chunk c cs) = go c cs
-- XXX Don't inline this. Something breaks with 6.8.2 (haven't investigated yet)

-- | /O(n\/c)/ Return all the elements of a 'ByteString' except the last one.
init :: ByteString -> ByteString
init Empty          = errorEmptyList "init"
init (Chunk c0 cs0) = go c0 cs0
  where go c Empty | S.length c == 1 = Empty
                   | otherwise       = Chunk (S.unsafeInit c) Empty
        go c (Chunk c' cs)           = Chunk c (go c' cs)

-- | /O(n\/c)/ Extract the 'init' and 'last' of a ByteString, returning Nothing
-- if it is empty.
--
-- * It is no faster than using 'init' and 'last'
unsnoc :: ByteString -> Maybe (ByteString, Word8)
unsnoc Empty        = Nothing
unsnoc (Chunk c cs) = Just (init (Chunk c cs), last (Chunk c cs))

-- | /O(n\/c)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append = mappend
{-# INLINE append #-}

-- ---------------------------------------------------------------------
-- Transformations

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@.
map :: (Word8 -> Word8) -> ByteString -> ByteString
map f s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = Chunk y ys
            where
                y  = S.map f x
                ys = go xs
{-# INLINE map #-}

-- | /O(n)/ 'reverse' @xs@ returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse cs0 = rev Empty cs0
  where rev a Empty        = a
        rev a (Chunk c cs) = rev (Chunk (S.reverse c) a) cs
{-# INLINE reverse #-}

-- | The 'intersperse' function takes a 'Word8' and a 'ByteString' and
-- \`intersperses\' that byte between the elements of the 'ByteString'.
-- It is analogous to the intersperse function on Lists.
intersperse :: Word8 -> ByteString -> ByteString
intersperse _ Empty        = Empty
intersperse w (Chunk c cs) = Chunk (S.intersperse w c)
                                   (foldrChunks (Chunk . intersperse') Empty cs)
  where intersperse' :: P.ByteString -> P.ByteString
        intersperse' (S.PS fp o l) =
          S.unsafeCreate (2*l) $ \p' -> withForeignPtr fp $ \p -> do
            poke p' w
            S.c_intersperse (p' `plusPtr` 1) (p `plusPtr` o) (fromIntegral l) w

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose css = L.map (\ss -> Chunk (S.pack ss) Empty)
                      (L.transpose (L.map unpack css))
--TODO: make this fast

-- ---------------------------------------------------------------------
-- Reducing 'ByteString's

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl f z = go z
  where go a Empty        = a
        go a (Chunk c cs) = go (S.foldl f a c) cs
{-# INLINE foldl #-}

-- | 'foldl\'' is like 'foldl', but strict in the accumulator.
foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' f z = go z
  where go a _ | a `seq` False = undefined
        go a Empty        = a
        go a (Chunk c cs) = go (S.foldl' f a c) cs
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a ByteString,
-- reduces the ByteString using the binary operator, from right to left.
foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr k z cs = foldrChunks (flip (S.foldr k)) z cs
{-# INLINE foldr #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 _ Empty        = errorEmptyList "foldl1"
foldl1 f (Chunk c cs) = foldl f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldl1\'' is like 'foldl1', but strict in the accumulator.
foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' _ Empty        = errorEmptyList "foldl1'"
foldl1' f (Chunk c cs) = foldl' f (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 _ Empty          = errorEmptyList "foldr1"
foldr1 f (Chunk c0 cs0) = go c0 cs0
  where go c Empty         = S.foldr1 f c
        go c (Chunk c' cs) = S.foldr  f (go c' cs) c

-- ---------------------------------------------------------------------
-- Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat = mconcat

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap _ Empty        = Empty
concatMap f (Chunk c0 cs0) = to c0 cs0
  where
    go :: ByteString -> P.ByteString -> ByteString -> ByteString
    go Empty        c' cs' = to c' cs'
    go (Chunk c cs) c' cs' = Chunk c (go cs c' cs')

    to :: P.ByteString -> ByteString -> ByteString
    to c cs | S.null c  = case cs of
        Empty          -> Empty
        (Chunk c' cs') -> to c' cs'
            | otherwise = go (f (S.unsafeHead c)) (S.unsafeTail c) cs

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any f cs = foldrChunks (\c rest -> S.any f c || rest) False cs
{-# INLINE any #-}
-- todo fuse

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all f cs = foldrChunks (\c rest -> S.all f c && rest) True cs
{-# INLINE all #-}
-- todo fuse

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Word8
maximum Empty        = errorEmptyList "maximum"
maximum (Chunk c cs) = foldlChunks (\n c' -> n `max` S.maximum c')
                                   (S.maximum c) cs
{-# INLINE maximum #-}

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Word8
minimum Empty        = errorEmptyList "minimum"
minimum (Chunk c cs) = foldlChunks (\n c' -> n `min` S.minimum c')
                                     (S.minimum c) cs
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s',  c')  = S.mapAccumL f s c
              (s'', cs') = go s' cs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f s0 cs0 = go s0 cs0
  where
    go s Empty        = (s, Empty)
    go s (Chunk c cs) = (s'', Chunk c' cs')
        where (s'', c') = S.mapAccumR f s' c
              (s', cs') = go s cs

-- ---------------------------------------------------------------------
-- Building ByteStrings

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl f z = snd . foldl k (z,singleton z)
 where
    k (c,acc) a = let n = f c a in (n, acc `snoc` n)
{-# INLINE scanl #-}

-- ---------------------------------------------------------------------
-- Unfolds and replicates

-- | @'iterate' f x@ returns an infinite ByteString of repeated applications
-- of @f@ to @x@:
--
-- > iterate f x == [x, f x, f (f x), ...]
--
iterate :: (Word8 -> Word8) -> Word8 -> ByteString
iterate f = unfoldr (\x -> case f x of x' -> x' `seq` Just (x', x'))

-- | @'repeat' x@ is an infinite ByteString, with @x@ the value of every
-- element.
--
repeat :: Word8 -> ByteString
repeat w = cs where cs = Chunk (S.replicate smallChunkSize w) cs

-- | /O(n)/ @'replicate' n x@ is a ByteString of length @n@ with @x@
-- the value of every element.
--
replicate :: Int64 -> Word8 -> ByteString
replicate n w
    | n <= 0             = Empty
    | n < fromIntegral smallChunkSize = Chunk (S.replicate (fromIntegral n) w) Empty
    | r == 0             = cs -- preserve invariant
    | otherwise          = Chunk (S.unsafeTake (fromIntegral r) c) cs
 where
    c      = S.replicate smallChunkSize w
    cs     = nChunks q
    (q, r) = quotRem n (fromIntegral smallChunkSize)
    nChunks 0 = Empty
    nChunks m = Chunk c (nChunks (m-1))

-- | 'cycle' ties a finite ByteString into a circular one, or equivalently,
-- the infinite repetition of the original ByteString.
--
cycle :: ByteString -> ByteString
cycle Empty = errorEmptyList "cycle"
cycle cs    = cs' where cs' = foldrChunks Chunk cs' cs

-- | /O(n)/ The 'unfoldr' function is analogous to the List \'unfoldr\'.
-- 'unfoldr' builds a ByteString from a seed value.  The function takes
-- the element and returns 'Nothing' if it is done producing the
-- ByteString or returns 'Just' @(a,b)@, in which case, @a@ is a
-- prepending to the ByteString and @b@ is used as the next element in a
-- recursive call.
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr f s0 = unfoldChunk 32 s0
  where unfoldChunk n s =
          case S.unfoldrN n f s of
            (c, Nothing)
              | S.null c  -> Empty
              | otherwise -> Chunk c Empty
            (c, Just s')  -> Chunk c (unfoldChunk (n*2) s')

-- ---------------------------------------------------------------------
-- Substrings

-- | /O(n\/c)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int64 -> ByteString -> ByteString
take i _ | i <= 0 = Empty
take i cs0         = take' i cs0
  where take' 0 _            = Empty
        take' _ Empty        = Empty
        take' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.take (fromIntegral n) c) Empty
            else Chunk c (take' (n - fromIntegral (S.length c)) cs)

-- | /O(n\/c)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int64 -> ByteString -> ByteString
drop i p | i <= 0 = p
drop i cs0 = drop' i cs0
  where drop' 0 cs           = cs
        drop' _ Empty        = Empty
        drop' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then Chunk (S.drop (fromIntegral n) c) cs
            else drop' (n - fromIntegral (S.length c)) cs

-- | /O(n\/c)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
splitAt i cs0 | i <= 0 = (Empty, cs0)
splitAt i cs0 = splitAt' i cs0
  where splitAt' 0 cs           = (Empty, cs)
        splitAt' _ Empty        = (Empty, Empty)
        splitAt' n (Chunk c cs) =
          if n < fromIntegral (S.length c)
            then (Chunk (S.take (fromIntegral n) c) Empty
                 ,Chunk (S.drop (fromIntegral n) c) cs)
            else let (cs', cs'') = splitAt' (n - fromIntegral (S.length c)) cs
                   in (Chunk c cs', cs'')


-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f cs0 = takeWhile' cs0
  where takeWhile' Empty        = Empty
        takeWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            0                  -> Empty
            n | n < S.length c -> Chunk (S.take n c) Empty
              | otherwise      -> Chunk c (takeWhile' cs)

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f cs0 = dropWhile' cs0
  where dropWhile' Empty        = Empty
        dropWhile' (Chunk c cs) =
          case findIndexOrEnd (not . f) c of
            n | n < S.length c -> Chunk (S.drop n c) cs
              | otherwise      -> dropWhile' cs

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break f cs0 = break' cs0
  where break' Empty        = (Empty, Empty)
        break' (Chunk c cs) =
          case findIndexOrEnd f c of
            0                  -> (Empty, Chunk c cs)
            n | n < S.length c -> (Chunk (S.take n c) Empty
                                  ,Chunk (S.drop n c) cs)
              | otherwise      -> let (cs', cs'') = break' cs
                                   in (Chunk c cs', cs'')

--
-- TODO
--
-- Add rules
--

{-
-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte c (LPS ps) = case (breakByte' ps) of (a,b) -> (LPS a, LPS b)
  where breakByte' []     = ([], [])
        breakByte' (x:xs) =
          case P.elemIndex c x of
            Just 0  -> ([], x : xs)
            Just n  -> (P.take n x : [], P.drop n x : xs)
            Nothing -> let (xs', xs'') = breakByte' xs
                        in (x : xs', xs'')

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c (LPS ps) = case (spanByte' ps) of (a,b) -> (LPS a, LPS b)
  where spanByte' []     = ([], [])
        spanByte' (x:xs) =
          case P.spanByte c x of
            (x', x'') | P.null x'  -> ([], x : xs)
                      | P.null x'' -> let (xs', xs'') = spanByte' xs
                                       in (x : xs', xs'')
                      | otherwise  -> (x' : [], x'' : xs)
-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span p = break (not . p)

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith _ Empty          = []
splitWith p (Chunk c0 cs0) = comb [] (S.splitWith p c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.splitWith p c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs

{-# INLINE splitWith #-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split _ Empty     = []
split w (Chunk c0 cs0) = comb [] (S.split w c0) cs0

  where comb :: [P.ByteString] -> [P.ByteString] -> ByteString -> [ByteString]
        comb acc (s:[]) Empty        = revChunks (s:acc) : []
        comb acc (s:[]) (Chunk c cs) = comb (s:acc) (S.split w c) cs
        comb acc (s:ss) cs           = revChunks (s:acc) : comb [] ss cs
{-# INLINE split #-}

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Word8 -> Bool) -> ByteString -> [ByteString]
tokens f = L.filter (not.null) . splitWith f
-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test.
group :: ByteString -> [ByteString]
group = go
  where
    go Empty        = []
    go (Chunk c cs)
      | S.length c == 1  = to [c] (S.unsafeHead c) cs
      | otherwise        = to [S.unsafeTake 1 c] (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

    to acc !_ Empty        = revNonEmptyChunks acc : []
    to acc !w (Chunk c cs) =
      case findIndexOrEnd (/= w) c of
        0                    -> revNonEmptyChunks acc
                              : go (Chunk c cs)
        n | n == S.length c  -> to (S.unsafeTake n c : acc) w cs
          | otherwise        -> revNonEmptyChunks (S.unsafeTake n c : acc)
                              : go (Chunk (S.unsafeDrop n c) cs)

-- | The 'groupBy' function is the non-overloaded version of 'group'.
--
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy k = go
  where
    go Empty        = []
    go (Chunk c cs)
      | S.length c == 1  = to [c] (S.unsafeHead c) cs
      | otherwise        = to [S.unsafeTake 1 c] (S.unsafeHead c) (Chunk (S.unsafeTail c) cs)

    to acc !_ Empty        = revNonEmptyChunks acc : []
    to acc !w (Chunk c cs) =
      case findIndexOrEnd (not . k w) c of
        0                    -> revNonEmptyChunks acc
                              : go (Chunk c cs)
        n | n == S.length c  -> to (S.unsafeTake n c : acc) w cs
          | otherwise        -> revNonEmptyChunks (S.unsafeTake n c : acc)
                              : go (Chunk (S.unsafeDrop n c) cs)

-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString
intercalate s = concat . (L.intersperse s)

-- ---------------------------------------------------------------------
-- Indexing ByteStrings

-- | /O(c)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int64 -> Word8
index _  i | i < 0  = moduleError "index" ("negative index: " ++ show i)
index cs0 i         = index' cs0 i
  where index' Empty     n = moduleError "index" ("index too large: " ++ show n)
        index' (Chunk c cs) n
          | n >= fromIntegral (S.length c) =
              index' cs (n - fromIntegral (S.length c))
          | otherwise       = S.unsafeIndex c (fromIntegral n)

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element.
-- This implementation uses memchr(3).
elemIndex :: Word8 -> ByteString -> Maybe Int64
elemIndex w cs0 = elemIndex' 0 cs0
  where elemIndex' _ Empty        = Nothing
        elemIndex' n (Chunk c cs) =
          case S.elemIndex w c of
            Nothing -> elemIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)

{-
-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd ch (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p ->
    go (p `plusPtr` s) (l-1)
  where
    go a b | a `seq` b `seq` False = undefined
    go p i | i < 0     = return Nothing
           | otherwise = do ch' <- peekByteOff p i
                            if ch == ch'
                                then return $ Just i
                                else go p (i-1)
-}
-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int64]
elemIndices w cs0 = elemIndices' 0 cs0
  where elemIndices' _ Empty        = []
        elemIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.elemIndices w c)
                             ++ elemIndices' (n + fromIntegral (S.length c)) cs

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int64
count w cs = foldlChunks (\n c -> n + fromIntegral (S.count w c)) 0 cs

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int64
findIndex k cs0 = findIndex' 0 cs0
  where findIndex' _ Empty        = Nothing
        findIndex' n (Chunk c cs) =
          case S.findIndex k c of
            Nothing -> findIndex' (n + fromIntegral (S.length c)) cs
            Just i  -> Just (n + fromIntegral i)
{-# INLINE findIndex #-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find f cs0 = find' cs0
  where find' Empty        = Nothing
        find' (Chunk c cs) = case S.find f c of
            Nothing -> find' cs
            Just w  -> Just w
{-# INLINE find #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int64]
findIndices k cs0 = findIndices' 0 cs0
  where findIndices' _ Empty        = []
        findIndices' n (Chunk c cs) = L.map ((+n).fromIntegral) (S.findIndices k c)
                             ++ findIndices' (n + fromIntegral (S.length c)) cs

-- ---------------------------------------------------------------------
-- Searching ByteStrings

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem w cs = case elemIndex w cs of Nothing -> False ; _ -> True

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem w cs = not (elem w cs)

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Word8 -> Bool) -> ByteString -> ByteString
filter p s = go s
    where
        go Empty        = Empty
        go (Chunk x xs) = chunk (S.filter p x) (go xs)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single byte. It is more
-- efficient to use /filterByte/ in this case.
--
-- > filterByte == filter . (==)
--
-- filterByte is around 10x faster, and uses much less space, than its
-- filter equivalent
filterByte :: Word8 -> ByteString -> ByteString
filterByte w ps = replicate (count w ps) w
{-# INLINE filterByte #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
  filter ((==) x) = filterByte x

"ByteString specialise filter (== x)" forall x.
 filter (== x) = filterByte x
  #-}
-}
{-
-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single byte out of a list. It is more efficient
-- to use /filterNotByte/ in this case.
--
-- > filterNotByte == filter . (/=)
--
-- filterNotByte is around 2x faster than its filter equivalent.
filterNotByte :: Word8 -> ByteString -> ByteString
filterNotByte w (LPS xs) = LPS (filterMap (P.filterNotByte w) xs)
-}
-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- the pair of ByteStrings with elements which do and do not satisfy the-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- predicate, respectively; i.e.,-- the pair of ByteStrings with elements which do and do not satisfy the
---- predicate, respectively; i.e.,
---- > partition p bs == (filter p xs, filter (not . p) xs)
---- > partition p bs == (filter p xs, filter (not . p) xs)
--partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition ::f p(Word8= (filter-> Boolf p) ->filter(not . ->f) (ByteString)         , ByteString)
partition--TODO: use a better implementation p = (filter f p, filter (not . f) p)
--TODO: use a better implementation
-- ---------------------------------------------------------------------
-- Searching for substrings-- ---------------------------------------------------------------------
-- Searching for substrings
-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
isPrefixOf-- iff the first is a prefix of the second.:: ByteString -> ByteString -> Bool
isPrefixOf ::Empty_  = True-> ByteString -> Bool
isPrefixOf Empty_ Empty  = TrueFalse
isPrefixOf _Chunkx =xsFalse) (Chunk y ys)
isPrefixOf| S.lengthChunkx == xsS.length) (Chunky y ysx )== y  && isPrefixOf xs ys
    | S.length x ==<  S.length y = x == yyh && isPrefixOf xs ys(Chunk yt ys)
    | S.lengthotherwisex <  S.length y = xxh====yhy && isPrefixOf xs(ChunkChunkxt yt)ysys)
  where otherwise(xh,xt) = S.splitAt (S.length= xh ==yy &&x  isPrefixOf (Chunk xt xs) ys
  where (xh,xt) = S.splitAt (S.length y) x
        (yh,yt) = S.splitAt (S.length x) y
-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
---- iff the first is a suffix of the second.
---- The following holds:
---- The following holds:
---- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
---- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf ::x yByteString= reverse ->x `ByteString`->reverse  y
isSuffixOf--TODO: a better implementation y = reverse x `isPrefixOf` reverse y
--TODO: a better implementation
-- ---------------------------------------------------------------------
-- Zipping-- ---------------------------------------------------------------------
-- Zipping
-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of-- corresponding pairs of bytes. If one input ByteString is short,
-- corresponding pairs of bytes. If one input ByteString is short,
-- equivalent to a pair of 'unpack' operations.-- excess elements of the longer ByteString are discarded. This is
zip-- equivalent to a pair of 'unpack' operations.:: ByteString -> ByteString -> [(Word8,Word8)]
zip ::= zipWith(,) -> ByteString -> [(Word8,Word8)]
zip = zipWith (,)
-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
zipWith-- corresponding sums.:: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith ::_ EmptyWord8 ->_Word8= []-> a) -> ByteString -> ByteString -> [a]
zipWith _ Empty_      Empty  = []
zipWith _ _Chunk Emptya as) =Chunk]   b bs) = go a as b bs
zipWithwhere f (Chunk a as) (Chunk b bs) = go a as b bs
  wherego x xs y ys = f (S.unsafeHead x) (S.unsafeHead y)
    go x xs y ys = fto(S.unsafeHead(S.unsafeTailx))(S.unsafeHeadxs (S.unsafeTail)  y) ys
                 : to (S.unsafeTail x) xs (S.unsafeTail y) ys
    to x Empty         _ _             | S.null x       = []
    to x Empty_             _ _Empty         | S.null x       = []
    to _ _xs            y Emptyys            | S.nullnot (S.null    x) = []
    to x xs            y ys           && not (S.null x) = go x  xs y  ys
    to x xs            _ (Chunk y' ys)&&| not (S.null y) = go x  xs yy' ys
    to x xs(Chunk x' xs) _ (ysChunk y' ys) | not (S.null x) = go xx' xs y'y  ys
    to _ (Chunk x' xs) y ys(Chunk y' ys) | not (S.null y) = go x' xs yy' ys
    to _ (Chunk x' xs) _ (Chunk y' ys)                  = go x' xs y' ys
-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
unzip-- ByteStrings. Note that this performs two 'pack' operations.:: [(Word8,Word8)] -> (ByteString,ByteString)
unzip :: [(Word8(pack,Word8(L.map)]fst-> (lsByteString), pack (,L.mapByteStringsnd ls)))
unzip{-# INLINE = (unzippack (#-}L.map fst ls), pack (L.map snd ls))
{-# INLINE unzip #-}
-- ---------------------------------------------------------------------
-- Special lists-- ---------------------------------------------------------------------
-- Special lists
-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.:: ByteString -> [ByteString]
inits ::= (ByteStringEmpty :) . ->inits'ByteString]
initswhere= (inits'Empty :Empty) . inits'  = []
  where inits' Empty(Chunk c cs) = [L.map]    (\c' -> Chunk c' Empty) (L.tail (S.inits c))
        inits' (Chunk c cs)++= L.map (\Chunkc' ->cChunk) (inits' Emptycs) ) (L.tail (S.inits c))
                           ++ L.map (Chunk c) (inits' cs)
-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.:: ByteString -> [ByteString]
tails ::Empty ->= EmptyByteString: []  ]
tails Emptycs@(Chunk c cs'=)Empty : []
tails| S.length@(Chunkc == cs'1 =)cs : tails cs'
  | S.lengthotherwisec == 1 = cs : tails cs'(Chunk (S.unsafeTail c) cs')
  | otherwise       = cs : tails (Chunk (S.unsafeTail c) cs')
-- ---------------------------------------------------------------------
-- Low level constructors-- ---------------------------------------------------------------------
-- Low level constructors
-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
--   This is mainly useful to allow the rest of the data pointed
--   to by the 'ByteString' to be garbage collected, for example--   if a large string has been read in, and only a small part of it
--   is needed in the rest of the program.--   if a large string has been read in, and only a small part of it
copy--   is needed in the rest of the program.:: ByteString -> ByteString
copy :: ByteString= foldrChunks-> ByteString(Chunk . S.copy) Empty cs
copy--TODO, we could coalese small blocks here = foldrChunks (Chunk . S.copy) Empty cs
--TODO, we could coalese small blocks here--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.--FIXME: probably not strict enough, if we're doing this to avoid retaining
-- the parent blocks then we'd better copy strictly.
-- ---------------------------------------------------------------------
-- ---------------------------------------------------------------------
-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString-- TODO defrag func that concatenates block together that are below a threshold
-- defrag :: ByteString -> ByteString
-- ---------------------------------------------------------------------
-- Lazy ByteString IO-- ---------------------------------------------------------------------
---- Lazy ByteString IO
---- Rule for when to close: is it expected to read the whole file?
-- If so, close when done.-- Rule for when to close: is it expected to read the whole file?
---- If so, close when done.
--
-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, in at most @k@-sized chunks. It does not block
-- waiting for a whole @k@-sized chunk, so if less than @k@ bytes are-- available then they will be returned immediately as a smaller chunk.
---- available then they will be returned immediately as a smaller chunk.
---- The handle is closed on EOF.
---- The handle is closed on EOF.
---- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to-- Note: the 'Handle' should be placed in binary mode with
-- work correctly.-- 'System.IO.hSetBinaryMode' for 'hGetContentsN' to
---- work correctly.
--hGetContentsN :: Int -> Handle -> IO ByteString
hGetContentsN ::k hInt= lazyRead-> Handle-- TODO close on exceptions-> IO ByteString
hGetContentsNwhere       k h = lazyRead -- TODO close on exceptions
  wherelazyRead = unsafeInterleaveIO loop
    lazyRead = unsafeInterleaveIO loop
    loop = do
    loopc=<-S.hGetSome h k -- only blocks if there is no data available
        cif<-S.nullc     h k -- only blocks if there is no data available
        ifthendo chClose h >> return Empty
          then     do hClosecs <- lazyRead >> return Empty
          else do csreturn<- lazyRead(Chunk c cs)
                  return (Chunk c cs)
-- | Read @n@ bytes into a 'ByteString', directly from the
-- specified 'Handle', in chunks of size @k@.-- | Read @n@ bytes into a 'ByteString', directly from the
---- specified 'Handle', in chunks of size @k@.
--hGetN :: Int -> Handle -> Int -> IO ByteString
hGetN ::k hIntn |->n Handle> 0 = readChunks-> Int -> IOn  ByteString
hGetNwhere h n | n > 0 = readChunks n
  whereSTRICT1(readChunks)
    readChunks a | ado`seq` False = undefined
    readChunksc <- S.hGet = doh (min k i)
        ccase<- S.hGetS.length (minof k i)
        case0S.length-> return ofEmpty
            0 -> returndo cs <-readChunks (i - m)
            m -> do csreturn<- readChunks(Chunk c csi - m)
                    return (Chunk c cs)
hGetN _ _ 0 = return Empty
hGetN _ _ 0 = returnillegalBufferSize      h "hGet" n
hGetN _ h n = illegalBufferSize h "hGet" n
-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
-- waiting for data to become available, instead it returns only whatever data-- | hGetNonBlockingN is similar to 'hGetContentsN', except that it will never block
-- is available. Chunks are read on demand, in @k@-sized chunks.-- waiting for data to become available, instead it returns only whatever data
---- is available. Chunks are read on demand, in @k@-sized chunks.
--hGetNonBlockingN :: Int -> Handle -> Int -> IO ByteString
hGetNonBlockingN#if defined(__GLASGOW_HASKELL__):: Int -> Handle -> Int -> IO ByteString
hGetNonBlockingN k h n | n > 0= readChunks n
hGetNonBlockingNwhere          k h n | n > 0= readChunks n
  whereSTRICT1(readChunks)
    readChunks a | ado`seq` False = undefined
    readChunksc <- S.hGetNonBlocking = do          h (min k i)
        ccase<- S.hGetNonBlockingS.length c of     h (min k i)
        case0S.length-> return ofEmpty
            0 -> returndo cs <-readChunks (i - m)
            m -> do csreturn<- readChunks(Chunk c csi - m)
                    return (Chunk c cs)
hGetNonBlockingN _ _ 0 = return Empty
hGetNonBlockingN _ _ 0 = returnillegalBufferSize      h "hGetNonBlocking" n
hGetNonBlockingN#else             _ h n = illegalBufferSize h "hGetNonBlocking" n
hGetNonBlockingN = hGetN
#endif

illegalBufferSize :: Handle -> String -> Int -> IO a
illegalBufferSize ::handlefn -> String=      -> Int -> IO a
illegalBufferSizeioError (mkIOErrorillegalOperationErrorType sz =                 msg (Just handle) Nothing)
    ioError--TODO: System.IO uses InvalidArgument here, but it's not exported :-(mkIOError illegalOperationErrorType msg (Just handle) Nothing)
    where--TODO: System.IO uses InvalidArgument here, but it's not exported :-(
    wheremsg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
      msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
-- are read on demand, using the default chunk size.-- | Read entire handle contents /lazily/ into a 'ByteString'. Chunks
---- are read on demand, using the default chunk size.
---- Once EOF is encountered, the Handle is closed.
---- Once EOF is encountered, the Handle is closed.
---- Note: the 'Handle' should be placed in binary mode with
-- 'System.IO.hSetBinaryMode' for 'hGetContents' to-- Note: the 'Handle' should be placed in binary mode with
-- work correctly.-- 'System.IO.hSetBinaryMode' for 'hGetContents' to
---- work correctly.
--hGetContents :: Handle -> IO ByteString
hGetContents ::= hGetContentsN -> IO ByteStringdefaultChunkSize
hGetContents = hGetContentsN defaultChunkSize
-- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
---- | Read @n@ bytes into a 'ByteString', directly from the specified 'Handle'.
--hGet :: Handle -> Int -> IO ByteString
hGet ::= hGetNdefaultChunkSize-> Int -> IO ByteString
hGet = hGetN defaultChunkSize
-- | hGetNonBlocking is similar to 'hGet', except that it will never block
-- | hGetNonBlocking is similar to 'hGet', except that it will never block-- waiting for data to become available, instead it returns only whatever data
-- is available.  If there is no data available to be read, 'hGetNonBlocking'-- waiting for data to become available, instead it returns only whatever data
-- returns 'empty'.-- is available.  If there is no data available to be read, 'hGetNonBlocking'
---- returns 'empty'.
---- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hGet'.-- Note: on Windows and with Haskell implementation other than GHC, this
---- function does not work correctly; it behaves identically to 'hGet'.
--#if defined(__GLASGOW_HASKELL__)
hGetNonBlocking :: Handle -> Int -> IO ByteString
hGetNonBlocking ::= hGetNonBlockingN -> Int ->defaultChunkSize ByteString
hGetNonBlocking#else            = hGetNonBlockingN defaultChunkSize
hGetNonBlocking = hGet
#endif

-- | Read an entire file /lazily/ into a 'ByteString'.
-- | Read an entire file /lazily/ into a 'ByteString'.-- The Handle will be held open until EOF is encountered.
---- The Handle will be held open until EOF is encountered.
--readFile :: FilePath -> IO ByteString
readFile ::f =FilePathopenBinaryFile-> IO ByteStringf ReadMode >>= hGetContents
readFile f = openBinaryFile f ReadMode >>= hGetContents
-- | Write a 'ByteString' to a file.
---- | Write a 'ByteString' to a file.
--writeFile :: FilePath -> ByteString -> IO ()
writeFile ::f txt= bracket-> ByteString(openBinaryFile-> IO ()WriteMode) hClose
writeFile(\hdl f->txthPut= brackethdl txt)(openBinaryFile f WriteMode) hClose
    (\hdl -> hPut hdl txt)
-- | Append a 'ByteString' to a file.
---- | Append a 'ByteString' to a file.
--appendFile :: FilePath -> ByteString -> IO ()
appendFile ::f txt= bracket-> ByteString(openBinaryFile-> IO ()AppendMode) hClose
appendFile(\hdl -> txthPut=hdltxt) (openBinaryFile f AppendMode) hClose
    (\hdl -> hPut hdl txt)
-- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
---- | getContents. Equivalent to hGetContents stdin. Will read /lazily/
--getContents :: IO ByteString
getContents ::= hGetContents ByteStringstdin
getContents = hGetContents stdin
-- | Outputs a 'ByteString' to the specified 'Handle'.
---- | Outputs a 'ByteString' to the specified 'Handle'.
--hPut :: Handle -> ByteString -> IO ()
hPut ::h cs= foldrChunks-> ByteString(\c rest-> IO->()S.hPut h c >> rest) (return ()) cs
hPut h cs = foldrChunks (\c rest -> S.hPut h c >> rest) (return ()) cs
-- | Similar to 'hPut' except that it will never block. Instead it returns
-- | Similar to 'hPut' except that it will never block. Instead it returns-- any tail that did not get written. This tail may be 'empty' in the case that
-- the whole string was written, or the whole original string if nothing was-- any tail that did not get written. This tail may be 'empty' in the case that
-- written. Partial writes are also possible.-- the whole string was written, or the whole original string if nothing was
---- written. Partial writes are also possible.
---- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hPut'.-- Note: on Windows and with Haskell implementation other than GHC, this
---- function does not work correctly; it behaves identically to 'hPut'.
--hPutNonBlocking :: Handle -> ByteString -> IO ByteString
hPutNonBlocking ::_ Empty -> ByteString= return-> IOEmpty
hPutNonBlocking _ Emptybs@(Chunk c cs) = returndo     Empty
hPutNonBlockingc' <- S.hPutNonBlocking bs@(Chunkh c cs) = do
  c'case<-S.lengthc' of     h c
  casel' S.length| l' == S.length of   c -> hPutNonBlocking h cs
    l'0  | l' == S.length c -> hPutNonBlockingreturn bs       h cs
    0                     -> return bs(Chunk c' cs)
    _                     -> return (Chunk c' cs)
-- | A synonym for @hPut@, for compatibility
---- | A synonym for @hPut@, for compatibility
--hPutStr :: Handle -> ByteString -> IO ()
hPutStr ::= hPut -> ByteString -> IO ()
hPutStr = hPut
-- | Write a ByteString to stdout
putStr-- | Write a ByteString to stdout:: ByteString -> IO ()
putStr ::= hPutstdout -> IO ()
putStr = hPut stdout
-- | Write a ByteString to stdout, appending a newline byte
---- | Write a ByteString to stdout, appending a newline byte
--putStrLn :: ByteString -> IO ()
putStrLn :: ByteString= hPut stdout-> IO (>>) hPut stdout (singleton 0x0a)
putStrLn ps = hPut stdout ps >> hPut stdout (singleton 0x0a)
{-# DEPRECATED putStrLn
{-# DEPRECATED"Use Data.ByteString.Lazy.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.ByteString.Lazy.Char8)"
  #-}
  #-}
-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- | The interact function takes a function of type @ByteString -> ByteString@
-- standard output device.-- as its argument. The entire input from the standard input device is passed
---- to this function as its argument, and the resulting string is output on the
interact-- standard output device.:: (ByteString -> ByteString) -> IO ()
--interact transformer = putStr . transformer =<< getContents
interact :: (ByteString -> ByteString) -> IO ()
interact-- --------------------------------------------------------------------- = putStr . transformer =<< getContents
-- Internal utilities
-- ---------------------------------------------------------------------
-- Internal utilities-- Common up near identical calls to `error' to reduce the number
-- constant strings created when compiled:
errorEmptyList-- Common up near identical calls to `error' to reduce the number:: String -> a
errorEmptyList-- constant strings created when compiled:fun = moduleError fun "empty ByteString"
errorEmptyList{-# NOINLINE errorEmptyList:: String -> a#-}
errorEmptyList fun = moduleError fun "empty ByteString"
{-# NOINLINEmoduleError ::String -> String#-} -> a
moduleError fun msg = error ("Data.ByteString.Lazy." ++ fun ++ ':':' ':msg)
moduleError{-# NOINLINE::moduleError -> String#-}    -> a
moduleError fun msg = error ("Data.ByteString.Lazy." ++ fun ++ ':':' ':msg)
{-# NOINLINE moduleError #-}
-- reverse a list of non-empty chunks into a lazy ByteString
revNonEmptyChunks :: [P.ByteString] -> ByteString
revNonEmptyChunks-- reverse a list of non-empty chunks into a lazy ByteStringcs = L.foldl' (flip Chunk) Empty cs
revNonEmptyChunks :: [P.ByteString] -> ByteString
revNonEmptyChunks-- reverse a list of possibly-empty chunks into a lazy ByteString = L.foldl' (flip Chunk) Empty cs
revChunks :: [P.ByteString] -> ByteString
revChunks-- reverse a list of possibly-empty chunks into a lazy ByteStringcs = L.foldl' (flip chunk) Empty cs
revChunks :: [P.ByteString] -> ByteString
revChunks-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length = L.foldl' (flip chunk) Empty cs
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length:: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEnd-- of the string if no element is found, rather than Nothing.k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
findIndexOrEndwhere        :: (Word8 -> Bool) -> P.ByteString -> Int
findIndexOrEndSTRICT2(go)k (S.PS x s l) = S.inlinePerformIO $ withForeignPtr x $ \f -> go (f `plusPtr` s) 0
  wherego ptr n | n >= l    = return l
    go a b | a `otherwiseseq` b `seq= `doFalsew <- =peekptr
    go ptr n | n >= l    = returnif klw
             | otherwise = do w <-thenreturn n
                              ifelse w go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}   then return n
                                else go (ptr `plusPtr` 1) (n+1)
{-# INLINE findIndexOrEnd #-}

</pre>