<a href="FilePath.hs16683066481683337704.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Filter.hs12778441887638.out.html">next</a></br></br><pre>8d7
<   ( FSConf(..)
9d7
<   , FSBackend(..)
10c8
<   , runFSBackend
---
> module( FSConfNetwork.FTP.Backend.FileSystem(..)
10a9
>   ( FSConfFSBackend(..)..)
10a10
>   , FSBackendrunFSBackend(..)
10a11
>   , runFSBackendwhere
12d12
< 
16d15
< 
18d16
< import BasicPrelude
19c17
< import System.Directory
---
> import qualifiedBasicPreludePrelude
19a18
> import BasicPreludeSystem.Directory
19a19
> import System.DirectoryFilesystem.Path.CurrentOS
21d20
< 
23c22
< import Control.Monad.Trans.Control
---
> import Control.Monad.Trans.ReaderControl.Monad.Trans.Control
23a23
> import Control.Monad.Trans.ControlControl.Monad.Base
25d24
< 
27d25
< import Data.Conduit
28d25
< import qualified Data.Conduit.List as C
29c26
< import qualified Data.Conduit.Binary as C
---
> import qualifiedData.ConduitData.ByteString.Char8 as S
29a27
> import Data.Conduitqualified Data.Conduit.List as C
29a28
> import qualified Data.Conduit.ListData.Conduit.BinaryasasC C
29a29
> import qualified Data.Conduit.BinaryData.Conduit.ProcessasasCC
31d30
< 
32a32
> import Network.FTP.UtilsNetwork.FTP.BackenddropHeadingPathSeparator(FTPBackend(..))       )
34d33
< 
35a35
> data{ fsBase::= FSConfFilePath
38d37
< 
40c39
<     deriving ( Functor, Applicative, Monad, MonadIO
---
> newtypederiving( Functor = FSBackend, Applicative unFSBackend, Monad, MonadIO:: ReaderT FSConf (ResourceT IO) a }
40a40
>     deriving ( FunctorMonadUnsafeIO, Applicative, MonadThrow, Monad, ,MonadResource
43d42
< 
44a44
> instanceliftBase= FSBackend FSBackend. liftBasewhere
46d45
< 
48d46
<     newtype StM FSBackend a = FSBackendStM { unFSBackendStM :: StM (ReaderT FSConf (ResourceT IO)) a }
49c47
<     liftBaseWith f = FSBackend . liftBaseWith $ \runInBase -> f $ liftM FSBackendStM . runInBase . unFSBackend
---
> instancenewtypeStM FSBackend IOa =FSBackendFSBackendStMwhere{ unFSBackendStM :: StM (ReaderT FSConf (ResourceT IO)) a }
49a48
>     newtypeliftBaseWith FSBackendf = FSBackend = FSBackendStM. liftBaseWith unFSBackendStM$ \runInBase ->::fStM$ liftMReaderTFSBackendStM (ResourceT. runInBase)) aunFSBackend}
49a49
>     liftBaseWithrestoreM = FSBackend = FSBackend. restoreM liftBaseWith. unFSBackendStM \runInBase -> f $ liftM FSBackendStM . runInBase . unFSBackend
51d50
< 
52a52
> runFSBackend :: FSConfm = runResourceT-> FSBackend$ runReaderT -> IO a (unFSBackend m) st
54d53
< 
56d54
< makeAbsolute path = do
57c55
<     b <- FSBackend (asks fsBase)
---
> makeAbsolute ::path= do   -> FSBackend FilePath
57a56
> makeAbsoluteb <- FSBackend =(doasks fsBase)
57a57
>     breturn<- FSBackend$ b </> (dropHeadingPathSeparatorasks fsBase)            path
59d58
< 
60a60
> instancetype FTPBackendUserId FSBackend= ByteStringwhere
62d61
< 
64c63
< 
---
>     ftplog = liftIO . S.putStrLn
66d64
<         if user==pass
67c65
<           then return (Just user)
---
>     authenticateif user==user pass =
67a66
>         ifthen==returnpass (Just user)
67a67
>           then return (NothingJust user)
69d68
< 
71c70
<         dir' <- lift (makeAbsolute dir)
---
>     listdir' =<-dolift (makeAbsolute dir)
71a71
>         dir'C.sourceCmd<- lift$(makeAbsolute"ls -l " ++ encodeString)        dir'
73d72
< 
75d73
<         dir'  <- lift (makeAbsolute dir)
76c74
<         paths <- liftIO $ getDirectoryContents (encodeString dir')
---
>     nlstdir' =<-lift (makeAbsolute dir)
76a75
>         dir'paths <- liftliftIOmakeAbsolute$ getDirectoryContents)       (encodeString dir')
76a76
>         pathsC.sourceList<- liftIO$ map getDirectoryContents(S.pack . (++"\n")) (pathsencodeString dir')
78d77
< 
79a79
>     mkd dirmakeAbsolute=        dir >>= liftIO . createDirectory . encodeString
81d80
< 
82a82
>     delemakeAbsolute =      name >>= liftIO . removeFile . encodeString
84d83
< 
85a85
>     renamefname'<-tnamemakeAbsolute= do    fname
87c87
<         tname' <- makeAbsolute tname
---
>         tname' <-$ renameFile(encodeString      fname') (encodeString tname')
89d88
< 
91c90
<         dir' <- makeAbsolute dir
---
>     rmd dirdir'=<-makeAbsolute dir
91a91
>         dir'liftIO<-$makeAbsoluteremoveDirectory (encodeString dir')
93d92
< 
94a94
>     downloadlift name(makeAbsolute=        name) >>= C.sourceFile . encodeString
96d95
< 
97a97
>     uploadlift name(makeAbsolute=        name) >>= C.sinkFile . encodeString
98a99
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE GeneralizedNewtypeDeriving
           , OverloadedStrings
           , TypeFamilies
           , MultiParamTypeClasses
           , CPP
           #-}
module Network.FTP.Backend.FileSystem
  ( FSConf(..)
  , FSBackend(..)
  , runFSBackend
  ) where

{-|
 - Simple file system backend.
 -}

import qualified Prelude
import BasicPrelude
import System.Directory
import Filesystem.Path.CurrentOS

import Control.Monad.Trans.Reader
import Control.Monad.Trans.Control
import Control.Monad.Base

import qualified Data.ByteString.Char8 as S
import Data.Conduit
import qualified Data.Conduit.List as C
import qualified Data.Conduit.Binary as C
import qualified Data.Conduit.Process as C

import Network.FTP.Utils (dropHeadingPathSeparator)
import Network.FTP.Backend (FTPBackend(..))

data FSConf = FSConf
  { fsBase :: FilePath
  }

newtype FSBackend a = FSBackend { unFSBackend :: ReaderT FSConf (ResourceT IO) a }
    deriving ( Functor, Applicative, Monad, MonadIO
             , MonadUnsafeIO, MonadThrow, MonadResource
             )

instance MonadBase IO FSBackend where
    liftBase = FSBackend . liftBase

instance MonadBaseControl IO FSBackend where
    newtype StM FSBackend a = FSBackendStM { unFSBackendStM :: StM (ReaderT FSConf (ResourceT IO)) a }
    liftBaseWith f = FSBackend . liftBaseWith $ \runInBase -> f $ liftM FSBackendStM . runInBase . unFSBackend
    restoreM = FSBackend . restoreM . unFSBackendStM

runFSBackend :: FSConf -> FSBackend a -> IO a
runFSBackend st m = runResourceT $ runReaderT (unFSBackend m) st

makeAbsolute :: FilePath -> FSBackend FilePath
makeAbsolute path = do
    b <- FSBackend (asks fsBase)
    return $ b </> dropHeadingPathSeparator path

instance FTPBackend FSBackend where
    type UserId FSBackend = ByteString

    ftplog = liftIO . S.putStrLn

    authenticate user pass =
        if user==pass
          then return (Just user)
          else return Nothing

    list dir = do
        dir' <- lift (makeAbsolute dir)
        C.sourceCmd $ "ls -l " ++ encodeString dir'

    nlst dir = do
        dir'  <- lift (makeAbsolute dir)
        paths <- liftIO $ getDirectoryContents (encodeString dir')
        C.sourceList $ map (S.pack . (++"\n")) paths

    mkd dir =
        makeAbsolute dir >>= liftIO . createDirectory . encodeString

    dele name =
        makeAbsolute name >>= liftIO . removeFile . encodeString

    rename fname tname = do
        fname' <- makeAbsolute fname
        tname' <- makeAbsolute tname
        liftIO $ renameFile (encodeString fname') (encodeString tname')

    rmd dir = do
        dir' <- makeAbsolute dir
        liftIO $ removeDirectory (encodeString dir')

    download name =
        lift (makeAbsolute name) >>= C.sourceFile . encodeString

    upload   name =
        lift (makeAbsolute name) >>= C.sinkFile . encodeString
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE GeneralizedNewtypeDeriving
           , OverloadedStrings
           , TypeFamilies
           , MultiParamTypeClasses
           , CPP
           #-}
module Network.FTP.Backend.FileSystem
module( FSConfNetwork.FTP.Backend.FileSystem(..)
  ( FSConfFSBackend(..)..)
  , FSBackendrunFSBackend(..)
  , runFSBackendwhere
  ) where
{-|
 - Simple file system backend.
 -}
import qualified Prelude
import qualifiedBasicPreludePrelude
import BasicPreludeSystem.Directory
import System.DirectoryFilesystem.Path.CurrentOS
import Filesystem.Path.CurrentOS
import Control.Monad.Trans.Reader
import Control.Monad.Trans.ReaderControl.Monad.Trans.Control
import Control.Monad.Trans.ControlControl.Monad.Base
import Control.Monad.Base
import qualified Data.ByteString.Char8 as S
import qualifiedData.ConduitData.ByteString.Char8 as S
import Data.Conduitqualified Data.Conduit.List as C
import qualified Data.Conduit.ListData.Conduit.BinaryasasC C
import qualified Data.Conduit.BinaryData.Conduit.ProcessasasCC
import qualified Data.Conduit.Process as C
import Network.FTP.Utils (dropHeadingPathSeparator)
import Network.FTP.UtilsNetwork.FTP.BackenddropHeadingPathSeparator(FTPBackend(..))       )
import Network.FTP.Backend (FTPBackend(..))
data FSConf = FSConf
data{ fsBase::= FSConfFilePath
  { fsBase :: FilePath
  }
newtype FSBackend a = FSBackend { unFSBackend :: ReaderT FSConf (ResourceT IO) a }
newtypederiving( Functor = FSBackend, Applicative unFSBackend, Monad, MonadIO:: ReaderT FSConf (ResourceT IO) a }
    deriving ( FunctorMonadUnsafeIO, Applicative, MonadThrow, Monad, ,MonadResource
             , MonadUnsafeIO, MonadThrow, MonadResource
             )
instance MonadBase IO FSBackend where
instanceliftBase= FSBackend FSBackend. liftBasewhere
    liftBase = FSBackend . liftBase
instance MonadBaseControl IO FSBackend where
instancenewtypeStM FSBackend IOa =FSBackendFSBackendStMwhere{ unFSBackendStM :: StM (ReaderT FSConf (ResourceT IO)) a }
    newtypeliftBaseWith FSBackendf = FSBackend = FSBackendStM. liftBaseWith unFSBackendStM$ \runInBase ->::fStM$ liftMReaderTFSBackendStM (ResourceT. runInBase)) aunFSBackend}
    liftBaseWithrestoreM = FSBackend = FSBackend. restoreM liftBaseWith. unFSBackendStM \runInBase -> f $ liftM FSBackendStM . runInBase . unFSBackend
    restoreM = FSBackend . restoreM . unFSBackendStM
runFSBackend :: FSConf -> FSBackend a -> IO a
runFSBackend :: FSConfm = runResourceT-> FSBackend$ runReaderT -> IO a (unFSBackend m) st
runFSBackend st m = runResourceT $ runReaderT (unFSBackend m) st
makeAbsolute :: FilePath -> FSBackend FilePath
makeAbsolute ::path= do   -> FSBackend FilePath
makeAbsoluteb <- FSBackend =(doasks fsBase)
    breturn<- FSBackend$ b </> (dropHeadingPathSeparatorasks fsBase)            path
    return $ b </> dropHeadingPathSeparator path
instance FTPBackend FSBackend where
instancetype FTPBackendUserId FSBackend= ByteStringwhere
    type UserId FSBackend = ByteString
    ftplog = liftIO . S.putStrLn
    ftplog = liftIO . S.putStrLn
    authenticate user pass =
    authenticateif user==user pass =
        ifthen==returnpass (Just user)
          then return (NothingJust user)
          else return Nothing
    list dir = do
    listdir' =<-dolift (makeAbsolute dir)
        dir'C.sourceCmd<- lift$(makeAbsolute"ls -l " ++ encodeString)        dir'
        C.sourceCmd $ "ls -l " ++ encodeString dir'
    nlst dir = do
    nlstdir' =<-lift (makeAbsolute dir)
        dir'paths <- liftliftIOmakeAbsolute$ getDirectoryContents)       (encodeString dir')
        pathsC.sourceList<- liftIO$ map getDirectoryContents(S.pack . (++"\n")) (pathsencodeString dir')
        C.sourceList $ map (S.pack . (++"\n")) paths
    mkd dir =
    mkd dirmakeAbsolute=        dir >>= liftIO . createDirectory . encodeString
        makeAbsolute dir >>= liftIO . createDirectory . encodeString
    dele name =
    delemakeAbsolute =      name >>= liftIO . removeFile . encodeString
        makeAbsolute name >>= liftIO . removeFile . encodeString
    rename fname tname = do
    renamefname'<-tnamemakeAbsolute= do    fname
        fname' <- makeAbsolute fname
        tname' <-$ renameFile(encodeString      fname') (encodeString tname')
        liftIO $ renameFile (encodeString fname') (encodeString tname')
    rmd dir = do
    rmd dirdir'=<-makeAbsolute dir
        dir'liftIO<-$makeAbsoluteremoveDirectory (encodeString dir')
        liftIO $ removeDirectory (encodeString dir')
    download name =
    downloadlift name(makeAbsolute=        name) >>= C.sourceFile . encodeString
        lift (makeAbsolute name) >>= C.sourceFile . encodeString
    upload   name =
    uploadlift name(makeAbsolute=        name) >>= C.sinkFile . encodeString
        lift (makeAbsolute name) >>= C.sinkFile . encodeString

</pre>