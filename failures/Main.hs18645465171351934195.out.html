<a href="Main.hs1828087692621301815.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs1952509530130060903.out.html">next</a></br></br><pre>34c34
< errorVisual :: String → IO Int
---
> errorVisual :: String -> IO Int
42c42
< warnVisual :: MessageType → ButtonsType → String → String → IO ResponseId
---
> warnVisual :: MessageType -> ButtonsType -> String -> String -> IO ResponseId
47c47
<   dlg ← messageDialogNewWithMarkup Nothing [] mt bt msg
---
>   dlg <- messageDialogNewWithMarkup Nothing [] mt bt msg
49c49
<   onResponse dlg (\_ → widgetDestroy dlg)
---
>   onResponse dlg (\_ -> widgetDestroy dlg)
53c53
< start :: [String] → IO Int
---
> start :: [String] -> IO Int
61c61
<   is ← getInterfaces
---
>   is <- getInterfaces
63d62
<     [] → errorVisual "No wireless network interfaces."
64c63
<     _  → withArgs is $ start is
---
>     [] -> errorVisual "No wireless network interfaces."
64a64
>     _  -> withArgs is $ start is
69d68
<   icn ← statusIcon
70c69
<   win ← mainWindowNew
---
>   icn <- statusIcon
70a70
>   win <- mainWindowNew
83c83
< interfaceArg = return . (\(i:_) → i) =<< getArgs
---
> interfaceArg = return . (\(i:_) -> i) =<< getArgs
106c106
< (=:) :: IORef a → a → IO a
---
> (=:) :: IORef a -> a -> IO a
111c111
<   vis ← mutateUsing not mainWindowVisibility
---
>   vis <- mutateUsing not mainWindowVisibility
115c115
< mutateUsing :: (a → a) → IORef a → IO a
---
> mutateUsing :: (a -> a) -> IORef a -> IO a
119c119
< (⇆) :: a → a → IO a
---
> (⇆) :: a -> a -> IO a
121d120
<   it ← interfaceArg
122c121
<   cs ← getConnectionStatus it
---
>   it <- interfaceArg
122a122
>   cs <- getConnectionStatus it
124d123
<     Connected _ _ → return d
125c124
<     _             → return c
---
>     Connected _ _ -> return d
125a125
>     _             -> return c
129d128
<   stc ← stockConnect ⇆ stockDisconnect
130c129
<   icn ← statusIconNewFromStock stc
---
>   stc <- stockConnect ⇆ stockDisconnect
130a130
>   icn <- statusIconNewFromStock stc
133d132
<   mnu ← mkmenu icn
134c133
<   I.onPopupMenu icn $ \b a → do
---
>   mnu <- mkmenu icn
134a134
>   I.onPopupMenu icn $ \b a -> do
143d142
<       m ← menuNew
144c143
<       i ← interfaceArg
---
>       m <- menuNew
144a144
>       i <- interfaceArg
156c156
<           i ← imageMenuItemNewFromStock label
---
>           i <- imageMenuItemNewFromStock label
164d163
<   vbx ← readIORef mainBox
165c164
<   vio ← readIORef mainView
---
>   vbx <- readIORef mainBox
165a165
>   vio <- readIORef mainView
167c167
<   vin ← wlanTreeViewNew
---
>   vin <- wlanTreeViewNew
174d173
<   win ← windowNew
175c174
<   vbx ← vBoxNew False 0
---
>   win <- windowNew
175a175
>   vbx <- vBoxNew False 0
177c177
<   mnu ← createMenu
---
>   mnu <- createMenu
180c180
<   view ← wlanTreeViewNew
---
>   view <- wlanTreeViewNew
183c183
<   sbr ← statusbarNew
---
>   sbr <- statusbarNew
214d213
<   model ← wlanTreeModelNew
215d213
<   view ← treeViewNewWithModel model
216d213
<   cs@[c1,c2,c3,c4] ← replicateM 4 treeViewColumnNew
217c214
<   mapM_ (\(c,t) → treeViewColumnSetTitle c t) $ zip cs
---
>   model <- wlanTreeModelNew
217a215
>   view <- treeViewNewWithModel model
217a216
>   cs@[c1,c2,c3,c4] <- replicateM 4 treeViewColumnNew
217a217
>   mapM_ (\(c,t) -> treeViewColumnSetTitle c t) $ zip cs
219d218
<   [r2,r4] ← replicateM 2 cellRendererTextNew
220d218
<   r3 ← cellRendererProgressNew
221c219
<   r1 ← cellRendererToggleNew
---
>   [r2,r4] <- replicateM 2 cellRendererTextNew
221a220
>   r3 <- cellRendererProgressNew
221a221
>   r1 <- cellRendererToggleNew
223c223
<   mapM_ (\(c,pc) → pc c) $
---
>   mapM_ (\(c,pc) -> pc c) $
232c232
<   s ← getConnectionStatus =<< interfaceArg
---
>   s <- getConnectionStatus =<< interfaceArg
234d233
<   cellLayoutSetAttributes c2 r2 model $ \r → [ cellText := idof r            ]
235c234
<   cellLayoutSetAttributes c3 r3 model $ \r → [ cellProgressValue := qual r,
---
>   cellLayoutSetAttributes c2 r2 model $ \r -> [ cellText := idof r            ]
235a235
>   cellLayoutSetAttributes c3 r3 model $ \r -> [ cellProgressValue := qual r,
237d236
<   cellLayoutSetAttributes c4 r4 model $ \r → [ cellText := show (cencrypt r) ]
238c237
<   cellLayoutSetAttributes c1 r1 model $ \r → [ cellToggleActive := conn s r,
---
>   cellLayoutSetAttributes c4 r4 model $ \r -> [ cellText := show (cencrypt r) ]
238a238
>   cellLayoutSetAttributes c1 r1 model $ \r -> [ cellToggleActive := conn s r,
257c257
<       r ← treeStoreGetValue model path
---
>       r <- treeStoreGetValue model path
259d258
<         None → ((flip connectFree) (cessid r) =<< interfaceArg) >> refresh
260c259
<         _    → connectUsingSettings (cessid r)
---
>         None -> ((flip connectFree) (cessid r) =<< interfaceArg) >> refresh
260a260
>         _    -> connectUsingSettings (cessid r)
264c264
< connectUsingSettings :: SSID → IO ()
---
> connectUsingSettings :: SSID -> IO ()
266d265
<   it ← interfaceArg
267c266
<   ms ← return . find (settingEq id) =<< readSettings
---
>   it <- interfaceArg
267a267
>   ms <- return . find (settingEq id) =<< readSettings
269d268
<     Just s → connect it s >> refresh
270c269
<     _      → (warnVisual MessageError ButtonsOk appName $
---
>     Just s -> connect it s >> refresh
270a270
>     _      -> (warnVisual MessageError ButtonsOk appName $
281c281
<   mc ← tryReadFile settingsFile
---
>   mc <- tryReadFile settingsFile
283d282
<     Just contents → return . read $ contents
284c283
<     _             → create settingsFile >> return []
---
>     Just contents -> return . read $ contents
284a284
>     _             -> create settingsFile >> return []
288c288
< tryReadFile :: FilePath → IO (Maybe String)
---
> tryReadFile :: FilePath -> IO (Maybe String)
290c290
<   exists ← doesFileExist file
---
>   exists <- doesFileExist file
292d291
<     True  → return . Just =<< readFile file
293c292
<     False → return Nothing
---
>     True  -> return . Just =<< readFile file
293a293
>     False -> return Nothing
301c301
< cwlanToNode :: CWLAN → Tree CWLAN
---
> cwlanToNode :: CWLAN -> Tree CWLAN
311c311
< disconnectHandler :: Interface → IO ()
---
> disconnectHandler :: Interface -> IO ()
318c318
< doif :: Monad m ⇒ Bool → m () → m ()
---
> doif :: Monad m => Bool -> m () -> m ()
325d324
<   fma ← actionNew "FMA" "_File" Nothing Nothing
326c325
<   hma ← actionNew "HMA" "_Help" Nothing Nothing
---
>   fma <- actionNew "FMA" "_File" Nothing Nothing
326a326
>   hma <- actionNew "HMA" "_Help" Nothing Nothing
328d327
<   refa ← actionNew "REFA" "_Refresh"  (Just "stub") (Just stockRefresh)
329c328
<   exia ← actionNew "EXIA" "_Quit"  (Just "stub") (Just stockQuit)
---
>   refa <- actionNew "REFA" "_Refresh"  (Just "stub") (Just stockRefresh)
329a329
>   exia <- actionNew "EXIA" "_Quit"  (Just "stub") (Just stockQuit)
331c331
<   aboa ← actionNew "ABOA" "_About" (Just "stub") (Just stockAbout)
---
>   aboa <- actionNew "ABOA" "_About" (Just "stub") (Just stockAbout)
333c333
<   agr ← actionGroupNew "AGR"
---
>   agr <- actionGroupNew "AGR"
335c335
<   mapM_ (\act → actionGroupAddActionWithAccel agr act Nothing) [refa,exia,aboa]
---
>   mapM_ (\act -> actionGroupAddActionWithAccel agr act Nothing) [refa,exia,aboa]
341c341
<   ui ← uiManagerNew
---
>   ui <- uiManagerNew
345c345
<   maybeMenubar ← uiManagerGetWidget ui "/ui/menubar"
---
>   maybeMenubar <- uiManagerGetWidget ui "/ui/menubar"
373d372
<   dlg ← aboutDialogNew
374c373
<   lcs ← return license
---
>   dlg <- aboutDialogNew
374a374
>   lcs <- return license
385c385
<   onResponse dlg (\_ → widgetDestroy dlg)
---
>   onResponse dlg (\_ -> widgetDestroy dlg)
434a435
> 
</pre></br><h2>original</h2></br><pre>{-# OPTIONS -fglasgow-exts #-}

module Main where

import IO
import HNM.WLAN
import Data.List
import Data.Tree
import System.IO
import Data.IORef
import GHC.IOBase
import Data.Maybe
import System.Exit
import System.Process
import Graphics.UI.Gtk hiding (disconnect)
import System.Directory
import System.IO.Unsafe
import Text.Regex.Posix
import System.Posix.User
import System.Environment
import Control.Concurrent
import Control.Monad.State
import System.Glib.Signals (on)
import Graphics.UI.Gtk.ModelView
import Graphics.UI.Gtk.ModelView.TreeStore
import qualified Graphics.UI.Gtk.Display.StatusIcon as I

--import HNM.Settings

main :: IO Int
main = start =<< getArgs --assu (start =<< getArgs) warn


errorVisual :: String → IO Int
errorVisual msg = do
  warnVisual MessageError ButtonsOk appName msg
  return 1

warn :: IO Int
warn = errorVisual $ "You have to be root to run " ++ appName ++ "!"

warnVisual :: MessageType → ButtonsType → String → String → IO ResponseId
warnVisual mt bt tt msg = do
  putStrLn msg
  initGUI
  windowSetDefaultIconName "gtk-network"
  dlg ← messageDialogNewWithMarkup Nothing [] mt bt msg
  windowSetTitle dlg tt
  onResponse dlg (\_ → widgetDestroy dlg)
  dialogRun dlg


start :: [String] → IO Int
start ["--version"] = do
  printVersion
start ["-V"] = do
  printVersion
start ["--license"] = do
  printLicense
start [] = do
  is ← getInterfaces
  case is of
    [] → errorVisual "No wireless network interfaces."
    _  → withArgs is $ start is
start [interface] = assu (do
  putStrLn interface
  initGUI
  windowSetDefaultIconName "gtk-network"
  icn ← statusIcon
  win ← mainWindowNew
  mainWindow =: win
  taskbarIcon =: icn
  statusIconSetVisible icn True
  mainGUI
  return 0) warn
start [interface,driver] = assu (do
  putStrLn driver
  initHardware driver interface
  start [interface]) warn


interfaceArg :: IO Interface
interfaceArg = return . (\(i:_) → i) =<< getArgs

{-# NOINLINE mainWindow #-}
mainWindow :: IORef Window
mainWindow = unsafePerformIO $ newIORef $ unsafePerformIO mainWindowNew

{-# NOINLINE mainBox #-}
mainBox :: IORef VBox
mainBox = unsafePerformIO $ newIORef undefined

{-# NOINLINE mainView #-}
mainView :: IORef TreeView
mainView = unsafePerformIO $ newIORef undefined

{-# NOINLINE taskbarIcon #-}
taskbarIcon :: IORef StatusIcon
taskbarIcon = unsafePerformIO $ newIORef undefined

{-# NOINLINE mainWindowVisibility #-}
mainWindowVisibility :: IORef Bool
mainWindowVisibility = unsafePerformIO $ newIORef True


(=:) :: IORef a → a → IO a
r =: v = writeIORef r v >> return v

alternateMainWindowVisibility :: IO ()
alternateMainWindowVisibility = do
  vis ← mutateUsing not mainWindowVisibility
  (if vis then widgetShow
          else widgetHide) =<< readIORef mainWindow

mutateUsing :: (a → a) → IORef a → IO a
mutateUsing f r = (r =:) . f =<< x r
  where x = readIORef

(⇆) :: a → a → IO a
c ⇆ d = do
  it ← interfaceArg
  cs ← getConnectionStatus it
  case cs of
    Connected _ _ → return d
    _             → return c

statusIcon :: IO StatusIcon
statusIcon = do
  stc ← stockConnect ⇆ stockDisconnect
  icn ← statusIconNewFromStock stc
  statusIconSetVisible icn True
  statusIconSetTooltip icn appName
  mnu ← mkmenu icn
  I.onPopupMenu icn $ \b a → do
    widgetShowAll mnu
    print (b,a)
    menuPopup mnu $ maybe Nothing (\b' -> Just (b',a)) b
  I.onActivate icn $
    alternateMainWindowVisibility
  return icn
  where
    mkmenu s = do
      m ← menuNew
      i ← interfaceArg
      mapM_ (mkitem m) [("gtk-refresh", refresh)               ,
                        ("gtk-disconnect", disconnectHandler i),
                        ("---", undefined)                     ,
                        ("gtk-about", showAbout)               ,
                        ("---", undefined)                     ,
                        ("gtk-quit", mainQuit)                  ]
      return m
      where
        mkitem menu ("---",_) = do
          menuShellAppend menu =<< separatorMenuItemNew
        mkitem menu (label,act) = do
          i ← imageMenuItemNewFromStock label
          menuShellAppend menu i
          onActivateLeaf i act
          return ()


refresh :: IO ()
refresh = do
  vbx ← readIORef mainBox
  vio ← readIORef mainView
  containerRemove vbx vio
  vin ← wlanTreeViewNew
  mainView =: vin
  containerAdd vbx vin


mainWindowNew :: IO Window
mainWindowNew = do
  win ← windowNew
  vbx ← vBoxNew False 0

  mnu ← createMenu
  boxPackStart vbx mnu PackNatural 0

  view ← wlanTreeViewNew
  containerAdd vbx view

  sbr ← statusbarNew
  boxPackEnd vbx sbr PackNatural 0

{-txt ← textViewNew
  textViewSetEditable txt False
  widgetSetSizeRequest txt 0 160
  boxPackEnd vbx txt PackGrow 0-}

  containerAdd win vbx

  mainBox =: vbx
  mainView =: view

  windowSetTitle win appName

  onDestroy win mainQuit
  widgetShowAll win

--  forkIO autorefresh

  return win

autorefresh :: IO ()
autorefresh = do
  refresh
  putStrLn "refreshed"
  system "sleep 1"
  autorefresh

wlanTreeViewNew :: IO TreeView
wlanTreeViewNew = do
  model ← wlanTreeModelNew
  view ← treeViewNewWithModel model
  cs@[c1,c2,c3,c4] ← replicateM 4 treeViewColumnNew
  mapM_ (\(c,t) → treeViewColumnSetTitle c t) $ zip cs
    ["", "essid", "quality", "encryption"]
  [r2,r4] ← replicateM 2 cellRendererTextNew
  r3 ← cellRendererProgressNew
  r1 ← cellRendererToggleNew

  mapM_ (\(c,pc) → pc c) $
    zip cs ([pack r1,
             pack r2,
             pack r3,
             pack r4])

  treeViewColumnSetSizing     c3 TreeViewColumnFixed
  treeViewColumnSetFixedWidth c3 150

  s ← getConnectionStatus =<< interfaceArg

  cellLayoutSetAttributes c2 r2 model $ \r → [ cellText := idof r            ]
  cellLayoutSetAttributes c3 r3 model $ \r → [ cellProgressValue := qual r,
                                               cellProgressText  := Just ""  ]
  cellLayoutSetAttributes c4 r4 model $ \r → [ cellText := show (cencrypt r) ]
  cellLayoutSetAttributes c1 r1 model $ \r → [ cellToggleActive := conn s r,
                                               cellToggleRadio := True       ]

  on r1 cellToggled (connect model)

  mapM_ (treeViewAppendColumn view) cs
  widgetShowAll view
  return view
  where
    idof r = if id == "" && ln == 1 then mac else id
      where
        id             = cessid r
        cs@((mac,_):_) = ccell r
        ln             = length cs
    qual = meanQuality . map snd . ccell
    pack r c = cellLayoutPackStart c r True -- continuation
    conn NotConnected      _ = False
    conn (Connected _ cid) r = cid == cessid r
    connect model pathStr = do
      r ← treeStoreGetValue model path
      case cencrypt r of
        None → ((flip connectFree) (cessid r) =<< interfaceArg) >> refresh
        _    → connectUsingSettings (cessid r)
      where
        path = stringToTreePath pathStr

connectUsingSettings :: SSID → IO ()
connectUsingSettings id = do
  it ← interfaceArg
  ms ← return . find (settingEq id) =<< readSettings
  case ms of
    Just s → connect it s >> refresh
    _      → (warnVisual MessageError ButtonsOk appName $
              "No configuration for encrypted network " ++ id ++
              " found in: " ++ settingsFile) >> return ()
  where
    settingEq id (Wireless sid _) = id == sid

settingsFile :: FilePath
settingsFile = "/etc/hnm.conf"

readSettings :: IO [ConnectionSetting]
readSettings = do
  mc ← tryReadFile settingsFile
  case mc of
    Just contents → return . read $ contents
    _             → create settingsFile >> return []
  where
    create f = writeFile f "[]"

tryReadFile :: FilePath → IO (Maybe String)
tryReadFile file = do
  exists ← doesFileExist file
  case exists of
    True  → return . Just =<< readFile file
    False → return Nothing


wlanTreeModelNew :: IO (TreeStore CWLAN)
wlanTreeModelNew = do
  treeStoreNew . (map cwlanToNode) . compact =<< getWLANs =<< interfaceArg


cwlanToNode :: CWLAN → Tree CWLAN
cwlanToNode w = Node w s
  where
    s       = if ln > 1 then map (c2w w) cs else []
      where
        cs  = ccell w
        ln  = length cs
    c2w w c = Node (CWLAN (fst c) (cencrypt w) [([],snd c)]) []


disconnectHandler :: Interface → IO ()
disconnectHandler interface = do
  disconnect interface
  ifconfig [interface, "up"]
  refresh


doif :: Monad m ⇒ Bool → m () → m ()
doif True act = act
doif False _  = return ()


createMenu :: IO Widget
createMenu = do
  fma ← actionNew "FMA" "_File" Nothing Nothing
  hma ← actionNew "HMA" "_Help" Nothing Nothing

  refa ← actionNew "REFA" "_Refresh"  (Just "stub") (Just stockRefresh)
  exia ← actionNew "EXIA" "_Quit"  (Just "stub") (Just stockQuit)

  aboa ← actionNew "ABOA" "_About" (Just "stub") (Just stockAbout)

  agr ← actionGroupNew "AGR"
  mapM_ (actionGroupAddAction agr) [fma,hma]
  mapM_ (\act → actionGroupAddActionWithAccel agr act Nothing) [refa,exia,aboa]

  onActionActivate refa refresh
  onActionActivate exia mainQuit
  onActionActivate aboa showAbout

  ui ← uiManagerNew
  uiManagerAddUiFromString ui menuDecl
  uiManagerInsertActionGroup ui agr 0

  maybeMenubar ← uiManagerGetWidget ui "/ui/menubar"
  return $ fromJust maybeMenubar
  where
    menuDecl = "<ui>\
\            <menubar>\
\             <menu action=\"FMA\">\
\               <menuitem action=\"REFA\" />\
\               <menuitem action=\"EXIA\" />\
\             </menu>\
\             <menu action=\"HMA\">\
\               <menuitem action=\"ABOA\" />\
\             </menu>\
\            </menubar>\
\           </ui>"


appName :: String
appName = "Happy Network Manager"

appNameShort :: String
appNameShort = "HNM"

appVersion :: String
appVersion = "0.1.2"


showAbout :: IO ()
showAbout = do
  dlg ← aboutDialogNew
  lcs ← return license
  set dlg [
            aboutDialogName := appName,
            aboutDialogVersion := appVersion,
            aboutDialogComments := "A quick and dirty applet to help you connect to wireless networks.",
            aboutDialogCopyright := "Copyright © 2008 Cetin Sert",
            aboutDialogWebsite := "http://sert.homedns.org/hs/hnm/",
            aboutDialogLicense := (Just lcs),
            aboutDialogAuthors := ["cs ^.^", "CS *^o^*"],
            aboutDialogLogoIconName := (Just "gtk-network")
          ]
  onResponse dlg (\_ → widgetDestroy dlg)
  dialogRun dlg
  return ()


printVersion :: IO Int
printVersion = do
  putStrLn $ appName ++ " " ++ appVersion
  putStrLn ""
  return 0

printLicense :: IO Int
printLicense = do
  printVersion
  putStrLn license
  putStrLn ""
  return 0

license :: String
license = "Copyright (c) 2008, Cetin Sert\n\
\\n\
\All rights reserved.\n\
\\n\
\Redistribution and use in source and binary forms, with or without\n\
\modification, are permitted provided that the following conditions are\n\
\met:\n\
\\n\
\    1. Redistributions of source code must retain the above copyright\n\
\       notice, this list of conditions and the following disclaimer.\n\
\\n\
\    2. Redistributions in binary form must reproduce the above\n\
\       copyright notice, this list of conditions and the following\n\
\       disclaimer in the documentation and/or other materials provided\n\
\       with the distribution.\n\
\\n\
\    3. The names of contributors may not be used to endorse or promote\n\
\       products derived from this software without specific prior\n\
\       written permission.\n\
\\n\
\THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\
\\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\
\LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\
\A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\
\OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\
\SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\
\LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\
\DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\
\THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\
\(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\
\OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
</pre></br><h2>printed</h2></br><pre>{-# OPTIONS -fglasgow-exts #-}

module Main where

import IO
import HNM.WLAN
import Data.List
import Data.Tree
import System.IO
import Data.IORef
import GHC.IOBase
import Data.Maybe
import System.Exit
import System.Process
import Graphics.UI.Gtk hiding (disconnect)
import System.Directory
import System.IO.Unsafe
import Text.Regex.Posix
import System.Posix.User
import System.Environment
import Control.Concurrent
import Control.Monad.State
import System.Glib.Signals (on)
import Graphics.UI.Gtk.ModelView
import Graphics.UI.Gtk.ModelView.TreeStore
import qualified Graphics.UI.Gtk.Display.StatusIcon as I

--import HNM.Settings

main :: IO Int
main = start =<< getArgs --assu (start =<< getArgs) warn


errorVisual :: String -> IO Int
errorVisual msg = do
  warnVisual MessageError ButtonsOk appName msg
  return 1

warn :: IO Int
warn = errorVisual $ "You have to be root to run " ++ appName ++ "!"

warnVisual :: MessageType -> ButtonsType -> String -> String -> IO ResponseId
warnVisual mt bt tt msg = do
  putStrLn msg
  initGUI
  windowSetDefaultIconName "gtk-network"
  dlg <- messageDialogNewWithMarkup Nothing [] mt bt msg
  windowSetTitle dlg tt
  onResponse dlg (\_ -> widgetDestroy dlg)
  dialogRun dlg


start :: [String] -> IO Int
start ["--version"] = do
  printVersion
start ["-V"] = do
  printVersion
start ["--license"] = do
  printLicense
start [] = do
  is <- getInterfaces
  case is of
    [] -> errorVisual "No wireless network interfaces."
    _  -> withArgs is $ start is
start [interface] = assu (do
  putStrLn interface
  initGUI
  windowSetDefaultIconName "gtk-network"
  icn <- statusIcon
  win <- mainWindowNew
  mainWindow =: win
  taskbarIcon =: icn
  statusIconSetVisible icn True
  mainGUI
  return 0) warn
start [interface,driver] = assu (do
  putStrLn driver
  initHardware driver interface
  start [interface]) warn


interfaceArg :: IO Interface
interfaceArg = return . (\(i:_) -> i) =<< getArgs

{-# NOINLINE mainWindow #-}
mainWindow :: IORef Window
mainWindow = unsafePerformIO $ newIORef $ unsafePerformIO mainWindowNew

{-# NOINLINE mainBox #-}
mainBox :: IORef VBox
mainBox = unsafePerformIO $ newIORef undefined

{-# NOINLINE mainView #-}
mainView :: IORef TreeView
mainView = unsafePerformIO $ newIORef undefined

{-# NOINLINE taskbarIcon #-}
taskbarIcon :: IORef StatusIcon
taskbarIcon = unsafePerformIO $ newIORef undefined

{-# NOINLINE mainWindowVisibility #-}
mainWindowVisibility :: IORef Bool
mainWindowVisibility = unsafePerformIO $ newIORef True


(=:) :: IORef a -> a -> IO a
r =: v = writeIORef r v >> return v

alternateMainWindowVisibility :: IO ()
alternateMainWindowVisibility = do
  vis <- mutateUsing not mainWindowVisibility
  (if vis then widgetShow
          else widgetHide) =<< readIORef mainWindow

mutateUsing :: (a -> a) -> IORef a -> IO a
mutateUsing f r = (r =:) . f =<< x r
  where x = readIORef

(⇆) :: a -> a -> IO a
c ⇆ d = do
  it <- interfaceArg
  cs <- getConnectionStatus it
  case cs of
    Connected _ _ -> return d
    _             -> return c

statusIcon :: IO StatusIcon
statusIcon = do
  stc <- stockConnect ⇆ stockDisconnect
  icn <- statusIconNewFromStock stc
  statusIconSetVisible icn True
  statusIconSetTooltip icn appName
  mnu <- mkmenu icn
  I.onPopupMenu icn $ \b a -> do
    widgetShowAll mnu
    print (b,a)
    menuPopup mnu $ maybe Nothing (\b' -> Just (b',a)) b
  I.onActivate icn $
    alternateMainWindowVisibility
  return icn
  where
    mkmenu s = do
      m <- menuNew
      i <- interfaceArg
      mapM_ (mkitem m) [("gtk-refresh", refresh)               ,
                        ("gtk-disconnect", disconnectHandler i),
                        ("---", undefined)                     ,
                        ("gtk-about", showAbout)               ,
                        ("---", undefined)                     ,
                        ("gtk-quit", mainQuit)                  ]
      return m
      where
        mkitem menu ("---",_) = do
          menuShellAppend menu =<< separatorMenuItemNew
        mkitem menu (label,act) = do
          i <- imageMenuItemNewFromStock label
          menuShellAppend menu i
          onActivateLeaf i act
          return ()


refresh :: IO ()
refresh = do
  vbx <- readIORef mainBox
  vio <- readIORef mainView
  containerRemove vbx vio
  vin <- wlanTreeViewNew
  mainView =: vin
  containerAdd vbx vin


mainWindowNew :: IO Window
mainWindowNew = do
  win <- windowNew
  vbx <- vBoxNew False 0

  mnu <- createMenu
  boxPackStart vbx mnu PackNatural 0

  view <- wlanTreeViewNew
  containerAdd vbx view

  sbr <- statusbarNew
  boxPackEnd vbx sbr PackNatural 0

{-txt ← textViewNew
  textViewSetEditable txt False
  widgetSetSizeRequest txt 0 160
  boxPackEnd vbx txt PackGrow 0-}

  containerAdd win vbx

  mainBox =: vbx
  mainView =: view

  windowSetTitle win appName

  onDestroy win mainQuit
  widgetShowAll win

--  forkIO autorefresh

  return win

autorefresh :: IO ()
autorefresh = do
  refresh
  putStrLn "refreshed"
  system "sleep 1"
  autorefresh

wlanTreeViewNew :: IO TreeView
wlanTreeViewNew = do
  model <- wlanTreeModelNew
  view <- treeViewNewWithModel model
  cs@[c1,c2,c3,c4] <- replicateM 4 treeViewColumnNew
  mapM_ (\(c,t) -> treeViewColumnSetTitle c t) $ zip cs
    ["", "essid", "quality", "encryption"]
  [r2,r4] <- replicateM 2 cellRendererTextNew
  r3 <- cellRendererProgressNew
  r1 <- cellRendererToggleNew

  mapM_ (\(c,pc) -> pc c) $
    zip cs ([pack r1,
             pack r2,
             pack r3,
             pack r4])

  treeViewColumnSetSizing     c3 TreeViewColumnFixed
  treeViewColumnSetFixedWidth c3 150

  s <- getConnectionStatus =<< interfaceArg

  cellLayoutSetAttributes c2 r2 model $ \r -> [ cellText := idof r            ]
  cellLayoutSetAttributes c3 r3 model $ \r -> [ cellProgressValue := qual r,
                                               cellProgressText  := Just ""  ]
  cellLayoutSetAttributes c4 r4 model $ \r -> [ cellText := show (cencrypt r) ]
  cellLayoutSetAttributes c1 r1 model $ \r -> [ cellToggleActive := conn s r,
                                               cellToggleRadio := True       ]

  on r1 cellToggled (connect model)

  mapM_ (treeViewAppendColumn view) cs
  widgetShowAll view
  return view
  where
    idof r = if id == "" && ln == 1 then mac else id
      where
        id             = cessid r
        cs@((mac,_):_) = ccell r
        ln             = length cs
    qual = meanQuality . map snd . ccell
    pack r c = cellLayoutPackStart c r True -- continuation
    conn NotConnected      _ = False
    conn (Connected _ cid) r = cid == cessid r
    connect model pathStr = do
      r <- treeStoreGetValue model path
      case cencrypt r of
        None -> ((flip connectFree) (cessid r) =<< interfaceArg) >> refresh
        _    -> connectUsingSettings (cessid r)
      where
        path = stringToTreePath pathStr

connectUsingSettings :: SSID -> IO ()
connectUsingSettings id = do
  it <- interfaceArg
  ms <- return . find (settingEq id) =<< readSettings
  case ms of
    Just s -> connect it s >> refresh
    _      -> (warnVisual MessageError ButtonsOk appName $
              "No configuration for encrypted network " ++ id ++
              " found in: " ++ settingsFile) >> return ()
  where
    settingEq id (Wireless sid _) = id == sid

settingsFile :: FilePath
settingsFile = "/etc/hnm.conf"

readSettings :: IO [ConnectionSetting]
readSettings = do
  mc <- tryReadFile settingsFile
  case mc of
    Just contents -> return . read $ contents
    _             -> create settingsFile >> return []
  where
    create f = writeFile f "[]"

tryReadFile :: FilePath -> IO (Maybe String)
tryReadFile file = do
  exists <- doesFileExist file
  case exists of
    True  -> return . Just =<< readFile file
    False -> return Nothing


wlanTreeModelNew :: IO (TreeStore CWLAN)
wlanTreeModelNew = do
  treeStoreNew . (map cwlanToNode) . compact =<< getWLANs =<< interfaceArg


cwlanToNode :: CWLAN -> Tree CWLAN
cwlanToNode w = Node w s
  where
    s       = if ln > 1 then map (c2w w) cs else []
      where
        cs  = ccell w
        ln  = length cs
    c2w w c = Node (CWLAN (fst c) (cencrypt w) [([],snd c)]) []


disconnectHandler :: Interface -> IO ()
disconnectHandler interface = do
  disconnect interface
  ifconfig [interface, "up"]
  refresh


doif :: Monad m => Bool -> m () -> m ()
doif True act = act
doif False _  = return ()


createMenu :: IO Widget
createMenu = do
  fma <- actionNew "FMA" "_File" Nothing Nothing
  hma <- actionNew "HMA" "_Help" Nothing Nothing

  refa <- actionNew "REFA" "_Refresh"  (Just "stub") (Just stockRefresh)
  exia <- actionNew "EXIA" "_Quit"  (Just "stub") (Just stockQuit)

  aboa <- actionNew "ABOA" "_About" (Just "stub") (Just stockAbout)

  agr <- actionGroupNew "AGR"
  mapM_ (actionGroupAddAction agr) [fma,hma]
  mapM_ (\act -> actionGroupAddActionWithAccel agr act Nothing) [refa,exia,aboa]

  onActionActivate refa refresh
  onActionActivate exia mainQuit
  onActionActivate aboa showAbout

  ui <- uiManagerNew
  uiManagerAddUiFromString ui menuDecl
  uiManagerInsertActionGroup ui agr 0

  maybeMenubar <- uiManagerGetWidget ui "/ui/menubar"
  return $ fromJust maybeMenubar
  where
    menuDecl = "<ui>\
\            <menubar>\
\             <menu action=\"FMA\">\
\               <menuitem action=\"REFA\" />\
\               <menuitem action=\"EXIA\" />\
\             </menu>\
\             <menu action=\"HMA\">\
\               <menuitem action=\"ABOA\" />\
\             </menu>\
\            </menubar>\
\           </ui>"


appName :: String
appName = "Happy Network Manager"

appNameShort :: String
appNameShort = "HNM"

appVersion :: String
appVersion = "0.1.2"


showAbout :: IO ()
showAbout = do
  dlg <- aboutDialogNew
  lcs <- return license
  set dlg [
            aboutDialogName := appName,
            aboutDialogVersion := appVersion,
            aboutDialogComments := "A quick and dirty applet to help you connect to wireless networks.",
            aboutDialogCopyright := "Copyright © 2008 Cetin Sert",
            aboutDialogWebsite := "http://sert.homedns.org/hs/hnm/",
            aboutDialogLicense := (Just lcs),
            aboutDialogAuthors := ["cs ^.^", "CS *^o^*"],
            aboutDialogLogoIconName := (Just "gtk-network")
          ]
  onResponse dlg (\_ -> widgetDestroy dlg)
  dialogRun dlg
  return ()


printVersion :: IO Int
printVersion = do
  putStrLn $ appName ++ " " ++ appVersion
  putStrLn ""
  return 0

printLicense :: IO Int
printLicense = do
  printVersion
  putStrLn license
  putStrLn ""
  return 0

license :: String
license = "Copyright (c) 2008, Cetin Sert\n\
\\n\
\All rights reserved.\n\
\\n\
\Redistribution and use in source and binary forms, with or without\n\
\modification, are permitted provided that the following conditions are\n\
\met:\n\
\\n\
\    1. Redistributions of source code must retain the above copyright\n\
\       notice, this list of conditions and the following disclaimer.\n\
\\n\
\    2. Redistributions in binary form must reproduce the above\n\
\       copyright notice, this list of conditions and the following\n\
\       disclaimer in the documentation and/or other materials provided\n\
\       with the distribution.\n\
\\n\
\    3. The names of contributors may not be used to endorse or promote\n\
\       products derived from this software without specific prior\n\
\       written permission.\n\
\\n\
\THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\
\\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\
\LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\
\A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\
\OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\
\SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\
\LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\
\DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\
\THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\
\(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\
\OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

</pre>