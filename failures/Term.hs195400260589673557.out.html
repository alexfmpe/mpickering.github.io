<a href="Term.hs13349489051724586126.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Term.hs197941363348318738.out.html">next</a></br></br><pre>33c33
< data Pattern = Pat {constr ∷ String, vars ∷ [String]} deriving (Show, Eq, Ord)
---
> data Pattern = Pat {constr :: String, vars :: [String]} deriving (Show, Eq, Ord)
35c35
< testParser ∷ IndentParser tok () c → [tok] → c
---
> testParser :: IndentParser tok () c -> [tok] -> c
38c38
< parse ∷ [Char] → Λ
---
> parse :: [Char] -> Λ
41c41
< parseFile ∷ FilePath → IO Λ
---
> parseFile :: FilePath -> IO Λ
44c44
< expression ∷ IndentCharParser st Λ
---
> expression :: IndentCharParser st Λ
47c47
< application ∷ IndentCharParser st Λ
---
> application :: IndentCharParser st Λ
50c50
< variable ∷ IndentCharParser st Λ
---
> variable :: IndentCharParser st Λ
53c53
< numeral ∷ IndentCharParser st Λ
---
> numeral :: IndentCharParser st Λ
56c56
< numeric ∷ IndentCharParser st String
---
> numeric :: IndentCharParser st String
59c59
< parenthetic ∷ IndentCharParser st Λ
---
> parenthetic :: IndentCharParser st Λ
62c62
< tokP ∷ T.TokenParser st
---
> tokP :: T.TokenParser st
65c65
< caseExpr ∷ IndentCharParser st Λ
---
> caseExpr :: IndentCharParser st Λ
69c69
< patterns ∷ IndentCharParser st [(Pattern, Λ)]
---
> patterns :: IndentCharParser st [(Pattern, Λ)]
72c72
< arrow ∷ IndentCharParser st String
---
> arrow :: IndentCharParser st String
75c75
< pattern ∷ IndentCharParser st (Pattern, Λ)
---
> pattern :: IndentCharParser st (Pattern, Λ)
79c79
< lambda ∷ IndentCharParser st String
---
> lambda :: IndentCharParser st String
82c82
< abstraction ∷ IndentCharParser st Λ
---
> abstraction :: IndentCharParser st Λ
87c87
< letBinding ∷ IndentCharParser st Λ
---
> letBinding :: IndentCharParser st Λ
90c90
<         e ← optionMaybe $ keyword "in" *> expression
---
>         e <- optionMaybe $ keyword "in" *> expression
92d91
<             Just je → return ([], Just je)
93d91
<             Nothing → do
94c92
<                 (b,e) ← lineFold $ (,) <$> binding <*> (optionMaybe $ keyword "in" *> expression)
---
>             Just je -> return ([], Just je)
94a93
>             Nothing -> do
94a94
>                 (b,e) <- lineFold $ (,) <$> binding <*> (optionMaybe $ keyword "in" *> expression)
96d95
<                     Nothing → do
97c96
<                         rec ← optionMaybe parseBindings
---
>                     Nothing -> do
97a97
>                         rec <- optionMaybe parseBindings
99d98
<                             Nothing → return ([b], Nothing)
100d98
<                             Just (bs, me) → return (b:bs, me)
101d98
<                     Just je → return ([b], Just je)
102c99
<     (binds, e) ← keyword "let" *> block parseBindings
---
>                             Nothing -> return ([b], Nothing)
102a100
>                             Just (bs, me) -> return (b:bs, me)
102a101
>                     Just je -> return ([b], Just je)
102a102
>     (binds, e) <- keyword "let" *> block parseBindings
104d103
<         Nothing → L binds <$> (keyword "in" *> expression)
105c104
<         Just je → return $ L binds je
---
>         Nothing -> L binds <$> (keyword "in" *> expression)
105a105
>         Just je -> return $ L binds je
107c107
< binding ∷ IndentCharParser st (String,Λ)
---
> binding :: IndentCharParser st (String,Λ)
109d108
<     funct ← ident
110c109
<     rhs ← flip (foldr Λ) <$> many ident <*> (sym "=" *> expression)
---
>     funct <- ident
110a110
>     rhs <- flip (foldr Λ) <$> many ident <*> (sym "=" *> expression)
113c113
< keyword ∷ String → IndentCharParser st ()
---
> keyword :: String -> IndentCharParser st ()
116c116
< ident ∷ IndentCharParser st String
---
> ident :: IndentCharParser st String
119c119
< sym ∷ String → IndentCharParser st String
---
> sym :: String -> IndentCharParser st String
120a121
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module Term where

import Prelude.Unicode
import Text.ParserCombinators.Parsec as Parsec
    hiding (space, eof, notFollowedBy, anyChar, many, optional, (<|>))
import Text.ParserCombinators.Parsec.IndentParser as Indent
import Text.ParserCombinators.Parsec.Language
import Text.ParserCombinators.Parsec.IndentParser.Token
import qualified Text.ParserCombinators.Parsec.Token as T
import Control.Monad
import Data.Functor
import Control.Applicative


instance Applicative (GenParser s a) where
    pure  = return
    (<*>) = ap

instance Alternative (GenParser s a) where
    empty = mzero
    (<|>) = mplus

-- | The AST of a lambda expression
data Λ = A Λ Λ            -- ^ application
    | Λ String Λ           -- ^ abstraction
    | L [(String,Λ)] Λ     -- ^ let binding
    | Case Λ [(Pattern,Λ)] -- ^ case expression
    | C String [Λ]         -- ^ constructor
    deriving (Show,Eq,Ord)

-- | The LHS of a case expression. Numbers are parsed as strings.
data Pattern = Pat {constr ∷ String, vars ∷ [String]} deriving (Show, Eq, Ord)

testParser ∷ IndentParser tok () c → [tok] → c
testParser parser str = either (error ∘ show) id (Indent.parse parser "(null)" str)

parse ∷ [Char] → Λ
parse = testParser expression

parseFile ∷ FilePath → IO Λ
parseFile = liftM (either (error ∘ show) id) ∘ Indent.parseFromFile expression

expression ∷ IndentCharParser st Λ
expression = flip label "expression" $ letBinding <|> caseExpr <|> application

application ∷ IndentCharParser st Λ
application = foldl1 A <$> many1 (parenthetic <|> abstraction <|> variable <|> numeral)

variable ∷ IndentCharParser st Λ
variable = C <$> (ident <|> operator haskell) <*> pure []

numeral ∷ IndentCharParser st Λ
numeral = C <$> numeric <*> pure []

numeric ∷ IndentCharParser st String
numeric = either show show <$> naturalOrFloat haskell

parenthetic ∷ IndentCharParser st Λ
parenthetic = parens haskell expression

tokP ∷ T.TokenParser st
tokP = T.makeTokenParser haskellDef

caseExpr ∷ IndentCharParser st Λ
caseExpr = flip label "case expression" $
    Case <$> (keyword "case" *> expression <* keyword "of") <*> bracesOrBlock tokP patterns

patterns ∷ IndentCharParser st [(Pattern, Λ)]
patterns = semiOrNewLineSep tokP pattern

arrow ∷ IndentCharParser st String
arrow = sym "→" <|> sym "->"

pattern ∷ IndentCharParser st (Pattern, Λ)
pattern = (,) <$> lhs <*> (arrow *> expression) where
    lhs = Pat <$> (ident <|> numeric) <*> many (ident <|> numeric)

lambda ∷ IndentCharParser st String
lambda = sym "λ" <|> sym "\\"

abstraction ∷ IndentCharParser st Λ
abstraction = flip label "abstraction" $
    flip (foldr Λ) <$> (lambda *> many1 ident) <*> ((sym "." <|> arrow) *> expression)

-- Ugly, but works. Keyword "in" terminates binding blocks and bindings. Allows empty lets
letBinding ∷ IndentCharParser st Λ
letBinding = flip label "let binding" $ do
    let parseBindings = do
        e ← optionMaybe $ keyword "in" *> expression
        case e of
            Just je → return ([], Just je)
            Nothing → do
                (b,e) ← lineFold $ (,) <$> binding <*> (optionMaybe $ keyword "in" *> expression)
                case e of
                    Nothing → do
                        rec ← optionMaybe parseBindings
                        case rec of
                            Nothing → return ([b], Nothing)
                            Just (bs, me) → return (b:bs, me)
                    Just je → return ([b], Just je)
    (binds, e) ← keyword "let" *> block parseBindings
    case e of
        Nothing → L binds <$> (keyword "in" *> expression)
        Just je → return $ L binds je

binding ∷ IndentCharParser st (String,Λ)
binding = flip label "binding" $ do
    funct ← ident
    rhs ← flip (foldr Λ) <$> many ident <*> (sym "=" *> expression)
    return (funct, rhs)

keyword ∷ String → IndentCharParser st ()
keyword = reserved haskell

ident ∷ IndentCharParser st String
ident = identifier haskell

sym ∷ String → IndentCharParser st String
sym = symbol haskell
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module Term where

import Prelude.Unicode
import Text.ParserCombinators.Parsec as Parsec
    hiding (space, eof, notFollowedBy, anyChar, many, optional, (<|>))
import Text.ParserCombinators.Parsec.IndentParser as Indent
import Text.ParserCombinators.Parsec.Language
import Text.ParserCombinators.Parsec.IndentParser.Token
import qualified Text.ParserCombinators.Parsec.Token as T
import Control.Monad
import Data.Functor
import Control.Applicative


instance Applicative (GenParser s a) where
    pure  = return
    (<*>) = ap

instance Alternative (GenParser s a) where
    empty = mzero
    (<|>) = mplus

-- | The AST of a lambda expression
data Λ = A Λ Λ            -- ^ application
    | Λ String Λ           -- ^ abstraction
    | L [(String,Λ)] Λ     -- ^ let binding
    | Case Λ [(Pattern,Λ)] -- ^ case expression
    | C String [Λ]         -- ^ constructor
    deriving (Show,Eq,Ord)

-- | The LHS of a case expression. Numbers are parsed as strings.
data Pattern = Pat {constr :: String, vars :: [String]} deriving (Show, Eq, Ord)

testParser :: IndentParser tok () c -> [tok] -> c
testParser parser str = either (error ∘ show) id (Indent.parse parser "(null)" str)

parse :: [Char] -> Λ
parse = testParser expression

parseFile :: FilePath -> IO Λ
parseFile = liftM (either (error ∘ show) id) ∘ Indent.parseFromFile expression

expression :: IndentCharParser st Λ
expression = flip label "expression" $ letBinding <|> caseExpr <|> application

application :: IndentCharParser st Λ
application = foldl1 A <$> many1 (parenthetic <|> abstraction <|> variable <|> numeral)

variable :: IndentCharParser st Λ
variable = C <$> (ident <|> operator haskell) <*> pure []

numeral :: IndentCharParser st Λ
numeral = C <$> numeric <*> pure []

numeric :: IndentCharParser st String
numeric = either show show <$> naturalOrFloat haskell

parenthetic :: IndentCharParser st Λ
parenthetic = parens haskell expression

tokP :: T.TokenParser st
tokP = T.makeTokenParser haskellDef

caseExpr :: IndentCharParser st Λ
caseExpr = flip label "case expression" $
    Case <$> (keyword "case" *> expression <* keyword "of") <*> bracesOrBlock tokP patterns

patterns :: IndentCharParser st [(Pattern, Λ)]
patterns = semiOrNewLineSep tokP pattern

arrow :: IndentCharParser st String
arrow = sym "→" <|> sym "->"

pattern :: IndentCharParser st (Pattern, Λ)
pattern = (,) <$> lhs <*> (arrow *> expression) where
    lhs = Pat <$> (ident <|> numeric) <*> many (ident <|> numeric)

lambda :: IndentCharParser st String
lambda = sym "λ" <|> sym "\\"

abstraction :: IndentCharParser st Λ
abstraction = flip label "abstraction" $
    flip (foldr Λ) <$> (lambda *> many1 ident) <*> ((sym "." <|> arrow) *> expression)

-- Ugly, but works. Keyword "in" terminates binding blocks and bindings. Allows empty lets
letBinding :: IndentCharParser st Λ
letBinding = flip label "let binding" $ do
    let parseBindings = do
        e <- optionMaybe $ keyword "in" *> expression
        case e of
            Just je -> return ([], Just je)
            Nothing -> do
                (b,e) <- lineFold $ (,) <$> binding <*> (optionMaybe $ keyword "in" *> expression)
                case e of
                    Nothing -> do
                        rec <- optionMaybe parseBindings
                        case rec of
                            Nothing -> return ([b], Nothing)
                            Just (bs, me) -> return (b:bs, me)
                    Just je -> return ([b], Just je)
    (binds, e) <- keyword "let" *> block parseBindings
    case e of
        Nothing -> L binds <$> (keyword "in" *> expression)
        Just je -> return $ L binds je

binding :: IndentCharParser st (String,Λ)
binding = flip label "binding" $ do
    funct <- ident
    rhs <- flip (foldr Λ) <$> many ident <*> (sym "=" *> expression)
    return (funct, rhs)

keyword :: String -> IndentCharParser st ()
keyword = reserved haskell

ident :: IndentCharParser st String
ident = identifier haskell

sym :: String -> IndentCharParser st String
sym = symbol haskell

</pre>