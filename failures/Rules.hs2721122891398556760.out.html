<a href="Rules.hs21198788182049590396.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Rules.hs2817252261901915394.out.html">next</a></br></br><pre>9c9
< unshare ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> unshare :: (View [Port] n, View Vertex n) => Rule n
11d10
<     e ← edge
12c11
<     c ← liftReader $ edgeCardinality e
---
>     e <- edge
12a12
>     c <- liftReader $ edgeCardinality e
14c14
<     v ← nodeWith e
---
>     v <- nodeWith e
16d15
<     rewrite $ \[n] → do
17d15
<         es ← deleteEdge e
18d15
<         v' ← inspectNode n
19c16
<         mapM_ (copyNode n) [v {inp = i} | i ← es, i ≢ inp v']
---
>     rewrite $ \[n] -> do
19a17
>         es <- deleteEdge e
19a18
>         v' <- inspectNode n
19a19
>         mapM_ (copyNode n) [v {inp = i} | i <- es, i ≢ inp v']
22c22
< eraseRule ∷ (View [Port] n, View Vertex n) ⇒ Rule n
---
> eraseRule :: (View [Port] n, View Vertex n) => Rule n
24c24
<     e ← edge
---
>     e <- edge
26c26
<     _ ∷ [Port] ← nodeWith e
---
>     _ :: [Port] <- nodeWith e
27a28
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts, ScopedTypeVariables #-}
module Rules where

import Prelude.Unicode
import Graph
import GraphRewriting


unshare ∷ (View [Port] n, View Vertex n) ⇒ Rule n
unshare = do
    e ← edge
    c ← liftReader $ edgeCardinality e
    require (c > 2)
    v ← nodeWith e
    require (e ≡ inp v)
    rewrite $ \[n] → do
        es ← deleteEdge e
        v' ← inspectNode n
        mapM_ (copyNode n) [v {inp = i} | i ← es, i ≢ inp v']
        deleteNode n

eraseRule ∷ (View [Port] n, View Vertex n) ⇒ Rule n
eraseRule = do
    e ← edge
    requireM $ liftReader $ dangling e
    _ ∷ [Port] ← nodeWith e
    erase
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts, ScopedTypeVariables #-}
module Rules where

import Prelude.Unicode
import Graph
import GraphRewriting


unshare :: (View [Port] n, View Vertex n) => Rule n
unshare = do
    e <- edge
    c <- liftReader $ edgeCardinality e
    require (c > 2)
    v <- nodeWith e
    require (e ≡ inp v)
    rewrite $ \[n] -> do
        es <- deleteEdge e
        v' <- inspectNode n
        mapM_ (copyNode n) [v {inp = i} | i <- es, i ≢ inp v']
        deleteNode n

eraseRule :: (View [Port] n, View Vertex n) => Rule n
eraseRule = do
    e <- edge
    requireM $ liftReader $ dangling e
    _ :: [Port] <- nodeWith e
    erase

</pre>