<a href="Term.hs195400260589673557.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Term.hs616783871382955828.out.html">next</a></br></br><pre>18c18
< parse ∷ String → Λ
---
> parse :: String -> Λ
21c21
< parseFile ∷ FilePath → IO Λ
---
> parseFile :: FilePath -> IO Λ
24c24
< parser ∷ IndentCharParser st Λ
---
> parser :: IndentCharParser st Λ
34d33
<         _ ← sym "λ" <|> sym "\\"
35d33
<         vars ← many1 ident
36d33
<         _ ← sym "." <|> sym "→" <|> sym "->"
37c34
<         body ← expression
---
>         _ <- sym "λ" <|> sym "\\"
37a35
>         vars <- many1 ident
37a36
>         _ <- sym "." <|> sym "→" <|> sym "->"
37a37
>         body <- expression
46c46
<             e ← optionMaybe $ keyword "in" >> expression
---
>             e <- optionMaybe $ keyword "in" >> expression
48d47
<                 Just je → return ([], Just je)
49d47
<                 Nothing → do
50d47
<                     (b,e) ← lineFold $ do
51d47
<                         b ← binding
52c48
<                         e ← optionMaybe $ keyword "in" >> expression
---
>                 Just je -> return ([], Just je)
52a49
>                 Nothing -> do
52a50
>                     (b,e) <- lineFold $ do
52a51
>                         b <- binding
52a52
>                         e <- optionMaybe $ keyword "in" >> expression
55d54
<                         Nothing → do
56c55
<                             rec ← optionMaybe parseBindings
---
>                         Nothing -> do
56a56
>                             rec <- optionMaybe parseBindings
58d57
<                                 Nothing → return ([b], Nothing)
59d57
<                                 Just (bs, me) → return (b:bs, me)
60d57
<                         Just je → return ([b], Just je)
61c58
<         (binds, e) ← block parseBindings
---
>                                 Nothing -> return ([b], Nothing)
61a59
>                                 Just (bs, me) -> return (b:bs, me)
61a60
>                         Just je -> return ([b], Just je)
61a61
>         (binds, e) <- block parseBindings
63d62
<             Nothing → liftM (L binds) (keyword "in" >> expression)
64c63
<             Just je → return $ L binds je
---
>             Nothing -> liftM (L binds) (keyword "in" >> expression)
64a64
>             Just je -> return $ L binds je
66c66
<     binding ∷ IndentCharParser st (String,Λ)
---
>     binding :: IndentCharParser st (String,Λ)
68d67
<         funct  ← ident
69d67
<         params ← many ident
70c68
<         body   ← sym "=" >> expression
---
>         funct  <- ident
70a69
>         params <- many ident
70a70
>         body   <- sym "=" >> expression
75a76
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module Term where

import Prelude.Unicode
import Text.ParserCombinators.Parsec as Parsec
import Text.ParserCombinators.Parsec.IndentParser as Indent
import Text.ParserCombinators.Parsec.Language
import Text.ParserCombinators.Parsec.IndentParser.Token
import Control.Monad (liftM)


data Λ = A Λ Λ            -- ^ application
       | Λ String Λ       -- ^ abstraction
       | V String         -- ^ variable
       | L [(String,Λ)] Λ -- ^ let binding
    deriving (Show,Eq,Ord)

parse ∷ String → Λ
parse str = either (error ∘ show) id (Indent.parse parser "(null)" str)

parseFile ∷ FilePath → IO Λ
parseFile = liftM (either (error ∘ show) id) ∘ Indent.parseFromFile parser

parser ∷ IndentCharParser st Λ
parser = expression where

    expression = flip label "expression" $ application <|> letBinding

    application = liftM (foldl1 A) $ many1 $ choice [parenthetic, abstraction, variable]

    parenthetic = parens haskell expression

    abstraction = flip label "abstraction" $ do
        _ ← sym "λ" <|> sym "\\"
        vars ← many1 ident
        _ ← sym "." <|> sym "→" <|> sym "->"
        body ← expression
        return $ foldr Λ body vars

    variable = liftM V $ ident <|> operator haskell <|> liftM (either show show) (naturalOrFloat haskell)

    -- Ugly, but works. Keyword "in" terminates binding blocks and bindings. Allows empty lets
    letBinding = flip label "let binding" $ do
        keyword "let"
        let parseBindings = do
            e ← optionMaybe $ keyword "in" >> expression
            case e of
                Just je → return ([], Just je)
                Nothing → do
                    (b,e) ← lineFold $ do
                        b ← binding
                        e ← optionMaybe $ keyword "in" >> expression
                        return (b,e)
                    case e of
                        Nothing → do
                            rec ← optionMaybe parseBindings
                            case rec of
                                Nothing → return ([b], Nothing)
                                Just (bs, me) → return (b:bs, me)
                        Just je → return ([b], Just je)
        (binds, e) ← block parseBindings
        case e of
            Nothing → liftM (L binds) (keyword "in" >> expression)
            Just je → return $ L binds je

    binding ∷ IndentCharParser st (String,Λ)
    binding = flip label "binding" $ do
        funct  ← ident
        params ← many ident
        body   ← sym "=" >> expression
        return (funct, foldr Λ body params)

    keyword = reserved haskell
    ident = identifier haskell
    sym = symbol haskell
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module Term where

import Prelude.Unicode
import Text.ParserCombinators.Parsec as Parsec
import Text.ParserCombinators.Parsec.IndentParser as Indent
import Text.ParserCombinators.Parsec.Language
import Text.ParserCombinators.Parsec.IndentParser.Token
import Control.Monad (liftM)


data Λ = A Λ Λ            -- ^ application
       | Λ String Λ       -- ^ abstraction
       | V String         -- ^ variable
       | L [(String,Λ)] Λ -- ^ let binding
    deriving (Show,Eq,Ord)

parse :: String -> Λ
parse str = either (error ∘ show) id (Indent.parse parser "(null)" str)

parseFile :: FilePath -> IO Λ
parseFile = liftM (either (error ∘ show) id) ∘ Indent.parseFromFile parser

parser :: IndentCharParser st Λ
parser = expression where

    expression = flip label "expression" $ application <|> letBinding

    application = liftM (foldl1 A) $ many1 $ choice [parenthetic, abstraction, variable]

    parenthetic = parens haskell expression

    abstraction = flip label "abstraction" $ do
        _ <- sym "λ" <|> sym "\\"
        vars <- many1 ident
        _ <- sym "." <|> sym "→" <|> sym "->"
        body <- expression
        return $ foldr Λ body vars

    variable = liftM V $ ident <|> operator haskell <|> liftM (either show show) (naturalOrFloat haskell)

    -- Ugly, but works. Keyword "in" terminates binding blocks and bindings. Allows empty lets
    letBinding = flip label "let binding" $ do
        keyword "let"
        let parseBindings = do
            e <- optionMaybe $ keyword "in" >> expression
            case e of
                Just je -> return ([], Just je)
                Nothing -> do
                    (b,e) <- lineFold $ do
                        b <- binding
                        e <- optionMaybe $ keyword "in" >> expression
                        return (b,e)
                    case e of
                        Nothing -> do
                            rec <- optionMaybe parseBindings
                            case rec of
                                Nothing -> return ([b], Nothing)
                                Just (bs, me) -> return (b:bs, me)
                        Just je -> return ([b], Just je)
        (binds, e) <- block parseBindings
        case e of
            Nothing -> liftM (L binds) (keyword "in" >> expression)
            Just je -> return $ L binds je

    binding :: IndentCharParser st (String,Λ)
    binding = flip label "binding" $ do
        funct  <- ident
        params <- many ident
        body   <- sym "=" >> expression
        return (funct, foldr Λ body params)

    keyword = reserved haskell
    ident = identifier haskell
    sym = symbol haskell

</pre>