<a href="Internal.hs12648177091998097157.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Internal.hs14338298741464689331.out.html">next</a></br></br><pre>24c24
< packPackets ∷ (Bitstream (Packet d), Monad m) ⇒ Stream m Bool → Stream m (Packet d)
---
> packPackets :: (Bitstream (Packet d), Monad m) => Stream m Bool -> Stream m (Packet d)
28c28
<       sz' ∷ Size
---
>       sz' :: Size
31d30
<               Exact n → Exact ((n+7) `div` 8)
32d30
<               Max   n → Max   ((n+7) `div` 8)
33c31
<               Unknown → Unknown
---
>               Exact n -> Exact ((n+7) `div` 8)
33a32
>               Max   n -> Max   ((n+7) `div` 8)
33a33
>               Unknown -> Unknown
36c36
<           = do r ← step s
---
>           = do r <- step s
39d38
<                      | full p    → return $ Yield p (singleton b, Just s')
40d38
<                      | otherwise → return $ Skip    (p `snoc` b , Just s')
41c39
<                  Skip    s'      → return $ Skip    (p          , Just s')
---
>                      | full p    -> return $ Yield p (singleton b, Just s')
41a40
>                      | otherwise -> return $ Skip    (p `snoc` b , Just s')
41a41
>                  Skip    s'      -> return $ Skip    (p          , Just s')
43d42
<                      | null p    → return Done
44c43
<                      | otherwise → return $ Yield p ((⊥)       , Nothing)
---
>                      | null p    -> return Done
44a44
>                      | otherwise -> return $ Yield p ((⊥)       , Nothing)
48c48
< nOctets ∷ Integral n ⇒ n → Int
---
> nOctets :: Integral n => n -> Int
53c53
< lePacketsFromNBits ∷ ( Integral n
---
> lePacketsFromNBits :: ( Integral n
58d57
<                    ⇒ n
59d57
<                    → β
60c58
<                    → Stream m (Packet Left)
---
>                    => n
60a59
>                    -> β
60a60
>                    -> Stream m (Packet Left)
76c76
< bePacketsFromNBits ∷ ( Integral n
---
> bePacketsFromNBits :: ( Integral n
81d80
<                    ⇒ n
82d80
<                    → β
83c81
<                    → Stream m (Packet Right)
---
>                    => n
83a82
>                    -> β
83a83
>                    -> Stream m (Packet Right)
99c99
< lePacketsToBits ∷ (Monad m, Integral β, Bits β) ⇒ Stream m (Packet Left) → m β
---
> lePacketsToBits :: (Monad m, Integral β, Bits β) => Stream m (Packet Left) -> m β
105c105
<           = do r ← step s
---
>           = do r <- step s
107d106
<                  Yield p s' → let !n' = (toBits p `shiftL` o) .|. n
108d106
<                                   !o' = o + length p
109d106
<                               in
110d106
<                                 go (s', o', n')
111d106
<                  Skip    s' → go (s', o, n)
112c107
<                  Done       → return n
---
>                  Yield p s' -> let !n' = (toBits p `shiftL` o) .|. n
112a108
>                                    !o' = o + length p
112a109
>                                in
112a110
>                                  go (s', o', n')
112a111
>                  Skip    s' -> go (s', o, n)
112a112
>                  Done       -> return n
114c114
< bePacketsToBits ∷ (Monad m, Integral β, Bits β) ⇒ Stream m (Packet Right) → m β
---
> bePacketsToBits :: (Monad m, Integral β, Bits β) => Stream m (Packet Right) -> m β
120c120
<           = do r ← step s
---
>           = do r <- step s
122d121
<                  Yield p s' → let !o  = length p
123d121
<                                   !n' = (n `shiftL` o) .|. toBits p
124d121
<                               in
125d121
<                                 go (s', n')
126d121
<                  Skip    s' → go (s', n)
127c122
<                  Done       → return n
---
>                  Yield p s' -> let !o  = length p
127a123
>                                    !n' = (n `shiftL` o) .|. toBits p
127a124
>                                in
127a125
>                                  go (s', n')
127a126
>                  Skip    s' -> go (s', n)
127a127
>                  Done       -> return n
127a128
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , FlexibleContexts
  , UnicodeSyntax
  #-}
module Data.Bitstream.Internal
    ( packPackets

    , lePacketsFromNBits
    , bePacketsFromNBits

    , lePacketsToBits
    , bePacketsToBits
    )
    where
import Data.Bits
import Data.Bitstream.Generic
import Data.Bitstream.Packet
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Prelude hiding (length, null)
import Prelude.Unicode

packPackets ∷ (Bitstream (Packet d), Monad m) ⇒ Stream m Bool → Stream m (Packet d)
{-# INLINEABLE packPackets #-}
packPackets (Stream step s0 sz) = Stream step' ((∅), Just s0) sz'
    where
      sz' ∷ Size
      {-# INLINE sz' #-}
      sz' = case sz of
              Exact n → Exact ((n+7) `div` 8)
              Max   n → Max   ((n+7) `div` 8)
              Unknown → Unknown
      {-# INLINE step' #-}
      step' (p, Just s)
          = do r ← step s
               case r of
                 Yield b s'
                     | full p    → return $ Yield p (singleton b, Just s')
                     | otherwise → return $ Skip    (p `snoc` b , Just s')
                 Skip    s'      → return $ Skip    (p          , Just s')
                 Done
                     | null p    → return Done
                     | otherwise → return $ Yield p ((⊥)       , Nothing)
      step' (_, Nothing)
          = return Done

nOctets ∷ Integral n ⇒ n → Int
{-# INLINE nOctets #-}
nOctets nBits
    = (fromIntegral nBits + 7) `div` 8

lePacketsFromNBits ∷ ( Integral n
                     , Integral β
                     , Bits β
                     , Monad m
                     )
                   ⇒ n
                   → β
                   → Stream m (Packet Left)
{-# INLINEABLE lePacketsFromNBits #-}
lePacketsFromNBits n0 β0 = Stream step (n0, β0) (Exact (nOctets n0))
    where
      {-# INLINE step #-}
      step (n, β)
          | n > 0
              = let !n'  = min 8 n
                    !n'' = n - n'
                    !p   = fromNBits n' β
                    !β'  = β `shiftR` 8
                in
                  return $ Yield p (n'', β')
          | otherwise
              = return Done

bePacketsFromNBits ∷ ( Integral n
                     , Integral β
                     , Bits β
                     , Monad m
                     )
                   ⇒ n
                   → β
                   → Stream m (Packet Right)
{-# INLINEABLE bePacketsFromNBits #-}
bePacketsFromNBits n0 β = Stream step (n0, nOctets n0 ⋅ 8) (Exact (nOctets n0))
    where
      {-# INLINE step #-}
      step (n, r)
          | n > 0
              = let !r'  = r - 8
                    !n'  = n - fromIntegral r'
                    !n'' = n - n'
                    !p   = fromNBits n' (β `shiftR` r')
                in
                  return $ Yield p (n'', r')
          | otherwise
              = return Done

lePacketsToBits ∷ (Monad m, Integral β, Bits β) ⇒ Stream m (Packet Left) → m β
{-# INLINEABLE lePacketsToBits #-}
lePacketsToBits (Stream step s0 _) = go (s0, 0, 0)
    where
      {-# INLINE go #-}
      go (s, o, n)
          = do r ← step s
               case r of
                 Yield p s' → let !n' = (toBits p `shiftL` o) .|. n
                                  !o' = o + length p
                              in
                                go (s', o', n')
                 Skip    s' → go (s', o, n)
                 Done       → return n

bePacketsToBits ∷ (Monad m, Integral β, Bits β) ⇒ Stream m (Packet Right) → m β
{-# INLINEABLE bePacketsToBits #-}
bePacketsToBits (Stream step s0 _) = go (s0, 0)
    where
      {-# INLINE go #-}
      go (s, n)
          = do r ← step s
               case r of
                 Yield p s' → let !o  = length p
                                  !n' = (n `shiftL` o) .|. toBits p
                              in
                                go (s', n')
                 Skip    s' → go (s', n)
                 Done       → return n
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , FlexibleContexts
  , UnicodeSyntax
  #-}
module Data.Bitstream.Internal
    ( packPackets

    , lePacketsFromNBits
    , bePacketsFromNBits

    , lePacketsToBits
    , bePacketsToBits
    )
    where
import Data.Bits
import Data.Bitstream.Generic
import Data.Bitstream.Packet
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Prelude hiding (length, null)
import Prelude.Unicode

packPackets :: (Bitstream (Packet d), Monad m) => Stream m Bool -> Stream m (Packet d)
{-# INLINEABLE packPackets #-}
packPackets (Stream step s0 sz) = Stream step' ((∅), Just s0) sz'
    where
      sz' :: Size
      {-# INLINE sz' #-}
      sz' = case sz of
              Exact n -> Exact ((n+7) `div` 8)
              Max   n -> Max   ((n+7) `div` 8)
              Unknown -> Unknown
      {-# INLINE step' #-}
      step' (p, Just s)
          = do r <- step s
               case r of
                 Yield b s'
                     | full p    -> return $ Yield p (singleton b, Just s')
                     | otherwise -> return $ Skip    (p `snoc` b , Just s')
                 Skip    s'      -> return $ Skip    (p          , Just s')
                 Done
                     | null p    -> return Done
                     | otherwise -> return $ Yield p ((⊥)       , Nothing)
      step' (_, Nothing)
          = return Done

nOctets :: Integral n => n -> Int
{-# INLINE nOctets #-}
nOctets nBits
    = (fromIntegral nBits + 7) `div` 8

lePacketsFromNBits :: ( Integral n
                     , Integral β
                     , Bits β
                     , Monad m
                     )
                   => n
                   -> β
                   -> Stream m (Packet Left)
{-# INLINEABLE lePacketsFromNBits #-}
lePacketsFromNBits n0 β0 = Stream step (n0, β0) (Exact (nOctets n0))
    where
      {-# INLINE step #-}
      step (n, β)
          | n > 0
              = let !n'  = min 8 n
                    !n'' = n - n'
                    !p   = fromNBits n' β
                    !β'  = β `shiftR` 8
                in
                  return $ Yield p (n'', β')
          | otherwise
              = return Done

bePacketsFromNBits :: ( Integral n
                     , Integral β
                     , Bits β
                     , Monad m
                     )
                   => n
                   -> β
                   -> Stream m (Packet Right)
{-# INLINEABLE bePacketsFromNBits #-}
bePacketsFromNBits n0 β = Stream step (n0, nOctets n0 ⋅ 8) (Exact (nOctets n0))
    where
      {-# INLINE step #-}
      step (n, r)
          | n > 0
              = let !r'  = r - 8
                    !n'  = n - fromIntegral r'
                    !n'' = n - n'
                    !p   = fromNBits n' (β `shiftR` r')
                in
                  return $ Yield p (n'', r')
          | otherwise
              = return Done

lePacketsToBits :: (Monad m, Integral β, Bits β) => Stream m (Packet Left) -> m β
{-# INLINEABLE lePacketsToBits #-}
lePacketsToBits (Stream step s0 _) = go (s0, 0, 0)
    where
      {-# INLINE go #-}
      go (s, o, n)
          = do r <- step s
               case r of
                 Yield p s' -> let !n' = (toBits p `shiftL` o) .|. n
                                   !o' = o + length p
                               in
                                 go (s', o', n')
                 Skip    s' -> go (s', o, n)
                 Done       -> return n

bePacketsToBits :: (Monad m, Integral β, Bits β) => Stream m (Packet Right) -> m β
{-# INLINEABLE bePacketsToBits #-}
bePacketsToBits (Stream step s0 _) = go (s0, 0)
    where
      {-# INLINE go #-}
      go (s, n)
          = do r <- step s
               case r of
                 Yield p s' -> let !o  = length p
                                   !n' = (n `shiftL` o) .|. toBits p
                               in
                                 go (s', n')
                 Skip    s' -> go (s', n)
                 Done       -> return n

</pre>