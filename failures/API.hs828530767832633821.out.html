<a href="API.hs6780301931105222769.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Apiary.hs2121578553552265483.out.html">next</a></br></br><pre>1d0
< {-# LINE 2 "src/ehc/CoreRun/API.chs" #-}
2a2
> 
114a115
> 
</pre></br><h2>original</h2></br><pre>{-# LINE 2 "src/ehc/CoreRun/API.chs" #-}

-- | CoreRun Public API
--
-- Intended for constructing basic CoreRun Programs.
--
-- CoreRun is a simplified Core intended to be used for direct interpretation/execution.
-- For semantics, see TBD
--

module UHC.Light.Compiler.CoreRun.API
  (
  -- * CoreRun AST
  -- | The datatypes making up a CoreRun program.
    Mod
  , Exp, MbExp
  , SExp
  , Alt
  -- , Pat
  , Bind
  , RRef
  , Import
  , Meta
  , DataCon

  -- * Utilities
  , CRArray

  -- * Construction functions

  -- ** References
  , mkLocLevRef
  , mkLocDifRef
  , mkGlobRef
  , mkImpRef
  , mkModRef

  -- ** Expressions
  , mkExp

  , mkVar, mkVar'
  , mkInt, mkInt'
  , mkChar, mkChar'
  , mkInteger, mkInteger'
  , mkString, mkString'
  , mkDbg, mkDbg'

  , mkApp, mkApp'
  , mkTup, mkTup'
  , mkEval
  , mkTail
  , mkCase
  , mkLam, mkLam'
  , mkLet, mkLet'
  , mkFFI, mkFFI'

  -- ** Meta
  , mkMetaDataCon, mkMetaDataType

  -- ** Modules
  , mkMod, mkMod', mkModWithMetas, mkModWithImportsMetas
  , mkImport

  -- * Conversion
  , rrefToDif

  -- * Parsing
  , parseModFromString

  -- * Running
  , runCoreRunIO

  -- * Misc utils
  , printModule
  )
  where

import UHC.Light.Compiler.Base.API
import UHC.Light.Compiler.CoreRun as CR
import UHC.Light.Compiler.CoreRun.Pretty as CR
import UHC.Light.Compiler.CoreRun.Parser as CR
import UHC.Light.Compiler.CoreRun.Run as CR
import UHC.Light.Compiler.CoreRun.Run.Val as CR
import UHC.Light.Compiler.CoreRun.Run.Val.RunExplStk as CR

import System.IO
import Control.Exception

import UHC.Util.Pretty


-- **************************************
-- Running
-- **************************************

-- | Run CoreRun in IO
-- TBD: fix dependence on whole program linked
runCoreRunIO
  :: EHCOpts        -- ^ options, e.g. for turning on tracing (if supported by runner)
     -> Mod         -- ^ the module to run
     -> IO (Either Err RVal)
runCoreRunIO opts mod = do
    catch
      (runCoreRun opts [] mod $ cmodRun opts mod)
      (\(e :: SomeException) -> hFlush stdout >> (return $ Left $ strMsg $ "runCoreRunIO: " ++ show e))

-- **************************************
-- Utilities (i.e. other stuff)
-- **************************************

-- | Pretty print 'Mod'
printModule :: EHCOpts -> Mod -> PP_Doc
printModule = ppMod'

</pre></br><h2>printed</h2></br><pre>

-- | CoreRun Public API
--
-- Intended for constructing basic CoreRun Programs.
--
-- CoreRun is a simplified Core intended to be used for direct interpretation/execution.
-- For semantics, see TBD
--

module UHC.Light.Compiler.CoreRun.API
  (
  -- * CoreRun AST
  -- | The datatypes making up a CoreRun program.
    Mod
  , Exp, MbExp
  , SExp
  , Alt
  -- , Pat
  , Bind
  , RRef
  , Import
  , Meta
  , DataCon

  -- * Utilities
  , CRArray

  -- * Construction functions

  -- ** References
  , mkLocLevRef
  , mkLocDifRef
  , mkGlobRef
  , mkImpRef
  , mkModRef

  -- ** Expressions
  , mkExp

  , mkVar, mkVar'
  , mkInt, mkInt'
  , mkChar, mkChar'
  , mkInteger, mkInteger'
  , mkString, mkString'
  , mkDbg, mkDbg'

  , mkApp, mkApp'
  , mkTup, mkTup'
  , mkEval
  , mkTail
  , mkCase
  , mkLam, mkLam'
  , mkLet, mkLet'
  , mkFFI, mkFFI'

  -- ** Meta
  , mkMetaDataCon, mkMetaDataType

  -- ** Modules
  , mkMod, mkMod', mkModWithMetas, mkModWithImportsMetas
  , mkImport

  -- * Conversion
  , rrefToDif

  -- * Parsing
  , parseModFromString

  -- * Running
  , runCoreRunIO

  -- * Misc utils
  , printModule
  )
  where

import UHC.Light.Compiler.Base.API
import UHC.Light.Compiler.CoreRun as CR
import UHC.Light.Compiler.CoreRun.Pretty as CR
import UHC.Light.Compiler.CoreRun.Parser as CR
import UHC.Light.Compiler.CoreRun.Run as CR
import UHC.Light.Compiler.CoreRun.Run.Val as CR
import UHC.Light.Compiler.CoreRun.Run.Val.RunExplStk as CR

import System.IO
import Control.Exception

import UHC.Util.Pretty


-- **************************************
-- Running
-- **************************************

-- | Run CoreRun in IO
-- TBD: fix dependence on whole program linked
runCoreRunIO
  :: EHCOpts        -- ^ options, e.g. for turning on tracing (if supported by runner)
     -> Mod         -- ^ the module to run
     -> IO (Either Err RVal)
runCoreRunIO opts mod = do
    catch
      (runCoreRun opts [] mod $ cmodRun opts mod)
      (\(e :: SomeException) -> hFlush stdout >> (return $ Left $ strMsg $ "runCoreRunIO: " ++ show e))

-- **************************************
-- Utilities (i.e. other stuff)
-- **************************************

-- | Pretty print 'Mod'
printModule :: EHCOpts -> Mod -> PP_Doc
printModule = ppMod'


</pre>