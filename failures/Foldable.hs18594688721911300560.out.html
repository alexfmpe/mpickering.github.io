<a href="Foldable.hs16376081551129841133.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Foldable.hs5305119672110010672.out.html">next</a></br></br><pre>24c24
< split ch = foldMap (\a -> ((,zero)<|>(zero,)) (ch a))
---
> split ch = foldMap (\a -> (( zero)<|>(zero,)) (ch a))
33a34
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TupleSections #-}
module Clean.Foldable where

import Clean.Core
import Clean.Classes
import Clean.Functor
import Data.Tree

class Functor t => Foldable t where
  fold :: Monoid m => t m -> m
instance Foldable Id where fold = getId
instance Foldable (Either a) where
  fold = pure zero <|> id
instance Foldable [] where
  fold [] = zero
  fold (x:t) = x+fold t
deriving instance Foldable Interleave
instance Foldable Tree where fold (Node m subs) = m + fold (map fold subs)

foldMap f e = fold (map f e)
concat = fold
sum = fold

split ch = foldMap (\a -> ((,zero)<|>(zero,)) (ch a))
partition p = split (\a -> (if p a then Left else Right) (pure a))
filter p = fst . partition p

count = sum . map (const 1)
length :: (Num n,Monoid n) => [a] -> n
length = count

foldl f e t = runEndo (foldMap (\b -> Endo (\a -> f a b)) t) e
foldr f e t = runEndo (foldMap (\b -> Endo (f b)) t) e
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TupleSections #-}
module Clean.Foldable where

import Clean.Core
import Clean.Classes
import Clean.Functor
import Data.Tree

class Functor t => Foldable t where
  fold :: Monoid m => t m -> m
instance Foldable Id where fold = getId
instance Foldable (Either a) where
  fold = pure zero <|> id
instance Foldable [] where
  fold [] = zero
  fold (x:t) = x+fold t
deriving instance Foldable Interleave
instance Foldable Tree where fold (Node m subs) = m + fold (map fold subs)

foldMap f e = fold (map f e)
concat = fold
sum = fold

split ch = foldMap (\a -> (( zero)<|>(zero,)) (ch a))
partition p = split (\a -> (if p a then Left else Right) (pure a))
filter p = fst . partition p

count = sum . map (const 1)
length :: (Num n,Monoid n) => [a] -> n
length = count

foldl f e t = runEndo (foldMap (\b -> Endo (\a -> f a b)) t) e
foldr f e t = runEndo (foldMap (\b -> Endo (f b)) t) e

</pre>