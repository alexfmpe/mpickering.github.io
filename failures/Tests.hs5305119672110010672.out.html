<a href="tests.hs388471006681910962.out.html">prev</a></br><a href="failures.html">home</a></br><a href="failures.html">next</a></br></br><pre>30d29
<     p <- $requireRight (compile (b "^foo$"))
31c30
<     $expect (equal (patternInput p) (b "^foo$"))
---
>     p <- requireRight (compile (b "^foo$"))
31a31
>     expect (equal (patternInput p) (b "^foo$"))
35d34
<     err <- $requireLeft (compile (b "^f(oo$"))
36d34
<     $expect (equal (errorMessage err) "missing ): ^f(oo$")
37c35
<     $expect (equal (errorCode err) ErrorMissingParen)
---
>     err <- requireLeft (compile (b "^f(oo$"))
37a36
>     expect (equal (errorMessage err) "missing ): ^f(oo$")
37a37
>     expect (equal (errorCode err) ErrorMissingParen)
41d40
<     p <- $requireRight (compile (b "^(foo)(?P<named1>bar)(?P<named2>baz)$"))
42c41
<     $expect (equal (patternGroups p) (V.fromList
---
>     p <- requireRight (compile (b "^(foo)(?P<named1>bar)(?P<named2>baz)$"))
42a42
>     expect (equal (patternGroups p) (V.fromList
50c50
<     p <- $requireRight (compile (b "(ba)r"))
---
>     p <- requireRight (compile (b "(ba)r"))
53c53
<         $assert (just found)
---
>         assert (just found)
55c55
<         $expect (equal (matchGroups m) (V.fromList []))
---
>         expect (equal (matchGroups m) (V.fromList []))
58c58
<         $assert (nothing found)
---
>         assert (nothing found)
61c61
<         $assert (just found)
---
>         assert (just found)
63c63
<         $expect (equal (matchGroups m) (V.fromList
---
>         expect (equal (matchGroups m) (V.fromList
69c69
<     p <- $requireRight (compile (b "(foo)|(\\d)(\\d)\\d"))
---
>     p <- requireRight (compile (b "(foo)|(\\d)(\\d)\\d"))
71c71
<     $assert (just found)
---
>     assert (just found)
73c73
<     $expect (equal (matchGroups m) (V.fromList
---
>     expect (equal (matchGroups m) (V.fromList
82d81
<     p <- $requireRight (compile (b "foo"))
83d81
<     $expect (equal (replace p (b "no match") (b "baz")) (b "no match", False))
84d81
<     $expect (equal (replace p (b "foo bar foo bar") (b "baz")) (b "baz bar foo bar", True))
85c82
<     $expect (equal (replace p (b "foo bar foo bar") (b "b\\1az")) (b "baz bar foo bar", True))
---
>     p <- requireRight (compile (b "foo"))
85a83
>     expect (equal (replace p (b "no match") (b "baz")) (b "no match", False))
85a84
>     expect (equal (replace p (b "foo bar foo bar") (b "baz")) (b "baz bar foo bar", True))
85a85
>     expect (equal (replace p (b "foo bar foo bar") (b "b\\1az")) (b "baz bar foo bar", True))
89d88
<     p <- $requireRight (compile (b "foo"))
90d88
<     $expect (equal (replaceAll p (b "no match") (b "baz")) (b "no match", 0))
91c89
<     $expect (equal (replaceAll p (b "foo bar foo bar") (b "baz")) (b "baz bar baz bar", 2))
---
>     p <- requireRight (compile (b "foo"))
91a90
>     expect (equal (replaceAll p (b "no match") (b "baz")) (b "no match", 0))
91a91
>     expect (equal (replaceAll p (b "foo bar foo bar") (b "baz")) (b "baz bar baz bar", 2))
95d94
<     p <- $requireRight (compile (b "(foo)"))
96d94
<     $expect (equal (extract p (b "no match") (b "baz")) Nothing)
97d94
<     $expect (equal (extract p (b "foo bar foo bar") (b "baz")) (Just (b "baz")))
98c95
<     $expect (equal (extract p (b "foo bar foo bar") (b "\\1baz")) (Just (b "foobaz")))
---
>     p <- requireRight (compile (b "(foo)"))
98a96
>     expect (equal (extract p (b "no match") (b "baz")) Nothing)
98a97
>     expect (equal (extract p (b "foo bar foo bar") (b "baz")) (Just (b "baz")))
98a98
>     expect (equal (extract p (b "foo bar foo bar") (b "\\1baz")) (Just (b "foobaz")))
103d102
<     utfP <- $requireRight (compileWith utfOpts (b "^(.)"))
104c103
<     $expect (equal (extract utfP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE\xBB")))
---
>     utfP <- requireRight (compileWith utfOpts (b "^(.)"))
104a104
>     expect (equal (extract utfP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE\xBB")))
107d106
<     latinP <- $requireRight (compileWith latinOpts (b "^(.)"))
108c107
<     $expect (equal (extract latinP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE")))
---
>     latinP <- requireRight (compileWith latinOpts (b "^(.)"))
108a108
>     expect (equal (extract latinP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE")))
112d111
<     $expect (equal (quoteMeta (b "^foo$")) (b "\\^foo\\$"))
113c112
<     $expect (equal (quoteMeta (b "^f\NULoo$")) (b "\\^f\\x00oo\\$"))
---
>     expect (equal (quoteMeta (b "^foo$")) (b "\\^foo\\$"))
113a113
>     expect (equal (quoteMeta (b "^f\NULoo$")) (b "\\^f\\x00oo\\$"))
116a117
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}

module Main where

import qualified Data.ByteString.Char8 as B
import qualified Data.Vector as V
import           Test.Chell

import           Regex.RE2

main :: IO ()
main = Test.Chell.defaultMain [tests]

tests :: Suite
tests = suite "re2"
    [ test_CompileSuccess
    , test_CompileFailure
    , test_PatternGroups
    , test_Match
    , test_Find
    , test_Replace
    , test_ReplaceAll
    , test_Extract
    , test_OptionEncoding
    , test_QuoteMeta
    ]

test_CompileSuccess :: Test
test_CompileSuccess = assertions "compile.success" $ do
    p <- $requireRight (compile (b "^foo$"))
    $expect (equal (patternInput p) (b "^foo$"))

test_CompileFailure :: Test
test_CompileFailure = assertions "compile.failure" $ do
    err <- $requireLeft (compile (b "^f(oo$"))
    $expect (equal (errorMessage err) "missing ): ^f(oo$")
    $expect (equal (errorCode err) ErrorMissingParen)

test_PatternGroups :: Test
test_PatternGroups = assertions "patternGroups" $ do
    p <- $requireRight (compile (b "^(foo)(?P<named1>bar)(?P<named2>baz)$"))
    $expect (equal (patternGroups p) (V.fromList
        [ Nothing
        , Just (b "named1")
        , Just (b "named2")
        ]))

test_Match :: Test
test_Match = assertions "match" $ do
    p <- $requireRight (compile (b "(ba)r"))
    do
        let found = match p (b "foo bar") 0 (length "foo bar") Nothing 0
        $assert (just found)
        let Just m = found
        $expect (equal (matchGroups m) (V.fromList []))
    do
        let found = match p (b "foo bar") 0 (length "foo bar") (Just AnchorStart) 0
        $assert (nothing found)
    do
        let found = match p (b "foo bar") 0 (length "foo bar") Nothing 1
        $assert (just found)
        let Just m = found
        $expect (equal (matchGroups m) (V.fromList
            [ Just (b "bar")
            ]))

test_Find :: Test
test_Find = assertions "find" $ do
    p <- $requireRight (compile (b "(foo)|(\\d)(\\d)\\d"))
    let found = find p (b "abc 123")
    $assert (just found)
    let Just m = found
    $expect (equal (matchGroups m) (V.fromList
        [ Just (b "123")
        , Nothing
        , Just (b "1")
        , Just (b "2")
        ]))

test_Replace :: Test
test_Replace = assertions "replace" $ do
    p <- $requireRight (compile (b "foo"))
    $expect (equal (replace p (b "no match") (b "baz")) (b "no match", False))
    $expect (equal (replace p (b "foo bar foo bar") (b "baz")) (b "baz bar foo bar", True))
    $expect (equal (replace p (b "foo bar foo bar") (b "b\\1az")) (b "baz bar foo bar", True))

test_ReplaceAll :: Test
test_ReplaceAll = assertions "replaceAll" $ do
    p <- $requireRight (compile (b "foo"))
    $expect (equal (replaceAll p (b "no match") (b "baz")) (b "no match", 0))
    $expect (equal (replaceAll p (b "foo bar foo bar") (b "baz")) (b "baz bar baz bar", 2))

test_Extract :: Test
test_Extract = assertions "extract" $ do
    p <- $requireRight (compile (b "(foo)"))
    $expect (equal (extract p (b "no match") (b "baz")) Nothing)
    $expect (equal (extract p (b "foo bar foo bar") (b "baz")) (Just (b "baz")))
    $expect (equal (extract p (b "foo bar foo bar") (b "\\1baz")) (Just (b "foobaz")))

test_OptionEncoding :: Test
test_OptionEncoding = assertions "optionEncoding" $ do
    let utfOpts = defaultOptions
    utfP <- $requireRight (compileWith utfOpts (b "^(.)"))
    $expect (equal (extract utfP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE\xBB")))

    let latinOpts = defaultOptions { optionEncoding = EncodingLatin1 }
    latinP <- $requireRight (compileWith latinOpts (b "^(.)"))
    $expect (equal (extract latinP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE")))

test_QuoteMeta :: Test
test_QuoteMeta = assertions "quoteMeta" $ do
    $expect (equal (quoteMeta (b "^foo$")) (b "\\^foo\\$"))
    $expect (equal (quoteMeta (b "^f\NULoo$")) (b "\\^f\\x00oo\\$"))

b :: String -> B.ByteString
b = B.pack
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}

module Main where

import qualified Data.ByteString.Char8 as B
import qualified Data.Vector as V
import           Test.Chell

import           Regex.RE2

main :: IO ()
main = Test.Chell.defaultMain [tests]

tests :: Suite
tests = suite "re2"
    [ test_CompileSuccess
    , test_CompileFailure
    , test_PatternGroups
    , test_Match
    , test_Find
    , test_Replace
    , test_ReplaceAll
    , test_Extract
    , test_OptionEncoding
    , test_QuoteMeta
    ]

test_CompileSuccess :: Test
test_CompileSuccess = assertions "compile.success" $ do
    p <- requireRight (compile (b "^foo$"))
    expect (equal (patternInput p) (b "^foo$"))

test_CompileFailure :: Test
test_CompileFailure = assertions "compile.failure" $ do
    err <- requireLeft (compile (b "^f(oo$"))
    expect (equal (errorMessage err) "missing ): ^f(oo$")
    expect (equal (errorCode err) ErrorMissingParen)

test_PatternGroups :: Test
test_PatternGroups = assertions "patternGroups" $ do
    p <- requireRight (compile (b "^(foo)(?P<named1>bar)(?P<named2>baz)$"))
    expect (equal (patternGroups p) (V.fromList
        [ Nothing
        , Just (b "named1")
        , Just (b "named2")
        ]))

test_Match :: Test
test_Match = assertions "match" $ do
    p <- requireRight (compile (b "(ba)r"))
    do
        let found = match p (b "foo bar") 0 (length "foo bar") Nothing 0
        assert (just found)
        let Just m = found
        expect (equal (matchGroups m) (V.fromList []))
    do
        let found = match p (b "foo bar") 0 (length "foo bar") (Just AnchorStart) 0
        assert (nothing found)
    do
        let found = match p (b "foo bar") 0 (length "foo bar") Nothing 1
        assert (just found)
        let Just m = found
        expect (equal (matchGroups m) (V.fromList
            [ Just (b "bar")
            ]))

test_Find :: Test
test_Find = assertions "find" $ do
    p <- requireRight (compile (b "(foo)|(\\d)(\\d)\\d"))
    let found = find p (b "abc 123")
    assert (just found)
    let Just m = found
    expect (equal (matchGroups m) (V.fromList
        [ Just (b "123")
        , Nothing
        , Just (b "1")
        , Just (b "2")
        ]))

test_Replace :: Test
test_Replace = assertions "replace" $ do
    p <- requireRight (compile (b "foo"))
    expect (equal (replace p (b "no match") (b "baz")) (b "no match", False))
    expect (equal (replace p (b "foo bar foo bar") (b "baz")) (b "baz bar foo bar", True))
    expect (equal (replace p (b "foo bar foo bar") (b "b\\1az")) (b "baz bar foo bar", True))

test_ReplaceAll :: Test
test_ReplaceAll = assertions "replaceAll" $ do
    p <- requireRight (compile (b "foo"))
    expect (equal (replaceAll p (b "no match") (b "baz")) (b "no match", 0))
    expect (equal (replaceAll p (b "foo bar foo bar") (b "baz")) (b "baz bar baz bar", 2))

test_Extract :: Test
test_Extract = assertions "extract" $ do
    p <- requireRight (compile (b "(foo)"))
    expect (equal (extract p (b "no match") (b "baz")) Nothing)
    expect (equal (extract p (b "foo bar foo bar") (b "baz")) (Just (b "baz")))
    expect (equal (extract p (b "foo bar foo bar") (b "\\1baz")) (Just (b "foobaz")))

test_OptionEncoding :: Test
test_OptionEncoding = assertions "optionEncoding" $ do
    let utfOpts = defaultOptions
    utfP <- requireRight (compileWith utfOpts (b "^(.)"))
    expect (equal (extract utfP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE\xBB")))

    let latinOpts = defaultOptions { optionEncoding = EncodingLatin1 }
    latinP <- requireRight (compileWith latinOpts (b "^(.)"))
    expect (equal (extract latinP (b "\xCE\xBB") (b "\\1")) (Just (b "\xCE")))

test_QuoteMeta :: Test
test_QuoteMeta = assertions "quoteMeta" $ do
    expect (equal (quoteMeta (b "^foo$")) (b "\\^foo\\$"))
    expect (equal (quoteMeta (b "^f\NULoo$")) (b "\\^f\\x00oo\\$"))

b :: String -> B.ByteString
b = B.pack

</pre>