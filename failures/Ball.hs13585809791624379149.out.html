<a href="BalanceReport.hs12648177091998097157.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Bam.hs1622650073984943658.out.html">next</a></br></br><pre>12c12
< data Ball = Ball {ballPos ∷ Position3D, ballSpeed ∷ Speed3D} deriving Show
---
> data Ball = Ball {ballPos :: Position3D, ballSpeed :: Speed3D} deriving Show
15c15
< mkBall ∷ Position → Speed → Ball
---
> mkBall :: Position -> Speed -> Ball
19c19
< ballIsFree ∷ BallState → Bool
---
> ballIsFree :: BallState -> Bool
24c24
< ballAtCenter ∷ Field → Ball
---
> ballAtCenter :: Field -> Ball
28c28
< ballIsGainedBy ∷ PlayerID → BallState → Bool
---
> ballIsGainedBy :: PlayerID -> BallState -> Bool
35c35
< bounceBall ∷ BounceDirection → (Speed3D,StdGen) → (Speed3D,StdGen)
---
> bounceBall :: BounceDirection -> (Speed3D,StdGen) -> (Speed3D,StdGen)
43c43
< radiusBall      ∷ Float -- ^ officially it should be 0.113m, but that turns out to be too small for rendering
---
> radiusBall      :: Float -- ^ officially it should be 0.113m, but that turns out to be too small for rendering
46c46
< surfaceResistance   ∷ Float -- ^ maximum speed of ball when moving over surface
---
> surfaceResistance   :: Float -- ^ maximum speed of ball when moving over surface
49c49
< airResistance       ∷ Float -- ^ maximum speed of ball when moving through air (should depend on velocity)
---
> airResistance       :: Float -- ^ maximum speed of ball when moving through air (should depend on velocity)
52c52
< accellerationSec    ∷ Float -- ^ acceleration difference per square second
---
> accellerationSec    :: Float -- ^ acceleration difference per square second
53a54
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module SoccerFun.Ball where

import SoccerFun.Prelude
import System.Random
import SoccerFun.Types
import SoccerFun.Geometry
import SoccerFun.Field

data BallState = Free Ball | GainedBy PlayerID deriving Show

data Ball = Ball {ballPos ∷ Position3D, ballSpeed ∷ Speed3D} deriving Show

{-| mkBall returns a ball with 3D dimensions. -}
mkBall ∷ Position → Speed → Ball
mkBall pos2D speed2D = Ball {ballPos = toPosition3D pos2D, ballSpeed = toSpeed3D speed2D}

{-| ballIsFree yields True iff argument is (Free ...). -}
ballIsFree ∷ BallState → Bool
ballIsFree (Free _) = True
ballIsFree _ = False

{-| ballAtCenter returns a non-moving ball at the center of the ball field. -}
ballAtCenter ∷ Field → Ball
ballAtCenter field = Ball {ballPos=zero {pxy=Position{px=flength field /2.0,py=fwidth field /2.0}}, ballSpeed = zero}

{-| ballIsGainedBy yields True iff the ball is in possession by the given player. -}
ballIsGainedBy ∷ PlayerID → BallState → Bool
ballIsGainedBy id (GainedBy id') = id == id'
ballIsGainedBy _ _ = False

data BounceDirection = Down | Up | Forward | Back

{-| Function used for giving a new random direction towards the given BounceDirection (#param1) -}
bounceBall ∷ BounceDirection → (Speed3D,StdGen) → (Speed3D,StdGen)
bounceBall Up (speed,seed) = let (p,seed1) = random seed in (speed {vz = (10.0-vz speed ) * p}, seed1)
bounceBall Down (speed,seed) = let (p,seed1) = random seed in (speed {vz = vz speed  * p}, seed1)
bounceBall Forward (speed@Speed3D{vxy=sp2d@Speed{direction=d}},seed) = let (p,seed1) = random seed in (speed {vxy = sp2d {direction=d + p*pi/2.0 }},seed1)
bounceBall Back (speed@Speed3D{vxy=sp2d@Speed{direction=d}},seed) = let (p,seed1) = random seed in (speed {vxy = sp2d {direction=d - p*pi/2.0 }},seed1)

------------------------------------------------------------------------------

radiusBall      ∷ Float -- ^ officially it should be 0.113m, but that turns out to be too small for rendering
radiusBall      = 0.4

surfaceResistance   ∷ Float -- ^ maximum speed of ball when moving over surface
surfaceResistance   = 0.85

airResistance       ∷ Float -- ^ maximum speed of ball when moving through air (should depend on velocity)
airResistance       = 0.95

accellerationSec    ∷ Float -- ^ acceleration difference per square second
accellerationSec    = 9.81
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
module SoccerFun.Ball where

import SoccerFun.Prelude
import System.Random
import SoccerFun.Types
import SoccerFun.Geometry
import SoccerFun.Field

data BallState = Free Ball | GainedBy PlayerID deriving Show

data Ball = Ball {ballPos :: Position3D, ballSpeed :: Speed3D} deriving Show

{-| mkBall returns a ball with 3D dimensions. -}
mkBall :: Position -> Speed -> Ball
mkBall pos2D speed2D = Ball {ballPos = toPosition3D pos2D, ballSpeed = toSpeed3D speed2D}

{-| ballIsFree yields True iff argument is (Free ...). -}
ballIsFree :: BallState -> Bool
ballIsFree (Free _) = True
ballIsFree _ = False

{-| ballAtCenter returns a non-moving ball at the center of the ball field. -}
ballAtCenter :: Field -> Ball
ballAtCenter field = Ball {ballPos=zero {pxy=Position{px=flength field /2.0,py=fwidth field /2.0}}, ballSpeed = zero}

{-| ballIsGainedBy yields True iff the ball is in possession by the given player. -}
ballIsGainedBy :: PlayerID -> BallState -> Bool
ballIsGainedBy id (GainedBy id') = id == id'
ballIsGainedBy _ _ = False

data BounceDirection = Down | Up | Forward | Back

{-| Function used for giving a new random direction towards the given BounceDirection (#param1) -}
bounceBall :: BounceDirection -> (Speed3D,StdGen) -> (Speed3D,StdGen)
bounceBall Up (speed,seed) = let (p,seed1) = random seed in (speed {vz = (10.0-vz speed ) * p}, seed1)
bounceBall Down (speed,seed) = let (p,seed1) = random seed in (speed {vz = vz speed  * p}, seed1)
bounceBall Forward (speed@Speed3D{vxy=sp2d@Speed{direction=d}},seed) = let (p,seed1) = random seed in (speed {vxy = sp2d {direction=d + p*pi/2.0 }},seed1)
bounceBall Back (speed@Speed3D{vxy=sp2d@Speed{direction=d}},seed) = let (p,seed1) = random seed in (speed {vxy = sp2d {direction=d - p*pi/2.0 }},seed1)

------------------------------------------------------------------------------

radiusBall      :: Float -- ^ officially it should be 0.113m, but that turns out to be too small for rendering
radiusBall      = 0.4

surfaceResistance   :: Float -- ^ maximum speed of ball when moving over surface
surfaceResistance   = 0.85

airResistance       :: Float -- ^ maximum speed of ball when moving through air (should depend on velocity)
airResistance       = 0.95

accellerationSec    :: Float -- ^ acceleration difference per square second
accellerationSec    = 9.81

</pre>