<a href="Bits.hs500782188657821123.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Bitstream.hs585640194937186357.out.html">next</a></br></br><pre>199c199
< instance Show (Packet d) ⇒ Show (Bitstream d) where
---
> instance Show (Packet d) => Show (Bitstream d) where
212c212
< instance G.Bitstream (Bitstream d) ⇒ Eq (Bitstream d) where
---
> instance G.Bitstream (Bitstream d) => Eq (Bitstream d) where
227c227
< instance G.Bitstream (Bitstream d) ⇒ Ord (Bitstream d) where
---
> instance G.Bitstream (Bitstream d) => Ord (Bitstream d) where
238c238
< instance G.Bitstream (Bitstream d) ⇒ Monoid (Bitstream d) where
---
> instance G.Bitstream (Bitstream d) => Monoid (Bitstream d) where
353c353
< strictStream ∷ G.Bitstream (Packet d) ⇒ Bitstream d → S.Stream Bool
---
> strictStream :: G.Bitstream (Packet d) => Bitstream d -> S.Stream Bool
356c356
<     = {-# CORE "Strict Bitstream stream" #-}
---
>     = {-# CORE Strict Bitstream stream #-}
361c361
< strictUnstream ∷ G.Bitstream (Packet d) ⇒ S.Stream Bool → Bitstream d
---
> strictUnstream :: G.Bitstream (Packet d) => S.Stream Bool -> Bitstream d
364c364
<     = {-# CORE "Strict Bitstream unstream" #-}
---
>     = {-# CORE Strict Bitstream unstream #-}
367c367
< strictCons ∷ G.Bitstream (Packet d) ⇒ Bool → Bitstream d → Bitstream d
---
> strictCons :: G.Bitstream (Packet d) => Bool -> Bitstream d -> Bitstream d
372d371
<         p | length p < (8 ∷ Int)
373c372
<                 → Bitstream (l+1) ((b `cons` p) `SV.cons` SV.tail v)
---
>         p | length p < (8 :: Int)
373a373
>                 -> Bitstream (l+1) ((b `cons` p) `SV.cons` SV.tail v)
375c375
<                 → Bitstream (l+1) (singleton b `SV.cons` v)
---
>                 -> Bitstream (l+1) (singleton b `SV.cons` v)
377c377
< strictSnoc ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool → Bitstream d
---
> strictSnoc :: G.Bitstream (Packet d) => Bitstream d -> Bool -> Bitstream d
382d381
<         p | length p < (8 ∷ Int)
383c382
<                 → Bitstream (l+1) (SV.init v `SV.snoc` (p `snoc` b))
---
>         p | length p < (8 :: Int)
383a383
>                 -> Bitstream (l+1) (SV.init v `SV.snoc` (p `snoc` b))
385c385
<                 → Bitstream (l+1) (v `SV.snoc` singleton b)
---
>                 -> Bitstream (l+1) (v `SV.snoc` singleton b)
387c387
< strictAppend ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d → Bitstream d
---
> strictAppend :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d -> Bitstream d
392c392
< strictTail ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
---
> strictTail :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
397d396
<         p' | null p'   → Bitstream (l-1) (SV.tail v)
398c397
<            | otherwise → Bitstream (l-1) (p' `SV.cons` SV.tail v)
---
>         p' | null p'   -> Bitstream (l-1) (SV.tail v)
398a398
>            | otherwise -> Bitstream (l-1) (p' `SV.cons` SV.tail v)
400c400
< strictInit ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
---
> strictInit :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
405d404
<         p' | null p'   → Bitstream (l-1) (SV.init v)
406c405
<            | otherwise → Bitstream (l-1) (SV.init v `SV.snoc` p')
---
>         p' | null p'   -> Bitstream (l-1) (SV.init v)
406a406
>            | otherwise -> Bitstream (l-1) (SV.init v `SV.snoc` p')
408c408
< strictMap ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
---
> strictMap :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
413c413
< strictReverse ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
---
> strictReverse :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
418c418
< strictConcat ∷ G.Bitstream (Bitstream d) ⇒ [Bitstream d] → Bitstream d
---
> strictConcat :: G.Bitstream (Bitstream d) => [Bitstream d] -> Bitstream d
421c421
<     = let (!l, !vs) = L.mapAccumL (\n x → (n + length x, toPackets x)) 0 xs
---
>     = let (!l, !vs) = L.mapAccumL (\n x -> (n + length x, toPackets x)) 0 xs
426c426
< strictScanl ∷ G.Bitstream (Bitstream d) ⇒ (Bool → Bool → Bool) → Bool → Bitstream d → Bitstream d
---
> strictScanl :: G.Bitstream (Bitstream d) => (Bool -> Bool -> Bool) -> Bool -> Bitstream d -> Bitstream d
431c431
< strictTake ∷ ( Integral n
---
> strictTake :: ( Integral n
435d434
<            ⇒ n
436d434
<            → Bitstream d
437c435
<            → Bitstream d
---
>            => n
437a436
>            -> Bitstream d
437a437
>            -> Bitstream d
446d445
<                           → let !mv' = New.apply (MVector.take np) mv
447d445
<                                 !v   = GV.new mv'
448d445
<                             in
449c446
<                               Bitstream l v
---
>                           -> let !mv' = New.apply (MVector.take np) mv
449a447
>                                  !v   = GV.new mv'
449a448
>                              in
449a449
>                                Bitstream l v
461c461
<                             !mv' = New.modify (\x → MVector.write x np p') mv
---
>                             !mv' = New.modify (\x -> MVector.write x np p') mv
465c465
< strictDrop ∷ (Integral n, G.Bitstream (Packet d)) ⇒ n → Bitstream d → Bitstream d
---
> strictDrop :: (Integral n, G.Bitstream (Packet d)) => n -> Bitstream d -> Bitstream d
470c470
<                     (# l, v #) → Bitstream l v
---
>                     (# l, v #) -> Bitstream l v
478d477
<                      p' | null p'   → go (n - length p) (l - length p) (SV.tail v)
479c478
<                         | otherwise → (# l - length p + length p'
---
>                      p' | null p'   -> go (n - length p) (l - length p) (SV.tail v)
479a479
>                         | otherwise -> (# l - length p + length p'
482c482
< strictTakeWhile ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
---
> strictTakeWhile :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
493c493
<                 = do r ← step s
---
>                 = do r <- step s
496d495
<                            → case takeWhile f p of
497d495
<                                 p' | p ≡ p'    → return $ Yield p' (Just s')
498c496
<                                    | otherwise → return $ Yield p' Nothing
---
>                            -> case takeWhile f p of
498a497
>                                 p' | p ≡ p'    -> return $ Yield p' (Just s')
498a498
>                                    | otherwise -> return $ Yield p' Nothing
500c500
<                            → return $ Skip (Just s')
---
>                            -> return $ Skip (Just s')
502c502
<                            → return Done
---
>                            -> return Done
504c504
< strictDropWhile ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
---
> strictDropWhile :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
508c508
<                                         (# l, v #) → Bitstream l v
---
>                                         (# l, v #) -> Bitstream l v
516d515
<                    p' | null p'   → go (l - pLen) (SV.tail v)
517c516
<                       | otherwise → (# l - pLen + length p'
---
>                    p' | null p'   -> go (l - pLen) (SV.tail v)
517a517
>                       | otherwise -> (# l - pLen + length p'
520c520
< strictFilter ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
---
> strictFilter :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
530c530
<                 = do r ← step s
---
>                 = do r <- step s
532d531
<                        Yield p s' → case filter f p of
533d531
<                                        p' | null p'   → return $ Skip s'
534d531
<                                           | otherwise → return $ Yield p' s'
535d531
<                        Skip    s' → return $ Skip s'
536c532
<                        Done       → return Done
---
>                        Yield p s' -> case filter f p of
536a533
>                                        p' | null p'   -> return $ Skip s'
536a534
>                                           | otherwise -> return $ Yield p' s'
536a535
>                        Skip    s' -> return $ Skip s'
536a536
>                        Done       -> return Done
538d537
< strictHead ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
539d537
< {-# RULES "head → strictHead" [1]
540c538
<     ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
---
> strictHead :: G.Bitstream (Packet d) => Bitstream d -> Bool
540a539
> {-# RULES "head \8594 strictHead" [1]
540a540
>     forall(v :: G.Bitstream (Packet d) => Bitstream d).
545d544
< strictLast ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
546d544
< {-# RULES "last → strictLast" [1]
547c545
<     ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
---
> strictLast :: G.Bitstream (Packet d) => Bitstream d -> Bool
547a546
> {-# RULES "last \8594 strictLast" [1]
547a547
>     forall(v :: G.Bitstream (Packet d) => Bitstream d).
552d551
< strictNull ∷ Bitstream d → Bool
553c552
< {-# RULES "null → strictNull" [1] null = strictNull #-}
---
> strictNull :: Bitstream d -> Bool
553a553
> {-# RULES "null \8594 strictNull" [1] null = strictNull #-}
558d557
< strictLength ∷ Num n ⇒ Bitstream d → n
559c558
< {-# RULES "length → strictLength" [1] length = strictLength #-}
---
> strictLength :: Num n => Bitstream d -> n
559a559
> {-# RULES "length \8594 strictLength" [1] length = strictLength #-}
563d562
< strictAnd ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
564d562
< {-# RULES "and → strictAnd" [1]
565c563
<     ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
---
> strictAnd :: G.Bitstream (Packet d) => Bitstream d -> Bool
565a564
> {-# RULES "and \8594 strictAnd" [1]
565a565
>     forall(v :: G.Bitstream (Packet d) => Bitstream d).
571d570
< strictOr ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
572d570
< {-# RULES "or → strictOr" [1]
573c571
<     ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
---
> strictOr :: G.Bitstream (Packet d) => Bitstream d -> Bool
573a572
> {-# RULES "or \8594 strictOr" [1]
573a573
>     forall(v :: G.Bitstream (Packet d) => Bitstream d).
579d578
< strictIndex ∷ (G.Bitstream (Packet d), Integral n, Show n) ⇒ Bitstream d → n → Bool
580d578
< {-# RULES "(!!) → strictIndex" [1]
581c579
<     ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d) n.
---
> strictIndex :: (G.Bitstream (Packet d), Integral n, Show n) => Bitstream d -> n -> Bool
581a580
> {-# RULES "(!!) \8594 strictIndex" [1]
581a581
>     forall(v :: G.Bitstream (Packet d) => Bitstream d) n.
592d591
<                           p | i < length p → p !! i
593c592
<                             | otherwise    → go (SV.tail v) (i - length p)
---
>                           p | i < length p -> p !! i
593a593
>                             | otherwise    -> go (SV.tail v) (i - length p)
595c595
< emptyStream ∷ α
---
> emptyStream :: α
600c600
< indexOutOfRange ∷ (Integral n, Show n) ⇒ n → α
---
> indexOutOfRange :: (Integral n, Show n) => n -> α
606c606
< fromByteString ∷ BS.ByteString → Bitstream d
---
> fromByteString :: BS.ByteString -> Bitstream d
610c610
<       nOctets ∷ Int
---
>       nOctets :: Int
614c614
<       go bs = do (o, bs') ← BS.uncons bs
---
>       go bs = do (o, bs') <- BS.uncons bs
621c621
< toByteString ∷ ∀d. ( G.Bitstream (Bitstream d)
---
> toByteString :: foralld. ( G.Bitstream (Bitstream d)
623c623
<                                      ) ⇒ Bitstream d → BS.ByteString
---
>                                      ) => Bitstream d -> BS.ByteString
625c625
<              ∘ (packPackets ∷ Stream Id Bool → Stream Id (Packet d))
---
>              ∘ (packPackets :: Stream Id Bool -> Stream Id (Packet d))
628c628
< unstreamBS ∷ Stream Id (Packet d) → BS.ByteString
---
> unstreamBS :: Stream Id (Packet d) -> BS.ByteString
632d631
<         Just n  → fst $ BS.unfoldrN n (unId ∘ go) s0
633c632
<         Nothing → BS.unfoldr (unId ∘ go) s0
---
>         Just n  -> fst $ BS.unfoldrN n (unId ∘ go) s0
633a633
>         Nothing -> BS.unfoldr (unId ∘ go) s0
636c636
<         go s = do r ← step s
---
>         go s = do r <- step s
638d637
<                     Yield p s' → return $ Just (toOctet p, s')
639d637
<                     Skip    s' → go s'
640c638
<                     Done       → return Nothing
---
>                     Yield p s' -> return $ Just (toOctet p, s')
640a639
>                     Skip    s' -> go s'
640a640
>                     Done       -> return Nothing
643c643
< countBits ∷ (G.Bitstream (Packet d), Num n) ⇒ SV.Vector (Packet d) → n
---
> countBits :: (G.Bitstream (Packet d), Num n) => SV.Vector (Packet d) -> n
645c645
< countBits = SV.foldl' (\n p → n + length p) 0
---
> countBits = SV.foldl' (\n p -> n + length p) 0
648c648
< fromPackets ∷ G.Bitstream (Packet d) ⇒ SV.Vector (Packet d) → Bitstream d
---
> fromPackets :: G.Bitstream (Packet d) => SV.Vector (Packet d) -> Bitstream d
656c656
< unsafeFromPackets ∷ G.Bitstream (Packet d) ⇒ Int → SV.Vector (Packet d) → Bitstream d
---
> unsafeFromPackets :: G.Bitstream (Packet d) => Int -> SV.Vector (Packet d) -> Bitstream d
661c661
< toPackets ∷ Bitstream d → SV.Vector (Packet d)
---
> toPackets :: Bitstream d -> SV.Vector (Packet d)
666c666
< streamPackets ∷ Bitstream d → S.Stream (Packet d)
---
> streamPackets :: Bitstream d -> S.Stream (Packet d)
671c671
< unstreamPackets ∷ G.Bitstream (Packet d) ⇒ S.Stream (Packet d) → Bitstream d
---
> unstreamPackets :: G.Bitstream (Packet d) => S.Stream (Packet d) -> Bitstream d
681c681
<     ∀s. streamPackets (unstreamPackets s) = s
---
>     foralls. streamPackets (unstreamPackets s) = s
684c684
<     ∀v. unstreamPackets (streamPackets v) = v
---
>     forallv. unstreamPackets (streamPackets v) = v
690c690
< directionLToR ∷ Bitstream Left → Bitstream Right
---
> directionLToR :: Bitstream Left -> Bitstream Right
697c697
< directionRToL ∷ Bitstream Right → Bitstream Left
---
> directionRToL :: Bitstream Right -> Bitstream Left
704c704
< getContents ∷ G.Bitstream (Packet d) ⇒ IO (Bitstream d)
---
> getContents :: G.Bitstream (Packet d) => IO (Bitstream d)
710c710
< putBits ∷ ( G.Bitstream (Bitstream d)
---
> putBits :: ( G.Bitstream (Bitstream d)
713d712
<         ⇒ Bitstream d
714c713
<         → IO ()
---
>         => Bitstream d
714a714
>         -> IO ()
722c722
< interact ∷ ( G.Bitstream (Bitstream d)
---
> interact :: ( G.Bitstream (Bitstream d)
725d724
<          ⇒ (Bitstream d → Bitstream d)
726c725
<          → IO ()
---
>          => (Bitstream d -> Bitstream d)
726a726
>          -> IO ()
734c734
< readFile ∷ G.Bitstream (Packet d) ⇒ FilePath → IO (Bitstream d)
---
> readFile :: G.Bitstream (Packet d) => FilePath -> IO (Bitstream d)
739c739
< writeFile ∷ ( G.Bitstream (Bitstream d)
---
> writeFile :: ( G.Bitstream (Bitstream d)
742d741
<           ⇒ FilePath
743d741
<           → Bitstream d
744c742
<           → IO ()
---
>           => FilePath
744a743
>           -> Bitstream d
744a744
>           -> IO ()
749c749
< appendFile ∷ ( G.Bitstream (Bitstream d)
---
> appendFile :: ( G.Bitstream (Bitstream d)
752d751
<            ⇒ FilePath
753d751
<            → Bitstream d
754c752
<            → IO ()
---
>            => FilePath
754a753
>            -> Bitstream d
754a754
>            -> IO ()
767c767
< hGetContents ∷ G.Bitstream (Packet d) ⇒ Handle → IO (Bitstream d)
---
> hGetContents :: G.Bitstream (Packet d) => Handle -> IO (Bitstream d)
779c779
< hGet ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
---
> hGet :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
787c787
< hGetSome ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
---
> hGetSome :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
794c794
< hGetNonBlocking ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
---
> hGetNonBlocking :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
799c799
< hPut ∷ ( G.Bitstream (Bitstream d)
---
> hPut :: ( G.Bitstream (Bitstream d)
802d801
<      ⇒ Handle
803d801
<      → Bitstream d
804c802
<      → IO ()
---
>      => Handle
804a803
>      -> Bitstream d
804a804
>      -> IO ()
806a807
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , FlexibleContexts
  , FlexibleInstances
  , ScopedTypeVariables
  , UnboxedTuples
  , UndecidableInstances
  , UnicodeSyntax
  #-}
-- | Fast, packed, strict bit streams (i.e. list of 'Bool's) with
-- semi-automatic stream fusion.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions. e.g.
--
-- > import qualified Data.BitStream as BS
--
-- Strict 'Bitstream's are made of strict 'SV.Vector' of 'Packet's,
-- and each 'Packet's have at least 1 bit.
module Data.Bitstream
    ( -- * Data types
      Bitstream
    , Left
    , Right

      -- * Introducing and eliminating 'Bitstream's
    , empty
    , (∅)
    , singleton
    , pack
    , unpack
    , fromPackets
    , unsafeFromPackets
    , toPackets

      -- ** Converting from\/to strict 'BS.ByteString's
    , fromByteString
    , toByteString

    -- ** Converting from\/to 'Bits''
    , fromBits
    , fromNBits
    , toBits

      -- ** Converting from\/to 'S.Stream's
    , stream
    , unstream
    , streamPackets
    , unstreamPackets

      -- * Changing bit order in octets
    , directionLToR
    , directionRToL

      -- * Basic interface
    , cons
    , snoc
    , append
    , (⧺)
    , head
    , last
    , tail
    , init
    , null
    , length

      -- * Transforming 'Bitstream's
    , map
    , reverse

      -- * Reducing 'Bitstream's
    , foldl
    , foldl'
    , foldl1
    , foldl1'
    , foldr
    , foldr1

      -- ** Special folds
    , concat
    , concatMap
    , and
    , or
    , any
    , all

      -- * Building 'Bitstream's
      -- ** Scans
    , scanl
    , scanl1
    , scanr
    , scanr1

      -- ** Replication
    , replicate

      -- ** Unfolding
    , unfoldr
    , unfoldrN

      -- * Substreams
    , take
    , drop
    , takeWhile
    , dropWhile
    , span
    , break

      -- * Searching streams
      -- ** Searching by equality
    , elem
    , (∈)
    , (∋)
    , notElem
    , (∉)
    , (∌)

      -- ** Searching with a predicate
    , find
    , filter
    , partition

      -- ** Indexing streams
    , (!!)
    , elemIndex
    , elemIndices
    , findIndex
    , findIndices

      -- * Zipping and unzipping streams
    , zip
    , zip3
    , zip4
    , zip5
    , zip6
    , zipWith
    , zipWith3
    , zipWith4
    , zipWith5
    , zipWith6
    , unzip
    , unzip3
    , unzip4
    , unzip5
    , unzip6

    -- * I/O with 'Bitstream's
    -- ** Standard input and output
    , getContents
    , putBits
    , interact

    -- ** Files
    , readFile
    , writeFile
    , appendFile

    -- ** I/O with 'Handle's
    , hGetContents
    , hGet
    , hGetSome
    , hGetNonBlocking
    , hPut
    )
    where
import Data.Bitstream.Generic hiding (Bitstream)
import qualified Data.Bitstream.Generic as G
import Data.Bitstream.Internal
import Data.Bitstream.Packet
import qualified Data.ByteString as BS
import qualified Data.List as L
import Data.Monoid
import qualified Data.Vector.Generic as GV
import qualified Data.Vector.Generic.New as New
import qualified Data.Vector.Generic.Mutable as MVector
import qualified Data.Vector.Storable as SV
import qualified Data.Vector.Fusion.Stream as S
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Data.Vector.Fusion.Util
import Prelude ( Bool(..), Eq(..), Int, Integral, Maybe(..), Monad(..), Num(..)
               , Ord(..), Show(..), ($), error, fmap, fromIntegral, fst
               , otherwise
               )
import Prelude.Unicode hiding ((⧺), (∈), (∉))
import System.IO (FilePath, Handle, IO)

-- | A space-efficient representation of a 'Bool' vector, supporting
-- many efficient operations. 'Bitstream's have an idea of
-- /directions/ controlling how octets are interpreted as bits. There
-- are two types of concrete 'Bitstream's: @'Bitstream' 'Left'@ and
-- @'Bitstream' 'Right'@.
data Bitstream d
    = Bitstream {-# UNPACK #-} !Int -- bit length
                {-# UNPACK #-} !(SV.Vector (Packet d))
-- THINKME: The bit length should only be a hint, just like stream
-- size.

instance Show (Packet d) ⇒ Show (Bitstream d) where
    {-# INLINEABLE show #-}
    show (Bitstream _ v0)
        = L.concat
          [ "(S"
          , L.concat (L.unfoldr go v0)
          , ")"
          ]
        where
          {-# INLINE go #-}
          go v | SV.null v = Nothing
               | otherwise = Just (show (SV.head v), SV.tail v)

instance G.Bitstream (Bitstream d) ⇒ Eq (Bitstream d) where
    {-# INLINE (==) #-}
    x == y = stream x ≡ stream y

-- | 'Bitstream's are lexicographically ordered.
--
-- @
-- let x = 'pack' ['True' , 'False', 'False']
--     y = 'pack' ['False', 'True' , 'False']
--     z = 'pack' ['False']
-- in
--   [ 'compare' x y -- 'GT'
--   , 'compare' z y -- 'LT'
--   ]
-- @
instance G.Bitstream (Bitstream d) ⇒ Ord (Bitstream d) where
    {-# INLINE compare #-}
    x `compare` y = stream x `compare` stream y

-- | 'Bitstream' forms 'Monoid' in the same way as ordinary lists:
--
-- @
-- 'mempty'  = 'empty'
-- 'mappend' = 'append'
-- 'mconcat' = 'concat'
-- @
instance G.Bitstream (Bitstream d) ⇒ Monoid (Bitstream d) where
    mempty  = (∅)
    mappend = (⧺)
    mconcat = concat

instance G.Bitstream (Bitstream Left) where
    {-# INLINE basicStream #-}
    basicStream = strictStream

    {-# INLINE basicUnstream #-}
    basicUnstream = strictUnstream

    {-# INLINE basicCons #-}
    basicCons = strictCons

    {-# INLINE basicSnoc #-}
    basicSnoc = strictSnoc

    {-# INLINE basicAppend #-}
    basicAppend = strictAppend

    {-# INLINE basicTail #-}
    basicTail = strictTail

    {-# INLINE basicInit #-}
    basicInit = strictInit

    {-# INLINE basicMap #-}
    basicMap = strictMap

    {-# INLINE basicReverse #-}
    basicReverse = strictReverse

    {-# INLINE basicConcat #-}
    basicConcat = strictConcat

    {-# INLINE basicScanl #-}
    basicScanl = strictScanl

    {-# INLINE basicTake #-}
    basicTake = strictTake

    {-# INLINE basicDrop #-}
    basicDrop = strictDrop

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = strictTakeWhile

    {-# INLINE basicDropWhile #-}
    basicDropWhile = strictDropWhile

    {-# INLINE basicFilter #-}
    basicFilter = strictFilter

    {-# INLINE basicFromNBits #-}
    basicFromNBits = (unstreamPackets ∘) ∘ lePacketsFromNBits

    {-# INLINE basicToBits #-}
    basicToBits = unId ∘ lePacketsToBits ∘ streamPackets

instance G.Bitstream (Bitstream Right) where
    {-# INLINE basicStream #-}
    basicStream = strictStream

    {-# INLINE basicUnstream #-}
    basicUnstream = strictUnstream

    {-# INLINE basicCons #-}
    basicCons = strictCons

    {-# INLINE basicSnoc #-}
    basicSnoc = strictSnoc

    {-# INLINE basicAppend #-}
    basicAppend = strictAppend

    {-# INLINE basicTail #-}
    basicTail = strictTail

    {-# INLINE basicInit #-}
    basicInit = strictInit

    {-# INLINE basicMap #-}
    basicMap = strictMap

    {-# INLINE basicReverse #-}
    basicReverse = strictReverse

    {-# INLINE basicConcat #-}
    basicConcat = strictConcat

    {-# INLINE basicScanl #-}
    basicScanl = strictScanl

    {-# INLINE basicTake #-}
    basicTake = strictTake

    {-# INLINE basicDrop #-}
    basicDrop = strictDrop

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = strictTakeWhile

    {-# INLINE basicDropWhile #-}
    basicDropWhile = strictDropWhile

    {-# INLINE basicFilter #-}
    basicFilter = strictFilter

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits = (unstreamPackets ∘) ∘ bePacketsFromNBits

    {-# INLINEABLE basicToBits #-}
    basicToBits = unId ∘ bePacketsToBits ∘ streamPackets

strictStream ∷ G.Bitstream (Packet d) ⇒ Bitstream d → S.Stream Bool
{-# INLINE strictStream #-}
strictStream (Bitstream l v)
    = {-# CORE "Strict Bitstream stream" #-}
      S.concatMap stream (GV.stream v)
      `S.sized`
      Exact l

strictUnstream ∷ G.Bitstream (Packet d) ⇒ S.Stream Bool → Bitstream d
{-# INLINE strictUnstream #-}
strictUnstream
    = {-# CORE "Strict Bitstream unstream" #-}
      unstreamPackets ∘ packPackets

strictCons ∷ G.Bitstream (Packet d) ⇒ Bool → Bitstream d → Bitstream d
{-# INLINEABLE strictCons #-}
strictCons b (Bitstream 0 _) = Bitstream 1 (SV.singleton (singleton b))
strictCons b (Bitstream l v)
    = case SV.head v of
        p | length p < (8 ∷ Int)
                → Bitstream (l+1) ((b `cons` p) `SV.cons` SV.tail v)
          | otherwise
                → Bitstream (l+1) (singleton b `SV.cons` v)

strictSnoc ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool → Bitstream d
{-# INLINEABLE strictSnoc #-}
strictSnoc (Bitstream 0 _) b = Bitstream 1 (SV.singleton (singleton b))
strictSnoc (Bitstream l v) b
    = case SV.last v of
        p | length p < (8 ∷ Int)
                → Bitstream (l+1) (SV.init v `SV.snoc` (p `snoc` b))
          | otherwise
                → Bitstream (l+1) (v `SV.snoc` singleton b)

strictAppend ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d → Bitstream d
{-# INLINE strictAppend #-}
strictAppend (Bitstream lx x) (Bitstream ly y)
    = Bitstream (lx + ly) (x SV.++ y)

strictTail ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
{-# INLINEABLE strictTail #-}
strictTail (Bitstream 0 _) = emptyStream
strictTail (Bitstream l v)
    = case tail (SV.head v) of
        p' | null p'   → Bitstream (l-1) (SV.tail v)
           | otherwise → Bitstream (l-1) (p' `SV.cons` SV.tail v)

strictInit ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
{-# INLINEABLE strictInit #-}
strictInit (Bitstream 0 _) = emptyStream
strictInit (Bitstream l v)
    = case init (SV.last v) of
        p' | null p'   → Bitstream (l-1) (SV.init v)
           | otherwise → Bitstream (l-1) (SV.init v `SV.snoc` p')

strictMap ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
{-# INLINE strictMap #-}
strictMap f (Bitstream l v)
    = Bitstream l (SV.map (map f) v)

strictReverse ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bitstream d
{-# INLINE strictReverse #-}
strictReverse (Bitstream l v)
    = Bitstream l (SV.reverse (SV.map reverse v))

strictConcat ∷ G.Bitstream (Bitstream d) ⇒ [Bitstream d] → Bitstream d
{-# INLINEABLE strictConcat #-}
strictConcat xs
    = let (!l, !vs) = L.mapAccumL (\n x → (n + length x, toPackets x)) 0 xs
          !v        = SV.concat vs
      in
        Bitstream l v

strictScanl ∷ G.Bitstream (Bitstream d) ⇒ (Bool → Bool → Bool) → Bool → Bitstream d → Bitstream d
{-# INLINE strictScanl #-}
strictScanl f b
    = unstream ∘ S.scanl f b ∘ stream

strictTake ∷ ( Integral n
             , G.Bitstream (Bitstream d)
             , G.Bitstream (Packet d)
             )
           ⇒ n
           → Bitstream d
           → Bitstream d
{-# INLINEABLE strictTake #-}
strictTake n0 (Bitstream l0 v0)
    | l0 ≡ 0    = (∅)
    | n0 ≤ 0    = (∅)
    | otherwise = let !e = New.create (MVector.new (SV.length v0))
                  in
                    case go n0 v0 0 0 e of
                      (# l, np, mv #)
                          → let !mv' = New.apply (MVector.take np) mv
                                !v   = GV.new mv'
                            in
                              Bitstream l v
    where
      {-# INLINE go #-}
      go 0 _ l np mv  = (# l, np, mv #)
      go n v l np mv
          | SV.null v = (# l, np, mv #)
          | otherwise = let !p   = SV.head v
                            !p'  = take n p
                            !n'  = n - length p'
                            !v'  = SV.tail v
                            !l'  = l + length p'
                            !np' = np + 1
                            !mv' = New.modify (\x → MVector.write x np p') mv
                        in
                          go n' v' l' np' mv'

strictDrop ∷ (Integral n, G.Bitstream (Packet d)) ⇒ n → Bitstream d → Bitstream d
{-# INLINEABLE strictDrop #-}
strictDrop n0 (Bitstream l0 v0)
    | n0 ≤ 0    = Bitstream l0 v0
    | otherwise = case go n0 l0 v0 of
                    (# l, v #) → Bitstream l v
    where
      {-# INLINE go #-}
      go 0 l v = (# l, v #)
      go _ 0 v = (# 0, v #)
      go n l v = let !p = SV.head v
                 in
                   case drop n p of
                     p' | null p'   → go (n - length p) (l - length p) (SV.tail v)
                        | otherwise → (# l - length p + length p'
                                       , p' `SV.cons` SV.tail v #)

strictTakeWhile ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
{-# INLINEABLE strictTakeWhile #-}
strictTakeWhile f
    = unstreamPackets ∘ takeWhilePS ∘ streamPackets
    where
      {-# INLINE takeWhilePS #-}
      takeWhilePS (Stream step s0 sz) = Stream step' (Just s0) (toMax sz)
          where
            {-# INLINE step' #-}
            step' Nothing  = return Done
            step' (Just s)
                = do r ← step s
                     case r of
                       Yield p s'
                           → case takeWhile f p of
                                p' | p ≡ p'    → return $ Yield p' (Just s')
                                   | otherwise → return $ Yield p' Nothing
                       Skip    s'
                           → return $ Skip (Just s')
                       Done
                           → return Done

strictDropWhile ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
{-# INLINEABLE strictDropWhile #-}
strictDropWhile _ (Bitstream 0  v0) = Bitstream 0 v0
strictDropWhile f (Bitstream l0 v0) = case go l0 v0 of
                                        (# l, v #) → Bitstream l v
    where
      {-# INLINE go #-}
      go 0 v = (# 0, v #)
      go l v = let !p    = SV.head v
                   !pLen = length p
               in
                 case dropWhile f p of
                   p' | null p'   → go (l - pLen) (SV.tail v)
                      | otherwise → (# l - pLen + length p'
                                     , p' `SV.cons` SV.tail v #)

strictFilter ∷ G.Bitstream (Packet d) ⇒ (Bool → Bool) → Bitstream d → Bitstream d
{-# INLINEABLE strictFilter #-}
strictFilter f
    = unstreamPackets ∘ filterPS ∘ streamPackets
    where
      {-# INLINE filterPS #-}
      filterPS (Stream step s0 sz) = Stream step' s0 (toMax sz)
          where
            {-# INLINE step' #-}
            step' s
                = do r ← step s
                     case r of
                       Yield p s' → case filter f p of
                                       p' | null p'   → return $ Skip s'
                                          | otherwise → return $ Yield p' s'
                       Skip    s' → return $ Skip s'
                       Done       → return Done

strictHead ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
{-# RULES "head → strictHead" [1]
    ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
    head v = strictHead v #-}
{-# INLINE strictHead #-}
strictHead (Bitstream _ v) = head (SV.head v)

strictLast ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
{-# RULES "last → strictLast" [1]
    ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
    last v = strictLast v #-}
{-# INLINE strictLast #-}
strictLast (Bitstream _ v) = last (SV.last v)

strictNull ∷ Bitstream d → Bool
{-# RULES "null → strictNull" [1] null = strictNull #-}
{-# INLINE strictNull #-}
strictNull (Bitstream 0 _) = True
strictNull _               = False

strictLength ∷ Num n ⇒ Bitstream d → n
{-# RULES "length → strictLength" [1] length = strictLength #-}
{-# INLINE strictLength #-}
strictLength (Bitstream len _) = fromIntegral len

strictAnd ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
{-# RULES "and → strictAnd" [1]
    ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
    and v = strictAnd v #-}
{-# INLINE strictAnd #-}
strictAnd (Bitstream _ v)
    = SV.all and v

strictOr ∷ G.Bitstream (Packet d) ⇒ Bitstream d → Bool
{-# RULES "or → strictOr" [1]
    ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d).
    or v = strictOr v #-}
{-# INLINE strictOr #-}
strictOr (Bitstream _ v)
    = SV.any or v

strictIndex ∷ (G.Bitstream (Packet d), Integral n, Show n) ⇒ Bitstream d → n → Bool
{-# RULES "(!!) → strictIndex" [1]
    ∀(v ∷ G.Bitstream (Packet d) ⇒ Bitstream d) n.
    v !! n = strictIndex v n #-}
{-# INLINEABLE strictIndex #-}
strictIndex (Bitstream _ v0) i0
    | i0 < 0    = indexOutOfRange i0
    | otherwise = go v0 i0
    where
      {-# INLINE go #-}
      go v i
          | SV.null v = indexOutOfRange i
          | otherwise = case SV.head v of
                          p | i < length p → p !! i
                            | otherwise    → go (SV.tail v) (i - length p)

emptyStream ∷ α
emptyStream
    = error "Data.Bitstream: empty stream"

{-# INLINE indexOutOfRange #-}
indexOutOfRange ∷ (Integral n, Show n) ⇒ n → α
indexOutOfRange n = error ("Data.Bitstream: index out of range: " L.++ show n)

-- | /O(n)/ Convert a strict 'BS.ByteString' into a strict
-- 'Bitstream'.
{-# INLINE fromByteString #-}
fromByteString ∷ BS.ByteString → Bitstream d
fromByteString bs0
    = Bitstream (nOctets ⋅ 8) (SV.unfoldrN nOctets go bs0)
    where
      nOctets ∷ Int
      {-# INLINE nOctets #-}
      nOctets = BS.length bs0
      {-# INLINE go #-}
      go bs = do (o, bs') ← BS.uncons bs
                 return (fromOctet o, bs')

-- | /O(n)/ @'toByteString' bits@ converts a strict 'Bitstream' @bits@
-- into a strict 'BS.ByteString'. The resulting octets will be padded
-- with zeroes if the 'length' of @bs@ is not multiple of 8.
{-# INLINEABLE toByteString #-}
toByteString ∷ ∀d. ( G.Bitstream (Bitstream d)
                   , G.Bitstream (Packet d)
                                     ) ⇒ Bitstream d → BS.ByteString
toByteString = unstreamBS
             ∘ (packPackets ∷ Stream Id Bool → Stream Id (Packet d))
             ∘ stream

unstreamBS ∷ Stream Id (Packet d) → BS.ByteString
{-# INLINE unstreamBS #-}
unstreamBS (Stream step s0 sz)
    = case upperBound sz of
        Just n  → fst $ BS.unfoldrN n (unId ∘ go) s0
        Nothing → BS.unfoldr (unId ∘ go) s0
      where
        {-# INLINE go #-}
        go s = do r ← step s
                  case r of
                    Yield p s' → return $ Just (toOctet p, s')
                    Skip    s' → go s'
                    Done       → return Nothing

-- WARNING: countBits is rather slow.
countBits ∷ (G.Bitstream (Packet d), Num n) ⇒ SV.Vector (Packet d) → n
{-# INLINE countBits #-}
countBits = SV.foldl' (\n p → n + length p) 0

-- | /O(n)/ Convert a 'SV.Vector' of 'Packet's into a 'Bitstream'.
fromPackets ∷ G.Bitstream (Packet d) ⇒ SV.Vector (Packet d) → Bitstream d
{-# INLINE fromPackets #-}
fromPackets v = Bitstream (countBits v) v

-- | /O(1)/ Convert a 'SV.Vector' of 'Packet's into a 'Bitstream',
-- with provided overall bit length. The correctness of the bit length
-- isn't checked, so you MUST be sure your bit length is absolutely
-- correct.
unsafeFromPackets ∷ G.Bitstream (Packet d) ⇒ Int → SV.Vector (Packet d) → Bitstream d
{-# INLINE unsafeFromPackets #-}
unsafeFromPackets = Bitstream

-- | /O(1)/ Convert a 'Bitstream' into a 'SV.Vector' of 'Packet's.
toPackets ∷ Bitstream d → SV.Vector (Packet d)
{-# INLINE toPackets #-}
toPackets (Bitstream _ d) = d

-- | /O(1)/ Convert a 'Bitstream' into a 'S.Stream' of 'Packet's.
streamPackets ∷ Bitstream d → S.Stream (Packet d)
{-# NOINLINE streamPackets #-}
streamPackets (Bitstream _ v) = GV.stream v

-- | /O(n)/ Convert a 'S.Stream' of 'Packet's into 'Bitstream'.
unstreamPackets ∷ G.Bitstream (Packet d) ⇒ S.Stream (Packet d) → Bitstream d
{-# NOINLINE unstreamPackets #-}
unstreamPackets s
    = let !v = GV.unstream s
          !l = countBits v
      in
        Bitstream l v

{-# RULES
"Strict Bitstream streamPackets/unstreamPackets fusion"
    ∀s. streamPackets (unstreamPackets s) = s

"Strict Bitstream unstreamPackets/streamPackets fusion"
    ∀v. unstreamPackets (streamPackets v) = v
  #-}

-- | /O(n)/ Convert a @'Bitstream' 'Left'@ into a @'Bitstream'
-- 'Right'@. Bit directions only affect octet-based operations such as
-- 'toByteString'.
directionLToR ∷ Bitstream Left → Bitstream Right
{-# INLINE directionLToR #-}
directionLToR (Bitstream l v) = Bitstream l (SV.map packetLToR v)

-- | /O(n)/ Convert a @'Bitstream' 'Right'@ into a @'Bitstream'
-- 'Left'@. Bit directions only affect octet-based operations such as
-- 'toByteString'.
directionRToL ∷ Bitstream Right → Bitstream Left
{-# INLINE directionRToL #-}
directionRToL (Bitstream l v) = Bitstream l (SV.map packetRToL v)

-- | /O(n)/ Read a 'Bitstream' from the stdin strictly, equivalent to
-- 'hGetContents' @stdin@. The 'Handle' is closed after the contents
-- have been read.
getContents ∷ G.Bitstream (Packet d) ⇒ IO (Bitstream d)
{-# INLINE getContents #-}
getContents = fmap fromByteString BS.getContents

-- | /O(n)/ Write a 'Bitstream' to the stdout, equivalent to 'hPut'
-- @stdout@.
putBits ∷ ( G.Bitstream (Bitstream d)
          , G.Bitstream (Packet d)
          )
        ⇒ Bitstream d
        → IO ()
{-# INLINE putBits #-}
putBits = BS.putStr ∘ toByteString

-- | The 'interact' function takes a function of type @'Bitstream' d
-- -> 'Bitstream' d@ as its argument. The entire input from the stdin
-- is passed to this function as its argument, and the resulting
-- 'Bitstream' is output on the stdout.
interact ∷ ( G.Bitstream (Bitstream d)
           , G.Bitstream (Packet d)
           )
         ⇒ (Bitstream d → Bitstream d)
         → IO ()
{-# INLINE interact #-}
interact = BS.interact ∘ lift'
    where
      {-# INLINE lift' #-}
      lift' f = toByteString ∘ f ∘ fromByteString

-- | /O(n)/ Read an entire file strictly into a 'Bitstream'.
readFile ∷ G.Bitstream (Packet d) ⇒ FilePath → IO (Bitstream d)
{-# INLINE readFile #-}
readFile = fmap fromByteString ∘ BS.readFile

-- | /O(n)/ Write a 'Bitstream' to a file.
writeFile ∷ ( G.Bitstream (Bitstream d)
            , G.Bitstream (Packet d)
            )
          ⇒ FilePath
          → Bitstream d
          → IO ()
{-# INLINE writeFile #-}
writeFile = (∘ toByteString) ∘ BS.writeFile

-- | /O(n)/ Append a 'Bitstream' to a file.
appendFile ∷ ( G.Bitstream (Bitstream d)
             , G.Bitstream (Packet d)
             )
           ⇒ FilePath
           → Bitstream d
           → IO ()
{-# INLINE appendFile #-}
appendFile = (∘ toByteString) ∘ BS.appendFile

-- | /O(n)/ Read entire handle contents strictly into a 'Bitstream'.
--
-- This function reads chunks at a time, doubling the chunksize on each
-- read. The final buffer is then realloced to the appropriate size. For
-- files > half of available memory, this may lead to memory exhaustion.
-- Consider using 'readFile' in this case.
--
-- The 'Handle' is closed once the contents have been read, or if an
-- exception is thrown.
hGetContents ∷ G.Bitstream (Packet d) ⇒ Handle → IO (Bitstream d)
{-# INLINE hGetContents #-}
hGetContents = fmap fromByteString ∘ BS.hGetContents

-- | /O(n)/ @'hGet' h n@ reads a 'Bitstream' directly from the
-- specified 'Handle' @h@. First argument @h@ is the 'Handle' to read
-- from, and the second @n@ is the number of /octets/ to read, not
-- /bits/. It returns the octets read, up to @n@, or null if EOF has
-- been reached.
--
-- If the handle is a pipe or socket, and the writing end is closed,
-- 'hGet' will behave as if EOF was reached.
hGet ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
{-# INLINE hGet #-}
hGet = (fmap fromByteString ∘) ∘ BS.hGet

-- | /O(n)/ Like 'hGet', except that a shorter 'Bitstream' may be
-- returned if there are not enough octets immediately available to
-- satisfy the whole request. 'hGetSome' only blocks if there is no
-- data available, and EOF has not yet been reached.
hGetSome ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
{-# INLINE hGetSome #-}
hGetSome = (fmap fromByteString ∘) ∘ BS.hGetSome

-- | /O(n)/ 'hGetNonBlocking' is similar to 'hGet', except that it
-- will never block waiting for data to become available. If there is
-- no data available to be read, 'hGetNonBlocking' returns 'empty'.
hGetNonBlocking ∷ G.Bitstream (Packet d) ⇒ Handle → Int → IO (Bitstream d)
{-# INLINE hGetNonBlocking #-}
hGetNonBlocking = (fmap fromByteString ∘) ∘ BS.hGetNonBlocking

-- | /O(n)/ Write a 'Bitstream' to the given 'Handle'.
hPut ∷ ( G.Bitstream (Bitstream d)
       , G.Bitstream (Packet d)
       )
     ⇒ Handle
     → Bitstream d
     → IO ()
{-# INLINE hPut #-}
hPut = (∘ toByteString) ∘ BS.hPut
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , FlexibleContexts
  , FlexibleInstances
  , ScopedTypeVariables
  , UnboxedTuples
  , UndecidableInstances
  , UnicodeSyntax
  #-}
-- | Fast, packed, strict bit streams (i.e. list of 'Bool's) with
-- semi-automatic stream fusion.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions. e.g.
--
-- > import qualified Data.BitStream as BS
--
-- Strict 'Bitstream's are made of strict 'SV.Vector' of 'Packet's,
-- and each 'Packet's have at least 1 bit.
module Data.Bitstream
    ( -- * Data types
      Bitstream
    , Left
    , Right

      -- * Introducing and eliminating 'Bitstream's
    , empty
    , (∅)
    , singleton
    , pack
    , unpack
    , fromPackets
    , unsafeFromPackets
    , toPackets

      -- ** Converting from\/to strict 'BS.ByteString's
    , fromByteString
    , toByteString

    -- ** Converting from\/to 'Bits''
    , fromBits
    , fromNBits
    , toBits

      -- ** Converting from\/to 'S.Stream's
    , stream
    , unstream
    , streamPackets
    , unstreamPackets

      -- * Changing bit order in octets
    , directionLToR
    , directionRToL

      -- * Basic interface
    , cons
    , snoc
    , append
    , (⧺)
    , head
    , last
    , tail
    , init
    , null
    , length

      -- * Transforming 'Bitstream's
    , map
    , reverse

      -- * Reducing 'Bitstream's
    , foldl
    , foldl'
    , foldl1
    , foldl1'
    , foldr
    , foldr1

      -- ** Special folds
    , concat
    , concatMap
    , and
    , or
    , any
    , all

      -- * Building 'Bitstream's
      -- ** Scans
    , scanl
    , scanl1
    , scanr
    , scanr1

      -- ** Replication
    , replicate

      -- ** Unfolding
    , unfoldr
    , unfoldrN

      -- * Substreams
    , take
    , drop
    , takeWhile
    , dropWhile
    , span
    , break

      -- * Searching streams
      -- ** Searching by equality
    , elem
    , (∈)
    , (∋)
    , notElem
    , (∉)
    , (∌)

      -- ** Searching with a predicate
    , find
    , filter
    , partition

      -- ** Indexing streams
    , (!!)
    , elemIndex
    , elemIndices
    , findIndex
    , findIndices

      -- * Zipping and unzipping streams
    , zip
    , zip3
    , zip4
    , zip5
    , zip6
    , zipWith
    , zipWith3
    , zipWith4
    , zipWith5
    , zipWith6
    , unzip
    , unzip3
    , unzip4
    , unzip5
    , unzip6

    -- * I/O with 'Bitstream's
    -- ** Standard input and output
    , getContents
    , putBits
    , interact

    -- ** Files
    , readFile
    , writeFile
    , appendFile

    -- ** I/O with 'Handle's
    , hGetContents
    , hGet
    , hGetSome
    , hGetNonBlocking
    , hPut
    )
    where
import Data.Bitstream.Generic hiding (Bitstream)
import qualified Data.Bitstream.Generic as G
import Data.Bitstream.Internal
import Data.Bitstream.Packet
import qualified Data.ByteString as BS
import qualified Data.List as L
import Data.Monoid
import qualified Data.Vector.Generic as GV
import qualified Data.Vector.Generic.New as New
import qualified Data.Vector.Generic.Mutable as MVector
import qualified Data.Vector.Storable as SV
import qualified Data.Vector.Fusion.Stream as S
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Data.Vector.Fusion.Util
import Prelude ( Bool(..), Eq(..), Int, Integral, Maybe(..), Monad(..), Num(..)
               , Ord(..), Show(..), ($), error, fmap, fromIntegral, fst
               , otherwise
               )
import Prelude.Unicode hiding ((⧺), (∈), (∉))
import System.IO (FilePath, Handle, IO)

-- | A space-efficient representation of a 'Bool' vector, supporting
-- many efficient operations. 'Bitstream's have an idea of
-- /directions/ controlling how octets are interpreted as bits. There
-- are two types of concrete 'Bitstream's: @'Bitstream' 'Left'@ and
-- @'Bitstream' 'Right'@.
data Bitstream d
    = Bitstream {-# UNPACK #-} !Int -- bit length
                {-# UNPACK #-} !(SV.Vector (Packet d))
-- THINKME: The bit length should only be a hint, just like stream
-- size.

instance Show (Packet d) => Show (Bitstream d) where
    {-# INLINEABLE show #-}
    show (Bitstream _ v0)
        = L.concat
          [ "(S"
          , L.concat (L.unfoldr go v0)
          , ")"
          ]
        where
          {-# INLINE go #-}
          go v | SV.null v = Nothing
               | otherwise = Just (show (SV.head v), SV.tail v)

instance G.Bitstream (Bitstream d) => Eq (Bitstream d) where
    {-# INLINE (==) #-}
    x == y = stream x ≡ stream y

-- | 'Bitstream's are lexicographically ordered.
--
-- @
-- let x = 'pack' ['True' , 'False', 'False']
--     y = 'pack' ['False', 'True' , 'False']
--     z = 'pack' ['False']
-- in
--   [ 'compare' x y -- 'GT'
--   , 'compare' z y -- 'LT'
--   ]
-- @
instance G.Bitstream (Bitstream d) => Ord (Bitstream d) where
    {-# INLINE compare #-}
    x `compare` y = stream x `compare` stream y

-- | 'Bitstream' forms 'Monoid' in the same way as ordinary lists:
--
-- @
-- 'mempty'  = 'empty'
-- 'mappend' = 'append'
-- 'mconcat' = 'concat'
-- @
instance G.Bitstream (Bitstream d) => Monoid (Bitstream d) where
    mempty  = (∅)
    mappend = (⧺)
    mconcat = concat

instance G.Bitstream (Bitstream Left) where
    {-# INLINE basicStream #-}
    basicStream = strictStream

    {-# INLINE basicUnstream #-}
    basicUnstream = strictUnstream

    {-# INLINE basicCons #-}
    basicCons = strictCons

    {-# INLINE basicSnoc #-}
    basicSnoc = strictSnoc

    {-# INLINE basicAppend #-}
    basicAppend = strictAppend

    {-# INLINE basicTail #-}
    basicTail = strictTail

    {-# INLINE basicInit #-}
    basicInit = strictInit

    {-# INLINE basicMap #-}
    basicMap = strictMap

    {-# INLINE basicReverse #-}
    basicReverse = strictReverse

    {-# INLINE basicConcat #-}
    basicConcat = strictConcat

    {-# INLINE basicScanl #-}
    basicScanl = strictScanl

    {-# INLINE basicTake #-}
    basicTake = strictTake

    {-# INLINE basicDrop #-}
    basicDrop = strictDrop

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = strictTakeWhile

    {-# INLINE basicDropWhile #-}
    basicDropWhile = strictDropWhile

    {-# INLINE basicFilter #-}
    basicFilter = strictFilter

    {-# INLINE basicFromNBits #-}
    basicFromNBits = (unstreamPackets ∘) ∘ lePacketsFromNBits

    {-# INLINE basicToBits #-}
    basicToBits = unId ∘ lePacketsToBits ∘ streamPackets

instance G.Bitstream (Bitstream Right) where
    {-# INLINE basicStream #-}
    basicStream = strictStream

    {-# INLINE basicUnstream #-}
    basicUnstream = strictUnstream

    {-# INLINE basicCons #-}
    basicCons = strictCons

    {-# INLINE basicSnoc #-}
    basicSnoc = strictSnoc

    {-# INLINE basicAppend #-}
    basicAppend = strictAppend

    {-# INLINE basicTail #-}
    basicTail = strictTail

    {-# INLINE basicInit #-}
    basicInit = strictInit

    {-# INLINE basicMap #-}
    basicMap = strictMap

    {-# INLINE basicReverse #-}
    basicReverse = strictReverse

    {-# INLINE basicConcat #-}
    basicConcat = strictConcat

    {-# INLINE basicScanl #-}
    basicScanl = strictScanl

    {-# INLINE basicTake #-}
    basicTake = strictTake

    {-# INLINE basicDrop #-}
    basicDrop = strictDrop

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = strictTakeWhile

    {-# INLINE basicDropWhile #-}
    basicDropWhile = strictDropWhile

    {-# INLINE basicFilter #-}
    basicFilter = strictFilter

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits = (unstreamPackets ∘) ∘ bePacketsFromNBits

    {-# INLINEABLE basicToBits #-}
    basicToBits = unId ∘ bePacketsToBits ∘ streamPackets

strictStream :: G.Bitstream (Packet d) => Bitstream d -> S.Stream Bool
{-# INLINE strictStream #-}
strictStream (Bitstream l v)
    = {-# CORE Strict Bitstream stream #-}
      S.concatMap stream (GV.stream v)
      `S.sized`
      Exact l

strictUnstream :: G.Bitstream (Packet d) => S.Stream Bool -> Bitstream d
{-# INLINE strictUnstream #-}
strictUnstream
    = {-# CORE Strict Bitstream unstream #-}
      unstreamPackets ∘ packPackets

strictCons :: G.Bitstream (Packet d) => Bool -> Bitstream d -> Bitstream d
{-# INLINEABLE strictCons #-}
strictCons b (Bitstream 0 _) = Bitstream 1 (SV.singleton (singleton b))
strictCons b (Bitstream l v)
    = case SV.head v of
        p | length p < (8 :: Int)
                -> Bitstream (l+1) ((b `cons` p) `SV.cons` SV.tail v)
          | otherwise
                -> Bitstream (l+1) (singleton b `SV.cons` v)

strictSnoc :: G.Bitstream (Packet d) => Bitstream d -> Bool -> Bitstream d
{-# INLINEABLE strictSnoc #-}
strictSnoc (Bitstream 0 _) b = Bitstream 1 (SV.singleton (singleton b))
strictSnoc (Bitstream l v) b
    = case SV.last v of
        p | length p < (8 :: Int)
                -> Bitstream (l+1) (SV.init v `SV.snoc` (p `snoc` b))
          | otherwise
                -> Bitstream (l+1) (v `SV.snoc` singleton b)

strictAppend :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d -> Bitstream d
{-# INLINE strictAppend #-}
strictAppend (Bitstream lx x) (Bitstream ly y)
    = Bitstream (lx + ly) (x SV.++ y)

strictTail :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
{-# INLINEABLE strictTail #-}
strictTail (Bitstream 0 _) = emptyStream
strictTail (Bitstream l v)
    = case tail (SV.head v) of
        p' | null p'   -> Bitstream (l-1) (SV.tail v)
           | otherwise -> Bitstream (l-1) (p' `SV.cons` SV.tail v)

strictInit :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
{-# INLINEABLE strictInit #-}
strictInit (Bitstream 0 _) = emptyStream
strictInit (Bitstream l v)
    = case init (SV.last v) of
        p' | null p'   -> Bitstream (l-1) (SV.init v)
           | otherwise -> Bitstream (l-1) (SV.init v `SV.snoc` p')

strictMap :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
{-# INLINE strictMap #-}
strictMap f (Bitstream l v)
    = Bitstream l (SV.map (map f) v)

strictReverse :: G.Bitstream (Packet d) => Bitstream d -> Bitstream d
{-# INLINE strictReverse #-}
strictReverse (Bitstream l v)
    = Bitstream l (SV.reverse (SV.map reverse v))

strictConcat :: G.Bitstream (Bitstream d) => [Bitstream d] -> Bitstream d
{-# INLINEABLE strictConcat #-}
strictConcat xs
    = let (!l, !vs) = L.mapAccumL (\n x -> (n + length x, toPackets x)) 0 xs
          !v        = SV.concat vs
      in
        Bitstream l v

strictScanl :: G.Bitstream (Bitstream d) => (Bool -> Bool -> Bool) -> Bool -> Bitstream d -> Bitstream d
{-# INLINE strictScanl #-}
strictScanl f b
    = unstream ∘ S.scanl f b ∘ stream

strictTake :: ( Integral n
             , G.Bitstream (Bitstream d)
             , G.Bitstream (Packet d)
             )
           => n
           -> Bitstream d
           -> Bitstream d
{-# INLINEABLE strictTake #-}
strictTake n0 (Bitstream l0 v0)
    | l0 ≡ 0    = (∅)
    | n0 ≤ 0    = (∅)
    | otherwise = let !e = New.create (MVector.new (SV.length v0))
                  in
                    case go n0 v0 0 0 e of
                      (# l, np, mv #)
                          -> let !mv' = New.apply (MVector.take np) mv
                                 !v   = GV.new mv'
                             in
                               Bitstream l v
    where
      {-# INLINE go #-}
      go 0 _ l np mv  = (# l, np, mv #)
      go n v l np mv
          | SV.null v = (# l, np, mv #)
          | otherwise = let !p   = SV.head v
                            !p'  = take n p
                            !n'  = n - length p'
                            !v'  = SV.tail v
                            !l'  = l + length p'
                            !np' = np + 1
                            !mv' = New.modify (\x -> MVector.write x np p') mv
                        in
                          go n' v' l' np' mv'

strictDrop :: (Integral n, G.Bitstream (Packet d)) => n -> Bitstream d -> Bitstream d
{-# INLINEABLE strictDrop #-}
strictDrop n0 (Bitstream l0 v0)
    | n0 ≤ 0    = Bitstream l0 v0
    | otherwise = case go n0 l0 v0 of
                    (# l, v #) -> Bitstream l v
    where
      {-# INLINE go #-}
      go 0 l v = (# l, v #)
      go _ 0 v = (# 0, v #)
      go n l v = let !p = SV.head v
                 in
                   case drop n p of
                     p' | null p'   -> go (n - length p) (l - length p) (SV.tail v)
                        | otherwise -> (# l - length p + length p'
                                       , p' `SV.cons` SV.tail v #)

strictTakeWhile :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
{-# INLINEABLE strictTakeWhile #-}
strictTakeWhile f
    = unstreamPackets ∘ takeWhilePS ∘ streamPackets
    where
      {-# INLINE takeWhilePS #-}
      takeWhilePS (Stream step s0 sz) = Stream step' (Just s0) (toMax sz)
          where
            {-# INLINE step' #-}
            step' Nothing  = return Done
            step' (Just s)
                = do r <- step s
                     case r of
                       Yield p s'
                           -> case takeWhile f p of
                                p' | p ≡ p'    -> return $ Yield p' (Just s')
                                   | otherwise -> return $ Yield p' Nothing
                       Skip    s'
                           -> return $ Skip (Just s')
                       Done
                           -> return Done

strictDropWhile :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
{-# INLINEABLE strictDropWhile #-}
strictDropWhile _ (Bitstream 0  v0) = Bitstream 0 v0
strictDropWhile f (Bitstream l0 v0) = case go l0 v0 of
                                        (# l, v #) -> Bitstream l v
    where
      {-# INLINE go #-}
      go 0 v = (# 0, v #)
      go l v = let !p    = SV.head v
                   !pLen = length p
               in
                 case dropWhile f p of
                   p' | null p'   -> go (l - pLen) (SV.tail v)
                      | otherwise -> (# l - pLen + length p'
                                     , p' `SV.cons` SV.tail v #)

strictFilter :: G.Bitstream (Packet d) => (Bool -> Bool) -> Bitstream d -> Bitstream d
{-# INLINEABLE strictFilter #-}
strictFilter f
    = unstreamPackets ∘ filterPS ∘ streamPackets
    where
      {-# INLINE filterPS #-}
      filterPS (Stream step s0 sz) = Stream step' s0 (toMax sz)
          where
            {-# INLINE step' #-}
            step' s
                = do r <- step s
                     case r of
                       Yield p s' -> case filter f p of
                                       p' | null p'   -> return $ Skip s'
                                          | otherwise -> return $ Yield p' s'
                       Skip    s' -> return $ Skip s'
                       Done       -> return Done

strictHead :: G.Bitstream (Packet d) => Bitstream d -> Bool
{-# RULES "head \8594 strictHead" [1]
    forall(v :: G.Bitstream (Packet d) => Bitstream d).
    head v = strictHead v #-}
{-# INLINE strictHead #-}
strictHead (Bitstream _ v) = head (SV.head v)

strictLast :: G.Bitstream (Packet d) => Bitstream d -> Bool
{-# RULES "last \8594 strictLast" [1]
    forall(v :: G.Bitstream (Packet d) => Bitstream d).
    last v = strictLast v #-}
{-# INLINE strictLast #-}
strictLast (Bitstream _ v) = last (SV.last v)

strictNull :: Bitstream d -> Bool
{-# RULES "null \8594 strictNull" [1] null = strictNull #-}
{-# INLINE strictNull #-}
strictNull (Bitstream 0 _) = True
strictNull _               = False

strictLength :: Num n => Bitstream d -> n
{-# RULES "length \8594 strictLength" [1] length = strictLength #-}
{-# INLINE strictLength #-}
strictLength (Bitstream len _) = fromIntegral len

strictAnd :: G.Bitstream (Packet d) => Bitstream d -> Bool
{-# RULES "and \8594 strictAnd" [1]
    forall(v :: G.Bitstream (Packet d) => Bitstream d).
    and v = strictAnd v #-}
{-# INLINE strictAnd #-}
strictAnd (Bitstream _ v)
    = SV.all and v

strictOr :: G.Bitstream (Packet d) => Bitstream d -> Bool
{-# RULES "or \8594 strictOr" [1]
    forall(v :: G.Bitstream (Packet d) => Bitstream d).
    or v = strictOr v #-}
{-# INLINE strictOr #-}
strictOr (Bitstream _ v)
    = SV.any or v

strictIndex :: (G.Bitstream (Packet d), Integral n, Show n) => Bitstream d -> n -> Bool
{-# RULES "(!!) \8594 strictIndex" [1]
    forall(v :: G.Bitstream (Packet d) => Bitstream d) n.
    v !! n = strictIndex v n #-}
{-# INLINEABLE strictIndex #-}
strictIndex (Bitstream _ v0) i0
    | i0 < 0    = indexOutOfRange i0
    | otherwise = go v0 i0
    where
      {-# INLINE go #-}
      go v i
          | SV.null v = indexOutOfRange i
          | otherwise = case SV.head v of
                          p | i < length p -> p !! i
                            | otherwise    -> go (SV.tail v) (i - length p)

emptyStream :: α
emptyStream
    = error "Data.Bitstream: empty stream"

{-# INLINE indexOutOfRange #-}
indexOutOfRange :: (Integral n, Show n) => n -> α
indexOutOfRange n = error ("Data.Bitstream: index out of range: " L.++ show n)

-- | /O(n)/ Convert a strict 'BS.ByteString' into a strict
-- 'Bitstream'.
{-# INLINE fromByteString #-}
fromByteString :: BS.ByteString -> Bitstream d
fromByteString bs0
    = Bitstream (nOctets ⋅ 8) (SV.unfoldrN nOctets go bs0)
    where
      nOctets :: Int
      {-# INLINE nOctets #-}
      nOctets = BS.length bs0
      {-# INLINE go #-}
      go bs = do (o, bs') <- BS.uncons bs
                 return (fromOctet o, bs')

-- | /O(n)/ @'toByteString' bits@ converts a strict 'Bitstream' @bits@
-- into a strict 'BS.ByteString'. The resulting octets will be padded
-- with zeroes if the 'length' of @bs@ is not multiple of 8.
{-# INLINEABLE toByteString #-}
toByteString :: foralld. ( G.Bitstream (Bitstream d)
                   , G.Bitstream (Packet d)
                                     ) => Bitstream d -> BS.ByteString
toByteString = unstreamBS
             ∘ (packPackets :: Stream Id Bool -> Stream Id (Packet d))
             ∘ stream

unstreamBS :: Stream Id (Packet d) -> BS.ByteString
{-# INLINE unstreamBS #-}
unstreamBS (Stream step s0 sz)
    = case upperBound sz of
        Just n  -> fst $ BS.unfoldrN n (unId ∘ go) s0
        Nothing -> BS.unfoldr (unId ∘ go) s0
      where
        {-# INLINE go #-}
        go s = do r <- step s
                  case r of
                    Yield p s' -> return $ Just (toOctet p, s')
                    Skip    s' -> go s'
                    Done       -> return Nothing

-- WARNING: countBits is rather slow.
countBits :: (G.Bitstream (Packet d), Num n) => SV.Vector (Packet d) -> n
{-# INLINE countBits #-}
countBits = SV.foldl' (\n p -> n + length p) 0

-- | /O(n)/ Convert a 'SV.Vector' of 'Packet's into a 'Bitstream'.
fromPackets :: G.Bitstream (Packet d) => SV.Vector (Packet d) -> Bitstream d
{-# INLINE fromPackets #-}
fromPackets v = Bitstream (countBits v) v

-- | /O(1)/ Convert a 'SV.Vector' of 'Packet's into a 'Bitstream',
-- with provided overall bit length. The correctness of the bit length
-- isn't checked, so you MUST be sure your bit length is absolutely
-- correct.
unsafeFromPackets :: G.Bitstream (Packet d) => Int -> SV.Vector (Packet d) -> Bitstream d
{-# INLINE unsafeFromPackets #-}
unsafeFromPackets = Bitstream

-- | /O(1)/ Convert a 'Bitstream' into a 'SV.Vector' of 'Packet's.
toPackets :: Bitstream d -> SV.Vector (Packet d)
{-# INLINE toPackets #-}
toPackets (Bitstream _ d) = d

-- | /O(1)/ Convert a 'Bitstream' into a 'S.Stream' of 'Packet's.
streamPackets :: Bitstream d -> S.Stream (Packet d)
{-# NOINLINE streamPackets #-}
streamPackets (Bitstream _ v) = GV.stream v

-- | /O(n)/ Convert a 'S.Stream' of 'Packet's into 'Bitstream'.
unstreamPackets :: G.Bitstream (Packet d) => S.Stream (Packet d) -> Bitstream d
{-# NOINLINE unstreamPackets #-}
unstreamPackets s
    = let !v = GV.unstream s
          !l = countBits v
      in
        Bitstream l v

{-# RULES
"Strict Bitstream streamPackets/unstreamPackets fusion"
    foralls. streamPackets (unstreamPackets s) = s

"Strict Bitstream unstreamPackets/streamPackets fusion"
    forallv. unstreamPackets (streamPackets v) = v
  #-}

-- | /O(n)/ Convert a @'Bitstream' 'Left'@ into a @'Bitstream'
-- 'Right'@. Bit directions only affect octet-based operations such as
-- 'toByteString'.
directionLToR :: Bitstream Left -> Bitstream Right
{-# INLINE directionLToR #-}
directionLToR (Bitstream l v) = Bitstream l (SV.map packetLToR v)

-- | /O(n)/ Convert a @'Bitstream' 'Right'@ into a @'Bitstream'
-- 'Left'@. Bit directions only affect octet-based operations such as
-- 'toByteString'.
directionRToL :: Bitstream Right -> Bitstream Left
{-# INLINE directionRToL #-}
directionRToL (Bitstream l v) = Bitstream l (SV.map packetRToL v)

-- | /O(n)/ Read a 'Bitstream' from the stdin strictly, equivalent to
-- 'hGetContents' @stdin@. The 'Handle' is closed after the contents
-- have been read.
getContents :: G.Bitstream (Packet d) => IO (Bitstream d)
{-# INLINE getContents #-}
getContents = fmap fromByteString BS.getContents

-- | /O(n)/ Write a 'Bitstream' to the stdout, equivalent to 'hPut'
-- @stdout@.
putBits :: ( G.Bitstream (Bitstream d)
          , G.Bitstream (Packet d)
          )
        => Bitstream d
        -> IO ()
{-# INLINE putBits #-}
putBits = BS.putStr ∘ toByteString

-- | The 'interact' function takes a function of type @'Bitstream' d
-- -> 'Bitstream' d@ as its argument. The entire input from the stdin
-- is passed to this function as its argument, and the resulting
-- 'Bitstream' is output on the stdout.
interact :: ( G.Bitstream (Bitstream d)
           , G.Bitstream (Packet d)
           )
         => (Bitstream d -> Bitstream d)
         -> IO ()
{-# INLINE interact #-}
interact = BS.interact ∘ lift'
    where
      {-# INLINE lift' #-}
      lift' f = toByteString ∘ f ∘ fromByteString

-- | /O(n)/ Read an entire file strictly into a 'Bitstream'.
readFile :: G.Bitstream (Packet d) => FilePath -> IO (Bitstream d)
{-# INLINE readFile #-}
readFile = fmap fromByteString ∘ BS.readFile

-- | /O(n)/ Write a 'Bitstream' to a file.
writeFile :: ( G.Bitstream (Bitstream d)
            , G.Bitstream (Packet d)
            )
          => FilePath
          -> Bitstream d
          -> IO ()
{-# INLINE writeFile #-}
writeFile = (∘ toByteString) ∘ BS.writeFile

-- | /O(n)/ Append a 'Bitstream' to a file.
appendFile :: ( G.Bitstream (Bitstream d)
             , G.Bitstream (Packet d)
             )
           => FilePath
           -> Bitstream d
           -> IO ()
{-# INLINE appendFile #-}
appendFile = (∘ toByteString) ∘ BS.appendFile

-- | /O(n)/ Read entire handle contents strictly into a 'Bitstream'.
--
-- This function reads chunks at a time, doubling the chunksize on each
-- read. The final buffer is then realloced to the appropriate size. For
-- files > half of available memory, this may lead to memory exhaustion.
-- Consider using 'readFile' in this case.
--
-- The 'Handle' is closed once the contents have been read, or if an
-- exception is thrown.
hGetContents :: G.Bitstream (Packet d) => Handle -> IO (Bitstream d)
{-# INLINE hGetContents #-}
hGetContents = fmap fromByteString ∘ BS.hGetContents

-- | /O(n)/ @'hGet' h n@ reads a 'Bitstream' directly from the
-- specified 'Handle' @h@. First argument @h@ is the 'Handle' to read
-- from, and the second @n@ is the number of /octets/ to read, not
-- /bits/. It returns the octets read, up to @n@, or null if EOF has
-- been reached.
--
-- If the handle is a pipe or socket, and the writing end is closed,
-- 'hGet' will behave as if EOF was reached.
hGet :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
{-# INLINE hGet #-}
hGet = (fmap fromByteString ∘) ∘ BS.hGet

-- | /O(n)/ Like 'hGet', except that a shorter 'Bitstream' may be
-- returned if there are not enough octets immediately available to
-- satisfy the whole request. 'hGetSome' only blocks if there is no
-- data available, and EOF has not yet been reached.
hGetSome :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
{-# INLINE hGetSome #-}
hGetSome = (fmap fromByteString ∘) ∘ BS.hGetSome

-- | /O(n)/ 'hGetNonBlocking' is similar to 'hGet', except that it
-- will never block waiting for data to become available. If there is
-- no data available to be read, 'hGetNonBlocking' returns 'empty'.
hGetNonBlocking :: G.Bitstream (Packet d) => Handle -> Int -> IO (Bitstream d)
{-# INLINE hGetNonBlocking #-}
hGetNonBlocking = (fmap fromByteString ∘) ∘ BS.hGetNonBlocking

-- | /O(n)/ Write a 'Bitstream' to the given 'Handle'.
hPut :: ( G.Bitstream (Bitstream d)
       , G.Bitstream (Packet d)
       )
     => Handle
     -> Bitstream d
     -> IO ()
{-# INLINE hPut #-}
hPut = (∘ toByteString) ∘ BS.hPut

</pre>