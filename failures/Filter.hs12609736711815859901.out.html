<a href="Filter.hs1088387561264032581.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Filter.hs13418536351808266298.out.html">next</a></br></br><pre>25c25
<    {- ** Smooth -}
---
>    {- ** Smooth 
28c28
<    {- ** Delay -}
---
>    {- ** Delay 
35c35
<    {- * Recursive -}
---
>    {- * Recursive 
37c37
<    {- ** Without resonance -}
---
>    {- ** Without resonance 
46c46
<    {- ** With resonance -}
---
>    {- ** With resonance 
49c49
<    {- ** Allpass -}
---
>    {- ** Allpass 
51c51
<    {- ** Reverb -}
---
>    {- ** Reverb 
126d125
<       SigI.T a q y  {- ^ the envelope -}
127c126
<    -> SigI.T a q v  {- ^ the signal to be enveloped -}
---
>       SigI.T a q y  {- ^ the envelope 
127a127
>    -> SigI.T a q v  {- ^ the signal to be enveloped 
156c156
< {- | needs a good handling of boundaries, yet -}
---
> {- | needs a good handling of boundaries, yet 
159c159
<       q            {- ^ time length of the window -}
---
>       q            {- ^ time length of the window 
183c183
<    -> q   {- ^ minDelay, minimal delay, may be negative -}
---
>    -> q   {- ^ minDelay, minimal delay, may be negative 
186c186
<                in the range [minDelay,maxDelay]. -}
---
>                in the range [minDelay,maxDelay]. 
189c189
<                negative numbers mean prefetch -}
---
>                negative numbers mean prefetch 
207c207
< {- | symmetric phaser -}
---
> {- | symmetric phaser 
211c211
<    -> q   {- ^ maxDelay, must be positive -}
---
>    -> q   {- ^ maxDelay, must be positive 
213c213
<           {- ^ delay control -}
---
>           {- ^ delay control 
223c223
<    -> q   {- ^ maxDelay, must be positive -}
---
>    -> q   {- ^ maxDelay, must be positive 
225c225
<           {- ^ delay control -}
---
>           {- ^ delay control 
234c234
<    -> q   {- ^ maxDelay, must be positive -}
---
>    -> q   {- ^ maxDelay, must be positive 
236c236
<           {- ^ delay control -}
---
>           {- ^ delay control 
250d249
<       SigI.T a q a {- ^ Control signal for the cut-off frequency. -}
251c250
<    -> SigI.T a q v {- ^ Input signal -}
---
>       SigI.T a q a {- ^ Control signal for the cut-off frequency. 
251a251
>    -> SigI.T a q v {- ^ Input signal 
272c272
<                         the higher the order, the sharper is the separation of frequencies. -}
---
>                         the higher the order, the sharper is the separation of frequencies. 
274d273
<                         Should be between 0 and 1. -}
275d273
<    -> SigI.T a q a {- ^ Control signal for the cut-off frequency. -}
276c274
<    -> SigI.T a q v {- ^ Input signal -}
---
>                         Should be between 0 and 1. 
276a275
>    -> SigI.T a q a {- ^ Control signal for the cut-off frequency. 
276a276
>    -> SigI.T a q v {- ^ Input signal 
304d303
<                         relatively to the transition band. -}
305d303
<    -> SigI.T a q a {- ^ signal for cut off and band center frequency -}
306d303
<    -> SigI.T a q v {- ^ input signal -}
307c304
<    -> SigI.Process a q (v,v,v) {- ^ highpass, bandpass, lowpass filter -}
---
>                         relatively to the transition band. 
307a305
>    -> SigI.T a q a {- ^ signal for cut off and band center frequency 
307a306
>    -> SigI.T a q v {- ^ input signal 
307a307
>    -> SigI.Process a q (v,v,v) {- ^ highpass, bandpass, lowpass filter 
321d320
<                         relatively to the transition band. -}
322c321
<    -> SigI.T a q a {- ^ signal for cut off and band center frequency -}
---
>                         relatively to the transition band. 
322a322
>    -> SigI.T a q a {- ^ signal for cut off and band center frequency 
335d334
<       Int          {- ^ order, number of filters in the cascade -}
336d334
<    -> a            {- ^ the phase shift to be achieved for the given frequency -}
337c335
<    -> SigI.T a q a {- ^ lowest comb frequency -}
---
>       Int          {- ^ order, number of filters in the cascade 
337a336
>    -> a            {- ^ the phase shift to be achieved for the given frequency 
337a337
>    -> SigI.T a q a {- ^ lowest comb frequency 
348c348
< {- | Infinitely many equi-delayed exponentially decaying echos. -}
---
> {- | Infinitely many equi-delayed exponentially decaying echos. 
377a378
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{- |
Copyright   :  (c) Henning Thielemann 2006
License     :  GPL

Maintainer  :  synthesizer@henning-thielemann.de
Stability   :  provisional
Portability :  requires multi-parameter type classes
-}
module Synthesizer.Inference.Fix.Filter (
   {- * Non-recursive -}

   {- ** Amplification -}
   amplify,
   negate,
{-
   envelope,
-}
   {- ** Filter operators from calculus -}
   differentiate,

{-
   {- ** Smooth -}
   mean,

   {- ** Delay -}
   delay,
   phaseModulation,
   phaser,
   phaserStereo,


   {- * Recursive -}

   {- ** Without resonance -}
   firstOrderLowpass,
   firstOrderHighpass,
   butterworthLowpass,
   butterworthHighpass,
   chebyshevALowpass,
   chebyshevAHighpass,
   chebyshevBLowpass,
   chebyshevBHighpass,
   {- ** With resonance -}
   universal,
   moogLowpass,
   {- ** Allpass -}
   allpassCascade,
   {- ** Reverb -}
   comb,
-}
   {- ** Filter operators from calculus -}
   integrate
) where

-- import qualified InferenceFix.Signal as SigF
import Synthesizer.Inference.Fix (InputSignal, OutputSignal, Parameters, Results)

import qualified UniqueLogicNP.Lazy.SingleStep as Logic

{-
import InferenceFix.Signal
   (toTimeScalar, toFrequencyScalar, sampleRateExpr,
    amplitudeExpr)
-}


import qualified Synthesizer.Physical.Signal as SigP
{-
import qualified Synthesizer.Plain.Displacement as Syn
import qualified Synthesizer.Plain.Interpolation as Interpolation
import qualified Synthesizer.Plain.Filter.Delay.ST as Delay
import qualified Synthesizer.Plain.Filter.Recursive    as FiltR
-}
import qualified Synthesizer.Plain.Filter.Recursive.Integration as Integrate
import qualified Synthesizer.Plain.Filter.NonRecursive as FiltNR
{-
import qualified InferenceFunc.Synthesizer as SynI
import qualified Synthesizer.Inference.Func.Cut         as CutI

import Data.Ord.HT (limit)

import qualified Algebra.OccasionallyScalar as OccScalar
import qualified Algebra.VectorSpace    as VectorSpace
import qualified Algebra.Module         as Module
import qualified Algebra.Transcendental as Trans
import qualified Algebra.RealField      as RealField
-}
import qualified Algebra.Field          as Field
-- import qualified Algebra.Real           as Real
-- import qualified Algebra.Ring           as Ring
import qualified Algebra.Additive       as Additive

-- import Control.Monad(liftM2)

-- import NumericPrelude hiding (negate)
import PreludeBase as P


{- | The amplification factor must be positive. -}
amplify :: (Eq t', Field.C y') =>
   y' ->
   (Parameters t' y', InputSignal t t' y y' yv) ->
   (OutputSignal t t' y y' yv, Results t' y')
amplify volume ((srY,ampY), sigX) =
   let (srYResult,  srXResult)  = Logic.equal srY (SigP.sampleRate sigX)
       (ampYResult, ampXResult) = Logic.scale volume ampY (SigP.amplitude sigX)
   in  (SigP.replaceParameters srYResult ampYResult sigX,
        (srXResult, ampXResult))

negate :: (Additive.C yv, Eq t', Eq y') =>
   (Parameters t' y', InputSignal t t' y y' yv) ->
   (OutputSignal t t' y y' yv, Results t' y')
negate ((srY,ampY), sigX) =
   let (srYResult,  srXResult)  = Logic.equal srY  (SigP.sampleRate sigX)
       (ampYResult, ampXResult) = Logic.equal ampY (SigP.amplitude  sigX)
   in  (SigP.cons srYResult ampYResult
          (Additive.negate (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
envelope :: (Module.C y v, Field.C q, Eq q) =>
      SigI.T a q y  {- ^ the envelope -}
   -> SigI.T a q v  {- ^ the signal to be enveloped -}
   -> SigI.Process a q v
envelope y x =
   do sampleRate <- Process.fromExpr (sampleRateExpr x =!= sampleRateExpr y)
      amplitude  <- Process.fromExpr (amplitudeExpr  x  *  amplitudeExpr  y)
      SigI.returnCons sampleRate amplitude
         (FiltNR.envelopeVector (SigP.samples y) (SigP.samples x))
-}


{- |
Although the routine could derive the sample rate
from the ratio of amplitudes,
this seems to be not very sensible,
since the choice of amplitude value is quite arbitrary
and the choice of sample rates is not.
-}
differentiate :: (Eq ty', Field.C ty', Additive.C yv) =>
   (Parameters ty' ty', InputSignal t ty' y ty' yv) ->
   (OutputSignal t ty' y ty' yv, Results ty' ty')
differentiate ((srY,ampY), sigX) =
   let srX = SigP.sampleRate sigX
       (srYResult,  srXResult)  = Logic.equal srY srX
       (_, ampXResult, ampYResult) = Logic.mul srX (SigP.amplitude sigX) ampY
   in  (SigP.cons srYResult ampYResult (FiltNR.differentiate (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
{- | needs a good handling of boundaries, yet -}
mean :: (Additive.C v, Field.C q, Eq q, RealField.C a,
         Module.C a v, OccScalar.C a q) =>
      q            {- ^ time length of the window -}
   -> SigI.T a q v
   -> SigI.Process a q v
mean time x =
   do t <- toTimeScalar x (Expr.constant time)
      let tInt  = round ((t-1)/2)
      let width = tInt*2+1
      returnModified []
         ((SigP.asTypeOfAmplitude (recip (fromIntegral width)) x *> ) .
          Filt.sums width . FiltNR.delay tInt) x


delay :: (Additive.C v, Field.C q, Eq q, RealField.C a, OccScalar.C a q) =>
      q
   -> SigI.T a q v
   -> SigI.Process a q v
delay time x =
   do t <- toTimeScalar x (Expr.constant time)
      returnModified [] (FiltNR.delay (round t)) x


phaseModulation ::
         (Additive.C v, Field.C q, Eq q, RealField.C a, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ minDelay, minimal delay, may be negative -}
   -> q   {- ^ maxDelay, maximal delay, it must be @minDelay <= maxDelay@
               and the modulation must always be
               in the range [minDelay,maxDelay]. -}
   -> SigI.T a q a
          {- ^ delay control, positive numbers mean delay,
               negative numbers mean prefetch -}
   -> SigI.T a q v
   -> SigI.Process a q v
phaseModulation ip minDelay maxDelay delays x =
   do t0 <- toTimeScalar x (Expr.constant minDelay)
      t1 <- toTimeScalar x (Expr.constant maxDelay)
      let tInt0 = floor   t0
      let tInt1 = ceiling t1
      let tInt0Neg = Additive.negate tInt0
      ds <- SigI.scalarSamples (toTimeScalar delays) delays
      returnModified [SigP.sampleRate delays]
         (FiltNR.delay tInt0 .
             Delay.modulated ip (tInt1-tInt0+1)
               (FiltNR.delay tInt0Neg
                  (Syn.raise (fromIntegral tInt0Neg)
                     (map (limit (t0,t1)) ds)))) x


{- | symmetric phaser -}
phaser :: (Additive.C v, Field.C q, Eq q, RealField.C a,
           Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive -}
   -> SigI.T a q a
          {- ^ delay control -}
   -> SigI.T a q v
   -> SigI.Process a q v
phaser ip maxDelay delays x =
   amplify (asTypeOf 0.5 maxDelay) =<<
      uncurry SynI.mix =<< phaserCore ip maxDelay delays x

phaserStereo :: (Additive.C v, Field.C q, Eq q, Real.C q, RealField.C a,
                 Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive -}
   -> SigI.T a q a
          {- ^ delay control -}
   -> SigI.T a q v
   -> SigI.Process a q (v,v)
phaserStereo ip maxDelay delays x =
   uncurry CutI.zip =<< phaserCore ip maxDelay delays x

phaserCore :: (Additive.C v, Field.C q, Eq q, RealField.C a,
               Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive -}
   -> SigI.T a q a
          {- ^ delay control -}
   -> SigI.T a q v
   -> Process.T q (SigI.T a q v, SigI.T a q v)
phaserCore ip maxDelay delays x =
   do let minDelay = Additive.negate maxDelay
      negDelays <- InferenceFunc.Filter.negate delays
      liftM2 (,)
         (phaseModulation ip minDelay maxDelay delays x)
         (phaseModulation ip minDelay maxDelay negDelays x)



firstOrderLowpass, firstOrderHighpass ::
   (Trans.C a, Trans.C q, Eq q, Module.C a v, OccScalar.C a q) =>
      SigI.T a q a {- ^ Control signal for the cut-off frequency. -}
   -> SigI.T a q v {- ^ Input signal -}
   -> SigI.Process a q v
firstOrderLowpass  = firstOrderGen Syn.lowpass1stOrder
firstOrderHighpass = firstOrderGen Syn.highpass1stOrder

firstOrderGen :: (Trans.C a, Trans.C q, Eq q, Module.C a v, OccScalar.C a q) =>
      ([a] -> [v] -> [v])
   -> SigI.T a q a
   -> SigI.T a q v
   -> SigI.Process a q v
firstOrderGen filt freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      returnModified [SigP.sampleRate freq]
         (filt (map Syn.lowpass1stOrderParam freqs)) x


butterworthLowpass, butterworthHighpass,
   chebyshevALowpass, chebyshevAHighpass,
   chebyshevBLowpass, chebyshevBHighpass ::
      (Field.C q, Eq q, Trans.C a, VectorSpace.C a v, OccScalar.C a q) =>
      Int          {- ^ Order of the filter, must be even,
                        the higher the order, the sharper is the separation of frequencies. -}
   -> a            {- ^ The attenuation at the cut-off frequency.
                        Should be between 0 and 1. -}
   -> SigI.T a q a {- ^ Control signal for the cut-off frequency. -}
   -> SigI.T a q v {- ^ Input signal -}
   -> SigI.Process a q v

butterworthLowpass  = higherOrderNoResoGen Syn.butterworthLowpass
butterworthHighpass = higherOrderNoResoGen Syn.butterworthHighpass
chebyshevALowpass   = higherOrderNoResoGen Syn.chebyshevALowpass
chebyshevAHighpass  = higherOrderNoResoGen Syn.chebyshevAHighpass
chebyshevBLowpass   = higherOrderNoResoGen Syn.chebyshevBLowpass
chebyshevBHighpass  = higherOrderNoResoGen Syn.chebyshevBHighpass

higherOrderNoResoGen ::
   (Field.C q, Eq q, Ring.C a, OccScalar.C a q) =>
      (Int -> a -> [a] -> [v] -> [v])
   -> Int
   -> a
   -> SigI.T a q a
   -> SigI.T a q v
   -> SigI.Process a q v
higherOrderNoResoGen filt order ratio freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      returnModified [SigP.sampleRate freq]
         (filt order ratio freqs) x



universal :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      SigI.T a q a {- ^ signal for resonance,
                        i.e. factor of amplification at the resonance frequency
                        relatively to the transition band. -}
   -> SigI.T a q a {- ^ signal for cut off and band center frequency -}
   -> SigI.T a q v {- ^ input signal -}
   -> SigI.Process a q (v,v,v) {- ^ highpass, bandpass, lowpass filter -}
universal reso freq x =
   do resos <- SigI.scalarSamples (Process.exprToScalar) reso
      freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params =
             map UniFilter.parameter
                 (zipWith Syn.Pole resos freqs)
      returnModified [SigP.sampleRate reso, SigP.sampleRate freq]
         (UniFilter.run params) x

moogLowpass :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      Int
   -> SigI.T a q a {- ^ signal for resonance,
                        i.e. factor of amplification at the resonance frequency
                        relatively to the transition band. -}
   -> SigI.T a q a {- ^ signal for cut off and band center frequency -}
   -> SigI.T a q v
   -> SigI.Process a q v
moogLowpass order reso freq x =
   do resos <- SigI.scalarSamples (Process.exprToScalar) reso
      freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params =
             map (Moog.parameter order)
                 (zipWith Syn.Pole resos freqs)
      returnModified [SigP.sampleRate reso, SigP.sampleRate freq]
         (Moog.lowpass order params) x

allpassCascade :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      Int          {- ^ order, number of filters in the cascade -}
   -> a            {- ^ the phase shift to be achieved for the given frequency -}
   -> SigI.T a q a {- ^ lowest comb frequency -}
   -> SigI.T a q v
   -> SigI.Process a q v
allpassCascade order phase freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params = map (Syn.allpassCascadeParam order phase) freqs
      returnModified [SigP.sampleRate freq]
         (Syn.allpassCascade order params) x



{- | Infinitely many equi-delayed exponentially decaying echos. -}
comb :: (RealField.C a, Field.C q, Eq q, OccScalar.C a q, Module.C a v) =>
   q -> a -> SigI.T a q v -> SigI.Process a q v
comb time gain x =
   do t <- toTimeScalar x (Expr.constant time)
      returnModified [] (FiltR.comb (round t) gain) x
-}


integrate :: (Eq ty', Field.C ty', Additive.C yv) =>
   (Parameters ty' ty', InputSignal t ty' y ty' yv) ->
   (OutputSignal t ty' y ty' yv, Results ty' ty')
integrate ((srY,ampY), sigX) =
   let srX = SigP.sampleRate sigX
       (srYResult,  srXResult)  = Logic.equal srY srX
       (_, ampYResult, ampXResult) = Logic.mul srX ampY (SigP.amplitude sigX)
   in  (SigP.cons srYResult ampYResult (Integrate.run (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
returnModified :: (Eq q) =>
   [Process.Value q] -> ([v] -> [w]) -> SigI.T a q v -> SigI.Process a q w
returnModified sampleRates proc x =
   do let sampleRate = SigP.sampleRate x
      mapM_ (Process.equalValue sampleRate) sampleRates
      SigI.returnCons
         sampleRate (SigP.amplitude x)
         (proc (SigP.samples x))
-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleInstances #-}
{- |
Copyright   :  (c) Henning Thielemann 2006
License     :  GPL

Maintainer  :  synthesizer@henning-thielemann.de
Stability   :  provisional
Portability :  requires multi-parameter type classes
-}
module Synthesizer.Inference.Fix.Filter (
   {- * Non-recursive -}

   {- ** Amplification -}
   amplify,
   negate,
{-
   envelope,
-}
   {- ** Filter operators from calculus -}
   differentiate,

{-
   {- ** Smooth 
   mean,

   {- ** Delay 
   delay,
   phaseModulation,
   phaser,
   phaserStereo,


   {- * Recursive 

   {- ** Without resonance 
   firstOrderLowpass,
   firstOrderHighpass,
   butterworthLowpass,
   butterworthHighpass,
   chebyshevALowpass,
   chebyshevAHighpass,
   chebyshevBLowpass,
   chebyshevBHighpass,
   {- ** With resonance 
   universal,
   moogLowpass,
   {- ** Allpass 
   allpassCascade,
   {- ** Reverb 
   comb,
-}
   {- ** Filter operators from calculus -}
   integrate
) where

-- import qualified InferenceFix.Signal as SigF
import Synthesizer.Inference.Fix (InputSignal, OutputSignal, Parameters, Results)

import qualified UniqueLogicNP.Lazy.SingleStep as Logic

{-
import InferenceFix.Signal
   (toTimeScalar, toFrequencyScalar, sampleRateExpr,
    amplitudeExpr)
-}


import qualified Synthesizer.Physical.Signal as SigP
{-
import qualified Synthesizer.Plain.Displacement as Syn
import qualified Synthesizer.Plain.Interpolation as Interpolation
import qualified Synthesizer.Plain.Filter.Delay.ST as Delay
import qualified Synthesizer.Plain.Filter.Recursive    as FiltR
-}
import qualified Synthesizer.Plain.Filter.Recursive.Integration as Integrate
import qualified Synthesizer.Plain.Filter.NonRecursive as FiltNR
{-
import qualified InferenceFunc.Synthesizer as SynI
import qualified Synthesizer.Inference.Func.Cut         as CutI

import Data.Ord.HT (limit)

import qualified Algebra.OccasionallyScalar as OccScalar
import qualified Algebra.VectorSpace    as VectorSpace
import qualified Algebra.Module         as Module
import qualified Algebra.Transcendental as Trans
import qualified Algebra.RealField      as RealField
-}
import qualified Algebra.Field          as Field
-- import qualified Algebra.Real           as Real
-- import qualified Algebra.Ring           as Ring
import qualified Algebra.Additive       as Additive

-- import Control.Monad(liftM2)

-- import NumericPrelude hiding (negate)
import PreludeBase as P


{- | The amplification factor must be positive. -}
amplify :: (Eq t', Field.C y') =>
   y' ->
   (Parameters t' y', InputSignal t t' y y' yv) ->
   (OutputSignal t t' y y' yv, Results t' y')
amplify volume ((srY,ampY), sigX) =
   let (srYResult,  srXResult)  = Logic.equal srY (SigP.sampleRate sigX)
       (ampYResult, ampXResult) = Logic.scale volume ampY (SigP.amplitude sigX)
   in  (SigP.replaceParameters srYResult ampYResult sigX,
        (srXResult, ampXResult))

negate :: (Additive.C yv, Eq t', Eq y') =>
   (Parameters t' y', InputSignal t t' y y' yv) ->
   (OutputSignal t t' y y' yv, Results t' y')
negate ((srY,ampY), sigX) =
   let (srYResult,  srXResult)  = Logic.equal srY  (SigP.sampleRate sigX)
       (ampYResult, ampXResult) = Logic.equal ampY (SigP.amplitude  sigX)
   in  (SigP.cons srYResult ampYResult
          (Additive.negate (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
envelope :: (Module.C y v, Field.C q, Eq q) =>
      SigI.T a q y  {- ^ the envelope 
   -> SigI.T a q v  {- ^ the signal to be enveloped 
   -> SigI.Process a q v
envelope y x =
   do sampleRate <- Process.fromExpr (sampleRateExpr x =!= sampleRateExpr y)
      amplitude  <- Process.fromExpr (amplitudeExpr  x  *  amplitudeExpr  y)
      SigI.returnCons sampleRate amplitude
         (FiltNR.envelopeVector (SigP.samples y) (SigP.samples x))
-}


{- |
Although the routine could derive the sample rate
from the ratio of amplitudes,
this seems to be not very sensible,
since the choice of amplitude value is quite arbitrary
and the choice of sample rates is not.
-}
differentiate :: (Eq ty', Field.C ty', Additive.C yv) =>
   (Parameters ty' ty', InputSignal t ty' y ty' yv) ->
   (OutputSignal t ty' y ty' yv, Results ty' ty')
differentiate ((srY,ampY), sigX) =
   let srX = SigP.sampleRate sigX
       (srYResult,  srXResult)  = Logic.equal srY srX
       (_, ampXResult, ampYResult) = Logic.mul srX (SigP.amplitude sigX) ampY
   in  (SigP.cons srYResult ampYResult (FiltNR.differentiate (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
{- | needs a good handling of boundaries, yet 
mean :: (Additive.C v, Field.C q, Eq q, RealField.C a,
         Module.C a v, OccScalar.C a q) =>
      q            {- ^ time length of the window 
   -> SigI.T a q v
   -> SigI.Process a q v
mean time x =
   do t <- toTimeScalar x (Expr.constant time)
      let tInt  = round ((t-1)/2)
      let width = tInt*2+1
      returnModified []
         ((SigP.asTypeOfAmplitude (recip (fromIntegral width)) x *> ) .
          Filt.sums width . FiltNR.delay tInt) x


delay :: (Additive.C v, Field.C q, Eq q, RealField.C a, OccScalar.C a q) =>
      q
   -> SigI.T a q v
   -> SigI.Process a q v
delay time x =
   do t <- toTimeScalar x (Expr.constant time)
      returnModified [] (FiltNR.delay (round t)) x


phaseModulation ::
         (Additive.C v, Field.C q, Eq q, RealField.C a, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ minDelay, minimal delay, may be negative 
   -> q   {- ^ maxDelay, maximal delay, it must be @minDelay <= maxDelay@
               and the modulation must always be
               in the range [minDelay,maxDelay]. 
   -> SigI.T a q a
          {- ^ delay control, positive numbers mean delay,
               negative numbers mean prefetch 
   -> SigI.T a q v
   -> SigI.Process a q v
phaseModulation ip minDelay maxDelay delays x =
   do t0 <- toTimeScalar x (Expr.constant minDelay)
      t1 <- toTimeScalar x (Expr.constant maxDelay)
      let tInt0 = floor   t0
      let tInt1 = ceiling t1
      let tInt0Neg = Additive.negate tInt0
      ds <- SigI.scalarSamples (toTimeScalar delays) delays
      returnModified [SigP.sampleRate delays]
         (FiltNR.delay tInt0 .
             Delay.modulated ip (tInt1-tInt0+1)
               (FiltNR.delay tInt0Neg
                  (Syn.raise (fromIntegral tInt0Neg)
                     (map (limit (t0,t1)) ds)))) x


{- | symmetric phaser 
phaser :: (Additive.C v, Field.C q, Eq q, RealField.C a,
           Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive 
   -> SigI.T a q a
          {- ^ delay control 
   -> SigI.T a q v
   -> SigI.Process a q v
phaser ip maxDelay delays x =
   amplify (asTypeOf 0.5 maxDelay) =<<
      uncurry SynI.mix =<< phaserCore ip maxDelay delays x

phaserStereo :: (Additive.C v, Field.C q, Eq q, Real.C q, RealField.C a,
                 Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive 
   -> SigI.T a q a
          {- ^ delay control 
   -> SigI.T a q v
   -> SigI.Process a q (v,v)
phaserStereo ip maxDelay delays x =
   uncurry CutI.zip =<< phaserCore ip maxDelay delays x

phaserCore :: (Additive.C v, Field.C q, Eq q, RealField.C a,
               Module.C a v, OccScalar.C a q) =>
      Interpolation.T a v
   -> q   {- ^ maxDelay, must be positive 
   -> SigI.T a q a
          {- ^ delay control 
   -> SigI.T a q v
   -> Process.T q (SigI.T a q v, SigI.T a q v)
phaserCore ip maxDelay delays x =
   do let minDelay = Additive.negate maxDelay
      negDelays <- InferenceFunc.Filter.negate delays
      liftM2 (,)
         (phaseModulation ip minDelay maxDelay delays x)
         (phaseModulation ip minDelay maxDelay negDelays x)



firstOrderLowpass, firstOrderHighpass ::
   (Trans.C a, Trans.C q, Eq q, Module.C a v, OccScalar.C a q) =>
      SigI.T a q a {- ^ Control signal for the cut-off frequency. 
   -> SigI.T a q v {- ^ Input signal 
   -> SigI.Process a q v
firstOrderLowpass  = firstOrderGen Syn.lowpass1stOrder
firstOrderHighpass = firstOrderGen Syn.highpass1stOrder

firstOrderGen :: (Trans.C a, Trans.C q, Eq q, Module.C a v, OccScalar.C a q) =>
      ([a] -> [v] -> [v])
   -> SigI.T a q a
   -> SigI.T a q v
   -> SigI.Process a q v
firstOrderGen filt freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      returnModified [SigP.sampleRate freq]
         (filt (map Syn.lowpass1stOrderParam freqs)) x


butterworthLowpass, butterworthHighpass,
   chebyshevALowpass, chebyshevAHighpass,
   chebyshevBLowpass, chebyshevBHighpass ::
      (Field.C q, Eq q, Trans.C a, VectorSpace.C a v, OccScalar.C a q) =>
      Int          {- ^ Order of the filter, must be even,
                        the higher the order, the sharper is the separation of frequencies. 
   -> a            {- ^ The attenuation at the cut-off frequency.
                        Should be between 0 and 1. 
   -> SigI.T a q a {- ^ Control signal for the cut-off frequency. 
   -> SigI.T a q v {- ^ Input signal 
   -> SigI.Process a q v

butterworthLowpass  = higherOrderNoResoGen Syn.butterworthLowpass
butterworthHighpass = higherOrderNoResoGen Syn.butterworthHighpass
chebyshevALowpass   = higherOrderNoResoGen Syn.chebyshevALowpass
chebyshevAHighpass  = higherOrderNoResoGen Syn.chebyshevAHighpass
chebyshevBLowpass   = higherOrderNoResoGen Syn.chebyshevBLowpass
chebyshevBHighpass  = higherOrderNoResoGen Syn.chebyshevBHighpass

higherOrderNoResoGen ::
   (Field.C q, Eq q, Ring.C a, OccScalar.C a q) =>
      (Int -> a -> [a] -> [v] -> [v])
   -> Int
   -> a
   -> SigI.T a q a
   -> SigI.T a q v
   -> SigI.Process a q v
higherOrderNoResoGen filt order ratio freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      returnModified [SigP.sampleRate freq]
         (filt order ratio freqs) x



universal :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      SigI.T a q a {- ^ signal for resonance,
                        i.e. factor of amplification at the resonance frequency
                        relatively to the transition band. 
   -> SigI.T a q a {- ^ signal for cut off and band center frequency 
   -> SigI.T a q v {- ^ input signal 
   -> SigI.Process a q (v,v,v) {- ^ highpass, bandpass, lowpass filter 
universal reso freq x =
   do resos <- SigI.scalarSamples (Process.exprToScalar) reso
      freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params =
             map UniFilter.parameter
                 (zipWith Syn.Pole resos freqs)
      returnModified [SigP.sampleRate reso, SigP.sampleRate freq]
         (UniFilter.run params) x

moogLowpass :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      Int
   -> SigI.T a q a {- ^ signal for resonance,
                        i.e. factor of amplification at the resonance frequency
                        relatively to the transition band. 
   -> SigI.T a q a {- ^ signal for cut off and band center frequency 
   -> SigI.T a q v
   -> SigI.Process a q v
moogLowpass order reso freq x =
   do resos <- SigI.scalarSamples (Process.exprToScalar) reso
      freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params =
             map (Moog.parameter order)
                 (zipWith Syn.Pole resos freqs)
      returnModified [SigP.sampleRate reso, SigP.sampleRate freq]
         (Moog.lowpass order params) x

allpassCascade :: (Trans.C a, Module.C a v, Field.C q, Eq q, OccScalar.C a q) =>
      Int          {- ^ order, number of filters in the cascade 
   -> a            {- ^ the phase shift to be achieved for the given frequency 
   -> SigI.T a q a {- ^ lowest comb frequency 
   -> SigI.T a q v
   -> SigI.Process a q v
allpassCascade order phase freq x =
   do freqs <- SigI.scalarSamples (toFrequencyScalar x) freq
      let params = map (Syn.allpassCascadeParam order phase) freqs
      returnModified [SigP.sampleRate freq]
         (Syn.allpassCascade order params) x



{- | Infinitely many equi-delayed exponentially decaying echos. 
comb :: (RealField.C a, Field.C q, Eq q, OccScalar.C a q, Module.C a v) =>
   q -> a -> SigI.T a q v -> SigI.Process a q v
comb time gain x =
   do t <- toTimeScalar x (Expr.constant time)
      returnModified [] (FiltR.comb (round t) gain) x
-}


integrate :: (Eq ty', Field.C ty', Additive.C yv) =>
   (Parameters ty' ty', InputSignal t ty' y ty' yv) ->
   (OutputSignal t ty' y ty' yv, Results ty' ty')
integrate ((srY,ampY), sigX) =
   let srX = SigP.sampleRate sigX
       (srYResult,  srXResult)  = Logic.equal srY srX
       (_, ampYResult, ampXResult) = Logic.mul srX ampY (SigP.amplitude sigX)
   in  (SigP.cons srYResult ampYResult (Integrate.run (SigP.samples sigX)),
        (srXResult, ampXResult))


{-
returnModified :: (Eq q) =>
   [Process.Value q] -> ([v] -> [w]) -> SigI.T a q v -> SigI.Process a q w
returnModified sampleRates proc x =
   do let sampleRate = SigP.sampleRate x
      mapM_ (Process.equalValue sampleRate) sampleRates
      SigI.returnCons
         sampleRate (SigP.amplitude x)
         (proc (SigP.samples x))
-}

</pre>