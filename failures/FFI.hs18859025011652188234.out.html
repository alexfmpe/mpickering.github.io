<a href="FB2.hs12081991961746004787.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Fieldwise.hs13640931281925270571.out.html">next</a></br></br><pre>38c38
< {-# LINE 39 "src/ehc/Core/FFI.chs" #-}
---
> 
44c44
< {-# LINE 55 "src/ehc/Core/FFI.chs" #-}
---
> 
44a45
> 
44a46
> 
44a47
> 
44a48
> 
44a49
> 
44a50
> 
44a51
> 
44a52
> 
44a53
> 
44a54
> 
58c68
< {-# LINE 80 "src/ehc/Core/FFI.chs" #-}
---
> 
58a69
> 
58a70
> 
58a71
> 
58a72
> 
58a73
> 
58a74
> 
58a75
> 
58a76
> 
58a77
> 
58a78
> 
58a79
> 
84c105
< {-# LINE 131 "src/ehc/Core/FFI.chs" #-}
---
> 
84a106
> 
84a107
> 
84a108
> 
84a109
> 
84a110
> 
84a111
> 
84a112
> 
84a113
> 
84a114
> 
84a115
> 
84a116
> 
84a117
> 
84a118
> 
84a119
> 
84a120
> 
84a121
> 
84a122
> 
84a123
> 
84a124
> 
84a125
> 
84a126
> 
84a127
> 
84a128
> 
84a129
> 
84a130
> 
123c169
< {-# LINE 273 "src/ehc/Core/FFI.chs" #-}
---
> 
123a170
> 
123a171
> 
123a172
> 
123a173
> 
123a174
> 
123a175
> 
123a176
> 
123a177
> 
123a178
> 
123a179
> 
123a180
> 
123a181
> 
123a182
> 
123a183
> 
123a184
> 
123a185
> 
123a186
> 
123a187
> 
123a188
> 
123a189
> 
123a190
> 
123a191
> 
123a192
> 
123a193
> 
123a194
> 
123a195
> 
123a196
> 
123a197
> 
123a198
> 
123a199
> 
123a200
> 
123a201
> 
123a202
> 
123a203
> 
123a204
> 
123a205
> 
123a206
> 
123a207
> 
123a208
> 
123a209
> 
123a210
> 
123a211
> 
123a212
> 
123a213
> 
123a214
> 
123a215
> 
123a216
> 
123a217
> 
123a218
> 
123a219
> 
123a220
> 
123a221
> 
123a222
> 
123a223
> 
123a224
> 
123a225
> 
123a226
> 
123a227
> 
123a228
> 
123a229
> 
123a230
> 
123a231
> 
123a232
> 
123a233
> 
123a234
> 
123a235
> 
123a236
> 
123a237
> 
123a238
> 
123a239
> 
123a240
> 
123a241
> 
123a242
> 
123a243
> 
123a244
> 
123a245
> 
123a246
> 
123a247
> 
123a248
> 
123a249
> 
123a250
> 
123a251
> 
123a252
> 
123a253
> 
123a254
> 
123a255
> 
123a256
> 
123a257
> 
123a258
> 
123a259
> 
123a260
> 
123a261
> 
123a262
> 
123a263
> 
123a264
> 
123a265
> 
123a266
> 
123a267
> 
123a268
> 
123a269
> 
123a270
> 
123a271
> 
123a272
> 
132c281
< {-# LINE 287 "src/ehc/Core/FFI.chs" #-}
---
> 
132a282
> 
132a283
> 
132a284
> 
132a285
> 
132a286
> 
160c314
< {-# LINE 338 "src/ehc/Core/FFI.chs" #-}
---
> 
160a315
> 
160a316
> 
160a317
> 
160a318
> 
160a319
> 
160a320
> 
160a321
> 
160a322
> 
160a323
> 
160a324
> 
160a325
> 
160a326
> 
160a327
> 
160a328
> 
160a329
> 
160a330
> 
160a331
> 
160a332
> 
160a333
> 
160a334
> 
160a335
> 
160a336
> 
160a337
> 
177c354
< {-# LINE 360 "src/ehc/Core/FFI.chs" #-}
---
> 
177a355
> 
177a356
> 
177a357
> 
177a358
> 
177a359
> 
192c374
< {-# LINE 390 "src/ehc/Core/FFI.chs" #-}
---
> 
192a375
> 
192a376
> 
192a377
> 
192a378
> 
192a379
> 
192a380
> 
192a381
> 
192a382
> 
192a383
> 
192a384
> 
192a385
> 
192a386
> 
192a387
> 
192a388
> 
192a389
> 
205c402
< {-# LINE 408 "src/ehc/Core/FFI.chs" #-}
---
> 
205a403
> 
205a404
> 
205a405
> 
205a406
> 
205a407
> 
251c453
< {-# LINE 464 "src/ehc/Core/FFI.chs" #-}
---
> 
251a454
> 
251a455
> 
251a456
> 
251a457
> 
251a458
> 
251a459
> 
251a460
> 
251a461
> 
251a462
> 
251a463
> 
283a496
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Core.FFI
( tyNmFFIBoxBasicAnnot
, tyNmGBMayLiveAsTaggedPtr, tyNmGBTagPtrBasicAnnot
, ffiMkArgUnpack
, ffiMkResPack
, ffiEvalAdapt
, ffiCoreEvalAdapt
, ffiCoreMk
, ffeCoreMk
, ffiMbIORes
, ffiIOAdapt
, ffiCoreIOAdapt )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.CodeGen.BuiltinSizeInfo
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import qualified Data.Map as Map
import Data.List
import Data.Maybe
import UHC.Light.Compiler.CodeGen.BasicAnnot
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Gam.DataGam
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.Core.Utils
import qualified UHC.Light.Compiler.Core.SysF.AsTy as SysF
import UHC.Light.Compiler.Foreign.Extract
import UHC.Light.Compiler.Foreign.Boxing
import UHC.Light.Compiler.CodeGen.BuiltinPrims





{-# LINE 39 "src/ehc/Core/FFI.chs" #-}
-- | is ty going to be passed unboxed to ffi, return info about it if so?
tyNmFFIBoxBasicAnnot :: EHCOpts -> HsName -> Maybe BasicAnnot
tyNmFFIBoxBasicAnnot opts
  = const Nothing

{-# LINE 55 "src/ehc/Core/FFI.chs" #-}
-- | is ty living as a tagged pointer?
tyNmGBMayLiveAsTaggedPtr :: EHCOpts -> HsName -> Maybe BuiltinInfo
tyNmGBMayLiveAsTaggedPtr opts
  | otherwise                                = const Nothing

-- | BasicAnnot when unboxing also means living as tagged pointer
tyNmGBTagPtrBasicAnnot :: EHCOpts -> Bool -> HsName -> BasicAnnot -> BasicAnnot
tyNmGBTagPtrBasicAnnot opts box t annot
  = case tyNmGBMayLiveAsTaggedPtr opts t of
      Just x
        | otherwise             -> annot
      Nothing -> annot

{-# LINE 80 "src/ehc/Core/FFI.chs" #-}
-- | make argument, i.e. wrap given argument name in proper introduction with annotation about what it is
ffiMkArgUnpack
  :: EHCOpts
     -> DataGam
     -> (HsName -> BasicAnnot -> HsName -> intro)     -- make intro: node around basic type
     -> (HsName -> HsName -> intro)             -- make intro: enum
     -> (HsName -> HsName -> intro)             -- make intro: var
     -> (HsName -> HsName -> intro)             -- make intro: opaque
     -> (HsName -> HsName -> intro)             -- make intro: pointer
     -> HsName                              -- arg name
     -> Ty                                  -- its type
     -> intro
ffiMkArgUnpack
     opts dataGam
     mkNodeI mkEnumI mkVarI mkOpaqI mkPtrI
     argNm ty
  = mk
  where tyNm  = tyAppFunConNm ty
        mbAnn = tyNmFFIBoxBasicAnnot opts tyNm
        mk | isJust mbAnn                   = mkNodeI tyNm (tyNmGBTagPtrBasicAnnot opts False tyNm (fromJust mbAnn)) argNm
           | tyNmIsFFIEnumable dataGam tyNm = mkEnumI tyNm argNm
           | isJust (recMbRecRow ty)        = mkVarI  tyNm argNm
           | tyNmIsFFIOpaque dataGam tyNm   = mkOpaqI tyNm argNm
           | otherwise                      = mkPtrI  tyNm argNm

{-# LINE 131 "src/ehc/Core/FFI.chs" #-}
-- | make result, i.e. wrap given argument name in proper adaption with annotation about what it is
-- Note: 0-tuple is assumed to be Enumerable (change this here, and in the RTS, if the 0-tuple is to be regarded as a basis for extensible rows)
ffiMkResPack
  :: EHCOpts
     -> DataGam
     -> (BasicAnnot -> HsName -> intro)     -- make intro: node around basic type
     -> (HsName -> HsName -> intro)         -- make intro: enum
     -> (HsName -> intro)                   -- make intro: opaque
     -> (HsName -> HsName -> intro)         -- make intro: pointer
     -> (e -> intro -> e -> e)              -- make bind: let .. in
     -> (Ty -> HsName -> HsName -> e)       -- make expr: node
     -> (Ty -> HsName -> HsName -> e)       -- make expr: enum
     -> (Ty -> HsName -> HsName -> e)       -- make expr: opaq
     -> (Ty -> HsName -> HsName -> e)       -- make expr: ptr
     -> HsName                              -- arg name
     -> Ty                                  -- its type
     -> e                                   -- res value
     -> e
ffiMkResPack
     opts dataGam
     mkNodeI mkEnumI mkOpaqI mkPtrI
     mkBindE
     mkNodeE mkEnumE mkOpaqE mkPtrE
     resNm resTy res
  = mk
  where resTyNm  = tyAppFunConNm resTy
        mbAnn = tyNmFFIBoxBasicAnnot opts resTyNm
        mkE e = e resTy resTyNm resNm
        mk | isJust mbAnn                       = mkBindE res (mkNodeI (tyNmGBTagPtrBasicAnnot opts True resTyNm (fromJust mbAnn)) resNm) (mkE mkNodeE)
           | tyNmIsFFIEnumable dataGam resTyNm  = mkBindE res (mkEnumI resTyNm                                                     resNm) (mkE mkEnumE)
           | isRec && arity == 0                = mkBindE res (mkEnumI recNm                                                       resNm) (mkE mkEnumE)
           | isRec                              = mkBindE res (mkPtrI  recNm                                                       resNm) (mkE mkPtrE )
           | tyNmIsFFIOpaque dataGam resTyNm    = mkBindE res (mkOpaqI                                                             resNm) (mkE mkOpaqE)
           | otherwise                          = mkBindE res (mkPtrI  resTyNm                                                     resNm) (mkE mkPtrE )
           where isRec = isJust $ recMbRecRow resTy
                 arity = length $ snd $ tyRecExts resTy
                 recNm = builtinRecNm arity

{-# LINE 273 "src/ehc/Core/FFI.chs" #-}
-- | is type an IO type, if so return the IO type argument (result returned by IO)
ffiMbIORes :: EHCOpts -> Ty -> Maybe Ty
ffiMbIORes opts resTy
  = case appMbConApp resTy of
      Just (n,[a]) | ehcOptBuiltin opts ehbnIO == n
        -> Just a
      _ -> Nothing

{-# LINE 287 "src/ehc/Core/FFI.chs" #-}
-- | adapt type etc for IO ffi call
ffiIOAdapt
  :: EHCOpts
     -> (UID -> HsName)             -- make unique name (if needed so)
     -> (HsName -> Ty -> e -> e)              -- handle unit result
     -> (HsName -> Ty -> HsName -> Ty -> e -> e)    -- make tupled result, for state representation
     -> UID
     -> Ty                              -- IO result type
     -> ( [Ty]                          -- type of additional arguments
        , [HsName]                      -- names of additional arguments
        , e -> e                        -- wrapping/adaption of result
        )
ffiIOAdapt
     opts
     mkUniqNm
     mkUnitRes
     mkTupledRes
     uniq iores
  = ([tyState],[nmState],wrapRes)
  where tyState = appCon $ ehcOptBuiltin opts ehbnRealWorld
        [nmState,nmRes,nmIgnoreRes] = take 3 (map (mkUniqNm) (iterate uidNext uniq))
        wrapRes = mkTupledRes nmState (appDbg "ffiIOAdapt.mkTupledRes.state") nmRes (appDbg "ffiIOAdapt.mkTupledRes.res") . dealWithUnitRes
                where dealWithUnitRes
                        = case tyMbRecExts iores of
                            Just (_,[]) -> mkUnitRes nmIgnoreRes (appDbg "ffiIOAdapt.mkUnitRes")
                            _           -> id

{-# LINE 338 "src/ehc/Core/FFI.chs" #-}
-- | adapt type etc for IO ffi call, specialized for Core
ffiCoreIOAdapt
  :: EHCOpts
     -> UID
     -> Ty                              -- IO result type
     -> ([Ty],[HsName],CExpr -> CExpr)
ffiCoreIOAdapt
     opts
     uniq iores
  = ffiIOAdapt
      opts
      mkHNm
      (\          nmIgnoreRes ty r -> acoreLet1StrictTy nmIgnoreRes (SysF.ty2TyCforFFI opts ty) r $ acoreTup []                               )
      (\nmState _ nmRes       ty r -> acoreLet1StrictTy nmRes       (SysF.ty2TyCforFFI opts ty) r $ acoreTup [acoreVar nmState,acoreVar nmRes])
      uniq iores

{-# LINE 360 "src/ehc/Core/FFI.chs" #-}
-- | evaluate value etc for ffi call
ffiEvalAdapt
  :: ((HsName,Ty,intro,Bool) -> e -> e)     -- construct arg w.r.t. eval need, and bind to intro
     -> ((HsName,Ty,e,Bool) -> e)               -- construct result w.r.t. eval need
     -> [(HsName,Ty,intro,Bool)]                -- arg name + introduction + eval need
     -> (HsName,Ty,e,Bool)                      -- result
     -> e
ffiEvalAdapt
     evalBindArg
     evalRes
     args
     res
  = foldr evalBindArg (evalRes res) args

{-# LINE 390 "src/ehc/Core/FFI.chs" #-}
-- | evaluate value etc for ffi call, specialized for Core
ffiCoreEvalAdapt
  :: EHCOpts
     -> [(HsName,Ty,HsName,Bool)]           -- arg name + introduction + eval need
     -> (HsName,Ty,CExpr,Bool)              -- result
     -> CExpr
ffiCoreEvalAdapt opts
  = ffiEvalAdapt
      (\(n,ty,i,ev) e -> (if ev then acoreLet1StrictTy                                              else acoreLet1PlainTy) i (SysF.ty2TyCforFFI opts ty) (acoreVar n) e)
      (\(n,ty,e,ev)   ->  if ev then acoreLet1StrictTy n (SysF.ty2TyCforFFI opts ty) e (acoreVar n) else e               )


{-# LINE 408 "src/ehc/Core/FFI.chs" #-}
-- | Construct Core code for FFI
ffiCoreMk
  :: EHCOpts
     -> ( Ty -> CExpr           -- make FFI call
        )
     -> UID
     -> RCEEnv
     -> ForeignExtraction       -- the ffi info
     -> Ty                      -- original type signature of FFI
     -> CExpr
ffiCoreMk
     opts
     (mkFFI)
     uniq rceEnv
     foreignEntInfo
     tyFFI
  = acoreLamTy (zip nmArgL (map (SysF.ty2TyCforFFI opts) argTyL) ++ zip nmArgLExtra (repeat $ acoreTyErr "ffiCoreMk.nmArgLExtra.TBD"))
    $ ffiCoreEvalAdapt opts
        ( zip4 nmArgL argTyL nmArgPatL primArgNeedsEvalL )
        ( nmEvalRes
        , resTyAdapted
        , wrapRes
          $ acoreApp (mkFFI $ argTyL `appArr` resTyAdapted)
          $ map acoreVar nmArgPatL
        , primResNeedsEval
        )
  where (argTyL,resTy) = appUnArr tyFFI
        argLen = length argTyL
        (_,u1,u2) = mkNewLevUID2 uniq
        (nmRes:nmEvalRes:nmArgL) = take (argLen + 2) (map mkHNm (iterate uidNext u1))
        nmArgPatL = map (hsnUniqify HsNameUniqifier_FFIArg) nmArgL
        (resTyAdapted,argTyLExtra,nmArgLExtra,wrapRes)
           =
               case ffiMbIORes opts resTy of
                 Just iores
                   -> (iores,a,n,w)
                   where (a,n,w) = ffiCoreIOAdapt opts u2 iores
                 _ ->
                      (resTy,[],[],id)
        mbPrimNeedEval  =   maybe Nothing lookupPrimNeedsEval $ forextractMbEnt foreignEntInfo
        primArgNeedsEvalL
                        =   take argLen $ maybe (repeat True) (\p -> primArgNeedEval p ++ repeat True) mbPrimNeedEval
        primResNeedsEval
                        =   maybe False primResNeedEval mbPrimNeedEval

{-# LINE 464 "src/ehc/Core/FFI.chs" #-}
-- | Construct Core code for FFE
ffeCoreMk
  :: EHCOpts
     -> UID
     -> RCEEnv
     -> Ty                      -- original type signature of FFE
     -> ( CExpr -> CExpr        -- ffe wrapper
        , Ty                    -- corresponding type
        )
ffeCoreMk
     opts uniq rceEnv
     tyFFE
  = ( \e ->
          acoreLamTy (zipWith (\a t -> (a, SysF.ty2TyCforFFI opts t)) nmArgL argTyL)
          $ acoreLet1StrictTy nmEvalRes (SysF.ty2TyCforFFI opts resTyAdapted)
              (wrapRes $ acoreApp e $ map acoreVar nmArgL ++ argLExtra)
              (acoreVar nmEvalRes)
    , argTyL `appArr` resTyAdapted
    )
  where (argTyL,resTy) = appUnArr tyFFE
        argLen = length argTyL
        (nmRes:nmEvalRes:nmIOEvalRes:nmArgL) = map mkHNm $ mkNewLevUIDL (argLen+3) uniq
        (resTyAdapted,argLExtra,wrapRes)
           =
               case ffiMbIORes opts resTy of
                 Just iores
                   -> ( iores
                      , [acoreTup []]       -- (), unit, the world
                      , \e -> acoreExprSatSelCaseTy rceEnv (Just (nmIOEvalRes,acoreTyErr "ffeCoreMk.wrapRes")) e CTagRec nmIOEvalRes 1 Nothing
                      )
                 _ ->
                      (resTy,[],id)
</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Core.FFI
( tyNmFFIBoxBasicAnnot
, tyNmGBMayLiveAsTaggedPtr, tyNmGBTagPtrBasicAnnot
, ffiMkArgUnpack
, ffiMkResPack
, ffiEvalAdapt
, ffiCoreEvalAdapt
, ffiCoreMk
, ffeCoreMk
, ffiMbIORes
, ffiIOAdapt
, ffiCoreIOAdapt )
where
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.CodeGen.BuiltinSizeInfo
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import qualified Data.Map as Map
import Data.List
import Data.Maybe
import UHC.Light.Compiler.CodeGen.BasicAnnot
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Gam.DataGam
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.Core.Utils
import qualified UHC.Light.Compiler.Core.SysF.AsTy as SysF
import UHC.Light.Compiler.Foreign.Extract
import UHC.Light.Compiler.Foreign.Boxing
import UHC.Light.Compiler.CodeGen.BuiltinPrims






-- | is ty going to be passed unboxed to ffi, return info about it if so?
tyNmFFIBoxBasicAnnot :: EHCOpts -> HsName -> Maybe BasicAnnot
tyNmFFIBoxBasicAnnot opts
  = const Nothing












-- | is ty living as a tagged pointer?
tyNmGBMayLiveAsTaggedPtr :: EHCOpts -> HsName -> Maybe BuiltinInfo
tyNmGBMayLiveAsTaggedPtr opts
  | otherwise                                = const Nothing

-- | BasicAnnot when unboxing also means living as tagged pointer
tyNmGBTagPtrBasicAnnot :: EHCOpts -> Bool -> HsName -> BasicAnnot -> BasicAnnot
tyNmGBTagPtrBasicAnnot opts box t annot
  = case tyNmGBMayLiveAsTaggedPtr opts t of
      Just x
        | otherwise             -> annot
      Nothing -> annot













-- | make argument, i.e. wrap given argument name in proper introduction with annotation about what it is
ffiMkArgUnpack
  :: EHCOpts
     -> DataGam
     -> (HsName -> BasicAnnot -> HsName -> intro)     -- make intro: node around basic type
     -> (HsName -> HsName -> intro)             -- make intro: enum
     -> (HsName -> HsName -> intro)             -- make intro: var
     -> (HsName -> HsName -> intro)             -- make intro: opaque
     -> (HsName -> HsName -> intro)             -- make intro: pointer
     -> HsName                              -- arg name
     -> Ty                                  -- its type
     -> intro
ffiMkArgUnpack
     opts dataGam
     mkNodeI mkEnumI mkVarI mkOpaqI mkPtrI
     argNm ty
  = mk
  where tyNm  = tyAppFunConNm ty
        mbAnn = tyNmFFIBoxBasicAnnot opts tyNm
        mk | isJust mbAnn                   = mkNodeI tyNm (tyNmGBTagPtrBasicAnnot opts False tyNm (fromJust mbAnn)) argNm
           | tyNmIsFFIEnumable dataGam tyNm = mkEnumI tyNm argNm
           | isJust (recMbRecRow ty)        = mkVarI  tyNm argNm
           | tyNmIsFFIOpaque dataGam tyNm   = mkOpaqI tyNm argNm
           | otherwise                      = mkPtrI  tyNm argNm



























-- | make result, i.e. wrap given argument name in proper adaption with annotation about what it is
-- Note: 0-tuple is assumed to be Enumerable (change this here, and in the RTS, if the 0-tuple is to be regarded as a basis for extensible rows)
ffiMkResPack
  :: EHCOpts
     -> DataGam
     -> (BasicAnnot -> HsName -> intro)     -- make intro: node around basic type
     -> (HsName -> HsName -> intro)         -- make intro: enum
     -> (HsName -> intro)                   -- make intro: opaque
     -> (HsName -> HsName -> intro)         -- make intro: pointer
     -> (e -> intro -> e -> e)              -- make bind: let .. in
     -> (Ty -> HsName -> HsName -> e)       -- make expr: node
     -> (Ty -> HsName -> HsName -> e)       -- make expr: enum
     -> (Ty -> HsName -> HsName -> e)       -- make expr: opaq
     -> (Ty -> HsName -> HsName -> e)       -- make expr: ptr
     -> HsName                              -- arg name
     -> Ty                                  -- its type
     -> e                                   -- res value
     -> e
ffiMkResPack
     opts dataGam
     mkNodeI mkEnumI mkOpaqI mkPtrI
     mkBindE
     mkNodeE mkEnumE mkOpaqE mkPtrE
     resNm resTy res
  = mk
  where resTyNm  = tyAppFunConNm resTy
        mbAnn = tyNmFFIBoxBasicAnnot opts resTyNm
        mkE e = e resTy resTyNm resNm
        mk | isJust mbAnn                       = mkBindE res (mkNodeI (tyNmGBTagPtrBasicAnnot opts True resTyNm (fromJust mbAnn)) resNm) (mkE mkNodeE)
           | tyNmIsFFIEnumable dataGam resTyNm  = mkBindE res (mkEnumI resTyNm                                                     resNm) (mkE mkEnumE)
           | isRec && arity == 0                = mkBindE res (mkEnumI recNm                                                       resNm) (mkE mkEnumE)
           | isRec                              = mkBindE res (mkPtrI  recNm                                                       resNm) (mkE mkPtrE )
           | tyNmIsFFIOpaque dataGam resTyNm    = mkBindE res (mkOpaqI                                                             resNm) (mkE mkOpaqE)
           | otherwise                          = mkBindE res (mkPtrI  resTyNm                                                     resNm) (mkE mkPtrE )
           where isRec = isJust $ recMbRecRow resTy
                 arity = length $ snd $ tyRecExts resTy
                 recNm = builtinRecNm arity









































































































-- | is type an IO type, if so return the IO type argument (result returned by IO)
ffiMbIORes :: EHCOpts -> Ty -> Maybe Ty
ffiMbIORes opts resTy
  = case appMbConApp resTy of
      Just (n,[a]) | ehcOptBuiltin opts ehbnIO == n
        -> Just a
      _ -> Nothing







-- | adapt type etc for IO ffi call
ffiIOAdapt
  :: EHCOpts
     -> (UID -> HsName)             -- make unique name (if needed so)
     -> (HsName -> Ty -> e -> e)              -- handle unit result
     -> (HsName -> Ty -> HsName -> Ty -> e -> e)    -- make tupled result, for state representation
     -> UID
     -> Ty                              -- IO result type
     -> ( [Ty]                          -- type of additional arguments
        , [HsName]                      -- names of additional arguments
        , e -> e                        -- wrapping/adaption of result
        )
ffiIOAdapt
     opts
     mkUniqNm
     mkUnitRes
     mkTupledRes
     uniq iores
  = ([tyState],[nmState],wrapRes)
  where tyState = appCon $ ehcOptBuiltin opts ehbnRealWorld
        [nmState,nmRes,nmIgnoreRes] = take 3 (map (mkUniqNm) (iterate uidNext uniq))
        wrapRes = mkTupledRes nmState (appDbg "ffiIOAdapt.mkTupledRes.state") nmRes (appDbg "ffiIOAdapt.mkTupledRes.res") . dealWithUnitRes
                where dealWithUnitRes
                        = case tyMbRecExts iores of
                            Just (_,[]) -> mkUnitRes nmIgnoreRes (appDbg "ffiIOAdapt.mkUnitRes")
                            _           -> id

























-- | adapt type etc for IO ffi call, specialized for Core
ffiCoreIOAdapt
  :: EHCOpts
     -> UID
     -> Ty                              -- IO result type
     -> ([Ty],[HsName],CExpr -> CExpr)
ffiCoreIOAdapt
     opts
     uniq iores
  = ffiIOAdapt
      opts
      mkHNm
      (\          nmIgnoreRes ty r -> acoreLet1StrictTy nmIgnoreRes (SysF.ty2TyCforFFI opts ty) r $ acoreTup []                               )
      (\nmState _ nmRes       ty r -> acoreLet1StrictTy nmRes       (SysF.ty2TyCforFFI opts ty) r $ acoreTup [acoreVar nmState,acoreVar nmRes])
      uniq iores







-- | evaluate value etc for ffi call
ffiEvalAdapt
  :: ((HsName,Ty,intro,Bool) -> e -> e)     -- construct arg w.r.t. eval need, and bind to intro
     -> ((HsName,Ty,e,Bool) -> e)               -- construct result w.r.t. eval need
     -> [(HsName,Ty,intro,Bool)]                -- arg name + introduction + eval need
     -> (HsName,Ty,e,Bool)                      -- result
     -> e
ffiEvalAdapt
     evalBindArg
     evalRes
     args
     res
  = foldr evalBindArg (evalRes res) args

















-- | evaluate value etc for ffi call, specialized for Core
ffiCoreEvalAdapt
  :: EHCOpts
     -> [(HsName,Ty,HsName,Bool)]           -- arg name + introduction + eval need
     -> (HsName,Ty,CExpr,Bool)              -- result
     -> CExpr
ffiCoreEvalAdapt opts
  = ffiEvalAdapt
      (\(n,ty,i,ev) e -> (if ev then acoreLet1StrictTy                                              else acoreLet1PlainTy) i (SysF.ty2TyCforFFI opts ty) (acoreVar n) e)
      (\(n,ty,e,ev)   ->  if ev then acoreLet1StrictTy n (SysF.ty2TyCforFFI opts ty) e (acoreVar n) else e               )








-- | Construct Core code for FFI
ffiCoreMk
  :: EHCOpts
     -> ( Ty -> CExpr           -- make FFI call
        )
     -> UID
     -> RCEEnv
     -> ForeignExtraction       -- the ffi info
     -> Ty                      -- original type signature of FFI
     -> CExpr
ffiCoreMk
     opts
     (mkFFI)
     uniq rceEnv
     foreignEntInfo
     tyFFI
  = acoreLamTy (zip nmArgL (map (SysF.ty2TyCforFFI opts) argTyL) ++ zip nmArgLExtra (repeat $ acoreTyErr "ffiCoreMk.nmArgLExtra.TBD"))
    $ ffiCoreEvalAdapt opts
        ( zip4 nmArgL argTyL nmArgPatL primArgNeedsEvalL )
        ( nmEvalRes
        , resTyAdapted
        , wrapRes
          $ acoreApp (mkFFI $ argTyL `appArr` resTyAdapted)
          $ map acoreVar nmArgPatL
        , primResNeedsEval
        )
  where (argTyL,resTy) = appUnArr tyFFI
        argLen = length argTyL
        (_,u1,u2) = mkNewLevUID2 uniq
        (nmRes:nmEvalRes:nmArgL) = take (argLen + 2) (map mkHNm (iterate uidNext u1))
        nmArgPatL = map (hsnUniqify HsNameUniqifier_FFIArg) nmArgL
        (resTyAdapted,argTyLExtra,nmArgLExtra,wrapRes)
           =
               case ffiMbIORes opts resTy of
                 Just iores
                   -> (iores,a,n,w)
                   where (a,n,w) = ffiCoreIOAdapt opts u2 iores
                 _ ->
                      (resTy,[],[],id)
        mbPrimNeedEval  =   maybe Nothing lookupPrimNeedsEval $ forextractMbEnt foreignEntInfo
        primArgNeedsEvalL
                        =   take argLen $ maybe (repeat True) (\p -> primArgNeedEval p ++ repeat True) mbPrimNeedEval
        primResNeedsEval
                        =   maybe False primResNeedEval mbPrimNeedEval












-- | Construct Core code for FFE
ffeCoreMk
  :: EHCOpts
     -> UID
     -> RCEEnv
     -> Ty                      -- original type signature of FFE
     -> ( CExpr -> CExpr        -- ffe wrapper
        , Ty                    -- corresponding type
        )
ffeCoreMk
     opts uniq rceEnv
     tyFFE
  = ( \e ->
          acoreLamTy (zipWith (\a t -> (a, SysF.ty2TyCforFFI opts t)) nmArgL argTyL)
          $ acoreLet1StrictTy nmEvalRes (SysF.ty2TyCforFFI opts resTyAdapted)
              (wrapRes $ acoreApp e $ map acoreVar nmArgL ++ argLExtra)
              (acoreVar nmEvalRes)
    , argTyL `appArr` resTyAdapted
    )
  where (argTyL,resTy) = appUnArr tyFFE
        argLen = length argTyL
        (nmRes:nmEvalRes:nmIOEvalRes:nmArgL) = map mkHNm $ mkNewLevUIDL (argLen+3) uniq
        (resTyAdapted,argLExtra,wrapRes)
           =
               case ffiMbIORes opts resTy of
                 Just iores
                   -> ( iores
                      , [acoreTup []]       -- (), unit, the world
                      , \e -> acoreExprSatSelCaseTy rceEnv (Just (nmIOEvalRes,acoreTyErr "ffeCoreMk.wrapRes")) e CTagRec nmIOEvalRes 1 Nothing
                      )
                 _ ->
                      (resTy,[],id)

</pre>