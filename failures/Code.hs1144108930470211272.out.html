<a href="CML.hs14656452031461495731.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Code.hs144128232716531729.out.html">next</a></br></br><pre>4d3
< module Code where
5d3
< {-# LINE 2 "src-ag/Code.ag" #-}
6d3
< 
7c4
< import Pretty
---
> module Code where Pretty
14d10
< {-# LINE 15 "dist/build/Code.hs" #-}
15d10
< {-# LINE 146 "src-ag/Code.ag" #-}
17d11
< -- Unboxed tuples
18d11
< --   unbox  Whether unboxed tuples are wanted or not
19d11
< --   inh    The inherited attributes.
20d11
< --          If there are none, no unboxing can take place,
21d11
< --          because in that case the semantic function (a top-level identifier) would have an unboxed type.
22d11
< -- Of course we can't have an unboxed 1-tuple
23d11
< mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
24d11
< mkTupleExpr unbox noInh exprs | not unbox || noInh || length exprs == 1 = TupleExpr exprs
25d11
<                               | otherwise                               = UnboxedTupleExpr exprs
26d11
< mkTupleType :: Bool -> Bool -> Types -> Type
27d11
< mkTupleType unbox noInh tps | not unbox || noInh || length tps == 1 = TupleType tps
28d11
<                             | otherwise                             = UnboxedTupleType tps
29d11
< mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
30d11
< mkTupleLhs  unbox noInh comps | not unbox || noInh || length comps == 1 = TupleLhs comps
31d11
<                               | otherwise                               = UnboxedTupleLhs comps
32c12
< {-# LINE 33 "dist/build/Code.hs" #-}
---
> 
32a13
> 
32a14
> 
32a15
> 
32a16
> 
32a17
> 
32a18
> 
32a19
> 
32a20
> 
32a21
> 
32a22
> 
32a23
> 
32a24
> 
32a25
> 
32a26
> 
32a27
> 
32a28
> 
32a29
> 
32a30
> 
32a31
> 
32a32
> 
32a33
> 
40c41
< data CaseAlt = CaseAlt (Lhs) (Expr)
---
> 
49c50
< type CaseAlts = [CaseAlt]
---
> 
64c65
< data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
---
> 
73c74
< type Chunks = [Chunk]
---
> 
84d84
< data DataAlt = DataAlt (String) (Types)
85c85
<              | Record (String) (NamedTypes)
---
> 
85a86
> 
94c95
< type DataAlts = [DataAlt]
---
> 
140a142
> 
140a143
> 
140a144
> 
140a145
> 
140a146
> 
140a147
> 
140a148
> 
140a149
> 
140a150
> 
140a151
> 
140a152
> 
140a153
> -- Decls -------------------------------------------------------
140a154
> --   unbox  Whether unboxed tuples are wanted or not
140a155
> --   inh    The inherited attributes.
140a156
> --          If there are none, no unboxing can take place,
140a157
> --          because in that case the semantic function (a top-level identifier) would have an unboxed type.
140a158
> -- Of course we can't have an unboxed 1-tuple
140a159
> mkTupleExpr{-
140a160
>    alternatives:
140a161
>       alternative Cons:
140a162
>          child hd             : Decl
140a163
>          child tl             : Decls
140a164
>       alternative Nil:
140a165
> -}          :: Bool -> Bool -> Exprs -> Expr
140a166
> mkTupleExpr unbox noInh exprs | not unbox || noInh || length exprs == 1 = TupleExpr exprs
140a167
>                               | otherwise                               = UnboxedTupleExpr exprs
140a168
> mkTupleType :: Bool -> Bool -> Types -> Type
140a169
> mkTupleType unbox noInh tps | not unbox || noInh || length tps == 1 = TupleType tps
140a170
>                             | otherwise                             = UnboxedTupleType tps
140a171
> mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
140a172
> mkTupleLhs  unbox noInh comps | not unbox || noInh || length comps == 1 = TupleLhs comps
140a173
> -- Expr -------------------------------------------------------- otherwise                               = UnboxedTupleLhs comps CaseAlt = CaseAlt (Lhs) (Expr)
140a174
> 
140a175
> 
140a176
> 
140a177
> 
140a178
> 
140a179
> 
140a180
> 
140a181
> 
140a182
> type CaseAlts = [CaseAlt]
140a183
> 
140a184
> 
140a185
> 
140a186
> 
140a187
> 
140a188
> 
140a189
> 
140a190
> 
140a191
> 
140a192
> 
140a193
> 
140a194
> 
140a195
> 
140a196
> 
140a197
> data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
140a198
> 
140a199
> 
140a200
> 
140a201
> 
140a202
> 
140a203
> 
140a204
> 
140a205
> 
140a206
> type Chunks = [Chunk]
140a207
> 
140a208
> 
140a209
> 
140a210
> 
140a211
> 
140a212
> 
140a213
> 
140a214
> 
140a215
> 
140a216
> 
140a217
> data DataAlt = DataAlt (String) (Types)
140a218
>              | Record (String) (NamedTypes)
140a219
> 
140a220
> 
140a221
> 
140a222
> 
140a223
> 
140a224
> 
140a225
> 
140a226
> 
140a227
> type DataAlts = [DataAlt]
140a228
> 
140a229
> 
140a230
> 
140a231
> 
140a232
> 
140a233
> 
140a234
> 
140a235
> 
140a236
> 
140a237
> 
140a238
> 
140a239
> 
140a240
> 
140a241
> 
140a242
> 
140a243
> 
140a244
> 
140a245
> 
140a246
> 
140a247
> 
140a248
> 
140a249
> 
140a250
> 
140a251
> 
140a252
> 
140a253
> 
140a254
> 
140a255
> 
140a256
> 
140a257
> 
140a258
> 
140a259
> 
140a260
> 
140a261
> 
140a262
> 
140a263
> 
140a264
> 
140a265
> 
140a266
> 
140a267
> 
140a268
> 
140a269
> 
140a270
> 
140a271
> 
140a272
> 
140a273
> 
152d284
< -- Decls -------------------------------------------------------
153d284
< {-
154d284
<    alternatives:
155d284
<       alternative Cons:
156d284
<          child hd             : Decl
157d284
<          child tl             : Decls
158d284
<       alternative Nil:
159c285
< -}
---
> 
159a286
> 
159a287
> 
159a288
> 
159a289
> 
159a290
> 
159a291
> 
159a292
> 
161c294
< -- Expr --------------------------------------------------------
---
> 
353a487
> 
</pre></br><h2>original</h2></br><pre>

-- UUAGC 0.9.40.1 (src-ag/Code.ag)
module Code where
{-# LINE 2 "src-ag/Code.ag" #-}

import Pretty
import Patterns
import Data.List(partition)
import Data.Set(Set)
import qualified Data.Set as Set
import Data.Map(Map)
import qualified Data.Map as Map
{-# LINE 15 "dist/build/Code.hs" #-}
{-# LINE 146 "src-ag/Code.ag" #-}

-- Unboxed tuples
--   unbox  Whether unboxed tuples are wanted or not
--   inh    The inherited attributes.
--          If there are none, no unboxing can take place,
--          because in that case the semantic function (a top-level identifier) would have an unboxed type.
-- Of course we can't have an unboxed 1-tuple
mkTupleExpr :: Bool -> Bool -> Exprs -> Expr
mkTupleExpr unbox noInh exprs | not unbox || noInh || length exprs == 1 = TupleExpr exprs
                              | otherwise                               = UnboxedTupleExpr exprs
mkTupleType :: Bool -> Bool -> Types -> Type
mkTupleType unbox noInh tps | not unbox || noInh || length tps == 1 = TupleType tps
                            | otherwise                             = UnboxedTupleType tps
mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
mkTupleLhs  unbox noInh comps | not unbox || noInh || length comps == 1 = TupleLhs comps
                              | otherwise                               = UnboxedTupleLhs comps
{-# LINE 33 "dist/build/Code.hs" #-}
-- CaseAlt -----------------------------------------------------
{-
   alternatives:
      alternative CaseAlt:
         child left           : Lhs
         child expr           : Expr
-}
data CaseAlt = CaseAlt (Lhs) (Expr)
-- CaseAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : CaseAlt
         child tl             : CaseAlts
      alternative Nil:
-}
type CaseAlts = [CaseAlt]
-- Chunk -------------------------------------------------------
{-
   alternatives:
      alternative Chunk:
         child name           : {String}
         child comment        : Decl
         child info           : Decls
         child dataDef        : Decls
         child cataFun        : Decls
         child semDom         : Decls
         child semWrapper     : Decls
         child semFunctions   : Decls
         child semNames       : {[String]}
-}
data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))
-- Chunks ------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Chunk
         child tl             : Chunks
      alternative Nil:
-}
type Chunks = [Chunk]
-- DataAlt -----------------------------------------------------
{-
   alternatives:
      alternative DataAlt:
         child name           : {String}
         child args           : Types
      alternative Record:
         child name           : {String}
         child args           : NamedTypes
-}
data DataAlt = DataAlt (String) (Types)
             | Record (String) (NamedTypes)
-- DataAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : DataAlt
         child tl             : DataAlts
      alternative Nil:
-}
type DataAlts = [DataAlt]
-- Decl --------------------------------------------------------
{-
   alternatives:
      alternative Bind:
         child left           : Lhs
         child rhs            : Expr
      alternative BindLet:
         child left           : Lhs
         child rhs            : Expr
      alternative Comment:
         child txt            : {String}
      alternative Data:
         child name           : {String}
         child params         : {[String]}
         child alts           : DataAlts
         child strict         : {Bool}
         child derivings      : {[String]}
      alternative Decl:
         child left           : Lhs
         child rhs            : Expr
         child binds          : {Set String}
         child uses           : {Set String}
      alternative EvalDecl:
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative NewType:
         child name           : {String}
         child params         : {[String]}
         child con            : {String}
         child tp             : Type
      alternative PragmaDecl:
         child txt            : {String}
      alternative Resume:
         child monadic        : {Bool}
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative TSig:
         child name           : {String}
         child tp             : Type
      alternative Type:
         child name           : {String}
         child params         : {[String]}
         child tp             : Type
-}
data Decl = Bind (Lhs) (Expr)
          | BindLet (Lhs) (Expr)
          | Comment (String)
          | Data (String) (([String])) (DataAlts) (Bool) (([String]))
          | Decl (Lhs) (Expr) ((Set String)) ((Set String))
          | EvalDecl (String) (Lhs) (Expr)
          | NewType (String) (([String])) (String) (Type)
          | PragmaDecl (String)
          | Resume (Bool) (String) (Lhs) (Expr)
          | TSig (String) (Type)
          | Type (String) (([String])) (Type)
-- Decls -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Decl
         child tl             : Decls
      alternative Nil:
-}
type Decls = [Decl]
-- Expr --------------------------------------------------------
{-
   alternatives:
      alternative App:
         child name           : {String}
         child args           : Exprs
      alternative Case:
         child expr           : Expr
         child alts           : CaseAlts
      alternative Do:
         child stmts          : Decls
         child body           : Expr
      alternative InvokeExpr:
         child nt             : {String}
         child expr           : Expr
         child args           : Exprs
      alternative Lambda:
         child args           : Exprs
         child body           : Expr
      alternative Let:
         child decls          : Decls
         child body           : Expr
      alternative LineExpr:
         child expr           : Expr
      alternative PragmaExpr:
         child onLeftSide     : {Bool}
         child onNewLine      : {Bool}
         child txt            : {String}
         child expr           : Expr
      alternative ResultExpr:
         child nt             : {String}
         child expr           : Expr
      alternative ResumeExpr:
         child nt             : {String}
         child expr           : Expr
         child left           : Lhs
         child rhs            : Expr
      alternative SemFun:
         child nt             : {String}
         child args           : Exprs
         child body           : Expr
      alternative SimpleExpr:
         child txt            : {String}
      alternative TextExpr:
         child lns            : {[String]}
      alternative Trace:
         child txt            : {String}
         child expr           : Expr
      alternative TupleExpr:
         child exprs          : Exprs
      alternative TypedExpr:
         child expr           : Expr
         child tp             : Type
      alternative UnboxedTupleExpr:
         child exprs          : Exprs
-}
data Expr = App (String) (Exprs)
          | Case (Expr) (CaseAlts)
          | Do (Decls) (Expr)
          | InvokeExpr (String) (Expr) (Exprs)
          | Lambda (Exprs) (Expr)
          | Let (Decls) (Expr)
          | LineExpr (Expr)
          | PragmaExpr (Bool) (Bool) (String) (Expr)
          | ResultExpr (String) (Expr)
          | ResumeExpr (String) (Expr) (Lhs) (Expr)
          | SemFun (String) (Exprs) (Expr)
          | SimpleExpr (String)
          | TextExpr (([String]))
          | Trace (String) (Expr)
          | TupleExpr (Exprs)
          | TypedExpr (Expr) (Type)
          | UnboxedTupleExpr (Exprs)
-- Exprs -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Expr
         child tl             : Exprs
      alternative Nil:
-}
type Exprs = [Expr]
-- Lhs ---------------------------------------------------------
{-
   alternatives:
      alternative Fun:
         child name           : {String}
         child args           : Exprs
      alternative Pattern3:
         child pat3           : {Pattern}
      alternative Pattern3SM:
         child pat3           : {Pattern}
      alternative TupleLhs:
         child comps          : {[String]}
      alternative UnboxedTupleLhs:
         child comps          : {[String]}
      alternative Unwrap:
         child name           : {String}
         child sub            : Lhs
-}
data Lhs = Fun (String) (Exprs)
         | Pattern3 (Pattern)
         | Pattern3SM (Pattern)
         | TupleLhs (([String]))
         | UnboxedTupleLhs (([String]))
         | Unwrap (String) (Lhs)
-- NamedType ---------------------------------------------------
{-
   alternatives:
      alternative Named:
         child strict         : {Bool}
         child name           : {String}
         child tp             : Type
-}
data NamedType = Named (Bool) (String) (Type)
-- NamedTypes --------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : NamedType
         child tl             : NamedTypes
      alternative Nil:
-}
type NamedTypes = [NamedType]
-- Program -----------------------------------------------------
{-
   alternatives:
      alternative Program:
         child chunks         : Chunks
         child ordered        : {Bool}
-}
data Program = Program (Chunks) (Bool)
-- Type --------------------------------------------------------
{-
   alternatives:
      alternative Arr:
         child left           : Type
         child right          : Type
      alternative CtxApp:
         child left           : {[(String, [String])]}
         child right          : Type
      alternative List:
         child tp             : Type
      alternative NontermType:
         child name           : {String}
         child params         : {[String]}
         child deforested     : {Bool}
      alternative QuantApp:
         child left           : {String}
         child right          : Type
      alternative SimpleType:
         child txt            : {String}
      alternative TEither:
         child left           : Type
         child right          : Type
      alternative TIntMap:
         child value          : Type
      alternative TMap:
         child key            : Type
         child value          : Type
      alternative TMaybe:
         child tp             : Type
      alternative TupleType:
         child tps            : Types
      alternative TypeApp:
         child func           : Type
         child args           : Types
      alternative UnboxedTupleType:
         child tps            : Types
-}
data Type = Arr (Type) (Type)
          | CtxApp (([(String, [String])])) (Type)
          | List (Type)
          | NontermType (String) (([String])) (Bool)
          | QuantApp (String) (Type)
          | SimpleType (String)
          | TEither (Type) (Type)
          | TIntMap (Type)
          | TMap (Type) (Type)
          | TMaybe (Type)
          | TupleType (Types)
          | TypeApp (Type) (Types)
          | UnboxedTupleType (Types)
          deriving ( Show)
-- Types -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Type
         child tl             : Types
      alternative Nil:
-}
type Types = [Type]
</pre></br><h2>printed</h2></br><pre>

-- UUAGC 0.9.40.1 (src-ag/Code.ag)
module Code where Pretty
import Patterns
import Data.List(partition)
import Data.Set(Set)
import qualified Data.Set as Set
import Data.Map(Map)
import qualified Data.Map as Map























-- CaseAlt -----------------------------------------------------
{-
   alternatives:
      alternative CaseAlt:
         child left           : Lhs
         child expr           : Expr
-}

-- CaseAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : CaseAlt
         child tl             : CaseAlts
      alternative Nil:
-}

-- Chunk -------------------------------------------------------
{-
   alternatives:
      alternative Chunk:
         child name           : {String}
         child comment        : Decl
         child info           : Decls
         child dataDef        : Decls
         child cataFun        : Decls
         child semDom         : Decls
         child semWrapper     : Decls
         child semFunctions   : Decls
         child semNames       : {[String]}
-}

-- Chunks ------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Chunk
         child tl             : Chunks
      alternative Nil:
-}

-- DataAlt -----------------------------------------------------
{-
   alternatives:
      alternative DataAlt:
         child name           : {String}
         child args           : Types
      alternative Record:
         child name           : {String}
         child args           : NamedTypes
-}


-- DataAlts ----------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : DataAlt
         child tl             : DataAlts
      alternative Nil:
-}

-- Decl --------------------------------------------------------
{-
   alternatives:
      alternative Bind:
         child left           : Lhs
         child rhs            : Expr
      alternative BindLet:
         child left           : Lhs
         child rhs            : Expr
      alternative Comment:
         child txt            : {String}
      alternative Data:
         child name           : {String}
         child params         : {[String]}
         child alts           : DataAlts
         child strict         : {Bool}
         child derivings      : {[String]}
      alternative Decl:
         child left           : Lhs
         child rhs            : Expr
         child binds          : {Set String}
         child uses           : {Set String}
      alternative EvalDecl:
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative NewType:
         child name           : {String}
         child params         : {[String]}
         child con            : {String}
         child tp             : Type
      alternative PragmaDecl:
         child txt            : {String}
      alternative Resume:
         child monadic        : {Bool}
         child nt             : {String}
         child left           : Lhs
         child rhs            : Expr
      alternative TSig:
         child name           : {String}
         child tp             : Type
      alternative Type:
         child name           : {String}
         child params         : {[String]}
         child tp             : Type
-}











-- Decls -------------------------------------------------------
--   unbox  Whether unboxed tuples are wanted or not
--   inh    The inherited attributes.
--          If there are none, no unboxing can take place,
--          because in that case the semantic function (a top-level identifier) would have an unboxed type.
-- Of course we can't have an unboxed 1-tuple
mkTupleExpr{-
   alternatives:
      alternative Cons:
         child hd             : Decl
         child tl             : Decls
      alternative Nil:
-}          :: Bool -> Bool -> Exprs -> Expr
mkTupleExpr unbox noInh exprs | not unbox || noInh || length exprs == 1 = TupleExpr exprs
                              | otherwise                               = UnboxedTupleExpr exprs
mkTupleType :: Bool -> Bool -> Types -> Type
mkTupleType unbox noInh tps | not unbox || noInh || length tps == 1 = TupleType tps
                            | otherwise                             = UnboxedTupleType tps
mkTupleLhs :: Bool -> Bool -> [String] -> Lhs
mkTupleLhs  unbox noInh comps | not unbox || noInh || length comps == 1 = TupleLhs comps
-- Expr -------------------------------------------------------- otherwise                               = UnboxedTupleLhs comps CaseAlt = CaseAlt (Lhs) (Expr)








type CaseAlts = [CaseAlt]














data Chunk = Chunk (String) (Decl) (Decls) (Decls) (Decls) (Decls) (Decls) (Decls) (([String]))








type Chunks = [Chunk]










data DataAlt = DataAlt (String) (Types)
             | Record (String) (NamedTypes)








type DataAlts = [DataAlt]














































data Decl = Bind (Lhs) (Expr)
          | BindLet (Lhs) (Expr)
          | Comment (String)
          | Data (String) (([String])) (DataAlts) (Bool) (([String]))
          | Decl (Lhs) (Expr) ((Set String)) ((Set String))
          | EvalDecl (String) (Lhs) (Expr)
          | NewType (String) (([String])) (String) (Type)
          | PragmaDecl (String)
          | Resume (Bool) (String) (Lhs) (Expr)
          | TSig (String) (Type)
          | Type (String) (([String])) (Type)








type Decls = [Decl]

{-
   alternatives:
      alternative App:
         child name           : {String}
         child args           : Exprs
      alternative Case:
         child expr           : Expr
         child alts           : CaseAlts
      alternative Do:
         child stmts          : Decls
         child body           : Expr
      alternative InvokeExpr:
         child nt             : {String}
         child expr           : Expr
         child args           : Exprs
      alternative Lambda:
         child args           : Exprs
         child body           : Expr
      alternative Let:
         child decls          : Decls
         child body           : Expr
      alternative LineExpr:
         child expr           : Expr
      alternative PragmaExpr:
         child onLeftSide     : {Bool}
         child onNewLine      : {Bool}
         child txt            : {String}
         child expr           : Expr
      alternative ResultExpr:
         child nt             : {String}
         child expr           : Expr
      alternative ResumeExpr:
         child nt             : {String}
         child expr           : Expr
         child left           : Lhs
         child rhs            : Expr
      alternative SemFun:
         child nt             : {String}
         child args           : Exprs
         child body           : Expr
      alternative SimpleExpr:
         child txt            : {String}
      alternative TextExpr:
         child lns            : {[String]}
      alternative Trace:
         child txt            : {String}
         child expr           : Expr
      alternative TupleExpr:
         child exprs          : Exprs
      alternative TypedExpr:
         child expr           : Expr
         child tp             : Type
      alternative UnboxedTupleExpr:
         child exprs          : Exprs
-}
data Expr = App (String) (Exprs)
          | Case (Expr) (CaseAlts)
          | Do (Decls) (Expr)
          | InvokeExpr (String) (Expr) (Exprs)
          | Lambda (Exprs) (Expr)
          | Let (Decls) (Expr)
          | LineExpr (Expr)
          | PragmaExpr (Bool) (Bool) (String) (Expr)
          | ResultExpr (String) (Expr)
          | ResumeExpr (String) (Expr) (Lhs) (Expr)
          | SemFun (String) (Exprs) (Expr)
          | SimpleExpr (String)
          | TextExpr (([String]))
          | Trace (String) (Expr)
          | TupleExpr (Exprs)
          | TypedExpr (Expr) (Type)
          | UnboxedTupleExpr (Exprs)
-- Exprs -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Expr
         child tl             : Exprs
      alternative Nil:
-}
type Exprs = [Expr]
-- Lhs ---------------------------------------------------------
{-
   alternatives:
      alternative Fun:
         child name           : {String}
         child args           : Exprs
      alternative Pattern3:
         child pat3           : {Pattern}
      alternative Pattern3SM:
         child pat3           : {Pattern}
      alternative TupleLhs:
         child comps          : {[String]}
      alternative UnboxedTupleLhs:
         child comps          : {[String]}
      alternative Unwrap:
         child name           : {String}
         child sub            : Lhs
-}
data Lhs = Fun (String) (Exprs)
         | Pattern3 (Pattern)
         | Pattern3SM (Pattern)
         | TupleLhs (([String]))
         | UnboxedTupleLhs (([String]))
         | Unwrap (String) (Lhs)
-- NamedType ---------------------------------------------------
{-
   alternatives:
      alternative Named:
         child strict         : {Bool}
         child name           : {String}
         child tp             : Type
-}
data NamedType = Named (Bool) (String) (Type)
-- NamedTypes --------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : NamedType
         child tl             : NamedTypes
      alternative Nil:
-}
type NamedTypes = [NamedType]
-- Program -----------------------------------------------------
{-
   alternatives:
      alternative Program:
         child chunks         : Chunks
         child ordered        : {Bool}
-}
data Program = Program (Chunks) (Bool)
-- Type --------------------------------------------------------
{-
   alternatives:
      alternative Arr:
         child left           : Type
         child right          : Type
      alternative CtxApp:
         child left           : {[(String, [String])]}
         child right          : Type
      alternative List:
         child tp             : Type
      alternative NontermType:
         child name           : {String}
         child params         : {[String]}
         child deforested     : {Bool}
      alternative QuantApp:
         child left           : {String}
         child right          : Type
      alternative SimpleType:
         child txt            : {String}
      alternative TEither:
         child left           : Type
         child right          : Type
      alternative TIntMap:
         child value          : Type
      alternative TMap:
         child key            : Type
         child value          : Type
      alternative TMaybe:
         child tp             : Type
      alternative TupleType:
         child tps            : Types
      alternative TypeApp:
         child func           : Type
         child args           : Types
      alternative UnboxedTupleType:
         child tps            : Types
-}
data Type = Arr (Type) (Type)
          | CtxApp (([(String, [String])])) (Type)
          | List (Type)
          | NontermType (String) (([String])) (Bool)
          | QuantApp (String) (Type)
          | SimpleType (String)
          | TEither (Type) (Type)
          | TIntMap (Type)
          | TMap (Type) (Type)
          | TMaybe (Type)
          | TupleType (Types)
          | TypeApp (Type) (Types)
          | UnboxedTupleType (Types)
          deriving ( Show)
-- Types -------------------------------------------------------
{-
   alternatives:
      alternative Cons:
         child hd             : Type
         child tl             : Types
      alternative Nil:
-}
type Types = [Type]

</pre>