<a href="Tests.hs1974930991404280278.out.html">prev</a></br><a href="failures.html">home</a></br><a href="tests.hs3301111371227619358.out.html">next</a></br></br><pre>12c12
< main ∷ IO ()
---
> main :: IO ()
16d15
<          [ binWordGroup "Word8" (0 ∷ Word8)
17d15
<          , binWordGroup "Word16" (0 ∷ Word16)
18d15
<          , binWordGroup "Word32" (0 ∷ Word32)
19d15
<          , binWordGroup "Word64" (0 ∷ Word64)
20d15
<          , binWordGroup "Int8" (0 ∷ Int8)
21d15
<          , binWordGroup "Int16" (0 ∷ Int16)
22d15
<          , binWordGroup "Int32" (0 ∷ Int32)
23c16
<          , binWordGroup "Int64" (0 ∷ Int64)
---
>          [ binWordGroup "Word8" (0 :: Word8)
23a17
>          , binWordGroup "Word16" (0 :: Word16)
23a18
>          , binWordGroup "Word32" (0 :: Word32)
23a19
>          , binWordGroup "Word64" (0 :: Word64)
23a20
>          , binWordGroup "Int8" (0 :: Int8)
23a21
>          , binWordGroup "Int16" (0 :: Int16)
23a22
>          , binWordGroup "Int32" (0 :: Int32)
23a23
>          , binWordGroup "Int64" (0 :: Int64)
26c26
< sameType ∷ α → α → α
---
> sameType :: α -> α -> α
29d28
< binWordGroup ∷ (Show w, Arbitrary w, Integral w, Integral (UnsignedWord w),
30c29
<                 BinaryWord w) ⇒ TestName → w → TestTree
---
> binWordGroup :: (Show w, Arbitrary w, Integral w, Integral (UnsignedWord w),
30a30
>                 BinaryWord w) => TestName -> w -> TestTree
34c34
<   , testProperty "unwrappedAdd" $ \w₁ w₂ →
---
>   , testProperty "unwrappedAdd" $ \w₁ w₂ ->
38c38
<   , testProperty "unwrappedMul" $ \w₁ w₂ →
---
>   , testProperty "unwrappedMul" $ \w₁ w₂ ->
42a43
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE FlexibleContexts #-}

import Test.Tasty (TestName, TestTree, defaultMain, localOption, testGroup)
import Test.Tasty.QuickCheck hiding ((.&.))

import Data.Bits (Bits(..))
import Data.Int
import Data.Word
import Data.BinaryWord

main ∷ IO ()
main = defaultMain
     $ localOption (QuickCheckTests 10000)
     $ testGroup "Tests"
         [ binWordGroup "Word8" (0 ∷ Word8)
         , binWordGroup "Word16" (0 ∷ Word16)
         , binWordGroup "Word32" (0 ∷ Word32)
         , binWordGroup "Word64" (0 ∷ Word64)
         , binWordGroup "Int8" (0 ∷ Int8)
         , binWordGroup "Int16" (0 ∷ Int16)
         , binWordGroup "Int32" (0 ∷ Int32)
         , binWordGroup "Int64" (0 ∷ Int64)
         ]

sameType ∷ α → α → α
sameType = const id

binWordGroup ∷ (Show w, Arbitrary w, Integral w, Integral (UnsignedWord w),
                BinaryWord w) ⇒ TestName → w → TestTree
binWordGroup n w = testGroup n
  [ testProperty "allZeroes" $ popCount (sameType w allZeroes) == 0
  , testProperty "allOnes" $ popCount (sameType w allOnes) == bitSize w
  , testProperty "unwrappedAdd" $ \w₁ w₂ →
      let (h, l) = unwrappedAdd (sameType w w₁) w₂ in
        toInteger h * 2 ^ bitSize w + toInteger l ==
          toInteger w₁ + toInteger w₂
  , testProperty "unwrappedMul" $ \w₁ w₂ →
      let (h, l) = unwrappedMul (sameType w w₁) w₂ in
        toInteger h * 2 ^ bitSize w + toInteger l ==
          toInteger w₁ * toInteger w₂
  ]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE FlexibleContexts #-}

import Test.Tasty (TestName, TestTree, defaultMain, localOption, testGroup)
import Test.Tasty.QuickCheck hiding ((.&.))

import Data.Bits (Bits(..))
import Data.Int
import Data.Word
import Data.BinaryWord

main :: IO ()
main = defaultMain
     $ localOption (QuickCheckTests 10000)
     $ testGroup "Tests"
         [ binWordGroup "Word8" (0 :: Word8)
         , binWordGroup "Word16" (0 :: Word16)
         , binWordGroup "Word32" (0 :: Word32)
         , binWordGroup "Word64" (0 :: Word64)
         , binWordGroup "Int8" (0 :: Int8)
         , binWordGroup "Int16" (0 :: Int16)
         , binWordGroup "Int32" (0 :: Int32)
         , binWordGroup "Int64" (0 :: Int64)
         ]

sameType :: α -> α -> α
sameType = const id

binWordGroup :: (Show w, Arbitrary w, Integral w, Integral (UnsignedWord w),
                BinaryWord w) => TestName -> w -> TestTree
binWordGroup n w = testGroup n
  [ testProperty "allZeroes" $ popCount (sameType w allZeroes) == 0
  , testProperty "allOnes" $ popCount (sameType w allOnes) == bitSize w
  , testProperty "unwrappedAdd" $ \w₁ w₂ ->
      let (h, l) = unwrappedAdd (sameType w w₁) w₂ in
        toInteger h * 2 ^ bitSize w + toInteger l ==
          toInteger w₁ + toInteger w₂
  , testProperty "unwrappedMul" $ \w₁ w₂ ->
      let (h, l) = unwrappedMul (sameType w w₁) w₂ in
        toInteger h * 2 ^ bitSize w + toInteger l ==
          toInteger w₁ * toInteger w₂
  ]

</pre>