<a href="Facter.hs2817252261901915394.out.html">prev</a></br><a href="failures.html">home</a></br><a href="FAD.hs8357402621743532054.out.html">next</a></br></br><pre>57d56
< type family (a :: Factor *) $= (b :: Factor *) :: Bool where
58d56
<   (F n1 z1) $= (F n2 z2) = n1 == n2
59c57
<   a         $= b         = False
---
> type family                 $=a :: Factor *)    (b :: Factor *) :: Bool where
59a58
>             $=F n1 z1)    (F n2 z2) = n1 == n2
59a59
>             $=            b         = False
71d70
<   Extract s '[] = '( '[], Nothing )
72c71
<   Extract s (h ': t) =
---
>   Extract s     =       , Nothing
72a72
>   Extract s (h  : t) =
74d73
<       '(t, Just h)
75c74
<       '(h ': Fst (Extract s t), Snd (Extract s t))
---
>         t, Just h
75a75
>         h  : Fst (Extract s t), Snd (Extract s t)
92d91
<   Reorder '[]  x     = '[]
93d91
<   Reorder '[x] y     = '[x]
94d91
<   Reorder x '[]      = x
95c92
<   Reorder x (h ': t) = Reorder' (Extract h x) t
---
>   Reorder      x     = 
95a93
>   Reorder   x] y     =   x]
95a94
>   Reorder x          = x
95a95
>   Reorder x (h  : t) = Reorder' (Extract h x) t
101d100
<   Reorder' '(lst, Nothing) t = Reorder lst t
102c101
<   Reorder' '(lst, Just elt) t = elt ': (Reorder lst t)
---
>   Reorder'   lst, Nothing  t = Reorder lst t
102a102
>   Reorder'   lst, Just elt  t = elt  : (Reorder lst t)
106d105
< type family (a :: [Factor *]) @~ (b :: [Factor *]) :: Constraint where
107c106
<   a @~ b = (Normalize (a @- b) ~ '[])
---
> type family                   @~a :: [Factor *])    (b :: [Factor *]) :: Constraint where
107a107
>     @~    b = (Normalize (a @- b) ~    )
115d114
<   Normalize '[] = '[]
116d114
<   Normalize ((F n Zero) ': t) = Normalize t
117c115
<   Normalize (h ': t) = h ': Normalize t
---
>   Normalize     = 
117a116
>   Normalize ((F n Zero)  : t) = Normalize t
117a117
>   Normalize (h  : t) = h  : Normalize t
126d125
< type family (a :: [Factor *]) @@+ (b :: [Factor *]) :: [Factor *] where
127d125
<   '[]                 @@+ b                   = b
128d125
<   a                   @@+ '[]                 = a
129d125
<   ((F name z1) ': t1) @@+ ((F name z2) ': t2) = (F name (z1 #+ z2)) ': (t1 @@+ t2)
130c126
<   (h ': t)            @@+ b                   = h ': (t @@+ b)
---
> type family                   @@+a :: [Factor *])     (b :: [Factor *]) :: [Factor *] where
130a127
>                       @@+ b                   = b
130a128
>                       @@+                                           = a
130a129
>                       @@+(F name z1)  : t1)     ((F name z2)  : t2) = (F name (z1 #+ z2))  : (t1 @@+ t2)
130a130
>                       @@+h  : t)                b                   = h  : (t @@+ b)
134d133
< type family (a :: [Factor *]) @+ (b :: [Factor *]) :: [Factor *] where
135c134
<   a @+ b = a @@+ (Reorder b a)
---
> type family                   @+a :: [Factor *])    (b :: [Factor *]) :: [Factor *] where
135a135
>     @+    b = a @@+ (Reorder b a)
140d139
< type family (a :: [Factor *]) @@- (b :: [Factor *]) :: [Factor *] where
141d139
<   '[]                 @@- b                   = NegList b
142d139
<   a                   @@- '[]                 = a
143d139
<   ((F name z1) ': t1) @@- ((F name z2) ': t2) = (F name (z1 #- z2)) ': (t1 @@- t2)
144c140
<   (h ': t)            @@- b                   = h ': (t @@- b)
---
> type family                   @@-a :: [Factor *])     (b :: [Factor *]) :: [Factor *] where
144a141
>                       @@- b                   = NegList b
144a142
>                       @@-                                           = a
144a143
>                       @@-(F name z1)  : t1)     ((F name z2)  : t2) = (F name (z1 #- z2))  : (t1 @@- t2)
144a144
>                       @@-h  : t)                b                   = h  : (t @@- b)
148d147
< type family (a :: [Factor *]) @- (b :: [Factor *]) :: [Factor *] where
149d147
<   a @- a = '[]
150c148
<   a @- b = a @@- (Reorder b a)
---
> type family                   @-a :: [Factor *])    (b :: [Factor *]) :: [Factor *] where
150a149
>     @-    a = 
150a150
>     @-    b = a @@- (Reorder b a)
158d157
<   NegList '[]      = '[]
159c158
<   NegList (h ': t) = (NegDim h ': (NegList t))
---
>   NegList          = 
159a159
>   NegList (h  : t) = (NegDim h  : (NegList t))
163d162
< type family (base :: [Factor *]) @* (power :: Z) :: [Factor *] where
164d162
<   '[]                 @* power = '[]
165c163
<   ((F name num) ': t) @* power = (F name (num #* power)) ': (t @* power)
---
> type family                      @*base :: [Factor *])    (power :: Z) :: [Factor *] where
165a164
>                       @* power = 
165a165
>                       @*(F name num)  : t)    power = (F name (num #* power))  : (t @* power)
169d168
< type family (dims :: [Factor *]) @/ (z :: Z) :: [Factor *] where
170d168
<   '[]                 @/ z = '[]
171c169
<   ((F name num) ': t) @/ z = (F name (num #/ z)) ': (t @/ z)
---
> type family                      @/dims :: [Factor *])    (z :: Z) :: [Factor *] where
171a170
>                       @/ z = 
171a171
>                       @/(F name num)  : t)    z = (F name (num #/ z))  : (t @/ z)
171a172
> 
</pre></br><h2>original</h2></br><pre>{- Data/Metrology.Factor.hs

   The units Package
   Copyright (c) 2013 Richard Eisenberg
   eir@cis.upenn.edu

   This file defines the Factor kind and operations over lists of Factors.

   Factors represents dimensions and units raised to a power of integers, and the lists of Factors represents monomials of dimensions and units.
-}

{-# LANGUAGE TypeFamilies, DataKinds, TypeOperators, UndecidableInstances #-}

module Data.Metrology.Factor where

import GHC.Exts (Constraint)
import Data.Metrology.Z as Z
import Data.Type.Equality
import Data.Type.Bool

import Data.Singletons.Prelude

-- | This will only be used at the kind level. It holds a dimension or unit
-- with its exponent.
data Factor star = F star Z

----------------------------------------------------------
--- Set-like operations ----------------------------------
----------------------------------------------------------
{-
These functions are templates for type-level functions.
remove :: String -> [String] -> [String]
remove _ [] = []
remove s (h:t) = if s == h then t else h : remove s t

member :: String -> [String] -> Bool
member _ [] = False
member s (h:t) = s == h || member s t

extract :: String -> [String] -> ([String], Maybe String)
extract _ [] = ([], Nothing)
extract s (h:t) =
  if s == h
   then (t, Just s)
   else let (resList, resVal) = extract s t in (h : resList, resVal)

reorder :: [String] -> [String] -> [String]
reorder x [] = x
reorder x (h:t) =
  case extract h x of
    (lst, Nothing) -> reorder lst t
    (lst, Just elt) -> elt : (reorder lst t)
-}

infix 4 $=
-- | Do these Factors represent the same dimension?
type family (a :: Factor *) $= (b :: Factor *) :: Bool where
  (F n1 z1) $= (F n2 z2) = n1 == n2
  a         $= b         = False

-- | @(Extract s lst)@ pulls the Factor that matches s out of lst, returning a
--   diminished list and, possibly, the extracted Factor.
--
-- @
-- Extract A [A, B, C] ==> ([B, C], Just A
-- Extract F [A, B, C] ==> ([A, B, C], Nothing)
-- @
type family Extract (s :: Factor *)
                    (lst :: [Factor *])
                 :: ([Factor *], Maybe (Factor *)) where
  Extract s '[] = '( '[], Nothing )
  Extract s (h ': t) =
    If (s $= h)
      '(t, Just h)
      '(h ': Fst (Extract s t), Snd (Extract s t))

-- kind DimAnnotation = [Factor *]
-- a list of Factors forms a full annotation of a quantity's dimension

-- | Reorders a to be the in the same order as b, putting entries not in b at the end
--
-- @
-- Reorder [A 1, B 2] [B 5, A 2] ==> [B 2, A 1]
-- Reorder [A 1, B 2, C 3] [C 2, A 8] ==> [C 3, A 1, B 2]
-- Reorder [A 1, B 2] [B 4, C 1, A 9] ==> [B 2, A 1]
-- Reorder x x ==> x
-- Reorder x [] ==> x
-- Reorder [] x ==> []
-- @
type family Reorder (a :: [Factor *]) (b :: [Factor *]) :: [Factor *] where
  Reorder x    x     = x
  Reorder '[]  x     = '[]
  Reorder '[x] y     = '[x]
  Reorder x '[]      = x
  Reorder x (h ': t) = Reorder' (Extract h x) t

-- | Helper function in 'Reorder'
type family Reorder' (scrut :: ([Factor *], Maybe (Factor *)))
                     (t :: [Factor *])
                     :: [Factor *] where
  Reorder' '(lst, Nothing) t = Reorder lst t
  Reorder' '(lst, Just elt) t = elt ': (Reorder lst t)

infix 4 @~
-- | Check if two @[Factor *]@s should be considered to be equal
type family (a :: [Factor *]) @~ (b :: [Factor *]) :: Constraint where
  a @~ b = (Normalize (a @- b) ~ '[])

----------------------------------------------------------
--- Normalization ----------------------------------------
----------------------------------------------------------

-- | Take a @[Factor *]@ and remove any @Factor@s with an exponent of 0
type family Normalize (d :: [Factor *]) :: [Factor *] where
  Normalize '[] = '[]
  Normalize ((F n Zero) ': t) = Normalize t
  Normalize (h ': t) = h ': Normalize t

----------------------------------------------------------
--- Arithmetic -------------------------------------------
----------------------------------------------------------

infixl 6 @@+
-- | Adds corresponding exponents in two dimension, assuming the lists are
-- ordered similarly.
type family (a :: [Factor *]) @@+ (b :: [Factor *]) :: [Factor *] where
  '[]                 @@+ b                   = b
  a                   @@+ '[]                 = a
  ((F name z1) ': t1) @@+ ((F name z2) ': t2) = (F name (z1 #+ z2)) ': (t1 @@+ t2)
  (h ': t)            @@+ b                   = h ': (t @@+ b)

infixl 6 @+
-- | Adds corresponding exponents in two dimension, preserving order
type family (a :: [Factor *]) @+ (b :: [Factor *]) :: [Factor *] where
  a @+ b = a @@+ (Reorder b a)

infixl 6 @@-
-- | Subtract exponents in two dimensions, assuming the lists are ordered
-- similarly.
type family (a :: [Factor *]) @@- (b :: [Factor *]) :: [Factor *] where
  '[]                 @@- b                   = NegList b
  a                   @@- '[]                 = a
  ((F name z1) ': t1) @@- ((F name z2) ': t2) = (F name (z1 #- z2)) ': (t1 @@- t2)
  (h ': t)            @@- b                   = h ': (t @@- b)

infixl 6 @-
-- | Subtract exponents in two dimensions
type family (a :: [Factor *]) @- (b :: [Factor *]) :: [Factor *] where
  a @- a = '[]
  a @- b = a @@- (Reorder b a)

-- | negate a single @Factor@
type family NegDim (a :: Factor *) :: Factor * where
  NegDim (F n z) = F n (Z.Negate z)

-- | negate a list of @Factor@s
type family NegList (a :: [Factor *]) :: [Factor *] where
  NegList '[]      = '[]
  NegList (h ': t) = (NegDim h ': (NegList t))

infixl 7 @*
-- | Multiplication of the exponents in a dimension by a scalar
type family (base :: [Factor *]) @* (power :: Z) :: [Factor *] where
  '[]                 @* power = '[]
  ((F name num) ': t) @* power = (F name (num #* power)) ': (t @* power)

infixl 7 @/
-- | Division of the exponents in a dimension by a scalar
type family (dims :: [Factor *]) @/ (z :: Z) :: [Factor *] where
  '[]                 @/ z = '[]
  ((F name num) ': t) @/ z = (F name (num #/ z)) ': (t @/ z)
</pre></br><h2>printed</h2></br><pre>{- Data/Metrology.Factor.hs

   The units Package
   Copyright (c) 2013 Richard Eisenberg
   eir@cis.upenn.edu

   This file defines the Factor kind and operations over lists of Factors.

   Factors represents dimensions and units raised to a power of integers, and the lists of Factors represents monomials of dimensions and units.
-}

{-# LANGUAGE TypeFamilies, DataKinds, TypeOperators, UndecidableInstances #-}

module Data.Metrology.Factor where

import GHC.Exts (Constraint)
import Data.Metrology.Z as Z
import Data.Type.Equality
import Data.Type.Bool

import Data.Singletons.Prelude

-- | This will only be used at the kind level. It holds a dimension or unit
-- with its exponent.
data Factor star = F star Z

----------------------------------------------------------
--- Set-like operations ----------------------------------
----------------------------------------------------------
{-
These functions are templates for type-level functions.
remove :: String -> [String] -> [String]
remove _ [] = []
remove s (h:t) = if s == h then t else h : remove s t

member :: String -> [String] -> Bool
member _ [] = False
member s (h:t) = s == h || member s t

extract :: String -> [String] -> ([String], Maybe String)
extract _ [] = ([], Nothing)
extract s (h:t) =
  if s == h
   then (t, Just s)
   else let (resList, resVal) = extract s t in (h : resList, resVal)

reorder :: [String] -> [String] -> [String]
reorder x [] = x
reorder x (h:t) =
  case extract h x of
    (lst, Nothing) -> reorder lst t
    (lst, Just elt) -> elt : (reorder lst t)
-}

infix 4 $=
-- | Do these Factors represent the same dimension?
type family                 $=a :: Factor *)    (b :: Factor *) :: Bool where
            $=F n1 z1)    (F n2 z2) = n1 == n2
            $=            b         = False

-- | @(Extract s lst)@ pulls the Factor that matches s out of lst, returning a
--   diminished list and, possibly, the extracted Factor.
--
-- @
-- Extract A [A, B, C] ==> ([B, C], Just A
-- Extract F [A, B, C] ==> ([A, B, C], Nothing)
-- @
type family Extract (s :: Factor *)
                    (lst :: [Factor *])
                 :: ([Factor *], Maybe (Factor *)) where
  Extract s     =       , Nothing
  Extract s (h  : t) =
    If (s $= h)
        t, Just h
        h  : Fst (Extract s t), Snd (Extract s t)

-- kind DimAnnotation = [Factor *]
-- a list of Factors forms a full annotation of a quantity's dimension

-- | Reorders a to be the in the same order as b, putting entries not in b at the end
--
-- @
-- Reorder [A 1, B 2] [B 5, A 2] ==> [B 2, A 1]
-- Reorder [A 1, B 2, C 3] [C 2, A 8] ==> [C 3, A 1, B 2]
-- Reorder [A 1, B 2] [B 4, C 1, A 9] ==> [B 2, A 1]
-- Reorder x x ==> x
-- Reorder x [] ==> x
-- Reorder [] x ==> []
-- @
type family Reorder (a :: [Factor *]) (b :: [Factor *]) :: [Factor *] where
  Reorder x    x     = x
  Reorder      x     = 
  Reorder   x] y     =   x]
  Reorder x          = x
  Reorder x (h  : t) = Reorder' (Extract h x) t

-- | Helper function in 'Reorder'
type family Reorder' (scrut :: ([Factor *], Maybe (Factor *)))
                     (t :: [Factor *])
                     :: [Factor *] where
  Reorder'   lst, Nothing  t = Reorder lst t
  Reorder'   lst, Just elt  t = elt  : (Reorder lst t)

infix 4 @~
-- | Check if two @[Factor *]@s should be considered to be equal
type family                   @~a :: [Factor *])    (b :: [Factor *]) :: Constraint where
    @~    b = (Normalize (a @- b) ~    )

----------------------------------------------------------
--- Normalization ----------------------------------------
----------------------------------------------------------

-- | Take a @[Factor *]@ and remove any @Factor@s with an exponent of 0
type family Normalize (d :: [Factor *]) :: [Factor *] where
  Normalize     = 
  Normalize ((F n Zero)  : t) = Normalize t
  Normalize (h  : t) = h  : Normalize t

----------------------------------------------------------
--- Arithmetic -------------------------------------------
----------------------------------------------------------

infixl 6 @@+
-- | Adds corresponding exponents in two dimension, assuming the lists are
-- ordered similarly.
type family                   @@+a :: [Factor *])     (b :: [Factor *]) :: [Factor *] where
                      @@+ b                   = b
                      @@+                                           = a
                      @@+(F name z1)  : t1)     ((F name z2)  : t2) = (F name (z1 #+ z2))  : (t1 @@+ t2)
                      @@+h  : t)                b                   = h  : (t @@+ b)

infixl 6 @+
-- | Adds corresponding exponents in two dimension, preserving order
type family                   @+a :: [Factor *])    (b :: [Factor *]) :: [Factor *] where
    @+    b = a @@+ (Reorder b a)

infixl 6 @@-
-- | Subtract exponents in two dimensions, assuming the lists are ordered
-- similarly.
type family                   @@-a :: [Factor *])     (b :: [Factor *]) :: [Factor *] where
                      @@- b                   = NegList b
                      @@-                                           = a
                      @@-(F name z1)  : t1)     ((F name z2)  : t2) = (F name (z1 #- z2))  : (t1 @@- t2)
                      @@-h  : t)                b                   = h  : (t @@- b)

infixl 6 @-
-- | Subtract exponents in two dimensions
type family                   @-a :: [Factor *])    (b :: [Factor *]) :: [Factor *] where
    @-    a = 
    @-    b = a @@- (Reorder b a)

-- | negate a single @Factor@
type family NegDim (a :: Factor *) :: Factor * where
  NegDim (F n z) = F n (Z.Negate z)

-- | negate a list of @Factor@s
type family NegList (a :: [Factor *]) :: [Factor *] where
  NegList          = 
  NegList (h  : t) = (NegDim h  : (NegList t))

infixl 7 @*
-- | Multiplication of the exponents in a dimension by a scalar
type family                      @*base :: [Factor *])    (power :: Z) :: [Factor *] where
                      @* power = 
                      @*(F name num)  : t)    power = (F name (num #* power))  : (t @* power)

infixl 7 @/
-- | Division of the exponents in a dimension by a scalar
type family                      @/dims :: [Factor *])    (z :: Z) :: [Factor *] where
                      @/ z = 
                      @/(F name num)  : t)    z = (F name (num #/ z))  : (t @/ z)

</pre>