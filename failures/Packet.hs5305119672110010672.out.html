<a href="PackageDatabase.hs21187978011060806853.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Pad.hs1622650073984943658.out.html">next</a></br></br><pre>72d71
<         = do n ← peekByteOff p 0
73d71
<              o ← peekByteOff p 1
74c72
<              return $! Packet (fromIntegral (n ∷ Word8)) o
---
>         = do n <- peekByteOff p 0
74a73
>              o <- peekByteOff p 1
74a74
>              return $! Packet (fromIntegral (n :: Word8)) o
77c77
<         = do pokeByteOff p 0 (fromIntegral n ∷ Word8)
---
>         = do pokeByteOff p 0 (fromIntegral n :: Word8)
105c105
<           δ ∷ Int
---
>           δ :: Int
128c128
<         = {-# CORE "Packet Left stream" #-}
---
>         = {-# CORE Packet Left stream #-}
138c138
<         = {-# CORE "Packet Left unstream" #-}
---
>         = {-# CORE Packet Left unstream #-}
141d140
<                 | n ≤ 8     → unId (unsafeConsume s0 0 0)
142d140
<                 | otherwise → packetOverflow
143c141
<             Nothing         → unId (safeConsume   s0 0 0)
---
>                 | n ≤ 8     -> unId (unsafeConsume s0 0 0)
143a142
>                 | otherwise -> packetOverflow
143a143
>             Nothing         -> unId (safeConsume   s0 0 0)
147c147
<               = do r ← step s
---
>               = do r <- step s
149d148
<                      Yield True  s' → unsafeConsume s' (i+1) (o `setBit` i)
150d148
<                      Yield False s' → unsafeConsume s' (i+1)  o
151d148
<                      Skip        s' → unsafeConsume s'  i     o
152c149
<                      Done           → return $! Packet i o
---
>                      Yield True  s' -> unsafeConsume s' (i+1) (o `setBit` i)
152a150
>                      Yield False s' -> unsafeConsume s' (i+1)  o
152a151
>                      Skip        s' -> unsafeConsume s'  i     o
152a152
>                      Done           -> return $! Packet i o
155c155
<               = do r ← step s
---
>               = do r <- step s
158c158
<                          | i < 8     → safeConsume s' (i+1) (if b
---
>                          | i < 8     -> safeConsume s' (i+1) (if b
161d160
<                          | otherwise → packetOverflow
162d160
<                      Skip    s'      → safeConsume s' i o
163c161
<                      Done            → return $! Packet i o
---
>                          | otherwise -> packetOverflow
163a162
>                      Skip    s'      -> safeConsume s' i o
163a163
>                      Done            -> return $! Packet i o
237c237
<         | otherwise = let n' ∷ Int
---
>         | otherwise = let n' :: Int
239c239
<                           o  ∷ Word8
---
>                           o  :: Word8
250c250
<         = {-# CORE "Packet Right stream" #-}
---
>         = {-# CORE Packet Right stream #-}
260c260
<         = {-# CORE "Packet Right unstream" #-}
---
>         = {-# CORE Packet Right unstream #-}
263d262
<                 | n ≤ 8     → unId (unsafeConsume s0 0 0)
264d262
<                 | otherwise → packetOverflow
265c263
<             Nothing         → unId (safeConsume   s0 0 0)
---
>                 | n ≤ 8     -> unId (unsafeConsume s0 0 0)
265a264
>                 | otherwise -> packetOverflow
265a265
>             Nothing         -> unId (safeConsume   s0 0 0)
269c269
<               = do r ← step s
---
>               = do r <- step s
271d270
<                      Yield True  s' → unsafeConsume s' (i+1) (o `setBit` (7-i))
272d270
<                      Yield False s' → unsafeConsume s' (i+1)  o
273d270
<                      Skip        s' → unsafeConsume s'  i     o
274c271
<                      Done           → return $! Packet i o
---
>                      Yield True  s' -> unsafeConsume s' (i+1) (o `setBit` (7-i))
274a272
>                      Yield False s' -> unsafeConsume s' (i+1)  o
274a273
>                      Skip        s' -> unsafeConsume s'  i     o
274a274
>                      Done           -> return $! Packet i o
277c277
<               = do r ← step s
---
>               = do r <- step s
280c280
<                          | i < 8     → safeConsume s' (i+1) (if b
---
>                          | i < 8     -> safeConsume s' (i+1) (if b
283d282
<                          | otherwise → packetOverflow
284d282
<                      Skip    s'      → safeConsume s' i o
285c283
<                      Done            → return $! Packet i o
---
>                          | otherwise -> packetOverflow
285a284
>                      Skip    s'      -> safeConsume s' i o
285a285
>                      Done            -> return $! Packet i o
359c359
<         | otherwise = let n' ∷ Int
---
>         | otherwise = let n' :: Int
361c361
<                           o  ∷ Word8
---
>                           o  :: Word8
372d371
< packetHeadL ∷ Packet Left → Bool
373c372
< {-# RULES "head → packetHeadL" [1] head = packetHeadL #-}
---
> packetHeadL :: Packet Left -> Bool
373a373
> {-# RULES "head \8594 packetHeadL" [1] head = packetHeadL #-}
378d377
< packetHeadR ∷ Packet Right → Bool
379c378
< {-# RULES "head → packetHeadR" [1] head = packetHeadR #-}
---
> packetHeadR :: Packet Right -> Bool
379a379
> {-# RULES "head \8594 packetHeadR" [1] head = packetHeadR #-}
384d383
< packetLastL ∷ Packet Left → Bool
385c384
< {-# RULES "last → packetLastL" [1] last = packetLastL #-}
---
> packetLastL :: Packet Left -> Bool
385a385
> {-# RULES "last \8594 packetLastL" [1] last = packetLastL #-}
390d389
< packetLastR ∷ Packet Right → Bool
391c390
< {-# RULES "head → packetLastR" [1] last = packetLastR #-}
---
> packetLastR :: Packet Right -> Bool
391a391
> {-# RULES "head \8594 packetLastR" [1] last = packetLastR #-}
396d395
< packetAndL ∷ Packet Left → Bool
397c396
< {-# RULES "and → packetAndL" [1] and = packetAndL #-}
---
> packetAndL :: Packet Left -> Bool
397a397
> {-# RULES "and \8594 packetAndL" [1] and = packetAndL #-}
401d400
< packetAndR ∷ Packet Right → Bool
402c401
< {-# RULES "and → packetAndR" [1] and = packetAndR #-}
---
> packetAndR :: Packet Right -> Bool
402a402
> {-# RULES "and \8594 packetAndR" [1] and = packetAndR #-}
406d405
< packetIndexL ∷ (Integral n, Show n) ⇒ Packet Left → n → Bool
407c406
< {-# RULES "(!!) → packetIndexL" [1] (!!) = packetIndexL #-}
---
> packetIndexL :: (Integral n, Show n) => Packet Left -> n -> Bool
407a407
> {-# RULES "(!!) \8594 packetIndexL" [1] (!!) = packetIndexL #-}
413d412
< packetIndexR ∷ (Integral n, Show n) ⇒ Packet Right → n → Bool
414c413
< {-# RULES "(!!) → packetIndexR" [1] (!!) = packetIndexR #-}
---
> packetIndexR :: (Integral n, Show n) => Packet Right -> n -> Bool
414a414
> {-# RULES "(!!) \8594 packetIndexR" [1] (!!) = packetIndexR #-}
420c420
< unsafePacketIndexL ∷ Integral n ⇒ Packet Left → n → Bool
---
> unsafePacketIndexL :: Integral n => Packet Left -> n -> Bool
425c425
< unsafePacketIndexR ∷ Integral n ⇒ Packet Right → n → Bool
---
> unsafePacketIndexR :: Integral n => Packet Right -> n -> Bool
430d429
< packetNull ∷ Packet d → Bool
431c430
< {-# RULES "null → packetNull" [1] null = packetNull #-}
---
> packetNull :: Packet d -> Bool
431a431
> {-# RULES "null \8594 packetNull" [1] null = packetNull #-}
436d435
< packetLength ∷ Num n ⇒ Packet d → n
437c436
< {-# RULES "length → packetLength" [1] length = packetLength #-}
---
> packetLength :: Num n => Packet d -> n
437a437
> {-# RULES "length \8594 packetLength" [1] length = packetLength #-}
441d440
< packetOr ∷ Packet d → Bool
442c441
< {-# RULES "or → packetOr" [1] or = packetOr #-}
---
> packetOr :: Packet d -> Bool
442a442
> {-# RULES "or \8594 packetOr" [1] or = packetOr #-}
447c447
< emptyNotAllowed ∷ α
---
> emptyNotAllowed :: α
451c451
< packetOverflow ∷ α
---
> packetOverflow :: α
455c455
< indexOutOfRange ∷ (Integral n, Show n) ⇒ n → α
---
> indexOutOfRange :: (Integral n, Show n) => n -> α
460c460
< full ∷ Packet d → Bool
---
> full :: Packet d -> Bool
466c466
< fromOctet ∷ Word8 → Packet d
---
> fromOctet :: Word8 -> Packet d
472c472
< toOctet ∷ Packet d → Word8
---
> toOctet :: Packet d -> Word8
477c477
< unsafeConsL ∷ Bool → Packet Left → Packet Left
---
> unsafeConsL :: Bool -> Packet Left -> Packet Left
482c482
< unsafeConsR ∷ Bool → Packet Right → Packet Right
---
> unsafeConsR :: Bool -> Packet Right -> Packet Right
487c487
< unsafeSnocL ∷ Packet Left → Bool → Packet Left
---
> unsafeSnocL :: Packet Left -> Bool -> Packet Left
492c492
< unsafeSnocR ∷ Packet Right → Bool → Packet Right
---
> unsafeSnocR :: Packet Right -> Bool -> Packet Right
499c499
< packetLToR ∷ Packet Left → Packet Right
---
> packetLToR :: Packet Left -> Packet Right
506c506
< packetRToL ∷ Packet Right → Packet Left
---
> packetRToL :: Packet Right -> Packet Left
511c511
< reverseBits ∷ Word8 → Word8
---
> reverseBits :: Word8 -> Word8
523c523
< scanlPacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool → Bool) → Bool → Packet d → Packet d
---
> scanlPacket :: Bitstream (Packet d) => (Bool -> Bool -> Bool) -> Bool -> Packet d -> Packet d
528d527
< takeWhilePacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
529c528
< takeWhilePacket f α = take (go 0 ∷ Int) α
---
> takeWhilePacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
529a529
> takeWhilePacket f α = take (go 0 :: Int) α
537d536
< dropWhilePacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
538c537
< dropWhilePacket f α = drop (go 0 ∷ Int) α
---
> dropWhilePacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
538a538
> dropWhilePacket f α = drop (go 0 :: Int) α
545c545
< filterPacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
---
> filterPacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
547a548
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , EmptyDataDecls
  , FlexibleContexts
  , FlexibleInstances
  , UnicodeSyntax
  #-}
-- | For internal use only.
module Data.Bitstream.Packet
    ( Left
    , Right

    , Packet

    , full

    , fromOctet
    , toOctet

    , packetLToR
    , packetRToL
    )
    where
import Data.Bitstream.Generic
import Data.Bits
import qualified Data.List as L
import Data.Ord
import qualified Data.Vector.Fusion.Stream as S
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Data.Vector.Fusion.Util
import Data.Word
import Foreign.Storable
import Prelude ( Bool(..), Eq(..), Int, Integral, Maybe(..)
               , Monad(..), Num(..), Show(..), ($!), error, fromIntegral
               , otherwise
               )
import Prelude.Unicode

-- | 'Left' bitstreams interpret an octet as a vector of bits whose
-- LSB comes first and MSB comes last e.g.
--
--   * 11110000 => [False, False, False, False, True, True , True , True]
--
--   * 10010100 => [False, False, True , False, True, False, False, True]
--
-- 'Bits' operations (like 'toBits') treat a 'Left' bitstream as a
-- little-endian integer.
data Left

-- | 'Right' bitstreams interpret an octet as a vector of bits whose
-- MSB comes first and LSB comes last e.g.
--
--   * 11110000 => [True, True , True , True, False, False, False, False]
--
--   * 10010100 => [True, False, False, True, False, True , False, False]
--
-- 'Bits' operations (like 'toBits') treat a 'Right' bitstream as a
-- big-endian integer.
data Right

-- | 'Packet's are strict 'Bitstream's having at most 8 bits.
data Packet d = Packet {-# UNPACK #-} !Int
                       {-# UNPACK #-} !Word8
    deriving (Eq)

instance Storable (Packet d) where
    sizeOf _  = 2
    alignment = sizeOf
    {-# INLINE peek #-}
    peek p
        = do n ← peekByteOff p 0
             o ← peekByteOff p 1
             return $! Packet (fromIntegral (n ∷ Word8)) o
    {-# INLINE poke #-}
    poke p (Packet n o)
        = do pokeByteOff p 0 (fromIntegral n ∷ Word8)
             pokeByteOff p 1 o

instance Show (Packet Left) where
    {-# INLINEABLE show #-}
    show (Packet n0 o0)
        = L.concat
          [ "["
          , L.unfoldr go (n0, o0)
          , "←]"
          ]
        where
          {-# INLINE go #-}
          go (0, _) = Nothing
          go (n, o)
              | o `testBit` (n-1) = Just ('1', (n-1, o))
              | otherwise         = Just ('0', (n-1, o))

instance Show (Packet Right) where
    {-# INLINEABLE show #-}
    show (Packet n0 o0)
        = L.concat
          [ "[→"
          , L.unfoldr go (n0, o0)
          , "]"
          ]
        where
          {-# INLINE δ #-}
          δ ∷ Int
          δ = 7 - n0
          {-# INLINE go #-}
          go (0, _) = Nothing
          go (n, o)
              | o `testBit` (n+δ) = Just ('1', (n-1, o))
              | otherwise         = Just ('0', (n-1, o))

instance Ord (Packet Left) where
    {-# INLINE compare #-}
    px `compare` py
        = comparing packetLToR px py

instance Ord (Packet Right) where
    {-# INLINE compare #-}
    (Packet nx ox) `compare` (Packet ny oy)
        = compare
          (ox `shiftR` (8-nx))
          (oy `shiftR` (8-ny))

instance Bitstream (Packet Left) where
    {-# INLINE basicStream #-}
    basicStream (Packet n o)
        = {-# CORE "Packet Left stream" #-}
          Stream step 0 (Exact n)
        where
          {-# INLINE step #-}
          step !i
              | i ≥ n     = return Done
              | otherwise = return $! Yield (o `testBit` i) (i+1)

    {-# INLINE basicUnstream #-}
    basicUnstream (Stream step s0 sz)
        = {-# CORE "Packet Left unstream" #-}
          case upperBound sz of
            Just n
                | n ≤ 8     → unId (unsafeConsume s0 0 0)
                | otherwise → packetOverflow
            Nothing         → unId (safeConsume   s0 0 0)
        where
          {-# INLINE unsafeConsume #-}
          unsafeConsume s !i !o
              = do r ← step s
                   case r of
                     Yield True  s' → unsafeConsume s' (i+1) (o `setBit` i)
                     Yield False s' → unsafeConsume s' (i+1)  o
                     Skip        s' → unsafeConsume s'  i     o
                     Done           → return $! Packet i o
          {-# INLINE safeConsume #-}
          safeConsume s !i !o
              = do r ← step s
                   case r of
                     Yield b s'
                         | i < 8     → safeConsume s' (i+1) (if b
                                                             then o `setBit` i
                                                             else o)
                         | otherwise → packetOverflow
                     Skip    s'      → safeConsume s' i o
                     Done            → return $! Packet i o

    {-# INLINE basicCons #-}
    basicCons b p
        | full p    = packetOverflow
        | otherwise = b `unsafeConsL` p

    {-# INLINE basicSnoc #-}
    basicSnoc p b
        | full p    = packetOverflow
        | otherwise = p `unsafeSnocL` b

    {-# INLINE basicAppend #-}
    basicAppend (Packet nx ox) (Packet ny oy)
        | nx + ny > 8 = packetOverflow
        | otherwise   = Packet (nx + ny) (ox .|. (oy `shiftL` nx))

    {-# INLINE basicTail #-}
    basicTail (Packet 0 _) = emptyNotAllowed
    basicTail (Packet n o) = Packet (n-1) (o `shiftR` 1)

    {-# INLINE basicInit #-}
    basicInit (Packet 0 _) = emptyNotAllowed
    basicInit (Packet n o) = Packet (n-1) o

    {-# INLINE basicMap #-}
    basicMap f (Packet n o0) = Packet n (go 0 o0)
        where
          {-# INLINE go #-}
          go i o
              | i ≥ n             = o
              | f (o `testBit` i) = go (i+1) (o `setBit`   i)
              | otherwise         = go (i+1) (o `clearBit` i)

    {-# INLINE basicReverse #-}
    basicReverse (Packet n o)
        = Packet n (reverseBits o `shiftR` (8-n))

    {-# INLINE basicScanl #-}
    basicScanl = scanlPacket

    {-# INLINE basicTake #-}
    basicTake l (Packet n o)
        | l ≤ 0      = (∅)
        | otherwise
            = let n' = fromIntegral (min (fromIntegral n) l)
                  o' = (0xFF `shiftR` (8-n')) .&. o
              in
                Packet n' o'

    {-# INLINE basicDrop #-}
    basicDrop l (Packet n o)
        | l ≤ 0      = Packet n o
        | otherwise
            = let d  = fromIntegral (min (fromIntegral n) l)
                  n' = n-d
                  o' = o `shiftR` d
              in
                Packet n' o'

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = takeWhilePacket

    {-# INLINE basicDropWhile #-}
    basicDropWhile = dropWhilePacket

    {-# INLINE basicFilter #-}
    basicFilter = filterPacket

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits n β
        | n < 0     = (∅)
        | n > 8     = packetOverflow
        | n ≡ 8     = Packet (fromIntegral n) (fromIntegral β)
        | otherwise = let n' ∷ Int
                          n' = fromIntegral n
                          o  ∷ Word8
                          o  = fromIntegral (β .&. ((1 `shiftL` n') - 1))
                      in Packet n' o

    {-# INLINE basicToBits #-}
    basicToBits = fromIntegral ∘ toOctet


instance Bitstream (Packet Right) where
    {-# INLINE basicStream #-}
    basicStream (Packet n o)
        = {-# CORE "Packet Right stream" #-}
          Stream step 0 (Exact n)
        where
          {-# INLINE step #-}
          step !i
              | i ≥ n     = return Done
              | otherwise = return $! Yield (o `testBit` (7-i)) (i+1)

    {-# INLINE basicUnstream #-}
    basicUnstream (Stream step s0 sz)
        = {-# CORE "Packet Right unstream" #-}
          case upperBound sz of
            Just n
                | n ≤ 8     → unId (unsafeConsume s0 0 0)
                | otherwise → packetOverflow
            Nothing         → unId (safeConsume   s0 0 0)
        where
          {-# INLINE unsafeConsume #-}
          unsafeConsume s i o
              = do r ← step s
                   case r of
                     Yield True  s' → unsafeConsume s' (i+1) (o `setBit` (7-i))
                     Yield False s' → unsafeConsume s' (i+1)  o
                     Skip        s' → unsafeConsume s'  i     o
                     Done           → return $! Packet i o
          {-# INLINE safeConsume #-}
          safeConsume s i o
              = do r ← step s
                   case r of
                     Yield b s'
                         | i < 8     → safeConsume s' (i+1) (if b
                                                             then o `setBit` (7-i)
                                                             else o)
                         | otherwise → packetOverflow
                     Skip    s'      → safeConsume s' i o
                     Done            → return $! Packet i o

    {-# INLINE basicCons #-}
    basicCons b p
        | full p    = packetOverflow
        | otherwise = b `unsafeConsR` p

    {-# INLINE basicSnoc #-}
    basicSnoc p b
        | full p    = packetOverflow
        | otherwise = p `unsafeSnocR` b

    {-# INLINE basicAppend #-}
    basicAppend (Packet nx ox) (Packet ny oy)
        | nx + ny > 8 = packetOverflow
        | otherwise   = Packet (nx + ny) (ox .|. (oy `shiftR` nx))

    {-# INLINE basicTail #-}
    basicTail (Packet 0 _) = emptyNotAllowed
    basicTail (Packet n o) = Packet (n-1) (o `shiftL` 1)

    {-# INLINE basicInit #-}
    basicInit (Packet 0 _) = emptyNotAllowed
    basicInit (Packet n o) = Packet (n-1) o

    {-# INLINE basicMap #-}
    basicMap f (Packet n o0) = Packet n (go 0 o0)
        where
          {-# INLINE go #-}
          go i o
              | i ≥ n                 = o
              | f (o `testBit` (7-i)) = go (i+1) (o `setBit`   (7-i))
              | otherwise             = go (i+1) (o `clearBit` (7-i))

    {-# INLINE basicReverse #-}
    basicReverse (Packet n o)
        = Packet n (reverseBits o `shiftL` (8-n))

    {-# INLINE basicScanl #-}
    basicScanl = scanlPacket

    {-# INLINE basicTake #-}
    basicTake l (Packet n o)
        | l ≤ 0      = (∅)
        | otherwise
            = let n' = fromIntegral (min (fromIntegral n) l)
                  o' = (0xFF `shiftL` (8-n')) .&. o
              in
                Packet n' o'

    {-# INLINE basicDrop #-}
    basicDrop l (Packet n o)
        | l ≤ 0      = Packet n o
        | otherwise
            = let d  = fromIntegral (min (fromIntegral n) l)
                  n' = n-d
                  o' = o `shiftL` d
              in
                Packet n' o'

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = takeWhilePacket

    {-# INLINE basicDropWhile #-}
    basicDropWhile = dropWhilePacket

    {-# INLINE basicFilter #-}
    basicFilter = filterPacket

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits n β
        | n < 0     = (∅)
        | n > 8     = packetOverflow
        | n ≡ 8     = Packet (fromIntegral n) (fromIntegral β)
        | otherwise = let n' ∷ Int
                          n' = fromIntegral n
                          o  ∷ Word8
                          o  = fromIntegral ( (β .&. ((1 `shiftL` n') - 1))
                                              `shiftL`
                                              (8-n')
                                            )
                      in Packet n' o

    {-# INLINE basicToBits #-}
    basicToBits (Packet n o)
        = fromIntegral (o `shiftR` (8-n))

packetHeadL ∷ Packet Left → Bool
{-# RULES "head → packetHeadL" [1] head = packetHeadL #-}
{-# INLINE packetHeadL #-}
packetHeadL (Packet 0 _) = emptyNotAllowed
packetHeadL (Packet _ o) = o `testBit` 0

packetHeadR ∷ Packet Right → Bool
{-# RULES "head → packetHeadR" [1] head = packetHeadR #-}
{-# INLINE packetHeadR #-}
packetHeadR (Packet 0 _) = emptyNotAllowed
packetHeadR (Packet _ o) = o `testBit` 7

packetLastL ∷ Packet Left → Bool
{-# RULES "last → packetLastL" [1] last = packetLastL #-}
{-# INLINE packetLastL #-}
packetLastL (Packet 0 _) = emptyNotAllowed
packetLastL (Packet n o) = o `testBit` (n-1)

packetLastR ∷ Packet Right → Bool
{-# RULES "head → packetLastR" [1] last = packetLastR #-}
{-# INLINE packetLastR #-}
packetLastR (Packet 0 _) = emptyNotAllowed
packetLastR (Packet n o) = o `testBit` (8-n)

packetAndL ∷ Packet Left → Bool
{-# RULES "and → packetAndL" [1] and = packetAndL #-}
{-# INLINE packetAndL #-}
packetAndL (Packet n o) = (0xFF `shiftR` (8-n)) ≡ o

packetAndR ∷ Packet Right → Bool
{-# RULES "and → packetAndR" [1] and = packetAndR #-}
{-# INLINE packetAndR #-}
packetAndR (Packet n o) = (0xFF `shiftL` (8-n)) ≡ o

packetIndexL ∷ (Integral n, Show n) ⇒ Packet Left → n → Bool
{-# RULES "(!!) → packetIndexL" [1] (!!) = packetIndexL #-}
{-# INLINE packetIndexL #-}
packetIndexL p i
    | i < 0 ∨ i ≥ length p = indexOutOfRange i
    | otherwise            = unsafePacketIndexL p i

packetIndexR ∷ (Integral n, Show n) ⇒ Packet Right → n → Bool
{-# RULES "(!!) → packetIndexR" [1] (!!) = packetIndexR #-}
{-# INLINE packetIndexR #-}
packetIndexR p i
    | i < 0 ∨ i ≥ length p = indexOutOfRange i
    | otherwise            = unsafePacketIndexR p i

unsafePacketIndexL ∷ Integral n ⇒ Packet Left → n → Bool
{-# INLINE unsafePacketIndexL #-}
unsafePacketIndexL (Packet _ o) i
    = o `testBit` fromIntegral i

unsafePacketIndexR ∷ Integral n ⇒ Packet Right → n → Bool
{-# INLINE unsafePacketIndexR #-}
unsafePacketIndexR (Packet _ o) i
    = o `testBit` (7 - fromIntegral i)

packetNull ∷ Packet d → Bool
{-# RULES "null → packetNull" [1] null = packetNull #-}
{-# INLINE packetNull #-}
packetNull (Packet 0 _) = True
packetNull _            = False

packetLength ∷ Num n ⇒ Packet d → n
{-# RULES "length → packetLength" [1] length = packetLength #-}
{-# INLINE packetLength #-}
packetLength (Packet n _) = fromIntegral n

packetOr ∷ Packet d → Bool
{-# RULES "or → packetOr" [1] or = packetOr #-}
{-# INLINE packetOr #-}
packetOr (Packet _ o) = o ≢ 0

{-# INLINE emptyNotAllowed #-}
emptyNotAllowed ∷ α
emptyNotAllowed = error "Data.Bitstream.Packet: packet is empty"

{-# INLINE packetOverflow #-}
packetOverflow ∷ α
packetOverflow = error "Data.Bitstream.Packet: packet size overflow"

{-# INLINE indexOutOfRange #-}
indexOutOfRange ∷ (Integral n, Show n) ⇒ n → α
indexOutOfRange n = error ("Data.Bitstream.Packet: index out of range: " L.++ show n)

-- | /O(1)/ @'full' p == 'True'@ iff @'length' p == 8@, otherwise it
-- returns 'False'.
full ∷ Packet d → Bool
{-# INLINE full #-}
full (Packet 8 _) = True
full _            = False

-- | /O(1)/ Convert an octet to 'Packet'.
fromOctet ∷ Word8 → Packet d
{-# INLINE fromOctet #-}
fromOctet = Packet 8

-- | /O(1)/ 'toOctet' @p@ converts a 'Packet' @p@ to an octet, padding
-- with zeroes if @'length' p < 8@.
toOctet ∷ Packet d → Word8
{-# INLINE toOctet #-}
toOctet (Packet _ o) = o

{-# INLINE unsafeConsL #-}
unsafeConsL ∷ Bool → Packet Left → Packet Left
unsafeConsL True  (Packet n o) = Packet (n+1) ((o `shiftL` 1) .|. 1)
unsafeConsL False (Packet n o) = Packet (n+1)  (o `shiftL` 1)

{-# INLINE unsafeConsR #-}
unsafeConsR ∷ Bool → Packet Right → Packet Right
unsafeConsR True  (Packet n o) = Packet (n+1) ((o `shiftR` 1) .|. 0x80)
unsafeConsR False (Packet n o) = Packet (n+1)  (o `shiftR` 1)

{-# INLINE unsafeSnocL #-}
unsafeSnocL ∷ Packet Left → Bool → Packet Left
unsafeSnocL (Packet n o) True  = Packet (n+1) (o `setBit` n)
unsafeSnocL (Packet n o) False = Packet (n+1)  o

{-# INLINE unsafeSnocR #-}
unsafeSnocR ∷ Packet Right → Bool → Packet Right
unsafeSnocR (Packet n o) True  = Packet (n+1) (o `setBit` (7-n))
unsafeSnocR (Packet n o) False = Packet (n+1)  o

-- | /O(1)/ Change the direction of 'Packet' from 'Left' to
-- 'Right'. Bit directions only affect octet-based operations such as
-- 'toOctet'.
packetLToR ∷ Packet Left → Packet Right
{-# INLINE packetLToR #-}
packetLToR (Packet n o) = Packet n (reverseBits o)

-- | /O(1)/ Change the direction of 'Packet' from 'Right' to
-- 'Left'. Bit directions only affect octet-based operations such as
-- 'toOctet'.
packetRToL ∷ Packet Right → Packet Left
{-# INLINE packetRToL #-}
packetRToL (Packet n o) = Packet n (reverseBits o)

{-# INLINE reverseBits #-}
reverseBits ∷ Word8 → Word8
reverseBits x
    = ((x .&. 0x01) `shiftL` 7) .|.
      ((x .&. 0x02) `shiftL` 5) .|.
      ((x .&. 0x04) `shiftL` 3) .|.
      ((x .&. 0x08) `shiftL` 1) .|.
      ((x .&. 0x10) `shiftR` 1) .|.
      ((x .&. 0x20) `shiftR` 3) .|.
      ((x .&. 0x40) `shiftR` 5) .|.
      ((x .&. 0x80) `shiftR` 7)

{-# INLINE scanlPacket #-}
scanlPacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool → Bool) → Bool → Packet d → Packet d
scanlPacket f b
    = unstream ∘ S.scanl f b ∘ stream

{-# INLINEABLE takeWhilePacket #-}
takeWhilePacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
takeWhilePacket f α = take (go 0 ∷ Int) α
    where
      {-# INLINE go #-}
      go i | i ≥ length α = i
           | f (α !! i)   = go (i+1)
           | otherwise    = i

{-# INLINEABLE dropWhilePacket #-}
dropWhilePacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
dropWhilePacket f α = drop (go 0 ∷ Int) α
    where
      {-# INLINE go #-}
      go i | i ≥ length α = i
           | f (α !! i)   = go (i+1)
           | otherwise    = i

filterPacket ∷ Bitstream (Packet d) ⇒ (Bool → Bool) → Packet d → Packet d
{-# INLINE filterPacket #-}
filterPacket f = unstream ∘ S.filter f ∘ stream
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , EmptyDataDecls
  , FlexibleContexts
  , FlexibleInstances
  , UnicodeSyntax
  #-}
-- | For internal use only.
module Data.Bitstream.Packet
    ( Left
    , Right

    , Packet

    , full

    , fromOctet
    , toOctet

    , packetLToR
    , packetRToL
    )
    where
import Data.Bitstream.Generic
import Data.Bits
import qualified Data.List as L
import Data.Ord
import qualified Data.Vector.Fusion.Stream as S
import Data.Vector.Fusion.Stream.Monadic (Stream(..), Step(..))
import Data.Vector.Fusion.Stream.Size
import Data.Vector.Fusion.Util
import Data.Word
import Foreign.Storable
import Prelude ( Bool(..), Eq(..), Int, Integral, Maybe(..)
               , Monad(..), Num(..), Show(..), ($!), error, fromIntegral
               , otherwise
               )
import Prelude.Unicode

-- | 'Left' bitstreams interpret an octet as a vector of bits whose
-- LSB comes first and MSB comes last e.g.
--
--   * 11110000 => [False, False, False, False, True, True , True , True]
--
--   * 10010100 => [False, False, True , False, True, False, False, True]
--
-- 'Bits' operations (like 'toBits') treat a 'Left' bitstream as a
-- little-endian integer.
data Left

-- | 'Right' bitstreams interpret an octet as a vector of bits whose
-- MSB comes first and LSB comes last e.g.
--
--   * 11110000 => [True, True , True , True, False, False, False, False]
--
--   * 10010100 => [True, False, False, True, False, True , False, False]
--
-- 'Bits' operations (like 'toBits') treat a 'Right' bitstream as a
-- big-endian integer.
data Right

-- | 'Packet's are strict 'Bitstream's having at most 8 bits.
data Packet d = Packet {-# UNPACK #-} !Int
                       {-# UNPACK #-} !Word8
    deriving (Eq)

instance Storable (Packet d) where
    sizeOf _  = 2
    alignment = sizeOf
    {-# INLINE peek #-}
    peek p
        = do n <- peekByteOff p 0
             o <- peekByteOff p 1
             return $! Packet (fromIntegral (n :: Word8)) o
    {-# INLINE poke #-}
    poke p (Packet n o)
        = do pokeByteOff p 0 (fromIntegral n :: Word8)
             pokeByteOff p 1 o

instance Show (Packet Left) where
    {-# INLINEABLE show #-}
    show (Packet n0 o0)
        = L.concat
          [ "["
          , L.unfoldr go (n0, o0)
          , "←]"
          ]
        where
          {-# INLINE go #-}
          go (0, _) = Nothing
          go (n, o)
              | o `testBit` (n-1) = Just ('1', (n-1, o))
              | otherwise         = Just ('0', (n-1, o))

instance Show (Packet Right) where
    {-# INLINEABLE show #-}
    show (Packet n0 o0)
        = L.concat
          [ "[→"
          , L.unfoldr go (n0, o0)
          , "]"
          ]
        where
          {-# INLINE δ #-}
          δ :: Int
          δ = 7 - n0
          {-# INLINE go #-}
          go (0, _) = Nothing
          go (n, o)
              | o `testBit` (n+δ) = Just ('1', (n-1, o))
              | otherwise         = Just ('0', (n-1, o))

instance Ord (Packet Left) where
    {-# INLINE compare #-}
    px `compare` py
        = comparing packetLToR px py

instance Ord (Packet Right) where
    {-# INLINE compare #-}
    (Packet nx ox) `compare` (Packet ny oy)
        = compare
          (ox `shiftR` (8-nx))
          (oy `shiftR` (8-ny))

instance Bitstream (Packet Left) where
    {-# INLINE basicStream #-}
    basicStream (Packet n o)
        = {-# CORE Packet Left stream #-}
          Stream step 0 (Exact n)
        where
          {-# INLINE step #-}
          step !i
              | i ≥ n     = return Done
              | otherwise = return $! Yield (o `testBit` i) (i+1)

    {-# INLINE basicUnstream #-}
    basicUnstream (Stream step s0 sz)
        = {-# CORE Packet Left unstream #-}
          case upperBound sz of
            Just n
                | n ≤ 8     -> unId (unsafeConsume s0 0 0)
                | otherwise -> packetOverflow
            Nothing         -> unId (safeConsume   s0 0 0)
        where
          {-# INLINE unsafeConsume #-}
          unsafeConsume s !i !o
              = do r <- step s
                   case r of
                     Yield True  s' -> unsafeConsume s' (i+1) (o `setBit` i)
                     Yield False s' -> unsafeConsume s' (i+1)  o
                     Skip        s' -> unsafeConsume s'  i     o
                     Done           -> return $! Packet i o
          {-# INLINE safeConsume #-}
          safeConsume s !i !o
              = do r <- step s
                   case r of
                     Yield b s'
                         | i < 8     -> safeConsume s' (i+1) (if b
                                                             then o `setBit` i
                                                             else o)
                         | otherwise -> packetOverflow
                     Skip    s'      -> safeConsume s' i o
                     Done            -> return $! Packet i o

    {-# INLINE basicCons #-}
    basicCons b p
        | full p    = packetOverflow
        | otherwise = b `unsafeConsL` p

    {-# INLINE basicSnoc #-}
    basicSnoc p b
        | full p    = packetOverflow
        | otherwise = p `unsafeSnocL` b

    {-# INLINE basicAppend #-}
    basicAppend (Packet nx ox) (Packet ny oy)
        | nx + ny > 8 = packetOverflow
        | otherwise   = Packet (nx + ny) (ox .|. (oy `shiftL` nx))

    {-# INLINE basicTail #-}
    basicTail (Packet 0 _) = emptyNotAllowed
    basicTail (Packet n o) = Packet (n-1) (o `shiftR` 1)

    {-# INLINE basicInit #-}
    basicInit (Packet 0 _) = emptyNotAllowed
    basicInit (Packet n o) = Packet (n-1) o

    {-# INLINE basicMap #-}
    basicMap f (Packet n o0) = Packet n (go 0 o0)
        where
          {-# INLINE go #-}
          go i o
              | i ≥ n             = o
              | f (o `testBit` i) = go (i+1) (o `setBit`   i)
              | otherwise         = go (i+1) (o `clearBit` i)

    {-# INLINE basicReverse #-}
    basicReverse (Packet n o)
        = Packet n (reverseBits o `shiftR` (8-n))

    {-# INLINE basicScanl #-}
    basicScanl = scanlPacket

    {-# INLINE basicTake #-}
    basicTake l (Packet n o)
        | l ≤ 0      = (∅)
        | otherwise
            = let n' = fromIntegral (min (fromIntegral n) l)
                  o' = (0xFF `shiftR` (8-n')) .&. o
              in
                Packet n' o'

    {-# INLINE basicDrop #-}
    basicDrop l (Packet n o)
        | l ≤ 0      = Packet n o
        | otherwise
            = let d  = fromIntegral (min (fromIntegral n) l)
                  n' = n-d
                  o' = o `shiftR` d
              in
                Packet n' o'

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = takeWhilePacket

    {-# INLINE basicDropWhile #-}
    basicDropWhile = dropWhilePacket

    {-# INLINE basicFilter #-}
    basicFilter = filterPacket

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits n β
        | n < 0     = (∅)
        | n > 8     = packetOverflow
        | n ≡ 8     = Packet (fromIntegral n) (fromIntegral β)
        | otherwise = let n' :: Int
                          n' = fromIntegral n
                          o  :: Word8
                          o  = fromIntegral (β .&. ((1 `shiftL` n') - 1))
                      in Packet n' o

    {-# INLINE basicToBits #-}
    basicToBits = fromIntegral ∘ toOctet


instance Bitstream (Packet Right) where
    {-# INLINE basicStream #-}
    basicStream (Packet n o)
        = {-# CORE Packet Right stream #-}
          Stream step 0 (Exact n)
        where
          {-# INLINE step #-}
          step !i
              | i ≥ n     = return Done
              | otherwise = return $! Yield (o `testBit` (7-i)) (i+1)

    {-# INLINE basicUnstream #-}
    basicUnstream (Stream step s0 sz)
        = {-# CORE Packet Right unstream #-}
          case upperBound sz of
            Just n
                | n ≤ 8     -> unId (unsafeConsume s0 0 0)
                | otherwise -> packetOverflow
            Nothing         -> unId (safeConsume   s0 0 0)
        where
          {-# INLINE unsafeConsume #-}
          unsafeConsume s i o
              = do r <- step s
                   case r of
                     Yield True  s' -> unsafeConsume s' (i+1) (o `setBit` (7-i))
                     Yield False s' -> unsafeConsume s' (i+1)  o
                     Skip        s' -> unsafeConsume s'  i     o
                     Done           -> return $! Packet i o
          {-# INLINE safeConsume #-}
          safeConsume s i o
              = do r <- step s
                   case r of
                     Yield b s'
                         | i < 8     -> safeConsume s' (i+1) (if b
                                                             then o `setBit` (7-i)
                                                             else o)
                         | otherwise -> packetOverflow
                     Skip    s'      -> safeConsume s' i o
                     Done            -> return $! Packet i o

    {-# INLINE basicCons #-}
    basicCons b p
        | full p    = packetOverflow
        | otherwise = b `unsafeConsR` p

    {-# INLINE basicSnoc #-}
    basicSnoc p b
        | full p    = packetOverflow
        | otherwise = p `unsafeSnocR` b

    {-# INLINE basicAppend #-}
    basicAppend (Packet nx ox) (Packet ny oy)
        | nx + ny > 8 = packetOverflow
        | otherwise   = Packet (nx + ny) (ox .|. (oy `shiftR` nx))

    {-# INLINE basicTail #-}
    basicTail (Packet 0 _) = emptyNotAllowed
    basicTail (Packet n o) = Packet (n-1) (o `shiftL` 1)

    {-# INLINE basicInit #-}
    basicInit (Packet 0 _) = emptyNotAllowed
    basicInit (Packet n o) = Packet (n-1) o

    {-# INLINE basicMap #-}
    basicMap f (Packet n o0) = Packet n (go 0 o0)
        where
          {-# INLINE go #-}
          go i o
              | i ≥ n                 = o
              | f (o `testBit` (7-i)) = go (i+1) (o `setBit`   (7-i))
              | otherwise             = go (i+1) (o `clearBit` (7-i))

    {-# INLINE basicReverse #-}
    basicReverse (Packet n o)
        = Packet n (reverseBits o `shiftL` (8-n))

    {-# INLINE basicScanl #-}
    basicScanl = scanlPacket

    {-# INLINE basicTake #-}
    basicTake l (Packet n o)
        | l ≤ 0      = (∅)
        | otherwise
            = let n' = fromIntegral (min (fromIntegral n) l)
                  o' = (0xFF `shiftL` (8-n')) .&. o
              in
                Packet n' o'

    {-# INLINE basicDrop #-}
    basicDrop l (Packet n o)
        | l ≤ 0      = Packet n o
        | otherwise
            = let d  = fromIntegral (min (fromIntegral n) l)
                  n' = n-d
                  o' = o `shiftL` d
              in
                Packet n' o'

    {-# INLINE basicTakeWhile #-}
    basicTakeWhile = takeWhilePacket

    {-# INLINE basicDropWhile #-}
    basicDropWhile = dropWhilePacket

    {-# INLINE basicFilter #-}
    basicFilter = filterPacket

    {-# INLINEABLE basicFromNBits #-}
    basicFromNBits n β
        | n < 0     = (∅)
        | n > 8     = packetOverflow
        | n ≡ 8     = Packet (fromIntegral n) (fromIntegral β)
        | otherwise = let n' :: Int
                          n' = fromIntegral n
                          o  :: Word8
                          o  = fromIntegral ( (β .&. ((1 `shiftL` n') - 1))
                                              `shiftL`
                                              (8-n')
                                            )
                      in Packet n' o

    {-# INLINE basicToBits #-}
    basicToBits (Packet n o)
        = fromIntegral (o `shiftR` (8-n))

packetHeadL :: Packet Left -> Bool
{-# RULES "head \8594 packetHeadL" [1] head = packetHeadL #-}
{-# INLINE packetHeadL #-}
packetHeadL (Packet 0 _) = emptyNotAllowed
packetHeadL (Packet _ o) = o `testBit` 0

packetHeadR :: Packet Right -> Bool
{-# RULES "head \8594 packetHeadR" [1] head = packetHeadR #-}
{-# INLINE packetHeadR #-}
packetHeadR (Packet 0 _) = emptyNotAllowed
packetHeadR (Packet _ o) = o `testBit` 7

packetLastL :: Packet Left -> Bool
{-# RULES "last \8594 packetLastL" [1] last = packetLastL #-}
{-# INLINE packetLastL #-}
packetLastL (Packet 0 _) = emptyNotAllowed
packetLastL (Packet n o) = o `testBit` (n-1)

packetLastR :: Packet Right -> Bool
{-# RULES "head \8594 packetLastR" [1] last = packetLastR #-}
{-# INLINE packetLastR #-}
packetLastR (Packet 0 _) = emptyNotAllowed
packetLastR (Packet n o) = o `testBit` (8-n)

packetAndL :: Packet Left -> Bool
{-# RULES "and \8594 packetAndL" [1] and = packetAndL #-}
{-# INLINE packetAndL #-}
packetAndL (Packet n o) = (0xFF `shiftR` (8-n)) ≡ o

packetAndR :: Packet Right -> Bool
{-# RULES "and \8594 packetAndR" [1] and = packetAndR #-}
{-# INLINE packetAndR #-}
packetAndR (Packet n o) = (0xFF `shiftL` (8-n)) ≡ o

packetIndexL :: (Integral n, Show n) => Packet Left -> n -> Bool
{-# RULES "(!!) \8594 packetIndexL" [1] (!!) = packetIndexL #-}
{-# INLINE packetIndexL #-}
packetIndexL p i
    | i < 0 ∨ i ≥ length p = indexOutOfRange i
    | otherwise            = unsafePacketIndexL p i

packetIndexR :: (Integral n, Show n) => Packet Right -> n -> Bool
{-# RULES "(!!) \8594 packetIndexR" [1] (!!) = packetIndexR #-}
{-# INLINE packetIndexR #-}
packetIndexR p i
    | i < 0 ∨ i ≥ length p = indexOutOfRange i
    | otherwise            = unsafePacketIndexR p i

unsafePacketIndexL :: Integral n => Packet Left -> n -> Bool
{-# INLINE unsafePacketIndexL #-}
unsafePacketIndexL (Packet _ o) i
    = o `testBit` fromIntegral i

unsafePacketIndexR :: Integral n => Packet Right -> n -> Bool
{-# INLINE unsafePacketIndexR #-}
unsafePacketIndexR (Packet _ o) i
    = o `testBit` (7 - fromIntegral i)

packetNull :: Packet d -> Bool
{-# RULES "null \8594 packetNull" [1] null = packetNull #-}
{-# INLINE packetNull #-}
packetNull (Packet 0 _) = True
packetNull _            = False

packetLength :: Num n => Packet d -> n
{-# RULES "length \8594 packetLength" [1] length = packetLength #-}
{-# INLINE packetLength #-}
packetLength (Packet n _) = fromIntegral n

packetOr :: Packet d -> Bool
{-# RULES "or \8594 packetOr" [1] or = packetOr #-}
{-# INLINE packetOr #-}
packetOr (Packet _ o) = o ≢ 0

{-# INLINE emptyNotAllowed #-}
emptyNotAllowed :: α
emptyNotAllowed = error "Data.Bitstream.Packet: packet is empty"

{-# INLINE packetOverflow #-}
packetOverflow :: α
packetOverflow = error "Data.Bitstream.Packet: packet size overflow"

{-# INLINE indexOutOfRange #-}
indexOutOfRange :: (Integral n, Show n) => n -> α
indexOutOfRange n = error ("Data.Bitstream.Packet: index out of range: " L.++ show n)

-- | /O(1)/ @'full' p == 'True'@ iff @'length' p == 8@, otherwise it
-- returns 'False'.
full :: Packet d -> Bool
{-# INLINE full #-}
full (Packet 8 _) = True
full _            = False

-- | /O(1)/ Convert an octet to 'Packet'.
fromOctet :: Word8 -> Packet d
{-# INLINE fromOctet #-}
fromOctet = Packet 8

-- | /O(1)/ 'toOctet' @p@ converts a 'Packet' @p@ to an octet, padding
-- with zeroes if @'length' p < 8@.
toOctet :: Packet d -> Word8
{-# INLINE toOctet #-}
toOctet (Packet _ o) = o

{-# INLINE unsafeConsL #-}
unsafeConsL :: Bool -> Packet Left -> Packet Left
unsafeConsL True  (Packet n o) = Packet (n+1) ((o `shiftL` 1) .|. 1)
unsafeConsL False (Packet n o) = Packet (n+1)  (o `shiftL` 1)

{-# INLINE unsafeConsR #-}
unsafeConsR :: Bool -> Packet Right -> Packet Right
unsafeConsR True  (Packet n o) = Packet (n+1) ((o `shiftR` 1) .|. 0x80)
unsafeConsR False (Packet n o) = Packet (n+1)  (o `shiftR` 1)

{-# INLINE unsafeSnocL #-}
unsafeSnocL :: Packet Left -> Bool -> Packet Left
unsafeSnocL (Packet n o) True  = Packet (n+1) (o `setBit` n)
unsafeSnocL (Packet n o) False = Packet (n+1)  o

{-# INLINE unsafeSnocR #-}
unsafeSnocR :: Packet Right -> Bool -> Packet Right
unsafeSnocR (Packet n o) True  = Packet (n+1) (o `setBit` (7-n))
unsafeSnocR (Packet n o) False = Packet (n+1)  o

-- | /O(1)/ Change the direction of 'Packet' from 'Left' to
-- 'Right'. Bit directions only affect octet-based operations such as
-- 'toOctet'.
packetLToR :: Packet Left -> Packet Right
{-# INLINE packetLToR #-}
packetLToR (Packet n o) = Packet n (reverseBits o)

-- | /O(1)/ Change the direction of 'Packet' from 'Right' to
-- 'Left'. Bit directions only affect octet-based operations such as
-- 'toOctet'.
packetRToL :: Packet Right -> Packet Left
{-# INLINE packetRToL #-}
packetRToL (Packet n o) = Packet n (reverseBits o)

{-# INLINE reverseBits #-}
reverseBits :: Word8 -> Word8
reverseBits x
    = ((x .&. 0x01) `shiftL` 7) .|.
      ((x .&. 0x02) `shiftL` 5) .|.
      ((x .&. 0x04) `shiftL` 3) .|.
      ((x .&. 0x08) `shiftL` 1) .|.
      ((x .&. 0x10) `shiftR` 1) .|.
      ((x .&. 0x20) `shiftR` 3) .|.
      ((x .&. 0x40) `shiftR` 5) .|.
      ((x .&. 0x80) `shiftR` 7)

{-# INLINE scanlPacket #-}
scanlPacket :: Bitstream (Packet d) => (Bool -> Bool -> Bool) -> Bool -> Packet d -> Packet d
scanlPacket f b
    = unstream ∘ S.scanl f b ∘ stream

{-# INLINEABLE takeWhilePacket #-}
takeWhilePacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
takeWhilePacket f α = take (go 0 :: Int) α
    where
      {-# INLINE go #-}
      go i | i ≥ length α = i
           | f (α !! i)   = go (i+1)
           | otherwise    = i

{-# INLINEABLE dropWhilePacket #-}
dropWhilePacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
dropWhilePacket f α = drop (go 0 :: Int) α
    where
      {-# INLINE go #-}
      go i | i ≥ length α = i
           | f (α !! i)   = go (i+1)
           | otherwise    = i

filterPacket :: Bitstream (Packet d) => (Bool -> Bool) -> Packet d -> Packet d
{-# INLINE filterPacket #-}
filterPacket f = unstream ∘ S.filter f ∘ stream

</pre>