<a href="Base.hs340756291478446501.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Base58Address.hs340756291478446501.out.html">next</a></br></br><pre>43d42
< EGL14(eglGetError, IO EGLint)
44d42
< EGL14(eglGetDisplay, EGLNativeDisplay -> IO EGLDisplay)
45d42
< EGL14(eglInitialize, EGLDisplay -> Ptr EGLint -> Ptr EGLint -> IO EGLboolean)
46c43
< EGL14(eglTerminate, EGLDisplay -> IO EGLboolean)
---
> foreignEGL14(eglGetErrorimport ccall, IOunsafeEGLint"EGL/egl.h")           eglGetError ::  IO EGLint
46a44
> foreignEGL14(eglGetDisplayimport ccall, unsafeEGLNativeDisplay"EGL/egl.h"->eglGetDisplayIO EGLDisplay::)   EGLNativeDisplay -> IO EGLDisplay
46a45
> foreignEGL14(eglInitializeimport ccall, unsafeEGLDisplay"EGL/egl.h"-> Ptr EGLint-> Ptr EGLint::  EGLDisplay-> IO EGLboolean-> Ptr EGLint)      -> Ptr EGLint -> IO EGLboolean
46a46
> foreignEGL14(eglTerminateimport ccall, EGLDisplay "EGL/egl.h"-> IO EGLboolean)     ::  EGLDisplay -> IO EGLboolean
48c48
< EGL14(eglQueryString, EGLDisplay -> EGLint -> IO CString)
---
> foreignEGL14(eglQueryStringimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLint-> IO CString::)  EGLDisplay -> EGLint -> IO CString
50d49
< EGL14(eglGetConfigs, EGLDisplay -> Ptr EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)
51d49
< EGL14(eglChooseConfig, EGLDisplay -> Ptr EGLint -> Ptr EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)
52c50
< EGL14(eglGetConfigAttrib, EGLDisplay -> EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)
---
> foreignEGL14(eglGetConfigsimport ccall, unsafeEGLDisplay"EGL/egl.h"-> Ptr EGLConfig-> EGLint::  EGLDisplay-> Ptr EGLint-> Ptr-> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
52a51
> foreignEGL14(eglChooseConfigimport ccall unsafe, EGLDisplay"EGL/egl.h"-> PtreglChooseConfigEGLint -> Ptr EGLConfig::  EGLDisplay-> EGLint-> Ptr-> EGLintPtr EGLint-> Ptr-> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
52a52
> foreignEGL14(eglGetConfigAttribimport ccall unsafe, EGLDisplay"EGL/egl.h"-> eglGetConfigAttribEGLConfig -> EGLint::-> EGLDisplayPtr EGLint -> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
54d53
< EGL14(eglCreateWindowSurface, EGLDisplay -> EGLConfig -> EGLNativeWindow -> Ptr EGLint -> IO EGLSurface)
55d53
< EGL14(eglCreatePbufferSurface, EGLDisplay -> EGLConfig -> Ptr EGLint -> IO EGLSurface)
56d53
< EGL14(eglCreatePixmapSurface, EGLDisplay -> EGLConfig -> EGLNativePixmap -> Ptr EGLint -> IO EGLSurface)
57d53
< EGL14(eglDestroySurface, EGLDisplay -> EGLSurface -> IO EGLboolean)
58c54
< EGL14(eglQuerySurface, EGLDisplay -> EGLSurface -> EGLint -> Ptr EGLint -> IO EGLboolean)
---
> foreignEGL14(eglCreateWindowSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplayeglCreateWindowSurface-> EGLConfig -> EGLNativeWindow::  EGLDisplay-> Ptr->EGLint-> IO->EGLSurface)      -> Ptr EGLint -> IO EGLSurface
58a55
> foreignEGL14(eglCreatePbufferSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplay-> EGLConfig -> Ptr EGLint::  EGLDisplay-> IO EGLSurface-> EGLConfig)      -> Ptr EGLint -> IO EGLSurface
58a56
> foreignEGL14(eglCreatePixmapSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplayeglCreatePixmapSurface-> EGLConfig -> EGLNativePixmap::  EGLDisplay-> Ptr->EGLint-> IO->EGLSurface)      -> Ptr EGLint -> IO EGLSurface
58a57
> foreignEGL14(eglDestroySurfaceimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> IO EGLboolean::  EGLDisplay)      -> EGLSurface -> IO EGLboolean
58a58
> foreignEGL14(eglQuerySurfaceimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayPtr EGLint->->EGLSurfaceIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
60d59
< EGL14(eglBindAPI, EGLenum -> IO EGLboolean)
61c60
< EGL14(eglQueryAPI, IO EGLenum)
---
> foreignEGL14(eglBindAPIimport ccall, EGLenum->"EGL/egl.h"IO EGLboolean)        ::  EGLenum -> IO EGLboolean
61a61
> foreignEGL14(eglQueryAPIimport ccall, IOunsafeEGLenum"EGL/egl.h")          eglQueryAPI ::  IO EGLenum
63c63
< EGL14(eglWaitClient, IO EGLboolean)
---
> foreignEGL14(eglWaitClientimport ccall, unsafeIO EGLboolean"EGL/egl.h")     eglWaitClient ::  IO EGLboolean
65c65
< EGL14(eglReleaseThread, IO EGLboolean)
---
> foreignEGL14(eglReleaseThreadimport ccall unsafe, IO EGLboolean"EGL/egl.h")  eglReleaseThread ::  IO EGLboolean
67c67
< EGL14(eglCreatePbufferFromClientBuffer, EGLDisplay -> EGLenum -> EGLClientBuffer -> EGLConfig -> Ptr EGLint -> IO EGLSurface)
---
> foreignEGL14(eglCreatePbufferFromClientBufferimport ccall unsafe "EGL/egl.h", eglCreatePbufferFromClientBufferEGLDisplay -> EGLenum -> EGLClientBuffer::  EGLDisplay-> EGLConfig-> EGLenum-> Ptr->EGLint-> IO EGLSurface-> EGLConfig)      -> Ptr EGLint -> IO EGLSurface
69d68
< EGL14(eglSurfaceAttrib, EGLDisplay -> EGLSurface -> EGLint -> EGLint -> IO EGLboolean)
70d68
< EGL14(eglBindTexImage, EGLDisplay -> EGLSurface -> EGLint -> IO EGLboolean)
71c69
< EGL14(eglReleaseTexImage, EGLDisplay -> EGLSurface -> EGLint -> IO EGLboolean)
---
> foreignEGL14(eglSurfaceAttribimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayEGLint -> -> EGLSurface)-> EGLint -> EGLint -> IO EGLboolean
71a70
> foreignEGL14(eglBindTexImageimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayIO EGLboolean-> EGLSurface)          -> EGLint -> IO EGLboolean
71a71
> foreignEGL14(eglReleaseTexImageimport ccall unsafe, EGLDisplay"EGL/egl.h"-> eglReleaseTexImageEGLSurface -> EGLint::->EGLDisplayIO EGLboolean-> EGLSurface)          -> EGLint -> IO EGLboolean
73c73
< EGL14(eglSwapInterval, EGLDisplay -> EGLint -> IO EGLboolean)
---
> foreignEGL14(eglSwapIntervalimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLint-> IO EGLboolean::  EGLDisplay)          -> EGLint -> IO EGLboolean
75d74
< EGL14(eglCreateContext, EGLDisplay -> EGLConfig -> EGLContext -> Ptr EGLint -> IO EGLContext)
76d74
< EGL14(eglDestroyContext, EGLDisplay -> EGLContext -> IO EGLboolean)
77c75
< EGL14(eglMakeCurrent, EGLDisplay -> EGLSurface -> EGLSurface -> EGLContext -> IO EGLboolean)
---
> foreignEGL14(eglCreateContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLConfig-> EGLContext::  EGLDisplay-> Ptr EGLint-> EGLConfig-> IO EGLContext-> EGLContext)      -> Ptr EGLint -> IO EGLContext
77a76
> foreignEGL14(eglDestroyContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLContext-> IO EGLboolean::  EGLDisplay)      -> EGLContext -> IO EGLboolean
77a77
> foreignEGL14(eglMakeCurrentimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> EGLSurface::  EGLDisplay-> EGLContext-> EGLSurface-> IO EGLboolean-> EGLSurface)      -> EGLContext -> IO EGLboolean
79d78
< EGL14(eglGetCurrentContext, IO EGLContext)
80d78
< EGL14(eglGetCurrentSurface, EGLint -> IO EGLSurface)
81d78
< EGL14(eglGetCurrentDisplay, IO EGLDisplay)
82c79
< EGL14(eglQueryContext, EGLDisplay -> EGLContext -> EGLint -> Ptr EGLint -> IO EGLboolean)
---
> foreignEGL14(eglGetCurrentContextimport ccall unsafe, "EGL/egl.h"IO EGLContext)                   ::  IO EGLContext
82a80
> foreignEGL14(eglGetCurrentSurfaceimport ccall unsafe, "EGL/egl.h"EGLint -> IOeglGetCurrentSurfaceEGLSurface)         ::  EGLint -> IO EGLSurface
82a81
> foreignEGL14(eglGetCurrentDisplayimport ccall unsafe, "EGL/egl.h"IO EGLDisplay)                   ::  IO EGLDisplay
82a82
> foreignEGL14(eglQueryContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLContext-> EGLint::->EGLDisplayPtr EGLint->->EGLContextIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
84d83
< --EGL14(eglWaitGL, IO EGLboolean)
85d83
< EGL14(eglWaitNative, EGLint -> IO EGLboolean)
86d83
< EGL14(eglSwapBuffers, EGLDisplay -> EGLSurface -> IO EGLboolean)
87c84
< EGL14(eglCopyBuffers, EGLDisplay -> EGLSurface -> EGLNativePixmap -> IO EGLboolean)
---
> --EGL14(eglWaitGL, IO EGLboolean)--foreign import ccall unsafe "EGL/egl.h" eglWaitGL ::  IO EGLboolean
87a85
> foreignEGL14(eglWaitNativeimport ccall, unsafe "EGL/egl.h"-> IO EGLboolean)         ::  EGLint -> IO EGLboolean
87a86
> foreignEGL14(eglSwapBuffersimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> IO EGLboolean::  EGLDisplay)      -> EGLSurface -> IO EGLboolean
87a87
> foreignEGL14(eglCopyBuffersimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> EGLNativePixmap::  EGLDisplay-> IO->EGLboolean) -> EGLNativePixmap -> IO EGLboolean
114c114
< 
---
> -- * Misc
116c116
< newtype EGLSurfAttr = EGLSurfAttr EGLint
---
> newtype EGLConfAttr = EGLConfAttr EGLint
116a117
> newtype EGLSurfAttrEGLContextAttr= EGLSurfAttr= EGLContextAttrEGLint
118d118
< 
120d119
< queryString :: EGLint -> Egl -> IO String
121d119
< queryString name egl = do
122c120
<     display <- fmap disp $ readIORef egl
---
> {-# NOINLINEqueryString ::EGLint -> #-} -> IO String
122a121
> queryString ::nameegl =->doEgl -> IO String
122a122
> queryStringdisplay name<- fmapdisp= do$ readIORef egl
122a123
>     displayeglQueryString<- fmapdisplay $ readIORefname >>= peekCString
124d124
< 
126d125
< queryContext :: EGLint -> Egl -> IO EGLint
127d125
< queryContext attr egl = do
128d125
<     EglCurrent{disp=disp, context=context} <- readIORef egl
129d125
<     alloca $ \value ->
130d125
<         eglQueryContext disp context attr value >> peek value
131c126
< 
---
> {-# NOINLINE queryContext:: EGLint -> #-} -> IO EGLint
131a127
> queryContext ::attregl =->doEgl -> IO EGLint
131a128
> queryContextEglCurrent{disp=disp= do, context=context} <- readIORef egl
131a129
>     EglCurrentalloca $ \{valuedisp=disp->  , context=context} <- readIORef egl
131a130
>     allocaeglQueryContext \value ->  disp context attr value >> peek value
131a131
>                    eglQueryContext disp context attr value >> peek value
133c133
< 
---
> type Egl = IORef EglCurrent
135d134
<     { disp :: EGLDisplay
136d134
<     , chosen :: EGLConfig
137c135
<     , context :: EGLContext
---
> data{EglCurrentdisp :: EGLDisplay= EglCurrent
137a136
>     { dispchosen::::EGLConfig
137a137
>     , chosencontext::::EGLConfigEGLContext
137a138
>     , contextdsurf ::::EGLSurface
139d139
<     , rsurf :: EGLSurface
140d139
<     , nwin :: EGLNativeWindow
141d139
<     , screenDims :: (Int32, Int32)
142d139
<     , ndisp :: Maybe EGLNativeDisplay
143d139
<     , confcand :: [[(EGLConfAttr, Int32)]]
144c140
<     --, surfconf :: [[(EGLSurfAttr, Int32)]]
---
>     , rsurfnwin ::::EGLNativeWindow
144a141
>     , nwinscreenDims:: EGLNativeWindow:: (Int32, Int32)
144a142
>     , screenDimsndisp :: Maybe:: (Int32EGLNativeDisplay, Int32)
144a143
>     , ndispconfcand:: Maybe:: [[(EGLNativeDisplayEGLConfAttr, Int32)]]
144a144
>     ,--, surfconf :: [[(EGLSurfAttr, Int32)]] :: [[(EGLConfAttr, Int32)]]
144a145
>     ,--, surfconf :: [[(EGLSurfAttr, Int32)]]cxtconf :: [(EGLContextAttr, Int32)]
147d147
< 
149c149
< 
---
> initial = EglCurrent nullPtr nullPtr nullPtr nullPtr nullPtr nullPtr (0,0)
151d150
< showEglError :: EGLint -> String
152d150
< showEglError x = case x of
153d150
<     0x3000 -> "EGLSuccess: Function succeeded."
154d150
<     0x3001 -> "EGLNotInitialized: EGL is not or could not be initialized, for the specified display."
155d150
<     0x3002 -> "EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread)."
156d150
<     0x3003 -> "EGLBadAlloc: EGL failed to allocate resources for the requested operation."
157d150
<     0x3004 -> "EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list."
158d150
<     0x3005 -> "EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig."
159d150
<     0x3006 -> "EGLBadContext: An EGLContext argument does not name a valid EGLContext."
160d150
<     0x3007 -> "EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid."
161d150
<     0x3008 -> "EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay."
162c151
<     0x3009 -> "EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface."
---
> {-# NOINLINE showEglError:: EGLint -> #-}String
162a152
> showEglError ::x =EGLintcase x->ofString
162a153
> showEglError0x3000 ->x"EGLSuccess: Function succeeded."= case x of
162a154
>     0x3000 -> "EGLSuccess: Function succeeded.""EGLNotInitialized: EGL is not or could not be initialized, for the specified display."
162a155
>     0x3001 -> "EGLNotInitialized: EGL is not or could not be initialized, for the specified display.""EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread)."
162a156
>     0x3002 -> "EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread).""EGLBadAlloc: EGL failed to allocate resources for the requested operation."
162a157
>     0x3003 -> "EGLBadAlloc: EGL failed to allocate resources for the requested operation.""EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list."
162a158
>     0x3004 -> "EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list.""EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig."
162a159
>     0x3005 -> "EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig.""EGLBadContext: An EGLContext argument does not name a valid EGLContext."
162a160
>     0x3006 -> "EGLBadContext: An EGLContext argument does not name a valid EGLContext.""EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid."
162a161
>     0x3007 -> "EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid.""EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay."
162a162
>     0x3008 -> "EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay.""EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface."
162a163
>     0x3009 -> "EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface.""EGLBadNativePixmap: An EGLNativePixmapType argument does not refer to a valid native pixmap."
164d164
<     0x300B -> "EGLBadNativeWindow: An EGLNativeWindowType argument does not refer to a valid native window."
165d164
<     0x300C -> "EGLBadParameter: One or more argument values are invalid."
166d164
<     0x300D -> "EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering."
167d164
<     0x300E -> "EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."
168d164
<     x | 0x300E < x && x < 0x3020 ->
169c165
<         "EGLUnknownError: Error " ++ show x ++ " is not defined in EGL 1.4 spec."
---
>     0x300B -> "EGLBadNativeWindow: An EGLNativeWindowType argument does not refer to a valid native window.""EGLBadParameter: One or more argument values are invalid."
169a166
>     0x300C -> "EGLBadParameter: One or more argument values are invalid.""EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering."
169a167
>     0x300D -> "EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering.""EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."
169a168
>     0x300Ex | 0x300E "EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."< x && x < 0x3020 ->
169a169
>     x | 0x300E"EGLUnknownError: Error " x && x < 0x3020 ->++ show x ++ " is not defined in EGL 1.4 spec."
169a170
>     x ->"EGLUnknownError: Error ""showEglError: Value out of range: " show x ++++show x
171d171
< 
173d172
< withAttrList :: [(EGLint, Int32)] -> (Ptr EGLint -> IO b) -> IO b
174c173
< withAttrList attrs =
---
> {-# NOINLINE withAttrList:: [(EGLint, #-}Int32)] -> (Ptr EGLint -> IO b) -> IO b
174a174
> withAttrList ::attrs(EGLint=    , Int32)] -> (Ptr EGLint -> IO b) -> IO b
174a175
> withAttrListwithArrayattrs$ foldr=  (\(k, v) l -> k : v : l) [0x3038] attrs
176d176
< 
178d177
< -- | Get an EGLDisplay and choose a suitable config
179d177
< setupEgl :: Maybe EGLNativeDisplay -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
180d177
< setupEgl nd attribsList = do
181c178
<     display <- eglGetDisplay $ maybe nullPtr id nd
---
> {-# NOINLINE-- | Get an EGLDisplay and choose a suitable config #-}
181a179
> setupEgl-- | Get an EGLDisplay and choose a suitable config:: Maybe EGLNativeDisplay -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
181a180
> setupEgl :: MaybeattribsList= do       -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
181a181
> setupEgldisplay attribsList<- eglGetDisplay= do $ maybe nullPtr id nd
181a182
>     displayeglInitialize<- eglGetDisplaydisplay nullPtr maybenullPtr id nd
183d183
< 
185d184
<     -- Below, we select an EGLConfig with at least 8 bits per color
186d184
<     -- component compatible with on-screen windows
187d184
<     let go _ _ [] = return nullPtr -- suitable config not found!
188d184
<         go cfg numConfigs (x:xs) = withAttrList (map (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
189d184
<         eglChooseConfig display attribs cfg 1 numConfigs
190d184
<         n <- peek numConfigs
191d184
<         if n /= 0 then peek cfg else go cfg numConfigs xs
192d184
<     config <- alloca $ \cfg ->
193d184
<         alloca $ \numConfigs ->
194d184
<             go cfg numConfigs attribsList
195c185
< 
---
>     -- Here specify the attributes of the desired configuration.-- Below, we select an EGLConfig with at least 8 bits per color
195a186
>     -- component compatible with on-screen windows-- Below, we select an EGLConfig with at least 8 bits per color
195a187
>     let-- component compatible with on-screen windowsgo _ _ [] = return nullPtr -- suitable config not found!
195a188
>     let go _cfg [numConfigs] = return(nullPtrx:xs) = withAttrList-- suitable config not found!(map (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
195a189
>         goeglChooseConfig numConfigsdisplayx:xs)attribs= withAttrListcfg 1 numConfigsmap (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
195a190
>                                   eglChooseConfign <- peek numConfigs attribs cfg 1 numConfigs
195a191
>                                   nif<-n peek/= 0 numConfigsthen peek cfg else go cfg numConfigs xs
195a192
>                               config n<-/=alloca then$ peek\cfg cfg->  else go cfg numConfigs xs
195a193
>     configalloca<- alloca$ \numConfigs \cfg ->->
195a194
>                  allocago $cfgnumConfigsnumConfigs->attribsList
195a195
>                      go cfg numConfigs attribsList
197d196
<     -- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.
198d196
<     -- As soon as we picked a EGLConfig, we can safely reconfigure the
199d196
<     -- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.
200d196
<     --alloca $ \format->
201d196
<     --  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
202c197
<     --  ANativeWindow_setBuffersGeometry window 0 0 format
---
>     -- EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is-- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.
202a198
>     -- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.-- As soon as we picked a EGLConfig, we can safely reconfigure the
202a199
>     -- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.-- As soon as we picked a EGLConfig, we can safely reconfigure the
202a200
>     --alloca $ \format->-- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.
202a201
>     --alloca $ \format->--  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
202a202
>     --  ANativeWindow_setBuffersGeometry window 0 0 format--  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
202a203
>     return--  ANativeWindow_setBuffersGeometry window 0 0 format(display, config)
204d204
< 
206d205
< setSurface :: EGLDisplay -> EGLConfig -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
207d205
< setSurface disp config window = do
208d205
<     surf <- eglCreateWindowSurface disp config window nullPtr
209d205
<     alloca $ \ptr -> do
210d205
<         eglQuerySurface disp surf 0x3057 ptr
211d205
<         screen_width <- peek ptr
212d205
<         eglQuerySurface disp surf 0x3056 ptr
213d205
<         screen_height <- peek ptr
214c206
<         return (surf, screen_width, screen_height)
---
> {-# NOINLINEsetSurface ::setSurfaceEGLDisplay#-}-> EGLConfig -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
214a207
> setSurface ::dispconfig window-> EGLConfig= do    -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
214a208
> setSurfacesurf <-dispeglCreateWindowSurface window = do disp config window nullPtr
214a209
>     surfalloca<-$eglCreateWindowSurface\ptr -> do            disp config window nullPtr
214a210
>     allocaeglQuerySurface \ptr -> do disp surf 0x3057 ptr
214a211
>                    eglQuerySurfacescreen_width <- disp surfptr  0x3057 ptr
214a212
>                    screen_widtheglQuerySurface<- peek ptrsurf 0x3056 ptr
214a213
>                    eglQuerySurfacescreen_height <-disppeeksurfptr 0x3056 ptr
214a214
>                    screen_heightreturn (surf, <-screen_width ptr , screen_height)
214a215
>                    return (surf, screen_width, screen_height)
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE Unsafe, UnliftedFFITypes, MagicHash, UnboxedTuples #-}
module Graphics.EGL.Base where

import Data.IORef
import Foreign
import Foreign.C.String
import System.IO.Unsafe (unsafePerformIO)
import GHC.Base (realWorld#)
import GHC.CString (unpackCString#)
import GHC.IO (IO (IO))
import GHC.Ptr (Ptr(..))


-- * EGL Types

-- | 32-bit signed integer
type EGLint = Int32

-- from EGL/egl.h
type EGLboolean = Word32
type EGLenum = Word32
type EGLConfig = Ptr ()
type EGLContext = Ptr ()
type EGLDisplay = Ptr ()
type EGLSurface = Ptr ()
type EGLClientBuffer = Ptr ()

-- from EGL/eglplatform.h
-- ** Window System Types

type EGLNativeWindow = Ptr ()
type EGLNativePixmap = Ptr ()
-- Symbian platform uses int instead of pointer
type EGLNativeDisplay = Ptr ()


-- * Bindings to EGL

#define EGL14(_name, _type) \
foreign import ccall unsafe "EGL/egl.h" _name :: _type

EGL14(eglGetError, IO EGLint)
EGL14(eglGetDisplay, EGLNativeDisplay -> IO EGLDisplay)
EGL14(eglInitialize, EGLDisplay -> Ptr EGLint -> Ptr EGLint -> IO EGLboolean)
EGL14(eglTerminate, EGLDisplay -> IO EGLboolean)

EGL14(eglQueryString, EGLDisplay -> EGLint -> IO CString)

EGL14(eglGetConfigs, EGLDisplay -> Ptr EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)
EGL14(eglChooseConfig, EGLDisplay -> Ptr EGLint -> Ptr EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)
EGL14(eglGetConfigAttrib, EGLDisplay -> EGLConfig -> EGLint -> Ptr EGLint -> IO EGLboolean)

EGL14(eglCreateWindowSurface, EGLDisplay -> EGLConfig -> EGLNativeWindow -> Ptr EGLint -> IO EGLSurface)
EGL14(eglCreatePbufferSurface, EGLDisplay -> EGLConfig -> Ptr EGLint -> IO EGLSurface)
EGL14(eglCreatePixmapSurface, EGLDisplay -> EGLConfig -> EGLNativePixmap -> Ptr EGLint -> IO EGLSurface)
EGL14(eglDestroySurface, EGLDisplay -> EGLSurface -> IO EGLboolean)
EGL14(eglQuerySurface, EGLDisplay -> EGLSurface -> EGLint -> Ptr EGLint -> IO EGLboolean)

EGL14(eglBindAPI, EGLenum -> IO EGLboolean)
EGL14(eglQueryAPI, IO EGLenum)

EGL14(eglWaitClient, IO EGLboolean)

EGL14(eglReleaseThread, IO EGLboolean)

EGL14(eglCreatePbufferFromClientBuffer, EGLDisplay -> EGLenum -> EGLClientBuffer -> EGLConfig -> Ptr EGLint -> IO EGLSurface)

EGL14(eglSurfaceAttrib, EGLDisplay -> EGLSurface -> EGLint -> EGLint -> IO EGLboolean)
EGL14(eglBindTexImage, EGLDisplay -> EGLSurface -> EGLint -> IO EGLboolean)
EGL14(eglReleaseTexImage, EGLDisplay -> EGLSurface -> EGLint -> IO EGLboolean)

EGL14(eglSwapInterval, EGLDisplay -> EGLint -> IO EGLboolean)

EGL14(eglCreateContext, EGLDisplay -> EGLConfig -> EGLContext -> Ptr EGLint -> IO EGLContext)
EGL14(eglDestroyContext, EGLDisplay -> EGLContext -> IO EGLboolean)
EGL14(eglMakeCurrent, EGLDisplay -> EGLSurface -> EGLSurface -> EGLContext -> IO EGLboolean)

EGL14(eglGetCurrentContext, IO EGLContext)
EGL14(eglGetCurrentSurface, EGLint -> IO EGLSurface)
EGL14(eglGetCurrentDisplay, IO EGLDisplay)
EGL14(eglQueryContext, EGLDisplay -> EGLContext -> EGLint -> Ptr EGLint -> IO EGLboolean)

--EGL14(eglWaitGL, IO EGLboolean)
EGL14(eglWaitNative, EGLint -> IO EGLboolean)
EGL14(eglSwapBuffers, EGLDisplay -> EGLSurface -> IO EGLboolean)
EGL14(eglCopyBuffers, EGLDisplay -> EGLSurface -> EGLNativePixmap -> IO EGLboolean)


-- * Obtain Extension Function Pointer

-- | Just like unsafePerformIO, but we inline it. Big performance gains as
-- it exposes lots of things to further inlining. /Very unsafe/. In
-- particular, you should do no memory allocation inside an
-- 'inlinePerformIO' block.
inlinePerformIO :: IO a -> a
inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
{-# INLINE inlinePerformIO #-}

foreign import ccall unsafe "EGL/egl.h eglGetProcAddress"
    c_eglGetProcAddress :: CString -> IO (FunPtr a)

eglGetProcAddress :: String -> FunPtr a
eglGetProcAddress procname = unsafePerformIO $
    withCString procname c_eglGetProcAddress
{-# INLINE [0] eglGetProcAddress #-}
{-# RULES
"EGL eglGetProcAddress/c_eglGetProcAddress" forall s .
   eglGetProcAddress (unpackCString# s) = inlinePerformIO (c_eglGetProcAddress (Ptr s))
 #-}


-- * Misc

newtype EGLConfAttr = EGLConfAttr EGLint
newtype EGLSurfAttr = EGLSurfAttr EGLint
newtype EGLContextAttr = EGLContextAttr EGLint

{-# NOINLINE queryString #-}
queryString :: EGLint -> Egl -> IO String
queryString name egl = do
    display <- fmap disp $ readIORef egl
    eglQueryString display name >>= peekCString

{-# NOINLINE queryContext #-}
queryContext :: EGLint -> Egl -> IO EGLint
queryContext attr egl = do
    EglCurrent{disp=disp, context=context} <- readIORef egl
    alloca $ \value ->
        eglQueryContext disp context attr value >> peek value

type Egl = IORef EglCurrent

data EglCurrent = EglCurrent
    { disp :: EGLDisplay
    , chosen :: EGLConfig
    , context :: EGLContext
    , dsurf :: EGLSurface
    , rsurf :: EGLSurface
    , nwin :: EGLNativeWindow
    , screenDims :: (Int32, Int32)
    , ndisp :: Maybe EGLNativeDisplay
    , confcand :: [[(EGLConfAttr, Int32)]]
    --, surfconf :: [[(EGLSurfAttr, Int32)]]
    , cxtconf :: [(EGLContextAttr, Int32)]
    }

initial = EglCurrent nullPtr nullPtr nullPtr nullPtr nullPtr nullPtr (0,0)

{-# NOINLINE showEglError #-}
showEglError :: EGLint -> String
showEglError x = case x of
    0x3000 -> "EGLSuccess: Function succeeded."
    0x3001 -> "EGLNotInitialized: EGL is not or could not be initialized, for the specified display."
    0x3002 -> "EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread)."
    0x3003 -> "EGLBadAlloc: EGL failed to allocate resources for the requested operation."
    0x3004 -> "EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list."
    0x3005 -> "EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig."
    0x3006 -> "EGLBadContext: An EGLContext argument does not name a valid EGLContext."
    0x3007 -> "EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid."
    0x3008 -> "EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay."
    0x3009 -> "EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface."
    0x300A -> "EGLBadNativePixmap: An EGLNativePixmapType argument does not refer to a valid native pixmap."
    0x300B -> "EGLBadNativeWindow: An EGLNativeWindowType argument does not refer to a valid native window."
    0x300C -> "EGLBadParameter: One or more argument values are invalid."
    0x300D -> "EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering."
    0x300E -> "EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."
    x | 0x300E < x && x < 0x3020 ->
        "EGLUnknownError: Error " ++ show x ++ " is not defined in EGL 1.4 spec."
    x -> "showEglError: Value out of range: " ++ show x

{-# NOINLINE withAttrList #-}
withAttrList :: [(EGLint, Int32)] -> (Ptr EGLint -> IO b) -> IO b
withAttrList attrs =
    withArray $ foldr (\(k, v) l -> k : v : l) [0x3038] attrs

{-# NOINLINE setupEgl #-}
-- | Get an EGLDisplay and choose a suitable config
setupEgl :: Maybe EGLNativeDisplay -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
setupEgl nd attribsList = do
    display <- eglGetDisplay $ maybe nullPtr id nd
    eglInitialize display nullPtr nullPtr

    -- Here specify the attributes of the desired configuration.
    -- Below, we select an EGLConfig with at least 8 bits per color
    -- component compatible with on-screen windows
    let go _ _ [] = return nullPtr -- suitable config not found!
        go cfg numConfigs (x:xs) = withAttrList (map (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
        eglChooseConfig display attribs cfg 1 numConfigs
        n <- peek numConfigs
        if n /= 0 then peek cfg else go cfg numConfigs xs
    config <- alloca $ \cfg ->
        alloca $ \numConfigs ->
            go cfg numConfigs attribsList

    -- EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is
    -- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.
    -- As soon as we picked a EGLConfig, we can safely reconfigure the
    -- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.
    --alloca $ \format->
    --  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
    --  ANativeWindow_setBuffersGeometry window 0 0 format
    return (display, config)

{-# NOINLINE setSurface #-}
setSurface :: EGLDisplay -> EGLConfig -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
setSurface disp config window = do
    surf <- eglCreateWindowSurface disp config window nullPtr
    alloca $ \ptr -> do
        eglQuerySurface disp surf 0x3057 ptr
        screen_width <- peek ptr
        eglQuerySurface disp surf 0x3056 ptr
        screen_height <- peek ptr
        return (surf, screen_width, screen_height)

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE Unsafe, UnliftedFFITypes, MagicHash, UnboxedTuples #-}
module Graphics.EGL.Base where

import Data.IORef
import Foreign
import Foreign.C.String
import System.IO.Unsafe (unsafePerformIO)
import GHC.Base (realWorld#)
import GHC.CString (unpackCString#)
import GHC.IO (IO (IO))
import GHC.Ptr (Ptr(..))


-- * EGL Types

-- | 32-bit signed integer
type EGLint = Int32

-- from EGL/egl.h
type EGLboolean = Word32
type EGLenum = Word32
type EGLConfig = Ptr ()
type EGLContext = Ptr ()
type EGLDisplay = Ptr ()
type EGLSurface = Ptr ()
type EGLClientBuffer = Ptr ()

-- from EGL/eglplatform.h
-- ** Window System Types

type EGLNativeWindow = Ptr ()
type EGLNativePixmap = Ptr ()
-- Symbian platform uses int instead of pointer
type EGLNativeDisplay = Ptr ()


-- * Bindings to EGL

#define EGL14(_name, _type) \
foreign import ccall unsafe "EGL/egl.h" _name :: _type

foreignEGL14(eglGetErrorimport ccall, IOunsafeEGLint"EGL/egl.h")           eglGetError ::  IO EGLint
foreignEGL14(eglGetDisplayimport ccall, unsafeEGLNativeDisplay"EGL/egl.h"->eglGetDisplayIO EGLDisplay::)   EGLNativeDisplay -> IO EGLDisplay
foreignEGL14(eglInitializeimport ccall, unsafeEGLDisplay"EGL/egl.h"-> Ptr EGLint-> Ptr EGLint::  EGLDisplay-> IO EGLboolean-> Ptr EGLint)      -> Ptr EGLint -> IO EGLboolean
foreignEGL14(eglTerminateimport ccall, EGLDisplay "EGL/egl.h"-> IO EGLboolean)     ::  EGLDisplay -> IO EGLboolean

foreignEGL14(eglQueryStringimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLint-> IO CString::)  EGLDisplay -> EGLint -> IO CString

foreignEGL14(eglGetConfigsimport ccall, unsafeEGLDisplay"EGL/egl.h"-> Ptr EGLConfig-> EGLint::  EGLDisplay-> Ptr EGLint-> Ptr-> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
foreignEGL14(eglChooseConfigimport ccall unsafe, EGLDisplay"EGL/egl.h"-> PtreglChooseConfigEGLint -> Ptr EGLConfig::  EGLDisplay-> EGLint-> Ptr-> EGLintPtr EGLint-> Ptr-> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean
foreignEGL14(eglGetConfigAttribimport ccall unsafe, EGLDisplay"EGL/egl.h"-> eglGetConfigAttribEGLConfig -> EGLint::-> EGLDisplayPtr EGLint -> EGLConfigIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean

foreignEGL14(eglCreateWindowSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplayeglCreateWindowSurface-> EGLConfig -> EGLNativeWindow::  EGLDisplay-> Ptr->EGLint-> IO->EGLSurface)      -> Ptr EGLint -> IO EGLSurface
foreignEGL14(eglCreatePbufferSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplay-> EGLConfig -> Ptr EGLint::  EGLDisplay-> IO EGLSurface-> EGLConfig)      -> Ptr EGLint -> IO EGLSurface
foreignEGL14(eglCreatePixmapSurfaceimport ccall unsafe "EGL/egl.h", EGLDisplayeglCreatePixmapSurface-> EGLConfig -> EGLNativePixmap::  EGLDisplay-> Ptr->EGLint-> IO->EGLSurface)      -> Ptr EGLint -> IO EGLSurface
foreignEGL14(eglDestroySurfaceimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> IO EGLboolean::  EGLDisplay)      -> EGLSurface -> IO EGLboolean
foreignEGL14(eglQuerySurfaceimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayPtr EGLint->->EGLSurfaceIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean

foreignEGL14(eglBindAPIimport ccall, EGLenum->"EGL/egl.h"IO EGLboolean)        ::  EGLenum -> IO EGLboolean
foreignEGL14(eglQueryAPIimport ccall, IOunsafeEGLenum"EGL/egl.h")          eglQueryAPI ::  IO EGLenum

foreignEGL14(eglWaitClientimport ccall, unsafeIO EGLboolean"EGL/egl.h")     eglWaitClient ::  IO EGLboolean

foreignEGL14(eglReleaseThreadimport ccall unsafe, IO EGLboolean"EGL/egl.h")  eglReleaseThread ::  IO EGLboolean

foreignEGL14(eglCreatePbufferFromClientBufferimport ccall unsafe "EGL/egl.h", eglCreatePbufferFromClientBufferEGLDisplay -> EGLenum -> EGLClientBuffer::  EGLDisplay-> EGLConfig-> EGLenum-> Ptr->EGLint-> IO EGLSurface-> EGLConfig)      -> Ptr EGLint -> IO EGLSurface

foreignEGL14(eglSurfaceAttribimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayEGLint -> -> EGLSurface)-> EGLint -> EGLint -> IO EGLboolean
foreignEGL14(eglBindTexImageimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLSurface-> EGLint::->EGLDisplayIO EGLboolean-> EGLSurface)          -> EGLint -> IO EGLboolean
foreignEGL14(eglReleaseTexImageimport ccall unsafe, EGLDisplay"EGL/egl.h"-> eglReleaseTexImageEGLSurface -> EGLint::->EGLDisplayIO EGLboolean-> EGLSurface)          -> EGLint -> IO EGLboolean

foreignEGL14(eglSwapIntervalimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLint-> IO EGLboolean::  EGLDisplay)          -> EGLint -> IO EGLboolean

foreignEGL14(eglCreateContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLConfig-> EGLContext::  EGLDisplay-> Ptr EGLint-> EGLConfig-> IO EGLContext-> EGLContext)      -> Ptr EGLint -> IO EGLContext
foreignEGL14(eglDestroyContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLContext-> IO EGLboolean::  EGLDisplay)      -> EGLContext -> IO EGLboolean
foreignEGL14(eglMakeCurrentimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> EGLSurface::  EGLDisplay-> EGLContext-> EGLSurface-> IO EGLboolean-> EGLSurface)      -> EGLContext -> IO EGLboolean

foreignEGL14(eglGetCurrentContextimport ccall unsafe, "EGL/egl.h"IO EGLContext)                   ::  IO EGLContext
foreignEGL14(eglGetCurrentSurfaceimport ccall unsafe, "EGL/egl.h"EGLint -> IOeglGetCurrentSurfaceEGLSurface)         ::  EGLint -> IO EGLSurface
foreignEGL14(eglGetCurrentDisplayimport ccall unsafe, "EGL/egl.h"IO EGLDisplay)                   ::  IO EGLDisplay
foreignEGL14(eglQueryContextimport ccall unsafe, EGLDisplay"EGL/egl.h"-> EGLContext-> EGLint::->EGLDisplayPtr EGLint->->EGLContextIO EGLboolean-> EGLint)      -> Ptr EGLint -> IO EGLboolean

--EGL14(eglWaitGL, IO EGLboolean)--foreign import ccall unsafe "EGL/egl.h" eglWaitGL ::  IO EGLboolean
foreignEGL14(eglWaitNativeimport ccall, unsafe "EGL/egl.h"-> IO EGLboolean)         ::  EGLint -> IO EGLboolean
foreignEGL14(eglSwapBuffersimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> IO EGLboolean::  EGLDisplay)      -> EGLSurface -> IO EGLboolean
foreignEGL14(eglCopyBuffersimport ccall,unsafeEGLDisplay"EGL/egl.h"-> EGLSurface-> EGLNativePixmap::  EGLDisplay-> IO->EGLboolean) -> EGLNativePixmap -> IO EGLboolean


-- * Obtain Extension Function Pointer

-- | Just like unsafePerformIO, but we inline it. Big performance gains as
-- it exposes lots of things to further inlining. /Very unsafe/. In
-- particular, you should do no memory allocation inside an
-- 'inlinePerformIO' block.
inlinePerformIO :: IO a -> a
inlinePerformIO (IO m) = case m realWorld# of (# _, r #) -> r
{-# INLINE inlinePerformIO #-}

foreign import ccall unsafe "EGL/egl.h eglGetProcAddress"
    c_eglGetProcAddress :: CString -> IO (FunPtr a)

eglGetProcAddress :: String -> FunPtr a
eglGetProcAddress procname = unsafePerformIO $
    withCString procname c_eglGetProcAddress
{-# INLINE [0] eglGetProcAddress #-}
{-# RULES
"EGL eglGetProcAddress/c_eglGetProcAddress" forall s .
   eglGetProcAddress (unpackCString# s) = inlinePerformIO (c_eglGetProcAddress (Ptr s))
 #-}


-- * Misc
-- * Misc
newtype EGLConfAttr = EGLConfAttr EGLint
newtype EGLConfAttr = EGLConfAttr EGLint
newtype EGLSurfAttrEGLContextAttr= EGLSurfAttr= EGLContextAttrEGLint
newtype EGLContextAttr = EGLContextAttr EGLint
{-# NOINLINE queryString #-}
{-# NOINLINEqueryString ::EGLint -> #-} -> IO String
queryString ::nameegl =->doEgl -> IO String
queryStringdisplay name<- fmapdisp= do$ readIORef egl
    displayeglQueryString<- fmapdisplay $ readIORefname >>= peekCString
    eglQueryString display name >>= peekCString
{-# NOINLINE queryContext #-}
{-# NOINLINE queryContext:: EGLint -> #-} -> IO EGLint
queryContext ::attregl =->doEgl -> IO EGLint
queryContextEglCurrent{disp=disp= do, context=context} <- readIORef egl
    EglCurrentalloca $ \{valuedisp=disp->  , context=context} <- readIORef egl
    allocaeglQueryContext \value ->  disp context attr value >> peek value
                   eglQueryContext disp context attr value >> peek value
type Egl = IORef EglCurrent
type Egl = IORef EglCurrent
data EglCurrent = EglCurrent
data{EglCurrentdisp :: EGLDisplay= EglCurrent
    { dispchosen::::EGLConfig
    , chosencontext::::EGLConfigEGLContext
    , contextdsurf ::::EGLSurface
    , dsurf :: EGLSurface
    , rsurfnwin ::::EGLNativeWindow
    , nwinscreenDims:: EGLNativeWindow:: (Int32, Int32)
    , screenDimsndisp :: Maybe:: (Int32EGLNativeDisplay, Int32)
    , ndispconfcand:: Maybe:: [[(EGLNativeDisplayEGLConfAttr, Int32)]]
    ,--, surfconf :: [[(EGLSurfAttr, Int32)]] :: [[(EGLConfAttr, Int32)]]
    ,--, surfconf :: [[(EGLSurfAttr, Int32)]]cxtconf :: [(EGLContextAttr, Int32)]
    , cxtconf :: [(EGLContextAttr, Int32)]
    }
initial = EglCurrent nullPtr nullPtr nullPtr nullPtr nullPtr nullPtr (0,0)
initial = EglCurrent nullPtr nullPtr nullPtr nullPtr nullPtr nullPtr (0,0)
{-# NOINLINE showEglError #-}
{-# NOINLINE showEglError:: EGLint -> #-}String
showEglError ::x =EGLintcase x->ofString
showEglError0x3000 ->x"EGLSuccess: Function succeeded."= case x of
    0x3000 -> "EGLSuccess: Function succeeded.""EGLNotInitialized: EGL is not or could not be initialized, for the specified display."
    0x3001 -> "EGLNotInitialized: EGL is not or could not be initialized, for the specified display.""EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread)."
    0x3002 -> "EGLBadAccess: EGL cannot access a requested resource (for example, a context is bound in another thread).""EGLBadAlloc: EGL failed to allocate resources for the requested operation."
    0x3003 -> "EGLBadAlloc: EGL failed to allocate resources for the requested operation.""EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list."
    0x3004 -> "EGLBadAttribute: An unrecognized attribute or attribute value was passed in an attribute list.""EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig."
    0x3005 -> "EGLBadConfig: An EGLConfig argument does not name a valid EGLConfig.""EGLBadContext: An EGLContext argument does not name a valid EGLContext."
    0x3006 -> "EGLBadContext: An EGLContext argument does not name a valid EGLContext.""EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid."
    0x3007 -> "EGLBadCurrentSurface: The current surface of the calling thread is a window, pbuffer, or pixmap that is no longer valid.""EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay."
    0x3008 -> "EGLBadDisplay: An EGLDisplay argument does not name a valid EGLDisplay.""EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface."
    0x3009 -> "EGLBadMatch: Arguments are inconsistent; for example, an otherwise valid context requires buffers (e.g. depth or stencil) not allocated by an otherwise valid surface.""EGLBadNativePixmap: An EGLNativePixmapType argument does not refer to a valid native pixmap."
    0x300A -> "EGLBadNativePixmap: An EGLNativePixmapType argument does not refer to a valid native pixmap."
    0x300B -> "EGLBadNativeWindow: An EGLNativeWindowType argument does not refer to a valid native window.""EGLBadParameter: One or more argument values are invalid."
    0x300C -> "EGLBadParameter: One or more argument values are invalid.""EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering."
    0x300D -> "EGLBadSurface: An EGLSurface argument does not name a valid surface (window, pbuffer, or pixmap) configured for rendering.""EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."
    0x300Ex | 0x300E "EGLContextLost: A power management event has occurred. The application must destroy all contexts and reinitialise client API state and objects to continue rendering."< x && x < 0x3020 ->
    x | 0x300E"EGLUnknownError: Error " x && x < 0x3020 ->++ show x ++ " is not defined in EGL 1.4 spec."
    x ->"EGLUnknownError: Error ""showEglError: Value out of range: " show x ++++show x
    x -> "showEglError: Value out of range: " ++ show x
{-# NOINLINE withAttrList #-}
{-# NOINLINE withAttrList:: [(EGLint, #-}Int32)] -> (Ptr EGLint -> IO b) -> IO b
withAttrList ::attrs(EGLint=    , Int32)] -> (Ptr EGLint -> IO b) -> IO b
withAttrListwithArrayattrs$ foldr=  (\(k, v) l -> k : v : l) [0x3038] attrs
    withArray $ foldr (\(k, v) l -> k : v : l) [0x3038] attrs
{-# NOINLINE setupEgl #-}
{-# NOINLINE-- | Get an EGLDisplay and choose a suitable config #-}
setupEgl-- | Get an EGLDisplay and choose a suitable config:: Maybe EGLNativeDisplay -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
setupEgl :: MaybeattribsList= do       -> [[(EGLConfAttr, Int32)]] -> IO (EGLDisplay, EGLConfig)
setupEgldisplay attribsList<- eglGetDisplay= do $ maybe nullPtr id nd
    displayeglInitialize<- eglGetDisplaydisplay nullPtr maybenullPtr id nd
    eglInitialize display nullPtr nullPtr
    -- Here specify the attributes of the desired configuration.
    -- Here specify the attributes of the desired configuration.-- Below, we select an EGLConfig with at least 8 bits per color
    -- component compatible with on-screen windows-- Below, we select an EGLConfig with at least 8 bits per color
    let-- component compatible with on-screen windowsgo _ _ [] = return nullPtr -- suitable config not found!
    let go _cfg [numConfigs] = return(nullPtrx:xs) = withAttrList-- suitable config not found!(map (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
        goeglChooseConfig numConfigsdisplayx:xs)attribs= withAttrListcfg 1 numConfigsmap (\(EGLConfAttr a,b)->(a,b))x) $ \attribs -> do
                                  eglChooseConfign <- peek numConfigs attribs cfg 1 numConfigs
                                  nif<-n peek/= 0 numConfigsthen peek cfg else go cfg numConfigs xs
                              config n<-/=alloca then$ peek\cfg cfg->  else go cfg numConfigs xs
    configalloca<- alloca$ \numConfigs \cfg ->->
                 allocago $cfgnumConfigsnumConfigs->attribsList
                     go cfg numConfigs attribsList
    -- EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is
    -- EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is-- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.
    -- guaranteed to be accepted by ANativeWindow_setBuffersGeometry.-- As soon as we picked a EGLConfig, we can safely reconfigure the
    -- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.-- As soon as we picked a EGLConfig, we can safely reconfigure the
    --alloca $ \format->-- ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID.
    --alloca $ \format->--  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
    --  ANativeWindow_setBuffersGeometry window 0 0 format--  eglGetConfigAttrib display config EGL_NATIVE_VISUAL_ID format
    return--  ANativeWindow_setBuffersGeometry window 0 0 format(display, config)
    return (display, config)
{-# NOINLINE setSurface #-}
{-# NOINLINEsetSurface ::setSurfaceEGLDisplay#-}-> EGLConfig -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
setSurface ::dispconfig window-> EGLConfig= do    -> EGLNativeWindow -> IO (EGLSurface, EGLint, EGLint)
setSurfacesurf <-dispeglCreateWindowSurface window = do disp config window nullPtr
    surfalloca<-$eglCreateWindowSurface\ptr -> do            disp config window nullPtr
    allocaeglQuerySurface \ptr -> do disp surf 0x3057 ptr
                   eglQuerySurfacescreen_width <- disp surfptr  0x3057 ptr
                   screen_widtheglQuerySurface<- peek ptrsurf 0x3056 ptr
                   eglQuerySurfacescreen_height <-disppeeksurfptr 0x3056 ptr
                   screen_heightreturn (surf, <-screen_width ptr , screen_height)
                   return (surf, screen_width, screen_height)

</pre>