<a href="Class.hs12384895531882410547.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Class.hs17195338081517273377.out.html">next</a></br></br><pre>39d38
< class Monad μ ⇒ MonadAbort e μ | μ → e where
40c39
<   abort ∷ e → μ α
---
> class Monad μ => MonadAbort e μ | μ -> e where
40a40
>   abort :: e -> μ α
42d41
< class MonadAbort e μ ⇒ MonadRecover e μ | μ → e where
43c42
<   recover ∷ μ α → (e → μ α) → μ α
---
> class MonadAbort e μ => MonadRecover e μ | μ -> e where
43a43
>   recover :: μ α -> (e -> μ α) -> μ α
45d44
< onError ∷ MonadRecover e μ ⇒ μ α → (e → μ β) → μ α
46c45
< onError m h = recover m (\e → h e >> abort e)
---
> onError :: MonadRecover e μ => μ α -> (e -> μ β) -> μ α
46a46
> onError m h = recover m (\e -> h e >> abort e)
48c48
< onError_ ∷ MonadRecover e μ ⇒ μ α → μ β → μ α
---
> onError_ :: MonadRecover e μ => μ α -> μ β -> μ α
51c51
< ignore ∷ MonadRecover e μ ⇒ μ α → μ ()
---
> ignore :: MonadRecover e μ => μ α -> μ ()
54c54
< instance Monad μ ⇒ MonadAbort e (AbortT e μ) where
---
> instance Monad μ => MonadAbort e (AbortT e μ) where
57c57
< instance Monad μ ⇒ MonadRecover e (AbortT e μ) where
---
> instance Monad μ => MonadRecover e (AbortT e μ) where
66c66
< instance Monad μ ⇒ MonadError e (AbortT e μ) where
---
> instance Monad μ => MonadError e (AbortT e μ) where
70d69
< instance MonadCont μ ⇒ MonadCont (AbortT e μ) where
71c70
<   callCC k = AbortT $ callCC $ \f → runAbortT $ k (lift . f . Right)
---
> instance MonadCont μ => MonadCont (AbortT e μ) where
71a71
>   callCC k = AbortT $ callCC $ \f -> runAbortT $ k (lift . f . Right)
73c73
< instance MonadReader r μ ⇒ MonadReader r (AbortT e μ) where
---
> instance MonadReader r μ => MonadReader r (AbortT e μ) where
77c77
< instance MonadState s μ ⇒ MonadState s (AbortT e μ) where
---
> instance MonadState s μ => MonadState s (AbortT e μ) where
81c81
< instance MonadWriter w μ ⇒ MonadWriter w (AbortT e μ) where
---
> instance MonadWriter w μ => MonadWriter w (AbortT e μ) where
84d83
<     (lr, w) ← listen $ runAbortT m
85c84
<     return $! fmap (, w) lr
---
>     (lr, w) <- listen $ runAbortT m
85a85
>     return $! fmap (  w) lr
87d86
<     lr ← runAbortT m
88c87
<     return $! either ((, id) . Left) (\(r, f) → (Right r, f)) lr
---
>     lr <- runAbortT m
88a88
>     return $! either ((  id) . Left) (\(r, f) -> (Right r, f)) lr
90c90
< instance MonadRWS r w s μ ⇒ MonadRWS r w s (AbortT e μ)
---
> instance MonadRWS r w s μ => MonadRWS r w s (AbortT e μ)
92c92
< instance MonadAbort e μ ⇒ MonadAbort e (IdentityT μ) where
---
> instance MonadAbort e μ => MonadAbort e (IdentityT μ) where
95c95
< instance MonadRecover e μ ⇒ MonadRecover e (IdentityT μ) where
---
> instance MonadRecover e μ => MonadRecover e (IdentityT μ) where
98c98
< instance MonadAbort e μ ⇒ MonadAbort e (ContT r μ) where
---
> instance MonadAbort e μ => MonadAbort e (ContT r μ) where
101c101
< instance MonadAbort e μ ⇒ MonadAbort e (MaybeT μ) where
---
> instance MonadAbort e μ => MonadAbort e (MaybeT μ) where
104c104
< instance MonadRecover e μ ⇒ MonadRecover e (MaybeT μ) where
---
> instance MonadRecover e μ => MonadRecover e (MaybeT μ) where
107c107
< instance MonadAbort e μ ⇒ MonadAbort e (ListT μ) where
---
> instance MonadAbort e μ => MonadAbort e (ListT μ) where
110c110
< instance MonadRecover e μ ⇒ MonadRecover e (ListT μ) where
---
> instance MonadRecover e μ => MonadRecover e (ListT μ) where
113c113
< instance MonadAbort e μ ⇒ MonadAbort e (ReaderT r μ) where
---
> instance MonadAbort e μ => MonadAbort e (ReaderT r μ) where
116d115
< instance MonadRecover e μ ⇒ MonadRecover e (ReaderT r μ) where
117c116
<   recover m h = ReaderT $ \r → runReaderT m r `recover` ((`runReaderT` r) . h)
---
> instance MonadRecover e μ => MonadRecover e (ReaderT r μ) where
117a117
>   recover m h = ReaderT $ \r -> runReaderT m r `recover` ((`runReaderT` r) . h)
119c119
< instance MonadAbort e μ ⇒ MonadAbort e (L.StateT s μ) where
---
> instance MonadAbort e μ => MonadAbort e (L.StateT s μ) where
122d121
< instance MonadRecover e μ ⇒ MonadRecover e (L.StateT s μ) where
123c122
<   recover m h = L.StateT $ \s →
---
> instance MonadRecover e μ => MonadRecover e (L.StateT s μ) where
123a123
>   recover m h = L.StateT $ \s ->
126c126
< instance MonadAbort e μ ⇒ MonadAbort e (S.StateT s μ) where
---
> instance MonadAbort e μ => MonadAbort e (S.StateT s μ) where
129d128
< instance MonadRecover e μ ⇒ MonadRecover e (S.StateT s μ) where
130c129
<   recover m h = S.StateT $ \s →
---
> instance MonadRecover e μ => MonadRecover e (S.StateT s μ) where
130a130
>   recover m h = S.StateT $ \s ->
133c133
< instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (L.WriterT w μ) where
---
> instance (MonadAbort e μ, Monoid w) => MonadAbort e (L.WriterT w μ) where
136c136
< instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (L.WriterT w μ) where
---
> instance (MonadRecover e μ, Monoid w) => MonadRecover e (L.WriterT w μ) where
139c139
< instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (S.WriterT w μ) where
---
> instance (MonadAbort e μ, Monoid w) => MonadAbort e (S.WriterT w μ) where
142c142
< instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (S.WriterT w μ) where
---
> instance (MonadRecover e μ, Monoid w) => MonadRecover e (S.WriterT w μ) where
145c145
< instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (L.RWST r w s μ) where
---
> instance (MonadAbort e μ, Monoid w) => MonadAbort e (L.RWST r w s μ) where
148d147
< instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (L.RWST r w s μ) where
149d147
<   recover m h = L.RWST $ \r s →
150c148
<     L.runRWST m r s `recover` (\e → L.runRWST (h e) r s)
---
> instance (MonadRecover e μ, Monoid w) => MonadRecover e (L.RWST r w s μ) where
150a149
>   recover m h = L.RWST $ \r s ->
150a150
>     L.runRWST m r s `recover` (\e -> L.runRWST (h e) r s)
152c152
< instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (S.RWST r w s μ) where
---
> instance (MonadAbort e μ, Monoid w) => MonadAbort e (S.RWST r w s μ) where
155d154
< instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (S.RWST r w s μ) where
156d154
<   recover m h = S.RWST $ \r s →
157c155
<     S.runRWST m r s `recover` (\e → S.runRWST (h e) r s)
---
> instance (MonadRecover e μ, Monoid w) => MonadRecover e (S.RWST r w s μ) where
157a156
>   recover m h = S.RWST $ \r s ->
157a157
>     S.runRWST m r s `recover` (\e -> S.runRWST (h e) r s)
158a159
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Control.Monad.Abort.Class (
    MonadAbort(..),
    MonadRecover(..),
    onError,
    onError_,
    ignore
  ) where

import Prelude hiding (catch)
import Data.Monoid
import Control.Exception (SomeException, throwIO, catch)
import Control.Monad.Trans.Identity
import Control.Monad.Trans.Maybe
import Control.Monad.Cont
import Control.Monad.Error
import Control.Monad.List
import Control.Monad.Reader
import Control.Monad.State (MonadState(..))
import qualified Control.Monad.State.Lazy as L
import qualified Control.Monad.State.Strict as S
import Control.Monad.Writer (MonadWriter(..))
import qualified Control.Monad.Writer.Lazy as L
import qualified Control.Monad.Writer.Strict as S
import Control.Monad.RWS (MonadRWS)
import qualified Control.Monad.RWS.Lazy as L
import qualified Control.Monad.RWS.Strict as S
import Control.Monad.Trans.Abort (AbortT(..))
import qualified Control.Monad.Trans.Abort as A

class Monad μ ⇒ MonadAbort e μ | μ → e where
  abort ∷ e → μ α

class MonadAbort e μ ⇒ MonadRecover e μ | μ → e where
  recover ∷ μ α → (e → μ α) → μ α

onError ∷ MonadRecover e μ ⇒ μ α → (e → μ β) → μ α
onError m h = recover m (\e → h e >> abort e)

onError_ ∷ MonadRecover e μ ⇒ μ α → μ β → μ α
onError_ m = onError m . const

ignore ∷ MonadRecover e μ ⇒ μ α → μ ()
ignore m = recover (m >> return ()) (const $ return ())

instance Monad μ ⇒ MonadAbort e (AbortT e μ) where
  abort = A.abort

instance Monad μ ⇒ MonadRecover e (AbortT e μ) where
  recover = A.recover

instance MonadAbort SomeException IO where
  abort = throwIO

instance MonadRecover SomeException IO where
  recover = catch

instance Monad μ ⇒ MonadError e (AbortT e μ) where
  throwError = A.abort
  catchError = A.recover

instance MonadCont μ ⇒ MonadCont (AbortT e μ) where
  callCC k = AbortT $ callCC $ \f → runAbortT $ k (lift . f . Right)

instance MonadReader r μ ⇒ MonadReader r (AbortT e μ) where
  ask = lift ask
  local f = AbortT . local f . runAbortT

instance MonadState s μ ⇒ MonadState s (AbortT e μ) where
  get = lift get
  put = lift . put

instance MonadWriter w μ ⇒ MonadWriter w (AbortT e μ) where
  tell = lift . tell
  listen m = AbortT $ do
    (lr, w) ← listen $ runAbortT m
    return $! fmap (, w) lr
  pass m = AbortT $ pass $ do
    lr ← runAbortT m
    return $! either ((, id) . Left) (\(r, f) → (Right r, f)) lr

instance MonadRWS r w s μ ⇒ MonadRWS r w s (AbortT e μ)

instance MonadAbort e μ ⇒ MonadAbort e (IdentityT μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (IdentityT μ) where
  recover m h = IdentityT $ runIdentityT m `recover` (runIdentityT . h)

instance MonadAbort e μ ⇒ MonadAbort e (ContT r μ) where
  abort = lift . abort

instance MonadAbort e μ ⇒ MonadAbort e (MaybeT μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (MaybeT μ) where
  recover m h = MaybeT $ runMaybeT m `recover` (runMaybeT . h)

instance MonadAbort e μ ⇒ MonadAbort e (ListT μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (ListT μ) where
  recover m h = ListT $ runListT m `recover` (runListT . h)

instance MonadAbort e μ ⇒ MonadAbort e (ReaderT r μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (ReaderT r μ) where
  recover m h = ReaderT $ \r → runReaderT m r `recover` ((`runReaderT` r) . h)

instance MonadAbort e μ ⇒ MonadAbort e (L.StateT s μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (L.StateT s μ) where
  recover m h = L.StateT $ \s →
    L.runStateT m s `recover` ((`L.runStateT` s) . h)

instance MonadAbort e μ ⇒ MonadAbort e (S.StateT s μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (S.StateT s μ) where
  recover m h = S.StateT $ \s →
    S.runStateT m s `recover` ((`S.runStateT` s) . h)

instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (L.WriterT w μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (L.WriterT w μ) where
  recover m h = L.WriterT $ L.runWriterT m `recover` (L.runWriterT . h)

instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (S.WriterT w μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (S.WriterT w μ) where
  recover m h = S.WriterT $ S.runWriterT m `recover` (S.runWriterT . h)

instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (L.RWST r w s μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (L.RWST r w s μ) where
  recover m h = L.RWST $ \r s →
    L.runRWST m r s `recover` (\e → L.runRWST (h e) r s)

instance (MonadAbort e μ, Monoid w) ⇒ MonadAbort e (S.RWST r w s μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) ⇒ MonadRecover e (S.RWST r w s μ) where
  recover m h = S.RWST $ \r s →
    S.runRWST m r s `recover` (\e → S.runRWST (h e) r s)

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Control.Monad.Abort.Class (
    MonadAbort(..),
    MonadRecover(..),
    onError,
    onError_,
    ignore
  ) where

import Prelude hiding (catch)
import Data.Monoid
import Control.Exception (SomeException, throwIO, catch)
import Control.Monad.Trans.Identity
import Control.Monad.Trans.Maybe
import Control.Monad.Cont
import Control.Monad.Error
import Control.Monad.List
import Control.Monad.Reader
import Control.Monad.State (MonadState(..))
import qualified Control.Monad.State.Lazy as L
import qualified Control.Monad.State.Strict as S
import Control.Monad.Writer (MonadWriter(..))
import qualified Control.Monad.Writer.Lazy as L
import qualified Control.Monad.Writer.Strict as S
import Control.Monad.RWS (MonadRWS)
import qualified Control.Monad.RWS.Lazy as L
import qualified Control.Monad.RWS.Strict as S
import Control.Monad.Trans.Abort (AbortT(..))
import qualified Control.Monad.Trans.Abort as A

class Monad μ => MonadAbort e μ | μ -> e where
  abort :: e -> μ α

class MonadAbort e μ => MonadRecover e μ | μ -> e where
  recover :: μ α -> (e -> μ α) -> μ α

onError :: MonadRecover e μ => μ α -> (e -> μ β) -> μ α
onError m h = recover m (\e -> h e >> abort e)

onError_ :: MonadRecover e μ => μ α -> μ β -> μ α
onError_ m = onError m . const

ignore :: MonadRecover e μ => μ α -> μ ()
ignore m = recover (m >> return ()) (const $ return ())

instance Monad μ => MonadAbort e (AbortT e μ) where
  abort = A.abort

instance Monad μ => MonadRecover e (AbortT e μ) where
  recover = A.recover

instance MonadAbort SomeException IO where
  abort = throwIO

instance MonadRecover SomeException IO where
  recover = catch

instance Monad μ => MonadError e (AbortT e μ) where
  throwError = A.abort
  catchError = A.recover

instance MonadCont μ => MonadCont (AbortT e μ) where
  callCC k = AbortT $ callCC $ \f -> runAbortT $ k (lift . f . Right)

instance MonadReader r μ => MonadReader r (AbortT e μ) where
  ask = lift ask
  local f = AbortT . local f . runAbortT

instance MonadState s μ => MonadState s (AbortT e μ) where
  get = lift get
  put = lift . put

instance MonadWriter w μ => MonadWriter w (AbortT e μ) where
  tell = lift . tell
  listen m = AbortT $ do
    (lr, w) <- listen $ runAbortT m
    return $! fmap (  w) lr
  pass m = AbortT $ pass $ do
    lr <- runAbortT m
    return $! either ((  id) . Left) (\(r, f) -> (Right r, f)) lr

instance MonadRWS r w s μ => MonadRWS r w s (AbortT e μ)

instance MonadAbort e μ => MonadAbort e (IdentityT μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (IdentityT μ) where
  recover m h = IdentityT $ runIdentityT m `recover` (runIdentityT . h)

instance MonadAbort e μ => MonadAbort e (ContT r μ) where
  abort = lift . abort

instance MonadAbort e μ => MonadAbort e (MaybeT μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (MaybeT μ) where
  recover m h = MaybeT $ runMaybeT m `recover` (runMaybeT . h)

instance MonadAbort e μ => MonadAbort e (ListT μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (ListT μ) where
  recover m h = ListT $ runListT m `recover` (runListT . h)

instance MonadAbort e μ => MonadAbort e (ReaderT r μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (ReaderT r μ) where
  recover m h = ReaderT $ \r -> runReaderT m r `recover` ((`runReaderT` r) . h)

instance MonadAbort e μ => MonadAbort e (L.StateT s μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (L.StateT s μ) where
  recover m h = L.StateT $ \s ->
    L.runStateT m s `recover` ((`L.runStateT` s) . h)

instance MonadAbort e μ => MonadAbort e (S.StateT s μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (S.StateT s μ) where
  recover m h = S.StateT $ \s ->
    S.runStateT m s `recover` ((`S.runStateT` s) . h)

instance (MonadAbort e μ, Monoid w) => MonadAbort e (L.WriterT w μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) => MonadRecover e (L.WriterT w μ) where
  recover m h = L.WriterT $ L.runWriterT m `recover` (L.runWriterT . h)

instance (MonadAbort e μ, Monoid w) => MonadAbort e (S.WriterT w μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) => MonadRecover e (S.WriterT w μ) where
  recover m h = S.WriterT $ S.runWriterT m `recover` (S.runWriterT . h)

instance (MonadAbort e μ, Monoid w) => MonadAbort e (L.RWST r w s μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) => MonadRecover e (L.RWST r w s μ) where
  recover m h = L.RWST $ \r s ->
    L.runRWST m r s `recover` (\e -> L.runRWST (h e) r s)

instance (MonadAbort e μ, Monoid w) => MonadAbort e (S.RWST r w s μ) where
  abort = lift . abort

instance (MonadRecover e μ, Monoid w) => MonadRecover e (S.RWST r w s μ) where
  recover m h = S.RWST $ \r s ->
    S.runRWST m r s `recover` (\e -> S.runRWST (h e) r s)


</pre>