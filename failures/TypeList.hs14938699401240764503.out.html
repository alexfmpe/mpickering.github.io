<a href="TypeList.hs10551512406933754.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TypeList.hs8716080311130220830.out.html">next</a></br></br><pre>23d22
< type instance '[]      :++: xs = xs
24c23
< type instance (h ': t) :++: xs = h ': (t :++: xs)
---
> type instance          :++:[]           xs = xs
24a24
> type instance          :++:h  : t)      xs = h  : (t :++: xs)
24a25
> 
</pre></br><h2>original</h2></br><pre>-----------------------------------------------------------------------------
-- |
-- Module:      Data.Pattern.Base.TypeList
-- License:     BSD3
-- Maintainer:  Brent Yorgey <byorgey@cis.upenn.edu>
-- Stability:   experimental
-- Portability: non-portable (see .cabal)
--
-- Type-level lists. These lists only describe the types, but contain
-- no data. That is, they are phantom types.
-----------------------------------------------------------------------------

{-# LANGUAGE PolyKinds, DataKinds #-}
module Data.Pattern.Base.TypeList where

infixr :++:

-- | Concatenation of lists. Instances:
--
-- > type instance Nil     :++: xs = xs
-- > type instance (h:*:t) :++: xs = h :*: (t :++: xs)
type family (:++:) (a :: [*]) (b :: [*]) :: [*]
type instance '[]      :++: xs = xs
type instance (h ': t) :++: xs = h ': (t :++: xs)
</pre></br><h2>printed</h2></br><pre>-----------------------------------------------------------------------------
-- |
-- Module:      Data.Pattern.Base.TypeList
-- License:     BSD3
-- Maintainer:  Brent Yorgey <byorgey@cis.upenn.edu>
-- Stability:   experimental
-- Portability: non-portable (see .cabal)
--
-- Type-level lists. These lists only describe the types, but contain
-- no data. That is, they are phantom types.
-----------------------------------------------------------------------------

{-# LANGUAGE PolyKinds, DataKinds #-}
module Data.Pattern.Base.TypeList where

infixr :++:

-- | Concatenation of lists. Instances:
--
-- > type instance Nil     :++: xs = xs
-- > type instance (h:*:t) :++: xs = h :*: (t :++: xs)
type family (:++:) (a :: [*]) (b :: [*]) :: [*]
type instance          :++:[]           xs = xs
type instance          :++:h  : t)      xs = h  : (t :++: xs)

</pre>