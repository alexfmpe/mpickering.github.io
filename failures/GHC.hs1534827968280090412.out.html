<a href="Get.hs577163951524325968.out.html">prev</a></br><a href="failures.html">home</a></br><a href="GramSchmidt.hs14587779232007237709.out.html">next</a></br></br><pre>1c1
< {-# LANGUAGE BangPatterns #-}
---
> {-# LANGUAGE BangPatterns #-}-- WARNING: This is not a full Haskell module, it is a snippet to #include...
3d2
< {-# LANGUAGE CPP #-}
4d2
< 
5d2
< -- | This is the simplest implementation of thread-local storage using
6d2
< -- GHC's built-in ThreadId capabilities.
7d2
< --
8d2
< -- While the interface below is designed to match the other
9d2
< -- implementations of TLS in this package, the GHC implementation can
10d2
< -- generaly be relied upon to keep a stable copy of the TLS variable
11d2
< -- for each `ThreadId` that calls `getTLS`.  This may change in the
12c3
< -- future, however!
---
> {-# LANGUAGE CPP #-}-- | Make a new per-thread variable.  This guarantees that no two
12a4
> -- threads that execute `getTLS` simultaneosly will receive the same
12a5
> -- | This is the simplest implementation of thread-local storage using-- copy of the value.  Generally, to meet this guarantee there must be
12a6
> -- GHC's built-in ThreadId capabilities.-- AT LEAST one copy of the TLS variable for each distinct OS thread
12a7
> ---- that calls `getAll`.  But this is a lower bound, and there may be
12a8
> -- While the interface below is designed to match the other-- *more*.  In particular, there could be one per Haskell IO thread
12a9
> -- rather than per OS thread.-- implementations of TLS in this package, the GHC implementation can
12a10
> ---- generaly be relied upon to keep a stable copy of the TLS variable
12a11
> -- Thread safe.-- for each `ThreadId` that calls `getTLS`.  This may change in the
12a12
> -- future, however!-- ^ Action for creating a single copy of the TLS variable.
15d14
<     ( TLS
16d14
<     , mkTLS
17d14
<     , getTLS
18d14
<     , allTLS
19c15
<     , forEachTLS_
---
> -- | Fetch this thread's copy of the TLS variable.  Note that all TLS
19a16
> -- values returned by this function may be immune to garbage collected, mkTLS
19a17
> -- until `freeTLS` is called., getTLS
19a18
> --  , allTLS
19a19
> -- Thread safe., forEachTLS_
23d22
< import Control.Monad
24d22
< import Control.Exception (evaluate)
25d22
< import Control.Concurrent
26d22
< import Data.Map.Strict as M
27c23
< import Data.IORef
---
> import-- | After a TLS-based computation is complete, iterate through allControl.Monad
27a24
> import-- the copies of the TLS variable which were used by all threads.Control.Exception (evaluate)
27a25
> import--     Control.Concurrent
27a26
> import-- NOT thread safe.Data.Map.Strict as M
27a27
> import Data.IORef :: IO a
27a28
>       -> IO (TLS a)
29d29
< -- Module signature:
30d29
< --------------------------------------------------------------------------------
32d30
< #include "TLS_Sig.hs"
34d31
< --------------------------------------------------------------------------------
36d32
< -- | A thread-local variable of type `a`.
37c33
< data TLS a = TLS { mkNew     ::  !(IO a)
---
> 
37a34
> 
37a35
> getTLS :: TLS a -> IO a
37a36
> 
37a37
> 
37a38
> 
37a39
> 
37a40
> 
37a41
> 
37a42
> allTLS :: TLS a -> IO [a]
37a43
> 
37a44
> -- Module signature:
37a45
> -- | Like `allTLS`, but apply a computation directly rather than--------------------------------------------------------------------------------
37a46
> -- building a list.
37a47
> forEachTLS_#include "TLS_Sig.hs":: TLS a -> (a -> IO ()) -> IO ()
37a48
> 
37a49
> -- | Release all copies of the TLS variable, across all threads.  This--------------------------------------------------------------------------------
37a50
> -- does not guarantee the storage will be freed immediately, but it
37a51
> -- | A thread-local variable of type `a`.-- guarantees that the storage can be reclaimed in the future.
37a52
> freeTLS :: TLS a -> IO () TLS a = TLS { mkNew     ::  !(IO a)
50d64
<         a <- mkNew
51d64
<         atomicModifyIORef' allCopies (\ mp -> (M.insert tid a mp, ()))
52d64
<         return $! a
54d65
< allTLS TLS{allCopies} = do
55d65
<   mp <- readIORef allCopies
56d65
<   return $! M.elems mp
57d65
< 
58d65
< forEachTLS_ tls fn = do
59d65
<   ls <- allTLS tls
60d65
<   forM_ ls fn
61d65
< 
62d65
< -- Nothing to do here... we haven't pinned anything.  Normal GC is fine.
63d65
< freeTLS _ = return ()
64d65
< 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE CPP #-}

-- | This is the simplest implementation of thread-local storage using
-- GHC's built-in ThreadId capabilities.
--
-- While the interface below is designed to match the other
-- implementations of TLS in this package, the GHC implementation can
-- generaly be relied upon to keep a stable copy of the TLS variable
-- for each `ThreadId` that calls `getTLS`.  This may change in the
-- future, however!

module Data.TLS.GHC
    ( TLS
    , mkTLS
    , getTLS
    , allTLS
    , forEachTLS_
    , freeTLS
    ) where

import Control.Monad
import Control.Exception (evaluate)
import Control.Concurrent
import Data.Map.Strict as M
import Data.IORef

-- Module signature:
--------------------------------------------------------------------------------

#include "TLS_Sig.hs"

--------------------------------------------------------------------------------

-- | A thread-local variable of type `a`.
data TLS a = TLS { mkNew     ::  !(IO a)
                 , allCopies :: {-# UNPACK #-} !(IORef (Map ThreadId a)) }

mkTLS new = do
  v <- newIORef $! M.empty
  return $! TLS new v

getTLS TLS{mkNew,allCopies} = do
    tid  <- myThreadId
    peek <- readIORef allCopies
    case M.lookup tid peek of
      Just a  -> return a
      Nothing -> do
        a <- mkNew
        atomicModifyIORef' allCopies (\ mp -> (M.insert tid a mp, ()))
        return $! a

allTLS TLS{allCopies} = do
  mp <- readIORef allCopies
  return $! M.elems mp

forEachTLS_ tls fn = do
  ls <- allTLS tls
  forM_ ls fn

-- Nothing to do here... we haven't pinned anything.  Normal GC is fine.
freeTLS _ = return ()

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE BangPatterns #-}-- WARNING: This is not a full Haskell module, it is a snippet to #include...
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE CPP #-}-- | Make a new per-thread variable.  This guarantees that no two
-- threads that execute `getTLS` simultaneosly will receive the same
-- | This is the simplest implementation of thread-local storage using-- copy of the value.  Generally, to meet this guarantee there must be
-- GHC's built-in ThreadId capabilities.-- AT LEAST one copy of the TLS variable for each distinct OS thread
---- that calls `getAll`.  But this is a lower bound, and there may be
-- While the interface below is designed to match the other-- *more*.  In particular, there could be one per Haskell IO thread
-- rather than per OS thread.-- implementations of TLS in this package, the GHC implementation can
---- generaly be relied upon to keep a stable copy of the TLS variable
-- Thread safe.-- for each `ThreadId` that calls `getTLS`.  This may change in the
-- future, however!-- ^ Action for creating a single copy of the TLS variable.

module Data.TLS.GHC
-- | Fetch this thread's copy of the TLS variable.  Note that all TLS
-- values returned by this function may be immune to garbage collected, mkTLS
-- until `freeTLS` is called., getTLS
--  , allTLS
-- Thread safe., forEachTLS_
    , freeTLS
    ) where

import-- | After a TLS-based computation is complete, iterate through allControl.Monad
import-- the copies of the TLS variable which were used by all threads.Control.Exception (evaluate)
import--     Control.Concurrent
import-- NOT thread safe.Data.Map.Strict as M
import Data.IORef :: IO a
      -> IO (TLS a)






getTLS :: TLS a -> IO a






allTLS :: TLS a -> IO [a]

-- Module signature:
-- | Like `allTLS`, but apply a computation directly rather than--------------------------------------------------------------------------------
-- building a list.
forEachTLS_#include "TLS_Sig.hs":: TLS a -> (a -> IO ()) -> IO ()

-- | Release all copies of the TLS variable, across all threads.  This--------------------------------------------------------------------------------
-- does not guarantee the storage will be freed immediately, but it
-- | A thread-local variable of type `a`.-- guarantees that the storage can be reclaimed in the future.
freeTLS :: TLS a -> IO () TLS a = TLS { mkNew     ::  !(IO a)
                 , allCopies :: {-# UNPACK #-} !(IORef (Map ThreadId a)) }

mkTLS new = do
  v <- newIORef $! M.empty
  return $! TLS new v

getTLS TLS{mkNew,allCopies} = do
    tid  <- myThreadId
    peek <- readIORef allCopies
    case M.lookup tid peek of
      Just a  -> return a
      Nothing -> do

</pre>