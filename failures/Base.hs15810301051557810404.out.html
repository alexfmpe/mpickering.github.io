<a href="Base.hs12672485902051724831.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Base.hs18171295601131570933.out.html">next</a></br></br><pre>8c8
< 
---
> {-# OPTIONS -Wall -fno-warn-orphans #-}
10c10
< 
---
> module Codec.TPTP.Base where
18c18
< 
---
> -- Assume we are using the newest versions when using ghci without cabal
20d19
< import Control.Applicative
21d19
< import Control.Monad.Identity
22d19
< import Control.Monad.State
23d19
< import Data.Data
24d19
< import Data.Function
25d19
< import Data.Monoid hiding(All)
26d19
< import Data.Set as S hiding(fold)
27d19
< import Data.String
28d19
< import Prelude --hiding(concat,foldl,foldl1,foldr,foldr1)
29d19
< import Test.QuickCheck hiding ((.&.))
30d19
< import Data.Pointed
31d19
< import Data.Copointed
32c20
< #if !MIN_VERSION_transformers(0,4,0)
---
> import Codec.TPTP.QuickCheckControl.Applicative
32a21
> import Control.ApplicativeControl.Monad.Identity
32a22
> import Control.Monad.IdentityControl.Monad.State
32a23
> import Control.Monad.StateData.Data
32a24
> import Data.DataData.Function
32a25
> import Data.FunctionData.Monoid hiding(All)
32a26
> import Data.MonoidData.Set as hidingS hiding(All(fold)  )
32a27
> import Data.SetData.Stringas S hiding(fold)
32a28
> import Data.StringPrelude --hiding(concat,foldl,foldl1,foldr,foldr1)
32a29
> import PreludeTest.QuickCheck--hiding(concat,foldl,foldl1,foldr,foldr1)hiding ((.&.))
32a30
> import Test.QuickCheckData.Pointed    hiding ((.&.))
32a31
> import Data.PointedData.Copointed
32a32
> import#if !MIN_VERSION_transformers(0,4,0)Data.Copointed
41c41
< #if MIN_VERSION_base(4,7,0)
---
> deriving#if MIN_VERSION_base(4,7,0)instance Data a => Data (Identity a)
43c43
< #else
---
> deriving#else     instance Typeable Identity
48c48
< 
---
> -- * Basic undecorated formulae and terms
49a50
> type-- | Basic (undecorated) first-order formulaeFormula = F Identity
51d51
< 
52a53
> type-- | Basic (undecorated) termsTerm = T Identity
54d54
< 
56c56
< 
---
> -- * Formulae and terms decorated with state
57a58
> type-- | First-order formulae decorated with stateFormulaST s = F (State s)
59d59
< 
60a61
> type-- | Terms decorated with stateTermST s = T (State s)
62d62
< 
63a64
> type-- | First-order formulae decorated with commentsFormulaC = FormulaST [String]
65d65
< 
66a67
> type-- | Terms decorated with commentsTermC = TermST [String]
68d68
< 
70d69
< forgetFC :: FormulaC -> Formula
71d69
< forgetFC (F f) = F . return $
72d69
<   case evalState f [] of
73d69
<     BinOp f1 op f2       -> BinOp (forgetFC f1) op (forgetFC f2)
74d69
<     InfixPred t1 pred_ t2 -> InfixPred (forgetTC t1) pred_ (forgetTC t2)
75d69
<     PredApp aw ts        -> PredApp aw (fmap forgetTC ts)
76c70
<     Quant quant vs f_     -> Quant quant vs (forgetFC f_)
---
> forgetFC-- | Forget comments in formulae decorated with comments:: FormulaC -> Formula
76a71
> forgetFC ::(F FormulaCf) = F . ->return$
76a72
> forgetFCcase evalStateF f) = F .]returnof    $
76a73
>   caseBinOpf1 op f2 [] of -> BinOp (forgetFC f1) op (forgetFC f2)
76a74
>     BinOpInfixPred opt1f2pred_ t2->->BinOpInfixPredforgetFC(forgetTC) opt1(forgetFCpred_ (forgetTC)     t2)
76a75
>     InfixPredPredApp awt1tspred_ t2->PredAppaw (forgetTCfmap forgetTC) pred_ts)  (forgetTC t2)
76a76
>     PredAppQuant quant tsvs f_    ->->PredAppQuant quant (fmapvs (forgetTC ts)
76a77
>     Quant(:~:) quantf_    vs f_     -> Quant(:~:) quant(forgetFC (forgetFCf_)      f_)
78d78
< 
80d79
< forgetTC :: TermC -> Term
81d79
< forgetTC (T t) = T . return $
82d79
<   case evalState t [] of
83d79
<     Var v -> Var v
84d79
<     NumberLitTerm d -> NumberLitTerm d
85c80
<     DistinctObjectTerm s -> DistinctObjectTerm s
---
> forgetTC-- | Forget comments in terms decorated with comments:: TermC -> Term
85a81
> forgetTC ::(T TermCt) = T->. Termreturn $
85a82
> forgetTCcase evalStateT t) = T .]returnof    $
85a83
>   caseVarevalStatev -> Var t [] of
85a84
>     VarNumberLitTerm -> Var vd -> NumberLitTerm d
85a85
>     NumberLitTermDistinctObjectTerm -> NumberLitTerms -> DistinctObjectTerm         s
85a86
>     DistinctObjectTermFunApp aw ts -> FunApp ->aw(fmap forgetTC tss
88d88
< 
90d89
< --
91d89
< -- Important special case:
92d89
< --
93d89
< -- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@
94c90
< (.<=>.) :: Pointed c => (F c) -> (F c) -> F c
---
> ---- | Equivalence
94a91
> ---- Important special case:
94a92
> ---- Important special case:
94a93
> ---- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@
94a94
> (-- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@.<=>.) :: Pointed c => (F c) -> (F c) -> F c
94a95
> (.<=>..<=>.) ::y =Pointed(F . point =>) (FBinOp) -> (F(c:<=>:) ->)Fyc
97d97
< 
99c99
< (.=>.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | Implication.=>.) :: Pointed c => (F c) -> (F c) -> F c
99a100
> (.=>..=>.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):=>:->)F c
101d101
< 
103c103
< (.<=.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | Reverse implication.<=.) :: Pointed c => (F c) -> (F c) -> F c
103a104
> (.<=..<=.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):<=:->)F c
105d105
< 
107c107
< (.|.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | Disjunction/OR.|.) :: Pointed c => (F c) -> (F c) -> F c
107a108
> (.|..|.) ::yPointed= (F . cpoint=> (F$c)BinOp-> (Fxc):|:->)F cy
109d109
< 
111c111
< (.&.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | Conjunction/AND.&.) :: Pointed c => (F c) -> (F c) -> F c
111a112
> (.&..&.) ::yPointed= (F . cpoint=> (F$c)BinOp-> (Fxc):&:->)F cy
113d113
< 
115c115
< (.<~>.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | XOR.<~>.) :: Pointed c => (F c) -> (F c) -> F c
115a116
> (.<~>..<~>.) ::y =Pointed(F . point =>) (FBinOp) -> (F(c:<~>:) ->)Fyc
117d117
< 
119c119
< (.~|.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | NOR.~|.) :: Pointed c => (F c) -> (F c) -> F c
119a120
> (.~|..~|.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):~|:->)F c
123d123
< 
125c125
< (.~&.) :: Pointed c => (F c) -> (F c) -> F c
---
> (-- | NAND.~&.) :: Pointed c => (F c) -> (F c) -> F c
125a126
> (.~&..~&.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):~&:->)F c
128d128
< 
130c130
< (.~.) :: Pointed c => (F c) -> F c
---
> (-- | Negation.~.) :: Pointed c => (F c) -> F c
130a131
> (.~.) ::x =Pointed(F . point =>) (F(c:~:) ->) xF c
132d132
< 
134c134
< (.=.) :: Pointed c => (T c) -> (T c) -> F c
---
> (-- | Equality.=.) :: Pointed c => (T c) -> (T c) -> F c
134a135
> (.=..=.) ::y  Pointed= (F . cpoint=> (T$c)InfixPred-> (T c)x->(:=: c   y
136d136
< 
138c138
< (.!=.) :: Pointed c => (T c) -> (T c) -> F c
---
> (-- | Inequality.!=.) :: Pointed c => (T c) -> (T c) -> F c
138a139
> (.!=..!=.) ::y  Pointed= (F . point =>)(T cInfixPred) -> (T c) ->(:!=: c y
140d140
< 
142c142
< for_all :: Pointed c => [V] -> (F c) -> F c
---
> for_all-- | Universal quantification:: Pointed c => [V] -> (F c) -> F c
142a143
> for_all ::varsx = (Fc.=>pointV])->$ (QuantF c) ->AllFvars   x
144d144
< 
146c146
< exists :: Pointed c => [V] -> (F c) -> F c
---
> exists-- | Existential quantification:: Pointed c => [V] -> (F c) -> F c
146a147
> exists ::varsx = (Fc.=>pointV])->$ (QuantF c) ->Exists c vars x
148d148
< 
150c150
< pApp :: Pointed c => AtomicWord -> [T c] -> F c
---
> pApp-- | Predicate symbol application:: Pointed c => AtomicWord -> [T c] -> F c
150a151
> pApp ::x args= (Fc.=>point) $ PredApp-> [T cargs] -> F c
152d152
< 
154c154
< var :: Pointed c => V -> T c
---
> var-- | Variable:: Pointed c => V -> T c
154a155
> var ::= (PointedT . point)=>. VVar-> T c
156d156
< 
158c158
< fApp :: Pointed c => AtomicWord -> [T c] -> T c
---
> fApp-- | Function symbol application (constants are encoded as nullary functions):: Pointed c => AtomicWord -> [T c] -> T c
158a159
> fApp ::x args= (Tc.=>point) $ FunApp-> [Targs] -> T c
160d160
< 
162c162
< numberLitTerm :: Pointed c => Rational -> T c
---
> numberLitTerm-- | Number literal:: Pointed c => Rational -> T c
162a163
> numberLitTerm ::= (PointedT . point)=>. RationalNumberLitTerm-> T c
164d164
< 
166c166
< distinctObjectTerm :: Pointed c => String -> T c
---
> distinctObjectTerm-- | Double-quoted string literal, called /Distinct Object/ in TPTP's grammar:: Pointed c => String -> T c
166a167
> distinctObjectTerm ::= (PointedT . point)=>. StringDistinctObjectTerm-> T c
168d168
< 
169a170
> infixl 2  .<=>..|. , ,.~|. ,  .<=. ,  .<~>.
173d173
< 
175c175
< 
---
> -- * General decorated formulae and terms
177d176
< data Formula0 term formula =
178d176
<               BinOp formula BinOp formula -- ^ Binary connective application
179d176
<             | InfixPred term InfixPred term -- ^ Infix predicate application (equalities, inequalities)
180d176
<             | PredApp AtomicWord [term] -- ^ Predicate application
181d176
<             | Quant Quant [V] formula -- ^ Quantified formula
182c177
<             | (:~:) formula -- ^ Negation
---
> data-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations, e.g. monadic subformulae). If you don't need decorations, you can just use 'Formula' and the wrapped constructors above.Formula0 term formula =
182a178
> data Formula0 termBinOpformulaformula=BinOp formula -- ^ Binary connective application
182a179
>             | BinOpInfixPredtermBinOpInfixPredterm-- ^ Binary connective application-- ^ Infix predicate application (equalities, inequalities)
182a180
>             | InfixPredPredApp AtomicWord InfixPred[term]term-- ^ Predicate application-- ^ Infix predicate application (equalities, inequalities)
182a181
>             | PredAppQuant Quant[V] formulaterm]-- ^ Quantified formula-- ^ Predicate application
182a182
>             | Quant(:~:) QuantformulaV]-- ^ Negation -- ^ Quantified formula
182a183
>             | (deriving:~:) formula(Eq,Ord-- ^ Negation,Show,Read,Data,Typeable)
185d185
< 
187d186
< data Term0 term =
188d186
<             Var V -- ^ Variable
189d186
<           | NumberLitTerm Rational -- ^ Number literal
190d186
<           | DistinctObjectTerm String -- ^ Double-quoted item
191c187
<           | FunApp AtomicWord [term] -- ^ Function symbol application (constants are encoded as nullary functions)
---
> data-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations). If you don't need decorations, you can just use 'Term' and the wrapped constructors above.Term0 term =
191a188
> data Term0 termVar = -- ^ Variable
191a189
>           | VarNumberLitTerm -- ^ VariableRational -- ^ Number literal
191a190
>           | NumberLitTermDistinctObjectTermString-- ^ Number literal-- ^ Double-quoted item
191a191
>           | DistinctObjectTermFunApp AtomicWord [Stringterm] -- ^ Function symbol application (constants are encoded as nullary functions)-- ^ Double-quoted item
191a192
>           | FunAppderiving(Eq,Ord,Showterm,Read] -- ^ Function symbol application (constants are encoded as nullary functions),Data,Typeable)
198d198
< 
200d199
< data BinOp =
201d199
<     -- Please don't change the constructor names (the Show instance is significant)
202d199
<                (:<=>:)  -- ^ Equivalence
203d199
<             |  (:=>:)  -- ^ Implication
204d199
<             |  (:<=:)  -- ^ Reverse Implication
205d199
<             |  (:&:)  -- ^ AND
206d199
<             |  (:|:)  -- ^ OR
207d199
<             |  (:~&:)  -- ^ NAND
208d199
<             |  (:~|:)  -- ^ NOR
209c200
<             |  (:<~>:)  -- ^ XOR
---
> data-- | Binary formula connectivesBinOp =
209a201
> data-- Please don't change the constructor names (the Show instance is significant) =
209a202
>     -- Please don't change the constructor names (the Show instance is significant)(:<=>:)  -- ^ Equivalence
209a203
>             |  (:<=>::=>:)) -- ^ Implication-- ^ Equivalence
209a204
>             |  (:=>:)  -- ^ Implication-- ^ Reverse Implication
209a205
>             |  (:<=::&:)) -- ^ AND-- ^ Reverse Implication
209a206
>             |  (:&:)  -- ^ OR-- ^ AND
209a207
>             |  (:|::~&:)) -- ^ OR-- ^ NAND
209a208
>             |  (:~&:)  -- ^ NOR-- ^ NAND
209a209
>             |  (:~|::<~>:)) -- ^ NOR-- ^ XOR
209a210
>             | deriving:<~>:) (Eq-- ^ XOR,Ord,Show,Read,Data,Typeable,Enum,Bounded)
211d211
< 
213d212
< data InfixPred =
214d212
<     -- Please don't change the constructor names (the Show instance is significant)
215c213
<     (:=:) | (:!=:)
---
> data-- | /Term -> Term -> Formula/ infix connectivesInfixPred =
215a214
> data-- Please don't change the constructor names (the Show instance is significant) =
215a215
>     (-- Please don't change the constructor names (the Show instance is significant):=:) | (:!=:)
215a216
>     (:=:) | (deriving:!=:)   (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
217d217
< 
219c219
< data Quant = All | Exists
---
> data-- | Quantifier specificationQuant = All | Exists
219a220
> data Quant = Allderiving| Exists(Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
221d221
< 
223c223
< 
---
> -- * Formula Metadata
225c225
< type TPTP_Input = TPTP_Input_ Identity
---
> type-- | A line of a TPTP file: Annotated formula, comment or include statement.TPTP_Input = TPTP_Input_ Identity
225a226
> type{-
225a227
>     -- | Annotated formulae
225a228
>     AFormula {
225a229
>       name :: AtomicWord
225a230
>     , role :: Role
225a231
>     , formula :: Formula
225a232
>     , annotations :: Annotations
225a233
>     }
225a234
>     | Comment String
225a235
>     | Include FilePath [AtomicWord]
225a236
> 
225a237
>     deriving (Eq,Ord,Show,Read,Data,Typeable)
225a238
> -}    = TPTP_Input_ Identity
239d251
< 
240a253
> type-- | A line of a TPTP file: Annotated formula (with the comment string embbeded in the State monad ), comment or include statementTPTP_Input_C = TPTP_Input_ (State [String])
242d254
< 
244d255
< forgetTIC :: TPTP_Input_C -> TPTP_Input
245d255
< forgetTIC tic@(AFormula {}) = tic { formula = forgetFC (formula tic) }
246c256
< forgetTIC (Comment s) = Comment s
---
> forgetTIC-- | Forget comments in a line of a TPTP file decorated with comments:: TPTP_Input_C -> TPTP_Input
246a257
> forgetTIC ::ticTPTP_Input_C@(AFormula {}->) =TPTP_Inputtic { formula = forgetFC (formula tic) }
246a258
> forgetTIC tic(Comment@(AFormulas) = {Comment}) = tics { formula = forgetFC (formula tic) }
246a259
> forgetTIC (Comment s)aws= Comment) = Include   p aws
248d260
< 
250d261
< data TPTP_Input_ c =
251d261
<    -- | Annotated formulae
252d261
<    AFormula {
253d261
<      name :: AtomicWord
254d261
<    , role :: Role
255c262
<    , formula :: F c
---
> data-- | Generalized TPTP_InputTPTP_Input_ c =
255a263
> data-- | Annotated formulae c =
255a264
>    AFormula-- | Annotated formulae{
255a265
>    AFormulaname ::{AtomicWord
255a266
>    , name :: AtomicWordRole
255a267
>    , roleformula:: Role:: F c
255a268
>    , formulaannotations:: F:: Annotations
257d269
<    }
258c270
<    | Comment String
---
>    } Comment String
258a271
>    | Comment StringFilePath [AtomicWord]
261d273
< 
263c275
< deriving instance Ord (c (Formula0 (T c) (F c))) => Ord (TPTP_Input_ c)
---
> deriving instance EqOrd(cc(Formula0(Formula0(TTc))(FFc))))=>=>EqOrdTPTP_Input_(TPTP_Input_)c)
263a276
> deriving instance OrdShow(cc(Formula0(Formula0(TTc))(FFc))))=>=>OrdShowTPTP_Input_(TPTP_Input_)c)
267d279
< 
270d281
< deriving instance Typeable TPTP_Input_
271c282
< #else
---
> deriving instance (TypeableTypeableTPTP_Input_, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
271a283
> deriving#else     instance Typeable TPTP_Input_
278c290
< data Annotations = NoAnnotations | Annotations GTerm UsefulInfo
---
> data-- | Annotations about the formulas originAnnotations = NoAnnotations | Annotations GTerm UsefulInfo
278a291
> data Annotations =deriving(Eq,Ord|,AnnotationsShow,Read,Data,Typeable)
280d292
< 
282c294
< data UsefulInfo = NoUsefulInfo | UsefulInfo [GTerm]
---
> data-- | Misc annotationsUsefulInfo = NoUsefulInfo | UsefulInfo [GTerm]
282a295
> data UsefulInfo = NoUsefulInfoderiving (Eq,|Ord,Show,Read[GTermData,]Typeable)
284d296
< 
286c298
< newtype Role = Role { unrole :: String }
---
> newtype-- | Formula rolesRole = Role { unrole :: String }
286a299
> newtype Rolederiving= Role {(unroleEq,Ord,::Show,Read,}Data,Typeable)
289d301
< 
291d302
< data GData = GWord AtomicWord
292d302
<                  | GApp AtomicWord [GTerm]
293d302
<                  | GVar V
294d302
<                  | GNumber Rational
295d302
<                  | GDistinctObject String
296c303
<                  | GFormulaData String Formula
---
> data-- | Metadata (the /general_data/ rule in TPTP's grammar)GData = GWord AtomicWord
296a304
> data GData = GWord| AtomicWordGApp AtomicWord [GTerm]
296a305
>                  | GApp AtomicWordV          [GTerm]
296a306
>                  | GVarGNumber  Rational
296a307
>                  | GNumberGDistinctObjectString
296a308
>                  | GDistinctObjectGFormulaData StringFormula
296a309
>                  | GFormulaDataderiving (Eq,StringOrd,Show,Read,Data,Typeable)
298d310
< 
300d311
< data GTerm = ColonSep GData GTerm
301d311
<            | GTerm GData
302c312
<            | GList [GTerm]
---
> data-- | Metadata (the /general_term/ rule in TPTP's grammar)GTerm = ColonSep GData GTerm
302a313
> data GTerm = ColonSepGTerm GData GTerm
302a314
>            | GTerm GData[GTerm]
302a315
>            | GListderivingGTerm(Eq]Ord,Show,Read,Data,Typeable)
307d319
< 
309c321
< 
---
> -- * Gathering free Variables
310a323
> -- class FormulaOrTerm c a where--     elimFormulaOrTerm :: (F c -> r) -> (T c -> r) -> a -> r
312d324
< 
313a326
> --     elimFormulaOrTerm k _ x = k x-- instance FormulaOrTerm Identity Formula where
315d327
< 
316a329
> --     elimFormulaOrTerm _ k x = k x-- instance FormulaOrTerm Identity Term where
318d330
< 
320c332
<     -- | Obtain the free variables from a formula or term
---
> class-- | Obtain the free variables from a formula or term a where
320a333
>     freeVars-- | Obtain the free variables from a formula or term:: a -> Set V
322d334
< 
324d335
< univquant_free_vars :: Formula -> Formula
325d335
< univquant_free_vars cnf =
326d335
<     case S.toList (freeVars cnf) of
327c336
<       [] -> cnf
---
> univquant_free_vars-- | Universally quantify all free variables in the formula:: Formula -> Formula
327a337
> univquant_free_vars ::cnfFormula=      -> Formula
327a338
> univquant_free_varscase S.toList (freeVars =   cnf) of
327a339
>     case[] S.toList-> cnf   (freeVars cnf) of
327a340
>       [vars] ->->for_all vars cnf
329d341
< 
331d342
<     freeVars = foldF
332d342
<                freeVars
333d342
<                (\_ vars x -> S.difference (freeVars x) (S.fromList vars))
334c343
<                (\x _ y -> (mappend `on` freeVars) x y)
---
> instancefreeVars= foldF where
334a344
>     freeVars = foldFfreeVars
334a345
>                freeVars(\_ vars x -> S.difference (freeVars x) (S.fromList vars))
334a346
>                (\_ vars_ y -> ->(mappend`on` freeVarsfreeVars) x x) (S.fromList vars))
335a348
>                (\x _args ->->(mappendS.unions`on(fmap` freeVarsfreeVars) xargs) ))
337d349
< 
339d350
<     freeVars = foldT
340c351
<                (const mempty)
---
> instancefreeVars= foldT where
340a352
>     freeVars = foldT(const mempty)
342c354
<                S.singleton
---
>                (S.singletonconst mempty)
342a355
>                S.singleton(\_ args -> S.unions (fmap freeVars args))
345d357
< 
347c359
< 
---
> --- Have the Arbitrary instances in this module to avoid orphan instances
349d360
<     where arbitrary = frequency [(10,
350d360
<                                     do
351c361
<                                       x1 <- AtomicWord <$> arbLowerWord
---
> instancewhereArbitraryarbitraryTPTP_Input= frequency [(10,
351a362
>     where arbitrary = frequency [(10,do
351a363
>                                     dox1 <- AtomicWord <$> arbLowerWord
351a364
>                                       x1 <- AtomicWordarbitrary  <$> arbLowerWord
354c367
<                                       x4 <- arbitrary
---
>                                       x4return<- arbitrary(AFormula x1 x2 x3 x4))
356d368
< 
358d369
<                                     do
359d369
<                                       x1 <- arbPrintable
360c370
<                                       return (Comment ("% "++x1))
---
>                                   , (do1,
360a371
>                                     dox1 <- arbPrintable
360a372
>                                       x1return<- arbPrintable(Comment ("% "++x1))
360a373
>                                   )   return (Comment ("% "++x1))
362d374
< 
364c376
<                                          listOf arbitrary)
---
>                                   , (1, IncludelistOf `arbitraryfmap` arbLowerWord)          `ap`
364a377
>                                 ]        listOf arbitrary)
366d378
< 
367a380
> instancewhereArbitraryarbitraryFormula= fmap (F . point) arbitrary
369d381
< 
370a383
> instancewhereArbitraryarbitraryTerm= fmap (T . point) arbitrary
372d384
< 
374d385
<     where arbitrary = oneof [
375d385
<                               return NoAnnotations
376c386
<                             , Annotations `fmap` arbitrary `ap` arbitrary
---
> instancewhereArbitraryarbitraryAnnotations= oneof [
376a387
>     where arbitrary = oneof [ return NoAnnotations
376a388
>                             , returnAnnotations`fmap` arbitrary `ap` arbitrary
376a389
>                       ]     , Annotations `fmap` arbitrary `ap` arbitrary
378d390
< 
380d391
<     where arbitrary = oneof [
381d391
<                               return NoUsefulInfo
382d391
<                              , do
383d391
<                                 x1 <- arbitrary
384c392
<                                 return (UsefulInfo x1)
---
> instancewhereArbitraryarbitraryUsefulInfo= oneof [
384a393
>     where arbitrary = oneof [ return NoUsefulInfo
384a394
>                              ,returndo    NoUsefulInfo
384a395
>                              , dox1 <- arbitrary
384a396
>                                 x1return<- arbitrary(UsefulInfo x1)
384a397
>                       ]         return (UsefulInfo x1)
386d398
< 
387a400
> instancewhereArbitraryarbitraryRole= Role `fmap` arbLowerWord
390d402
< 
392c404
< 
---
> instance (Arbitrary a, Arbitrary b) => Arbitrary (Formula0 a b)
395c407
< 
---
>     where arbitrary = sized go
396a409
>            wherego 0 = flip PredApp [] `fmap` arbitrary
398d410
< 
400d411
<                 oneof [ do
401d411
<                                   ileft <- choose (0,i-1)
402d411
<                                   x1 <- resize ileft arbitrary
403d411
<                                   x2 <- arbitrary
404c412
<                                   x3 <- resize (i - 1 - ileft) arbitrary
---
>             go ioneof=    [ do
404a413
>                 oneof [ do        ileft <- choose (0,i-1)
404a414
>                                   ileftx1 <- <-resizeileft0,iarbitrary-1)
404a415
>                                   x1 <- resizearbitrary arbitrary
404a416
>                                   x2 <- arbitraryresize (i - 1 - ileft) arbitrary
404a417
>                                   x3return<- resize(BinOp(ix1-x2 -x3ileft)    ) arbitrary
406d418
< 
407a420
>                       , do        x1 <- arbitrary
410c423
<                                   x3 <- arbitrary
---
>                                   x3return<- arbitrary(InfixPred x1 x2 x3)
412d424
< 
414d425
<                                   x1 <- arbitrary
415c426
<                                   x2 <- argsFreq vector
---
>                       , do        x1 <- arbitrary
415a427
>                                   x1 <- arbitraryargsFreq vector
415a428
>                                   x2return<- argsFreq(PredAppvectorx1 x2)
417d429
< 
419d430
<                                x1 <- arbitrary
420d430
<                                x2 <- liftM2 (:) arbitrary (argsFreq (\nargs -> vectorOf nargs arbitrary))
421c431
<                                x3 <- resize (i-1) arbitrary
---
>                       , do     x1 <- arbitrary
421a432
>                                x1 <- arbitraryliftM2 (:) arbitrary (argsFreq (\nargs -> vectorOf nargs arbitrary))
421a433
>                                x2 <- liftM2 (:)1arbitrary) arbitraryargsFreq (\nargs -> vectorOf nargs arbitrary))
421a434
>                                x3return<- resize(Quant(ix1-1)x2arbitraryx3)
423d435
< 
425d436
<                                   x1 <- resize (i-1) arbitrary
426c437
<                                   return ((:~:) x1)
---
>                       , do        x1 <- resize (i-1) arbitrary
426a438
>                                   x1return<- resize((:~:)(ix1-1) arbitrary
426a439
>                       ]           return ((:~:) x1)
428d440
< 
429a442
> instancewhereArbitraryarbitraryBinOp= elements
431d443
< 
432a445
>                              [ (:<=>::=>:))
434c447
<                              , (:<=:)
---
>                              , (:<=::&:))
436c449
<                              , (:|:)
---
>                              , (:|::~&:))
438c451
<                              , (:~|:)
---
>                              , (:~|::<~>:))
441d453
< 
442a455
> instancewhereArbitraryarbitraryInfixPred= elements [ (:=:),(:!=:) ]
444d456
< 
445a458
> instancewhereArbitraryarbitraryQuant= elements [All,Exists]
447d459
< 
449c461
<     where arbitrary = sized go
---
> instancewhereArbitraryarbitrarya==>sizedgo    (Term0 a)
449a462
>     where arbitrarywhere    = sized go
452d464
< 
454c466
< 
---
>             go 0 = frequency [ (2,Var <$> arbitrary), (1,FunApp `fmap` arbitrary `ap` return[] ) ]
456d467
<                              do
457c468
<                               x1 <- arbitrary
---
>             go i = oneof [   do
457a469
>                              dox1 <- arbitrary
457a470
>                               x1return<- arbitrary(Var x1)
459d471
< 
461c473
< 
---
>                            , arbNum NumberLitTerm
464c476
<                               x1 <- arbPrintable
---
>                            , dox1 <- arbPrintable
464a477
>                               x1return<- arbPrintable(DistinctObjectTerm x1)
466d478
< 
468d479
<                               x1 <- arbitrary
469d479
<                               args <- argsFreq
470d479
<                                 (\nargs -> do
471d479
<                                    parti <- arbPartition nargs (i-1)
472c480
<                                    mapM (flip resize arbitrary) parti
---
>                            , dox1 <- arbitrary
472a481
>                               x1args<-<-argsFreq
472a482
>                               args(\nargs<- argsFreq-> do
472a483
>                                 (\nargsparti-><-doarbPartition nargs (i-1)
472a484
>                                    partimapM (<-flipresize arbitrary)(iparti-1)
472a485
>                                 )  mapM (flip resize arbitrary) parti
474d486
< 
475a488
>                            ]  return (FunApp x1 args)
477d489
< 
478a491
> instancewhereArbitraryarbitraryGData= sized go
480d492
< 
482c494
<                        go 0 = oneof [ fmap GWord arbitrary
---
>                   wherego 0 = oneof [ fmap GWord arbitrary
482a495
>                        go 0 = oneof [ fmap GWordGVar arbitrary
485d497
< 
487d498
<                            oneof
488c499
<                            [
---
>                        go ioneof=
488a500
>                            oneof[
488a501
>                            [GWord <$> arbitrary
490d502
< 
492d503
<                               x1 <- arbLowerWord
493d503
<                               args <- argsFreq
494d503
<                                          (\nargs -> do
495d503
<                                             parti <- arbPartition nargs (i-1)
496c504
<                                             mapM (flip resize arbitrary) parti
---
>                            ,dox1 <- arbLowerWord
496a505
>                               x1args<-<-argsFreq
496a506
>                               args <- argsFreq(\nargs -> do
496a507
>                                          (\nargsparti-><-doarbPartition nargs (i-1)
496a508
>                                             partimapM (<-flipresize arbitrary)(iparti-1)
496a509
>                                          ) `mapMsuchThatflip` (resize(/=) []arbitrary)        ) parti
498d510
< 
500c512
< 
---
>                               return (GApp (AtomicWord x1) args)
501a514
>                            ,GVararbNumGNumber
503d515
< 
504a517
>                            ,GDistinctObjectGFormulaData `fmap` arbPrintable((:) '$' `fmap` arbLowerWord) `ap` (sized (\n -> resize (n `div` 2) arbitrary))
509d521
< 
510a523
> instancewhereArbitraryarbitraryGTerm= sized go
512d524
< 
513a526
>               wherego 0 = fmap GTerm arbitrary
515d527
< 
517d528
<                     oneof [
518d528
<                             do
519d528
<                                   ileft <- choose(0,i-1)
520d528
<                                   x1 <- resize ileft arbitrary
521c529
<                                   x2 <- resize (i-1-ileft) arbitrary
---
>                 go ioneof=    [
521a530
>                     oneof [ do
521a531
>                             do    ileft <- choose(0,i-1)
521a532
>                                   ileftx1 <- <-resizeileft(0,i-arbitrary1)
521a533
>                                   x1 <- resize ileft(i-1-ileft) arbitrary
521a534
>                                   x2return<- resize(ColonSepi-1-x1ileftx2)) arbitrary
523d535
< 
525c537
<                                   x1 <- arbitrary
---
>                           , do    x1 <- arbitrary
525a538
>                                   x1return<- arbitrary(GTerm x1)
527d539
< 
529d540
<                                   args <- argsFreq
530d540
<                                            (\nargs -> do
531d540
<                                               parti <- arbPartition nargs (i-1)
532c541
<                                               mapM (flip resize arbitrary) parti
---
>                           , do    args <- argsFreq
532a542
>                                   args <- argsFreq(\nargs -> do
532a543
>                                            (\nargsparti-><-doarbPartition nargs (i-1)
532a544
>                                               partimapM (<-flipresize arbitrary)(iparti-1)
532a545
>                                            ) `mapMsuchThatflip` (resize/= []) arbitrary) parti
534d546
< 
535a548
>                        ]          return (GList args)
537d549
< 
539d550
< --
540d550
< -- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'
541c551
< newtype AtomicWord = AtomicWord String
---
> ---- | TPTP constant symbol\/predicate symbol\/function symbol identifiers (they are output in single quotes unless they are /lower_word/s).
541a552
> ---- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'
541a553
> newtype-- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'AtomicWord = AtomicWord String
541a554
> newtypederiving(Eq,Ord=,AtomicWordShow,Data,Typeable ,Read,Monoid,IsString)
543d555
< 
545d556
<     arbitrary = frequency [  (5, AtomicWord <$> arbLowerWord)
546c557
<                             ,(1, AtomicWord <$> arbPrintable)
---
> instancearbitrary= frequency[  (where5, AtomicWord <$> arbLowerWord)
546a558
>     arbitrary = frequency [ ,(5, AtomicWord <$> arbLowerWord)
546a559
>                           ] ,(1, AtomicWord <$> arbPrintable)
548d560
< 
550c562
< newtype V = V String
---
> newtype-- | Variable namesV = V String
550a563
> newtypederiving = V(StringEq,Ord,Show,Data,Typeable,Read,Monoid,IsString)
552d564
< 
553a566
> instancearbitrary= V <$> wherearbVar
555d567
< 
557c569
< 
---
> -- * Fixed-point style decorated formulae and terms
559d570
< --
560d570
< -- For example:
561d570
< --
562d570
< -- - @c = 'Identity'@: Plain formulae
563d570
< --
564d570
< -- - @c = 'Maybe'@: Formulae that may contain \"holes\"
565d570
< --
566c571
< -- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressions
---
> ---- | Formulae whose subexpressions are wrapped in the given type constructor @c@.
566a572
> ---- For example:
566a573
> ---- For example:
566a574
> ---- - @c = 'Identity'@: Plain formulae
566a575
> ---- - @c = 'Identity'@: Plain formulae
566a576
> ---- - @c = 'Maybe'@: Formulae that may contain \"holes\"
566a577
> ---- - @c = 'Maybe'@: Formulae that may contain \"holes\"
566a578
> ---- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressions
566a579
> newtype-- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressionsF c = F { runF :: c (Formula0 (T c) (F c)) }
568d580
< 
569a582
> newtype-- | Terms whose subterms are wrapped in the given type constructor @c@T c = T { runT :: c (Term0 (T c)) }
571d583
< 
575d586
< DI(Ord)
576d586
< DI(Show)
577d586
< DI(Read)
578c587
< 
---
> derivingDI(Ord)  instance (Eq (c (Term0 (T c)))) => Eq (T c); deriving instance (Eq (c (Formula0 (T c) (F c)))) => Eq (F c)
578a588
> derivingDI(Show) instance (Ord (c (Term0 (T c)))) => Ord (T c); deriving instance (Ord (c (Formula0 (T c) (F c)))) => Ord (F c)
578a589
> derivingDI(Read) instance (Show (c (Term0 (T c)))) => Show (T c); deriving instance (Show (c (Formula0 (T c) (F c)))) => Show (F c)
578a590
> deriving instance (Read (c (Term0 (T c)))) => Read (T c); deriving instance (Read (c (Formula0 (T c) (F c)))) => Read (F c)
580a593
> deriving instance Typeable F
582d594
< 
584d595
< deriving instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
585c596
< #else
---
> deriving instance (Typeable c, Data (c (Term0Formula0T c)))) =>(F Datac))))(T=>c)Data (F c)
585a597
> deriving#else     instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
648d659
< foldF kneg kquant kbinop kinfix kpredapp f = foldFormula0 kneg kquant kbinop kinfix kpredapp (unwrapF f)
649d659
< 
650d659
< -- | Eliminate terms
651d659
< foldT ::
652d659
<          (Copointed t) =>
653d659
<            (String -> r) -- ^ Handle string literal
654d659
<          -> (Rational -> r) -- ^ Handle number literal
655d659
<          -> (V -> r) -- ^ Handle variable
656d659
<          -> (AtomicWord -> [T t] -> r) -- ^ Handle function symbol application
657d659
<          -> (T t -> r) -- ^ Handle term
658d659
< foldT kdistinct knum kvar kfunapp t = foldTerm0 kdistinct knum kvar kfunapp (unwrapT t)
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, NoMonomorphismRestriction
  , StandaloneDeriving
  , TypeSynonymInstances, FlexibleInstances, FlexibleContexts
  , UndecidableInstances, DeriveDataTypeable, GeneralizedNewtypeDeriving
  , OverlappingInstances, ScopedTypeVariables
  #-}
{-# OPTIONS -Wall -fno-warn-orphans #-}

module Codec.TPTP.Base where

#ifndef MIN_VERSION_transformers
#define MIN_VERSION_transformers(a,b,c) 1
#endif
#ifndef MIN_VERSION_base
#define MIN_VERSION_base(a,b,c) 1
#endif
-- Assume we are using the newest versions when using ghci without cabal

import Codec.TPTP.QuickCheck
import Control.Applicative
import Control.Monad.Identity
import Control.Monad.State
import Data.Data
import Data.Function
import Data.Monoid hiding(All)
import Data.Set as S hiding(fold)
import Data.String
import Prelude --hiding(concat,foldl,foldl1,foldr,foldr1)
import Test.QuickCheck hiding ((.&.))
import Data.Pointed
import Data.Copointed
#if !MIN_VERSION_transformers(0,4,0)
import Data.Functor.Classes() -- Import Eq,Ord,Show,Read orphan instances for Data.Functor.Identity from transformers-compat package
#endif

#if !MIN_VERSION_base(4,7,0)
import Util
#endif

deriving instance Data a => Data (Identity a)
#if MIN_VERSION_base(4,7,0)
deriving instance Typeable Identity
#else
deriving instance Typeable1 Identity
#endif

-- * Basic undecorated formulae and terms

-- | Basic (undecorated) first-order formulae
type Formula = F Identity

-- | Basic (undecorated) terms
type Term = T Identity

-- * Formulae and terms decorated with state

-- | First-order formulae decorated with state
type FormulaST s = F (State s)

-- | Terms decorated with state
type TermST s = T (State s)

-- | First-order formulae decorated with comments
type FormulaC = FormulaST [String]

-- | Terms decorated with comments
type TermC = TermST [String]

-- | Forget comments in formulae decorated with comments
forgetFC :: FormulaC -> Formula
forgetFC (F f) = F . return $
  case evalState f [] of
    BinOp f1 op f2       -> BinOp (forgetFC f1) op (forgetFC f2)
    InfixPred t1 pred_ t2 -> InfixPred (forgetTC t1) pred_ (forgetTC t2)
    PredApp aw ts        -> PredApp aw (fmap forgetTC ts)
    Quant quant vs f_     -> Quant quant vs (forgetFC f_)
    (:~:) f_              -> (:~:) (forgetFC f_)

-- | Forget comments in terms decorated with comments
forgetTC :: TermC -> Term
forgetTC (T t) = T . return $
  case evalState t [] of
    Var v -> Var v
    NumberLitTerm d -> NumberLitTerm d
    DistinctObjectTerm s -> DistinctObjectTerm s
    FunApp aw ts -> FunApp aw (fmap forgetTC ts)


-- | Equivalence
--
-- Important special case:
--
-- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@
(.<=>.) :: Pointed c => (F c) -> (F c) -> F c
x .<=>. y = (F . point) $ BinOp  x (:<=>:) y


-- | Implication
(.=>.) :: Pointed c => (F c) -> (F c) -> F c
x .=>.  y = (F . point) $ BinOp  x (:=>:)  y

-- | Reverse implication
(.<=.) :: Pointed c => (F c) -> (F c) -> F c
x .<=.  y = (F . point) $ BinOp  x (:<=:)  y

-- | Disjunction/OR
(.|.) :: Pointed c => (F c) -> (F c) -> F c
x .|.   y = (F . point) $ BinOp  x (:|:)   y

-- | Conjunction/AND
(.&.) :: Pointed c => (F c) -> (F c) -> F c
x .&.   y = (F . point) $ BinOp  x (:&:)   y

-- | XOR
(.<~>.) :: Pointed c => (F c) -> (F c) -> F c
x .<~>. y = (F . point) $ BinOp  x (:<~>:) y

-- | NOR
(.~|.) :: Pointed c => (F c) -> (F c) -> F c
x .~|.  y = (F . point) $ BinOp  x (:~|:)  y



-- | NAND
(.~&.) :: Pointed c => (F c) -> (F c) -> F c
x .~&.  y = (F . point) $ BinOp  x (:~&:)  y


-- | Negation
(.~.) :: Pointed c => (F c) -> F c
(.~.) x = (F . point) $ (:~:) x

-- | Equality
(.=.) :: Pointed c => (T c) -> (T c) -> F c
x .=. y   = (F . point) $ InfixPred x (:=:)   y

-- | Inequality
(.!=.) :: Pointed c => (T c) -> (T c) -> F c
x .!=. y  = (F . point) $ InfixPred x (:!=:) y

-- | Universal quantification
for_all :: Pointed c => [V] -> (F c) -> F c
for_all vars x = (F . point) $ Quant All vars x

-- | Existential quantification
exists :: Pointed c => [V] -> (F c) -> F c
exists vars x = (F . point) $ Quant Exists vars x

-- | Predicate symbol application
pApp :: Pointed c => AtomicWord -> [T c] -> F c
pApp x args = (F . point) $ PredApp x args

-- | Variable
var :: Pointed c => V -> T c
var = (T . point) . Var

-- | Function symbol application (constants are encoded as nullary functions)
fApp :: Pointed c => AtomicWord -> [T c] -> T c
fApp x args = (T . point) $ FunApp x args

-- | Number literal
numberLitTerm :: Pointed c => Rational -> T c
numberLitTerm = (T . point) . NumberLitTerm

-- | Double-quoted string literal, called /Distinct Object/ in TPTP's grammar
distinctObjectTerm :: Pointed c => String -> T c
distinctObjectTerm = (T . point) . DistinctObjectTerm

infixl 2  .<=>. ,  .=>. ,  .<=. ,  .<~>.
infixl 3  .|. ,  .~|.
infixl 4  .&. ,  .~&.
infixl 5  .=. ,  .!=.

-- * General decorated formulae and terms

-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations, e.g. monadic subformulae). If you don't need decorations, you can just use 'Formula' and the wrapped constructors above.
data Formula0 term formula =
              BinOp formula BinOp formula -- ^ Binary connective application
            | InfixPred term InfixPred term -- ^ Infix predicate application (equalities, inequalities)
            | PredApp AtomicWord [term] -- ^ Predicate application
            | Quant Quant [V] formula -- ^ Quantified formula
            | (:~:) formula -- ^ Negation
              deriving (Eq,Ord,Show,Read,Data,Typeable)


-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations). If you don't need decorations, you can just use 'Term' and the wrapped constructors above.
data Term0 term =
            Var V -- ^ Variable
          | NumberLitTerm Rational -- ^ Number literal
          | DistinctObjectTerm String -- ^ Double-quoted item
          | FunApp AtomicWord [term] -- ^ Function symbol application (constants are encoded as nullary functions)
            deriving (Eq,Ord,Show,Read,Data,Typeable)






-- | Binary formula connectives
data BinOp =
    -- Please don't change the constructor names (the Show instance is significant)
               (:<=>:)  -- ^ Equivalence
            |  (:=>:)  -- ^ Implication
            |  (:<=:)  -- ^ Reverse Implication
            |  (:&:)  -- ^ AND
            |  (:|:)  -- ^ OR
            |  (:~&:)  -- ^ NAND
            |  (:~|:)  -- ^ NOR
            |  (:<~>:)  -- ^ XOR
              deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)

-- | /Term -> Term -> Formula/ infix connectives
data InfixPred =
    -- Please don't change the constructor names (the Show instance is significant)
    (:=:) | (:!=:)
            deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)

-- | Quantifier specification
data Quant = All | Exists
              deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)

-- * Formula Metadata

-- | A line of a TPTP file: Annotated formula, comment or include statement.
type TPTP_Input = TPTP_Input_ Identity
{-
    -- | Annotated formulae
    AFormula {
      name :: AtomicWord
    , role :: Role
    , formula :: Formula
    , annotations :: Annotations
    }
    | Comment String
    | Include FilePath [AtomicWord]

    deriving (Eq,Ord,Show,Read,Data,Typeable)
-}

-- | A line of a TPTP file: Annotated formula (with the comment string embbeded in the State monad ), comment or include statement
type TPTP_Input_C = TPTP_Input_ (State [String])

-- | Forget comments in a line of a TPTP file decorated with comments
forgetTIC :: TPTP_Input_C -> TPTP_Input
forgetTIC tic@(AFormula {}) = tic { formula = forgetFC (formula tic) }
forgetTIC (Comment s) = Comment s
forgetTIC (Include p aws) = Include p aws

-- | Generalized TPTP_Input
data TPTP_Input_ c =
   -- | Annotated formulae
   AFormula {
     name :: AtomicWord
   , role :: Role
   , formula :: F c
   , annotations :: Annotations
   }
   | Comment String
   | Include FilePath [AtomicWord]


deriving instance Eq (c (Formula0 (T c) (F c))) => Eq (TPTP_Input_ c)
deriving instance Ord (c (Formula0 (T c) (F c))) => Ord (TPTP_Input_ c)
deriving instance Show (c (Formula0 (T c) (F c))) => Show (TPTP_Input_ c)
deriving instance Read (c (Formula0 (T c) (F c))) => Read (TPTP_Input_ c)


#if MIN_VERSION_base(4,7,0)
deriving instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
deriving instance Typeable TPTP_Input_
#else
deriving instance (Typeable1 c, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
instance Typeable1 c => Typeable (TPTP_Input_ c) where
  typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "TPTP_Input_"
#endif

-- | Annotations about the formulas origin
data Annotations = NoAnnotations | Annotations GTerm UsefulInfo
                  deriving (Eq,Ord,Show,Read,Data,Typeable)

-- | Misc annotations
data UsefulInfo = NoUsefulInfo | UsefulInfo [GTerm]
                  deriving (Eq,Ord,Show,Read,Data,Typeable)

-- | Formula roles
newtype Role = Role { unrole :: String }
            deriving (Eq,Ord,Show,Read,Data,Typeable)


-- | Metadata (the /general_data/ rule in TPTP's grammar)
data GData = GWord AtomicWord
                 | GApp AtomicWord [GTerm]
                 | GVar V
                 | GNumber Rational
                 | GDistinctObject String
                 | GFormulaData String Formula
                   deriving (Eq,Ord,Show,Read,Data,Typeable)

-- | Metadata (the /general_term/ rule in TPTP's grammar)
data GTerm = ColonSep GData GTerm
           | GTerm GData
           | GList [GTerm]
             deriving (Eq,Ord,Show,Read,Data,Typeable)




-- * Gathering free Variables

-- class FormulaOrTerm c a where
--     elimFormulaOrTerm :: (F c -> r) -> (T c -> r) -> a -> r

-- instance FormulaOrTerm Identity Formula where
--     elimFormulaOrTerm k _ x = k x

-- instance FormulaOrTerm Identity Term where
--     elimFormulaOrTerm _ k x = k x

class FreeVars a where
    -- | Obtain the free variables from a formula or term
    freeVars :: a -> Set V

-- | Universally quantify all free variables in the formula
univquant_free_vars :: Formula -> Formula
univquant_free_vars cnf =
    case S.toList (freeVars cnf) of
      [] -> cnf
      vars -> for_all vars cnf

instance FreeVars Formula where
    freeVars = foldF
               freeVars
               (\_ vars x -> S.difference (freeVars x) (S.fromList vars))
               (\x _ y -> (mappend `on` freeVars) x y)
               (\x _ y -> (mappend `on` freeVars) x y)
               (\_ args -> S.unions (fmap freeVars args))

instance FreeVars Term where
    freeVars = foldT
               (const mempty)
               (const mempty)
               S.singleton
               (\_ args -> S.unions (fmap freeVars args))


--- Have the Arbitrary instances in this module to avoid orphan instances

instance Arbitrary TPTP_Input
    where arbitrary = frequency [(10,
                                    do
                                      x1 <- AtomicWord <$> arbLowerWord
                                      x2 <- arbitrary
                                      x3 <- arbitrary
                                      x4 <- arbitrary
                                      return (AFormula x1 x2 x3 x4))

                                  , (1,
                                    do
                                      x1 <- arbPrintable
                                      return (Comment ("% "++x1))
                                  )

                                  , (1, Include `fmap` arbLowerWord `ap`
                                         listOf arbitrary)
                                ]

instance Arbitrary Formula
    where arbitrary = fmap (F . point) arbitrary

instance Arbitrary Term
    where arbitrary = fmap (T . point) arbitrary

instance Arbitrary Annotations
    where arbitrary = oneof [
                              return NoAnnotations
                            , Annotations `fmap` arbitrary `ap` arbitrary
                      ]

instance Arbitrary UsefulInfo
    where arbitrary = oneof [
                              return NoUsefulInfo
                             , do
                                x1 <- arbitrary
                                return (UsefulInfo x1)
                      ]

instance Arbitrary Role
    where arbitrary = Role `fmap` arbLowerWord


instance (Arbitrary a, Arbitrary b) => Arbitrary (Formula0 a b)


    where arbitrary = sized go

           where
            go 0 = flip PredApp [] `fmap` arbitrary

            go i =
                oneof [ do
                                  ileft <- choose (0,i-1)
                                  x1 <- resize ileft arbitrary
                                  x2 <- arbitrary
                                  x3 <- resize (i - 1 - ileft) arbitrary
                                  return (BinOp x1 x2 x3)

                      , do
                                  x1 <- arbitrary
                                  x2 <- arbitrary
                                  x3 <- arbitrary
                                  return (InfixPred x1 x2 x3)

                      , do
                                  x1 <- arbitrary
                                  x2 <- argsFreq vector
                                  return (PredApp x1 x2)

                      , do
                               x1 <- arbitrary
                               x2 <- liftM2 (:) arbitrary (argsFreq (\nargs -> vectorOf nargs arbitrary))
                               x3 <- resize (i-1) arbitrary
                               return (Quant x1 x2 x3)

                      , do
                                  x1 <- resize (i-1) arbitrary
                                  return ((:~:) x1)
                      ]

instance Arbitrary BinOp
    where arbitrary = elements

                             [ (:<=>:)
                             , (:=>:)
                             , (:<=:)
                             , (:&:)
                             , (:|:)
                             , (:~&:)
                             , (:~|:)
                             , (:<~>:)
                             ]

instance Arbitrary InfixPred
    where arbitrary = elements [ (:=:),(:!=:) ]

instance Arbitrary Quant
    where arbitrary = elements [All,Exists]

instance Arbitrary a => Arbitrary (Term0 a)
    where arbitrary = sized go
           where


            go 0 = frequency [ (2,Var <$> arbitrary), (1,FunApp `fmap` arbitrary `ap` return[] ) ]

            go i = oneof [
                             do
                              x1 <- arbitrary
                              return (Var x1)

                           , arbNum NumberLitTerm


                           , do
                              x1 <- arbPrintable
                              return (DistinctObjectTerm x1)

                           , do
                              x1 <- arbitrary
                              args <- argsFreq
                                (\nargs -> do
                                   parti <- arbPartition nargs (i-1)
                                   mapM (flip resize arbitrary) parti
                                )

                              return (FunApp x1 args)
                           ]

instance Arbitrary GData
    where arbitrary = sized go

                  where
                       go 0 = oneof [ fmap GWord arbitrary
                                    , fmap GVar arbitrary
                                    ]

                       go i =
                           oneof
                           [
                            GWord <$> arbitrary

                           ,do
                              x1 <- arbLowerWord
                              args <- argsFreq
                                         (\nargs -> do
                                            parti <- arbPartition nargs (i-1)
                                            mapM (flip resize arbitrary) parti
                                         ) `suchThat` ((/=) [])

                              return (GApp (AtomicWord x1) args)

                           ,GVar <$> arbitrary
                           ,arbNum GNumber

                           ,GDistinctObject <$> arbPrintable
                           ,GFormulaData `fmap` ((:) '$' `fmap` arbLowerWord) `ap` (sized (\n -> resize (n `div` 2) arbitrary))
                           ]



instance Arbitrary GTerm
    where arbitrary = sized go

              where
                go 0 = fmap GTerm arbitrary

                go i =
                    oneof [
                            do
                                  ileft <- choose(0,i-1)
                                  x1 <- resize ileft arbitrary
                                  x2 <- resize (i-1-ileft) arbitrary
                                  return (ColonSep x1 x2)

                          , do
                                  x1 <- arbitrary
                                  return (GTerm x1)

                          , do
                                  args <- argsFreq
                                           (\nargs -> do
                                              parti <- arbPartition nargs (i-1)
                                              mapM (flip resize arbitrary) parti
                                           ) `suchThat` (/= [])

                                  return (GList args)
                       ]

-- | TPTP constant symbol\/predicate symbol\/function symbol identifiers (they are output in single quotes unless they are /lower_word/s).
--
-- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'
newtype AtomicWord = AtomicWord String
    deriving (Eq,Ord,Show,Data,Typeable,Read,Monoid,IsString)

instance Arbitrary AtomicWord where
    arbitrary = frequency [  (5, AtomicWord <$> arbLowerWord)
                            ,(1, AtomicWord <$> arbPrintable)
                          ]

-- | Variable names
newtype V = V String
    deriving (Eq,Ord,Show,Data,Typeable,Read,Monoid,IsString)

instance Arbitrary V where
    arbitrary = V <$> arbVar

-- * Fixed-point style decorated formulae and terms

-- | Formulae whose subexpressions are wrapped in the given type constructor @c@.
--
-- For example:
--
-- - @c = 'Identity'@: Plain formulae
--
-- - @c = 'Maybe'@: Formulae that may contain \"holes\"
--
-- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressions
newtype F c = F { runF :: c (Formula0 (T c) (F c)) }

-- | Terms whose subterms are wrapped in the given type constructor @c@
newtype T c = T { runT :: c (Term0 (T c)) }

#define DI(X) deriving instance (X (c (Term0 (T c)))) => X (T c); deriving instance (X (c (Formula0 (T c) (F c)))) => X (F c)

DI(Eq)
DI(Ord)
DI(Show)
DI(Read)

#if MIN_VERSION_base(4,7,0)
deriving instance Typeable F
deriving instance Typeable T

deriving instance (Typeable c, Data (c (Term0 (T c)))) => Data (T c)
deriving instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
#else
instance Typeable1 c => Typeable (F c) where
    typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "F"

instance Typeable1 c => Typeable (T c) where
    typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "T"

deriving instance (Typeable1 c, Data (c (Term0 (T c)))) => Data (T c)
deriving instance (Typeable1 c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
#endif

-- * Utility functions

unwrapF ::
            (Copointed t) =>
            F t -> Formula0 (T t) (F t)
unwrapF (F x) = copoint x
unwrapT ::
            (Copointed t) =>
            T t -> Term0 (T t)
unwrapT (T x) = copoint x

foldFormula0 ::
                  (f -> r)
                -> (Quant -> [V] -> f -> r)
                -> (f -> BinOp -> f -> r)
                -> (t -> InfixPred -> t -> r)
                -> (AtomicWord -> [t] -> r)
                -> Formula0 t f
                -> r
foldFormula0 kneg kquant kbinop kinfix kpredapp f =
    case f of
      (:~:) x -> kneg x
      Quant x y z -> kquant x y z
      BinOp x y z -> kbinop x y z
      InfixPred x y z -> kinfix x y z
      PredApp x y -> kpredapp x y

foldTerm0 ::
               (String -> r)
             -> (Rational -> r)
             -> (V -> r)
             -> (AtomicWord -> [t] -> r)
             -> Term0 t
             -> r
foldTerm0 kdistinct knum kvar kfunapp t =
    case t of
      DistinctObjectTerm x -> kdistinct x
      NumberLitTerm x -> knum x
      Var x -> kvar x
      FunApp x y -> kfunapp x y


-- | Eliminate formulae
foldF ::
         (Copointed t) =>
           (F t -> r) -- ^ Handle negation
         -> (Quant -> [V] -> F t -> r) -- ^ Handle quantification
         -> (F t -> BinOp -> F t -> r) -- ^ Handle binary op
         -> (T t -> InfixPred -> T t -> r) -- ^ Handle equality/inequality
         -> (AtomicWord -> [T t] -> r) -- ^ Handle predicate symbol application
         -> (F t -> r) -- ^ Handle formula

foldF kneg kquant kbinop kinfix kpredapp f = foldFormula0 kneg kquant kbinop kinfix kpredapp (unwrapF f)

-- | Eliminate terms
foldT ::
         (Copointed t) =>
           (String -> r) -- ^ Handle string literal
         -> (Rational -> r) -- ^ Handle number literal
         -> (V -> r) -- ^ Handle variable
         -> (AtomicWord -> [T t] -> r) -- ^ Handle function symbol application
         -> (T t -> r) -- ^ Handle term
foldT kdistinct knum kvar kfunapp t = foldTerm0 kdistinct knum kvar kfunapp (unwrapT t)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, NoMonomorphismRestriction
  , StandaloneDeriving
  , TypeSynonymInstances, FlexibleInstances, FlexibleContexts
  , UndecidableInstances, DeriveDataTypeable, GeneralizedNewtypeDeriving
  , OverlappingInstances, ScopedTypeVariables
  #-}
{-# OPTIONS -Wall -fno-warn-orphans #-}
{-# OPTIONS -Wall -fno-warn-orphans #-}
module Codec.TPTP.Base where
module Codec.TPTP.Base where
#ifndef MIN_VERSION_transformers
#define MIN_VERSION_transformers(a,b,c) 1
#endif
#ifndef MIN_VERSION_base
#define MIN_VERSION_base(a,b,c) 1
#endif
-- Assume we are using the newest versions when using ghci without cabal
-- Assume we are using the newest versions when using ghci without cabal
import Codec.TPTP.QuickCheck
import Codec.TPTP.QuickCheckControl.Applicative
import Control.ApplicativeControl.Monad.Identity
import Control.Monad.IdentityControl.Monad.State
import Control.Monad.StateData.Data
import Data.DataData.Function
import Data.FunctionData.Monoid hiding(All)
import Data.MonoidData.Set as hidingS hiding(All(fold)  )
import Data.SetData.Stringas S hiding(fold)
import Data.StringPrelude --hiding(concat,foldl,foldl1,foldr,foldr1)
import PreludeTest.QuickCheck--hiding(concat,foldl,foldl1,foldr,foldr1)hiding ((.&.))
import Test.QuickCheckData.Pointed    hiding ((.&.))
import Data.PointedData.Copointed
import#if !MIN_VERSION_transformers(0,4,0)Data.Copointed
import Data.Functor.Classes() -- Import Eq,Ord,Show,Read orphan instances for Data.Functor.Identity from transformers-compat package
#endif

#if !MIN_VERSION_base(4,7,0)
import Util
#endif

deriving instance Data a => Data (Identity a)
deriving#if MIN_VERSION_base(4,7,0)instance Data a => Data (Identity a)
deriving instance Typeable Identity
deriving#else     instance Typeable Identity
deriving instance Typeable1 Identity
#endif

-- * Basic undecorated formulae and terms
-- * Basic undecorated formulae and terms
-- | Basic (undecorated) first-order formulae
type-- | Basic (undecorated) first-order formulaeFormula = F Identity
type Formula = F Identity
-- | Basic (undecorated) terms
type-- | Basic (undecorated) termsTerm = T Identity
type Term = T Identity
-- * Formulae and terms decorated with state
-- * Formulae and terms decorated with state
-- | First-order formulae decorated with state
type-- | First-order formulae decorated with stateFormulaST s = F (State s)
type FormulaST s = F (State s)
-- | Terms decorated with state
type-- | Terms decorated with stateTermST s = T (State s)
type TermST s = T (State s)
-- | First-order formulae decorated with comments
type-- | First-order formulae decorated with commentsFormulaC = FormulaST [String]
type FormulaC = FormulaST [String]
-- | Terms decorated with comments
type-- | Terms decorated with commentsTermC = TermST [String]
type TermC = TermST [String]
-- | Forget comments in formulae decorated with comments
forgetFC-- | Forget comments in formulae decorated with comments:: FormulaC -> Formula
forgetFC ::(F FormulaCf) = F . ->return$
forgetFCcase evalStateF f) = F .]returnof    $
  caseBinOpf1 op f2 [] of -> BinOp (forgetFC f1) op (forgetFC f2)
    BinOpInfixPred opt1f2pred_ t2->->BinOpInfixPredforgetFC(forgetTC) opt1(forgetFCpred_ (forgetTC)     t2)
    InfixPredPredApp awt1tspred_ t2->PredAppaw (forgetTCfmap forgetTC) pred_ts)  (forgetTC t2)
    PredAppQuant quant tsvs f_    ->->PredAppQuant quant (fmapvs (forgetTC ts)
    Quant(:~:) quantf_    vs f_     -> Quant(:~:) quant(forgetFC (forgetFCf_)      f_)
    (:~:) f_              -> (:~:) (forgetFC f_)
-- | Forget comments in terms decorated with comments
forgetTC-- | Forget comments in terms decorated with comments:: TermC -> Term
forgetTC ::(T TermCt) = T->. Termreturn $
forgetTCcase evalStateT t) = T .]returnof    $
  caseVarevalStatev -> Var t [] of
    VarNumberLitTerm -> Var vd -> NumberLitTerm d
    NumberLitTermDistinctObjectTerm -> NumberLitTerms -> DistinctObjectTerm         s
    DistinctObjectTermFunApp aw ts -> FunApp ->aw(fmap forgetTC tss
    FunApp aw ts -> FunApp aw (fmap forgetTC ts)

-- | Equivalence
---- | Equivalence
---- Important special case:
---- Important special case:
---- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@
(-- @\(\.\<\=\>\.\) :: 'Formula' -> 'Formula' -> 'Formula'@.<=>.) :: Pointed c => (F c) -> (F c) -> F c
(.<=>..<=>.) ::y =Pointed(F . point =>) (FBinOp) -> (F(c:<=>:) ->)Fyc
x .<=>. y = (F . point) $ BinOp  x (:<=>:) y

-- | Implication
(-- | Implication.=>.) :: Pointed c => (F c) -> (F c) -> F c
(.=>..=>.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):=>:->)F c
x .=>.  y = (F . point) $ BinOp  x (:=>:)  y
-- | Reverse implication
(-- | Reverse implication.<=.) :: Pointed c => (F c) -> (F c) -> F c
(.<=..<=.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):<=:->)F c
x .<=.  y = (F . point) $ BinOp  x (:<=:)  y
-- | Disjunction/OR
(-- | Disjunction/OR.|.) :: Pointed c => (F c) -> (F c) -> F c
(.|..|.) ::yPointed= (F . cpoint=> (F$c)BinOp-> (Fxc):|:->)F cy
x .|.   y = (F . point) $ BinOp  x (:|:)   y
-- | Conjunction/AND
(-- | Conjunction/AND.&.) :: Pointed c => (F c) -> (F c) -> F c
(.&..&.) ::yPointed= (F . cpoint=> (F$c)BinOp-> (Fxc):&:->)F cy
x .&.   y = (F . point) $ BinOp  x (:&:)   y
-- | XOR
(-- | XOR.<~>.) :: Pointed c => (F c) -> (F c) -> F c
(.<~>..<~>.) ::y =Pointed(F . point =>) (FBinOp) -> (F(c:<~>:) ->)Fyc
x .<~>. y = (F . point) $ BinOp  x (:<~>:) y
-- | NOR
(-- | NOR.~|.) :: Pointed c => (F c) -> (F c) -> F c
(.~|..~|.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):~|:->)F c
x .~|.  y = (F . point) $ BinOp  x (:~|:)  y


-- | NAND
(-- | NAND.~&.) :: Pointed c => (F c) -> (F c) -> F c
(.~&..~&.) ::y Pointed= (F . point =>)(F cBinOp) -> (F c):~&:->)F c
x .~&.  y = (F . point) $ BinOp  x (:~&:)  y

-- | Negation
(-- | Negation.~.) :: Pointed c => (F c) -> F c
(.~.) ::x =Pointed(F . point =>) (F(c:~:) ->) xF c
(.~.) x = (F . point) $ (:~:) x
-- | Equality
(-- | Equality.=.) :: Pointed c => (T c) -> (T c) -> F c
(.=..=.) ::y  Pointed= (F . cpoint=> (T$c)InfixPred-> (T c)x->(:=: c   y
x .=. y   = (F . point) $ InfixPred x (:=:)   y
-- | Inequality
(-- | Inequality.!=.) :: Pointed c => (T c) -> (T c) -> F c
(.!=..!=.) ::y  Pointed= (F . point =>)(T cInfixPred) -> (T c) ->(:!=: c y
x .!=. y  = (F . point) $ InfixPred x (:!=:) y
-- | Universal quantification
for_all-- | Universal quantification:: Pointed c => [V] -> (F c) -> F c
for_all ::varsx = (Fc.=>pointV])->$ (QuantF c) ->AllFvars   x
for_all vars x = (F . point) $ Quant All vars x
-- | Existential quantification
exists-- | Existential quantification:: Pointed c => [V] -> (F c) -> F c
exists ::varsx = (Fc.=>pointV])->$ (QuantF c) ->Exists c vars x
exists vars x = (F . point) $ Quant Exists vars x
-- | Predicate symbol application
pApp-- | Predicate symbol application:: Pointed c => AtomicWord -> [T c] -> F c
pApp ::x args= (Fc.=>point) $ PredApp-> [T cargs] -> F c
pApp x args = (F . point) $ PredApp x args
-- | Variable
var-- | Variable:: Pointed c => V -> T c
var ::= (PointedT . point)=>. VVar-> T c
var = (T . point) . Var
-- | Function symbol application (constants are encoded as nullary functions)
fApp-- | Function symbol application (constants are encoded as nullary functions):: Pointed c => AtomicWord -> [T c] -> T c
fApp ::x args= (Tc.=>point) $ FunApp-> [Targs] -> T c
fApp x args = (T . point) $ FunApp x args
-- | Number literal
numberLitTerm-- | Number literal:: Pointed c => Rational -> T c
numberLitTerm ::= (PointedT . point)=>. RationalNumberLitTerm-> T c
numberLitTerm = (T . point) . NumberLitTerm
-- | Double-quoted string literal, called /Distinct Object/ in TPTP's grammar
distinctObjectTerm-- | Double-quoted string literal, called /Distinct Object/ in TPTP's grammar:: Pointed c => String -> T c
distinctObjectTerm ::= (PointedT . point)=>. StringDistinctObjectTerm-> T c
distinctObjectTerm = (T . point) . DistinctObjectTerm
infixl 2  .<=>. ,  .=>. ,  .<=. ,  .<~>.
infixl 2  .<=>..|. , ,.~|. ,  .<=. ,  .<~>.
infixl 3  .|. ,  .~|.
infixl 4  .&. ,  .~&.
infixl 5  .=. ,  .!=.
-- * General decorated formulae and terms
-- * General decorated formulae and terms
-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations, e.g. monadic subformulae). If you don't need decorations, you can just use 'Formula' and the wrapped constructors above.
data-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations, e.g. monadic subformulae). If you don't need decorations, you can just use 'Formula' and the wrapped constructors above.Formula0 term formula =
data Formula0 termBinOpformulaformula=BinOp formula -- ^ Binary connective application
            | BinOpInfixPredtermBinOpInfixPredterm-- ^ Binary connective application-- ^ Infix predicate application (equalities, inequalities)
            | InfixPredPredApp AtomicWord InfixPred[term]term-- ^ Predicate application-- ^ Infix predicate application (equalities, inequalities)
            | PredAppQuant Quant[V] formulaterm]-- ^ Quantified formula-- ^ Predicate application
            | Quant(:~:) QuantformulaV]-- ^ Negation -- ^ Quantified formula
            | (deriving:~:) formula(Eq,Ord-- ^ Negation,Show,Read,Data,Typeable)
              deriving (Eq,Ord,Show,Read,Data,Typeable)

-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations). If you don't need decorations, you can just use 'Term' and the wrapped constructors above.
data-- | See <http://haskell.org/haskellwiki/Indirect_composite> for the point of the type parameters (they allow for future decorations). If you don't need decorations, you can just use 'Term' and the wrapped constructors above.Term0 term =
data Term0 termVar = -- ^ Variable
          | VarNumberLitTerm -- ^ VariableRational -- ^ Number literal
          | NumberLitTermDistinctObjectTermString-- ^ Number literal-- ^ Double-quoted item
          | DistinctObjectTermFunApp AtomicWord [Stringterm] -- ^ Function symbol application (constants are encoded as nullary functions)-- ^ Double-quoted item
          | FunAppderiving(Eq,Ord,Showterm,Read] -- ^ Function symbol application (constants are encoded as nullary functions),Data,Typeable)
            deriving (Eq,Ord,Show,Read,Data,Typeable)





-- | Binary formula connectives
data-- | Binary formula connectivesBinOp =
data-- Please don't change the constructor names (the Show instance is significant) =
    -- Please don't change the constructor names (the Show instance is significant)(:<=>:)  -- ^ Equivalence
            |  (:<=>::=>:)) -- ^ Implication-- ^ Equivalence
            |  (:=>:)  -- ^ Implication-- ^ Reverse Implication
            |  (:<=::&:)) -- ^ AND-- ^ Reverse Implication
            |  (:&:)  -- ^ OR-- ^ AND
            |  (:|::~&:)) -- ^ OR-- ^ NAND
            |  (:~&:)  -- ^ NOR-- ^ NAND
            |  (:~|::<~>:)) -- ^ NOR-- ^ XOR
            | deriving:<~>:) (Eq-- ^ XOR,Ord,Show,Read,Data,Typeable,Enum,Bounded)
              deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
-- | /Term -> Term -> Formula/ infix connectives
data-- | /Term -> Term -> Formula/ infix connectivesInfixPred =
data-- Please don't change the constructor names (the Show instance is significant) =
    (-- Please don't change the constructor names (the Show instance is significant):=:) | (:!=:)
    (:=:) | (deriving:!=:)   (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
            deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
-- | Quantifier specification
data-- | Quantifier specificationQuant = All | Exists
data Quant = Allderiving| Exists(Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
              deriving (Eq,Ord,Show,Read,Data,Typeable,Enum,Bounded)
-- * Formula Metadata
-- * Formula Metadata
-- | A line of a TPTP file: Annotated formula, comment or include statement.
type-- | A line of a TPTP file: Annotated formula, comment or include statement.TPTP_Input = TPTP_Input_ Identity
type{-
    -- | Annotated formulae
    AFormula {
      name :: AtomicWord
    , role :: Role
    , formula :: Formula
    , annotations :: Annotations
    }
    | Comment String
    | Include FilePath [AtomicWord]

    deriving (Eq,Ord,Show,Read,Data,Typeable)
-}    = TPTP_Input_ Identity
{-
    -- | Annotated formulae
    AFormula {
      name :: AtomicWord
    , role :: Role
    , formula :: Formula
    , annotations :: Annotations
    }
    | Comment String
    | Include FilePath [AtomicWord]

    deriving (Eq,Ord,Show,Read,Data,Typeable)
-}
-- | A line of a TPTP file: Annotated formula (with the comment string embbeded in the State monad ), comment or include statement
type-- | A line of a TPTP file: Annotated formula (with the comment string embbeded in the State monad ), comment or include statementTPTP_Input_C = TPTP_Input_ (State [String])
type TPTP_Input_C = TPTP_Input_ (State [String])
-- | Forget comments in a line of a TPTP file decorated with comments
forgetTIC-- | Forget comments in a line of a TPTP file decorated with comments:: TPTP_Input_C -> TPTP_Input
forgetTIC ::ticTPTP_Input_C@(AFormula {}->) =TPTP_Inputtic { formula = forgetFC (formula tic) }
forgetTIC tic(Comment@(AFormulas) = {Comment}) = tics { formula = forgetFC (formula tic) }
forgetTIC (Comment s)aws= Comment) = Include   p aws
forgetTIC (Include p aws) = Include p aws
-- | Generalized TPTP_Input
data-- | Generalized TPTP_InputTPTP_Input_ c =
data-- | Annotated formulae c =
   AFormula-- | Annotated formulae{
   AFormulaname ::{AtomicWord
   , name :: AtomicWordRole
   , roleformula:: Role:: F c
   , formulaannotations:: F:: Annotations
   , annotations :: Annotations
   } Comment String
   | Comment StringFilePath [AtomicWord]
   | Include FilePath [AtomicWord]

deriving instance Eq (c (Formula0 (T c) (F c))) => Eq (TPTP_Input_ c)
deriving instance EqOrd(cc(Formula0(Formula0(TTc))(FFc))))=>=>EqOrdTPTP_Input_(TPTP_Input_)c)
deriving instance OrdShow(cc(Formula0(Formula0(TTc))(FFc))))=>=>OrdShowTPTP_Input_(TPTP_Input_)c)
deriving instance Show (c (Formula0 (T c) (F c))) => Show (TPTP_Input_ c)
deriving instance Read (c (Formula0 (T c) (F c))) => Read (TPTP_Input_ c)

#if MIN_VERSION_base(4,7,0)
deriving instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
deriving instance (TypeableTypeableTPTP_Input_, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
deriving#else     instance Typeable TPTP_Input_
deriving instance (Typeable1 c, Data (c (Formula0 (T c) (F c)))) => Data (TPTP_Input_ c)
instance Typeable1 c => Typeable (TPTP_Input_ c) where
  typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "TPTP_Input_"
#endif

-- | Annotations about the formulas origin
data-- | Annotations about the formulas originAnnotations = NoAnnotations | Annotations GTerm UsefulInfo
data Annotations =deriving(Eq,Ord|,AnnotationsShow,Read,Data,Typeable)
                  deriving (Eq,Ord,Show,Read,Data,Typeable)
-- | Misc annotations
data-- | Misc annotationsUsefulInfo = NoUsefulInfo | UsefulInfo [GTerm]
data UsefulInfo = NoUsefulInfoderiving (Eq,|Ord,Show,Read[GTermData,]Typeable)
                  deriving (Eq,Ord,Show,Read,Data,Typeable)
-- | Formula roles
newtype-- | Formula rolesRole = Role { unrole :: String }
newtype Rolederiving= Role {(unroleEq,Ord,::Show,Read,}Data,Typeable)
            deriving (Eq,Ord,Show,Read,Data,Typeable)

-- | Metadata (the /general_data/ rule in TPTP's grammar)
data-- | Metadata (the /general_data/ rule in TPTP's grammar)GData = GWord AtomicWord
data GData = GWord| AtomicWordGApp AtomicWord [GTerm]
                 | GApp AtomicWordV          [GTerm]
                 | GVarGNumber  Rational
                 | GNumberGDistinctObjectString
                 | GDistinctObjectGFormulaData StringFormula
                 | GFormulaDataderiving (Eq,StringOrd,Show,Read,Data,Typeable)
                   deriving (Eq,Ord,Show,Read,Data,Typeable)
-- | Metadata (the /general_term/ rule in TPTP's grammar)
data-- | Metadata (the /general_term/ rule in TPTP's grammar)GTerm = ColonSep GData GTerm
data GTerm = ColonSepGTerm GData GTerm
           | GTerm GData[GTerm]
           | GListderivingGTerm(Eq]Ord,Show,Read,Data,Typeable)
             deriving (Eq,Ord,Show,Read,Data,Typeable)



-- * Gathering free Variables
-- * Gathering free Variables
-- class FormulaOrTerm c a where
-- class FormulaOrTerm c a where--     elimFormulaOrTerm :: (F c -> r) -> (T c -> r) -> a -> r
--     elimFormulaOrTerm :: (F c -> r) -> (T c -> r) -> a -> r
-- instance FormulaOrTerm Identity Formula where
--     elimFormulaOrTerm k _ x = k x-- instance FormulaOrTerm Identity Formula where
--     elimFormulaOrTerm k _ x = k x
-- instance FormulaOrTerm Identity Term where
--     elimFormulaOrTerm _ k x = k x-- instance FormulaOrTerm Identity Term where
--     elimFormulaOrTerm _ k x = k x
class FreeVars a where
class-- | Obtain the free variables from a formula or term a where
    freeVars-- | Obtain the free variables from a formula or term:: a -> Set V
    freeVars :: a -> Set V
-- | Universally quantify all free variables in the formula
univquant_free_vars-- | Universally quantify all free variables in the formula:: Formula -> Formula
univquant_free_vars ::cnfFormula=      -> Formula
univquant_free_varscase S.toList (freeVars =   cnf) of
    case[] S.toList-> cnf   (freeVars cnf) of
      [vars] ->->for_all vars cnf
      vars -> for_all vars cnf
instance FreeVars Formula where
instancefreeVars= foldF where
    freeVars = foldFfreeVars
               freeVars(\_ vars x -> S.difference (freeVars x) (S.fromList vars))
               (\_ vars_ y -> ->(mappend`on` freeVarsfreeVars) x x) (S.fromList vars))
               (\x _ y -> (mappend `on` freeVars) x y)
               (\x _args ->->(mappendS.unions`on(fmap` freeVarsfreeVars) xargs) ))
               (\_ args -> S.unions (fmap freeVars args))
instance FreeVars Term where
instancefreeVars= foldT where
    freeVars = foldT(const mempty)
               (const mempty)
               (S.singletonconst mempty)
               S.singleton(\_ args -> S.unions (fmap freeVars args))
               (\_ args -> S.unions (fmap freeVars args))

--- Have the Arbitrary instances in this module to avoid orphan instances
--- Have the Arbitrary instances in this module to avoid orphan instances
instance Arbitrary TPTP_Input
instancewhereArbitraryarbitraryTPTP_Input= frequency [(10,
    where arbitrary = frequency [(10,do
                                    dox1 <- AtomicWord <$> arbLowerWord
                                      x1 <- AtomicWordarbitrary  <$> arbLowerWord
                                      x2 <- arbitrary
                                      x3 <- arbitrary
                                      x4return<- arbitrary(AFormula x1 x2 x3 x4))
                                      return (AFormula x1 x2 x3 x4))
                                  , (1,
                                  , (do1,
                                    dox1 <- arbPrintable
                                      x1return<- arbPrintable(Comment ("% "++x1))
                                  )   return (Comment ("% "++x1))
                                  )
                                  , (1, Include `fmap` arbLowerWord `ap`
                                  , (1, IncludelistOf `arbitraryfmap` arbLowerWord)          `ap`
                                ]        listOf arbitrary)
                                ]
instance Arbitrary Formula
instancewhereArbitraryarbitraryFormula= fmap (F . point) arbitrary
    where arbitrary = fmap (F . point) arbitrary
instance Arbitrary Term
instancewhereArbitraryarbitraryTerm= fmap (T . point) arbitrary
    where arbitrary = fmap (T . point) arbitrary
instance Arbitrary Annotations
instancewhereArbitraryarbitraryAnnotations= oneof [
    where arbitrary = oneof [ return NoAnnotations
                            , returnAnnotations`fmap` arbitrary `ap` arbitrary
                      ]     , Annotations `fmap` arbitrary `ap` arbitrary
                      ]
instance Arbitrary UsefulInfo
instancewhereArbitraryarbitraryUsefulInfo= oneof [
    where arbitrary = oneof [ return NoUsefulInfo
                             ,returndo    NoUsefulInfo
                             , dox1 <- arbitrary
                                x1return<- arbitrary(UsefulInfo x1)
                      ]         return (UsefulInfo x1)
                      ]
instance Arbitrary Role
instancewhereArbitraryarbitraryRole= Role `fmap` arbLowerWord
    where arbitrary = Role `fmap` arbLowerWord

instance (Arbitrary a, Arbitrary b) => Arbitrary (Formula0 a b)
instance (Arbitrary a, Arbitrary b) => Arbitrary (Formula0 a b)

    where arbitrary = sized go
    where arbitrary = sized go
           where
           wherego 0 = flip PredApp [] `fmap` arbitrary
            go 0 = flip PredApp [] `fmap` arbitrary
            go i =
            go ioneof=    [ do
                oneof [ do        ileft <- choose (0,i-1)
                                  ileftx1 <- <-resizeileft0,iarbitrary-1)
                                  x1 <- resizearbitrary arbitrary
                                  x2 <- arbitraryresize (i - 1 - ileft) arbitrary
                                  x3return<- resize(BinOp(ix1-x2 -x3ileft)    ) arbitrary
                                  return (BinOp x1 x2 x3)
                      , do
                      , do        x1 <- arbitrary
                                  x1 <- arbitrary
                                  x2 <- arbitrary
                                  x3return<- arbitrary(InfixPred x1 x2 x3)
                                  return (InfixPred x1 x2 x3)
                      , do
                      , do        x1 <- arbitrary
                                  x1 <- arbitraryargsFreq vector
                                  x2return<- argsFreq(PredAppvectorx1 x2)
                                  return (PredApp x1 x2)
                      , do
                      , do     x1 <- arbitrary
                               x1 <- arbitraryliftM2 (:) arbitrary (argsFreq (\nargs -> vectorOf nargs arbitrary))
                               x2 <- liftM2 (:)1arbitrary) arbitraryargsFreq (\nargs -> vectorOf nargs arbitrary))
                               x3return<- resize(Quant(ix1-1)x2arbitraryx3)
                               return (Quant x1 x2 x3)
                      , do
                      , do        x1 <- resize (i-1) arbitrary
                                  x1return<- resize((:~:)(ix1-1) arbitrary
                      ]           return ((:~:) x1)
                      ]
instance Arbitrary BinOp
instancewhereArbitraryarbitraryBinOp= elements
    where arbitrary = elements
                             [ (:<=>:)
                             [ (:<=>::=>:))
                             , (:=>:)
                             , (:<=::&:))
                             , (:&:)
                             , (:|::~&:))
                             , (:~&:)
                             , (:~|::<~>:))
                             , (:<~>:)
                             ]
instance Arbitrary InfixPred
instancewhereArbitraryarbitraryInfixPred= elements [ (:=:),(:!=:) ]
    where arbitrary = elements [ (:=:),(:!=:) ]
instance Arbitrary Quant
instancewhereArbitraryarbitraryQuant= elements [All,Exists]
    where arbitrary = elements [All,Exists]
instance Arbitrary a => Arbitrary (Term0 a)
instancewhereArbitraryarbitrarya==>sizedgo    (Term0 a)
    where arbitrarywhere    = sized go
           where

            go 0 = frequency [ (2,Var <$> arbitrary), (1,FunApp `fmap` arbitrary `ap` return[] ) ]
            go 0 = frequency [ (2,Var <$> arbitrary), (1,FunApp `fmap` arbitrary `ap` return[] ) ]
            go i = oneof [
            go i = oneof [   do
                             dox1 <- arbitrary
                              x1return<- arbitrary(Var x1)
                              return (Var x1)
                           , arbNum NumberLitTerm
                           , arbNum NumberLitTerm

                           , do
                           , dox1 <- arbPrintable
                              x1return<- arbPrintable(DistinctObjectTerm x1)
                              return (DistinctObjectTerm x1)
                           , do
                           , dox1 <- arbitrary
                              x1args<-<-argsFreq
                              args(\nargs<- argsFreq-> do
                                (\nargsparti-><-doarbPartition nargs (i-1)
                                   partimapM (<-flipresize arbitrary)(iparti-1)
                                )  mapM (flip resize arbitrary) parti
                                )
                              return (FunApp x1 args)
                           ]  return (FunApp x1 args)
                           ]
instance Arbitrary GData
instancewhereArbitraryarbitraryGData= sized go
    where arbitrary = sized go
                  where
                  wherego 0 = oneof [ fmap GWord arbitrary
                       go 0 = oneof [ fmap GWordGVar arbitrary
                                    , fmap GVar arbitrary
                                    ]
                       go i =
                       go ioneof=
                           oneof[
                           [GWord <$> arbitrary
                            GWord <$> arbitrary
                           ,do
                           ,dox1 <- arbLowerWord
                              x1args<-<-argsFreq
                              args <- argsFreq(\nargs -> do
                                         (\nargsparti-><-doarbPartition nargs (i-1)
                                            partimapM (<-flipresize arbitrary)(iparti-1)
                                         ) `mapMsuchThatflip` (resize(/=) []arbitrary)        ) parti
                                         ) `suchThat` ((/=) [])
                              return (GApp (AtomicWord x1) args)
                              return (GApp (AtomicWord x1) args)
                           ,GVar <$> arbitrary
                           ,GVararbNumGNumber
                           ,arbNum GNumber
                           ,GDistinctObject <$> arbPrintable
                           ,GDistinctObjectGFormulaData `fmap` arbPrintable((:) '$' `fmap` arbLowerWord) `ap` (sized (\n -> resize (n `div` 2) arbitrary))
                           ,GFormulaData `fmap` ((:) '$' `fmap` arbLowerWord) `ap` (sized (\n -> resize (n `div` 2) arbitrary))
                           ]


instance Arbitrary GTerm
instancewhereArbitraryarbitraryGTerm= sized go
    where arbitrary = sized go
              where
              wherego 0 = fmap GTerm arbitrary
                go 0 = fmap GTerm arbitrary
                go i =
                go ioneof=    [
                    oneof [ do
                            do    ileft <- choose(0,i-1)
                                  ileftx1 <- <-resizeileft(0,i-arbitrary1)
                                  x1 <- resize ileft(i-1-ileft) arbitrary
                                  x2return<- resize(ColonSepi-1-x1ileftx2)) arbitrary
                                  return (ColonSep x1 x2)
                          , do
                          , do    x1 <- arbitrary
                                  x1return<- arbitrary(GTerm x1)
                                  return (GTerm x1)
                          , do
                          , do    args <- argsFreq
                                  args <- argsFreq(\nargs -> do
                                           (\nargsparti-><-doarbPartition nargs (i-1)
                                              partimapM (<-flipresize arbitrary)(iparti-1)
                                           ) `mapMsuchThatflip` (resize/= []) arbitrary) parti
                                           ) `suchThat` (/= [])
                                  return (GList args)
                       ]          return (GList args)
                       ]
-- | TPTP constant symbol\/predicate symbol\/function symbol identifiers (they are output in single quotes unless they are /lower_word/s).
---- | TPTP constant symbol\/predicate symbol\/function symbol identifiers (they are output in single quotes unless they are /lower_word/s).
---- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'
newtype-- Tip: Use the @-XOverloadedStrings@ compiler flag if you don't want to have to type /AtomicWord/ to construct an 'AtomicWord'AtomicWord = AtomicWord String
newtypederiving(Eq,Ord=,AtomicWordShow,Data,Typeable ,Read,Monoid,IsString)
    deriving (Eq,Ord,Show,Data,Typeable,Read,Monoid,IsString)
instance Arbitrary AtomicWord where
instancearbitrary= frequency[  (where5, AtomicWord <$> arbLowerWord)
    arbitrary = frequency [ ,(5, AtomicWord <$> arbLowerWord)
                          ] ,(1, AtomicWord <$> arbPrintable)
                          ]
-- | Variable names
newtype-- | Variable namesV = V String
newtypederiving = V(StringEq,Ord,Show,Data,Typeable,Read,Monoid,IsString)
    deriving (Eq,Ord,Show,Data,Typeable,Read,Monoid,IsString)
instance Arbitrary V where
instancearbitrary= V <$> wherearbVar
    arbitrary = V <$> arbVar
-- * Fixed-point style decorated formulae and terms
-- * Fixed-point style decorated formulae and terms
-- | Formulae whose subexpressions are wrapped in the given type constructor @c@.
---- | Formulae whose subexpressions are wrapped in the given type constructor @c@.
---- For example:
---- For example:
---- - @c = 'Identity'@: Plain formulae
---- - @c = 'Identity'@: Plain formulae
---- - @c = 'Maybe'@: Formulae that may contain \"holes\"
---- - @c = 'Maybe'@: Formulae that may contain \"holes\"
---- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressions
newtype-- - @c = 'IORef'@: (Mutable) formulae with mutable subexpressionsF c = F { runF :: c (Formula0 (T c) (F c)) }
newtype F c = F { runF :: c (Formula0 (T c) (F c)) }
-- | Terms whose subterms are wrapped in the given type constructor @c@
newtype-- | Terms whose subterms are wrapped in the given type constructor @c@T c = T { runT :: c (Term0 (T c)) }
newtype T c = T { runT :: c (Term0 (T c)) }
#define DI(X) deriving instance (X (c (Term0 (T c)))) => X (T c); deriving instance (X (c (Formula0 (T c) (F c)))) => X (F c)

DI(Eq)
derivingDI(Ord)  instance (Eq (c (Term0 (T c)))) => Eq (T c); deriving instance (Eq (c (Formula0 (T c) (F c)))) => Eq (F c)
derivingDI(Show) instance (Ord (c (Term0 (T c)))) => Ord (T c); deriving instance (Ord (c (Formula0 (T c) (F c)))) => Ord (F c)
derivingDI(Read) instance (Show (c (Term0 (T c)))) => Show (T c); deriving instance (Show (c (Formula0 (T c) (F c)))) => Show (F c)
deriving instance (Read (c (Term0 (T c)))) => Read (T c); deriving instance (Read (c (Formula0 (T c) (F c)))) => Read (F c)
#if MIN_VERSION_base(4,7,0)
deriving instance Typeable F
deriving instance Typeable F
deriving instance Typeable T
deriving instance (Typeable c, Data (c (Term0 (T c)))) => Data (T c)
deriving instance (Typeable c, Data (c (Term0Formula0T c)))) =>(F Datac))))(T=>c)Data (F c)
deriving#else     instance (Typeable c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
instance Typeable1 c => Typeable (F c) where
    typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "F"

instance Typeable1 c => Typeable (T c) where
    typeOf = mkTypeOfForRank2Kind "Codec.TPTP.Base" "T"

deriving instance (Typeable1 c, Data (c (Term0 (T c)))) => Data (T c)
deriving instance (Typeable1 c, Data (c (Formula0 (T c) (F c)))) => Data (F c)
#endif

-- * Utility functions

unwrapF ::
            (Copointed t) =>
            F t -> Formula0 (T t) (F t)
unwrapF (F x) = copoint x
unwrapT ::
            (Copointed t) =>
            T t -> Term0 (T t)
unwrapT (T x) = copoint x

foldFormula0 ::
                  (f -> r)
                -> (Quant -> [V] -> f -> r)
                -> (f -> BinOp -> f -> r)
                -> (t -> InfixPred -> t -> r)
                -> (AtomicWord -> [t] -> r)
                -> Formula0 t f
                -> r
foldFormula0 kneg kquant kbinop kinfix kpredapp f =
    case f of
      (:~:) x -> kneg x
      Quant x y z -> kquant x y z
      BinOp x y z -> kbinop x y z
      InfixPred x y z -> kinfix x y z
      PredApp x y -> kpredapp x y

foldTerm0 ::
               (String -> r)
             -> (Rational -> r)
             -> (V -> r)
             -> (AtomicWord -> [t] -> r)
             -> Term0 t
             -> r
foldTerm0 kdistinct knum kvar kfunapp t =
    case t of
      DistinctObjectTerm x -> kdistinct x
      NumberLitTerm x -> knum x
      Var x -> kvar x
      FunApp x y -> kfunapp x y


-- | Eliminate formulae
foldF ::
         (Copointed t) =>
           (F t -> r) -- ^ Handle negation
         -> (Quant -> [V] -> F t -> r) -- ^ Handle quantification
         -> (F t -> BinOp -> F t -> r) -- ^ Handle binary op
         -> (T t -> InfixPred -> T t -> r) -- ^ Handle equality/inequality
         -> (AtomicWord -> [T t] -> r) -- ^ Handle predicate symbol application
         -> (F t -> r) -- ^ Handle formula

</pre>