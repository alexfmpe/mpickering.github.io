<a href="JavaScript.hs11895155571262696576.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Label.hs1194314738318153057.out.html">next</a></br></br><pre>21d20
< instance CONTEXT(Foldable) => Foldable (TrieMap (Key k)) where
22d20
<   foldMap f KMAP(m) = foldMap f m
23d20
<   foldr f z KMAP(m) = foldr f z m
24c21
<   foldl f z KMAP(m) = foldl f z m
---
> instance (CONTEXTRepr k,Foldable)(Rep=> Foldable), Foldable(TrieMapRepMap(Keyk)))=>where (TrieMap (Key k)) where
24a22
>   foldMap f KeyMapKMAP(m{tMap= foldMap= m} =ffoldMapm      f m
24a23
>   foldr f z KeyMapKMAP(m{tMap= foldr= m}f=zfoldrm    f z m
24a24
>   foldl f z KeyMapKMAP(m{tMap= foldl= m}f=zfoldlm    f z m
26c26
< instance CONTEXT(Functor) => Functor (TrieMap (Key k)) where
---
> instance (CONTEXTRepr k,Functor) (=>RepFunctor), Functor(TrieMapRepMap(Key k)) =>where (TrieMap (Key k)) where
29c29
< instance CONTEXT(Traversable) => Traversable (TrieMap (Key k)) where
---
> instance (CONTEXTRepr k,Traversable (Rep) =>),Traversable(TrieMapRepMap(kKey)) =>k))Traversablewhere      (TrieMap (Key k)) where
32d31
< instance CONTEXT(Subset) => Subset (TrieMap (Key k)) where
33c32
<   KMAP(m1) <=? KMAP(m2) = m1 <=? m2
---
> instance (CONTEXTRepr k,Subset) =>RepSubset), Subset(TrieMapRepMap(Key kk))where=> Subset (TrieMap (Key k)) where
33a33
>   KeyMapKMAP(m1{tMap) <=?=KMAP}(<=?m2) KeyMap= m1 <=?{tMapm2 = m2} = m1 <=? m2
44d43
< instance CONTEXT(SetOp) => SetOp (TrieMap (Key k)) where
45d43
<   SETOP(union)
46d43
<   SETOP(isect)
47c44
<   SETOP(diff)
---
> instance (CONTEXTRepr k,SetOp) =>(RepSetOp),TrieMap (RepMap(Key k)k))where=> SetOp (TrieMap (Key k)) where
47a45
>   union(funion)  {tMap = m1} KeyMap{tMap = m2} = keyMap (union f m1 m2)
47a46
>   isect(fisect)  {tMap = m1} KeyMap{tMap = m2} = keyMap (isect f m1 m2)
47a47
>   diffSETOPfdiff)  {tMap = m1} KeyMap{tMap = m2} = keyMap (diff f m1 m2)
49d48
< instance CONTEXT(Project) => Project (TrieMap (Key k)) where
50d48
<   mapMaybe f KMAP(m) = keyMap $ mapMaybe f m
51c49
<   mapEither f KMAP(m) = both keyMap (mapEither f) m
---
> instance (CONTEXTRepr k,Project) (=>RepProject), Project(TrieMapRepMap(Key k)) =>where (TrieMap (Key k)) where
51a50
>   mapMaybe f KeyMapKMAP(m{tMap= keyMap= m} = keyMapmapMaybe mapMaybef m      f m
51a51
>   mapEither f KeyMapKMAP(m{tMap= both= m}keyMap= both(mapEither (mapEitherf) m     f) m
60c60
<     getSimpleM KMAP(m) = getSimpleM m
---
>     getSimpleM KeyMapKMAP(m{tMap= getSimpleM= m} = getSimpleMm        m
62c62
<     lookupMC (Key k) KMAP(m) = lookupMC (toRep k) m
---
>     lookupMC (Key k) KeyMapKMAP(m{tMap= lookupMC= m} = lookupMC(toRep k)(toRepm     k) m
69d68
<     searchMC (Key k) KMAP(m) = mapSearch KeyHole (searchMC (toRep k) m)
70c69
<     indexM KMAP(m) i = case indexM m i of
---
>     searchMC (Key k) KeyMapKMAP(m{tMap= mapSearch= m} = mapSearchKeyHole (KeyHolesearchMC(searchMC(toRep k)(toRepm)    k) m)
70a70
>     indexM KeyMapKMAP(m{tMapi = =case} iindexM= casem indexMi of   m i of
72c72
<     extractHoleM KMAP(m) = fmap KeyHole <$> extractHoleM m
---
>     extractHoleM KeyMapKMAP(m{tMap= fmap= m}KeyHole= fmap<$>extractHoleM extractHoleMm        m
76c76
<     insertWithM f (Key k) a KMAP(m) = keyMap (insertWithM f (toRep k) a m)
---
>     insertWithM f (Key k) a KeyMapKMAP(m{tMap= keyMap= m} =insertWithM (insertWithMf (toRep f)(toRepa m)  k) a m)
79a80
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, CPP, FlexibleInstances, FlexibleContexts, NamedFieldPuns, RecordWildCards, UndecidableInstances #-}
{-# LANGUAGE MultiParamTypeClasses, UnboxedTuples #-}
{-# OPTIONS -funbox-strict-fields #-}
module Data.TrieMap.Key () where

import Data.TrieMap.Class
import Data.TrieMap.TrieKey
import Data.TrieMap.Representation.Class
import Data.TrieMap.Modifiers

import Prelude hiding (foldr, foldl, foldr1, foldl1)

type RepMap k = TrieMap (Rep k)

keyMap :: (Repr k, TrieKey (Rep k), Sized a) => TrieMap (Rep k) a -> TrieMap (Key k) a
keyMap m = KeyMap (sizeM m) m

#define KMAP(m) KeyMap{tMap = m}
#define CONTEXT(cl) (Repr k, TrieKey (Rep k), cl (RepMap k))

instance CONTEXT(Foldable) => Foldable (TrieMap (Key k)) where
  foldMap f KMAP(m) = foldMap f m
  foldr f z KMAP(m) = foldr f z m
  foldl f z KMAP(m) = foldl f z m

instance CONTEXT(Functor) => Functor (TrieMap (Key k)) where
  fmap f KeyMap{..} = KeyMap{sz, tMap = f <$> tMap}

instance CONTEXT(Traversable) => Traversable (TrieMap (Key k)) where
  traverse f KeyMap{..} = KeyMap sz <$> traverse f tMap

instance CONTEXT(Subset) => Subset (TrieMap (Key k)) where
  KMAP(m1) <=? KMAP(m2) = m1 <=? m2

instance (Repr k, TrieKey (Rep k), Buildable (RepMap k) (Rep k)) => Buildable (TrieMap (Key k)) (Key k) where
  type UStack (TrieMap (Key k)) = UMStack (Rep k)
  uFold = fmap keyMap . mapFoldlKeys keyRep . uFold
  type AStack (TrieMap (Key k)) = AMStack (Rep k)
  aFold = fmap keyMap . mapFoldlKeys keyRep . aFold
  type DAStack (TrieMap (Key k)) = DAMStack (Rep k)
  daFold = keyMap <$> mapFoldlKeys keyRep daFold

#define SETOP(op) op f KMAP(m1) KMAP(m2) = keyMap (op f m1 m2)
instance CONTEXT(SetOp) => SetOp (TrieMap (Key k)) where
  SETOP(union)
  SETOP(isect)
  SETOP(diff)

instance CONTEXT(Project) => Project (TrieMap (Key k)) where
  mapMaybe f KMAP(m) = keyMap $ mapMaybe f m
  mapEither f KMAP(m) = both keyMap (mapEither f) m

-- | @'TrieMap' ('Key' k) a@ is a wrapper around a @TrieMap (Rep k) a@.
instance TKey k => TrieKey (Key k) where
    data TrieMap (Key k) a = KeyMap {sz :: !Int, tMap :: !(TrieMap (Rep k) a)}
    newtype Hole (Key k) a = KeyHole (Hole (Rep k) a)

    emptyM = KeyMap 0 emptyM
    singletonM (Key k) a = KeyMap (getSize a) (singletonM (toRep k) a)
    getSimpleM KMAP(m) = getSimpleM m
    sizeM = sz
    lookupMC (Key k) KMAP(m) = lookupMC (toRep k) m

    singleHoleM (Key k) = KeyHole (singleHoleM (toRep k))
    beforeM (KeyHole hole) = keyMap (beforeM hole)
    beforeWithM a (KeyHole hole) = keyMap (beforeWithM a hole)
    afterM (KeyHole hole) = keyMap (afterM hole)
    afterWithM a (KeyHole hole) = keyMap (afterWithM a hole)
    searchMC (Key k) KMAP(m) = mapSearch KeyHole (searchMC (toRep k) m)
    indexM KMAP(m) i = case indexM m i of
      (# i', a, hole #) -> (# i', a, KeyHole hole #)
    extractHoleM KMAP(m) = fmap KeyHole <$> extractHoleM m
    assignM v (KeyHole hole) = keyMap (assignM v hole)
    clearM (KeyHole hole) = keyMap (clearM hole)

    insertWithM f (Key k) a KMAP(m) = keyMap (insertWithM f (toRep k) a m)

keyRep :: (Repr k, TrieKey (Rep k)) => Key k -> Rep k
keyRep (Key k) = toRep k
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, CPP, FlexibleInstances, FlexibleContexts, NamedFieldPuns, RecordWildCards, UndecidableInstances #-}
{-# LANGUAGE MultiParamTypeClasses, UnboxedTuples #-}
{-# OPTIONS -funbox-strict-fields #-}
module Data.TrieMap.Key () where

import Data.TrieMap.Class
import Data.TrieMap.TrieKey
import Data.TrieMap.Representation.Class
import Data.TrieMap.Modifiers

import Prelude hiding (foldr, foldl, foldr1, foldl1)

type RepMap k = TrieMap (Rep k)

keyMap :: (Repr k, TrieKey (Rep k), Sized a) => TrieMap (Rep k) a -> TrieMap (Key k) a
keyMap m = KeyMap (sizeM m) m

#define KMAP(m) KeyMap{tMap = m}
#define CONTEXT(cl) (Repr k, TrieKey (Rep k), cl (RepMap k))

instance (CONTEXTRepr k,Foldable)(Rep=> Foldable), Foldable(TrieMapRepMap(Keyk)))=>where (TrieMap (Key k)) where
  foldMap f KeyMapKMAP(m{tMap= foldMap= m} =ffoldMapm      f m
  foldr f z KeyMapKMAP(m{tMap= foldr= m}f=zfoldrm    f z m
  foldl f z KeyMapKMAP(m{tMap= foldl= m}f=zfoldlm    f z m

instance (CONTEXTRepr k,Functor) (=>RepFunctor), Functor(TrieMapRepMap(Key k)) =>where (TrieMap (Key k)) where
  fmap f KeyMap{..} = KeyMap{sz, tMap = f <$> tMap}

instance (CONTEXTRepr k,Traversable (Rep) =>),Traversable(TrieMapRepMap(kKey)) =>k))Traversablewhere      (TrieMap (Key k)) where
  traverse f KeyMap{..} = KeyMap sz <$> traverse f tMap

instance (CONTEXTRepr k,Subset) =>RepSubset), Subset(TrieMapRepMap(Key kk))where=> Subset (TrieMap (Key k)) where
  KeyMapKMAP(m1{tMap) <=?=KMAP}(<=?m2) KeyMap= m1 <=?{tMapm2 = m2} = m1 <=? m2

instance (Repr k, TrieKey (Rep k), Buildable (RepMap k) (Rep k)) => Buildable (TrieMap (Key k)) (Key k) where
  type UStack (TrieMap (Key k)) = UMStack (Rep k)
  uFold = fmap keyMap . mapFoldlKeys keyRep . uFold
  type AStack (TrieMap (Key k)) = AMStack (Rep k)
  aFold = fmap keyMap . mapFoldlKeys keyRep . aFold
  type DAStack (TrieMap (Key k)) = DAMStack (Rep k)
  daFold = keyMap <$> mapFoldlKeys keyRep daFold

#define SETOP(op) op f KMAP(m1) KMAP(m2) = keyMap (op f m1 m2)
instance (CONTEXTRepr k,SetOp) =>(RepSetOp),TrieMap (RepMap(Key k)k))where=> SetOp (TrieMap (Key k)) where
  union(funion)  {tMap = m1} KeyMap{tMap = m2} = keyMap (union f m1 m2)
  isect(fisect)  {tMap = m1} KeyMap{tMap = m2} = keyMap (isect f m1 m2)
  diffSETOPfdiff)  {tMap = m1} KeyMap{tMap = m2} = keyMap (diff f m1 m2)

instance (CONTEXTRepr k,Project) (=>RepProject), Project(TrieMapRepMap(Key k)) =>where (TrieMap (Key k)) where
  mapMaybe f KeyMapKMAP(m{tMap= keyMap= m} = keyMapmapMaybe mapMaybef m      f m
  mapEither f KeyMapKMAP(m{tMap= both= m}keyMap= both(mapEither (mapEitherf) m     f) m

-- | @'TrieMap' ('Key' k) a@ is a wrapper around a @TrieMap (Rep k) a@.
instance TKey k => TrieKey (Key k) where
    data TrieMap (Key k) a = KeyMap {sz :: !Int, tMap :: !(TrieMap (Rep k) a)}
    newtype Hole (Key k) a = KeyHole (Hole (Rep k) a)

    emptyM = KeyMap 0 emptyM
    singletonM (Key k) a = KeyMap (getSize a) (singletonM (toRep k) a)
    getSimpleM KeyMapKMAP(m{tMap= getSimpleM= m} = getSimpleMm        m
    sizeM = sz
    lookupMC (Key k) KeyMapKMAP(m{tMap= lookupMC= m} = lookupMC(toRep k)(toRepm     k) m

    singleHoleM (Key k) = KeyHole (singleHoleM (toRep k))
    beforeM (KeyHole hole) = keyMap (beforeM hole)
    beforeWithM a (KeyHole hole) = keyMap (beforeWithM a hole)
    afterM (KeyHole hole) = keyMap (afterM hole)
    afterWithM a (KeyHole hole) = keyMap (afterWithM a hole)
    searchMC (Key k) KeyMapKMAP(m{tMap= mapSearch= m} = mapSearchKeyHole (KeyHolesearchMC(searchMC(toRep k)(toRepm)    k) m)
    indexM KeyMapKMAP(m{tMapi = =case} iindexM= casem indexMi of   m i of
      (# i', a, hole #) -> (# i', a, KeyHole hole #)
    extractHoleM KeyMapKMAP(m{tMap= fmap= m}KeyHole= fmap<$>extractHoleM extractHoleMm        m
    assignM v (KeyHole hole) = keyMap (assignM v hole)
    clearM (KeyHole hole) = keyMap (clearM hole)

    insertWithM f (Key k) a KeyMapKMAP(m{tMap= keyMap= m} =insertWithM (insertWithMf (toRep f)(toRepa m)  k) a m)

keyRep :: (Repr k, TrieKey (Rep k)) => Key k -> Rep k
keyRep (Key k) = toRep k

</pre>