<a href="FinalEnv.hs12619908451731634143.out.html">prev</a></br><a href="failures.html">home</a></br><a href="FitsInCommon2.hs10052520731017739962.out.html">next</a></br></br><pre>38c38
< {-# LINE 48 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
38a39
> 
38a40
> 
38a41
> 
38a42
> 
38a43
> 
38a44
> 
38a45
> 
38a46
> 
38a47
> 
45c54
< {-# LINE 66 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
45a55
> 
45a56
> 
45a57
> 
45a58
> 
45a59
> 
45a60
> 
45a61
> 
45a62
> 
45a63
> 
45a64
> 
45a65
> 
49c69
< {-# LINE 79 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
49a70
> 
49a71
> 
49a72
> 
49a73
> 
49a74
> 
49a75
> 
49a76
> 
49a77
> 
49a78
> 
68c97
< {-# LINE 124 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
68a98
> 
68a99
> 
68a100
> 
68a101
> 
68a102
> 
68a103
> 
68a104
> 
68a105
> 
68a106
> 
68a107
> 
68a108
> 
68a109
> 
68a110
> 
68a111
> 
68a112
> 
68a113
> 
68a114
> 
68a115
> 
68a116
> 
68a117
> 
68a118
> 
68a119
> 
68a120
> 
68a121
> 
68a122
> 
68a123
> 
87c142
< {-# LINE 166 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
87a143
> 
87a144
> 
87a145
> 
87a146
> 
87a147
> 
87a148
> 
87a149
> 
87a150
> 
87a151
> 
87a152
> 
87a153
> 
87a154
> 
87a155
> 
87a156
> 
87a157
> 
87a158
> 
87a159
> 
87a160
> 
87a161
> 
87a162
> 
87a163
> 
87a164
> 
87a165
> 
91c169
< {-# LINE 171 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
91a170
> 
95c174
< {-# LINE 180 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
95a175
> 
95a176
> 
95a177
> 
95a178
> 
95a179
> 
105c189
< {-# LINE 195 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
105a190
> 
105a191
> 
105a192
> 
105a193
> 
105a194
> 
108c197
< {-# LINE 199 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
108a198
> 
117c207
< {-# LINE 211 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
117a208
> 
117a209
> 
117a210
> 
124c217
< {-# LINE 219 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
124a218
> 
132c226
< {-# LINE 230 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
132a227
> 
132a228
> 
132a229
> 
136c233
< {-# LINE 235 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
136a234
> 
140c238
< {-# LINE 240 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
140a239
> 
148c247
< {-# LINE 249 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
148a248
> 
170c270
< {-# LINE 276 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
170a271
> 
170a272
> 
170a273
> 
170a274
> 
170a275
> 
174c279
< {-# LINE 281 "src/ehc/Ty/FitsInCommon.chs" #-}
---
> 
174a280
> 
187a294
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Ty.FitsInCommon
( FIOut (..), emptyFO, foHasErrs
, foErrSq
, FitsIn, FitsIn'
, trfit, trfitIn, trfitOu
, foAppSpineInfo
, foPlusVarMp, foSetVarMp, foBindTyVar
, AppSpineVertebraeInfo (..)
, unknownAppSpineVertebraeInfo
, unknownAppSpineVertebraeInfoL
, AppSpineInfo (asgiVertebraeL), emptyAppSpineInfo, asgiShift1SpinePos, asgiSpine
, fitsInLWith
, AppSpineFOUpdCoe
, asUpdateByPolarity )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Error
import qualified UHC.Util.FastSeq as Seq
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Substitutable
import UHC.Util.Pretty
import qualified Data.Set as Set
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Pred.CommonCHR
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.Core.Coercion
import UHC.Light.Compiler.Core.Subst








{-# LINE 48 "src/ehc/Ty/FitsInCommon.chs" #-}
trfit :: String -> String -> PP_Doc -> PP_Doc
trfit dir msg rest =  dir >|< "." >|< msg >|< ":" >#< rest

trfitIn = trfit ">"
trfitOu = trfit "<"

{-# LINE 66 "src/ehc/Ty/FitsInCommon.chs" #-}
foErrSq :: FIOut -> ErrSq
foErrSq = Seq.fromList . foErrL

{-# LINE 79 "src/ehc/Ty/FitsInCommon.chs" #-}
data FIOut
  =  FIOut
       {  foVarMp           :: !VarMp                   -- tvar bindings found during fitsIn
       ,  foTy              :: !Ty                      -- the unified type
       ,  foUniq            :: !UID                     -- uniq value seed for fresh tvars
       ,  foMbAppSpineInfo  :: !(Maybe AppSpineInfo)    -- Ty_App spine info
       ,  foErrL            :: !ErrL                    -- errors
       ,  foTrace           :: [PP_Doc]                 -- trace
       ,  foLInstToL        :: [InstTo]                 -- instantiation over arrow '->' of left ty
       ,  foRInstToL        :: [InstTo]                 -- instantiation over arrow '->' of right ty
       ,  foDontBind        :: !TyVarIdS                -- output variant of fioDontBind
       ,  foCSubst          :: !CSubst                  -- subst for holes in the Core
       ,  foLRCoe           :: !LRCoe                   -- coercion over arrow structure
       ,  foPredOccL        :: ![PredOcc]               -- arisen predicates (to be obsolete)
       ,  foGathCnstrMp     :: !CHRPredOccCnstrMp       -- arisen predicates
       ,  foRowCoeL         :: !(AssocL HsName Coe)     -- internal, coercions for row fields
       }

{-# LINE 124 "src/ehc/Ty/FitsInCommon.chs" #-}
emptyFO
  =  FIOut
       {  foVarMp           =   emptyVarMp
       ,  foTy              =   Ty_Any
       ,  foUniq            =   uidStart
       ,  foMbAppSpineInfo  =   Nothing
       ,  foErrL            =   []
       ,  foTrace           =   []
       ,  foLInstToL        =   []
       ,  foRInstToL        =   []
       ,  foDontBind        =   Set.empty
       ,  foCSubst          =   emptyCSubst
       ,  foLRCoe           =   emptyLRCoe
       ,  foPredOccL        =   []
       ,  foGathCnstrMp     =   emptyCnstrMp
       ,  foRowCoeL         =   []
       }

{-# LINE 166 "src/ehc/Ty/FitsInCommon.chs" #-}
foHasErrs :: FIOut -> Bool
foHasErrs = not . null . foErrL

{-# LINE 171 "src/ehc/Ty/FitsInCommon.chs" #-}
foAppSpineInfo :: FIOut -> AppSpineInfo
foAppSpineInfo fo = maybe emptyAppSpineInfo id $ foMbAppSpineInfo fo

{-# LINE 180 "src/ehc/Ty/FitsInCommon.chs" #-}
foPlusVarMp :: VarMp -> FIOut -> FIOut
foPlusVarMp c fo = fo {foVarMp = c |+> foVarMp fo}

foSetVarMp :: VarMp -> FIOut -> FIOut
foSetVarMp  c fo = fo {foVarMp = c}

foBindTyVar :: TyVarId -> Ty -> FIOut -> FIOut
foBindTyVar v t = foPlusVarMp (v `varmpTyUnit` t)

{-# LINE 195 "src/ehc/Ty/FitsInCommon.chs" #-}
type AppSpineFOUpdCoe = EHCOpts -> [FIOut] -> FIOut

{-# LINE 199 "src/ehc/Ty/FitsInCommon.chs" #-}
data AppSpineVertebraeInfo
  =  AppSpineVertebraeInfo
       { asPolarity     :: Polarity                     -- the polarity on this spine position
       , asFIO          :: FIOpts -> FIOpts             -- how to update the context (swap ...)
       , asFO           :: FIOut -> FIOut -> FIOut      -- \ffo afo -> afo, update app function arg FIOut with app function FIOut
       , asMbFOUpdCoe   :: Maybe AppSpineFOUpdCoe       -- possibly update coercion
       }

{-# LINE 211 "src/ehc/Ty/FitsInCommon.chs" #-}
instance Show AppSpineVertebraeInfo where
  show _ = "AppSpineVertebraeInfo"

instance PP AppSpineVertebraeInfo where
  pp = pp . asPolarity

{-# LINE 219 "src/ehc/Ty/FitsInCommon.chs" #-}
unknownAppSpineVertebraeInfo :: AppSpineVertebraeInfo
unknownAppSpineVertebraeInfo
  = AppSpineVertebraeInfo
      polInvariant fioMkUnify
      asFODflt
      Nothing

{-# LINE 230 "src/ehc/Ty/FitsInCommon.chs" #-}
asFODflt :: FIOut -> FIOut -> FIOut
asFODflt _ afo = afo

{-# LINE 235 "src/ehc/Ty/FitsInCommon.chs" #-}
unknownAppSpineVertebraeInfoL :: [AppSpineVertebraeInfo]
unknownAppSpineVertebraeInfoL = repeat unknownAppSpineVertebraeInfo

{-# LINE 240 "src/ehc/Ty/FitsInCommon.chs" #-}
asUpdateByPolarity :: Polarity -> AppSpineVertebraeInfo -> AppSpineVertebraeInfo
asUpdateByPolarity pol as
  = as {asPolarity = pol, asFIO = mkfio}
  where mkfio | polIsContravariant pol = fioMkStrong
              | polIsCovariant     pol = id
              | otherwise              = fioMkUnify

{-# LINE 249 "src/ehc/Ty/FitsInCommon.chs" #-}
data AppSpineInfo
  = AppSpineInfo
      { asgiSpinePos   :: Int
      , asgiVertebraeL :: [AppSpineVertebraeInfo]
      }

instance Show AppSpineInfo where
  show _ = "AppSpineInfo"

instance PP AppSpineInfo where
  pp i = ppBracketsCommas (take 5 $ asgiVertebraeL i) >|< "@" >|< asgiSpinePos i

emptyAppSpineInfo :: AppSpineInfo
emptyAppSpineInfo = AppSpineInfo 0 unknownAppSpineVertebraeInfoL

asgiShift1SpinePos :: AppSpineInfo -> AppSpineInfo
asgiShift1SpinePos i = i {asgiSpinePos = asgiSpinePos i + 1}

asgiSpine :: AppSpineInfo -> [AppSpineVertebraeInfo]
asgiSpine i = drop (asgiSpinePos i) $ asgiVertebraeL i

{-# LINE 276 "src/ehc/Ty/FitsInCommon.chs" #-}
type FitsIn' = FIOpts -> UID -> VarMp -> Ty -> Ty -> FIOut
type FitsIn = FIOpts -> UID -> VarMp -> Ty -> Ty -> (Ty,VarMp,ErrL)

{-# LINE 281 "src/ehc/Ty/FitsInCommon.chs" #-}
fitsInLWith :: (FIOut -> FIOut -> FIOut) -> FitsIn' -> FIOpts -> UID -> VarMp -> TyL -> TyL -> ([FIOut],FIOut)
fitsInLWith foCmb elemFits opts uniq varmp tyl1 tyl2
  = (foL,fo)
  where ((_,fo),foL)
          = foldr  (\(t1,t2) ((u,foThr),foL)
                      -> let  (u',ue) = mkNewLevUID u
                              fo = elemFits opts ue (foVarMp foThr `varUpd` varmp) (foVarMp foThr `varUpd` t1) (foVarMp foThr `varUpd` t2)
                         in   ((u',foCmb fo foThr),fo:foL)
                   )
                   ((uniq,emptyFO),[])
            . zip tyl1
            $ tyl2

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Ty.FitsInCommon
( FIOut (..), emptyFO, foHasErrs
, foErrSq
, FitsIn, FitsIn'
, trfit, trfitIn, trfitOu
, foAppSpineInfo
, foPlusVarMp, foSetVarMp, foBindTyVar
, AppSpineVertebraeInfo (..)
, unknownAppSpineVertebraeInfo
, unknownAppSpineVertebraeInfoL
, AppSpineInfo (asgiVertebraeL), emptyAppSpineInfo, asgiShift1SpinePos, asgiSpine
, fitsInLWith
, AppSpineFOUpdCoe
, asUpdateByPolarity )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Error
import qualified UHC.Util.FastSeq as Seq
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.Substitutable
import UHC.Util.Pretty
import qualified Data.Set as Set
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Pred.CommonCHR
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.Core.Coercion
import UHC.Light.Compiler.Core.Subst


















trfit :: String -> String -> PP_Doc -> PP_Doc
trfit dir msg rest =  dir >|< "." >|< msg >|< ":" >#< rest

trfitIn = trfit ">"
trfitOu = trfit "<"













foErrSq :: FIOut -> ErrSq
foErrSq = Seq.fromList . foErrL











data FIOut
  =  FIOut
       {  foVarMp           :: !VarMp                   -- tvar bindings found during fitsIn
       ,  foTy              :: !Ty                      -- the unified type
       ,  foUniq            :: !UID                     -- uniq value seed for fresh tvars
       ,  foMbAppSpineInfo  :: !(Maybe AppSpineInfo)    -- Ty_App spine info
       ,  foErrL            :: !ErrL                    -- errors
       ,  foTrace           :: [PP_Doc]                 -- trace
       ,  foLInstToL        :: [InstTo]                 -- instantiation over arrow '->' of left ty
       ,  foRInstToL        :: [InstTo]                 -- instantiation over arrow '->' of right ty
       ,  foDontBind        :: !TyVarIdS                -- output variant of fioDontBind
       ,  foCSubst          :: !CSubst                  -- subst for holes in the Core
       ,  foLRCoe           :: !LRCoe                   -- coercion over arrow structure
       ,  foPredOccL        :: ![PredOcc]               -- arisen predicates (to be obsolete)
       ,  foGathCnstrMp     :: !CHRPredOccCnstrMp       -- arisen predicates
       ,  foRowCoeL         :: !(AssocL HsName Coe)     -- internal, coercions for row fields
       }




























emptyFO
  =  FIOut
       {  foVarMp           =   emptyVarMp
       ,  foTy              =   Ty_Any
       ,  foUniq            =   uidStart
       ,  foMbAppSpineInfo  =   Nothing
       ,  foErrL            =   []
       ,  foTrace           =   []
       ,  foLInstToL        =   []
       ,  foRInstToL        =   []
       ,  foDontBind        =   Set.empty
       ,  foCSubst          =   emptyCSubst
       ,  foLRCoe           =   emptyLRCoe
       ,  foPredOccL        =   []
       ,  foGathCnstrMp     =   emptyCnstrMp
       ,  foRowCoeL         =   []
       }

























foHasErrs :: FIOut -> Bool
foHasErrs = not . null . foErrL



foAppSpineInfo :: FIOut -> AppSpineInfo
foAppSpineInfo fo = maybe emptyAppSpineInfo id $ foMbAppSpineInfo fo







foPlusVarMp :: VarMp -> FIOut -> FIOut
foPlusVarMp c fo = fo {foVarMp = c |+> foVarMp fo}

foSetVarMp :: VarMp -> FIOut -> FIOut
foSetVarMp  c fo = fo {foVarMp = c}

foBindTyVar :: TyVarId -> Ty -> FIOut -> FIOut
foBindTyVar v t = foPlusVarMp (v `varmpTyUnit` t)







type AppSpineFOUpdCoe = EHCOpts -> [FIOut] -> FIOut



data AppSpineVertebraeInfo
  =  AppSpineVertebraeInfo
       { asPolarity     :: Polarity                     -- the polarity on this spine position
       , asFIO          :: FIOpts -> FIOpts             -- how to update the context (swap ...)
       , asFO           :: FIOut -> FIOut -> FIOut      -- \ffo afo -> afo, update app function arg FIOut with app function FIOut
       , asMbFOUpdCoe   :: Maybe AppSpineFOUpdCoe       -- possibly update coercion
       }





instance Show AppSpineVertebraeInfo where
  show _ = "AppSpineVertebraeInfo"

instance PP AppSpineVertebraeInfo where
  pp = pp . asPolarity



unknownAppSpineVertebraeInfo :: AppSpineVertebraeInfo
unknownAppSpineVertebraeInfo
  = AppSpineVertebraeInfo
      polInvariant fioMkUnify
      asFODflt
      Nothing





asFODflt :: FIOut -> FIOut -> FIOut
asFODflt _ afo = afo



unknownAppSpineVertebraeInfoL :: [AppSpineVertebraeInfo]
unknownAppSpineVertebraeInfoL = repeat unknownAppSpineVertebraeInfo



asUpdateByPolarity :: Polarity -> AppSpineVertebraeInfo -> AppSpineVertebraeInfo
asUpdateByPolarity pol as
  = as {asPolarity = pol, asFIO = mkfio}
  where mkfio | polIsContravariant pol = fioMkStrong
              | polIsCovariant     pol = id
              | otherwise              = fioMkUnify



data AppSpineInfo
  = AppSpineInfo
      { asgiSpinePos   :: Int
      , asgiVertebraeL :: [AppSpineVertebraeInfo]
      }

instance Show AppSpineInfo where
  show _ = "AppSpineInfo"

instance PP AppSpineInfo where
  pp i = ppBracketsCommas (take 5 $ asgiVertebraeL i) >|< "@" >|< asgiSpinePos i

emptyAppSpineInfo :: AppSpineInfo
emptyAppSpineInfo = AppSpineInfo 0 unknownAppSpineVertebraeInfoL

asgiShift1SpinePos :: AppSpineInfo -> AppSpineInfo
asgiShift1SpinePos i = i {asgiSpinePos = asgiSpinePos i + 1}

asgiSpine :: AppSpineInfo -> [AppSpineVertebraeInfo]
asgiSpine i = drop (asgiSpinePos i) $ asgiVertebraeL i







type FitsIn' = FIOpts -> UID -> VarMp -> Ty -> Ty -> FIOut
type FitsIn = FIOpts -> UID -> VarMp -> Ty -> Ty -> (Ty,VarMp,ErrL)



fitsInLWith :: (FIOut -> FIOut -> FIOut) -> FitsIn' -> FIOpts -> UID -> VarMp -> TyL -> TyL -> ([FIOut],FIOut)
fitsInLWith foCmb elemFits opts uniq varmp tyl1 tyl2
  = (foL,fo)
  where ((_,fo),foL)
          = foldr  (\(t1,t2) ((u,foThr),foL)
                      -> let  (u',ue) = mkNewLevUID u
                              fo = elemFits opts ue (foVarMp foThr `varUpd` varmp) (foVarMp foThr `varUpd` t1) (foVarMp foThr `varUpd` t2)
                         in   ((u',foCmb fo foThr),fo:foL)
                   )
                   ((uniq,emptyFO),[])
            . zip tyl1
            $ tyl2


</pre>