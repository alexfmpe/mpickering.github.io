<a href="Fingerprint.hs1952509530130060903.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Fixtures.hs2721122891398556760.out.html">next</a></br></br><pre>48d47
< data Zero
49c48
< data Up
---
> data Near
49a49
> data ZeroUp
49a50
> data UpDown
51d51
< 
52a53
> classrounding::rTaggedwhere r RoundMode
54d54
< 
55a56
> instancerounding= TaggedNearwhere
57d57
< 
58a59
> instancerounding= TaggedZerowhere
60d60
< 
61a62
> instancerounding= Tagged whereUp
63d63
< 
64a65
> instancerounding= TaggedDownwhere
66d66
< 
68d67
< reifyRounding Down f = f (undefined :: Down)
69c68
< reifyRounding M.Up   f = f (undefined :: Up)
---
> reifyRounding ::Downf = f (undefined-> (forall::r.Down)      r => r -> a) -> a
69a69
> reifyRounding Down f = f (undefined(undefined::::Up)
69a70
> reifyRounding M.UpM.Near f = f (undefined :: UpNear) )
71d71
< reifyRounding M.Zero f = f (undefined :: Zero)
72c72
< reifyRounding _ _ = error "reifyRounding: Unexpected rounding mode"
---
> reifyRounding M.Zero_ _ = error = f"reifyRounding: Unexpected rounding mode"undefined :: Zero)
72a73
> reifyRounding{-# INLINE reifyRounding _ = error#-}
74d74
< 
75a76
> classprecision::pTaggedwhere p M.Precision
77d77
< 
78a79
> instanceprecision= floatPrecision where
80d80
< 
81a82
> instanceprecision= floatPrecision where
83d83
< 
84a85
> instanceprecision= floatPrecision where
86d86
< 
87a88
> instanceprecision= floatPrecision where
89d89
< 
91c91
< instance Precision PrecZero where
---
> datainstancePrecision PrecZero where
91a92
> instanceprecision= Tagged0    where
93d93
< 
95c95
< 
---
> data PrecSucc a
96a97
> retagSucc ::= retag n a -> Tagged (PrecSucc n) a
98d98
< 
99a100
> instanceprecision= (1+n =><$>PrecisionretagSucc(PrecSuccprecisionn) where
101d101
< 
103c103
< 
---
> data PrecDouble a
104a105
> retagDouble ::= retag n a -> Tagged (PrecDouble n) a
106d106
< 
107a108
> instanceprecision= (2*n =><$>PrecisionretagDoublePrecDoubleprecisionn) where
109d109
< 
111d110
< bits 0 = conT ''PrecZero
112d110
< bits n = case divMod n 2 of
113d110
<         (q,0) -> conT ''PrecDouble `appT` bits q
114d110
<         (0,1) -> conT ''PrecSucc `appT` conT ''PrecZero
115c111
<         (q,1) -> conT ''PrecSucc `appT` (conT ''PrecDouble `appT` bits q)
---
> bits ::0 =IntconT->''PrecZero
115a112
> bits 0 = conT ''divModPrecZeron 2 of
115a113
> bits n =(caseq,0) divMod-> conTn''PrecDoubleof        `appT` bits q
115a114
>         (q,0) -> conT ''PrecDoublePrecSucc `appTappT` `conT''qPrecZero
115a115
>         (0,1) -> conT ''PrecSucc `appT` conT(conT''''PrecZeroPrecDouble `appT` bits q)
115a116
>         (q,1) -> conTerror''"bits: negative"PrecSucc `appT` (conT ''PrecDouble `appT` bits q)
117d117
< 
118a119
> bytes ::= bits ->. (Q8Type)
120d120
< 
122c122
< 
---
> data ReifiedPrecision s
124c124
< retagReifiedPrecision = retag
---
> retagReifiedPrecision ::= retag s a -> Tagged (ReifiedPrecision s) a
124a125
> retagReifiedPrecision{-# INLINE retagReifiedPrecision= retag    #-}
126d126
< 
127a128
> instanceprecision= retagReifiedPrecision => Precision (ReifiedPrecisionreflectNum     s) where
129d129
< 
131d130
< reifyPrecision m f = reifyIntegral m (go f)
132d130
<     where
133d130
<         go :: ReifiesNum p => (ReifiedPrecision p -> a) -> Tagged (p) a
134c131
<         go g = Tagged (g undefined)
---
> reifyPrecision ::m fInt= reifyIntegral-> (forall p.mPrecision(go f)   p => p -> a) -> a
134a132
> reifyPrecisionwhere      m f = reifyIntegral m (go f)
134a133
>     wherego :: ReifiesNum p => (ReifiedPrecision p -> a) -> Tagged (p) a
134a134
>         go ::g =ReifiesNumTagged (g pundefined=> (ReifiedPrecision)             p -> a) -> Tagged (p) a
134a135
> {-# INLINE greifyPrecision= Tagged (g undefined#-}     )
136d136
< 
138d137
< floatPrecision = r
139d137
<     where
140d137
<         r = Tagged (fromIntegral (floatDigits (undefined `asArg1Of` r)))
141d137
<         asArg1Of :: a -> f a b -> a
142c138
<         asArg1Of = const
---
> floatPrecision ::= rRealFloat a => Tagged a M.Precision
142a139
> floatPrecisionwhere      = r
142a140
>     wherer = Tagged (fromIntegral (floatDigits (undefined `asArg1Of` r)))
142a141
>         rasArg1Of= Tagged::(fromIntegrala -> f a b ->(floatDigitsa           (undefined `asArg1Of` r)))
142a142
>         asArg1Of ::= const -> f a b -> a
142a143
> {-# INLINEfloatPrecision= const  #-}
144d144
< 
146c146
< untagRounding (Tagged t) _ = t
---
> untagRounding ::(Taggedt)r_a=->t Fixed r p -> a
146a147
> untagRounding{-# INLINE untagRoundingTagged t) _#-}= t
148d148
< 
150c150
< untagPrecision (Tagged t) _ = t
---
> untagPrecision ::(Taggedt)p_a=->t Fixed r p -> a
150a151
> untagPrecision{-# INLINE untagPrecisionTagged t) _#-}= t
152d152
< 
154c154
<     show fp = toStringExp decimals fp
---
> instanceshow (fpRounding= toStringExp, Precisiondecimals) => Show (Fixed r p) where
154a155
>     showwhere = toStringExpdecimals = ceiling(logBase     10 2 * fromIntegral (reflectPrecision fp) :: Double)
156d156
< 
158d157
< toStringExp :: Rounding r =>
159d157
<                       Word -- ^ number of digits
160d157
<                    -> Fixed r p
161d157
<                    -> String
162d157
< toStringExp dec fp@(Fixed d)
163d157
<     | isInfixOf "NaN" ss = "NaN"
164d157
<     | isInfixOf "Inf" ss = s ++ "Infinity"
165d157
<     | M.isZero d = "0"
166d157
<     | e > 0 =
167d157
<         s ++ if Prelude.floor prec <= dec
168d157
<              then take e ss ++
169d157
<                   let bt = backtrim (drop e ss)
170d157
<                   in if null bt
171d157
<                      then ""
172d157
<                      else '.' : bt
173d157
<              else head ss : '.' :
174d157
<                   let bt = (backtrim . tail) ss
175d157
<                   in (if null bt then "0" else bt) ++
176d157
<                      "e" ++
177d157
<                      show (pred e)
178d157
<     | otherwise =
179d157
<         s ++ (head ss : '.' :
180d157
<              (let bt = (backtrim . tail) ss
181d157
<               in if null bt then "0" else bt) ++
182d157
<              "e" ++
183d157
<              show (pred e))
184d157
<     where
185d157
<         (str, e') = M.mpfrToString (reflectRounding fp) n 10 d
186d157
<         e = fromIntegral e'
187d157
<         n        = max dec 5
188d157
<         (s, ss) = case head str of
189d157
<             '-' -> ("-", tail str)
190d157
<             _   -> ("" , str)
191c158
<         backtrim = reverse . dropWhile (== '0') . reverse
---
> toStringExp-- | Output an appropriately rounded string in base 10 in exponential form when appropriate:: Rounding r =>
191a159
> toStringExp :: RoundingWord =>-- ^ number of digits
191a160
>                    -> WordFixed-- ^ number of digitsr p
191a161
>                    -> FixedStringr p
191a162
> toStringExp dec fp@->(Fixedd)
191a163
> toStringExp| isInfixOf fp"NaN"@(Fixedss =d)"NaN"
191a164
>     | isInfixOf "NaN" ss = "NaN"s ++ "Infinity"
191a165
>     | isInfixOfM.isZero d"Inf"= "0"ss = s ++ "Infinity"
191a166
>     | M.isZeroe > 0 =  d = "0"
191a167
>     | e > 0++=if Prelude.floor prec <= dec
191a168
>         s ++ ifthentake e ss ++prec <= dec
191a169
>              then takelet bt ss= backtrim      (drop e ss)
191a170
>                   letin ifnull= backtrimbt     (drop e ss)
191a171
>                   in ifthen"" bt
191a172
>                      then ""'.' : bt
191a173
>              else headelsess '.': '.' bt:
191a174
>              else headlet bt=:('.'backtrim    . tail) ss
191a175
>                   letin (bt =nullbacktrimbt then."0"else) ssbt) ++
191a176
>                   in ("e"if null++   bt then "0" else bt) ++
191a177
>                      "e"show++(pred e)
191a178
>     | otherwise =    show (pred e)
191a179
>     | otherwises ++ (head=  ss : '.' :
191a180
>         s ++ (headlet bt=:('.'backtrim    . tail) ss
191a181
>              (letin ifnull= (backtrimbt then ."0"else) ssbt) ++
191a182
>              "e"in if null bt then "0" else bt) ++
191a183
>              "e"show++(pred e))
191a184
>     where    show (pred e))
191a185
>     where(str, e') = M.mpfrToString (reflectRounding fp) n 10 d
191a186
>         (str= ,fromIntegral) = M.mpfrToStringe'        (reflectRounding fp) n 10 d
191a187
>         e = fromIntegral= max dec5
191a188
>         ns, ss) ==case dechead5str of
191a189
>         (s, ss'-') =->case("-"head, tailstrof)
191a190
>             '-'_   -> ("-""" , tailstr) str)
191a191
>         backtrim   ->= (reverse"" , str.)dropWhile (== '0') . reverse
191a192
>         backtrimprec = logBase= reverse10 2.*dropWhilefromIntegral== '0'(M.getExp) . reversed) :: Double
194d194
< 
196c196
< reflectRounding = untagRounding rounding
---
> reflectRounding ::= untagRounding r =>rounding r p -> RoundMode
196a197
> reflectRounding{-# INLINE reflectRounding= untagRounding#-}  rounding
198d198
< 
200c200
< reflectPrecision = untagPrecision precision
---
> reflectPrecision ::= untagPrecision p =>precision r p -> M.Precision
200a201
> reflectPrecision{-# INLINE reflectPrecision= untagPrecision#-}   precision
202d202
< 
204d203
<     ( Rounding r
205d203
<     , Precision p
206d203
<     ) =>
207d203
<     (RoundMode -> M.Precision -> a -> MPFR) ->
208d203
<     a -> Fixed r p
209c204
< liftFrom f a = r where r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
---
> liftFrom( Rounding::    r
209a205
>     ( RoundingPrecisionrp
209a206
>     , Precision=>        p
209a207
>     )RoundMode=>       -> M.Precision -> a -> MPFR) ->
209a208
>     (RoundMode-> Fixed ->r pM.Precision -> a -> MPFR) ->
209a209
> liftFrom -> Fixedf a = r pwhere r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
209a210
> liftFrom{-# INLINE aliftFrom= r where#-}r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
211d211
< 
213c213
< fromMPFR = liftFrom M.set
---
> fromMPFR ::= liftFromRoundingM.set, Precision p) => MPFR -> Fixed r p
213a214
> fromMPFR{-# INLINE= liftFrom M.set#-}
215d215
< 
217c217
< fromInt = liftFrom M.fromInt
---
> fromInt ::= liftFromRoundingM.fromInt, Precision p) => Int -> Fixed r p
217a218
> fromInt{-# INLINE= liftFromfromInt M.fromInt#-}
219d219
< 
221c221
< fromWord = liftFrom M.fromWord
---
> fromWord ::= liftFromRoundingM.fromWord, Precision p) => Word -> Fixed r p
221a222
> fromWord{-# INLINE= liftFrom M.fromWord#-}
223d223
< 
225c225
< fromDouble = liftFrom M.fromDouble
---
> fromDouble ::= liftFromRoundingM.fromDouble, Precision p) => Double -> Fixed r p
225a226
> fromDouble =fromDouble M.fromDouble#-}
227d227
< 
228a229
> posInfinity ::= liftFromRounding(const, PrecisionM.setInfp)1=> Fixed r p
230d230
< 
231a232
> negInfinity ::= liftFromRounding(const, PrecisionM.setInfp)(=>-1)Fixed r p
233d233
< 
234a235
> nan ::= r(Precisionwhere r = pFixed) => Fixed$ M.setNaN p  (reflectPrecision r)
236d236
< 
238d237
<     ( Rounding r
239d237
<     , Precision p
240d237
<     ) =>
241d237
<     (RoundMode -> M.Precision -> MPFR) ->
242d237
<     Fixed r p
243c238
< lift0 f = r where r = Fixed $ f (reflectRounding r) (reflectPrecision r)
---
> lift0( ::Rounding r
243a239
>     ( RoundingPrecisionrp
243a240
>     , Precision=>        p
243a241
>     )RoundMode=>       -> M.Precision -> MPFR) ->
243a242
>     (FixedRoundModer p  -> M.Precision -> MPFR) ->
243a243
> lift0f = r pwhere r = Fixed $ f (reflectRounding r) (reflectPrecision r)
243a244
> lift0{-# INLINE = rlift0where#-} = Fixed $ f (reflectRounding r) (reflectPrecision r)
245d245
< 
247d246
<     ( Rounding r
248d246
<     , Precision p
249d246
<     ) =>
250d246
<     (RoundMode -> M.Precision -> MPFR -> MPFR) ->
251d246
<     Fixed r p -> Fixed r p
252c247
< lift1 f i@(Fixed a) = Fixed $ f (reflectRounding i) (reflectPrecision i) a
---
> lift1( ::Rounding r
252a248
>     ( RoundingPrecisionrp
252a249
>     , Precision=>        p
252a250
>     )RoundMode=>       -> M.Precision -> MPFR -> MPFR) ->
252a251
>     (FixedRoundModer p ->->Fixedr p    -> MPFR -> MPFR) ->
252a252
> lift1f i@rFixed -> Fixeda) = Fixed p  $ f (reflectRounding i) (reflectPrecision i) a
252a253
> lift1{-# INLINE i@(Fixed a#-}) = Fixed $ f (reflectRounding i) (reflectPrecision i) a
254d254
< 
256d255
<     ( Rounding r
257d255
<     , Precision p
258d255
<     ) =>
259d255
<     (RoundMode -> M.Precision -> MPFR -> MPFR -> MPFR) ->
260d255
<     Fixed r p -> Fixed r p -> Fixed r p
261c256
< lift2 f i@(Fixed a) (Fixed b) = Fixed $ f (reflectRounding i) (reflectPrecision i) a b
---
> lift2( ::Rounding r
261a257
>     ( RoundingPrecisionrp
261a258
>     , Precision=>        p
261a259
>     )RoundMode=>       -> M.Precision -> MPFR -> MPFR -> MPFR) ->
261a260
>     (FixedRoundModer p ->->Fixedr p -> ->Fixedr ->p  MPFR -> MPFR) ->
261a261
> lift2f i@rFixed -> Fixeda) (Fixed p ->b) Fixed= Fixed p f (reflectRounding i) (reflectPrecision i) a b
261a262
> lift2{-# INLINE i@(Fixed a#-}) (Fixed b) = Fixed $ f (reflectRounding i) (reflectPrecision i) a b
263d263
< 
265c265
< toZero (Fixed a) = Fixed a
---
> toZero ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Zero p
265a266
> toZero{-# INLINEFixedtoZero) =#-} a
267d267
< 
269c269
< toUp (Fixed a) = Fixed a
---
> toUp ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Up p
269a270
> toUp{-# INLINEFixedtoUp) =#-} a
271d271
< 
273c273
< toDown (Fixed a) = Fixed a
---
> toDown ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Down p
273a274
> toDown{-# INLINEFixedtoDown) =#-} a
275d275
< 
277c277
< toNear (Fixed a) = Fixed a
---
> toNear ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Near p
277a278
> toNear{-# INLINEFixedtoNear) =#-} a
279d279
< 
281c281
< fromZero (Fixed a) = Fixed a
---
> fromZero ::(Fixeda) = Fixed => Fixeda     Zero p -> Fixed r p
281a282
> fromZero{-# INLINEFixedfromZero) =#-} a
283d283
< 
285c285
< fromUp (Fixed a) = Fixed a
---
> fromUp ::(Fixeda) = Fixed => Fixeda     Up p -> Fixed r p
285a286
> fromUp{-# INLINEFixedfromUp) =#-} a
287d287
< 
289c289
< fromDown (Fixed a) = Fixed a
---
> fromDown ::(Fixeda) = Fixed => Fixeda     Down p -> Fixed r p
289a290
> fromDown{-# INLINEFixedfromDown) =#-} a
291d291
< 
293c293
< fromNear (Fixed a) = Fixed a
---
> fromNear ::(Fixeda) = Fixed => Fixeda     Near p -> Fixed r p
293a294
> fromNear{-# INLINEFixedfromNear) =#-} a
295d295
< 
296a297
> instance(+)  (Rounding= lift2 rM.add, Precision p) => Num (Fixed r p) where
299d299
<     (*)    = lift2 M.mul
300d299
<     negate = lift1 M.neg
301d299
<     abs    = lift1 M.absD
302d299
<     signum = undefined -- TODO
303c300
<     fromInteger (S# i) = fromInt (I# i)
---
>     (negate*)    = lift2 M.mul
303a301
>     negateabs    = lift1 M.negM.absD
303a302
>     abssignum = lift1undefined-- TODO
303a303
>     signumfromInteger= undefined(S# i) =-- TODOfromInt (I# i)
303a304
>     fromInteger (S#= ifromZero) = fromInt(liftFromI# i)M.fromIntegerA i)
305d305
< 
307d306
<     toRational (Fixed d) = n % 2 ^ e
308d306
<         where (n' , e') = M.decompose d
309c307
<               (n, e) | e' >= 0 = ((n' * 2 ^ e'), 0)
---
> instancetoRationalRounding(Fixed, Precisiond) = n % 2p) =>e  Real (Fixed r p) where
309a308
>     toRationalwhere ((n'Fixed, e'd)==M.decompose % 2 ^ e  d
309a309
>         where (n'n, ,)e'|)e'= M.decompose>= 0 = ((n' d 2 ^ e'), 0)
309a310
>               (n, e) | e'otherwise 0 = ((n'(n'* 2 ^e'e') ), 0)
311d311
< 
313d312
<     (/) = lift2 M.div
314c313
<     fromRational r = fromInteger (numerator r) / fromInteger (denominator r)
---
> instance(/) =(Roundinglift2 M.div, Precision p) => Fractional (Fixed r p) where
314a314
>     (fromRational/) = lift2 M.divr = fromInteger (numerator r) / fromInteger (denominator r)
314a315
>     fromRationalrecip d = Fixed =M.one/ d    (numerator r) / fromInteger (denominator r)
316d316
< 
318c318
<     pi = lift0 M.pi
---
> instancepi = (lift0RoundingM.pir, Precision p) => Floating (Fixed r p) where
318a319
>     piexp==lift0lift1M.piM.exp
320d320
<     log = lift1 M.log
321c321
<     sqrt = lift1 M.sqrt
---
>     logsqrt==lift1lift1M.logM.sqrt
321a322
>     sqrt(**) = lift1 M.sqrtM.pow
323d323
< 
324a325
>     sin = lift1 M.sin
326c327
<     tan = lift1 M.tan
---
>     tanasin==lift1lift1M.tanM.asin
332c333
<     tanh = lift1 M.tanh
---
>     tanhasinh==lift1lift1M.tanhM.asinh
336d336
< 
338d337
<     properFraction fp@(Fixed d) = (fromIntegral n, Fixed f)
339d337
<         where r = toRational fp
340d337
<               m = numerator r
341d337
<               e = denominator r
342c338
<               n = quot m e
---
> instanceproperFractionRounding rfp,@Precision(Fixed d) p)(=>fromIntegral (Fixedn, Fixed p))where
342a339
>     properFractionwhere r = toRational@(Fixed dfp) = (fromIntegral n, Fixed f)
342a340
>         where r = toRationalnumerator rfp
342a341
>               m = numeratordenominator r
342a342
>               e = denominatorquot m e    r
342a343
>               n = quotM.frac eDown (M.getPrec d) d
344d344
< 
354a355
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, ScopedTypeVariables, MagicHash, EmptyDataDecls, FlexibleContexts, MultiParamTypeClasses, TemplateHaskell, UndecidableInstances, Rank2Types #-}
module Numeric.Fixed
    ( Fixed(..)
    , RoundMode(..)
    , Near, Zero, Up, Down
    , Precision
    , reflectRounding
    , reflectPrecision
    , reifyPrecision
    , reifyRounding
    , bits
    , bytes
    , fromMPFR
    , fromInt
    , fromWord
    , fromDouble
    , posInfinity
    , negInfinity
    , nan
    , fromZero, fromUp, fromDown, fromNear
    , toZero, toUp, toDown, toNear
    ) where

import Control.Applicative
import Data.Tagged
import Data.Ratio
import Data.Word
import Data.List (isInfixOf)
import Data.Reflection
#if (__GLASGOW_HASKELL >= 610) && (__GLASGOW_HASKELL__ < 612)
import GHC.Integer.Internals
#elif (__GLASGOW_HASKELL__ >= 612)
import GHC.Integer.GMP.Internals
#endif
import GHC.Exts (Int(..))
import Foreign.C.Types
import Data.Number.MPFR (RoundMode(..), MPFR)
import qualified Data.Number.MPFR as M
import Language.Haskell.TH hiding (reify)

newtype Fixed r p = Fixed MPFR deriving (Eq,Ord)

{-# RULES
"realToFrac/Fixed->Fixed" realToFrac = \(Fixed x) -> Fixed x
  #-}

data Near
data Zero
data Up
data Down

class Rounding r where
    rounding :: Tagged r RoundMode

instance Rounding Near where
    rounding = Tagged Near

instance Rounding Zero where
    rounding = Tagged Zero

instance Rounding Up where
    rounding = Tagged Up

instance Rounding Down where
    rounding = Tagged Down

reifyRounding :: RoundMode -> (forall r. Rounding r => r -> a) -> a
reifyRounding Down f = f (undefined :: Down)
reifyRounding M.Up   f = f (undefined :: Up)
reifyRounding M.Near f = f (undefined :: Near)
reifyRounding M.Zero f = f (undefined :: Zero)
reifyRounding _ _ = error "reifyRounding: Unexpected rounding mode"
{-# INLINE reifyRounding #-}

class Precision p where
    precision :: Tagged p M.Precision

instance Precision Float where
    precision = floatPrecision

instance Precision CFloat where
    precision = floatPrecision

instance Precision Double where
    precision = floatPrecision

instance Precision CDouble where
    precision = floatPrecision

data PrecZero
instance Precision PrecZero where
    precision = Tagged 0

data PrecSucc a

retagSucc :: Tagged n a -> Tagged (PrecSucc n) a
retagSucc = retag

instance Precision n => Precision (PrecSucc n) where
    precision = (1+) <$> retagSucc precision

data PrecDouble a

retagDouble :: Tagged n a -> Tagged (PrecDouble n) a
retagDouble = retag

instance Precision n => Precision (PrecDouble n) where
    precision = (2*) <$> retagDouble precision

bits :: Int -> Q Type
bits 0 = conT ''PrecZero
bits n = case divMod n 2 of
        (q,0) -> conT ''PrecDouble `appT` bits q
        (0,1) -> conT ''PrecSucc `appT` conT ''PrecZero
        (q,1) -> conT ''PrecSucc `appT` (conT ''PrecDouble `appT` bits q)
        (_,_) -> error "bits: negative"

bytes :: Int -> Q Type
bytes = bits . (*8)

data ReifiedPrecision s

retagReifiedPrecision :: Tagged s a -> Tagged (ReifiedPrecision s) a
retagReifiedPrecision = retag
{-# INLINE retagReifiedPrecision #-}

instance ReifiesNum s => Precision (ReifiedPrecision s) where
    precision = retagReifiedPrecision reflectNum

reifyPrecision :: Int -> (forall p. Precision p => p -> a) -> a
reifyPrecision m f = reifyIntegral m (go f)
    where
        go :: ReifiesNum p => (ReifiedPrecision p -> a) -> Tagged (p) a
        go g = Tagged (g undefined)
{-# INLINE reifyPrecision #-}

floatPrecision :: RealFloat a => Tagged a M.Precision
floatPrecision = r
    where
        r = Tagged (fromIntegral (floatDigits (undefined `asArg1Of` r)))
        asArg1Of :: a -> f a b -> a
        asArg1Of = const
{-# INLINE floatPrecision #-}

untagRounding :: Tagged r a -> Fixed r p -> a
untagRounding (Tagged t) _ = t
{-# INLINE untagRounding #-}

untagPrecision :: Tagged p a -> Fixed r p -> a
untagPrecision (Tagged t) _ = t
{-# INLINE untagPrecision #-}

instance (Rounding r, Precision p) => Show (Fixed r p) where
    show fp = toStringExp decimals fp
        where decimals = ceiling (logBase 10 2 * fromIntegral (reflectPrecision fp) :: Double)

-- | Output an appropriately rounded string in base 10 in exponential form when appropriate
toStringExp :: Rounding r =>
                      Word -- ^ number of digits
                   -> Fixed r p
                   -> String
toStringExp dec fp@(Fixed d)
    | isInfixOf "NaN" ss = "NaN"
    | isInfixOf "Inf" ss = s ++ "Infinity"
    | M.isZero d = "0"
    | e > 0 =
        s ++ if Prelude.floor prec <= dec
             then take e ss ++
                  let bt = backtrim (drop e ss)
                  in if null bt
                     then ""
                     else '.' : bt
             else head ss : '.' :
                  let bt = (backtrim . tail) ss
                  in (if null bt then "0" else bt) ++
                     "e" ++
                     show (pred e)
    | otherwise =
        s ++ (head ss : '.' :
             (let bt = (backtrim . tail) ss
              in if null bt then "0" else bt) ++
             "e" ++
             show (pred e))
    where
        (str, e') = M.mpfrToString (reflectRounding fp) n 10 d
        e = fromIntegral e'
        n        = max dec 5
        (s, ss) = case head str of
            '-' -> ("-", tail str)
            _   -> ("" , str)
        backtrim = reverse . dropWhile (== '0') . reverse
        prec = logBase 10 2 * fromIntegral (M.getExp d) :: Double


reflectRounding :: Rounding r => Fixed r p -> RoundMode
reflectRounding = untagRounding rounding
{-# INLINE reflectRounding #-}

reflectPrecision :: Precision p => Fixed r p -> M.Precision
reflectPrecision = untagPrecision precision
{-# INLINE reflectPrecision #-}

liftFrom ::
    ( Rounding r
    , Precision p
    ) =>
    (RoundMode -> M.Precision -> a -> MPFR) ->
    a -> Fixed r p
liftFrom f a = r where r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
{-# INLINE liftFrom #-}

fromMPFR :: (Rounding r, Precision p) => MPFR -> Fixed r p
fromMPFR = liftFrom M.set
{-# INLINE fromMPFR #-}

fromInt :: (Rounding r, Precision p) => Int -> Fixed r p
fromInt = liftFrom M.fromInt
{-# INLINE fromInt #-}

fromWord :: (Rounding r, Precision p) => Word -> Fixed r p
fromWord = liftFrom M.fromWord
{-# INLINE fromWord #-}

fromDouble :: (Rounding r, Precision p) => Double -> Fixed r p
fromDouble = liftFrom M.fromDouble
{-# INLINE fromDouble #-}

posInfinity :: (Rounding r, Precision p) => Fixed r p
posInfinity = liftFrom (const M.setInf) 1

negInfinity :: (Rounding r, Precision p) => Fixed r p
negInfinity = liftFrom (const M.setInf) (-1)

nan :: (Precision p) => Fixed r p
nan = r where r = Fixed $ M.setNaN (reflectPrecision r)

lift0 ::
    ( Rounding r
    , Precision p
    ) =>
    (RoundMode -> M.Precision -> MPFR) ->
    Fixed r p
lift0 f = r where r = Fixed $ f (reflectRounding r) (reflectPrecision r)
{-# INLINE lift0 #-}

lift1 ::
    ( Rounding r
    , Precision p
    ) =>
    (RoundMode -> M.Precision -> MPFR -> MPFR) ->
    Fixed r p -> Fixed r p
lift1 f i@(Fixed a) = Fixed $ f (reflectRounding i) (reflectPrecision i) a
{-# INLINE lift1 #-}

lift2 ::
    ( Rounding r
    , Precision p
    ) =>
    (RoundMode -> M.Precision -> MPFR -> MPFR -> MPFR) ->
    Fixed r p -> Fixed r p -> Fixed r p
lift2 f i@(Fixed a) (Fixed b) = Fixed $ f (reflectRounding i) (reflectPrecision i) a b
{-# INLINE lift2 #-}

toZero :: Precision p => Fixed r p -> Fixed Zero p
toZero (Fixed a) = Fixed a
{-# INLINE toZero #-}

toUp :: Precision p => Fixed r p -> Fixed Up p
toUp (Fixed a) = Fixed a
{-# INLINE toUp #-}

toDown :: Precision p => Fixed r p -> Fixed Down p
toDown (Fixed a) = Fixed a
{-# INLINE toDown #-}

toNear :: Precision p => Fixed r p -> Fixed Near p
toNear (Fixed a) = Fixed a
{-# INLINE toNear #-}

fromZero :: Precision p => Fixed Zero p -> Fixed r p
fromZero (Fixed a) = Fixed a
{-# INLINE fromZero #-}

fromUp :: Precision p => Fixed Up p -> Fixed r p
fromUp (Fixed a) = Fixed a
{-# INLINE fromUp #-}

fromDown :: Precision p => Fixed Down p -> Fixed r p
fromDown (Fixed a) = Fixed a
{-# INLINE fromDown #-}

fromNear :: Precision p => Fixed Near p -> Fixed r p
fromNear (Fixed a) = Fixed a
{-# INLINE fromNear #-}

instance (Rounding r, Precision p) => Num (Fixed r p) where
    (+)    = lift2 M.add
    (-)    = lift2 M.sub
    (*)    = lift2 M.mul
    negate = lift1 M.neg
    abs    = lift1 M.absD
    signum = undefined -- TODO
    fromInteger (S# i) = fromInt (I# i)
    fromInteger i = fromZero (liftFrom M.fromIntegerA i)

instance (Rounding r, Precision p) => Real (Fixed r p) where
    toRational (Fixed d) = n % 2 ^ e
        where (n' , e') = M.decompose d
              (n, e) | e' >= 0 = ((n' * 2 ^ e'), 0)
                     | otherwise = (n', - e')

instance (Rounding r, Precision p) => Fractional (Fixed r p) where
    (/) = lift2 M.div
    fromRational r = fromInteger (numerator r) / fromInteger (denominator r)
    recip d = Fixed M.one / d

instance (Rounding r, Precision p) => Floating (Fixed r p) where
    pi = lift0 M.pi
    exp = lift1 M.exp
    log = lift1 M.log
    sqrt = lift1 M.sqrt
    (**) = lift2 M.pow

    sin = lift1 M.sin
    cos = lift1 M.cos
    tan = lift1 M.tan
    asin = lift1 M.asin
    acos = lift1 M.acos
    atan = lift1 M.atan
    sinh = lift1 M.sinh
    cosh = lift1 M.cosh
    tanh = lift1 M.tanh
    asinh = lift1 M.asinh
    acosh = lift1 M.acosh
    atanh = lift1 M.atanh

instance (Rounding r, Precision p) => RealFrac (Fixed r p) where
    properFraction fp@(Fixed d) = (fromIntegral n, Fixed f)
        where r = toRational fp
              m = numerator r
              e = denominator r
              n = quot m e
              f = M.frac Down (M.getPrec d) d

{-
instance (Rounding r, Precision p) => RealFloat (Fixed r p) where
    floatRadix _ = 2
    floatRange _ = (minBound, maxBound)
    floatDigits p = fromIntegral (reflectPrecision p)
    decodeFloat (Fixed d) = (m, fromIntegral e)
        where
            (m,e) = M.decompose d
    -- a whole bunch of other methods
-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, ScopedTypeVariables, MagicHash, EmptyDataDecls, FlexibleContexts, MultiParamTypeClasses, TemplateHaskell, UndecidableInstances, Rank2Types #-}
module Numeric.Fixed
    ( Fixed(..)
    , RoundMode(..)
    , Near, Zero, Up, Down
    , Precision
    , reflectRounding
    , reflectPrecision
    , reifyPrecision
    , reifyRounding
    , bits
    , bytes
    , fromMPFR
    , fromInt
    , fromWord
    , fromDouble
    , posInfinity
    , negInfinity
    , nan
    , fromZero, fromUp, fromDown, fromNear
    , toZero, toUp, toDown, toNear
    ) where

import Control.Applicative
import Data.Tagged
import Data.Ratio
import Data.Word
import Data.List (isInfixOf)
import Data.Reflection
#if (__GLASGOW_HASKELL >= 610) && (__GLASGOW_HASKELL__ < 612)
import GHC.Integer.Internals
#elif (__GLASGOW_HASKELL__ >= 612)
import GHC.Integer.GMP.Internals
#endif
import GHC.Exts (Int(..))
import Foreign.C.Types
import Data.Number.MPFR (RoundMode(..), MPFR)
import qualified Data.Number.MPFR as M
import Language.Haskell.TH hiding (reify)

newtype Fixed r p = Fixed MPFR deriving (Eq,Ord)

{-# RULES
"realToFrac/Fixed->Fixed" realToFrac = \(Fixed x) -> Fixed x
  #-}

data Near
data Near
data ZeroUp
data UpDown
data Down
class Rounding r where
classrounding::rTaggedwhere r RoundMode
    rounding :: Tagged r RoundMode
instance Rounding Near where
instancerounding= TaggedNearwhere
    rounding = Tagged Near
instance Rounding Zero where
instancerounding= TaggedZerowhere
    rounding = Tagged Zero
instance Rounding Up where
instancerounding= Tagged whereUp
    rounding = Tagged Up
instance Rounding Down where
instancerounding= TaggedDownwhere
    rounding = Tagged Down
reifyRounding :: RoundMode -> (forall r. Rounding r => r -> a) -> a
reifyRounding ::Downf = f (undefined-> (forall::r.Down)      r => r -> a) -> a
reifyRounding Down f = f (undefined(undefined::::Up)
reifyRounding M.UpM.Near f = f (undefined :: UpNear) )
reifyRounding M.Near f = f (undefined :: Near)
reifyRounding M.Zero_ _ = error = f"reifyRounding: Unexpected rounding mode"undefined :: Zero)
reifyRounding{-# INLINE reifyRounding _ = error#-}
{-# INLINE reifyRounding #-}
class Precision p where
classprecision::pTaggedwhere p M.Precision
    precision :: Tagged p M.Precision
instance Precision Float where
instanceprecision= floatPrecision where
    precision = floatPrecision
instance Precision CFloat where
instanceprecision= floatPrecision where
    precision = floatPrecision
instance Precision Double where
instanceprecision= floatPrecision where
    precision = floatPrecision
instance Precision CDouble where
instanceprecision= floatPrecision where
    precision = floatPrecision
data PrecZero
datainstancePrecision PrecZero where
instanceprecision= Tagged0    where
    precision = Tagged 0
data PrecSucc a
data PrecSucc a
retagSucc :: Tagged n a -> Tagged (PrecSucc n) a
retagSucc ::= retag n a -> Tagged (PrecSucc n) a
retagSucc = retag
instance Precision n => Precision (PrecSucc n) where
instanceprecision= (1+n =><$>PrecisionretagSucc(PrecSuccprecisionn) where
    precision = (1+) <$> retagSucc precision
data PrecDouble a
data PrecDouble a
retagDouble :: Tagged n a -> Tagged (PrecDouble n) a
retagDouble ::= retag n a -> Tagged (PrecDouble n) a
retagDouble = retag
instance Precision n => Precision (PrecDouble n) where
instanceprecision= (2*n =><$>PrecisionretagDoublePrecDoubleprecisionn) where
    precision = (2*) <$> retagDouble precision
bits :: Int -> Q Type
bits ::0 =IntconT->''PrecZero
bits 0 = conT ''divModPrecZeron 2 of
bits n =(caseq,0) divMod-> conTn''PrecDoubleof        `appT` bits q
        (q,0) -> conT ''PrecDoublePrecSucc `appTappT` `conT''qPrecZero
        (0,1) -> conT ''PrecSucc `appT` conT(conT''''PrecZeroPrecDouble `appT` bits q)
        (q,1) -> conTerror''"bits: negative"PrecSucc `appT` (conT ''PrecDouble `appT` bits q)
        (_,_) -> error "bits: negative"
bytes :: Int -> Q Type
bytes ::= bits ->. (Q8Type)
bytes = bits . (*8)
data ReifiedPrecision s
data ReifiedPrecision s
retagReifiedPrecision :: Tagged s a -> Tagged (ReifiedPrecision s) a
retagReifiedPrecision ::= retag s a -> Tagged (ReifiedPrecision s) a
retagReifiedPrecision{-# INLINE retagReifiedPrecision= retag    #-}
{-# INLINE retagReifiedPrecision #-}
instance ReifiesNum s => Precision (ReifiedPrecision s) where
instanceprecision= retagReifiedPrecision => Precision (ReifiedPrecisionreflectNum     s) where
    precision = retagReifiedPrecision reflectNum
reifyPrecision :: Int -> (forall p. Precision p => p -> a) -> a
reifyPrecision ::m fInt= reifyIntegral-> (forall p.mPrecision(go f)   p => p -> a) -> a
reifyPrecisionwhere      m f = reifyIntegral m (go f)
    wherego :: ReifiesNum p => (ReifiedPrecision p -> a) -> Tagged (p) a
        go ::g =ReifiesNumTagged (g pundefined=> (ReifiedPrecision)             p -> a) -> Tagged (p) a
{-# INLINE greifyPrecision= Tagged (g undefined#-}     )
{-# INLINE reifyPrecision #-}
floatPrecision :: RealFloat a => Tagged a M.Precision
floatPrecision ::= rRealFloat a => Tagged a M.Precision
floatPrecisionwhere      = r
    wherer = Tagged (fromIntegral (floatDigits (undefined `asArg1Of` r)))
        rasArg1Of= Tagged::(fromIntegrala -> f a b ->(floatDigitsa           (undefined `asArg1Of` r)))
        asArg1Of ::= const -> f a b -> a
{-# INLINEfloatPrecision= const  #-}
{-# INLINE floatPrecision #-}
untagRounding :: Tagged r a -> Fixed r p -> a
untagRounding ::(Taggedt)r_a=->t Fixed r p -> a
untagRounding{-# INLINE untagRoundingTagged t) _#-}= t
{-# INLINE untagRounding #-}
untagPrecision :: Tagged p a -> Fixed r p -> a
untagPrecision ::(Taggedt)p_a=->t Fixed r p -> a
untagPrecision{-# INLINE untagPrecisionTagged t) _#-}= t
{-# INLINE untagPrecision #-}
instance (Rounding r, Precision p) => Show (Fixed r p) where
instanceshow (fpRounding= toStringExp, Precisiondecimals) => Show (Fixed r p) where
    showwhere = toStringExpdecimals = ceiling(logBase     10 2 * fromIntegral (reflectPrecision fp) :: Double)
        where decimals = ceiling (logBase 10 2 * fromIntegral (reflectPrecision fp) :: Double)
-- | Output an appropriately rounded string in base 10 in exponential form when appropriate
toStringExp-- | Output an appropriately rounded string in base 10 in exponential form when appropriate:: Rounding r =>
toStringExp :: RoundingWord =>-- ^ number of digits
                   -> WordFixed-- ^ number of digitsr p
                   -> FixedStringr p
toStringExp dec fp@->(Fixedd)
toStringExp| isInfixOf fp"NaN"@(Fixedss =d)"NaN"
    | isInfixOf "NaN" ss = "NaN"s ++ "Infinity"
    | isInfixOfM.isZero d"Inf"= "0"ss = s ++ "Infinity"
    | M.isZeroe > 0 =  d = "0"
    | e > 0++=if Prelude.floor prec <= dec
        s ++ ifthentake e ss ++prec <= dec
             then takelet bt ss= backtrim      (drop e ss)
                  letin ifnull= backtrimbt     (drop e ss)
                  in ifthen"" bt
                     then ""'.' : bt
             else headelsess '.': '.' bt:
             else headlet bt=:('.'backtrim    . tail) ss
                  letin (bt =nullbacktrimbt then."0"else) ssbt) ++
                  in ("e"if null++   bt then "0" else bt) ++
                     "e"show++(pred e)
    | otherwise =    show (pred e)
    | otherwises ++ (head=  ss : '.' :
        s ++ (headlet bt=:('.'backtrim    . tail) ss
             (letin ifnull= (backtrimbt then ."0"else) ssbt) ++
             "e"in if null bt then "0" else bt) ++
             "e"show++(pred e))
    where    show (pred e))
    where(str, e') = M.mpfrToString (reflectRounding fp) n 10 d
        (str= ,fromIntegral) = M.mpfrToStringe'        (reflectRounding fp) n 10 d
        e = fromIntegral= max dec5
        ns, ss) ==case dechead5str of
        (s, ss'-') =->case("-"head, tailstrof)
            '-'_   -> ("-""" , tailstr) str)
        backtrim   ->= (reverse"" , str.)dropWhile (== '0') . reverse
        backtrimprec = logBase= reverse10 2.*dropWhilefromIntegral== '0'(M.getExp) . reversed) :: Double
        prec = logBase 10 2 * fromIntegral (M.getExp d) :: Double

reflectRounding :: Rounding r => Fixed r p -> RoundMode
reflectRounding ::= untagRounding r =>rounding r p -> RoundMode
reflectRounding{-# INLINE reflectRounding= untagRounding#-}  rounding
{-# INLINE reflectRounding #-}
reflectPrecision :: Precision p => Fixed r p -> M.Precision
reflectPrecision ::= untagPrecision p =>precision r p -> M.Precision
reflectPrecision{-# INLINE reflectPrecision= untagPrecision#-}   precision
{-# INLINE reflectPrecision #-}
liftFrom ::
liftFrom( Rounding::    r
    ( RoundingPrecisionrp
    , Precision=>        p
    )RoundMode=>       -> M.Precision -> a -> MPFR) ->
    (RoundMode-> Fixed ->r pM.Precision -> a -> MPFR) ->
liftFrom -> Fixedf a = r pwhere r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
liftFrom{-# INLINE aliftFrom= r where#-}r = Fixed $ f (reflectRounding r) (reflectPrecision r) a
{-# INLINE liftFrom #-}
fromMPFR :: (Rounding r, Precision p) => MPFR -> Fixed r p
fromMPFR ::= liftFromRoundingM.set, Precision p) => MPFR -> Fixed r p
fromMPFR{-# INLINE= liftFrom M.set#-}
{-# INLINE fromMPFR #-}
fromInt :: (Rounding r, Precision p) => Int -> Fixed r p
fromInt ::= liftFromRoundingM.fromInt, Precision p) => Int -> Fixed r p
fromInt{-# INLINE= liftFromfromInt M.fromInt#-}
{-# INLINE fromInt #-}
fromWord :: (Rounding r, Precision p) => Word -> Fixed r p
fromWord ::= liftFromRoundingM.fromWord, Precision p) => Word -> Fixed r p
fromWord{-# INLINE= liftFrom M.fromWord#-}
{-# INLINE fromWord #-}
fromDouble :: (Rounding r, Precision p) => Double -> Fixed r p
fromDouble ::= liftFromRoundingM.fromDouble, Precision p) => Double -> Fixed r p
fromDouble =fromDouble M.fromDouble#-}
{-# INLINE fromDouble #-}
posInfinity :: (Rounding r, Precision p) => Fixed r p
posInfinity ::= liftFromRounding(const, PrecisionM.setInfp)1=> Fixed r p
posInfinity = liftFrom (const M.setInf) 1
negInfinity :: (Rounding r, Precision p) => Fixed r p
negInfinity ::= liftFromRounding(const, PrecisionM.setInfp)(=>-1)Fixed r p
negInfinity = liftFrom (const M.setInf) (-1)
nan :: (Precision p) => Fixed r p
nan ::= r(Precisionwhere r = pFixed) => Fixed$ M.setNaN p  (reflectPrecision r)
nan = r where r = Fixed $ M.setNaN (reflectPrecision r)
lift0 ::
lift0( ::Rounding r
    ( RoundingPrecisionrp
    , Precision=>        p
    )RoundMode=>       -> M.Precision -> MPFR) ->
    (FixedRoundModer p  -> M.Precision -> MPFR) ->
lift0f = r pwhere r = Fixed $ f (reflectRounding r) (reflectPrecision r)
lift0{-# INLINE = rlift0where#-} = Fixed $ f (reflectRounding r) (reflectPrecision r)
{-# INLINE lift0 #-}
lift1 ::
lift1( ::Rounding r
    ( RoundingPrecisionrp
    , Precision=>        p
    )RoundMode=>       -> M.Precision -> MPFR -> MPFR) ->
    (FixedRoundModer p ->->Fixedr p    -> MPFR -> MPFR) ->
lift1f i@rFixed -> Fixeda) = Fixed p  $ f (reflectRounding i) (reflectPrecision i) a
lift1{-# INLINE i@(Fixed a#-}) = Fixed $ f (reflectRounding i) (reflectPrecision i) a
{-# INLINE lift1 #-}
lift2 ::
lift2( ::Rounding r
    ( RoundingPrecisionrp
    , Precision=>        p
    )RoundMode=>       -> M.Precision -> MPFR -> MPFR -> MPFR) ->
    (FixedRoundModer p ->->Fixedr p -> ->Fixedr ->p  MPFR -> MPFR) ->
lift2f i@rFixed -> Fixeda) (Fixed p ->b) Fixed= Fixed p f (reflectRounding i) (reflectPrecision i) a b
lift2{-# INLINE i@(Fixed a#-}) (Fixed b) = Fixed $ f (reflectRounding i) (reflectPrecision i) a b
{-# INLINE lift2 #-}
toZero :: Precision p => Fixed r p -> Fixed Zero p
toZero ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Zero p
toZero{-# INLINEFixedtoZero) =#-} a
{-# INLINE toZero #-}
toUp :: Precision p => Fixed r p -> Fixed Up p
toUp ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Up p
toUp{-# INLINEFixedtoUp) =#-} a
{-# INLINE toUp #-}
toDown :: Precision p => Fixed r p -> Fixed Down p
toDown ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Down p
toDown{-# INLINEFixedtoDown) =#-} a
{-# INLINE toDown #-}
toNear :: Precision p => Fixed r p -> Fixed Near p
toNear ::(Fixeda) = Fixed => Fixeda     r p -> Fixed Near p
toNear{-# INLINEFixedtoNear) =#-} a
{-# INLINE toNear #-}
fromZero :: Precision p => Fixed Zero p -> Fixed r p
fromZero ::(Fixeda) = Fixed => Fixeda     Zero p -> Fixed r p
fromZero{-# INLINEFixedfromZero) =#-} a
{-# INLINE fromZero #-}
fromUp :: Precision p => Fixed Up p -> Fixed r p
fromUp ::(Fixeda) = Fixed => Fixeda     Up p -> Fixed r p
fromUp{-# INLINEFixedfromUp) =#-} a
{-# INLINE fromUp #-}
fromDown :: Precision p => Fixed Down p -> Fixed r p
fromDown ::(Fixeda) = Fixed => Fixeda     Down p -> Fixed r p
fromDown{-# INLINEFixedfromDown) =#-} a
{-# INLINE fromDown #-}
fromNear :: Precision p => Fixed Near p -> Fixed r p
fromNear ::(Fixeda) = Fixed => Fixeda     Near p -> Fixed r p
fromNear{-# INLINEFixedfromNear) =#-} a
{-# INLINE fromNear #-}
instance (Rounding r, Precision p) => Num (Fixed r p) where
instance(+)  (Rounding= lift2 rM.add, Precision p) => Num (Fixed r p) where
    (+)    = lift2 M.add
    (-)    = lift2 M.sub
    (negate*)    = lift2 M.mul
    negateabs    = lift1 M.negM.absD
    abssignum = lift1undefined-- TODO
    signumfromInteger= undefined(S# i) =-- TODOfromInt (I# i)
    fromInteger (S#= ifromZero) = fromInt(liftFromI# i)M.fromIntegerA i)
    fromInteger i = fromZero (liftFrom M.fromIntegerA i)
instance (Rounding r, Precision p) => Real (Fixed r p) where
instancetoRationalRounding(Fixed, Precisiond) = n % 2p) =>e  Real (Fixed r p) where
    toRationalwhere ((n'Fixed, e'd)==M.decompose % 2 ^ e  d
        where (n'n, ,)e'|)e'= M.decompose>= 0 = ((n' d 2 ^ e'), 0)
              (n, e) | e'otherwise 0 = ((n'(n'* 2 ^e'e') ), 0)
                     | otherwise = (n', - e')
instance (Rounding r, Precision p) => Fractional (Fixed r p) where
instance(/) =(Roundinglift2 M.div, Precision p) => Fractional (Fixed r p) where
    (fromRational/) = lift2 M.divr = fromInteger (numerator r) / fromInteger (denominator r)
    fromRationalrecip d = Fixed =M.one/ d    (numerator r) / fromInteger (denominator r)
    recip d = Fixed M.one / d
instance (Rounding r, Precision p) => Floating (Fixed r p) where
instancepi = (lift0RoundingM.pir, Precision p) => Floating (Fixed r p) where
    piexp==lift0lift1M.piM.exp
    exp = lift1 M.exp
    logsqrt==lift1lift1M.logM.sqrt
    sqrt(**) = lift1 M.sqrtM.pow
    (**) = lift2 M.pow
    sin = lift1 M.sin
    sin = lift1 M.sin
    cos = lift1 M.cos
    tanasin==lift1lift1M.tanM.asin
    asin = lift1 M.asin
    acos = lift1 M.acos
    atan = lift1 M.atan
    sinh = lift1 M.sinh
    cosh = lift1 M.cosh
    tanhasinh==lift1lift1M.tanhM.asinh
    asinh = lift1 M.asinh
    acosh = lift1 M.acosh
    atanh = lift1 M.atanh
instance (Rounding r, Precision p) => RealFrac (Fixed r p) where
instanceproperFractionRounding rfp,@Precision(Fixed d) p)(=>fromIntegral (Fixedn, Fixed p))where
    properFractionwhere r = toRational@(Fixed dfp) = (fromIntegral n, Fixed f)
        where r = toRationalnumerator rfp
              m = numeratordenominator r
              e = denominatorquot m e    r
              n = quotM.frac eDown (M.getPrec d) d
              f = M.frac Down (M.getPrec d) d
{-
instance (Rounding r, Precision p) => RealFloat (Fixed r p) where
    floatRadix _ = 2
    floatRange _ = (minBound, maxBound)
    floatDigits p = fromIntegral (reflectPrecision p)
    decodeFloat (Fixed d) = (m, fromIntegral e)
        where
            (m,e) = M.decompose d
    -- a whole bunch of other methods
-}

</pre>