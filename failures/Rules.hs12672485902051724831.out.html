<a href="Rules.hs1194314738318153057.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Rules.hs1622650073984943658.out.html">next</a></br></br><pre>12c12
< ruleS ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> ruleS :: (View [Port] n, View SKI n) => Rule n
14d13
<     S {inp = si} ← node
15c14
<     Applicator {inp = i1, out1 = o1, out2 = f} ← nodeWith si
---
>     S {inp = si} <- node
15a15
>     Applicator {inp = i1, out1 = o1, out2 = f} <- nodeWith si
17c17
<     Applicator {inp = i2, out1 = o2, out2 = g} ← nodeWith i1
---
>     Applicator {inp = i2, out1 = o2, out2 = g} <- nodeWith i1
19c19
<     Applicator {inp = i3, out1 = o3, out2 = x} ← nodeWith i2
---
>     Applicator {inp = i3, out1 = o3, out2 = x} <- nodeWith i2
22c22
<         (l,r,lr,rr) ← (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
---
>         (l,r,lr,rr) <- (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
29c29
< ruleK ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> ruleK :: (View [Port] n, View SKI n) => Rule n
31d30
<     K {inp = si} ← node
32c31
<     Applicator {inp = i1, out1 = o1, out2 = x} ← nodeWith si
---
>     K {inp = si} <- node
32a32
>     Applicator {inp = i1, out1 = o1, out2 = x} <- nodeWith si
34c34
<     Applicator {inp = i2, out1 = o2, out2 = y} ← nodeWith i1
---
>     Applicator {inp = i2, out1 = o2, out2 = y} <- nodeWith i1
39c39
< ruleI ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> ruleI :: (View [Port] n, View SKI n) => Rule n
41d40
<     I {inp = iI} ← node
42c41
<     Applicator {inp = iA, out1 = o1, out2 = o2} ← nodeWith iI
---
>     I {inp = iI} <- node
42a42
>     Applicator {inp = iA, out1 = o1, out2 = o2} <- nodeWith iI
46c46
< combinatorAt ∷ (View [Port] n, View SKI n) ⇒ Edge → Pattern n SKI
---
> combinatorAt :: (View [Port] n, View SKI n) => Edge -> Pattern n SKI
48d47
<     s = do {s@S {} ← nodeWith e; return s}
49d47
<     k = do {k@K {} ← nodeWith e; return k}
50c48
<     i = do {i@I  {} ← nodeWith e; return i}
---
>     s = do {s@S {} <- nodeWith e; return s}
50a49
>     k = do {k@K {} <- nodeWith e; return k}
50a50
>     i = do {i@I  {} <- nodeWith e; return i}
52c52
< duplicateCombinator  ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> duplicateCombinator  :: (View [Port] n, View SKI n) => Rule n
54d53
<     Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
55c54
<     c ← combinatorAt o
---
>     Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
55a55
>     c <- combinatorAt o
58c58
< duplicateApp ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> duplicateApp :: (View [Port] n, View SKI n) => Rule n
60d59
<     Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
61c60
<     Applicator {inp = i, out1 = o1, out2 = o2} ← nodeWith o
---
>     Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
61a61
>     Applicator {inp = i, out1 = o1, out2 = o2} <- nodeWith o
63c63
<         (l,lr,rl,r) ← (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
---
>         (l,lr,rl,r) <- (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
69c69
< eraseCombinator ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> eraseCombinator :: (View [Port] n, View SKI n) => Rule n
71d70
<     Eraser {inp = i} ← node
72c71
<     _ ← combinatorAt i
---
>     Eraser {inp = i} <- node
72a72
>     _ <- combinatorAt i
75c75
< eraseApp ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> eraseApp :: (View [Port] n, View SKI n) => Rule n
77d76
<     Eraser {inp = i} ← node
78c77
<     Applicator {out1 = o1, out2 = o2} ← nodeWith i
---
>     Eraser {inp = i} <- node
78a78
>     Applicator {out1 = o1, out2 = o2} <- nodeWith i
81c81
< eliminate ∷ (View [Port] n, View SKI n) ⇒ Rule n
---
> eliminate :: (View [Port] n, View SKI n) => Rule n
83d82
<     Eraser {inp = iE} ← node
84c83
<     Duplicator {out = oD, inp1 = i1, inp2 = i2} ← nodeWith iE
---
>     Eraser {inp = iE} <- node
84a84
>     Duplicator {out = oD, inp1 = i1, inp2 = i2} <- nodeWith iE
89a90
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
module Direct.Rules where

import Prelude.Unicode
import Data.Monoid.Unicode
import Direct.Graph
import GraphRewriting
import Control.Applicative


-- <chunk: rules>
ruleS ∷ (View [Port] n, View SKI n) ⇒ Rule n
ruleS = do
    S {inp = si} ← node
    Applicator {inp = i1, out1 = o1, out2 = f} ← nodeWith si
    require (si ≡ o1)
    Applicator {inp = i2, out1 = o2, out2 = g} ← nodeWith i1
    require (i1 ≡ o2)
    Applicator {inp = i3, out1 = o3, out2 = x} ← nodeWith i2
    require (i2 ≡ o3)
    replace $ do
        (l,r,lr,rr) ← (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
        byNode Applicator {inp = i3, out1 = l, out2 = r}
        byNode Applicator {inp = l, out1 = f, out2 = lr}
        byNode Applicator {inp = r, out1 = g, out2 = rr}
        byNode Duplicator {inp1 = lr, inp2 = rr, out = x}

-- <chunk: ruleK>
ruleK ∷ (View [Port] n, View SKI n) ⇒ Rule n
ruleK = do
    K {inp = si} ← node
    Applicator {inp = i1, out1 = o1, out2 = x} ← nodeWith si
    require (si ≡ o1)
    Applicator {inp = i2, out1 = o2, out2 = y} ← nodeWith i1
    require (i1 ≡ o2)
    replace $ byWire x i2 ⊕ byNode Eraser {inp = y}
-- </chunk: ruleK>

ruleI ∷ (View [Port] n, View SKI n) ⇒ Rule n
ruleI = do
    I {inp = iI} ← node
    Applicator {inp = iA, out1 = o1, out2 = o2} ← nodeWith iI
    require (iI ≡ o1)
    rewire [[iA,o2]]

combinatorAt ∷ (View [Port] n, View SKI n) ⇒ Edge → Pattern n SKI
combinatorAt e = anyOf [s,k,i] where
    s = do {s@S {} ← nodeWith e; return s}
    k = do {k@K {} ← nodeWith e; return k}
    i = do {i@I  {} ← nodeWith e; return i}

duplicateCombinator  ∷ (View [Port] n, View SKI n) ⇒ Rule n
duplicateCombinator = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
    c ← combinatorAt o
    replace $ byNode c {inp = i1} ⊕ byNode c {inp = i2}

duplicateApp ∷ (View [Port] n, View SKI n) ⇒ Rule n
duplicateApp = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} ← node
    Applicator {inp = i, out1 = o1, out2 = o2} ← nodeWith o
    replace $ do
        (l,lr,rl,r) ← (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
        byNode Applicator {inp = i1, out1 = l, out2 = lr}
        byNode Applicator {inp = i2, out1 = rl, out2 = r}
        byNode Duplicator {inp1 = l, inp2 = rl, out = o1}
        byNode Duplicator {inp1 = lr, inp2 = r, out = o2}

eraseCombinator ∷ (View [Port] n, View SKI n) ⇒ Rule n
eraseCombinator = do
    Eraser {inp = i} ← node
    _ ← combinatorAt i
    erase

eraseApp ∷ (View [Port] n, View SKI n) ⇒ Rule n
eraseApp = do
    Eraser {inp = i} ← node
    Applicator {out1 = o1, out2 = o2} ← nodeWith i
    replace $ byNode Eraser {inp = o1} ⊕ byNode Eraser {inp = o2}

eliminate ∷ (View [Port] n, View SKI n) ⇒ Rule n
eliminate = do
    Eraser {inp = iE} ← node
    Duplicator {out = oD, inp1 = i1, inp2 = i2} ← nodeWith iE
    require (iE ≡ i1 ∨ iE ≡ i2)
    if iE ≡ i1
        then rewire [[oD,i2]]
        else rewire [[oD,i1]]
-- <chunk: rules>
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts #-}
module Direct.Rules where

import Prelude.Unicode
import Data.Monoid.Unicode
import Direct.Graph
import GraphRewriting
import Control.Applicative


-- <chunk: rules>
ruleS :: (View [Port] n, View SKI n) => Rule n
ruleS = do
    S {inp = si} <- node
    Applicator {inp = i1, out1 = o1, out2 = f} <- nodeWith si
    require (si ≡ o1)
    Applicator {inp = i2, out1 = o2, out2 = g} <- nodeWith i1
    require (i1 ≡ o2)
    Applicator {inp = i3, out1 = o3, out2 = x} <- nodeWith i2
    require (i2 ≡ o3)
    replace $ do
        (l,r,lr,rr) <- (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
        byNode Applicator {inp = i3, out1 = l, out2 = r}
        byNode Applicator {inp = l, out1 = f, out2 = lr}
        byNode Applicator {inp = r, out1 = g, out2 = rr}
        byNode Duplicator {inp1 = lr, inp2 = rr, out = x}

-- <chunk: ruleK>
ruleK :: (View [Port] n, View SKI n) => Rule n
ruleK = do
    K {inp = si} <- node
    Applicator {inp = i1, out1 = o1, out2 = x} <- nodeWith si
    require (si ≡ o1)
    Applicator {inp = i2, out1 = o2, out2 = y} <- nodeWith i1
    require (i1 ≡ o2)
    replace $ byWire x i2 ⊕ byNode Eraser {inp = y}
-- </chunk: ruleK>

ruleI :: (View [Port] n, View SKI n) => Rule n
ruleI = do
    I {inp = iI} <- node
    Applicator {inp = iA, out1 = o1, out2 = o2} <- nodeWith iI
    require (iI ≡ o1)
    rewire [[iA,o2]]

combinatorAt :: (View [Port] n, View SKI n) => Edge -> Pattern n SKI
combinatorAt e = anyOf [s,k,i] where
    s = do {s@S {} <- nodeWith e; return s}
    k = do {k@K {} <- nodeWith e; return k}
    i = do {i@I  {} <- nodeWith e; return i}

duplicateCombinator  :: (View [Port] n, View SKI n) => Rule n
duplicateCombinator = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
    c <- combinatorAt o
    replace $ byNode c {inp = i1} ⊕ byNode c {inp = i2}

duplicateApp :: (View [Port] n, View SKI n) => Rule n
duplicateApp = do
    Duplicator {inp1 = i1, inp2 = i2, out = o} <- node
    Applicator {inp = i, out1 = o1, out2 = o2} <- nodeWith o
    replace $ do
        (l,lr,rl,r) <- (,,,) <$> byEdge <*> byEdge <*> byEdge <*> byEdge
        byNode Applicator {inp = i1, out1 = l, out2 = lr}
        byNode Applicator {inp = i2, out1 = rl, out2 = r}
        byNode Duplicator {inp1 = l, inp2 = rl, out = o1}
        byNode Duplicator {inp1 = lr, inp2 = r, out = o2}

eraseCombinator :: (View [Port] n, View SKI n) => Rule n
eraseCombinator = do
    Eraser {inp = i} <- node
    _ <- combinatorAt i
    erase

eraseApp :: (View [Port] n, View SKI n) => Rule n
eraseApp = do
    Eraser {inp = i} <- node
    Applicator {out1 = o1, out2 = o2} <- nodeWith i
    replace $ byNode Eraser {inp = o1} ⊕ byNode Eraser {inp = o2}

eliminate :: (View [Port] n, View SKI n) => Rule n
eliminate = do
    Eraser {inp = iE} <- node
    Duplicator {out = oD, inp1 = i1, inp2 = i2} <- nodeWith iE
    require (iE ≡ i1 ∨ iE ≡ i2)
    if iE ≡ i1
        then rewire [[oD,i2]]
        else rewire [[oD,i1]]
-- <chunk: rules>

</pre>