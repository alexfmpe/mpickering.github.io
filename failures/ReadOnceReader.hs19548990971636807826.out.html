<a href="Readme.hs1520045406937673930.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ReadOnceReader.hs924745989866683784.out.html">next</a></br></br><pre>19c19
<     type Unit Reader = '[]
---
>     type Unit Reader = 
27c27
< ask :: Reader '[a] a
---
> ask :: Reader   a] a
39a40
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleInstances, DataKinds,
             TypeOperators #-}

module Control.Effect.ReadOnceReader (ask,Reader(..),List(..)) where

import Control.Effect
import Control.Effect.Cond
import Control.Effect.Helpers.List
import Prelude    hiding (Monad(..))

{-| Provides a weak reader monad, which can only read an item once. Provides
   an effect system as a list of the items that have been read -}

data Reader (r :: [*]) a = R { runReader :: (List r -> a) }

instance Effect Reader where
    type Inv Reader s t = Split s t

    type Unit Reader = '[]
    type Plus Reader s t = s :++ t

    return x = R $ \Nil -> x
    (R e) >>= k = R $ \xs -> let (s, t) = split xs
                             in (runReader $ k (e s)) t

{-| 'ask' for a value of type 'a' -}
ask :: Reader '[a] a
ask = R $ \(Cons a Nil) -> a

instance Cond Reader where
    type AltInv Reader s t = Split s t
    type Alt Reader s t = s :++ t

    ifM True (R x) (R y) = R $ \rs -> let (r, s) = split rs
                                          _      = y s
                                      in x r
    ifM False (R x) (R y) = R $ \rs -> let (r, s) = split rs
                                           _      = x r
                                       in y s
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleInstances, DataKinds,
             TypeOperators #-}

module Control.Effect.ReadOnceReader (ask,Reader(..),List(..)) where

import Control.Effect
import Control.Effect.Cond
import Control.Effect.Helpers.List
import Prelude    hiding (Monad(..))

{-| Provides a weak reader monad, which can only read an item once. Provides
   an effect system as a list of the items that have been read -}

data Reader (r :: [*]) a = R { runReader :: (List r -> a) }

instance Effect Reader where
    type Inv Reader s t = Split s t

    type Unit Reader = 
    type Plus Reader s t = s :++ t

    return x = R $ \Nil -> x
    (R e) >>= k = R $ \xs -> let (s, t) = split xs
                             in (runReader $ k (e s)) t

{-| 'ask' for a value of type 'a' -}
ask :: Reader   a] a
ask = R $ \(Cons a Nil) -> a

instance Cond Reader where
    type AltInv Reader s t = Split s t
    type Alt Reader s t = s :++ t

    ifM True (R x) (R y) = R $ \rs -> let (r, s) = split rs
                                          _      = y s
                                      in x r
    ifM False (R x) (R y) = R $ \rs -> let (r, s) = split rs
                                           _      = x r
                                       in y s

</pre>