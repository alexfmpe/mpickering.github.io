<a href="Locale.hs577163951524325968.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Location.hs307187357347221711.out.html">next</a></br></br><pre>35d34
<   { _varName ∷ !(Maybe String)
36c35
<   , _varIndex ∷ !Int
---
>   { _varName :: !(Maybe String)
36a36
>   , _varIndex :: !Int
56d55
<   ∷ Functor f
57d55
<   ⇒ (Maybe String → f (Maybe String))
58d55
<   → Var
59c56
<   → f Var
---
>   :: Functor f
59a57
>   => (Maybe String -> f (Maybe String))
59a58
>   -> Var
59a59
>   -> f Var
61c61
<   (\n' → Var n' j)
---
>   (\n' -> Var n' j)
71d70
<   ∷ Functor f
72d70
<   ⇒ (Int → f Int)
73d70
<   → Var
74c71
<   → f Var
---
>   :: Functor f
74a72
>   => (Int -> f Int)
74a73
>   -> Var
74a74
>   -> f Var
76c76
<   (\j' → Var n j')
---
>   (\j' -> Var n j')
81d80
< data Tm (o ∷ [Nat] → *) (n ∷ Nat) where
82d80
<   Free ∷ Var → Tm0 o
83d80
<   Bound ∷ Int → Tm0 o
84d80
<   Abs ∷ Tm o n → Tm o (S n)
85c81
<   App ∷ o ns → Rec (Tm o) ns → Tm0 o
---
> data Tm (o :: [Nat] -> *) (n :: Nat) where
85a82
>   Free :: Var -> Tm0 o
85a83
>   Bound :: Int -> Tm0 o
85a84
>   Abs :: Tm o n -> Tm o (S n)
85a85
>   App :: o ns -> Rec (Tm o) ns -> Tm0 o
93c93
< instance HEq1 o ⇒ HEq1 (Tm o) where
---
> instance HEq1 o => HEq1 (Tm o) where
98d97
<     | Just Refl ← heq1 o1 o2
99c98
<     , Just Refl ← heq1 es1 es2 = Just Refl
---
>     | Just Refl <- heq1 o1 o2
99a99
>     , Just Refl <- heq1 es1 es2 = Just Refl
103d102
<   ∷ Var
104d102
<   → Int
105d102
<   → Tm o n
106d102
<   → Tm o n
107d102
< shiftVar v n = \case
108d102
<   Free v' → if v == v' then Bound n else Free v'
109d102
<   Bound m → Bound m
110d102
<   Abs e → Abs $ shiftVar v (n + 1) e
111c103
<   App p es → App p $ shiftVar v n <<$>> es
---
>   :: Var
111a104
>   -> Int
111a105
>   -> Tm o n
111a106
>   -> Tm o n
111a107
> shiftVar v n = 
111a108
>   Free v' -> if v == v' then Bound n else Free v'
111a109
>   Bound m -> Bound m
111a110
>   Abs e -> Abs $ shiftVar v (n + 1) e
111a111
>   App p es -> App p $ shiftVar v n <<$>> es
114d113
<   ∷ Var
115d113
<   → Int
116d113
<   → Tm o n
117d113
<   → Tm o n
118d113
< addVar v n = \case
119d113
<   Free v' → Free v'
120d113
<   Bound m → if m == n then Free v else Bound m
121d113
<   Abs e → Abs $ addVar v (n + 1) e
122c114
<   App p es → App p $ addVar v n <<$>> es
---
>   :: Var
122a115
>   -> Int
122a116
>   -> Tm o n
122a117
>   -> Tm o n
122a118
> addVar v n = 
122a119
>   Free v' -> Free v'
122a120
>   Bound m -> if m == n then Free v else Bound m
122a121
>   Abs e -> Abs $ addVar v (n + 1) e
122a122
>   App p es -> App p $ addVar v n <<$>> es
124d123
< instance Show1 o ⇒ Abt Var o (Tm o) where
125d123
<   into = \case
126d123
<     V v → Free v
127d123
<     v :\ e → Abs $ shiftVar v 0 e
128c124
<     v :$ es → App v es
---
> instance Show1 o => Abt Var o (Tm o) where
128a125
>   into = 
128a126
>     V v -> Free v
128a127
>     v :\ e -> Abs $ shiftVar v 0 e
128a128
>     v :$ es -> App v es
130d129
<   out = \case
131d129
<     Free v → return $ V v
132d129
<     Bound _ → fail "bound variable occured in out"
133d129
<     Abs e → do
134c130
<       v ← fresh
---
>   out = 
134a131
>     Free v -> return $ V v
134a132
>     Bound _ -> fail "bound variable occured in out"
134a133
>     Abs e -> do
134a134
>       v <- fresh
136c136
<     App p es → return $ p :$ es
---
>     App p es -> return $ p :$ es
145c145
<   ∷ ( Choice p
---
>   :: ( Choice p
149d148
<   ⇒ o ns
150d148
<   → p (Rec (Tm o) ns) (f (Rec (Tm o) ns))
151c149
<   → p (Tm0 o) (f (Tm0 o))
---
>   => o ns
151a150
>   -> p (Rec (Tm o) ns) (f (Rec (Tm o) ns))
151a151
>   -> p (Tm0 o) (f (Tm0 o))
154d153
<     fro = \case
155d153
<       App o' es | Just Refl ← heq1 o o' → Right es
156c154
<       e → Left e
---
>     fro = 
156a155
>       App o' es | Just Refl <- heq1 o o' -> Right es
156a156
>       e -> Left e
156a157
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE UnicodeSyntax #-}

module Abt.Concrete.LocallyNameless
( Tm(..)
, Tm0
, _TmOp
, Var(..)
, varName
, varIndex
) where

import Abt.Types.Nat
import Abt.Types.View
import Abt.Class.HEq1
import Abt.Class.Show1
import Abt.Class.Abt
import Abt.Class.Monad

import Control.Applicative
import Data.Profunctor
import Data.Typeable hiding (Refl)
import Data.Vinyl

-- | A variable is a De Bruijn index, optionally decorated with a display name.
data Var
  = Var
  { _varName ∷ !(Maybe String)
  , _varIndex ∷ !Int
  } deriving Typeable

instance Show Var where
  show (Var (Just v) _) = v
  show (Var Nothing i) = "@" ++ show i

instance Eq Var where
  (Var _ i) == (Var _ j) = i == j

instance Ord Var where
  compare (Var _ i) (Var _ j) = compare i j

-- | A lens for '_varName'.
--
-- @
-- 'varName' ∷ Lens' 'Var' ('Maybe' 'String')
-- @
--
varName
  ∷ Functor f
  ⇒ (Maybe String → f (Maybe String))
  → Var
  → f Var
varName i (Var n j) =
  (\n' → Var n' j)
    <$> i n

-- | A lens for '_varIndex'.
--
-- @
-- 'varIndex' ∷ Lens' 'Var' 'Int'
-- @
--
varIndex
  ∷ Functor f
  ⇒ (Int → f Int)
  → Var
  → f Var
varIndex i (Var n j) =
  (\j' → Var n j')
    <$> i j

-- | Locally nameless terms with operators in @o@ at order @n@.
--
data Tm (o ∷ [Nat] → *) (n ∷ Nat) where
  Free ∷ Var → Tm0 o
  Bound ∷ Int → Tm0 o
  Abs ∷ Tm o n → Tm o (S n)
  App ∷ o ns → Rec (Tm o) ns → Tm0 o

deriving instance Typeable Tm

-- | First order terms (i.e. terms not headed by abstractions).
--
type Tm0 o = Tm o Z

instance HEq1 o ⇒ HEq1 (Tm o) where
  heq1 (Free v1) (Free v2) | v1 == v2 = Just Refl
  heq1 (Bound m) (Bound n) | m == n = Just Refl
  heq1 (Abs e1) (Abs e2) = cong <$> heq1 e1 e2
  heq1 (App o1 es1) (App o2 es2)
    | Just Refl ← heq1 o1 o2
    , Just Refl ← heq1 es1 es2 = Just Refl
  heq1 _ _ = Nothing

shiftVar
  ∷ Var
  → Int
  → Tm o n
  → Tm o n
shiftVar v n = \case
  Free v' → if v == v' then Bound n else Free v'
  Bound m → Bound m
  Abs e → Abs $ shiftVar v (n + 1) e
  App p es → App p $ shiftVar v n <<$>> es

addVar
  ∷ Var
  → Int
  → Tm o n
  → Tm o n
addVar v n = \case
  Free v' → Free v'
  Bound m → if m == n then Free v else Bound m
  Abs e → Abs $ addVar v (n + 1) e
  App p es → App p $ addVar v n <<$>> es

instance Show1 o ⇒ Abt Var o (Tm o) where
  into = \case
    V v → Free v
    v :\ e → Abs $ shiftVar v 0 e
    v :$ es → App v es

  out = \case
    Free v → return $ V v
    Bound _ → fail "bound variable occured in out"
    Abs e → do
      v ← fresh
      return $ v :\ addVar v 0 e
    App p es → return $ p :$ es

-- | A prism to extract arguments from a proposed operator.
--
-- @
-- '_TmOp' ∷ 'HEq1' o ⇒ o ns → Prism' ('Tm0' o) ('Rec' ('Tm0' o) ns)
-- @
--
_TmOp
  ∷ ( Choice p
    , Applicative f
    , HEq1 o
    )
  ⇒ o ns
  → p (Rec (Tm o) ns) (f (Rec (Tm o) ns))
  → p (Tm0 o) (f (Tm0 o))
_TmOp o = dimap fro (either pure (fmap (App o))) . right'
  where
    fro = \case
      App o' es | Just Refl ← heq1 o o' → Right es
      e → Left e
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE UnicodeSyntax #-}

module Abt.Concrete.LocallyNameless
( Tm(..)
, Tm0
, _TmOp
, Var(..)
, varName
, varIndex
) where

import Abt.Types.Nat
import Abt.Types.View
import Abt.Class.HEq1
import Abt.Class.Show1
import Abt.Class.Abt
import Abt.Class.Monad

import Control.Applicative
import Data.Profunctor
import Data.Typeable hiding (Refl)
import Data.Vinyl

-- | A variable is a De Bruijn index, optionally decorated with a display name.
data Var
  = Var
  { _varName :: !(Maybe String)
  , _varIndex :: !Int
  } deriving Typeable

instance Show Var where
  show (Var (Just v) _) = v
  show (Var Nothing i) = "@" ++ show i

instance Eq Var where
  (Var _ i) == (Var _ j) = i == j

instance Ord Var where
  compare (Var _ i) (Var _ j) = compare i j

-- | A lens for '_varName'.
--
-- @
-- 'varName' ∷ Lens' 'Var' ('Maybe' 'String')
-- @
--
varName
  :: Functor f
  => (Maybe String -> f (Maybe String))
  -> Var
  -> f Var
varName i (Var n j) =
  (\n' -> Var n' j)
    <$> i n

-- | A lens for '_varIndex'.
--
-- @
-- 'varIndex' ∷ Lens' 'Var' 'Int'
-- @
--
varIndex
  :: Functor f
  => (Int -> f Int)
  -> Var
  -> f Var
varIndex i (Var n j) =
  (\j' -> Var n j')
    <$> i j

-- | Locally nameless terms with operators in @o@ at order @n@.
--
data Tm (o :: [Nat] -> *) (n :: Nat) where
  Free :: Var -> Tm0 o
  Bound :: Int -> Tm0 o
  Abs :: Tm o n -> Tm o (S n)
  App :: o ns -> Rec (Tm o) ns -> Tm0 o

deriving instance Typeable Tm

-- | First order terms (i.e. terms not headed by abstractions).
--
type Tm0 o = Tm o Z

instance HEq1 o => HEq1 (Tm o) where
  heq1 (Free v1) (Free v2) | v1 == v2 = Just Refl
  heq1 (Bound m) (Bound n) | m == n = Just Refl
  heq1 (Abs e1) (Abs e2) = cong <$> heq1 e1 e2
  heq1 (App o1 es1) (App o2 es2)
    | Just Refl <- heq1 o1 o2
    , Just Refl <- heq1 es1 es2 = Just Refl
  heq1 _ _ = Nothing

shiftVar
  :: Var
  -> Int
  -> Tm o n
  -> Tm o n
shiftVar v n = 
  Free v' -> if v == v' then Bound n else Free v'
  Bound m -> Bound m
  Abs e -> Abs $ shiftVar v (n + 1) e
  App p es -> App p $ shiftVar v n <<$>> es

addVar
  :: Var
  -> Int
  -> Tm o n
  -> Tm o n
addVar v n = 
  Free v' -> Free v'
  Bound m -> if m == n then Free v else Bound m
  Abs e -> Abs $ addVar v (n + 1) e
  App p es -> App p $ addVar v n <<$>> es

instance Show1 o => Abt Var o (Tm o) where
  into = 
    V v -> Free v
    v :\ e -> Abs $ shiftVar v 0 e
    v :$ es -> App v es

  out = 
    Free v -> return $ V v
    Bound _ -> fail "bound variable occured in out"
    Abs e -> do
      v <- fresh
      return $ v :\ addVar v 0 e
    App p es -> return $ p :$ es

-- | A prism to extract arguments from a proposed operator.
--
-- @
-- '_TmOp' ∷ 'HEq1' o ⇒ o ns → Prism' ('Tm0' o) ('Rec' ('Tm0' o) ns)
-- @
--
_TmOp
  :: ( Choice p
    , Applicative f
    , HEq1 o
    )
  => o ns
  -> p (Rec (Tm o) ns) (f (Rec (Tm o) ns))
  -> p (Tm0 o) (f (Tm0 o))
_TmOp o = dimap fro (either pure (fmap (App o))) . right'
  where
    fro = 
      App o' es | Just Refl <- heq1 o o' -> Right es
      e -> Left e

</pre>