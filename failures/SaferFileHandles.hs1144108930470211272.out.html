<a href="SaferFileHandles.hs1010275441457850878.out.html">prev</a></br><a href="failures.html">home</a></br><a href="SaferFileHandles.hs14587779232007237709.out.html">next</a></br></br><pre>62c62
< hGetLine ∷ ( FileHandle handle, ReadModes ioMode
---
> hGetLine :: ( FileHandle handle, ReadModes ioMode
65c65
<          ⇒ handle ioMode pr → cr B.ByteString
---
>          => handle ioMode pr -> cr B.ByteString
69c69
< hGetContents ∷ ( FileHandle handle, ReadModes ioMode
---
> hGetContents :: ( FileHandle handle, ReadModes ioMode
72c72
<              ⇒ handle ioMode pr → cr B.ByteString
---
>              => handle ioMode pr -> cr B.ByteString
76c76
< hGet ∷ ( FileHandle handle, ReadModes ioMode
---
> hGet :: ( FileHandle handle, ReadModes ioMode
79c79
<      ⇒ handle ioMode pr → Int → cr B.ByteString
---
>      => handle ioMode pr -> Int -> cr B.ByteString
83c83
< hGetNonBlocking ∷ ( FileHandle handle, ReadModes ioMode
---
> hGetNonBlocking :: ( FileHandle handle, ReadModes ioMode
86c86
<                 ⇒ handle ioMode pr → Int → cr B.ByteString
---
>                 => handle ioMode pr -> Int -> cr B.ByteString
91c91
< hPut ∷ ( FileHandle handle, WriteModes ioMode
---
> hPut :: ( FileHandle handle, WriteModes ioMode
94c94
<      ⇒ handle ioMode pr → B.ByteString → cr ()
---
>      => handle ioMode pr -> B.ByteString -> cr ()
98c98
< hPutStr ∷ ( FileHandle handle, WriteModes ioMode
---
> hPutStr :: ( FileHandle handle, WriteModes ioMode
101c101
<         ⇒ handle ioMode pr → B.ByteString → cr ()
---
>         => handle ioMode pr -> B.ByteString -> cr ()
105c105
< hPutStrLn ∷ ( FileHandle handle, WriteModes ioMode
---
> hPutStrLn :: ( FileHandle handle, WriteModes ioMode
108c108
<           ⇒ handle ioMode pr → B.ByteString → cr ()
---
>           => handle ioMode pr -> B.ByteString -> cr ()
112a113
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, NoImplicitPrelude #-}

-------------------------------------------------------------------------------
-- |
-- Module      :  Data.ByteString.SaferFileHandles
-- Copyright   :  (c) 2010-2011 Bas van Dijk
-- License     :  BSD3 (see the file LICENSE)
-- Maintainer  :  Bas van Dijk <v.dijk.bas@gmail.com>
--
-- This module lifts the bytestring IO operations into the region monad.
--
-------------------------------------------------------------------------------

module Data.ByteString.Char8.SaferFileHandles
    ( hGetLine
    , hGetContents
    , hGet
    , hGetNonBlocking

    , hPut
    , hPutStr
    , hPutStrLn
    ) where

-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

-- from base:
import Data.Int ( Int )

-- from transformers:
import Control.Monad.IO.Class ( MonadIO )

-- from bytestring:
import qualified Data.ByteString.Char8 as B

-- from regions:
import Control.Monad.Trans.Region ( AncestorRegion )

-- from explicit-iomodes-bytestring:
import qualified Data.ByteString.Char8.ExplicitIOModes as E ( hGetLine
                                                            , hGetContents
                                                            , hGet
                                                            , hGetNonBlocking

                                                            , hPut
                                                            , hPutStr
                                                            , hPutStrLn
                                                            )

-- from safer-file-handles:
import System.IO.SaferFileHandles        ( FileHandle, ReadModes, WriteModes )
import System.IO.SaferFileHandles.Unsafe ( wrap, wrap2 )


-------------------------------------------------------------------------------
-- ByteString I/O with regional file handles
-------------------------------------------------------------------------------

-- | Wraps: @Data.ByteString.'B.hGetLine'@.
hGetLine ∷ ( FileHandle handle, ReadModes ioMode
           , pr `AncestorRegion` cr, MonadIO cr
           )
         ⇒ handle ioMode pr → cr B.ByteString
hGetLine = wrap E.hGetLine

-- | Wraps: @Data.ByteString.'B.hGetContents'@.
hGetContents ∷ ( FileHandle handle, ReadModes ioMode
               , pr `AncestorRegion` cr, MonadIO cr
               )
             ⇒ handle ioMode pr → cr B.ByteString
hGetContents = wrap E.hGetContents

-- | Wraps: @Data.ByteString.'B.hGet'@.
hGet ∷ ( FileHandle handle, ReadModes ioMode
       , pr `AncestorRegion` cr, MonadIO cr
       )
     ⇒ handle ioMode pr → Int → cr B.ByteString
hGet = wrap2 E.hGet

-- | Wraps: @Data.ByteString.'B.hGetNonBlocking'@.
hGetNonBlocking ∷ ( FileHandle handle, ReadModes ioMode
                  , pr `AncestorRegion` cr, MonadIO cr
                  )
                ⇒ handle ioMode pr → Int → cr B.ByteString
hGetNonBlocking = wrap2 E.hGetNonBlocking


-- | Wraps: @Data.ByteString.'B.hPut'@.
hPut ∷ ( FileHandle handle, WriteModes ioMode
       , pr `AncestorRegion` cr, MonadIO cr
       )
     ⇒ handle ioMode pr → B.ByteString → cr ()
hPut = wrap2 E.hPut

-- | Wraps: @Data.ByteString.'B.hPutStr'@.
hPutStr ∷ ( FileHandle handle, WriteModes ioMode
          , pr `AncestorRegion` cr, MonadIO cr
          )
        ⇒ handle ioMode pr → B.ByteString → cr ()
hPutStr = wrap2 E.hPutStr

-- | Wraps: @Data.ByteString.'B.hPutStrLn'@.
hPutStrLn ∷ ( FileHandle handle, WriteModes ioMode
            , pr `AncestorRegion` cr, MonadIO cr
            )
          ⇒ handle ioMode pr → B.ByteString → cr ()
hPutStrLn = wrap2 E.hPutStrLn


-- The End ---------------------------------------------------------------------
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, NoImplicitPrelude #-}

-------------------------------------------------------------------------------
-- |
-- Module      :  Data.ByteString.SaferFileHandles
-- Copyright   :  (c) 2010-2011 Bas van Dijk
-- License     :  BSD3 (see the file LICENSE)
-- Maintainer  :  Bas van Dijk <v.dijk.bas@gmail.com>
--
-- This module lifts the bytestring IO operations into the region monad.
--
-------------------------------------------------------------------------------

module Data.ByteString.Char8.SaferFileHandles
    ( hGetLine
    , hGetContents
    , hGet
    , hGetNonBlocking

    , hPut
    , hPutStr
    , hPutStrLn
    ) where

-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

-- from base:
import Data.Int ( Int )

-- from transformers:
import Control.Monad.IO.Class ( MonadIO )

-- from bytestring:
import qualified Data.ByteString.Char8 as B

-- from regions:
import Control.Monad.Trans.Region ( AncestorRegion )

-- from explicit-iomodes-bytestring:
import qualified Data.ByteString.Char8.ExplicitIOModes as E ( hGetLine
                                                            , hGetContents
                                                            , hGet
                                                            , hGetNonBlocking

                                                            , hPut
                                                            , hPutStr
                                                            , hPutStrLn
                                                            )

-- from safer-file-handles:
import System.IO.SaferFileHandles        ( FileHandle, ReadModes, WriteModes )
import System.IO.SaferFileHandles.Unsafe ( wrap, wrap2 )


-------------------------------------------------------------------------------
-- ByteString I/O with regional file handles
-------------------------------------------------------------------------------

-- | Wraps: @Data.ByteString.'B.hGetLine'@.
hGetLine :: ( FileHandle handle, ReadModes ioMode
           , pr `AncestorRegion` cr, MonadIO cr
           )
         => handle ioMode pr -> cr B.ByteString
hGetLine = wrap E.hGetLine

-- | Wraps: @Data.ByteString.'B.hGetContents'@.
hGetContents :: ( FileHandle handle, ReadModes ioMode
               , pr `AncestorRegion` cr, MonadIO cr
               )
             => handle ioMode pr -> cr B.ByteString
hGetContents = wrap E.hGetContents

-- | Wraps: @Data.ByteString.'B.hGet'@.
hGet :: ( FileHandle handle, ReadModes ioMode
       , pr `AncestorRegion` cr, MonadIO cr
       )
     => handle ioMode pr -> Int -> cr B.ByteString
hGet = wrap2 E.hGet

-- | Wraps: @Data.ByteString.'B.hGetNonBlocking'@.
hGetNonBlocking :: ( FileHandle handle, ReadModes ioMode
                  , pr `AncestorRegion` cr, MonadIO cr
                  )
                => handle ioMode pr -> Int -> cr B.ByteString
hGetNonBlocking = wrap2 E.hGetNonBlocking


-- | Wraps: @Data.ByteString.'B.hPut'@.
hPut :: ( FileHandle handle, WriteModes ioMode
       , pr `AncestorRegion` cr, MonadIO cr
       )
     => handle ioMode pr -> B.ByteString -> cr ()
hPut = wrap2 E.hPut

-- | Wraps: @Data.ByteString.'B.hPutStr'@.
hPutStr :: ( FileHandle handle, WriteModes ioMode
          , pr `AncestorRegion` cr, MonadIO cr
          )
        => handle ioMode pr -> B.ByteString -> cr ()
hPutStr = wrap2 E.hPutStr

-- | Wraps: @Data.ByteString.'B.hPutStrLn'@.
hPutStrLn :: ( FileHandle handle, WriteModes ioMode
            , pr `AncestorRegion` cr, MonadIO cr
            )
          => handle ioMode pr -> B.ByteString -> cr ()
hPutStrLn = wrap2 E.hPutStrLn


-- The End ---------------------------------------------------------------------

</pre>