<a href="CommandLine.hs14795752441507977295.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Common.hs1828087692621301815.out.html">next</a></br></br><pre>17c17
< {-# LINE 43 "src/ehc/EHC/CompilePhase/Common.chs" #-}
---
> 
17a18
> 
17a19
> 
17a20
> 
17a21
> 
17a22
> 
17a23
> 
17a24
> 
17a25
> 
17a26
> 
17a27
> 
17a28
> 
17a29
> 
17a30
> 
17a31
> 
17a32
> 
17a33
> 
17a34
> 
17a35
> 
17a36
> 
17a37
> 
17a38
> 
17a39
> 
17a40
> 
17a41
> 
17a42
> 
47a73
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Common
( cpGenModuleImportExportImpl )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.EHC.CompileUnit
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.CodeGen.ModuleImportExportImpl

{-# LINE 43 "src/ehc/EHC/CompilePhase/Common.chs" #-}
-- | Compute impl info for module codegen
cpGenModuleImportExportImpl :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ModuleImportExportImpl
cpGenModuleImportExportImpl modNm
  = do { cr <- get
       ; cpMsg modNm VerboseDebug "cpGenModuleImportExportImpl"
       ; impNmL <- cpGenImpNmInfo modNm
       ; let (ecu,crsi,opts,fp) = crBaseInfo modNm cr
             isWholeProg = ehcOptOptimizationScope opts > OptimizationScope_PerModule
             expNmFldMp | ecuIsMainMod ecu = Map.empty
                        | otherwise        = crsiExpNmOffMp modNm crsi
             modOffMp   | isWholeProg = Map.filterWithKey (\n _ -> n == modNm) $ crsiModOffMp crsi
                        | otherwise   = crsiModOffMp crsi
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl " ++ show impNmL
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHSDeclImpNmS " ++ show (ecuHSDeclImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHIDeclImpNmS " ++ show (ecuHIDeclImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHIUsedImpNmS " ++ show (ecuHIUsedImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl modOffMp " ++ show modOffMp
       -- ecuHSDeclImpNmS ecu, ecuHIDeclImpNmS ecu, ecuHIUsedImpNmS ecu
       ; return $ emptyModuleImportExportImpl
           { mieimplLamMp           = Core2GrSem.lamMp_Inh_CodeAGItf $ crsiCoreInh crsi
           , mieimplUsedModNmL      = if ecuIsMainMod ecu then [ m | (m,_) <- sortOn snd $ Map.toList $ Map.map fst modOffMp ] else []
           , mieimplHsName2FldMpMp  = Map.fromList
               [ (n,(o,mp))
               | (n,o) <- refGen 0 1 impNmL
               , let (_,mp) = panicJust ("cpGenModuleImportExportImpl: " ++ show n) (Map.lookup n (crsiModOffMp crsi))
               ]
           , mieimplHsName2FldMp    = expNmFldMp
           }
       }

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Common
( cpGenModuleImportExportImpl )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.FastSeq as Seq
import Control.Monad.State
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.EHC.CompileUnit
import qualified UHC.Light.Compiler.Core.ToGrin as Core2GrSem
import UHC.Light.Compiler.CodeGen.ModuleImportExportImpl



























-- | Compute impl info for module codegen
cpGenModuleImportExportImpl :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ModuleImportExportImpl
cpGenModuleImportExportImpl modNm
  = do { cr <- get
       ; cpMsg modNm VerboseDebug "cpGenModuleImportExportImpl"
       ; impNmL <- cpGenImpNmInfo modNm
       ; let (ecu,crsi,opts,fp) = crBaseInfo modNm cr
             isWholeProg = ehcOptOptimizationScope opts > OptimizationScope_PerModule
             expNmFldMp | ecuIsMainMod ecu = Map.empty
                        | otherwise        = crsiExpNmOffMp modNm crsi
             modOffMp   | isWholeProg = Map.filterWithKey (\n _ -> n == modNm) $ crsiModOffMp crsi
                        | otherwise   = crsiModOffMp crsi
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl " ++ show impNmL
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHSDeclImpNmS " ++ show (ecuHSDeclImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHIDeclImpNmS " ++ show (ecuHIDeclImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl ecuHIUsedImpNmS " ++ show (ecuHIUsedImpNmS ecu)
       -- ; liftIO $ putStrLn $ "cpGenModuleImportExportImpl modOffMp " ++ show modOffMp
       -- ecuHSDeclImpNmS ecu, ecuHIDeclImpNmS ecu, ecuHIUsedImpNmS ecu
       ; return $ emptyModuleImportExportImpl
           { mieimplLamMp           = Core2GrSem.lamMp_Inh_CodeAGItf $ crsiCoreInh crsi
           , mieimplUsedModNmL      = if ecuIsMainMod ecu then [ m | (m,_) <- sortOn snd $ Map.toList $ Map.map fst modOffMp ] else []
           , mieimplHsName2FldMpMp  = Map.fromList
               [ (n,(o,mp))
               | (n,o) <- refGen 0 1 impNmL
               , let (_,mp) = panicJust ("cpGenModuleImportExportImpl: " ++ show n) (Map.lookup n (crsiModOffMp crsi))
               ]
           , mieimplHsName2FldMp    = expNmFldMp
           }
       }


</pre>