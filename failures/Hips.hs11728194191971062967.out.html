<a href="HImg.hs1439025357738342585.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Hist.hs21187978011060806853.out.html">next</a></br></br><pre>9d8
< import "mtl" Control.Monad.Reader
10c9
< import "mtl" Control.Monad.Error
---
> import  Control.Monad.Reader
10a10
> import  Control.Monad.Error
18d17
< data InOut = InOut { hIn ∷ Handle
19c18
<                    , hOut ∷ Handle }
---
> data InOut = InOut { hIn :: Handle
19a19
>                    , hOut :: Handle }
22d21
< bsToInt ∷ ByteString → Int
23c22
< bsToInt = S.foldl (\acc x → acc `shiftL` 8 + fromIntegral x) 0
---
> bsToInt :: ByteString -> Int
23a23
> bsToInt = S.foldl (\acc x -> acc `shiftL` 8 + fromIntegral x) 0
25c25
< get ∷ Int → Patcher ByteString
---
> get :: Int -> Patcher ByteString
27c27
<     h ← asks hIn
---
>     h <- asks hIn
30c30
< getInt ∷ Int → Patcher Int
---
> getInt :: Int -> Patcher Int
33c33
< put ∷ Int → ByteString → Patcher ()
---
> put :: Int -> ByteString -> Patcher ()
35c35
<     h ← asks hOut
---
>     h <- asks hOut
40c40
< patchLoop ∷ Patcher ()
---
> patchLoop :: Patcher ()
42c42
<     tag ← get 3
---
>     tag <- get 3
44d43
<         s ← getInt 2
45d43
<         v ← if s /= 0 then get s else do
46c44
<             r ← getInt 2
---
>         s <- getInt 2
46a45
>         v <- if s /= 0 then get s else do
46a46
>             r <- getInt 2
51c51
< patch ∷ Patcher ()
---
> patch :: Patcher ()
53c53
<     header ← get 5
---
>     header <- get 5
57c57
< failWith ∷ IO α → IO β
---
> failWith :: IO α -> IO β
60c60
< printHelp ∷ IO ()
---
> printHelp :: IO ()
62c62
<     exe ← getProgName
---
>     exe <- getProgName
65c65
< main ∷ IO ()
---
> main :: IO ()
67c67
<     args ← getArgs
---
>     args <- getArgs
70c70
<     hPatch ← openBinaryFile patchFile ReadMode
---
>     hPatch <- openBinaryFile patchFile ReadMode
72d71
<     hFile ← openBinaryFile newFile ReadWriteMode
73c72
<     result ← runErrorT $ runReaderT patch InOut { hIn  = hPatch, hOut = hFile }
---
>     hFile <- openBinaryFile newFile ReadWriteMode
73a73
>     result <- runErrorT $ runReaderT patch InOut { hIn  = hPatch, hOut = hFile }
76d75
<         Left e → failWith $ putStrLn e
77c76
<         _ → putStrLn "done"
---
>         Left e -> failWith $ putStrLn e
77a77
>         _ -> putStrLn "done"
77a78
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE PackageImports #-}
import Data.ByteString (ByteString)
import qualified Data.ByteString as S
import qualified Data.ByteString.Char8 as S8
import Data.ByteString.Char8 (hGet, hPut)
import System.IO
import "mtl" Control.Monad.Reader
import "mtl" Control.Monad.Error
import Data.Bits
import Control.Applicative
import Data.Functor.Syntax ((.:))
import System.Directory
import System.Environment
import System.Exit

data InOut = InOut { hIn ∷ Handle
                   , hOut ∷ Handle }
type Patcher = ReaderT InOut (ErrorT String IO)

bsToInt ∷ ByteString → Int
bsToInt = S.foldl (\acc x → acc `shiftL` 8 + fromIntegral x) 0

get ∷ Int → Patcher ByteString
get l = do
    h ← asks hIn
    liftIO $ hGet h l

getInt ∷ Int → Patcher Int
getInt = bsToInt .: get

put ∷ Int → ByteString → Patcher ()
put o s = do
    h ← asks hOut
    liftIO $ do
        hSeek h AbsoluteSeek $ toInteger o
        hPut h s

patchLoop ∷ Patcher ()
patchLoop = do
    tag ← get 3
    unless (tag == "EOF") $ do
        s ← getInt 2
        v ← if s /= 0 then get s else do
            r ← getInt 2
            S8.replicate r . S8.head <$> get 1
        put (bsToInt tag) v
        patchLoop

patch ∷ Patcher ()
patch = do
    header ← get 5
    unless (header == "PATCH") $ throwError "bad header"
    patchLoop

failWith ∷ IO α → IO β
failWith a = a >> (exitWith =<< exitFailure)

printHelp ∷ IO ()
printHelp = do
    exe ← getProgName
    putStrLn $ "usage: " ++ exe ++ " patchfile datafile newfile"

main ∷ IO ()
main = do
    args ← getArgs
    unless (length args == 3) $ failWith printHelp
    let [patchFile, dataFile, newFile] = args
    hPatch ← openBinaryFile patchFile ReadMode
    copyFile dataFile newFile
    hFile ← openBinaryFile newFile ReadWriteMode
    result ← runErrorT $ runReaderT patch InOut { hIn  = hPatch, hOut = hFile }
    mapM_ hClose [hPatch, hFile]
    case result of
        Left e → failWith $ putStrLn e
        _ → putStrLn "done"
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE PackageImports #-}
import Data.ByteString (ByteString)
import qualified Data.ByteString as S
import qualified Data.ByteString.Char8 as S8
import Data.ByteString.Char8 (hGet, hPut)
import System.IO
import  Control.Monad.Reader
import  Control.Monad.Error
import Data.Bits
import Control.Applicative
import Data.Functor.Syntax ((.:))
import System.Directory
import System.Environment
import System.Exit

data InOut = InOut { hIn :: Handle
                   , hOut :: Handle }
type Patcher = ReaderT InOut (ErrorT String IO)

bsToInt :: ByteString -> Int
bsToInt = S.foldl (\acc x -> acc `shiftL` 8 + fromIntegral x) 0

get :: Int -> Patcher ByteString
get l = do
    h <- asks hIn
    liftIO $ hGet h l

getInt :: Int -> Patcher Int
getInt = bsToInt .: get

put :: Int -> ByteString -> Patcher ()
put o s = do
    h <- asks hOut
    liftIO $ do
        hSeek h AbsoluteSeek $ toInteger o
        hPut h s

patchLoop :: Patcher ()
patchLoop = do
    tag <- get 3
    unless (tag == "EOF") $ do
        s <- getInt 2
        v <- if s /= 0 then get s else do
            r <- getInt 2
            S8.replicate r . S8.head <$> get 1
        put (bsToInt tag) v
        patchLoop

patch :: Patcher ()
patch = do
    header <- get 5
    unless (header == "PATCH") $ throwError "bad header"
    patchLoop

failWith :: IO α -> IO β
failWith a = a >> (exitWith =<< exitFailure)

printHelp :: IO ()
printHelp = do
    exe <- getProgName
    putStrLn $ "usage: " ++ exe ++ " patchfile datafile newfile"

main :: IO ()
main = do
    args <- getArgs
    unless (length args == 3) $ failWith printHelp
    let [patchFile, dataFile, newFile] = args
    hPatch <- openBinaryFile patchFile ReadMode
    copyFile dataFile newFile
    hFile <- openBinaryFile newFile ReadWriteMode
    result <- runErrorT $ runReaderT patch InOut { hIn  = hPatch, hOut = hFile }
    mapM_ hClose [hPatch, hFile]
    case result of
        Left e -> failWith $ putStrLn e
        _ -> putStrLn "done"

</pre>