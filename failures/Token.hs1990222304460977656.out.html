<a href="ToCHR.hs14582327061433710178.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TokenParser.hs1677949663544733637.out.html">next</a></br></br><pre>16c16
< {-# LINE 27 "src/ehc/Scanner/Token.chs" #-}
---
> 
16a17
> 
16a18
> 
16a19
> 
16a20
> 
16a21
> 
16a22
> 
16a23
> 
16a24
> 
16a25
> 
16a26
> 
21c31
< {-# LINE 33 "src/ehc/Scanner/Token.chs" #-}
---
> 
21a32
> 
43c54
< {-# LINE 64 "src/ehc/Scanner/Token.chs" #-}
---
> 
43a55
> 
43a56
> 
43a57
> 
43a58
> 
43a59
> 
43a60
> 
43a61
> 
43a62
> 
43a63
> 
57c77
< {-# LINE 79 "src/ehc/Scanner/Token.chs" #-}
---
> 
57a78
> 
67c88
< {-# LINE 90 "src/ehc/Scanner/Token.chs" #-}
---
> 
67a89
> 
71c93
< {-# LINE 95 "src/ehc/Scanner/Token.chs" #-}
---
> 
71a94
> 
80c103
< {-# LINE 119 "src/ehc/Scanner/Token.chs" #-}
---
> 
80a104
> 
80a105
> 
80a106
> 
80a107
> 
80a108
> 
80a109
> 
80a110
> 
80a111
> 
80a112
> 
80a113
> 
80a114
> 
80a115
> 
80a116
> 
80a117
> 
80a118
> 
87a126
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Scanner.Token
( module UU.Scanner.GenToken
, reserved, valueToken, errToken, tokTpIsInt
, Token, ValTokenVal
, EnumValToken (..)
, tokenVals, tokenVal, tokenMap
, tokTpIsId
, tokTpQual )
where
import UU.Scanner.Position
import UU.Scanner.GenToken
import qualified Data.Set as Set



{-# LINE 27 "src/ehc/Scanner/Token.chs" #-}
-- | The value of a Token is a [String], of length > 1 only when it encodes qualified identifiers
type ValTokenVal = [String]
type Token = GenToken String EnumValToken ValTokenVal

{-# LINE 33 "src/ehc/Scanner/Token.chs" #-}
-- | The kind of tokens
data EnumValToken
  = TkVarid
  | TkConid
  | TkOp
  | TkConOp
  | TkString
  | TkChar
  | TkInteger8
  | TkInteger10
  | TkInteger16
  | TkFraction
  | TkTextnm
  | TkTextln
  | TkQVarid            -- qualified variants
  | TkQConid
  | TkQOp
  | TkQConOp
  | TkError
  deriving (Eq, Ord)

{-# LINE 64 "src/ehc/Scanner/Token.chs" #-}
-- | Extract the parts of a qualified identifier
tokenVals :: Token -> [String]
tokenVals (ValToken _ v _) = v
tokenVals (Reserved   v _) = [v]

-- | Extract the value as a flattened string
tokenVal :: Token -> String
tokenVal = concat . tokenVals

tokenMap :: (String->String) -> Token -> Token
tokenMap f (ValToken t v p) = ValToken t (map f v) p
tokenMap f (Reserved   k p) = Reserved   (f k) p

{-# LINE 79 "src/ehc/Scanner/Token.chs" #-}
reserved                :: String -> Pos -> Token
reserved                =  Reserved

valueToken              :: EnumValToken -> String -> Pos -> Token
valueToken t s p        =  ValToken t [s] p

errToken                :: String -> Pos -> Token
errToken                =  valueToken TkError

{-# LINE 90 "src/ehc/Scanner/Token.chs" #-}
tokTpIsInt :: EnumValToken -> Bool
tokTpIsInt tp = tp == TkInteger8 || tp == TkInteger10 || tp == TkInteger16

{-# LINE 95 "src/ehc/Scanner/Token.chs" #-}
tokTpIsId :: EnumValToken -> Bool
tokTpIsId
  = (`Set.member` ts)
  where ts = Set.fromList
               [TkVarid,TkConid,TkOp,TkConOp
               ,TkQVarid,TkQConid,TkQOp,TkQConOp
               ]

{-# LINE 119 "src/ehc/Scanner/Token.chs" #-}
-- | Qualified equivalents of token kinds representing unqualified tokens
tokTpQual :: EnumValToken -> EnumValToken
tokTpQual TkVarid = TkQVarid
tokTpQual TkConid = TkQConid
tokTpQual TkOp    = TkQOp
tokTpQual TkConOp = TkQConOp
tokTpQual t       = t
</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Scanner.Token
( module UU.Scanner.GenToken
, reserved, valueToken, errToken, tokTpIsInt
, Token, ValTokenVal
, EnumValToken (..)
, tokenVals, tokenVal, tokenMap
, tokTpIsId
, tokTpQual )
where
import UU.Scanner.Position
import UU.Scanner.GenToken
import qualified Data.Set as Set














-- | The value of a Token is a [String], of length > 1 only when it encodes qualified identifiers
type ValTokenVal = [String]
type Token = GenToken String EnumValToken ValTokenVal



-- | The kind of tokens
data EnumValToken
  = TkVarid
  | TkConid
  | TkOp
  | TkConOp
  | TkString
  | TkChar
  | TkInteger8
  | TkInteger10
  | TkInteger16
  | TkFraction
  | TkTextnm
  | TkTextln
  | TkQVarid            -- qualified variants
  | TkQConid
  | TkQOp
  | TkQConOp
  | TkError
  deriving (Eq, Ord)











-- | Extract the parts of a qualified identifier
tokenVals :: Token -> [String]
tokenVals (ValToken _ v _) = v
tokenVals (Reserved   v _) = [v]

-- | Extract the value as a flattened string
tokenVal :: Token -> String
tokenVal = concat . tokenVals

tokenMap :: (String->String) -> Token -> Token
tokenMap f (ValToken t v p) = ValToken t (map f v) p
tokenMap f (Reserved   k p) = Reserved   (f k) p



reserved                :: String -> Pos -> Token
reserved                =  Reserved

valueToken              :: EnumValToken -> String -> Pos -> Token
valueToken t s p        =  ValToken t [s] p

errToken                :: String -> Pos -> Token
errToken                =  valueToken TkError



tokTpIsInt :: EnumValToken -> Bool
tokTpIsInt tp = tp == TkInteger8 || tp == TkInteger10 || tp == TkInteger16



tokTpIsId :: EnumValToken -> Bool
tokTpIsId
  = (`Set.member` ts)
  where ts = Set.fromList
               [TkVarid,TkConid,TkOp,TkConOp
               ,TkQVarid,TkQConid,TkQOp,TkQConOp
               ]

















-- | Qualified equivalents of token kinds representing unqualified tokens
tokTpQual :: EnumValToken -> EnumValToken
tokTpQual TkVarid = TkQVarid
tokTpQual TkConid = TkQConid
tokTpQual TkOp    = TkQOp
tokTpQual TkConOp = TkQConOp
tokTpQual t       = t

</pre>