<a href="Memcached.hs1777724115269220094.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Memoize.hs12648177091998097157.out.html">next</a></br></br><pre>28c28
<         Left ma -> mdo
---
>         Left ma -> 
43a44
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE RecursiveDo #-}
module Reactive.Threepenny.Memo (
    Memo, fromPure, memoize, at, liftMemo1, liftMemo2,
    ) where

import Control.Monad
import Data.Functor
import Data.IORef
import System.IO.Unsafe

{-----------------------------------------------------------------------------
    Memoize time-varying values / computations
------------------------------------------------------------------------------}
data Memo a
    = Const a
    | Memoized (IORef (MemoD a))

type MemoD a = Either (IO a) a

fromPure = Const

at :: Memo a -> IO a
at (Const a)    = return a
at (Memoized r) = do
    memo <- readIORef r
    case memo of
        Right a -> return a
        Left ma -> mdo
            writeIORef r $ Right a
            a <- ma    -- allow some recursion
            return a

memoize :: IO a -> Memo a
memoize m = unsafePerformIO $ Memoized <$> newIORef (Left m)

liftMemo1 :: (a -> IO b) -> Memo a -> Memo b
liftMemo1 f ma = memoize $ f =<< at ma

liftMemo2 :: (a -> b -> IO c) -> Memo a -> Memo b -> Memo c
liftMemo2 f ma mb = memoize $ do
    a <- at ma
    b <- at mb
    f a b
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE RecursiveDo #-}
module Reactive.Threepenny.Memo (
    Memo, fromPure, memoize, at, liftMemo1, liftMemo2,
    ) where

import Control.Monad
import Data.Functor
import Data.IORef
import System.IO.Unsafe

{-----------------------------------------------------------------------------
    Memoize time-varying values / computations
------------------------------------------------------------------------------}
data Memo a
    = Const a
    | Memoized (IORef (MemoD a))

type MemoD a = Either (IO a) a

fromPure = Const

at :: Memo a -> IO a
at (Const a)    = return a
at (Memoized r) = do
    memo <- readIORef r
    case memo of
        Right a -> return a
        Left ma -> 
            writeIORef r $ Right a
            a <- ma    -- allow some recursion
            return a

memoize :: IO a -> Memo a
memoize m = unsafePerformIO $ Memoized <$> newIORef (Left m)

liftMemo1 :: (a -> IO b) -> Memo a -> Memo b
liftMemo1 f ma = memoize $ f =<< at ma

liftMemo2 :: (a -> b -> IO c) -> Memo a -> Memo b -> Memo c
liftMemo2 f ma mb = memoize $ do
    a <- at ma
    b <- at mb
    f a b

</pre>