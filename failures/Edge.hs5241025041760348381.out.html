<a href="Edge.hs17460073071928256141.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Effect.hs12507398241614285132.out.html">next</a></br></br><pre>32c32
<   Deducible 'True = ()
---
>   Deducible True = ()
36d35
<   Excluding a ('Just '[]) = Deducible 'True -- Basis
37d35
<   Excluding a 'Nothing    = Deducible 'True -- Basis
38d35
<   Excluding a ('Just (a ': ts)) = Deducible 'False -- Reject & Refute
39c36
<   Excluding a ('Just (b ': ts)) = Excluding a ('Just ts) -- continue
---
>   Excluding a (Just '[]) = Deducible True -- Basis
39a37
>   Excluding a Nothing    = Deducible True -- Basis
39a38
>   Excluding a (Just (a  : ts)) = Deducible False -- Reject & Refute
39a39
>   Excluding a (Just (b  : ts)) = Excluding a (Just ts) -- continue
43d42
<   Lookup a ( '( a, v) ': xs ) = 'Just v
44d42
<   Lookup a (b ': xs) = Lookup a xs
45c43
<   Lookup a '[] = 'Nothing
---
>   Lookup a (    a, v   : xs ) = Just v
45a44
>   Lookup a (b  : xs) = Lookup a xs
45a45
>   Lookup a '[] = Nothing
48d47
< type family (x :: k1) =/= (y :: k2) :: Constraint where
49d47
<   a =/= a = Deducible 'False
50c48
<   a =/= b = Deducible 'True
---
> type family           =/=x :: k1)     (y :: k2) :: Constraint where
50a49
>     =/=     a = Deducible False
50a50
>     =/=     b = Deducible True
60c60
<             Acceptable ('EdgeType from to) excludeMap 'False where
---
>             Acceptable (EdgeType from to) excludeMap False where
64c64
<             Acceptable ('EdgeType from to) excludeMap 'True where
---
>             Acceptable (EdgeType from to) excludeMap True where
69d68
<   PrependIfElem t a (t ': xs) = a ': t ': xs
70c69
<   PrependIfElem t a (u ': xs) = u ': (PrependIfElem t a xs)
---
>   PrependIfElem t a (t  : xs) = a  : t  : xs
70a70
>   PrependIfElem t a (u  : xs) = u  : (PrependIfElem t a xs)
81d80
<   DisallowIn ('EdgeType from to) ( '(from, xs) ': es) 'False =
82d80
<     '(from, (to ': xs)) ':                      -- add @to@ to transitive reach list
83c81
<       (DisallowIn ('EdgeType from to) es 'True) -- continue
---
>   DisallowIn (EdgeType from to) (   from, xs   : es) False =
83a82
>       from, (to  : xs)   :                      -- add @to@ to transitive reach list
83a83
>       (DisallowIn (EdgeType from to) es True) -- continue
85d84
<   DisallowIn ('EdgeType from to) ( '(key, vs) ': es ) keyFoundYet =
86d84
<     '(key, (PrependIfElem from to vs)) ':            -- find the needle if it exists
87c85
<         (DisallowIn ('EdgeType from to) es keyFoundYet) -- continue
---
>   DisallowIn (EdgeType from to) (   key, vs   : es ) keyFoundYet =
87a86
>       key, (PrependIfElem from to vs)   :            -- find the needle if it exists
87a87
>         (DisallowIn (EdgeType from to) es keyFoundYet) -- continue
89c89
<   DisallowIn a '[] 'True = '[] -- search over.
---
>   DisallowIn a '[] True = '[] -- search over.
91c91
<   DisallowIn ('EdgeType from to) '[] 'False = ('(from, (to ': '[])) ': '[])
---
>   DisallowIn (EdgeType from to) '[] False = (  from, (to  : '[])   : '[])
102c102
<            , DisallowIn b oldLoops 'False ~ c
---
>            , DisallowIn b oldLoops False ~ c
105c105
<              -> EdgeSchema (b ': old) c unique
---
>              -> EdgeSchema (b  : old) c unique
109c109
< unique :: EdgeSchema '[] '[] 'True
---
> unique :: EdgeSchema '[] '[] True
112c112
< notUnique :: EdgeSchema '[] '[] 'False
---
> notUnique :: EdgeSchema '[] '[] False
113a114
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}

module Data.Graph.DAG.Edge where

import Data.Constraint
import GHC.TypeLits
import Data.Proxy

-- | We use promoted symbol values for the @from@ and @to@ type parameters. This
-- is the user-level data type when declaring the list of edges.
data EdgeValue (from :: Symbol) (to :: Symbol) = Edge

-- | We need this for type-level computation list.
data EdgeKind = forall from to. EdgeType from to

-- | Some people just want to watch the world burn. Ideally, this shouldn't
-- exist; poor error messages, and is very square peg - round hole.
type family Deducible (x :: Bool) :: Constraint where
  Deducible 'True = ()

-- | @not . elem@ for lists of types, resulting in a constraint.
type family Excluding (x :: k) (xs :: Maybe [k]) :: Constraint where
  Excluding a ('Just '[]) = Deducible 'True -- Basis
  Excluding a 'Nothing    = Deducible 'True -- Basis
  Excluding a ('Just (a ': ts)) = Deducible 'False -- Reject & Refute
  Excluding a ('Just (b ': ts)) = Excluding a ('Just ts) -- continue

-- | A simple @Data.List.lookup@ function for type maps.
type family Lookup (index :: k) ( map :: [(k, k2)] ) :: Maybe k2 where
  Lookup a ( '( a, v) ': xs ) = 'Just v
  Lookup a (b ': xs) = Lookup a xs
  Lookup a '[] = 'Nothing

-- | Trivial inequality for non-reflexivity of edges
type family (x :: k1) =/= (y :: k2) :: Constraint where
  a =/= a = Deducible 'False
  a =/= b = Deducible 'True

-- | Simply reject anything that's been reached in the other direction. We
-- expect an explicit type signature when uniqueness is needed, otherwise we
-- will wait until invocation to see if the edges are unique.
class Acceptable (a :: EdgeKind)
                 ( oldLoops :: [(Symbol, [Symbol])] )
                 (unique :: Bool) where
instance ( Excluding from (Lookup to excludeMap)
         , from =/= to ) =>
            Acceptable ('EdgeType from to) excludeMap 'False where
instance ( Excluding from (Lookup to excludeMap)
         , Excluding to (Lookup from excludeMap)
         , from =/= to ) =>
            Acceptable ('EdgeType from to) excludeMap 'True where

-- | Add an explicit element to the head of a list, if the test is inside that
-- list.
type family PrependIfElem (test :: k) (a :: k) (xs :: [k]) :: [k] where
  PrependIfElem t a (t ': xs) = a ': t ': xs
  PrependIfElem t a (u ': xs) = u ': (PrependIfElem t a xs)
  PrependIfElem t a '[]       = '[]

-- | Update the exclusion map with the new edge: the @from@ key gets @to@ added,
-- likewise with keys that have @from@ in it's value list. We need to track if
-- the key exists yet.
type family DisallowIn
              (new :: EdgeKind)
              ( oldLoops :: [(Symbol, [Symbol])] )
              (keyFoundYet :: Bool) :: [(Symbol, [Symbol])] where
-- When @from ~ key@:
  DisallowIn ('EdgeType from to) ( '(from, xs) ': es) 'False =
    '(from, (to ': xs)) ':                      -- add @to@ to transitive reach list
      (DisallowIn ('EdgeType from to) es 'True) -- continue
-- When @from ~/~ key@, and @from ~/~ head value@
  DisallowIn ('EdgeType from to) ( '(key, vs) ': es ) keyFoundYet =
    '(key, (PrependIfElem from to vs)) ':            -- find the needle if it exists
        (DisallowIn ('EdgeType from to) es keyFoundYet) -- continue
-- Basis
  DisallowIn a '[] 'True = '[] -- search over.
-- Growth via append
  DisallowIn ('EdgeType from to) '[] 'False = ('(from, (to ': '[])) ': '[])

-- | @edges@ is a list of types with kind @EdgeKind@, while @nearLoops@ is a
-- map of the nodes transitively reachable by each node.
data EdgeSchema (edges :: [EdgeKind])
                (nearLoops :: [(Symbol, [Symbol])])
                (unique :: Bool) where
  ENil :: EdgeSchema '[] '[] unique
  ECons :: ( Acceptable b oldLoops unique
           , EdgeValue from to ~ a
           , EdgeType from to ~ b
           , DisallowIn b oldLoops 'False ~ c
           ) => !a
             -> !(EdgeSchema old oldLoops unique)
             -> EdgeSchema (b ': old) c unique

-- | Utility for constructing an @EdgeSchema@ incrementally without a type
-- signature.
unique :: EdgeSchema '[] '[] 'True
unique = ENil

notUnique :: EdgeSchema '[] '[] 'False
notUnique = ENil
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}

module Data.Graph.DAG.Edge where

import Data.Constraint
import GHC.TypeLits
import Data.Proxy

-- | We use promoted symbol values for the @from@ and @to@ type parameters. This
-- is the user-level data type when declaring the list of edges.
data EdgeValue (from :: Symbol) (to :: Symbol) = Edge

-- | We need this for type-level computation list.
data EdgeKind = forall from to. EdgeType from to

-- | Some people just want to watch the world burn. Ideally, this shouldn't
-- exist; poor error messages, and is very square peg - round hole.
type family Deducible (x :: Bool) :: Constraint where
  Deducible True = ()

-- | @not . elem@ for lists of types, resulting in a constraint.
type family Excluding (x :: k) (xs :: Maybe [k]) :: Constraint where
  Excluding a (Just '[]) = Deducible True -- Basis
  Excluding a Nothing    = Deducible True -- Basis
  Excluding a (Just (a  : ts)) = Deducible False -- Reject & Refute
  Excluding a (Just (b  : ts)) = Excluding a (Just ts) -- continue

-- | A simple @Data.List.lookup@ function for type maps.
type family Lookup (index :: k) ( map :: [(k, k2)] ) :: Maybe k2 where
  Lookup a (    a, v   : xs ) = Just v
  Lookup a (b  : xs) = Lookup a xs
  Lookup a '[] = Nothing

-- | Trivial inequality for non-reflexivity of edges
type family           =/=x :: k1)     (y :: k2) :: Constraint where
    =/=     a = Deducible False
    =/=     b = Deducible True

-- | Simply reject anything that's been reached in the other direction. We
-- expect an explicit type signature when uniqueness is needed, otherwise we
-- will wait until invocation to see if the edges are unique.
class Acceptable (a :: EdgeKind)
                 ( oldLoops :: [(Symbol, [Symbol])] )
                 (unique :: Bool) where
instance ( Excluding from (Lookup to excludeMap)
         , from =/= to ) =>
            Acceptable (EdgeType from to) excludeMap False where
instance ( Excluding from (Lookup to excludeMap)
         , Excluding to (Lookup from excludeMap)
         , from =/= to ) =>
            Acceptable (EdgeType from to) excludeMap True where

-- | Add an explicit element to the head of a list, if the test is inside that
-- list.
type family PrependIfElem (test :: k) (a :: k) (xs :: [k]) :: [k] where
  PrependIfElem t a (t  : xs) = a  : t  : xs
  PrependIfElem t a (u  : xs) = u  : (PrependIfElem t a xs)
  PrependIfElem t a '[]       = '[]

-- | Update the exclusion map with the new edge: the @from@ key gets @to@ added,
-- likewise with keys that have @from@ in it's value list. We need to track if
-- the key exists yet.
type family DisallowIn
              (new :: EdgeKind)
              ( oldLoops :: [(Symbol, [Symbol])] )
              (keyFoundYet :: Bool) :: [(Symbol, [Symbol])] where
-- When @from ~ key@:
  DisallowIn (EdgeType from to) (   from, xs   : es) False =
      from, (to  : xs)   :                      -- add @to@ to transitive reach list
      (DisallowIn (EdgeType from to) es True) -- continue
-- When @from ~/~ key@, and @from ~/~ head value@
  DisallowIn (EdgeType from to) (   key, vs   : es ) keyFoundYet =
      key, (PrependIfElem from to vs)   :            -- find the needle if it exists
        (DisallowIn (EdgeType from to) es keyFoundYet) -- continue
-- Basis
  DisallowIn a '[] True = '[] -- search over.
-- Growth via append
  DisallowIn (EdgeType from to) '[] False = (  from, (to  : '[])   : '[])

-- | @edges@ is a list of types with kind @EdgeKind@, while @nearLoops@ is a
-- map of the nodes transitively reachable by each node.
data EdgeSchema (edges :: [EdgeKind])
                (nearLoops :: [(Symbol, [Symbol])])
                (unique :: Bool) where
  ENil :: EdgeSchema '[] '[] unique
  ECons :: ( Acceptable b oldLoops unique
           , EdgeValue from to ~ a
           , EdgeType from to ~ b
           , DisallowIn b oldLoops False ~ c
           ) => !a
             -> !(EdgeSchema old oldLoops unique)
             -> EdgeSchema (b  : old) c unique

-- | Utility for constructing an @EdgeSchema@ incrementally without a type
-- signature.
unique :: EdgeSchema '[] '[] True
unique = ENil

notUnique :: EdgeSchema '[] '[] False
notUnique = ENil

</pre>