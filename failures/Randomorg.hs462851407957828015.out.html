<a href="Random.hs16460350011025921153.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Range.hs1137623865997389814.out.html">next</a></br></br><pre>26d25
<   get ∷ α → String
27c26
<   getF ∷ (Functor μ, Get α) ⇒ μ α → μ String
---
>   get :: α -> String
27a27
>   getF :: (Functor μ, Get α) => μ α -> μ String
43d42
< integers ∷ Int -- ^ Number of integers to generate ([1,1e4])
44d42
<          → Int -- ^ Minimum value (-1e9,1e9)
45d42
<          → Int -- ^ Maximum value (-1e9,1e9)
46d42
<          → RNG
47d42
<          → IO (Maybe [Int])
48d42
< integers (get → n)
49d42
<          (get → min)
50d42
<          (get → max)
51c43
<          (get → rng) =
---
> integers :: Int -- ^ Number of integers to generate ([1,1e4])
51a44
>          -> Int -- ^ Minimum value (-1e9,1e9)
51a45
>          -> Int -- ^ Maximum value (-1e9,1e9)
51a46
>          -> RNG
51a47
>          -> IO (Maybe [Int])
51a48
> integers (get -> n)
51a49
>          (get -> min)
51a50
>          (get -> max)
51a51
>          (get -> rng) =
54c54
<   in mapM (\l → fst <$> readInt l) . B.lines . respBody <$> query url params
---
>   in mapM (\l -> fst <$> readInt l) . B.lines . respBody <$> query url params
61d60
< shuffle ∷ Int -- ^ Minimum value (-1e9,1e9)
62d60
<         → Int -- ^ Maximum value (-1e9,1e9)
63d60
<         → RNG
64c61
<         → IO (Maybe [Int])
---
> shuffle :: Int -- ^ Minimum value (-1e9,1e9)
64a62
>         -> Int -- ^ Maximum value (-1e9,1e9)
64a63
>         -> RNG
64a64
>         -> IO (Maybe [Int])
67c67
<         (get → rng)
---
>         (get -> rng)
71c71
<     in mapM (\l → fst <$> readInt l) . B.lines . respBody <$> query url params
---
>     in mapM (\l -> fst <$> readInt l) . B.lines . respBody <$> query url params
75d74
< strings ∷ Int -- ^ Number of strings to generate ([1,1e4])
76d74
<         → Int -- ^ Length of each string ([1,20])
77d74
<         → Bool -- ^ Allow digits
78d74
<         → Bool -- ^ Allow uppercase alphabetic characters
79d74
<         → Bool -- ^ Allow lowercase alphabetic characters
80d74
<         → Bool -- ^ Whether all string should be unique
81d74
<         → RNG
82d74
<         → IO [String]
83d74
< strings (get → n)
84d74
<         (get → l)
85d74
<         (get → digits)
86d74
<         (get → upper)
87d74
<         (get → lower)
88d74
<         (get → unique)
89c75
<         (get → rng) =
---
> strings :: Int -- ^ Number of strings to generate ([1,1e4])
89a76
>         -> Int -- ^ Length of each string ([1,20])
89a77
>         -> Bool -- ^ Allow digits
89a78
>         -> Bool -- ^ Allow uppercase alphabetic characters
89a79
>         -> Bool -- ^ Allow lowercase alphabetic characters
89a80
>         -> Bool -- ^ Whether all string should be unique
89a81
>         -> RNG
89a82
>         -> IO [String]
89a83
> strings (get -> n)
89a84
>         (get -> l)
89a85
>         (get -> digits)
89a86
>         (get -> upper)
89a87
>         (get -> lower)
89a88
>         (get -> unique)
89a89
>         (get -> rng) =
95d94
< quota ∷ Maybe (Word8, Word8, Word8, Word8)-- ^ Optional IP address. If not provided use IP of the caller
96d94
<       → IO (Maybe Integer)
97c95
< quota (getF → ip) =
---
> quota :: Maybe (Word8, Word8, Word8, Word8)-- ^ Optional IP address. If not provided use IP of the caller
97a96
>       -> IO (Maybe Integer)
97a97
> quota (getF -> ip) =
102d101
< query ∷ String → [(String,String)] → IO (CurlResponse_ [(String, String)] ByteString)
103c102
< query url (filter (not . null . snd) → params) =
---
> query :: String -> [(String,String)] -> IO (CurlResponse_ [(String, String)] ByteString)
103a103
> query url (filter (not . null . snd) -> params) =
105c105
<   in withCurlDo $ curlGetResponse_ (url ++ intercalate "&" (map (\(k,v) → k ++ "=" ++ v) params))
---
>   in withCurlDo $ curlGetResponse_ (url ++ intercalate "&" (map (\(k,v) -> k ++ "=" ++ v) params))
108a109
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ViewPatterns #-}
-- | Random.org API module
{-# OPTIONS_HADDOCK prune #-}
module Network.Randomorg
  ( RNG(..)
  , integers, shuffle, strings, quota
  ) where

import Control.Applicative ((<$>))
import Data.ByteString.Char8 (ByteString, readInteger, readInt)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Data.Word (Word8)
import Network.Curl
import Prelude hiding (max, min)
import qualified Data.ByteString.Char8 as B

-- | Specify the randomization method
data RNG = New -- ^ Truly random bitstream
         | Id String -- ^ Determine randomization from a large pool of pregenerated bits
         | Date String -- ^ Determine randomization based on one of the daily pregenerated files. The date must be in YYYY-MM-DD format or one of the two shorthand strings `today' or `yesterday'.

class Get α where
  get ∷ α → String
  getF ∷ (Functor μ, Get α) ⇒ μ α → μ String
  getF = fmap get

instance Get Int where
  get = show
instance Get Bool where
  get True = "on"
  get False = "off"
instance Get (Word8,Word8,Word8,Word8) where
  get (α,β,γ,δ) = intercalate "." . map show $ [α,β,γ,δ]
instance Get RNG where
  get New = "new"
  get (Id s) = "id." ++ s
  get (Date s) = "date." ++ s

-- | Generate random integers in configurable intervals
integers ∷ Int -- ^ Number of integers to generate ([1,1e4])
         → Int -- ^ Minimum value (-1e9,1e9)
         → Int -- ^ Maximum value (-1e9,1e9)
         → RNG
         → IO (Maybe [Int])
integers (get → n)
         (get → min)
         (get → max)
         (get → rng) =
  let url = "http://www.random.org/integers/?col=1&base=10&format=plain&"
      params = zip ["num","min","max","rnd"] [n, min, max, rng]
  in mapM (\l → fst <$> readInt l) . B.lines . respBody <$> query url params

-- | Shuffle integers in given interval
--
-- NOTE: Maintains the invariant `max - min + 1 <= 1e4'
--
-- NOTE: Doesn't maintain the invariant `max >= min'
shuffle ∷ Int -- ^ Minimum value (-1e9,1e9)
        → Int -- ^ Maximum value (-1e9,1e9)
        → RNG
        → IO (Maybe [Int])
shuffle min
        max
        (get → rng)
  | max - min + 1 <= 10000 =
    let url = "http://www.random.org/sequences/?col=1&format=plain&"
        params = zip ["min","max","rnd"] [get min, get max, rng]
    in mapM (\l → fst <$> readInt l) . B.lines . respBody <$> query url params
  | otherwise = return Nothing

-- | Generate random strings of various length and composition
strings ∷ Int -- ^ Number of strings to generate ([1,1e4])
        → Int -- ^ Length of each string ([1,20])
        → Bool -- ^ Allow digits
        → Bool -- ^ Allow uppercase alphabetic characters
        → Bool -- ^ Allow lowercase alphabetic characters
        → Bool -- ^ Whether all string should be unique
        → RNG
        → IO [String]
strings (get → n)
        (get → l)
        (get → digits)
        (get → upper)
        (get → lower)
        (get → unique)
        (get → rng) =
  let url = "http://www.random.org/strings/?format=plain&"
      params = zip ["num","len","digits","upperalpha","loweralpha","unique","rnd"] [n, l, digits, upper, lower, unique, rng]
  in map B.unpack . B.lines . respBody <$> query url params

-- | Examine quota for given IP address
quota ∷ Maybe (Word8, Word8, Word8, Word8)-- ^ Optional IP address. If not provided use IP of the caller
      → IO (Maybe Integer)
quota (getF → ip) =
  let url = "http://www.random.org/quota/?format=plain&"
      params = zip ["ip"] [fromMaybe "" ip]
  in (fst <$>) . readInteger . respBody <$> query url params

query ∷ String → [(String,String)] → IO (CurlResponse_ [(String, String)] ByteString)
query url (filter (not . null . snd) → params) =
  let ua = "Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0 Iceweasel/10.0"
  in withCurlDo $ curlGetResponse_ (url ++ intercalate "&" (map (\(k,v) → k ++ "=" ++ v) params))
       [ CurlFailOnError False
       , CurlUserAgent ua
       ]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ViewPatterns #-}
-- | Random.org API module
{-# OPTIONS_HADDOCK prune #-}
module Network.Randomorg
  ( RNG(..)
  , integers, shuffle, strings, quota
  ) where

import Control.Applicative ((<$>))
import Data.ByteString.Char8 (ByteString, readInteger, readInt)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Data.Word (Word8)
import Network.Curl
import Prelude hiding (max, min)
import qualified Data.ByteString.Char8 as B

-- | Specify the randomization method
data RNG = New -- ^ Truly random bitstream
         | Id String -- ^ Determine randomization from a large pool of pregenerated bits
         | Date String -- ^ Determine randomization based on one of the daily pregenerated files. The date must be in YYYY-MM-DD format or one of the two shorthand strings `today' or `yesterday'.

class Get α where
  get :: α -> String
  getF :: (Functor μ, Get α) => μ α -> μ String
  getF = fmap get

instance Get Int where
  get = show
instance Get Bool where
  get True = "on"
  get False = "off"
instance Get (Word8,Word8,Word8,Word8) where
  get (α,β,γ,δ) = intercalate "." . map show $ [α,β,γ,δ]
instance Get RNG where
  get New = "new"
  get (Id s) = "id." ++ s
  get (Date s) = "date." ++ s

-- | Generate random integers in configurable intervals
integers :: Int -- ^ Number of integers to generate ([1,1e4])
         -> Int -- ^ Minimum value (-1e9,1e9)
         -> Int -- ^ Maximum value (-1e9,1e9)
         -> RNG
         -> IO (Maybe [Int])
integers (get -> n)
         (get -> min)
         (get -> max)
         (get -> rng) =
  let url = "http://www.random.org/integers/?col=1&base=10&format=plain&"
      params = zip ["num","min","max","rnd"] [n, min, max, rng]
  in mapM (\l -> fst <$> readInt l) . B.lines . respBody <$> query url params

-- | Shuffle integers in given interval
--
-- NOTE: Maintains the invariant `max - min + 1 <= 1e4'
--
-- NOTE: Doesn't maintain the invariant `max >= min'
shuffle :: Int -- ^ Minimum value (-1e9,1e9)
        -> Int -- ^ Maximum value (-1e9,1e9)
        -> RNG
        -> IO (Maybe [Int])
shuffle min
        max
        (get -> rng)
  | max - min + 1 <= 10000 =
    let url = "http://www.random.org/sequences/?col=1&format=plain&"
        params = zip ["min","max","rnd"] [get min, get max, rng]
    in mapM (\l -> fst <$> readInt l) . B.lines . respBody <$> query url params
  | otherwise = return Nothing

-- | Generate random strings of various length and composition
strings :: Int -- ^ Number of strings to generate ([1,1e4])
        -> Int -- ^ Length of each string ([1,20])
        -> Bool -- ^ Allow digits
        -> Bool -- ^ Allow uppercase alphabetic characters
        -> Bool -- ^ Allow lowercase alphabetic characters
        -> Bool -- ^ Whether all string should be unique
        -> RNG
        -> IO [String]
strings (get -> n)
        (get -> l)
        (get -> digits)
        (get -> upper)
        (get -> lower)
        (get -> unique)
        (get -> rng) =
  let url = "http://www.random.org/strings/?format=plain&"
      params = zip ["num","len","digits","upperalpha","loweralpha","unique","rnd"] [n, l, digits, upper, lower, unique, rng]
  in map B.unpack . B.lines . respBody <$> query url params

-- | Examine quota for given IP address
quota :: Maybe (Word8, Word8, Word8, Word8)-- ^ Optional IP address. If not provided use IP of the caller
      -> IO (Maybe Integer)
quota (getF -> ip) =
  let url = "http://www.random.org/quota/?format=plain&"
      params = zip ["ip"] [fromMaybe "" ip]
  in (fst <$>) . readInteger . respBody <$> query url params

query :: String -> [(String,String)] -> IO (CurlResponse_ [(String, String)] ByteString)
query url (filter (not . null . snd) -> params) =
  let ua = "Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0 Iceweasel/10.0"
  in withCurlDo $ curlGetResponse_ (url ++ intercalate "&" (map (\(k,v) -> k ++ "=" ++ v) params))
       [ CurlFailOnError False
       , CurlUserAgent ua
       ]

</pre>