<a href="Pointfree.hs12694067521816731566.out.html">prev</a></br><a href="failures.html">home</a></br><a href="PolGam.hs15320627671049997439.out.html">next</a></br></br><pre>14c14
< toPointStyle ∷ PointOption → PointStyle
---
> toPointStyle :: PointOption -> PointStyle
16d15
<     _ | s `elem` ".●" → filledCircles r color
17d15
<       | s `elem` "o○" → hollowCircles r thick color
18d15
<       | s `elem` "x" → exes r thick color
19d15
<       | s `elem` "+" → plusses r thick color
20d15
<       | s `elem` "*" → stars r thick color
21d15
<       | s `elem` "v▼" → filledPolygon r 3 True color
22d15
<       | s `elem` "^▲" → filledPolygon r 3 False color
23d15
<       | s `elem` "#■" → filledPolygon r 4 False color
24d15
<       | s `elem` "◆" → filledPolygon r 4 True color
25c16
<       | otherwise → filledCircles r color
---
>     _ | s `elem` ".●" -> filledCircles r color
25a17
>       | s `elem` "o○" -> hollowCircles r thick color
25a18
>       | s `elem` "x" -> exes r thick color
25a19
>       | s `elem` "+" -> plusses r thick color
25a20
>       | s `elem` "*" -> stars r thick color
25a21
>       | s `elem` "v▼" -> filledPolygon r 3 True color
25a22
>       | s `elem` "^▲" -> filledPolygon r 3 False color
25a23
>       | s `elem` "#■" -> filledPolygon r 4 False color
25a24
>       | s `elem` "◆" -> filledPolygon r 4 True color
25a25
>       | otherwise -> filledCircles r color
32c32
< points ∷ F.Foldable f ⇒ PointOption → (Maybe (f Double), f Double) → EitherPlot
---
> points :: F.Foldable f => PointOption -> (Maybe (f Double), f Double) -> EitherPlot
39a40
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings, UnicodeSyntax #-}
{-# LANGUAGE FlexibleContexts #-}

module Graphics.Rendering.HPlot.Points where

import qualified Data.Foldable as F
import Graphics.Rendering.Chart
import Control.Lens
import Data.Default
import Graphics.Rendering.HPlot.Types
import Graphics.Rendering.HPlot.Utils
import Data.Maybe

toPointStyle ∷ PointOption → PointStyle
toPointStyle opt = case () of
    _ | s `elem` ".●" → filledCircles r color
      | s `elem` "o○" → hollowCircles r thick color
      | s `elem` "x" → exes r thick color
      | s `elem` "+" → plusses r thick color
      | s `elem` "*" → stars r thick color
      | s `elem` "v▼" → filledPolygon r 3 True color
      | s `elem` "^▲" → filledPolygon r 3 False color
      | s `elem` "#■" → filledPolygon r 4 False color
      | s `elem` "◆" → filledPolygon r 4 True color
      | otherwise → filledCircles r color
        where
            s = opt^.shape
            r = opt^.radius
            color = mkColor (opt^.col) (opt^.opacity)
            thick = opt^.lwd

points ∷ F.Foldable f ⇒ PointOption → (Maybe (f Double), f Double) → EitherPlot
points opt (x, y) | isNothing x = Left $ mkPlot $ addIndexes y'
                  | otherwise = Right $ mkPlot $ zip (F.toList $ fromJust x) y'
    where
        y' = F.toList y
        mkPlot x_y = toPlot $ plot_points_values .~ x_y
            $ plot_points_style .~ toPointStyle opt
            $ def
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings, UnicodeSyntax #-}
{-# LANGUAGE FlexibleContexts #-}

module Graphics.Rendering.HPlot.Points where

import qualified Data.Foldable as F
import Graphics.Rendering.Chart
import Control.Lens
import Data.Default
import Graphics.Rendering.HPlot.Types
import Graphics.Rendering.HPlot.Utils
import Data.Maybe

toPointStyle :: PointOption -> PointStyle
toPointStyle opt = case () of
    _ | s `elem` ".●" -> filledCircles r color
      | s `elem` "o○" -> hollowCircles r thick color
      | s `elem` "x" -> exes r thick color
      | s `elem` "+" -> plusses r thick color
      | s `elem` "*" -> stars r thick color
      | s `elem` "v▼" -> filledPolygon r 3 True color
      | s `elem` "^▲" -> filledPolygon r 3 False color
      | s `elem` "#■" -> filledPolygon r 4 False color
      | s `elem` "◆" -> filledPolygon r 4 True color
      | otherwise -> filledCircles r color
        where
            s = opt^.shape
            r = opt^.radius
            color = mkColor (opt^.col) (opt^.opacity)
            thick = opt^.lwd

points :: F.Foldable f => PointOption -> (Maybe (f Double), f Double) -> EitherPlot
points opt (x, y) | isNothing x = Left $ mkPlot $ addIndexes y'
                  | otherwise = Right $ mkPlot $ zip (F.toList $ fromJust x) y'
    where
        y' = F.toList y
        mkPlot x_y = toPlot $ plot_points_values .~ x_y
            $ plot_points_style .~ toPointStyle opt
            $ def

</pre>