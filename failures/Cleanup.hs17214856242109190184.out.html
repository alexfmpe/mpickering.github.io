<a href="CleanModules.hs742794292821225633.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ClGam.hs12108846861783878630.out.html">next</a></br></br><pre>12c12
< {-# LINE 33 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
---
> 
12a13
> 
12a14
> 
12a15
> 
12a16
> 
12a17
> 
12a18
> 
12a19
> 
12a20
> 
12a21
> 
12a22
> 
12a23
> 
12a24
> 
12a25
> 
12a26
> 
12a27
> 
12a28
> 
12a29
> 
12a30
> 
12a31
> 
12a32
> 
42c62
< {-# LINE 64 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
---
> 
42a63
> 
53c74
< {-# LINE 116 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
---
> 
53a75
> 
53a76
> 
53a77
> 
53a78
> 
53a79
> 
53a80
> 
53a81
> 
53a82
> 
53a83
> 
53a84
> 
53a85
> 
53a86
> 
53a87
> 
53a88
> 
53a89
> 
53a90
> 
53a91
> 
53a92
> 
53a93
> 
53a94
> 
53a95
> 
53a96
> 
53a97
> 
53a98
> 
53a99
> 
53a100
> 
53a101
> 
53a102
> 
53a103
> 
53a104
> 
53a105
> 
53a106
> 
53a107
> 
53a108
> 
53a109
> 
53a110
> 
53a111
> 
53a112
> 
53a113
> 
53a114
> 
53a115
> 
72a135
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Cleanup
( cpCleanupHSMod, cpCleanupHS, cpCleanupFoldEH, cpCleanupEH
, cpCleanupCore
, cpCleanupCU, cpCleanupFlow )
where
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import Control.Monad.State

{-# LINE 33 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
cpCleanupHSMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupHSMod modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHSSemMod        = Nothing
               }
      )

cpCleanupHS :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupHS modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHS              = Nothing
               , ecuMbHSSem           = Nothing
               }
      )

cpCleanupFoldEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupFoldEH modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbEH              = Nothing
               }
      )

cpCleanupEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupEH modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbEHSem           = Nothing
               }
      )

{-# LINE 64 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
cpCleanupCore :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCleanupCore modNmL
  = cpSeq [cl m | m <- modNmL]
  where cl m = cpUpdCU m
                  (\e -> e { ecuMbCore            = Nothing
                           , ecuMbCoreSem         = Nothing
                           , ecuMbCoreSemMod      = Nothing
                           }
                  )

{-# LINE 116 "src/ehc/EHC/CompilePhase/Cleanup.chs" #-}
cpCleanupCU :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupCU modNm
  = do { cpUpdCU modNm
           (\e -> e { ecuHIInfo            = {- HI.hiiRetainAfterCleanup -} (ecuHIInfo e)
                    , ecuMbOptim           = Nothing
                    }
           )
       }

cpCleanupFlow :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupFlow modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHSSemMod        = Nothing
               -- , ecuMbPrevHI          = Nothing
               -- , ecuMbPrevHISem       = Nothing
               -- , ecuMbPrevHIInfo      = Nothing
               }
      )

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Cleanup
( cpCleanupHSMod, cpCleanupHS, cpCleanupFoldEH, cpCleanupEH
, cpCleanupCore
, cpCleanupCU, cpCleanupFlow )
where
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import Control.Monad.State






















cpCleanupHSMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupHSMod modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHSSemMod        = Nothing
               }
      )

cpCleanupHS :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupHS modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHS              = Nothing
               , ecuMbHSSem           = Nothing
               }
      )

cpCleanupFoldEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupFoldEH modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbEH              = Nothing
               }
      )

cpCleanupEH :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupEH modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbEHSem           = Nothing
               }
      )



cpCleanupCore :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCleanupCore modNmL
  = cpSeq [cl m | m <- modNmL]
  where cl m = cpUpdCU m
                  (\e -> e { ecuMbCore            = Nothing
                           , ecuMbCoreSem         = Nothing
                           , ecuMbCoreSemMod      = Nothing
                           }
                  )











































cpCleanupCU :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupCU modNm
  = do { cpUpdCU modNm
           (\e -> e { ecuHIInfo            = {- HI.hiiRetainAfterCleanup -} (ecuHIInfo e)
                    , ecuMbOptim           = Nothing
                    }
           )
       }

cpCleanupFlow :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpCleanupFlow modNm
  = cpUpdCU modNm
      (\e -> e { ecuMbHSSemMod        = Nothing
               -- , ecuMbPrevHI          = Nothing
               -- , ecuMbPrevHISem       = Nothing
               -- , ecuMbPrevHIInfo      = Nothing
               }
      )


</pre>