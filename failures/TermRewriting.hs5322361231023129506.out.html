<a href="TermLike.hs1777724115269220094.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Terms.hs7537995051102246882.out.html">next</a></br></br><pre>16c16
< buildRule ∷ (View Vertex n, View [Port] n) ⇒ Term → Term → Rule n
---
> buildRule :: (View Vertex n, View [Port] n) => Term -> Term -> Rule n
18d17
<     root ← edge
19c18
<     varMap ← buildLHS root lhs
---
>     root <- edge
19a19
>     varMap <- buildLHS root lhs
22c22
< buildLHS ∷ (View Vertex n, View [Port] n) ⇒ Edge → Term → Pattern n VarMap
---
> buildLHS :: (View Vertex n, View [Port] n) => Edge -> Term -> Pattern n VarMap
24d23
<     Var v | isLower v → return $ Map.singleton v root
25d23
<     Var v | otherwise → do
26c24
<         c ← liftReader (edgeCardinality root)
---
>     Var v | isLower v -> return $ Map.singleton v root
26a25
>     Var v | otherwise -> do
26a26
>         c <- liftReader (edgeCardinality root)
28c28
<         Variable {name = n} ← nodeWith root
---
>         Variable {name = n} <- nodeWith root
31d30
<     App f x → do
32c31
<         c ← liftReader (edgeCardinality root)
---
>     App f x -> do
32a32
>         c <- liftReader (edgeCardinality root)
34c34
<         Applicator {inp = i, out1 = o1, out2 = o2} ← nodeWith root
---
>         Applicator {inp = i, out1 = o1, out2 = o2} <- nodeWith root
39c39
< buildRHS ∷ (View Vertex n, View [Port] n) ⇒ Edge → VarMap → Term → Rule n
---
> buildRHS :: (View Vertex n, View [Port] n) => Edge -> VarMap -> Term -> Rule n
43c43
<         (xEdge,fEdge) ← (,) <$> byEdge <*> byEdge
---
>         (xEdge,fEdge) <- (,) <$> byEdge <*> byEdge
50a51
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts #-}
module TermRewriting (buildRule) where

import Prelude.Unicode
import GraphRewriting
import Data.Char (isLower)
import Control.Applicative
import Data.Map (Map)
import qualified Data.Map as Map
import Term
import Graph


type VarMap = Map Char Edge

buildRule ∷ (View Vertex n, View [Port] n) ⇒ Term → Term → Rule n
buildRule lhs rhs = do
    root ← edge
    varMap ← buildLHS root lhs
    buildRHS root varMap rhs

buildLHS ∷ (View Vertex n, View [Port] n) ⇒ Edge → Term → Pattern n VarMap
buildLHS root term = case term of
    Var v | isLower v → return $ Map.singleton v root
    Var v | otherwise → do
        c ← liftReader (edgeCardinality root)
        require (c ≡ 2)
        Variable {name = n} ← nodeWith root
        require (n ≡ v)
        return Map.empty
    App f x → do
        c ← liftReader (edgeCardinality root)
        require (c ≡ 2)
        Applicator {inp = i, out1 = o1, out2 = o2} ← nodeWith root
        require (i ≡ root)
        Map.unionWithKey nonLinear <$> buildLHS o1 f <*> buildLHS o2 x
        where nonLinear v = error $ "Left-hand side is not linear as " ⧺ [v] ⧺ " occurs twice"

buildRHS ∷ (View Vertex n, View [Port] n) ⇒ Edge → VarMap → Term → Rule n
buildRHS root bindings term = replace $ build term root where

    build (App f x) inc = do
        (xEdge,fEdge) ← (,) <$> byEdge <*> byEdge
        byNode Applicator {inp = inc, out1 = fEdge, out2 = xEdge}
        build f fEdge >> build x xEdge >> return ()

    build (Var v) inc = if isLower v
        then maybe freeVar (byWire inc) (Map.lookup v bindings)
        else byNode Variable {inp = inc, name = v}
        where freeVar = error $ v : " occurs free on the right-hand side"
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, MultiParamTypeClasses, FlexibleInstances, FlexibleContexts #-}
module TermRewriting (buildRule) where

import Prelude.Unicode
import GraphRewriting
import Data.Char (isLower)
import Control.Applicative
import Data.Map (Map)
import qualified Data.Map as Map
import Term
import Graph


type VarMap = Map Char Edge

buildRule :: (View Vertex n, View [Port] n) => Term -> Term -> Rule n
buildRule lhs rhs = do
    root <- edge
    varMap <- buildLHS root lhs
    buildRHS root varMap rhs

buildLHS :: (View Vertex n, View [Port] n) => Edge -> Term -> Pattern n VarMap
buildLHS root term = case term of
    Var v | isLower v -> return $ Map.singleton v root
    Var v | otherwise -> do
        c <- liftReader (edgeCardinality root)
        require (c ≡ 2)
        Variable {name = n} <- nodeWith root
        require (n ≡ v)
        return Map.empty
    App f x -> do
        c <- liftReader (edgeCardinality root)
        require (c ≡ 2)
        Applicator {inp = i, out1 = o1, out2 = o2} <- nodeWith root
        require (i ≡ root)
        Map.unionWithKey nonLinear <$> buildLHS o1 f <*> buildLHS o2 x
        where nonLinear v = error $ "Left-hand side is not linear as " ⧺ [v] ⧺ " occurs twice"

buildRHS :: (View Vertex n, View [Port] n) => Edge -> VarMap -> Term -> Rule n
buildRHS root bindings term = replace $ build term root where

    build (App f x) inc = do
        (xEdge,fEdge) <- (,) <$> byEdge <*> byEdge
        byNode Applicator {inp = inc, out1 = fEdge, out2 = xEdge}
        build f fEdge >> build x xEdge >> return ()

    build (Var v) inc = if isLower v
        then maybe freeVar (byWire inc) (Map.lookup v bindings)
        else byNode Variable {inp = inc, name = v}
        where freeVar = error $ v : " occurs free on the right-hand side"

</pre>