<a href="ByteString.hs12672485902051724831.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ByteStringCompat.hs178077656332106102.out.html">next</a></br></br><pre>11c11
< #endif
---
> #endif{-# LANGUAGE Trustworthy #-}
14c14
< 
---
> {-# OPTIONS_GHC -fno-warn-name-shadowing #-}
16d15
< -- Module      : Data.Vector.Storable.ByteString
17d15
< -- Copyright   : (c) The University of Glasgow 2001,
18d15
< --               (c) David Roundy 2003-2005,
19d15
< --               (c) Simon Marlow 2005
20d15
< --               (c) Bjorn Bringert 2006
21d15
< --               (c) Don Stewart 2005-2008
22d15
< --               (c) Bas van Dijk 2011
23d15
< --
24d15
< --               Array fusion code:
25d15
< --               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
26d15
< --               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
27d15
< --
28d15
< -- License     : BSD-style
29d15
< --
30d15
< -- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
31d15
< -- Stability   : experimental
32d15
< --
33c16
< -- A time and space-efficient implementation of byte vectors using
---
> -- |-- Module      : Data.Vector.Storable.ByteString
33a17
> -- Module      : Data.Vector.Storable.ByteString-- Copyright   : (c) The University of Glasgow 2001,
33a18
> --               (c) David Roundy 2003-2005,-- Copyright   : (c) The University of Glasgow 2001,
33a19
> --               (c) Simon Marlow 2005--               (c) David Roundy 2003-2005,
33a20
> --               (c) Simon Marlow 2005--               (c) Bjorn Bringert 2006
33a21
> --               (c) Bjorn Bringert 2006--               (c) Don Stewart 2005-2008
33a22
> --               (c) Bas van Dijk 2011--               (c) Don Stewart 2005-2008
33a23
> ----               (c) Bas van Dijk 2011
33a24
> ----               Array fusion code:
33a25
> --               Array fusion code:--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
33a26
> --               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
33a27
> ----               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
33a28
> ---- License     : BSD-style
33a29
> ---- License     : BSD-style
33a30
> ---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
33a31
> -- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
33a32
> ---- Stability   : experimental
33a33
> ---- A time and space-efficient implementation of byte vectors using
33a34
> -- A time and space-efficient implementation of byte vectors using-- vectors of Word8, suitable for high performance use, both in terms
35d35
< -- of large data quantities, or high speed requirements. Byte vectors
36d35
< -- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
37d35
< -- and can be passed between C and Haskell with little effort.
38d35
< --
39d35
< -- This module is intended to be imported @qualified@, to avoid name
40d35
< -- clashes with "Prelude" functions.  eg.
41d35
< --
42d35
< -- > import qualified Data.Vector.Storable.ByteString as B
43d35
< --
44d35
< -- Original GHC implementation by Bryan O\'Sullivan.
45d35
< -- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
46d35
< -- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
47d35
< -- Polished and extended by Don Stewart.
48d35
< -- Redefined ByteString as a Vector (from the vector package) of Word8s
49c36
< -- by Bas van Dijk
---
> -- of large data quantities, or high speed requirements. Byte vectors-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
49a37
> -- and can be passed between C and Haskell with little effort.-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
49a38
> ---- and can be passed between C and Haskell with little effort.
49a39
> ---- This module is intended to be imported @qualified@, to avoid name
49a40
> -- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
49a41
> ---- clashes with "Prelude" functions.  eg.
49a42
> ---- > import qualified Data.Vector.Storable.ByteString as B
49a43
> ---- > import qualified Data.Vector.Storable.ByteString as B
49a44
> ---- Original GHC implementation by Bryan O\'Sullivan.
49a45
> -- Original GHC implementation by Bryan O\'Sullivan.-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
49a46
> -- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
49a47
> -- Polished and extended by Don Stewart.-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
49a48
> -- Polished and extended by Don Stewart.-- Redefined ByteString as a Vector (from the vector package) of Word8s
49a49
> -- by Bas van Dijk-- Redefined ByteString as a Vector (from the vector package) of Word8s
49a50
> ---- by Bas van Dijk
51d51
< 
53c53
< 
---
> module Data.Vector.Storable.ByteString (
54a55
>         ByteString-- * The ByteString type,             -- instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
56d56
< 
58d57
<         empty,                  -- :: ByteString
59d57
<         singleton,              -- :: Word8   -> ByteString
60c58
<         pack,                   -- :: [Word8] -> ByteString
---
>         empty-- * Introducing and eliminating ByteStrings,                  -- :: ByteString
60a59
>         emptysingleton,   ,              -- :: ByteString-- :: Word8   -> ByteString
60a60
>         singletonpack,    ,              -- :: Word8   -> ByteString
60a61
>         packunpack, ,                 -- :: [Word8] -> ByteString
62d62
< 
63a64
>         cons-- * Basic interface,                   -- :: Word8 -> ByteString -> ByteString
65c66
<         snoc,                   -- :: ByteString -> Word8 -> ByteString
---
>         snocappend, ,                 -- :: ByteString -> Word8 -> ByteString-- :: ByteString -> ByteString -> ByteString
67d67
< 
68a69
>         headuncons, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
70d70
< 
71a72
>         last,                   -- :: ByteString -> Word8-- :: ByteString -> ByteString
73d73
<         init,                   -- :: ByteString -> ByteString
74c74
<         null,                   -- :: ByteString -> Bool
---
>         init,                   -- :: ByteString -> Bool-- :: ByteString -> ByteString
74a75
>         nulllength, ,                 -- :: ByteString -> Int-- :: ByteString -> Bool
76d76
< 
78d77
<         map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
79c78
<         reverse,                -- :: ByteString -> ByteString
---
>         map-- * Transforming ByteStrings,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
79a79
>         mapreverse,   ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> ByteString -> ByteString
79a80
>         reverseintersperse,   ,            -- :: ByteString -> ByteString-- :: Word8 -> ByteString -> ByteString
81d81
< 
82a83
>         intercalatetranspose, ,            -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
84d84
< 
86d85
<         foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
87d85
<         foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
88c86
<         foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
>         foldl-- * Reducing ByteStrings (folds),                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
88a87
>         foldlfoldl',,                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
88a88
>         foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
88a89
>         foldl1foldl1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
90d90
< 
92d91
<         foldr',                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a
93c92
<         foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
>         foldrfoldr',,                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a
93a93
>         foldr',                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
93a94
>         foldr1foldr1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
95d95
< 
97d96
<         concat,                 -- :: [ByteString] -> ByteString
98c97
<         concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
---
>         concat-- ** Special folds,                 -- :: [ByteString] -> ByteString
98a98
>         concatconcatMap,  ,              -- :: [ByteString] -> ByteString-- :: (Word8 -> ByteString) -> ByteString -> ByteString
98a99
>         concatMapany,     ,              -- :: (Word8 -> Bool) -> ByteString -> Bool-- :: (Word8 -> ByteString) -> ByteString -> ByteString
100c101
<         all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
---
>         allmaximum,   ,                -- :: ByteString -> Word8-- :: (Word8 -> Bool) -> ByteString -> Bool
103d103
< 
105d104
<         -- ** Scans
106d104
<         scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
107d104
<         scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
108c105
<         scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
---
>         -- ** Scans-- * Building ByteStrings
108a106
>         scanl-- ** Scans,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
108a107
>         scanlscanl1,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
108a108
>         scanl1scanr,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
108a109
>         scanrscanr1,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
110d110
< 
111a112
>         mapAccumL-- ** Accumulating maps,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
114d114
< 
116d115
<         replicate,              -- :: Int -> Word8 -> ByteString
117c116
<         unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
---
>         replicate-- ** Generating and unfolding ByteStrings,              -- :: Int -> Word8 -> ByteString
117a117
>         replicateunfoldr, ,              -- :: Int -> Word8 -> ByteString-- :: (a -> Maybe (Word8, a)) -> a -> ByteString
117a118
>         unfoldrunfoldrN,,               -- :: (a -> Maybe (Word8, a)) -> a -> ByteString-- :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
119d119
< 
121c121
< 
---
>         -- * Substrings
122a123
>         take-- ** Breaking strings,                   -- :: Int -> ByteString -> ByteString
124d124
<         drop,                   -- :: Int -> ByteString -> ByteString
125c125
<         splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
---
>         dropsplitAt,  ,                -- :: Int -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
125a126
>         splitAttakeWhile, ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
127d127
<         dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
128d127
<         span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
129d127
<         spanEnd,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
130d127
<         break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
131d127
<         breakEnd,               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
132d127
<         group,                  -- :: ByteString -> [ByteString]
133c128
<         groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
---
>         dropWhilespan,    ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
133a129
>         spanspanEnd,  ,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
133a130
>         spanEndbreak, ,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
133a131
>         breakbreakEnd,  ,               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
133a132
>         breakEndgroup,  ,               -- :: ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
133a133
>         groupgroupBy, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
133a134
>         groupByinits, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
136d136
< 
138c138
<         split,                  -- :: Word8 -> ByteString -> [ByteString]
---
>         split-- ** Breaking into many substrings,                  -- :: Word8 -> ByteString -> [ByteString]
138a139
>         splitsplitWith,   ,              -- :: Word8 -> ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> [ByteString]
140d140
< 
141a142
>         isPrefixOf-- * Predicates,             -- :: ByteString -> ByteString -> Bool
143c144
<         isSuffixOf,             -- :: ByteString -> ByteString -> Bool
---
>         isSuffixOfisInfixOf,,             -- :: ByteString -> ByteString -> Bool
145d145
< 
147d146
<         breakSubstring,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
148c147
<         findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
---
>         breakSubstring-- ** Search for arbitrary substrings,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
148a148
>         breakSubstringfindSubstring,,         -- :: ByteString -> ByteString -> Maybe Int-- :: ByteString -> ByteString -> (ByteString,ByteString)
148a149
>         findSubstringfindSubstrings,,         -- :: ByteString -> ByteString -> [Int]-- :: ByteString -> ByteString -> Maybe Int
150d150
< 
152c152
< 
---
>         -- * Searching ByteStrings
154c154
<         elem,                   -- :: Word8 -> ByteString -> Bool
---
>         elem-- ** Searching by equality,                   -- :: Word8 -> ByteString -> Bool
154a155
>         elemnotElem,  ,                -- :: Word8 -> ByteString -> Bool
156d156
< 
158d157
<         find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
159c158
<         filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
---
>         find-- ** Searching with a predicate,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
159a159
>         findfilter, ,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
159a160
>         filterpartition,  ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
161d161
< 
163d162
<         index,                  -- :: ByteString -> Int -> Word8
164d162
<         elemIndex,              -- :: Word8 -> ByteString -> Maybe Int
165d162
<         elemIndices,            -- :: Word8 -> ByteString -> [Int]
166d162
<         elemIndexEnd,           -- :: Word8 -> ByteString -> Maybe Int
167d162
<         findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int
168c163
<         findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int]
---
>         index-- * Indexing ByteStrings,                  -- :: ByteString -> Int -> Word8
168a164
>         indexelemIndex,   ,              -- :: ByteString -> Int -> Word8-- :: Word8 -> ByteString -> Maybe Int
168a165
>         elemIndexelemIndices, ,            -- :: Word8 -> ByteString -> [Int]-- :: Word8 -> ByteString -> Maybe Int
168a166
>         elemIndiceselemIndexEnd,,           -- :: Word8 -> ByteString -> [Int]-- :: Word8 -> ByteString -> Maybe Int
168a167
>         elemIndexEndfindIndex,  ,           -- :: Word8 -> ByteString -> Maybe Int-- :: (Word8 -> Bool) -> ByteString -> Maybe Int
168a168
>         findIndexfindIndices, ,            -- :: (Word8 -> Bool) -> ByteString -> [Int]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int
168a169
>         findIndicescount,     ,            -- :: Word8 -> ByteString -> Int-- :: (Word8 -> Bool) -> ByteString -> [Int]
170d170
< 
172d171
<         zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
173c172
<         zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
---
>         zip-- * Zipping and unzipping ByteStrings,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
173a173
>         zipzipWith,   ,                -- :: ByteString -> ByteString -> [(Word8,Word8)]-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
173a174
>         zipWithunzip, ,                -- :: [(Word8,Word8)] -> (ByteString,ByteString)-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
175d175
< 
176a177
>         sort-- * Ordered ByteStrings,                   -- :: ByteString -> ByteString
178d178
< 
180c180
<         -- ** Copying ByteStrings
---
>         -- ** Copying ByteStrings-- * Low level conversions
180a181
>         copy-- ** Copying ByteStrings,                   -- :: ByteString -> ByteString
182d182
< 
184c184
<         packCString,            -- :: CString -> IO ByteString
---
>         packCString-- ** Packing CStrings and pointers,            -- :: CString -> IO ByteString
184a185
>         packCStringpackCStringLen,  ,         -- :: CString -> IO ByteString-- :: CStringLen -> IO ByteString
186d186
< 
188c188
<         useAsCString,           -- :: ByteString -> (CString    -> IO a) -> IO a
---
>         useAsCString-- ** Using ByteStrings as CStrings,           -- :: ByteString -> (CString    -> IO a) -> IO a
188a189
>         useAsCStringuseAsCStringLen,  ,        -- :: ByteString -> (CString    -> IO a) -> IO a
190d190
< 
192c192
< 
---
>         -- * I\/O with ByteStrings
194d193
<         getLine,                -- :: IO ByteString
195d193
<         getContents,            -- :: IO ByteString
196d193
<         putStr,                 -- :: ByteString -> IO ()
197c194
<         putStrLn,               -- :: ByteString -> IO ()
---
>         getLine-- ** Standard input and output,                -- :: IO ByteString
197a195
>         getLinegetContents,   ,            -- :: IO ByteString
197a196
>         getContentsputStr,    ,            -- :: IO ByteString-- :: ByteString -> IO ()
197a197
>         putStrputStrLn, ,               -- :: ByteString -> IO ()
197a198
>         putStrLn,               -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
199d199
< 
201d200
<         readFile,               -- :: FilePath -> IO ByteString
202c201
<         writeFile,              -- :: FilePath -> ByteString -> IO ()
---
>         readFile-- ** Files,               -- :: FilePath -> IO ByteString
202a202
>         readFilewriteFile,,              -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
202a203
>         writeFileappendFile,,             -- :: FilePath -> ByteString -> IO ()
204d204
< 
206d205
<         hGetLine,               -- :: Handle -> IO ByteString
207d205
<         hGetContents,           -- :: Handle -> IO ByteString
208d205
<         hGet,                   -- :: Handle -> Int -> IO ByteString
209d205
<         hGetSome,               -- :: Handle -> Int -> IO ByteString
210d205
<         hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
211d205
<         hPut,                   -- :: Handle -> ByteString -> IO ()
212d205
<         hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
213c206
<         hPutStr,                -- :: Handle -> ByteString -> IO ()
---
>         hGetLine-- ** I\/O with Handles,               -- :: Handle -> IO ByteString
213a207
>         hGetLinehGetContents,   ,           -- :: Handle -> IO ByteString
213a208
>         hGetContentshGet,       ,           -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
213a209
>         hGethGetSome,   ,               -- :: Handle -> Int -> IO ByteString
213a210
>         hGetSomehGetNonBlocking,      ,        -- :: Handle -> Int -> IO ByteString
213a211
>         hGetNonBlockinghPut,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
213a212
>         hPuthPutNonBlocking,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
213a213
>         hPutNonBlockinghPutStr,       ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
213a214
>         hPutStrhPutStrLn, ,              -- :: Handle -> ByteString -> IO ()
215d215
< 
218c218
< 
---
>   ) where
221c221
< -- Imports
---
> -- Imports--------------------------------------------------------------------------------
221a222
> -- Imports--------------------------------------------------------------------------------
223d223
< 
225d224
< import Control.Exception     ( finally )
226d224
< import Control.Monad         ( (>>=), (=<<), (>>), return, void, when )
227d224
< import Data.Bool             ( Bool(False, True), not, otherwise, (||) )
228d224
< import Data.Char             ( ord )
229d224
< import Data.Eq               ( (==), (/=) )
230d224
< import Data.Function         ( (.), flip )
231d224
< import Data.Functor          ( fmap )
232d224
< import Data.IORef            ( readIORef, writeIORef )
233d224
< import Data.Maybe            ( Maybe(Nothing, Just), isJust, listToMaybe )
234d224
< import Data.Ord              ( min, (<), (>), (>=) )
235d224
< import Data.Tuple            ( fst, snd )
236d224
< import Data.Word             ( Word8 )
237d224
< import Foreign.C.String      ( CString, CStringLen )
238d224
< import Foreign.C.Types       ( CSize )
239d224
< import Foreign.ForeignPtr    ( newForeignPtr, withForeignPtr )
240c225
< import Foreign.Marshal.Alloc ( allocaBytes, mallocBytes
---
> import-- from base:Control.Exception     ( finally )
240a226
> import Control.ExceptionControl.Monad         ( finally(>>=), ()=<<), (>>), return, void, when )
240a227
> import Control.MonadData.Bool             ( (Bool>>=),False=<<,),True>>)),not, otherwise, void,,when(||)))
240a228
> import Data.Bool             ( Boolord (False, True), not, otherwise, (||) )
240a229
> import Data.CharData.Eq               ( ord(==)) (/=) )
240a230
> import Data.EqData.Function         ( (==.)),flip/=)))
240a231
> import Data.FunctionData.Functor          ( (fmap.), flip)    )
240a232
> import Data.FunctorData.IORef            ( fmapreadIORef)   , writeIORef )
240a233
> import Data.IORef            ( readIORefMaybe(Nothing, writeIORef, Just), )isJust, listToMaybe )
240a234
> import Data.MaybeData.Ord              ( Maybemin, (Nothing<), (>), Just(>=)), isJust, listToMaybe )
240a235
> import Data.OrdData.Tuple            ( min, (snd<),)(>), (>=) )
240a236
> import Data.TupleData.Word             ( fstWord8, snd)  )
240a237
> import Data.WordForeign.C.String      ( Word8CString), CStringLen )
240a238
> import Foreign.C.StringForeign.C.Types       ( CStringCSize ), CStringLen )
240a239
> import Foreign.C.TypesForeign.ForeignPtr    ( CSizenewForeignPtr)      , withForeignPtr )
240a240
> import Foreign.ForeignPtrForeign.Marshal.Alloc ( newForeignPtrallocaBytes, ,mallocBytes )
240a241
> import Foreign.Marshal.Alloc ( allocaBytesreallocBytes,,mallocBytesfinalizerFree
242d242
<                              )
243d242
< import Foreign.Marshal.Array ( allocaArray )
244d242
< import Foreign.Marshal.Utils ( copyBytes )
245d242
< import Foreign.Ptr           ( nullPtr, plusPtr, minusPtr, castPtr )
246c243
< import Foreign.Storable      ( peek, poke
---
> import Foreign.Marshal.Array ) allocaArray )
246a244
> import Foreign.Marshal.Array ( allocaArraycopyBytes ) )
246a245
> import Foreign.Marshal.UtilsForeign.Ptr           ( copyBytesnullPtr, plusPtr)     , minusPtr, castPtr )
246a246
> import Foreign.PtrForeign.Storable      ( nullPtrpeek, poke, plusPtr, minusPtr, castPtr )
246a247
> import Foreign.Storable      ( peekpeekElemOff, poke , pokeElemOff
248c249
<                              , peekByteOff, pokeByteOff
---
>                              , peekByteOffsizeOf     , pokeByteOff
250d250
<                              )
251c251
< import Prelude               ( (+),(-),(*), ($), ($!)
---
> import Prelude               ) (+),(-),(*), ($), ($!)
251a252
> import Prelude               ( (Int+),(-fromIntegral),(*), ($),,($!String)   , error, undefined
253d253
<                              )
254d253
< import System.IO             ( IO, FilePath, Handle
255d253
<                              , IOMode(ReadMode, WriteMode, AppendMode)
256d253
<                              , stdin, stdout
257d253
<                              , hGetBuf, hGetBufSome, hGetBufNonBlocking
258c254
<                              , hPutBuf, hPutBufNonBlocking, hFileSize
---
> import System.IO             ) IO, FilePath, Handle
258a255
> import System.IO             ( IOIOMode, FilePath(ReadMode, Handle, WriteMode, AppendMode)
258a256
>                              , IOModestdin,(ReadModestdout  , WriteMode, AppendMode)
258a257
>                              , stdinhGetBuf, stdout, hGetBufSome, hGetBufNonBlocking
258a258
>                              , hGetBuf, hGetBufSomehPutBufNonBlocking, hGetBufNonBlocking, hFileSize
258a259
>                              , hPutBufwithBinaryFile, hPutBufNonBlocking, hClose     , hFileSize
260d260
<                              )
261d260
< import System.IO.Unsafe      ( unsafePerformIO )
262c261
< import System.IO.Error       ( ioError, mkIOError, illegalOperationErrorType )
---
> import System.IO.Unsafe      ) unsafePerformIO )
262a262
> import System.IO.UnsafeSystem.IO.Error       ( unsafePerformIOioError, mkIOError) , illegalOperationErrorType )
262a263
> import System.IO.ErrorText.Show             ( ioErrorshow, showsPrec, mkIOError) , illegalOperationErrorType )
264d264
< 
266c266
<     ( intersperse, transpose, map, reverse )
---
> import( interspersequalified Data.List, transposeas, Lmap, reverse )
266a267
> import intersperseData.List , transpose(++) )   , map, reverse )
268d268
< 
269a270
> import GHC.IO.Handle.Internals ( wantReadableHandle_ioe_EOF            , flushCharReadBuffer
271d271
<                                )
272d271
< import GHC.IO.Handle.Types     ( Handle__(..) )
273c272
< import GHC.IO.Buffer           ( RawBuffer, Buffer(Buffer), bufRaw, bufL, bufR
---
> import GHC.IO.Handle.Types     ) Handle__(..) )
273a273
> import GHC.IO.Handle.TypesGHC.IO.Buffer           ( Handle__RawBuffer(.., )Buffer)   (Buffer), bufRaw, bufL, bufR
273a274
> import GHC.IO.Buffer           ( RawBufferwithRawBuffer, Buffer, isEmptyBuffer(Buffer), bufRaw, readWord8Buf, bufL, bufR
275c276
<                                )
---
> import GHC.IO.BufferedIO as Buffered)     ( fillReadBuffer )
277d277
< 
278a279
> import-- from primitive:Control.Monad.Primitive ( unsafeInlineIO )
280d280
< 
281a282
> import-- from vector:qualified Data.Vector.Storable as VS
283d283
< 
285d284
< import Data.Vector.Storable.ByteString.Internal
286d284
<     ( ByteString
287d284
<     , create, unsafeCreate, createAndTrim, createAndTrim'
288d284
<     , mallocByteString
289c285
<     , memcpy, memset, memchr, memcmp
---
> import-- from vector-bytestring (this package):Data.Vector.Storable.ByteString.Internal
289a286
> import( ByteStringData.Vector.Storable.ByteString.Internal
289a287
>     ( ByteStringcreate, unsafeCreate, createAndTrim, createAndTrim'
289a288
>     , createmallocByteString, unsafeCreate, createAndTrim, createAndTrim'
289a289
>     , mallocByteStringmemcpy, memset, memchr, memcmp
289a290
>     , memcpyc_strlen, memset, c_count, memchr, c_intersperse, memcmp
293d293
< 
295c295
< -- * Introducing and eliminating 'ByteString's
---
> -- * Introducing and eliminating 'ByteString's--------------------------------------------------------------------------------
295a296
> -- * Introducing and eliminating 'ByteString's--------------------------------------------------------------------------------
297d297
< 
299d298
< empty :: ByteString
300c299
< empty = VS.empty
---
> empty-- | /O(1)/ The empty 'ByteString':: ByteString
300a300
> empty ::= VS.empty
300a301
> empty{-# INLINE= VS.emptyempty #-}
302d302
< 
304d303
< singleton :: Word8 -> ByteString
305c304
< singleton = VS.singleton
---
> singleton-- | /O(1)/ Convert a 'Word8' into a 'ByteString':: Word8 -> ByteString
305a305
> singleton ::= VS.singleton -> ByteString
305a306
> singleton{-# INLINE=[VS.singleton1] singleton #-} -- Inline [1] for intercalate rule
307d307
< 
309d308
< --
310d308
< -- For applications with large numbers of string literals, pack can be a
311d308
< -- bottleneck. In such cases, consider using packAddress (GHC only).
312d308
< pack :: [Word8] -> ByteString
313c309
< pack = VS.fromList
---
> ---- | /O(n)/ Convert a @['Word8']@ into a 'ByteString'.
313a310
> ---- For applications with large numbers of string literals, pack can be a
313a311
> -- bottleneck. In such cases, consider using packAddress (GHC only).-- For applications with large numbers of string literals, pack can be a
313a312
> pack-- bottleneck. In such cases, consider using packAddress (GHC only).:: [Word8] -> ByteString
313a313
> pack ::= VS.fromListWord8] -> ByteString
313a314
> pack{-# INLINE= VS.fromListpack #-}
315d315
< 
317d316
< unpack :: ByteString -> [Word8]
318c317
< unpack = VS.toList
---
> unpack-- | /O(n)/ Converts a 'ByteString' to a @['Word8']@.:: ByteString -> [Word8]
318a318
> unpack ::= VS.toList -> [Word8]
318a319
> unpack{-# INLINE= VS.toListunpack #-}
321d321
< 
323c323
< --  * Basic interface
---
> --  * Basic interface--------------------------------------------------------------------------------
323a324
> --  * Basic interface--------------------------------------------------------------------------------
325d325
< 
327d326
< -- complexity, as it requires a memcpy.
328d326
< cons :: Word8 -> ByteString -> ByteString
329c327
< cons = VS.cons
---
> -- complexity, as it requires a memcpy.-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
329a328
> cons-- complexity, as it requires a memcpy.:: Word8 -> ByteString -> ByteString
329a329
> cons ::= VS.cons -> ByteString -> ByteString
329a330
> cons{-# INLINE= VS.conscons #-}
331d331
< 
333d332
< snoc :: ByteString -> Word8 -> ByteString
334c333
< snoc = VS.snoc
---
> snoc-- | /O(n)/ Append a byte to the end of a 'ByteString':: ByteString -> Word8 -> ByteString
334a334
> snoc ::= VS.snoc -> Word8 -> ByteString
334a335
> snoc{-# INLINE= VS.snocsnoc #-}
336d336
< 
338d337
< append :: ByteString -> ByteString -> ByteString
339c338
< append = (VS.++)
---
> append-- | /O(n)/ Append two ByteStrings:: ByteString -> ByteString -> ByteString
339a339
> append ::= (ByteStringVS.++)     -> ByteString -> ByteString
339a340
> append{-# INLINE= (VS.++append)  #-}
341d341
< 
343d342
< -- An exception will be thrown in the case of an empty ByteString.
344d342
< head :: ByteString -> Word8
345c343
< head = VS.head
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
345a344
> head-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> Word8
345a345
> head ::= VS.head -> Word8
345a346
> head{-# INLINE= VS.headhead #-}
347d347
< 
349d348
< -- An exception will be thrown in the case of an empty ByteString.
350d348
< tail :: ByteString -> ByteString
351c349
< tail = VS.tail
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
351a350
> tail-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> ByteString
351a351
> tail ::= VS.tail -> ByteString
351a352
> tail{-# INLINE= VS.tailtail #-}
353d353
< 
355d354
< -- if it is empty.
356d354
< uncons :: ByteString -> Maybe (Word8, ByteString)
357d354
< uncons v
358d354
<     | VS.length v == 0 = Nothing
359c355
<     | otherwise        = Just (VS.unsafeHead v, VS.unsafeTail v)
---
> -- if it is empty.-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
359a356
> uncons-- if it is empty.:: ByteString -> Maybe (Word8, ByteString)
359a357
> uncons ::v  ByteString -> Maybe (Word8, ByteString)
359a358
> uncons| VS.length        v == 0 = Nothing
359a359
>     | VS.length v == 0 = NothingJust (VS.unsafeHead v, VS.unsafeTail v)
359a360
> {-# INLINE otherwiseuncons #-}  = Just (VS.unsafeHead v, VS.unsafeTail v)
361d361
< 
363d362
< -- An exception will be thrown in the case of an empty ByteString.
364d362
< last :: ByteString -> Word8
365c363
< last = VS.last
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the last element of a ByteString, which must be finite and non-empty.
365a364
> last-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> Word8
365a365
> last ::= VS.last -> Word8
365a366
> last{-# INLINE= VS.lastlast #-}
367d367
< 
369d368
< -- An exception will be thrown in the case of an empty ByteString.
370d368
< init :: ByteString -> ByteString
371c369
< init = VS.init
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Return all the elements of a 'ByteString' except the last one.
371a370
> init-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> ByteString
371a371
> init ::= VS.init -> ByteString
371a372
> init{-# INLINE= VS.initinit #-}
373d373
< 
375d374
< null :: ByteString -> Bool
376c375
< null = VS.null
---
> null-- | /O(1)/ Test whether a ByteString is empty.:: ByteString -> Bool
376a376
> null ::= VS.null -> Bool
376a377
> null{-# INLINE= VS.nullnull #-}
378d378
< 
380d379
< length :: ByteString -> Int
381c380
< length = VS.length
---
> length-- | /O(1)/ 'length' returns the length of a ByteString as an 'Int'.:: ByteString -> Int
381a381
> length ::= VS.length -> Int
381a382
> length{-# INLINE= VS.lengthlength #-}
384d384
< 
386c386
< -- * Transforming ByteStrings
---
> -- * Transforming ByteStrings--------------------------------------------------------------------------------
386a387
> -- * Transforming ByteStrings--------------------------------------------------------------------------------
388d388
< 
390d389
< -- element of @xs@. This function is subject to array fusion.
391d389
< map :: (Word8 -> Word8) -> ByteString -> ByteString
392c390
< map = VS.map
---
> -- element of @xs@. This function is subject to array fusion.-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
392a391
> map-- element of @xs@. This function is subject to array fusion.:: (Word8 -> Word8) -> ByteString -> ByteString
392a392
> map ::= VS.mapWord8 -> Word8) -> ByteString -> ByteString
392a393
> map{-# INLINE= VS.mapmap #-}
394d394
< 
396d395
< reverse :: ByteString -> ByteString
397c396
< reverse = VS.reverse
---
> reverse-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.:: ByteString -> ByteString
397a397
> reverse ::= VS.reverse -> ByteString
397a398
> reverse{-# INLINE= VS.reversereverse #-}
399d399
< 
401d400
< -- 'ByteString' and \`intersperses\' that byte between the elements of
402d400
< -- the 'ByteString'.  It is analogous to the intersperse function on
403d400
< -- Lists.
404d400
< intersperse :: Word8 -> ByteString -> ByteString
405d400
< intersperse c v
406d400
<     | l < 2     = v
407d400
<     | otherwise = unsafeCreate (2*l-1) $ \p' -> withForeignPtr fp $ \p ->
408d400
<                     c_intersperse p' p (fromIntegral l) c
409d400
<     where
410c401
<       (fp, l) = VS.unsafeToForeignPtr0 v
---
> -- | /O(n)/ The 'intersperse' function takes a 'Word8' and a-- 'ByteString' and \`intersperses\' that byte between the elements of
410a402
> -- the 'ByteString'.  It is analogous to the intersperse function on-- 'ByteString' and \`intersperses\' that byte between the elements of
410a403
> -- Lists.-- the 'ByteString'.  It is analogous to the intersperse function on
410a404
> -- Lists.intersperse :: Word8 -> ByteString -> ByteString
410a405
> intersperse ::c vWord8 -> ByteString -> ByteString
410a406
> intersperse| l < 2 c v = v
410a407
>     | lotherwise 2     = vunsafeCreate (2*l-1) $ \p' -> withForeignPtr fp $ \p ->
410a408
>     | otherwise = unsafeCreatec_intersperse2*lp'-1) $fromIntegralp' -> withForeignPtrl) c      fp $ \p ->
410a409
>                 where           c_intersperse p' p (fromIntegral l) c
410a410
>     where(fp, l) = VS.unsafeToForeignPtr0 v
410a411
> {-# INLINEfp, lintersperse) = VS.unsafeToForeignPtr0#-}             v
412d412
< 
414d413
< -- 'ByteString's and concatenates the list after interspersing the first
415d413
< -- argument between each element of the list.
416d413
< intercalate :: ByteString -> [ByteString] -> ByteString
417c414
< intercalate s = VS.concat . L.intersperse s
---
> -- 'ByteString's and concatenates the list after interspersing the first-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
417a415
> -- argument between each element of the list.-- 'ByteString's and concatenates the list after interspersing the first
417a416
> intercalate-- argument between each element of the list.:: ByteString -> [ByteString] -> ByteString
417a417
> intercalate ::s =ByteStringVS.concat ->. L.intersperseByteString] ->s  ByteString
417a418
> intercalate{-# INLINE [s]=intercalate .#-} s
419d419
< 
421d420
< "ByteString specialise intercalate c -> intercalateByte" forall c s1 s2 .
422c421
<     intercalate (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
---
> {-# RULES"ByteString specialise intercalate c -> intercalateByte" forall c s1 s2 .
422a422
> "ByteString specialise intercalate c -> intercalateByte"intercalate (singleton c) (s1 : s2 : []) = intercalateWithByteforall c s1c s2 .s2
422a423
>   #-} (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
424d424
< 
427d426
< intercalateWithByte :: Word8 -> ByteString -> ByteString -> ByteString
428d426
< intercalateWithByte c v1 v2 =
429d426
<     unsafeCreate (l1 + l2 + 1) $ \ptr ->
430d426
<       withForeignPtr fp1 $ \p1 ->
431d426
<         withForeignPtr fp2 $ \p2 -> do
432d426
<           memcpy ptr p1 (fromIntegral l1)
433d426
<           poke (ptr `plusPtr` l1) c
434d426
<           memcpy (ptr `plusPtr` (l1 + 1)) p2 (fromIntegral l2)
435d426
<         where
436c427
<           (fp1, l1) = VS.unsafeToForeignPtr0 v1
---
> intercalateWithByte-- | /O(n)/ intercalateWithByte. An efficient way to join to two ByteStrings:: Word8 -> ByteString -> ByteString -> ByteString
436a428
> intercalateWithByte-- with a char. Around 4 times faster than the generalised join.c v1 v2 =
436a429
> intercalateWithByteunsafeCreate (l1::+ Word8l2 + 1->) $ByteString\ptr ->   -> ByteString -> ByteString
436a430
> intercalateWithBytewithForeignPtrcfp1 v2$ \=p1 ->
436a431
>     unsafeCreatewithForeignPtrl1 + l2fp2+$1)p2 \->ptrdo->
436a432
>           withForeignPtrmemcpy ptr fp1p1 ($fromIntegralp1 ->     l1)
436a433
>                      withForeignPtrpoke (ptr `plusPtr $`\p2)->c do
436a434
>                          memcpy ptr(ptrp1`plusPtrfromIntegral` (l1 + l11)) p2 (fromIntegral l2)
436a435
>                        where (ptr `plusPtr` l1) c
436a436
>                          memcpy(fp1, l1ptr) = `VS.unsafeToForeignPtr0plusPtr` (l1 + 1)) p2 (v1fromIntegral l2)
436a437
>         where(fp2, l2) = VS.unsafeToForeignPtr0 v2
436a438
> {-# INLINE(fp1intercalateWithByte, l1) = VS.unsafeToForeignPtr0#-}           v1
438d439
< {-# INLINE intercalateWithByte #-}
439d439
< 
440c440
< -- | The 'transpose' function transposes the rows and columns of its
---
> {-# INLINE-- | The 'transpose' function transposes the rows and columns of its #-}
442d441
< transpose :: [ByteString] -> [ByteString]
443d441
< transpose = L.map VS.fromList
444c442
<           . L.transpose
---
> transpose-- | The 'transpose' function transposes the rows and columns of its:: [ByteString] -> [ByteString]
444a443
> transpose-- 'ByteString' argument.= L.map VS.fromList
444a444
> transpose ::. L.transposeByteString] -> [ByteString]
444a445
> transpose = L.map VS.fromListVS.toList
444a446
> {-# INLINE.transpose#-}
447d448
< 
448d448
< 
452d451
< 
453c452
< foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
---
> -- * Reducing 'ByteString's (folds)
453a453
> foldl--------------------------------------------------------------------------------:: (a -> Word8 -> a) -> a -> ByteString -> a
455d454
< {-# INLINE foldl #-}
456d454
< 
457c455
< foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
---
> foldl{-# INLINE:: (afoldl-> Word8#-} -> a) -> a -> ByteString -> a
457a456
> foldl = VS.foldl
457a457
> {-# INLINEfoldl' :: (foldla -> Word8#-}  -> a) -> a -> ByteString -> a
459d458
< {-# INLINE foldl' #-}
460d458
< 
461c459
< foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
> foldl'{-# INLINE:: (afoldl'-> Word8#-} -> a) -> a -> ByteString -> a
461a460
> foldl' = VS.foldl'
461a461
> {-# INLINEfoldl1 :: (foldl'Word8 ->#-}Word8 -> Word8) -> ByteString -> Word8
463d462
< {-# INLINE foldl1 #-}
464d462
< 
465c463
< foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
> foldl1{-# INLINE:: (Word8foldl1->#-} -> Word8) -> ByteString -> Word8
465a464
> foldl1 = VS.foldl1
465a465
> {-# INLINEfoldl1' :: foldl1(Word8 #-}-> Word8 -> Word8) -> ByteString -> Word8
467d466
< {-# INLINE foldl1' #-}
468d466
< 
469c467
< foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
---
> foldl1'{-# INLINE:: (foldl1'Word8 ->#-} -> Word8) -> ByteString -> Word8
469a468
> foldl1' = VS.foldl1'
469a469
> {-# INLINEfoldr :: (Word8-> #-}a -> a) -> a -> ByteString -> a
471d470
< {-# INLINE foldr #-}
472d470
< 
473c471
< foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
---
> foldr{-# INLINE:: (Word8foldr->#-} -> a) -> a -> ByteString -> a
473a472
> foldr = VS.foldr
473a473
> {-# INLINEfoldr' :: (foldr #-}-> a -> a) -> a -> ByteString -> a
475d474
< {-# INLINE foldr' #-}
476d474
< 
477c475
< foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
> foldr'{-# INLINE:: (Word8foldr'->#-} -> a) -> a -> ByteString -> a
477a476
> foldr' = VS.foldr'
477a477
> {-# INLINEfoldr1 :: (foldr'Word8 ->#-}Word8 -> Word8) -> ByteString -> Word8
479d478
< {-# INLINE foldr1 #-}
480d478
< 
481c479
< foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
---
> foldr1{-# INLINE:: (Word8foldr1->#-} -> Word8) -> ByteString -> Word8
481a480
> foldr1 = VS.foldr1
481a481
> {-# INLINEfoldr1' :: foldr1(Word8 #-}-> Word8 -> Word8) -> ByteString -> Word8
483d482
< {-# INLINE foldr1' #-}
484d482
< 
485c483
< --------------------------------------------------------------------------------
---
> foldr1'{-# INLINE:: (foldr1'Word8 ->#-} -> Word8) -> ByteString -> Word8
485a484
> foldr1' = VS.foldr1'
485a485
> {-# INLINE-------------------------------------------------------------------------------- #-}
487d486
< 
488c487
< -- | /O(n)/ Concatenate a list of ByteStrings.
---
> --------------------------------------------------------------------------------
488a488
> -- ** Special folds-- | /O(n)/ Concatenate a list of ByteStrings.
489a490
> concat-- | /O(n)/ Concatenate a list of ByteStrings.= VS.concat
489a491
> concat{-# INLINE:: [ByteStringconcat #-}] -> ByteString
491d492
< {-# INLINE concat #-}
492d492
< 
493c493
< -- | Map a function over a 'ByteString' and concatenate the results
---
> {-# INLINE-- | Map a function over a 'ByteString' and concatenate the results #-}
494a495
> concatMap-- | Map a function over a 'ByteString' and concatenate the results= VS.concatMap
494a496
> concatMap{-# INLINE::concatMapWord8 ->#-}) -> ByteString -> ByteString
496d497
< {-# INLINE concatMap #-}
497d497
< 
498c498
< -- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
---
> {-# INLINE-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if #-}
500c500
< any :: (Word8 -> Bool) -> ByteString -> Bool
---
> any-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if:: (Word8 -> Bool) -> ByteString -> Bool
500a501
> any-- any element of the 'ByteString' satisfies the predicate.= VS.any
500a502
> any{-# INLINE:: (Word8any->#-}) -> ByteString -> Bool
502d503
< {-# INLINE any #-}
503d503
< 
504c504
< -- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
---
> {-# INLINE-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines #-}
506c506
< all :: (Word8 -> Bool) -> ByteString -> Bool
---
> all-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines:: (Word8 -> Bool) -> ByteString -> Bool
506a507
> all-- if all elements of the 'ByteString' satisfy the predicate.= VS.all
506a508
> all{-# INLINE:: (Word8all->#-}) -> ByteString -> Bool
508d509
< {-# INLINE all #-}
509d509
< 
510c510
< -- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
---
> {-# INLINE-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString' #-}
512d511
< -- An exception will be thrown in the case of an empty ByteString.
513c512
< maximum :: ByteString -> Word8
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
513a513
> maximum-- This function will fuse.:: ByteString -> Word8
513a514
> maximum-- An exception will be thrown in the case of an empty ByteString.= VS.maximum
513a515
> maximum{-# INLINE:: ByteStringmaximum #-}-> Word8
515d516
< {-# INLINE maximum #-}
516d516
< 
517c517
< -- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
---
> {-# INLINE-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString' #-}
519d518
< -- An exception will be thrown in the case of an empty ByteString.
520c519
< minimum :: ByteString -> Word8
---
> -- An exception will be thrown in the case of an empty ByteString.-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
520a520
> minimum-- This function will fuse.:: ByteString -> Word8
520a521
> minimum-- An exception will be thrown in the case of an empty ByteString.= VS.minimum
520a522
> minimum{-# INLINE:: ByteStringminimum #-}-> Word8
523d524
< 
524d524
< 
528c528
< 
---
> -- * Building ByteStrings
531d530
< 
532c531
< -- | 'scanl' is similar to 'foldl', but returns a list of successive
---
> --------------------------------------------------------------------------------
532a532
> -- ** Scans-- | 'scanl' is similar to 'foldl', but returns a list of successive
534d533
< --
535c534
< -- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
---
> ---- | 'scanl' is similar to 'foldl', but returns a list of successive
535a535
> -- reduced values from the left. This function will fuse.-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
537c537
< -- Note that
---
> -- Note that-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
539c539
< -- > last (scanl f z xs) == foldl f z xs.
---
> -- Note that-- > last (scanl f z xs) == foldl f z xs.
541c541
< scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
---
> scanl-- > last (scanl f z xs) == foldl f z xs.:: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
541a542
> --scanl = VS.scanl
541a543
> scanl{-# INLINE:: (Word8scanl->#-} -> Word8) -> Word8 -> ByteString -> ByteString
543d544
< {-# INLINE scanl #-}
544d544
< 
545c545
< -- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
---
> {-# INLINE-- | 'scanl1' is a variant of 'scanl' that has no starting value argument. #-}
547d546
< --
548d546
< -- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
549c547
< scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
---
> ---- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
549a548
> -- This function will fuse.-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
549a549
> --scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
549a550
> scanl1-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]= VS.scanl1
549a551
> scanl1{-# INLINE:: (Word8scanl1->#-} -> Word8) -> ByteString -> ByteString
551d552
< {-# INLINE scanl1 #-}
552d552
< 
553c553
< -- | scanr is the right-to-left dual of scanl.
---
> {-# INLINE-- | scanr is the right-to-left dual of scanl. #-}
554a555
> scanr-- | scanr is the right-to-left dual of scanl.= VS.scanr
554a556
> scanr{-# INLINE:: (Word8scanr->#-} -> Word8) -> Word8 -> ByteString -> ByteString
556d557
< {-# INLINE scanr #-}
557d557
< 
558c558
< -- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
---
> {-# INLINE-- | 'scanr1' is a variant of 'scanr' that has no starting value argument. #-}
559a560
> scanr1-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.= VS.scanr1
559a561
> scanr1{-# INLINE:: (Word8scanr1->#-} -> Word8) -> ByteString -> ByteString
561d562
< {-# INLINE scanr1 #-}
562d562
< 
563c563
< --------------------------------------------------------------------------------
---
> {-# INLINE-------------------------------------------------------------------------------- #-}
565d564
< 
566c565
< -- | The 'mapAccumL' function behaves like a combination of 'map' and
---
> --------------------------------------------------------------------------------
566a566
> -- ** Accumulating maps-- | The 'mapAccumL' function behaves like a combination of 'map' and
568d567
< -- passing an accumulating parameter from left to right, and returning a
569d567
< -- final value of this accumulator together with the new list.
570d567
< mapAccumL :: (acc -> Word8 -> (acc, Word8))
571d567
<           -> acc -> ByteString -> (acc, ByteString)
572d567
< mapAccumL f acc v = unsafeInlineIO $ withForeignPtr fp $ \p -> do
573d567
<     fp' <- mallocByteString l
574d567
<     withForeignPtr fp' $ \p' ->
575d567
<       let go !a !m
576d567
<             | m >= l = return (a, VS.unsafeFromForeignPtr0 fp' l)
577d567
<             | otherwise = do
578d567
<                 x <- peekByteOff p m
579d567
<                 let (a', y) = f a x
580d567
<                 pokeByteOff p' m y
581d567
<                 go a' (m+1)
582d567
<       in go acc 0
583c568
<           where
---
> -- | The 'mapAccumL' function behaves like a combination of 'map' and-- passing an accumulating parameter from left to right, and returning a
583a569
> -- final value of this accumulator together with the new list.-- 'foldl'; it applies a function to each element of a ByteString,
583a570
> mapAccumL-- passing an accumulating parameter from left to right, and returning a:: (acc -> Word8 -> (acc, Word8))
583a571
> -- final value of this accumulator together with the new list.-> acc -> ByteString -> (acc, ByteString)
583a572
> mapAccumL ::f accaccv ->= unsafeInlineIO -> (acc,$Word8withForeignPtr))         fp $ \p -> do
583a573
>     fp' <-->mallocByteString -> ByteStringl  -> (acc, ByteString)
583a574
> mapAccumLwithForeignPtr acc v =fp'$ \p' ->    $ withForeignPtr fp $ \p -> do
583a575
> fp'let<-go!a !m          l
583a576
> withForeignPtr| m >= fp'l = $returnp' ->(a, VS.unsafeFromForeignPtr0 fp' l)
583a577
>      let go|!aotherwise!m      = do
583a578
>            | m >=x <- =peekByteOff (a,pVS.unsafeFromForeignPtr0m                       fp' l)
583a579
>            | otherwiselet (a',=ydo) = f a x
583a580
>                xpokeByteOff<- peekByteOffp' m p m
583a581
>                letgo a'a'(,+y) = f a x
583a582
>      in go acc pokeByteOff0           p' m y
583a583
>          where go a' (m+1)
583a584
>      in go acc(fp,0l) = VS.unsafeToForeignPtr0 v
583a585
> {-# INLINEwheremapAccumL #-}
585d586
< {-# INLINE mapAccumL #-}
586d586
< 
587c587
< -- | The 'mapAccumR' function behaves like a combination of 'map' and
---
> {-# INLINE-- | The 'mapAccumR' function behaves like a combination of 'map' and #-}
589d588
< -- passing an accumulating parameter from right to left, and returning a
590d588
< -- final value of this accumulator together with the new ByteString.
591d588
< mapAccumR :: (acc -> Word8 -> (acc, Word8))
592d588
<           -> acc -> ByteString -> (acc, ByteString)
593d588
< mapAccumR f acc v = unsafeInlineIO $ withForeignPtr fp $ \p -> do
594d588
<     fp' <- mallocByteString l
595d588
<     withForeignPtr fp' $ \p' ->
596d588
<       let go !a !m
597d588
<             | m < 0     = return (a, VS.unsafeFromForeignPtr0 fp' l)
598d588
<             | otherwise = do
599d588
<                 x <- peekByteOff p m
600d588
<                 let (a', y) = f a x
601d588
<                 pokeByteOff p' m y
602d588
<                 go a' (m-1)
603d588
<       in go acc (l-1)
604c589
<           where
---
> -- | The 'mapAccumR' function behaves like a combination of 'map' and-- passing an accumulating parameter from right to left, and returning a
604a590
> -- 'foldr'; it applies a function to each element of a ByteString,-- final value of this accumulator together with the new ByteString.
604a591
> mapAccumR-- passing an accumulating parameter from right to left, and returning a:: (acc -> Word8 -> (acc, Word8))
604a592
> -- final value of this accumulator together with the new ByteString.-> acc -> ByteString -> (acc, ByteString)
604a593
> mapAccumR ::f accaccv ->= unsafeInlineIO -> (acc,$Word8withForeignPtr))         fp $ \p -> do
604a594
>     fp' <-->mallocByteString -> ByteStringl  -> (acc, ByteString)
604a595
> mapAccumRwithForeignPtr acc v =fp'$ \p' ->    $ withForeignPtr fp $ \p -> do
604a596
> fp'let<-go!a !m          l
604a597
> withForeignPtr| m < 0fp' $=\p'return->  (a, VS.unsafeFromForeignPtr0 fp' l)
604a598
>   let go|!aotherwise!m      = do
604a599
>         | m <  0<- peekByteOff= return (a, VS.unsafeFromForeignPtr0 fp' l)
604a600
>         | otherwiselet (a',=ydo) = f a x
604a601
>             xpokeByteOff<- peekByteOffp' m p m
604a602
>             letgo a'a'(,-y) = f a x
604a603
>   in go acc pokeByteOff(l-1)       p' m y
604a604
>       where go a' (m-1)
604a605
>   in go acc(fp,(l-1) VS.unsafeToForeignPtr0 v
604a606
> {-# INLINEwheremapAccumR #-}
606d607
< {-# INLINE mapAccumR #-}
607d607
< 
608c608
< --------------------------------------------------------------------------------
---
> {-# INLINE-------------------------------------------------------------------------------- #-}
610d609
< 
611c610
< -- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
---
> --------------------------------------------------------------------------------
611a611
> -- ** Generating and unfolding ByteStrings-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
613d612
< --
614c613
< -- > replicate n x = unfoldr n (\u -> Just (u,u)) x
---
> ---- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
614a614
> -- the value of every element. The following holds:
616c616
< replicate :: Int -> Word8 -> ByteString
---
> replicate-- > replicate n x = unfoldr n (\u -> Just (u,u)) x:: Int -> Word8 -> ByteString
616a617
> --replicate = VS.replicate
616a618
> replicate{-# INLINE::replicate -> Word8#-}  -> ByteString
618d619
< {-# INLINE replicate #-}
619d619
< 
620c620
< -- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
---
> {-# INLINE-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' #-}
622d621
< -- ByteString from a seed value.  The function takes the element and
623d621
< -- returns 'Nothing' if it is done producing the ByteString or returns
624d621
< -- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
625d621
< -- and @b@ is the seed value for further production.
626d621
< --
627d621
< -- Examples:
628d621
< --
629d621
< -- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
630c622
< -- > == pack [0, 1, 2, 3, 4, 5]
---
> -- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'-- ByteString from a seed value.  The function takes the element and
630a623
> -- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a-- returns 'Nothing' if it is done producing the ByteString or returns
630a624
> -- ByteString from a seed value.  The function takes the element and-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
630a625
> -- and @b@ is the seed value for further production.-- returns 'Nothing' if it is done producing the ByteString or returns
630a626
> ---- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
630a627
> -- Examples:-- and @b@ is the seed value for further production.
632c629
< unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
---
> -- Examples:-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
632a630
> ---- > == pack [0, 1, 2, 3, 4, 5]
632a631
> ---- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
632a632
> unfoldr-- > == pack [0, 1, 2, 3, 4, 5]:: (a -> Maybe (Word8, a)) -> a -> ByteString
632a633
> --unfoldr = VS.unfoldr
632a634
> unfoldr{-# INLINE:: (unfoldra -> Maybe#-} (Word8, a)) -> a -> ByteString
634d635
< {-# INLINE unfoldr #-}
635d635
< 
636c636
< -- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
---
> {-# INLINE-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed #-}
638d637
< -- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
639d637
< -- when the maximum length of the result is known.
640d637
< --
641c638
< -- The following equation relates 'unfoldrN' and 'unfoldr':
---
> -- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
641a639
> -- when the maximum length of the result is known.-- value.  However, the length of the result is limited by the first
641a640
> ---- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
641a641
> -- when the maximum length of the result is known.-- The following equation relates 'unfoldrN' and 'unfoldr':
643c643
< -- > snd (unfoldrN n f s) == take n (unfoldr f s)
---
> -- > snd (unfoldrN n f s) == take n (unfoldr f s)-- The following equation relates 'unfoldrN' and 'unfoldr':
645d644
< -- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/
646d644
< unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
647d644
< unfoldrN i f x0
648d644
<     | i < 0     = (VS.empty, Just x0)
649d644
<     | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
650d644
<   where
651d644
<     go !p !x !n =
652d644
<         case f x of
653d644
<           Nothing      -> return (0, n, Nothing)
654d644
<           Just (w, x')
655d644
<               | n == i    -> return (0, n, Just x)
656d644
<               | otherwise -> do
657c645
<                   poke p w
---
> -- > snd (unfoldrN n f s) == take n (unfoldr f s)-- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/
657a646
> --unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
657a647
> unfoldrN-- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/i f x0
657a648
> unfoldrN| i <::0 Int ->= ((VS.emptya -> Maybe, JustWord8x0), a)) -> a -> (ByteString, Maybe a)
657a649
> unfoldrN| otherwise f x0 = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
657a650
>   where i < 0     = (VS.empty, Just x0)
657a651
>     |gootherwise!p !x !n = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
657a652
>   where case f x of
657a653
>     go !p !Nothingx !n =      -> return (0, n, Nothing)
657a654
>         caseJust xwof, x')
657a655
>           Nothing| n == i -> return-> return0,(n, Nothingn, Just)x)
657a656
>           Just|(wotherwise, x')    -> do
657a657
>               | n ==poke p w-> return (0, n, Just x)
657a658
>               | otherwisego (p `plusPtr-> do ` 1) x' (n+1)
657a659
> {-# INLINE unfoldrN#-}p w
660d661
< 
661d661
< 
665c665
< 
---
> -- * Substrings
668d667
< 
669c668
< -- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
---
> --------------------------------------------------------------------------------
669a669
> -- ** Breaking strings-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
671c671
< take :: Int -> ByteString -> ByteString
---
> take-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix:: Int -> ByteString -> ByteString
671a672
> take-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.= VS.take
671a673
> take{-# INLINE:: Inttake-> ByteString#-}       -> ByteString
673d674
< {-# INLINE take #-}
674d674
< 
675c675
< -- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
---
> {-# INLINE-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@ #-}
677c677
< drop  :: Int -> ByteString -> ByteString
---
> drop-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@:: Int -> ByteString -> ByteString
677a678
> drop-- elements, or @[]@ if @n > 'length' xs@.= VS.drop
677a679
> drop{-# INLINE:: Intdrop-> ByteString#-}        -> ByteString
679d680
< {-# INLINE drop #-}
680d680
< 
681c681
< -- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
---
> {-# INLINE-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@. #-}
682a683
> splitAt-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.= VS.splitAt
682a684
> splitAt{-# INLINE:: IntsplitAt-> ByteString#-}       -> (ByteString, ByteString)
684d685
< {-# INLINE splitAt #-}
685d685
< 
686c686
< -- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
---
> {-# INLINE-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@, #-}
688d687
< -- satisfy @p@.
689c688
< takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
---
> -- satisfy @p@.-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
689a689
> takeWhile-- returns the longest prefix (possibly empty) of @xs@ of elements that:: (Word8 -> Bool) -> ByteString -> ByteString
689a690
> takeWhile-- satisfy @p@.f v = VS.unsafeTake (findIndexOrEnd (not . f) v) v
689a691
> takeWhile{-# INLINE::takeWhileWord8 ->#-}) -> ByteString -> ByteString
691d692
< {-# INLINE takeWhile #-}
692d692
< 
693c693
< -- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
---
> {-# INLINE-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@. #-}
694a695
> dropWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.f v = VS.unsafeDrop (findIndexOrEnd (not . f) v) v
694a696
> dropWhile{-# INLINE::dropWhileWord8 ->#-}) -> ByteString -> ByteString
696d697
< {-# INLINE dropWhile #-}
697d697
< 
698c698
< -- | 'span' @p xs@ breaks the ByteString into two segments. It is
---
> {-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It is #-}
700c700
< span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
---
> span-- | 'span' @p xs@ breaks the ByteString into two segments. It is:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
700a701
> span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@= VS.span
700a702
> span{-# INLINE:: (Word8[1] ->span#-}) -> ByteString -> (ByteString, ByteString)
702d703
< {-# INLINE [1] span #-}
703d703
< 
704c704
< {-# RULES
---
> {-# INLINE{-# RULES  [1] span #-}
706d705
<     span ((==) x) = spanByte x
707c706
< "ByteString specialise span (==x)" forall x.
---
> {-# RULESspan ((==) x) = spanByte x
707a707
> "ByteString specialise span (x==)" forall x.
707a708
>     span ((====x) x)spanByte= spanBytex  x
707a709
> "ByteString specialise span (==x)"#-}                              forall x.
709d710
<   #-}
710d710
< 
711c711
< -- | 'spanByte' breaks its ByteString argument at the first
---
> -- | 'spanByte' breaks its ByteString argument at the first#-}
714d713
< --
715d713
< -- > span  (=='c') "abcd" == spanByte 'c' "abcd"
716d713
< --
717d713
< spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
718d713
< spanByte c v = unsafeInlineIO $ withForeignPtr fp $ \p ->
719d713
<   let go !i | i >= l    = return (v, VS.empty)
720d713
<             | otherwise = do
721d713
<                 c' <- peekByteOff p i
722d713
<                 if c /= c'
723d713
<                   then return (VS.unsafeTake i v, VS.unsafeDrop i v)
724d713
<                   else go (i+1)
725c714
<   in go 0
---
> ---- | 'spanByte' breaks its ByteString argument at the first
725a715
> -- > span  (=='c') "abcd" == spanByte 'c' "abcd"-- occurence of a byte other than its argument. It is more efficient
725a716
> ---- than 'span (==)'
725a717
> --spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
725a718
> spanByte-- > span  (=='c') "abcd" == spanByte 'c' "abcd"c v = unsafeInlineIO $ withForeignPtr fp $ \p ->
725a719
> --let go !i | i >= l    = return (v, VS.empty)
725a720
> spanByte :: Word8| otherwise-> ByteString= do    -> (ByteString, ByteString)
725a721
> spanByte c v = unsafeInlineIOc' <- peekByteOff withForeignPtrp i          fp $ \p ->
725a722
>     let go !i | i >=   l /= =c'return (v, VS.empty)
725a723
>               | otherwisethen return= do  (VS.unsafeTake i v, VS.unsafeDrop i v)
725a724
>                   c'else<- peekByteOffgo (i+1)   p i
725a725
>     in go 0       if c /= c'
725a726
>         where       then return (VS.unsafeTake i v, VS.unsafeDrop i v)
725a727
>           (fp, l) = elseVS.unsafeToForeignPtr0 (i+1)          v
725a728
>   {-# INLINEin go 0  spanByte #-}
727c730
<         (fp, l) = VS.unsafeToForeignPtr0 v
---
> -- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.fp, l) = VS.unsafeToForeignPtr0 v
729d731
< 
730d731
< -- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
731d731
< -- We have
733d732
< -- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
734d732
< --
735d732
< -- and
736d732
< --
737d732
< -- > spanEnd (not . isSpace) v
738d732
< -- >    ==
739d732
< -- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
740c733
< --
---
> -- > spanEnd (not.isSpace) "x y z" == ("x y ","z")-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
740a734
> ---- We have
740a735
> ---- and
740a736
> ---- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
740a737
> ---- > spanEnd (not . isSpace) v
740a738
> -- and-- >    ==
740a739
> ---- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
740a740
> ---- > spanEnd (not . isSpace) v
740a741
> spanEnd-- >    ==:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
740a742
> spanEnd-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)p v = VS.splitAt (findFromEndUntil (not . p) v) v
740a743
> --{-# INLINE spanEnd #-}
742d744
< spanEnd p v = VS.splitAt (findFromEndUntil (not . p) v) v
743d744
< {-# INLINE spanEnd #-}
744d744
< 
745d744
< -- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
746c745
< --
---
> spanEnd-- | 'break' @p@ is equivalent to @'span' ('not' . p)@. v = VS.splitAt (findFromEndUntil (not . p) v) v
746a746
> {-# INLINE--         spanEnd #-}
748c748
< -- call to the specialised breakByte:
---
> -- call to the specialised breakByte:-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
750d749
< -- > break ((==) x) = breakByte x
751c750
< -- > break (==x) = breakByte x
---
> -- > break ((==) x) = breakByte x-- Under GHC, a rewrite rule will transform break (==) into a
751a751
> -- > break (==x) = breakByte x-- call to the specialised breakByte:
753d752
< break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
754c753
< break p v = (VS.unsafeTake n v, VS.unsafeDrop n v)
---
> break-- > break ((==) x) = breakByte x:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
754a754
> break-- > break (==x) = breakByte xp v = (VS.unsafeTake n v, VS.unsafeDrop n v)
754a755
> --  where
754a756
> break ::!n (Word8findIndexOrEnd-> Bool) ->p ByteStringv          -> (ByteString, ByteString)
754a757
> break{-# INLINE v =[(VS.unsafeTake] break #-}   n v, VS.unsafeDrop n v)
756d758
<       !n = findIndexOrEnd p v
757d758
< {-# INLINE [1] break #-}
758d758
< 
759d758
< {-# RULES
760c759
< "ByteString specialise break (x==)" forall x.
---
> {-# RULESn = findIndexOrEnd p v
760a760
> {-# INLINE"ByteString specialise break (x==)"[1] break #-}            forall x.
761a762
> {-# RULES"ByteString specialise break (==x)" forall x.
761a763
> "ByteString specialise break (x==)"break (==x) = breakByte x       forall x.
761a764
>   #-} ((==) x) = breakByte x
763d765
<     break (==x) = breakByte x
764d765
<   #-}
765d765
< 
766d765
< -- | 'breakByte' breaks its ByteString argument at the first occurence
767c766
< -- of the specified byte. It is more efficient than 'break' as it is
---
> -- | 'breakByte' breaks its ByteString argument at the first occurence (==x) = breakByte x
767a767
> -- of the specified byte. It is more efficient than 'break' as it is#-}
770d769
< -- > break (=='c') "abcd" == breakByte 'c' "abcd"
771d769
< --
772c770
< breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
---
> -- > break (=='c') "abcd" == breakByte 'c' "abcd"-- | 'breakByte' breaks its ByteString argument at the first occurence
772a771
> ---- of the specified byte. It is more efficient than 'break' as it is
772a772
> breakByte-- implemented with @memchr(3)@. I.e.:: Word8 -> ByteString -> (ByteString, ByteString)
772a773
> --breakByte x v = case VS.elemIndex x v of
772a774
> -- > break (=='c') "abcd" == breakByte 'c' "abcd"Nothing -> (v, VS.empty)
772a775
> --  Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
772a776
> breakByte{-# INLINE::breakByte ->#-} -> (ByteString, ByteString)
774d777
<     Nothing -> (v, VS.empty)
775d777
<     Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
776d777
< {-# INLINE breakByte #-}
777d777
< 
778d777
< -- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
779d777
< --
780c778
< -- breakEnd p == spanEnd (not.p)
---
> -- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString' -> (v, VS.empty)
780a779
> --  Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
780a780
> {-# INLINE-- breakEnd p == spanEnd (not.p) #-}
782d781
< breakEnd p v = VS.splitAt (findFromEndUntil p v) v
783d781
< {-# INLINE breakEnd #-}
784d781
< 
785d781
< -- | The 'group' function takes a ByteString and returns a list of
786d781
< -- ByteStrings such that the concatenation of the result is equal to the
787c782
< -- argument.  Moreover, each sublist in the result contains only equal
---
> breakEnd-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'p v = VS.splitAt (findFromEndUntil p v) v
787a783
> --{-# INLINE breakEnd #-}
787a784
> -- breakEnd p == spanEnd (not.p)
787a785
> breakEnd-- | The 'group' function takes a ByteString and returns a list of:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
787a786
> breakEnd-- ByteStrings such that the concatenation of the result is equal to the v = VS.splitAt (findFromEndUntil p v) v
787a787
> {-# INLINE-- argument.  Moreover, each sublist in the result contains only equal #-}
789d788
< --
790d788
< -- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
791d788
< --
792d788
< -- It is a special case of 'groupBy', which allows the programmer to
793d788
< -- supply their own equality test. It is about 40% faster than
794d788
< -- /groupBy (==)/
795d788
< group :: ByteString -> [ByteString]
796d788
< group v
797c789
<     | VS.null v = []
---
> ---- | The 'group' function takes a ByteString and returns a list of
797a790
> -- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]-- ByteStrings such that the concatenation of the result is equal to the
797a791
> ---- argument.  Moreover, each sublist in the result contains only equal
797a792
> -- elements.  For example,-- It is a special case of 'groupBy', which allows the programmer to
797a793
> ---- supply their own equality test. It is about 40% faster than
797a794
> -- /groupBy (==)/-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
797a795
> --group :: ByteString -> [ByteString]
797a796
> group-- It is a special case of 'groupBy', which allows the programmer tov
797a797
> -- supply their own equality test. It is about 40% faster than| VS.null v = []
797a798
> -- /groupBy (==)/| otherwise = ys : group zs
797a799
> groupwhere:: ByteString -> [ByteString]
797a800
> group v ys, zs) = spanByte (VS.unsafeHead v) v
797a801
> {-# INLINE VS.nullgroup =#-}]
799d802
<     where
800d802
<       (ys, zs) = spanByte (VS.unsafeHead v) v
801d802
< {-# INLINE group #-}
802d802
< 
803d802
< -- | The 'groupBy' function is the non-overloaded version of 'group'.
804d802
< groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
805c803
< groupBy  k v
---
> -- | The 'groupBy' function is the non-overloaded version of 'group'.where
805a804
> groupByys::, zs(Word8) = spanByte-> Word8(VS.unsafeHead-> Bool) -> ByteString) v     -> [ByteString]
805a805
> {-# INLINEgroupBy  k groupv     #-}
806a807
> -- | The 'groupBy' function is the non-overloaded version of 'group'.| otherwise = VS.unsafeTake n v : groupBy k (VS.unsafeDrop n v)
806a808
> groupBywhere:: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
806a809
> groupByn =k1v+ findIndexOrEnd (not . k (VS.unsafeHead v)) (VS.unsafeTail v)
806a810
> {-# INLINE VS.nullgroupBy = []#-}
808d811
<     where
809d811
<       n = 1 + findIndexOrEnd (not . k (VS.unsafeHead v)) (VS.unsafeTail v)
810d811
< {-# INLINE groupBy #-}
811d811
< 
812d811
< -- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
813d811
< inits :: ByteString -> [ByteString]
814c812
< inits v = [VS.unsafeTake s v | s <- [0..VS.length v]]
---
> -- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.where
814a813
> inits n::=ByteString + findIndexOrEnd-> [ByteStringnot . k (VS.unsafeHead v)) (VS.unsafeTail v)
814a814
> {-# INLINEinits v = [groupByVS.unsafeTake#-}   s v | s <- [0..VS.length v]]
816d815
< 
817d815
< -- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
818d815
< tails :: ByteString -> [ByteString]
819c816
< tails v | VS.null v = [VS.empty]
---
> -- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
819a817
> inits-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.:: ByteString -> [ByteString]
819a818
> inits v::=ByteStringVS.unsafeTake-> [ByteString v | s <-] [0..VS.length v]]
819a819
> {-# INLINEtails v | VS.null #-}v = [VS.empty]
820a821
> {-# INLINE-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.tails #-}
820a822
> tails :: ByteString -> [ByteString]
820a823
> tails-------------------------------------------------------------------------------- | VS.null v = [VS.empty]
820a824
> -- ** Breaking into many substrings otherwise = v : tails (VS.unsafeTail v)
822d825
< 
823d825
< --------------------------------------------------------------------------------
824d825
< -- ** Breaking into many substrings
825d825
< 
827d826
< -- argument, consuming the delimiter. I.e.
828c827
< --
---
> -- argument, consuming the delimiter. I.e.--------------------------------------------------------------------------------
828a828
> ---- ** Breaking into many substrings
830d829
< -- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
831d829
< -- > split 'x'  "x"          == ["",""]
832d829
< --
833c830
< -- and
---
> -- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
833a831
> -- > split 'x'  "x"          == ["",""]-- argument, consuming the delimiter. I.e.
835c833
< -- > intercalate [c] . split c == id
---
> -- and-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
835a834
> ---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
835a835
> -- > intercalate [c] . split c == id-- > split 'x'  "x"          == ["",""]
835a836
> ---- > split == splitWith . (==)
835a837
> ---- and
835a838
> ---- As for all splitting functions in this library, this function does
835a839
> -- > intercalate [c] . split c == id-- not copy the substrings, it just constructs new 'ByteStrings' that
838d841
< -- As for all splitting functions in this library, this function does
839d841
< -- not copy the substrings, it just constructs new 'ByteStrings' that
840d841
< -- are slices of the original.
841d841
< --
842c842
< split :: Word8 -> ByteString -> [ByteString]
---
> split-- As for all splitting functions in this library, this function does:: Word8 -> ByteString -> [ByteString]
842a843
> split-- not copy the substrings, it just constructs new 'ByteStrings' thatw v | l == 0    = []
842a844
> -- are slices of the original.| otherwise = go 0
842a845
> --  where
842a846
> split ::(fpWord8, l) =->VS.unsafeToForeignPtr0 -> [ByteStringv   ]
844c848
<           | otherwise = go 0
---
>       withFP otherwise= unsafeInlineIO= go 0  . withForeignPtr fp
846d849
<       (fp, l) = VS.unsafeToForeignPtr0 v
847d849
< 
848d849
<       withFP = unsafeInlineIO . withForeignPtr fp
849d849
< 
850c850
<       go !n | q == nullPtr = vec l'    : []
---
>       (gofp,nl) = VS.unsafeToForeignPtr0== nullPtr = vec l'    v []
852c852
<           where
---
>       withFPwhere= unsafeInlineIO . withForeignPtr fp
854d853
< 
855d853
<             q = withFP $ \p -> memchr (p `plusPtr` n) w (fromIntegral l')
856d853
<             i = withFP $ \p -> return (q `minusPtr` p)
857c854
< 
---
>       go !n | q == nullPtr = vec l'    : []
857a855
>             |  otherwise= withFP $ \p=->memchri-n)(: go`plusPtri+1)` n) w (fromIntegral l')
857a856
>           wherei = withFP $ \p -> return (q `minusPtr` p)
857a857
>             vec = VS.unsafeFromForeignPtr fp n
859d858
< {-# INLINE split #-}
860c859
< 
---
> {-# INLINE split = withFP#-}   $ \p -> memchr (p `plusPtr` n) w (fromIntegral l')
860a860
>             i = withFP $ \p -> return (q `minusPtr` p)
862d861
< -- separators, where the predicate returns True for a separator element.
863c862
< -- The resulting components do not contain the separators.  Two adjacent
---
> -- separators, where the predicate returns True for a separator element. = l - n
863a863
> {-# INLINE-- The resulting components do not contain the separators.  Two adjacent #-}
865d864
< --
866d864
< -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
867d864
< -- > splitWith (=='a') []        == []
868d864
< --
869d864
< splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
870c865
< splitWith pred v
---
> ---- | /O(n)/ Splits a 'ByteString' into components delimited by
870a866
> -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]-- separators, where the predicate returns True for a separator element.
870a867
> -- > splitWith (=='a') []        == []-- The resulting components do not contain the separators.  Two adjacent
870a868
> ---- separators result in an empty component in the output.  eg.
870a869
> --splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
870a870
> splitWith-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]pred v
870a871
> -- > splitWith (=='a') []        == []| l == 0    = []
870a872
> --  | otherwise = splitWith0 0 l
870a873
> splitWithwhere :: (Word8 -> Bool) -> ByteString -> [ByteString]
870a874
> splitWith(fp,predl) =vVS.unsafeToForeignPtr0 v
872d875
<     | otherwise = splitWith0 0 l
873d875
<     where
874d875
<       (fp, l) = VS.unsafeToForeignPtr0 v
875d875
< 
876d875
<       splitWith0 !off !len = unsafeInlineIO $ withForeignPtr fp $ \p ->
877d875
<         let vec = VS.unsafeFromForeignPtr fp off
878c876
<             go !idx
---
>     | otherwisesplitWith0=!splitWith0off !len = 0unsafeInlineIO            $ withForeignPtr fp $ \p ->
878a877
>     wherelet vec = VS.unsafeFromForeignPtr fp off
878a878
>       (fp, l)go=!VS.unsafeToForeignPtr0idx                    v
880d879
<                 | otherwise = do
881d879
<                     let sepIx = off + idx
882d879
<                     w <- peekElemOff p sepIx
883d879
<                     if pred w
884d879
<                       then return (vec idx : splitWith0 (sepIx+1) (len-idx-1))
885d879
<                       else go (idx+1)
886d879
<         in go 0
887d879
< {-# INLINE [1] splitWith #-}
888d879
< 
889d879
< {-# RULES
890d879
< "ByteString specialise splitWith (x==)" forall x.
891c880
<     splitWith ((==) x) = split x
---
>       splitWith0|!offotherwise!len ==unsafeInlineIOdo            $ withForeignPtr fp $ \p ->
891a881
>              let vec = VS.unsafeFromForeignPtrlet sepIx = off + idx fp off
891a882
>                  go !idx w <- peekElemOff p sepIx
891a883
>                      | idxif>=predw= return [vec idx]
891a884
>                      | otherwisethen return= do  (vec idx : splitWith0 (sepIx+1) (len-idx-1))
891a885
>                          letelsego =idx+1+ idx
891a886
>              in go 0     w <- peekElemOff p sepIx
891a887
>      {-# INLINE [1] splitWith pred#-}w
891a888
>                            then return (vec idx : splitWith0 (sepIx+1) (len-idx-1))
891a889
>      {-# RULES             else go (idx+1)
891a890
>      "ByteString specialise splitWith (x==)"in go 0                         forall x.
891a891
> {-# INLINEsplitWith[1](splitWith(==) x) = #-}split x
893d892
<     splitWith (==x) = split x
894d892
<   #-}
895d892
< 
896d892
< --------------------------------------------------------------------------------
897d892
< -- * Predicates
898c893
< --------------------------------------------------------------------------------
---
> {-# RULESsplitWith (==x) = split x
898a894
> "ByteString specialise splitWith (x==)"#-}                                   forall x.
898a895
>     splitWith ((==) x) = split x
898a896
> "ByteString specialise splitWith (==x)"--------------------------------------------------------------------------------forall x.
898a897
> -- * Predicates (==x) = split x
898a898
> --------------------------------------------------------------------------------#-}
901d900
< -- iff the first is a prefix of the second.
902d900
< isPrefixOf :: ByteString -> ByteString -> Bool
903c901
< isPrefixOf v1 v2
---
> -- iff the first is a prefix of the second.--------------------------------------------------------------------------------
903a902
> isPrefixOf-- * Predicates:: ByteString -> ByteString -> Bool
903a903
> isPrefixOf--------------------------------------------------------------------------------v1 v2
905d904
<     | l2 < l1   = False
906d904
<     | otherwise = unsafeInlineIO $
907d904
<                     withForeignPtr fp1 $ \p1 ->
908d904
<                       withForeignPtr fp2 $ \p2 -> do
909d904
<                         i <- memcmp p1 p2 (fromIntegral l1)
910d904
<                         return $! i == 0
911d904
<     where
912d904
<       (fp1, l1) = VS.unsafeToForeignPtr0 v1
913d904
<       (fp2, l2) = VS.unsafeToForeignPtr0 v2
914d904
< {-# INLINE isPrefixOf #-}
915d904
< 
916d904
< -- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
917d904
< -- iff the first is a suffix of the second.
918d904
< --
919d904
< -- The following holds:
920d904
< --
921c905
< -- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
---
> -- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'| l2 < l1   = False
921a906
> -- iff the first is a prefix of the second.| otherwise = unsafeInlineIO $
921a907
> isPrefixOf :: ByteStringwithForeignPtr-> ByteStringfp1 ->$ \Boolp1 ->
921a908
> isPrefixOf v1 v2      withForeignPtr fp2 $ \p2 -> do
921a909
>     | l1 == 0   = True  i <- memcmp p1 p2 (fromIntegral l1)
921a910
>     | l2 < l1   = False return $! i == 0
921a911
>     |where = unsafeInlineIO $
921a912
>       (fp1, l1) = VS.unsafeToForeignPtr0 fp1 $ \v1p1 ->
921a913
>             (fp2, l2) = VS.unsafeToForeignPtr0 fp2 $v2\p2 -> do
921a914
>           {-# INLINE isPrefixOf #-} <- memcmp p1 p2 (fromIntegral l1)
921a915
>                                   return $! i == 0
921a916
> -- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'where
921a917
> -- iff the first is a suffix of the second.fp1, l1) = VS.unsafeToForeignPtr0 v1
921a918
> --    (fp2, l2) = VS.unsafeToForeignPtr0 v2
921a919
> {-# INLINE-- The following holds: #-}
923d920
< -- However, the real implemenation uses memcmp to compare the end of the
924d920
< -- string only, with no reverse required..
925d920
< isSuffixOf :: ByteString -> ByteString -> Bool
926d920
< isSuffixOf v1 v2
927d920
<     | l1 == 0   = True
928d920
<     | l2 < l1   = False
929d920
<     | otherwise = unsafeInlineIO $
930d920
<                     withForeignPtr fp1 $ \p1 ->
931d920
<                       withForeignPtr fp2 $ \p2 -> do
932d920
<         i <- memcmp p1 (p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
933d920
<         return $! i == 0
934d920
<     where
935d920
<       (fp1, l1) = VS.unsafeToForeignPtr0 v1
936d920
<       (fp2, l2) = VS.unsafeToForeignPtr0 v2
937d920
< {-# INLINE isSuffixOf #-}
938c921
< 
---
> -- > isSuffixOf x y == reverse x `isPrefixOf` reverse y-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
938a922
> ---- iff the first is a suffix of the second.
938a923
> ---- However, the real implemenation uses memcmp to compare the end of the
938a924
> -- The following holds:-- string only, with no reverse required..
938a925
> --isSuffixOf :: ByteString -> ByteString -> Bool
938a926
> isSuffixOf-- > isSuffixOf x y == reverse x `isPrefixOf` reverse yv1 v2
938a927
> --  | l1 == 0   = True
938a928
> -- However, the real implemenation uses memcmp to compare the end of the| l2 < l1   = False
938a929
> -- string only, with no reverse required..| otherwise = unsafeInlineIO $
938a930
> isSuffixOf :: ByteStringwithForeignPtr-> ByteStringfp1 ->$ \Boolp1 ->
938a931
> isSuffixOf v1 v2      withForeignPtr fp2 $ \p2 -> do
938a932
>     | l1i==<-0memcmp= Truep1 (p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
938a933
>     | l2return l1  $!= Falsei == 0
938a934
>     |where = unsafeInlineIO $
938a935
>       (fp1, l1) = VS.unsafeToForeignPtr0 fp1 $ \v1p1 ->
938a936
>             (fp2, l2) = VS.unsafeToForeignPtr0 fp2 $v2\p2 -> do
938a937
>           {-# INLINE <-isSuffixOf p1#-}p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
938a938
>                   return $! i == 0
938a939
> -- | Check whether one string is a substring of another. @isInfixOfwhere
938a940
> -- p s@ is equivalent to @not (null (findSubstrings p s))@.fp1, l1) = VS.unsafeToForeignPtr0 v1
938a941
> isInfixOffp2,::l2ByteString) = VS.unsafeToForeignPtr0-> ByteString -> v2Bool
938a942
> {-# INLINEisInfixOf v1v2 = isJust#-}(findSubstring v1 v2)
938a943
> {-# INLINE isInfixOf #-}
940d944
< -- p s@ is equivalent to @not (null (findSubstrings p s))@.
941c945
< isInfixOf :: ByteString -> ByteString -> Bool
---
> -- p s@ is equivalent to @not (null (findSubstrings p s))@.--------------------------------------------------------------------------------
941a946
> isInfixOf--  ** Search for arbitrary substrings:: ByteString -> ByteString -> Bool
943d947
< {-# INLINE isInfixOf #-}
944d947
< 
945d947
< --------------------------------------------------------------------------------
946d947
< --  ** Search for arbitrary substrings
947d947
< 
948c948
< -- | Break a string on a substring, returning a pair of the part of the
---
> {-# INLINE-- | Break a string on a substring, returning a pair of the part of the #-}
950d949
< --
951d949
< -- The following relationships hold:
952d949
< --
953d949
< -- > break (== c) l == breakSubstring (singleton c) l
954d949
< --
955d949
< -- and:
956d949
< --
957d949
< -- > findSubstring s l ==
958d949
< -- >    if null s then Just 0
959d949
< -- >              else case breakSubstring s l of
960d949
< -- >                       (x,y) | null y    -> Nothing
961d949
< -- >                             | otherwise -> Just (length x)
962d949
< --
963d949
< -- For example, to tokenise a string, dropping delimiters:
964d949
< --
965d949
< -- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
966d949
< -- >     where (h,t) = breakSubstring x y
967d949
< --
968d949
< -- To skip to the first occurence of a string:
969d949
< --
970c950
< -- > snd (breakSubstring x y)
---
> ----------------------------------------------------------------------------------
970a951
> -- The following relationships hold:--  ** Search for arbitrary substrings
972c953
< -- To take the parts of a string before a delimiter:
---
> -- > break (== c) l == breakSubstring (singleton c) l-- | Break a string on a substring, returning a pair of the part of the
972a954
> ---- string prior to the match, and the rest of the string.
972a955
> ---- and:
972a956
> ---- The following relationships hold:
972a957
> ---- > findSubstring s l ==
972a958
> -- >    if null s then Just 0-- > break (== c) l == breakSubstring (singleton c) l
972a959
> ---- >              else case breakSubstring s l of
972a960
> -- and:-- >                       (x,y) | null y    -> Nothing
972a961
> ---- >                             | otherwise -> Just (length x)
972a962
> ---- > findSubstring s l ==
972a963
> -- >    if null s then Just 0-- For example, to tokenise a string, dropping delimiters:
972a964
> ---- >              else case breakSubstring s l of
972a965
> -- >                       (x,y) | null y    -> Nothing-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
972a966
> -- >     where (h,t) = breakSubstring x y-- >                             | otherwise -> Just (length x)
974c968
< -- > fst (breakSubstring x y)
---
> -- To skip to the first occurence of a string:-- For example, to tokenise a string, dropping delimiters:
976d969
< breakSubstring :: ByteString -- ^ String to search for
977d969
<                -> ByteString -- ^ String to search in
978d969
<                -> (ByteString, ByteString)
979d969
<                              -- ^ Head and tail of string broken at substring
980d969
< breakSubstring pat src = search 0 src
981c970
<   where
---
> -- > snd (breakSubstring x y)-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
981a971
> ---- >     where (h,t) = breakSubstring x y
981a972
> ---- To take the parts of a string before a delimiter:
981a973
> ---- To skip to the first occurence of a string:
981a974
> ---- > fst (breakSubstring x y)
981a975
> ---- > snd (breakSubstring x y)
981a976
> --breakSubstring :: ByteString -- ^ String to search for
981a977
> -- To take the parts of a string before a delimiter:-> ByteString -- ^ String to search in
981a978
> --             -> (ByteString, ByteString)
981a979
> -- > fst (breakSubstring x y)-- ^ Head and tail of string broken at substring
981a980
> --breakSubstring pat src = search 0 src
981a981
> breakSubstringwhere        :: ByteString -- ^ String to search for
981a982
>     search !n !->s  ByteString -- ^ String to search in
981a983
>         | VS.null-> (ByteString, ByteString(src, VS.empty)   ) -- not found
981a984
>         | pat `isPrefixOf` s =-- ^ Head and tail of string broken at substring(VS.take n src, s)
981a985
> breakSubstring| otherwise src = search= search src (n+1) (VS.unsafeTail s)
981a986
> {-# INLINEwhere    breakSubstring #-}
983d987
<         | VS.null s          = (src, VS.empty) -- not found
984d987
<         | pat `isPrefixOf` s = (VS.take n src, s)
985d987
<         | otherwise          = search (n+1) (VS.unsafeTail s)
986d987
< {-# INLINE breakSubstring #-}
987d987
< 
988d987
< -- | Get the first index of a substring in another string,
989d987
< --   or 'Nothing' if the string is not found.
990d987
< --   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.
991c988
< findSubstring :: ByteString -- ^ String to search for.
---
> -- | Get the first index of a substring in another string, VS.null s          = (src, VS.empty) -- not found
991a989
> --   or 'Nothing' if the string is not found. pat `isPrefixOf` s = (VS.take n src, s)
991a990
> --   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@. otherwise          = search (n+1) (VS.unsafeTail s)
991a991
> {-# INLINEfindSubstring:: ByteString#-}-- ^ String to search for.
992a993
> -- | Get the first index of a substring in another string,-> Maybe Int
992a994
> findSubstring--   or 'Nothing' if the string is not found.f i = listToMaybe (findSubstrings f i)
992a995
> {-# INLINE--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.findSubstring #-}
992a996
> findSubstring :: ByteString -- ^ String to search for.
992a997
> {-# DEPRECATED->findSubstring -- ^ String to seach in."findSubstring is deprecated in favour of breakSubstring." #-}
994d998
< findSubstring f i = listToMaybe (findSubstrings f i)
995d998
< {-# INLINE findSubstring #-}
996d998
< 
997d998
< {-# DEPRECATED findSubstring "findSubstring is deprecated in favour of breakSubstring." #-}
998d998
< 
999d998
< -- | Find the indexes of all (possibly overlapping) occurances of a
1000c999
< -- substring in a string.
---
> findSubstring-- | Find the indexes of all (possibly overlapping) occurances of a i = listToMaybe (findSubstrings f i)
1000a1000
> {-# INLINE-- substring in a string. #-}
1002c1002
< findSubstrings :: ByteString -- ^ String to search for.
---
> {-# DEPRECATED findSubstring:: ByteString "findSubstring is deprecated in favour of breakSubstring."-- ^ String to search for.                                 #-}
1004d1003
<                -> [Int]
1005d1003
< findSubstrings pat str
1006d1003
<     | VS.null pat = [0 .. VS.length str]
1007d1003
<     | otherwise   = search 0 str
1008d1003
<   where
1009d1003
<     search !ix !s
1010c1004
<         | VS.null s          = []
---
> -- | Find the indexes of all (possibly overlapping) occurances of a-> [Int]
1010a1005
> findSubstrings-- substring in a string.pat str
1010a1006
> --  | VS.null pat = [0 .. VS.length str]
1010a1007
> findSubstrings| otherwise:: ByteString= search 0 str-- ^ String to search for.
1010a1008
>   where        -> ByteString -- ^ String to seach in.
1010a1009
>     search !ix ->!s [Int]
1010a1010
> findSubstrings| VS.nullsstr       = []
1010a1011
>     | VS.null| pat pat`isPrefixOf= [0 ..`VS.lengths = ix : str]
1010a1012
>     | otherwise| otherwise= search 0 str=      ixs
1010a1013
>   where where
1010a1014
>     searchixs!ix=!ssearch (ix+1) (VS.unsafeTail s)
1010a1015
> {-# INLINE VS.nullfindSubstrings       #-}= []
1012c1017
<         | otherwise          =      ixs
---
> {-# DEPRECATED otherwisefindSubstrings="findSubstrings is deprecated in favour of breakSubstring."                                                   #-}
1015d1019
< {-# INLINE findSubstrings #-}
1016d1019
< 
1017d1019
< {-# DEPRECATED findSubstrings "findSubstrings is deprecated in favour of breakSubstring." #-}
1018d1019
< 
1019d1019
< 
1020c1020
< --------------------------------------------------------------------------------
---
> {-# INLINE-------------------------------------------------------------------------------- #-}
1022c1022
< --------------------------------------------------------------------------------
---
> {-# DEPRECATED-------------------------------------------------------------------------------- "findSubstrings is deprecated in favour of breakSubstring." #-}
1025d1024
< -- ** Searching by equality
1026d1024
< 
1027c1025
< -- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
---
> -- ** Searching by equality--------------------------------------------------------------------------------
1027a1026
> -- * Searching ByteStrings
1027a1027
> -- | /O(n)/ 'elem' is the 'ByteString' membership predicate.--------------------------------------------------------------------------------
1029d1028
< elem = VS.elem
1030d1028
< {-# INLINE elem #-}
1031d1028
< 
1032d1028
< -- | /O(n)/ 'notElem' is the inverse of 'elem'
1033d1028
< notElem :: Word8 -> ByteString -> Bool
1034d1028
< notElem = VS.notElem
1035c1029
< {-# INLINE notElem #-}
---
> elem--------------------------------------------------------------------------------= VS.elem
1035a1030
> {-# INLINE-- ** Searching by equalityelem #-}
1037d1031
< --------------------------------------------------------------------------------
1038c1032
< -- ** Searching with a predicate
---
> -- | /O(n)/ 'notElem' is the inverse of 'elem'-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
1038a1033
> elemnotElem:: Word8:: Word8-> ByteString-> ByteString-> Bool-> Bool
1038a1034
> elemnotElem= VS.elem= VS.notElem
1038a1035
> {-# INLINE elemnotElem#-}#-}
1040c1037
< -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
---
> -- | /O(n)/ 'notElem' is the inverse of 'elem'--------------------------------------------------------------------------------
1040a1038
> notElem-- ** Searching with a predicate:: Word8 -> ByteString -> Bool
1040a1039
> notElem = VS.notElem
1040a1040
> {-# INLINE-- | /O(n)/ The 'find' function takes a predicate and a ByteString, #-}
1042d1041
< -- if there is no such element.
1043c1042
< --
---
> -- if there is no such element.--------------------------------------------------------------------------------
1043a1043
> ---- ** Searching with a predicate
1045d1044
< --
1046d1044
< find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
1047d1044
< find = VS.find
1048d1044
< {-# INLINE find #-}
1049d1044
< 
1050d1044
< -- | /O(n)/ 'filter', applied to a predicate and a ByteString,
1051d1044
< -- returns a ByteString containing those characters that satisfy the
1052d1044
< -- predicate. This function is subject to array fusion.
1053c1045
< filter :: (Word8 -> Bool) -> ByteString -> ByteString
---
> ---- | /O(n)/ The 'find' function takes a predicate and a ByteString,
1053a1046
> find-- and returns the first element in matching the predicate, or 'Nothing':: (Word8 -> Bool) -> ByteString -> Maybe Word8
1053a1047
> find-- if there is no such element.= VS.find
1053a1048
> --{-# INLINE find #-}
1053a1049
> -- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
1053a1050
> ---- | /O(n)/ 'filter', applied to a predicate and a ByteString,
1053a1051
> find-- returns a ByteString containing those characters that satisfy the:: (Word8 -> Bool) -> ByteString -> Maybe Word8
1053a1052
> find-- predicate. This function is subject to array fusion.= VS.find
1053a1053
> {-# INLINEfilter :: (findWord8#-}-> Bool) -> ByteString -> ByteString
1055d1054
< {-# INLINE filter #-}
1056d1054
< 
1057d1054
< -- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1058d1054
< -- the pair of ByteStrings with elements which do and do not satisfy the
1059d1054
< -- predicate, respectively; i.e.,
1060c1055
< --
---
> {-# INLINE-- | /O(n)/ 'filter', applied to a predicate and a ByteString,filter #-}
1060a1056
> -- returns a ByteString containing those characters that satisfy the
1060a1057
> -- predicate. This function is subject to array fusion.-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1060a1058
> filter-- the pair of ByteStrings with elements which do and do not satisfy the:: (Word8 -> Bool) -> ByteString -> ByteString
1060a1059
> filter-- predicate, respectively; i.e.,= VS.filter
1060a1060
> {-# INLINE--         filter #-}
1061a1062
> ---- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
1061a1063
> partition-- the pair of ByteStrings with elements which do and do not satisfy the:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1061a1064
> partition-- predicate, respectively; i.e.,= VS.partition
1061a1065
> --{-# INLINE partition #-}
1061a1066
> -- > partition p bs == (filter p xs, filter (not . p) xs)
1063d1067
< partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1064d1067
< partition = VS.partition
1065d1067
< {-# INLINE partition #-}
1066d1067
< 
1067d1067
< 
1068d1067
< --------------------------------------------------------------------------------
1069d1067
< -- * Indexing ByteStrings
1070c1068
< --------------------------------------------------------------------------------
---
> partition--------------------------------------------------------------------------------:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
1070a1069
> partition-- * Indexing ByteStrings= VS.partition
1070a1070
> {-# INLINE-------------------------------------------------------------------------------- #-}
1073d1072
< index :: ByteString -> Int -> Word8
1074d1072
< index = (VS.!)
1075c1073
< {-# INLINE index #-}
---
> index--------------------------------------------------------------------------------:: ByteString -> Int -> Word8
1075a1074
> index-- * Indexing ByteStrings= (VS.!)
1075a1075
> {-# INLINE--------------------------------------------------------------------------------index #-}
1077d1076
< -- | /O(n)/ The 'elemIndex' function returns the index of the first
1078d1076
< -- element in the given 'ByteString' which is equal to the query
1079d1076
< -- element, or 'Nothing' if there is no such element.
1080c1077
< elemIndex :: Word8 -> ByteString -> Maybe Int
---
> -- | /O(n)/ The 'elemIndex' function returns the index of the first-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
1080a1078
> index-- element in the given 'ByteString' which is equal to the query:: ByteString -> Int -> Word8
1080a1079
> index-- element, or 'Nothing' if there is no such element.= (VS.!)
1080a1080
> {-# INLINEelemIndex ::Word8#-}-> ByteString -> Maybe Int
1082d1081
< {-# INLINE elemIndex #-}
1083d1081
< 
1084d1081
< -- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
1085d1081
< -- the indices of all elements equal to the query element, in ascending order.
1086d1081
< -- This implementation uses memchr(3).
1087d1081
< elemIndices :: Word8 -> ByteString -> [Int]
1088d1081
< elemIndices x v = VS.toList $ VS.elemIndices x v
1089d1081
< {-# INLINE elemIndices #-}
1090d1081
< 
1091c1082
< -- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
---
> {-# INLINE-- | /O(n)/ The 'elemIndex' function returns the index of the firstelemIndex #-}
1093d1083
< -- element, or 'Nothing' if there is no such element. The following
1094d1083
< -- holds:
1095d1083
< --
1096d1083
< -- > elemIndexEnd c xs ==
1097c1084
< -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
---
> -- element, or 'Nothing' if there is no such element.-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
1097a1085
> elemIndex-- the indices of all elements equal to the query element, in ascending order.:: Word8 -> ByteString -> Maybe Int
1097a1086
> elemIndex-- This implementation uses memchr(3).= VS.elemIndex
1097a1087
> {-# INLINEelemIndiceselemIndex:: Word8 #-}-> ByteString -> [Int]
1097a1088
> elemIndices x v = VS.toList $ VS.elemIndices x v
1097a1089
> {-# INLINE-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returningelemIndices #-}
1097a1090
> -- the indices of all elements equal to the query element, in ascending order.
1097a1091
> -- This implementation uses memchr(3).-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
1097a1092
> elemIndices-- element in the given 'ByteString' which is equal to the query:: Word8 -> ByteString -> [Int]
1097a1093
> elemIndices-- element, or 'Nothing' if there is no such element. The following v = VS.toList $ VS.elemIndices x v
1097a1094
> {-# INLINE-- holds:  elemIndices #-}
1099d1095
< elemIndexEnd :: Word8 -> ByteString -> Maybe Int
1100d1095
< elemIndexEnd x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
1101d1095
<     let go !i | i < 0     = return Nothing
1102d1095
<               | otherwise = do
1103d1095
<                   x' <- peekByteOff p i
1104d1095
<                   if x == x'
1105d1095
<                     then return $ Just i
1106d1095
<                     else go (i-1)
1107d1095
<     in go (l - 1)
1108d1095
<         where
1109d1095
<           (fp, l) = VS.unsafeToForeignPtr0 v
1110d1095
< {-# INLINE elemIndexEnd #-}
1111d1095
< 
1112d1095
< -- | The 'findIndex' function takes a predicate and a 'ByteString' and
1113d1095
< -- returns the index of the first element in the ByteString
1114d1095
< -- satisfying the predicate.
1115c1096
< findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
---
> -- > elemIndexEnd c xs ==-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
1115a1097
> -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- element in the given 'ByteString' which is equal to the query
1115a1098
> ---- element, or 'Nothing' if there is no such element. The following
1115a1099
> -- holds:elemIndexEnd :: Word8 -> ByteString -> Maybe Int
1115a1100
> --elemIndexEnd x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
1115a1101
> -- > elemIndexEnd c xs ==let go !i | i < 0     = return Nothing
1115a1102
> -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)| otherwise = do
1115a1103
> --                x' <- peekByteOff p i
1115a1104
> elemIndexEnd :: Word8if x->==ByteStringx'        -> Maybe Int
1115a1105
> elemIndexEnd x v = unsafeInlineIOthen return $ $Justi           fp $ \p ->
1115a1106
> let go !i | i < 0else go= return(i-1)  Nothing
1115a1107
> in go (l -|1otherwise)         = do
1115a1108
>     where     x' <- peekByteOff p i
1115a1109
>       (fp, l) if= VS.unsafeToForeignPtr0 == x'               v
1115a1110
> {-# INLINE elemIndexEndthen#-} $ Just i
1115a1111
>                 else go (i-1)
1115a1112
> -- | The 'findIndex' function takes a predicate and a 'ByteString' andin go (l - 1)
1115a1113
> -- returns the index of the first element in the ByteStringwhere
1115a1114
> -- satisfying the predicate.fp, l) = VS.unsafeToForeignPtr0 v
1115a1115
> {-# INLINEfindIndex ::(Word8 -> Bool#-}) -> ByteString -> Maybe Int
1117d1116
< {-# INLINE findIndex #-}
1118d1116
< 
1119d1116
< -- | The 'findIndices' function extends 'findIndex', by returning the
1120d1116
< -- indices of all elements satisfying the predicate, in ascending order.
1121d1116
< findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
1122c1117
< findIndices pred v = VS.toList $ VS.findIndices pred v
---
> {-# INLINE-- | The 'findIndex' function takes a predicate and a 'ByteString' andfindIndex #-}
1122a1118
> -- returns the index of the first element in the ByteString
1122a1119
> -- satisfying the predicate.-- | The 'findIndices' function extends 'findIndex', by returning the
1122a1120
> findIndex-- indices of all elements satisfying the predicate, in ascending order.:: (Word8 -> Bool) -> ByteString -> Maybe Int
1122a1121
> findIndexfindIndices= VS.findIndex:: (Word8 -> Bool) -> ByteString -> [Int]
1122a1122
> {-# INLINEfindIndicesfindIndexpred v = #-}VS.toList $ VS.findIndices pred v
1124d1123
< 
1125d1123
< -- | count returns the number of times its argument appears in the ByteString
1126d1123
< --
1127d1123
< -- > count = length . elemIndices
1128c1124
< --
---
> -- | The 'findIndices' function extends 'findIndex', by returning the
1128a1125
> -- indices of all elements satisfying the predicate, in ascending order.-- | count returns the number of times its argument appears in the ByteString
1128a1126
> findIndices--          :: (Word8 -> Bool) -> ByteString -> [Int]
1128a1127
> findIndices-- > count = length . elemIndices v = VS.toList $ VS.findIndices pred v
1128a1128
> {-# INLINE--         findIndices #-}
1130c1130
< count :: Word8 -> ByteString -> Int
---
> count-- | count returns the number of times its argument appears in the ByteString:: Word8 -> ByteString -> Int
1130a1131
> --count x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
1130a1132
> -- > count = length . elemIndicesfmap fromIntegral $ c_count p (fromIntegral l) x
1130a1133
> --      where
1130a1134
> -- But more efficiently than using length on the intermediate list.(fp, l) = VS.unsafeToForeignPtr0 v
1130a1135
> count{-# INLINE:: Word8count->#-} -> Int
1133d1137
<         where
1134d1137
<           (fp, l) = VS.unsafeToForeignPtr0 v
1135d1137
< {-# INLINE count #-}
1136d1137
< 
1137d1137
< 
1138d1137
< --------------------------------------------------------------------------------
1139d1137
< -- * Zipping and unzipping ByteStrings
1140c1138
< --------------------------------------------------------------------------------
---
> --------------------------------------------------------------------------------where
1140a1139
> -- * Zipping and unzipping ByteStringsfp, l) = VS.unsafeToForeignPtr0 v
1140a1140
> {-# INLINE-------------------------------------------------------------------------------- #-}
1143d1142
< -- corresponding pairs of bytes. If one input ByteString is short,
1144d1142
< -- excess elements of the longer ByteString are discarded. This is
1145c1143
< -- equivalent to a pair of 'unpack' operations.
---
> -- corresponding pairs of bytes. If one input ByteString is short,--------------------------------------------------------------------------------
1145a1144
> -- * Zipping and unzipping ByteStrings-- excess elements of the longer ByteString are discarded. This is
1145a1145
> -- equivalent to a pair of 'unpack' operations.--------------------------------------------------------------------------------
1146a1147
> zip-- | /O(n)/ 'zip' takes two ByteStrings and returns a list ofv1 v2
1146a1148
> -- corresponding pairs of bytes. If one input ByteString is short,| VS.null v1 || VS.null v2 = []
1146a1149
> -- excess elements of the longer ByteString are discarded. This is| otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
1146a1150
> -- equivalent to a pair of 'unpack' operations.: zip (VS.unsafeTail v1) (VS.unsafeTail v2)
1146a1151
> zip{-# INLINE:: ByteStringzip #-}-> ByteString -> [(Word8,Word8)]
1148d1152
<     | VS.null v1 || VS.null v2 = []
1149d1152
<     | otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
1150d1152
<                 : zip (VS.unsafeTail v1) (VS.unsafeTail v2)
1151d1152
< {-# INLINE zip #-}
1152d1152
< 
1153d1152
< -- | 'zipWith' generalises 'zip' by zipping with the function given as
1154d1152
< -- the first argument, instead of a tupling function.  For example,
1155d1152
< -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
1156c1153
< -- corresponding sums.
---
> -- | 'zipWith' generalises 'zip' by zipping with the function given as VS.null v1 || VS.null v2 = []
1156a1154
> -- the first argument, instead of a tupling function.  For example, otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
1156a1155
> -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of zip (VS.unsafeTail v1) (VS.unsafeTail v2)
1156a1156
> {-# INLINE-- corresponding sums. #-}
1158d1157
< zipWith f = go
1159c1158
<     where
---
> zipWith-- | 'zipWith' generalises 'zip' by zipping with the function given asf = go
1159a1159
> -- the first argument, instead of a tupling function.  For example,where
1159a1160
> -- @'zipWith' (+)@ is applied to two ByteStrings to produce the list ofgo v1 v2
1159a1161
> -- corresponding sums.| VS.null v1 || VS.null v2 = []
1159a1162
> zipWith ::| otherwiseWord8 ->=Word8f (VS.unsafeHead-> a) -> ByteStringv1) (VS.unsafeHead-> ByteStringv2)-> [a]
1159a1163
> zipWith f = go      : go (VS.unsafeTail v1) (VS.unsafeTail v2)
1159a1164
> {-# INLINEwhere  [1] zipWith #-}
1161d1165
<         | VS.null v1 || VS.null v2 = []
1162d1165
<         | otherwise = f (VS.unsafeHead v1) (VS.unsafeHead v2)
1163d1165
<                     : go (VS.unsafeTail v1) (VS.unsafeTail v2)
1164d1165
< {-# INLINE [1] zipWith #-}
1165d1165
< 
1166d1165
< {-# RULES
1167d1165
< "ByteString specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
1168d1165
<     zipWith f p q = unpack (zipWith' f p q)
1169c1166
<   #-}
---
> {-# RULES VS.null v1 || VS.null v2 = []
1169a1167
> "ByteString specialise zipWith" otherwise = f (VS.unsafeHeadforall v1(f)::VS.unsafeHeadWord8 -> Word8)-> Word8) p q .
1169a1168
>     zipWith f p q = :unpack (VS.unsafeTail(zipWith' f pv1q) (VS.unsafeTail v2)
1169a1169
> {-# INLINE#-}      [1] zipWith #-}
1171d1170
< -- | A specialised version of zipWith for the common case of a
1172d1170
< -- simultaneous map over two bytestrings, to build a 3rd. Rewrite rules
1173d1170
< -- are used to automatically covert zipWith into zipWith' when a pack is
1174c1171
< -- performed on the result of zipWith.
---
> {-# RULES-- | A specialised version of zipWith for the common case of a
1174a1172
> "ByteString specialise zipWith"-- simultaneous map over two bytestrings, to build a 3rd. Rewrite rulesforall (f :: Word8 -> Word8 -> Word8) p q .
1174a1173
> -- are used to automatically covert zipWith into zipWith' when a pack is f p q = unpack (zipWith' f p q)
1174a1174
> -- performed on the result of zipWith.#-}
1177d1176
<     unsafeInlineIO $
1178d1176
<       withForeignPtr fp1 $ \p1 ->
1179d1176
<          withForeignPtr fp2 $ \p2 ->
1180d1176
<            create len $ \p ->
1181d1176
<              let go !n
1182d1176
<                      | n >= len = return ()
1183d1176
<                      | otherwise = do
1184c1177
<                          x <- peekByteOff p1 n
---
> -- | A specialised version of zipWith for the common case of aunsafeInlineIO $
1184a1178
> -- simultaneous map over two bytestrings, to build a 3rd. Rewrite ruleswithForeignPtr fp1 $ \p1 ->
1184a1179
> -- are used to automatically covert zipWith into zipWith' when a pack iswithForeignPtr fp2 $ \p2 ->
1184a1180
> -- performed on the result of zipWith.create len $ \p ->
1184a1181
> zipWith' :: (Word8let go->!nWord8 -> Word8) -> ByteString -> ByteString -> ByteString
1184a1182
> zipWith' f v1 v2 =   | n >= len = return ()
1184a1183
>     unsafeInlineIO $ | otherwise = do
1184a1184
>       withForeignPtr fp1 $  \<-p1peekByteOff->         p1 n
1184a1185
>          withForeignPtr fp2y <- \peekByteOffp2 ->      p2 n
1184a1186
>            create len $ \ppokeByteOff->        p n (f x y)
1184a1187
>              let go !n   go (n+1)
1184a1188
>              in go 0 | n >= len = return ()
1184a1189
>     where            | otherwise = do
1184a1190
>       len = min l1 l2    x <- peekByteOff p1 n
1186d1191
<                          pokeByteOff p n (f x y)
1187d1191
<                          go (n+1)
1188c1192
<              in go 0
---
>       (fp1, l1) = VS.unsafeToForeignPtr0 p n (v1f x y)
1188a1193
>       (fp2, l2) = VS.unsafeToForeignPtr0 (n+1)        v2
1188a1194
> {-# INLINE zipWith'in go 0#-}
1190d1195
<       len = min l1 l2
1191d1195
< 
1192d1195
<       (fp1, l1) = VS.unsafeToForeignPtr0 v1
1193d1195
<       (fp2, l2) = VS.unsafeToForeignPtr0 v2
1194d1195
< {-# INLINE zipWith' #-}
1195d1195
< 
1196c1196
< -- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
---
> -- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of = min l1 l2
1198d1197
< unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
1199d1197
< unzip ls = ( VS.fromList $ L.map fst ls
1200c1198
<            , VS.fromList $ L.map snd ls
---
> unzip (::fp1[,Word8) = VS.unsafeToForeignPtr0Word8)] -> (ByteString,v1ByteString)
1200a1199
> unzip (lsfp2=,(l2VS.fromList) = VS.unsafeToForeignPtr0$ L.map fst ls  v2
1200a1200
> {-# INLINE zipWith', VS.fromList#-}  $ L.map snd ls
1201a1202
> {-# INLINE-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair ofunzip #-}
1201a1203
> -- ByteStrings. Note that this performs two 'pack' operations.
1201a1204
> unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
1201a1205
> unzip-------------------------------------------------------------------------------- = ( VS.fromList $ L.map fst ls
1201a1206
> -- * Ordered ByteStrings, VS.fromList $ L.map snd ls
1201a1207
> --------------------------------------------------------------------------------)
1203d1208
< 
1204d1208
< 
1205d1208
< --------------------------------------------------------------------------------
1206d1208
< -- * Ordered ByteStrings
1207d1208
< --------------------------------------------------------------------------------
1208d1208
< 
1211d1210
< sort v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do
1212d1210
< 
1213c1211
<     -- Initialize counts array to all 0s:
---
> sort--------------------------------------------------------------------------------v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do
1213a1212
> -- * Ordered ByteStrings
1213a1213
> ---------------------------------------------------------------------------------- Initialize counts array to all 0s:
1215d1214
<                   0
1216d1214
<                   (256 * fromIntegral (sizeOf (undefined :: CSize)))
1217c1215
< 
---
> -- | /O(n)/ Sort a ByteString efficiently, using counting sort.0
1217a1216
> sort :: ByteString(->256ByteString* fromIntegral (sizeOf (undefined :: CSize)))
1217a1217
> sort v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do
1219d1218
<     withForeignPtr fp $ \p ->
1220d1218
<         let go !i | i == l    = return ()
1221d1218
<                   | otherwise = do
1222c1219
<                       k <- fromIntegral `fmap` peekElemOff p i
---
>     withForeignPtr-- Initialize counts array to all 0s:fp $ \p ->
1222a1220
>     voidlet memsetgo !i (castPtri == l counts= return)     ()
1222a1221
>                   0 otherwise = do
1222a1222
>                   (256k*<-fromIntegralsizeOf`fmap`(undefinedpeekElemOff::pCSizei   )))
1224d1223
<                       pokeElemOff counts k (x + 1)
1225d1223
<                       go (i + 1)
1226d1223
<         in go 0
1227d1223
< 
1228d1223
<     -- Fill result array:
1229d1223
<     let go 256 _   = return ()
1230d1223
<         go !i !ptr = do
1231c1224
<           n <- peekElemOff counts i
---
>     -- Count occurrences:pokeElemOff counts k (x + 1)
1231a1225
>     withForeignPtr fp $go\pi->+ 1)
1231a1226
>         letin go0!i | i == l    = return ()
1231a1227
>                   | otherwise = do
1231a1228
>     -- Fill result array: <- fromIntegral `fmap` peekElemOff p i
1231a1229
>     let go 256 _   = return <- peekElemOff()         counts k
1231a1230
>         go !i !ptr = do counts k (x + 1)
1231a1231
>           n <- peekElemOff (icounts 1)  i
1231a1232
>         inwhen 0(n /= 0) $ void $ memset ptr (fromIntegral i) n
1231a1233
>           go (i + 1) (ptr `plusPtr` fromIntegral n)
1231a1234
>     go-- Fill result array:0 p'
1231a1235
>   where go 256 _   = return ()
1231a1236
>     (fp,gol)!i !VS.unsafeToForeignPtr0ptr = do              v
1231a1237
> {-# INLINEnsort<- peekElemOff#-}        counts i
1234d1239
<     go 0 p'
1235d1239
<   where
1236c1240
<     (fp, l) = VS.unsafeToForeignPtr0 v
---
> -------------------------------------------------------------------------------- 0 p'
1236a1241
> -- * Low level conversionswhere
1236a1242
> --------------------------------------------------------------------------------fp, l) = VS.unsafeToForeignPtr0 v
1238d1243
< 
1239d1243
< 
1241d1244
< -- * Low level conversions
1242d1244
< --------------------------------------------------------------------------------
1243d1244
< 
1244d1244
< --------------------------------------------------------------------------------
1246d1245
< 
1247d1245
< -- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
1248c1246
< -- This is mainly useful to allow the rest of the data pointed
---
> --------------------------------------------------------------------------------
1248a1247
> -- * Low level conversions-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
1248a1248
> -- This is mainly useful to allow the rest of the data pointed--------------------------------------------------------------------------------
1250d1249
< -- if a large string has been read in, and only a small part of it
1251c1250
< -- is needed in the rest of the program.
---
> -- if a large string has been read in, and only a small part of it--------------------------------------------------------------------------------
1251a1251
> -- ** Copying ByteStrings-- is needed in the rest of the program.
1253c1253
< copy :: ByteString -> ByteString
---
> copy-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.:: ByteString -> ByteString
1253a1254
> copy-- This is mainly useful to allow the rest of the data pointedv = unsafeCreate l $ \p' ->
1253a1255
> -- to by the 'ByteString' to be garbage collected, for examplewithForeignPtr fp $ \p ->
1253a1256
> -- if a large string has been read in, and only a small part of itmemcpy p' p (fromIntegral l)
1253a1257
> -- is needed in the rest of the program.where
1253a1258
> --    (fp, l) = VS.unsafeToForeignPtr0 v
1253a1259
> copy{-# INLINE:: ByteStringcopy #-}-> ByteString
1255d1260
<             withForeignPtr fp $ \p ->
1256c1261
<                 memcpy p' p (fromIntegral l)
---
> -------------------------------------------------------------------------------- fp $ \p ->
1256a1262
>                                                       --  ** Packing 'CString's and pointers p' p (fromIntegral l)
1258d1263
<       (fp, l) = VS.unsafeToForeignPtr0 v
1259d1263
< {-# INLINE copy #-}
1260d1263
< 
1261d1263
< --------------------------------------------------------------------------------
1262d1263
< --  ** Packing 'CString's and pointers
1263d1263
< 
1264d1263
< -- | /O(n)./ Construct a new @ByteString@ from a @CString@. The
1265c1264
< -- resulting @ByteString@ is an immutable copy of the original
---
> -- | /O(n)./ Construct a new @ByteString@ from a @CString@. Thefp, l) = VS.unsafeToForeignPtr0 v
1265a1265
> {-# INLINE-- resulting @ByteString@ is an immutable copy of the original #-}
1267d1266
< -- @CString@ must be null terminated.
1268c1267
< packCString :: CString -> IO ByteString
---
> -- @CString@ must be null terminated.--------------------------------------------------------------------------------
1268a1268
> packCString--  ** Packing 'CString's and pointers:: CString -> IO ByteString
1270d1269
<     len <- c_strlen cstr
1271d1269
<     packCStringLen (cstr, fromIntegral len)
1272d1269
< {-# INLINE packCString #-}
1273d1269
< 
1274d1269
< -- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. The
1275d1269
< -- resulting @ByteString@ is an immutable copy of the original @CStringLen@.
1276d1269
< -- The @ByteString@ is a normal Haskell value and will be managed on the
1277d1269
< -- Haskell heap.
1278c1270
< packCStringLen :: CStringLen -> IO ByteString
---
> -- | /O(n)./ Construct a new @ByteString@ from a @CString@. Thelen <- c_strlen cstr
1278a1271
> -- resulting @ByteString@ is an immutable copy of the originalpackCStringLen (cstr, fromIntegral len)
1278a1272
> {-# INLINE-- @CString@, and is managed on the Haskell heap. The originalpackCString #-}
1278a1273
> -- @CString@ must be null terminated.
1278a1274
> packCString-- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. The:: CString -> IO ByteString
1278a1275
> packCString-- resulting @ByteString@ is an immutable copy of the original @CStringLen@. = do
1278a1276
> -- The @ByteString@ is a normal Haskell value and will be managed on the <- c_strlen cstr
1278a1277
> -- Haskell heap. (cstr, fromIntegral len)
1278a1278
> {-# INLINEpackCStringLen:: CStringLen#-}   -> IO ByteString
1280c1280
<     memcpy p (castPtr cstr) (fromIntegral len)
---
> -- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. Thememcpy p (castPtr cstr) (fromIntegral len)
1280a1281
> packCStringLen-- resulting @ByteString@ is an immutable copy of the original @CStringLen@.(_, len) =
1280a1282
> -- The @ByteString@ is a normal Haskell value and will be managed on themoduleError "packCStringLen" ("negative length: " ++ show len)
1280a1283
> {-# INLINE-- Haskell heap.packCStringLen #-}
1280a1284
> packCStringLen :: CStringLen -> IO ByteString
1280a1285
> packCStringLen--------------------------------------------------------------------------------cstr, len) | len >= 0 = create len $ \p ->
1280a1286
>                                                                 -- ** Using ByteStrings as 'CString's p (castPtr cstr) (fromIntegral len)
1282d1287
<     moduleError "packCStringLen" ("negative length: " ++ show len)
1283d1287
< {-# INLINE packCStringLen #-}
1284d1287
< 
1285d1287
< --------------------------------------------------------------------------------
1286d1287
< -- ** Using ByteStrings as 'CString's
1287d1287
< 
1288d1287
< -- | /O(n) construction/ Use a @ByteString@ with a function requiring a
1289c1288
< -- null-terminated @CString@.  The @CString@ will be freed
---
> -- | /O(n) construction/ Use a @ByteString@ with a function requiring a "packCStringLen" ("negative length: " ++ show len)
1289a1289
> {-# INLINE-- null-terminated @CString@.  The @CString@ will be freed #-}
1291d1290
< useAsCString :: ByteString -> (CString -> IO a) -> IO a
1292c1291
< useAsCString v action = do
---
> useAsCString--------------------------------------------------------------------------------:: ByteString -> (CString -> IO a) -> IO a
1292a1292
> useAsCString-- ** Using ByteStrings as 'CString'sv action = do
1294d1293
<     withForeignPtr fp $ \p -> do
1295d1293
<       memcpy buf p (fromIntegral l)
1296d1293
<       pokeByteOff buf l (0::Word8)
1297d1293
<       action (castPtr buf)
1298d1293
<     where
1299d1293
<       (fp, l) = VS.unsafeToForeignPtr0 v
1300c1294
< {-# INLINE useAsCString #-}
---
> -- | /O(n) construction/ Use a @ByteString@ with a function requiring awithForeignPtr fp $ \p -> do
1300a1295
> -- null-terminated @CString@.  The @CString@ will be freedmemcpy buf p (fromIntegral l)
1300a1296
> -- automatically. This is a memcpy(3).pokeByteOff buf l (0::Word8)
1300a1297
> useAsCStringaction ::(castPtrbuf) -> (CString -> IO a) -> IO a
1300a1298
> useAsCStringwhere    v action = do
1300a1299
>  allocaBytes(fp, l)(l+1VS.unsafeToForeignPtr0) $ \buf ->           v
1300a1300
>                      {-# INLINEuseAsCString $ \#-}p -> do
1300a1301
>                      memcpy buf p (fromIntegral l)
1300a1302
>                -- | /O(n) construction/ Use a @ByteString@ with a function requiring a @CStringLen@. buf l (0::Word8)
1300a1303
>                -- As for @useAsCString@ this function makes a copy of the original @ByteString@. (castPtr buf)
1300a1304
> useAsCStringLenwhere       :: ByteString -> (CStringLen -> IO a) -> IO a
1300a1305
> useAsCStringLenfp, l) = VS.unsafeToForeignPtr0v f = useAsCString v $ vcstr -> f (cstr, VS.length v)
1300a1306
> {-# INLINE useAsCStringuseAsCStringLen#-}#-}
1303d1308
< -- As for @useAsCString@ this function makes a copy of the original @ByteString@.
1304d1308
< useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
1305c1309
< useAsCStringLen v f = useAsCString v $ \cstr -> f (cstr, VS.length v)
---
> ---------------------------------------------------------------------------------- As for @useAsCString@ this function makes a copy of the original @ByteString@.
1305a1310
> useAsCStringLen--  * I\/O with 'ByteString's:: ByteString -> (CStringLen -> IO a) -> IO a
1305a1311
> useAsCStringLen-------------------------------------------------------------------------------- f = useAsCString v $ \cstr -> f (cstr, VS.length v)
1307d1312
< 
1308d1312
< 
1310d1313
< --  * I\/O with 'ByteString's
1311d1313
< --------------------------------------------------------------------------------
1312d1313
< 
1313d1313
< --------------------------------------------------------------------------------
1315d1314
< 
1316d1314
< -- | Read a line from stdin.
1317c1315
< getLine :: IO ByteString
---
> --------------------------------------------------------------------------------
1317a1316
> -- | Read a line from stdin.--  * I\/O with 'ByteString's
1317a1317
> getLine--------------------------------------------------------------------------------:: IO ByteString
1319d1318
< 
1320c1319
< -- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
---
> --------------------------------------------------------------------------------
1320a1320
> -- ** Standard input and output-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
1322d1321
< --
1323d1321
< getContents :: IO ByteString
1324d1321
< getContents = hGetContents stdin
1325d1321
< 
1326d1321
< -- | Write a ByteString to stdout
1327d1321
< putStr :: ByteString -> IO ()
1328c1322
< putStr = hPut stdout
---
> ---- | Read a line from stdin.
1328a1323
> getLinegetContents:: IO::ByteStringIO ByteString
1328a1324
> getLinegetContents= hGetLine= hGetContents   stdin
1330c1326
< -- | Write a ByteString to stdout, appending a newline byte
---
> -- | Write a ByteString to stdout-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
1330a1327
> putStr-- The 'Handle' is closed after the contents have been read.:: ByteString -> IO ()
1330a1328
> --putStr = hPut stdout
1330a1329
> getContents :: IO ByteString
1330a1330
> getContents-- | Write a ByteString to stdout, appending a newline byte= hGetContents stdin
1332d1331
< putStrLn = hPutStrLn stdout
1333d1331
< 
1334c1332
< -- | The interact function takes a function of type @ByteString -> ByteString@
---
> putStrLn-- | Write a ByteString to stdout= hPutStrLn stdout
1334a1333
> putStr :: ByteString -> IO ()
1334a1334
> putStr-- | The interact function takes a function of type @ByteString -> ByteString@= hPut stdout
1336d1335
< -- to this function as its argument, and the resulting string is output on the
1337d1335
< -- standard output device.
1338c1336
< --
---
> -- | Write a ByteString to stdout, appending a newline byte-- to this function as its argument, and the resulting string is output on the
1338a1337
> putStrLn-- standard output device.:: ByteString -> IO ()
1338a1338
> putStrLn--       = hPutStrLn stdout
1340d1339
< interact transformer = putStr . transformer =<< getContents
1341d1339
< 
1342d1339
< --------------------------------------------------------------------------------
1343d1339
< -- ** Files
1344d1339
< 
1345d1339
< -- | Read an entire file strictly into a 'ByteString'.  This is far more
1346c1340
< -- efficient than reading the characters into a 'String' and then using
---
> interact-- | The interact function takes a function of type @ByteString -> ByteString@transformer = putStr . transformer =<< getContents
1346a1341
> -- as its argument. The entire input from the standard input device is passed
1346a1342
> -- to this function as its argument, and the resulting string is output on the--------------------------------------------------------------------------------
1346a1343
> -- ** Files-- standard output device.
1346a1344
> --
1346a1345
> interact-- | Read an entire file strictly into a 'ByteString'.  This is far more:: (ByteString -> ByteString) -> IO ()
1346a1346
> interact-- efficient than reading the characters into a 'String' and then using = putStr . transformer =<< getContents
1348d1347
< -- reading it using hGet. Files are read using 'binary mode' on Windows,
1349c1348
< -- for 'text mode' use the Char8 version of this function.
---
> -- reading it using hGet. Files are read using 'binary mode' on Windows,--------------------------------------------------------------------------------
1349a1349
> -- ** Files-- for 'text mode' use the Char8 version of this function.
1351c1351
< readFile :: FilePath -> IO ByteString
---
> readFile-- | Read an entire file strictly into a 'ByteString'.  This is far more:: FilePath -> IO ByteString
1351a1352
> readFile-- efficient than reading the characters into a 'String' and then usingf = withBinaryFile f ReadMode $ \h ->
1351a1353
> -- 'pack'.  It also may be more efficient than opening the file andhFileSize h >>= hGet h . fromIntegral
1351a1354
> -- reading it using hGet. Files are read using 'binary mode' on Windows,
1351a1355
> -- | Write a 'ByteString' to a file.-- for 'text mode' use the Char8 version of this function.
1351a1356
> --writeFile :: FilePath -> ByteString -> IO ()
1351a1357
> readFilewriteFile::f FilePathtxt = withBinaryFile-> IO ByteStringf WriteMode $ \h -> hPut h txt
1353d1358
<                hFileSize h >>= hGet h . fromIntegral
1354d1358
< 
1355c1359
< -- | Write a 'ByteString' to a file.
---
> -- | Append a 'ByteString' to a file. h >>= hGet h . fromIntegral
1355a1360
> appendFile :: FilePath -> ByteString -> IO ()
1355a1361
> appendFile-- | Write a 'ByteString' to a file.f txt = withBinaryFile f AppendMode $ \h -> hPut h txt
1357d1362
< writeFile f txt = withBinaryFile f WriteMode $ \h -> hPut h txt
1358c1363
< 
---
> writeFile-------------------------------------------------------------------------------- txt = withBinaryFile f WriteMode $ \h -> hPut h txt
1358a1364
> -- ** I\/O with Handles
1360c1366
< appendFile :: FilePath -> ByteString -> IO ()
---
> appendFile-- | Read a line from a handle:: FilePath -> ByteString -> IO ()
1362d1367
< 
1363d1367
< --------------------------------------------------------------------------------
1364d1367
< -- ** I\/O with Handles
1365d1367
< 
1366d1367
< -- | Read a line from a handle
1367d1367
< 
1369d1368
< hGetLine h =
1370c1369
<   wantReadableHandle_ "Data.Vector.Storable.ByteString.hGetLine" h $
---
> hGetLine--------------------------------------------------------------------------------h =
1370a1370
> -- ** I\/O with HandleswantReadableHandle_ "Data.Vector.Storable.ByteString.hGetLine" h $
1372c1372
<       flushCharReadBuffer h_
---
> -- | Read a line from a handleflushCharReadBuffer h_
1374d1373
<       if isEmptyBuffer buf
1375d1373
<         then fill    h_ buf 0 []
1376d1373
<         else haveBuf h_ buf 0 []
1377d1373
<  where
1378d1373
<   fill h_@Handle__{haByteBuffer, haDevice} buf !len xss = do
1379c1374
<     (r, buf') <- Buffered.fillReadBuffer haDevice buf
---
> hGetLineif ::isEmptyBuffer -> IObuf
1379a1375
> hGetLinethen = fill    h_ buf 0 []
1379a1376
>   wantReadableHandle_else haveBuf h_buf 0 []                                 h $
1379a1377
>  where h_@Handle__{haByteBuffer} -> do
1379a1378
>    fillflushCharReadBufferh_@Handle__{haByteBuffer   , haDevice} buf !len xss = do
1379a1379
>      (rbuf, buf'<-)readIORef<- Buffered.fillReadBuffer      haDevice buf
1379a1380
>      ififr isEmptyBuffer== 0          buf
1379a1381
>         thenthendowriteIORef bufhaByteBuffer []       buf{ bufR=0, bufL=0 }
1379a1382
>          else haveBufif lenh_> buf0   0 []
1379a1383
>  where            then mkBigPS len xss
1379a1384
>   fill h_@Handle__{elsehaByteBufferioe_EOF , haDevice} buf !len xss = do
1379a1385
>     (r,else)haveBuf<- Buffered.fillReadBufferh_ buf' len xss      haDevice buf
1381d1386
<        then do writeIORef haByteBuffer buf{ bufR=0, bufL=0 }
1382d1386
<                if len > 0
1383d1386
<                   then mkBigPS len xss
1384d1386
<                   else ioe_EOF
1385d1386
<        else haveBuf h_ buf' len xss
1386d1386
< 
1387d1386
<   haveBuf h_@Handle__{haByteBuffer}
1388d1386
<           buf@Buffer{ bufRaw=raw, bufR=w, bufL=r }
1389d1386
<           len xss = do
1390d1386
<     off <- findEOL r w raw
1391c1387
<     let new_len = len + off - r
---
>   haveBufthenh_do@Handle__{haByteBuffer}    buf{ bufR=0, bufL=0 }
1391a1388
>             buf@Buffer len{ >bufRaw   =raw, bufR=w, bufL=r }
1391a1389
>             len xss then= do mkBigPS len xss
1391a1390
>       off <- findEOLelser w ioe_EOFraw
1391a1391
>     letelsenew_len= len+buf'off len- r xss
1393d1392
< 
1394d1392
<     -- if eol == True, then off is the offset of the '\n'
1395d1392
<     -- otherwise off == w and the buffer is now empty.
1396d1392
<     if off /= w
1397d1392
<       then do if (w == off + 1)
1398c1393
<                 then writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
---
>   haveBuf h_@Handle__{haByteBuffer}
1398a1394
>     -- if eol == True, then off is the offset of the '\n'@Buffer{ bufRaw=raw, bufR=w, bufL=r }
1398a1395
>     -- otherwise off == w and the buffer is now empty. xss = do
1398a1396
>     offif off<- findEOL/= w    r w raw
1398a1397
>     letthendo if=(lenw ==+off+-1r
1398a1398
>     xs <- mkPS rawthen offwriteIORef haByteBuffer buf{ bufL=0, bufR=0 }
1400d1399
<               mkBigPS new_len (xs:xss)
1401d1399
<       else fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
1402d1399
< 
1403d1399
<   -- find the end-of-line character, if there is one
1404d1399
<   findEOL r w raw
1405d1399
<       | r == w = return w
1406d1399
<       | otherwise =  do
1407c1400
<           c <- readWord8Buf raw r
---
>     -- if eol == True, then off is the offset of the '\n'mkBigPS new_len (xs:xss)
1407a1401
>     -- otherwise off == w and the buffer is now empty.else fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
1407a1402
>     if off /= w
1407a1403
>   -- find the end-of-line character, if there is onethen do if (w == off + 1)
1407a1404
>                                                 findEOL r w rawthen writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
1407a1405
>                                                     | r == w =elsereturnw       haByteBuffer buf{ bufL = off + 1 }
1407a1406
>                                                     | otherwise=  do (xs:xss)
1407a1407
>       elsecfill<- readWord8Buf buf{ bufL=raw0, bufRr   =0 } new_len (xs:xss)
1409d1408
<             then return r -- NB. not r+1: don't include the '\n'
1410d1408
<             else findEOL (r+1) w raw
1411d1408
< 
1412c1409
< mkPS :: RawBuffer Word8 -> Int -> Int -> IO ByteString
---
>   -- find the end-of-line character, if there is onethen return r -- NB. not r+1: don't include the '\n'
1412a1410
>   findEOL r welsefindEOL (r+1) w raw
1412a1411
>       | r == w = return w
1412a1412
> mkPS :: otherwise =Word8 -> Int -> Int -> IO ByteString
1412a1413
> mkPS buf start <- readWord8Bufend =        raw r
1412a1414
>  create len$c\==p -> (ord '\n')
1412a1415
>    withRawBufferthen returnbuf $ \rpbuf-- NB. not r+1: don't include the '\n'-> do
1412a1416
>    copyByteselsep (pbuf`plusPtrr+1) wstart) len
1412a1417
>  where
1412a1418
> mkPSlen::=RawBufferend - start -> Int -> Int -> IO ByteString
1414d1419
<  create len $ \p ->
1415d1419
<    withRawBuffer buf $ \pbuf -> do
1416c1420
<    copyBytes p (pbuf `plusPtr` start) len
---
> mkBigPS len:: Int \p->->[ByteString] -> IO ByteString
1416a1421
>  mkBigPS_ [v] = return $ \pbuf -> do
1416a1422
> mkBigPS_ vs p=(pbufreturnplusPtr$! VS.concat` start)L.reverse      vs)
1418d1423
<    len = end - start
1419d1423
< 
1420d1423
< mkBigPS :: Int -> [ByteString] -> IO ByteString
1421d1423
< mkBigPS _ [v] = return v
1422d1423
< mkBigPS _ vs  = return $! VS.concat (L.reverse vs)
1423d1423
< 
1424c1424
< -- | Outputs a 'ByteString' to the specified 'Handle'.
---
> -- | Outputs a 'ByteString' to the specified 'Handle'. = end - start
1426d1425
< hPut h v
1427d1425
<     | l == 0    = return ()
1428c1426
<     | otherwise = withForeignPtr fp $ \p -> hPutBuf h p l
---
> mkBigPShPut h v:: Int -> [ByteString] -> IO ByteString
1428a1427
> mkBigPS| l _==[v] = return= return ()
1428a1428
> mkBigPS| otherwise vs  = return= withForeignPtr VS.concatfp (L.reverse\p -> hPutBuf)  h p l
1430d1429
<       (fp, l) = VS.unsafeToForeignPtr0 v
1431d1429
< 
1432d1429
< -- | Similar to 'hPut' except that it will never block. Instead it returns
1433d1429
< -- any tail that did not get written. This tail may be 'empty' in the case that
1434d1429
< -- the whole string was written, or the whole original string if nothing was
1435d1429
< -- written. Partial writes are also possible.
1436c1430
< --
---
> -- | Outputs a 'ByteString' to the specified 'Handle'.(fp, l) = VS.unsafeToForeignPtr0 v
1436a1431
> hPut :: Handle -> ByteString -> IO ()
1436a1432
> hPut-- | Similar to 'hPut' except that it will never block. Instead it returns v
1436a1433
> -- any tail that did not get written. This tail may be 'empty' in the case that l == 0    = return ()
1436a1434
> -- the whole string was written, or the whole original string if nothing was otherwise = withForeignPtr fp $ \p -> hPutBuf h p l
1436a1435
> -- written. Partial writes are also possible.where
1436a1436
> --    (fp, l) = VS.unsafeToForeignPtr0 v
1438d1437
< -- function does not work correctly; it behaves identically to 'hPut'.
1439c1438
< --
---
> -- function does not work correctly; it behaves identically to 'hPut'.-- | Similar to 'hPut' except that it will never block. Instead it returns
1439a1439
> ---- any tail that did not get written. This tail may be 'empty' in the case that
1439a1440
> hPutNonBlocking-- the whole string was written, or the whole original string if nothing was:: Handle -> ByteString -> IO ByteString
1439a1441
> hPutNonBlocking-- written. Partial writes are also possible.h v = do
1439a1442
> --bytesWritten <- withForeignPtr fp $ \p-> hPutBufNonBlocking h p l
1439a1443
> -- Note: on Windows and with Haskell implementation other than GHC, thisreturn $! VS.drop bytesWritten v
1439a1444
> -- function does not work correctly; it behaves identically to 'hPut'.where
1439a1445
> --      (fp, l) = VS.unsafeToForeignPtr0 v
1441d1446
< hPutNonBlocking h v = do
1442d1446
<   bytesWritten <- withForeignPtr fp $ \p-> hPutBufNonBlocking h p l
1443c1447
<   return $! VS.drop bytesWritten v
---
> hPutNonBlocking-- | A synonym for @hPut@, for compatibility v = do
1443a1448
> hPutStr:: Handle<- withForeignPtr-> ByteString ->IO \p-> hPutBufNonBlocking h p l
1443a1449
> hPutStr=$!hPut bytesWritten v
1445d1450
<         (fp, l) = VS.unsafeToForeignPtr0 v
1446d1450
< 
1447d1450
< -- | A synonym for @hPut@, for compatibility
1448d1450
< hPutStr :: Handle -> ByteString -> IO ()
1449d1450
< hPutStr = hPut
1450d1450
< 
1451c1451
< -- | Write a ByteString to a handle, appending a newline byte
---
> -- | Write a ByteString to a handle, appending a newline bytefp, l) = VS.unsafeToForeignPtr0 v
1453d1452
< hPutStrLn h v
1454d1452
<     | VS.length v < 1024 = hPut h (v `snoc` 0x0a)
1455c1453
<     | otherwise          = hPut h v >> hPut h (singleton (0x0a)) -- don't copy
---
> hPutStrLn-- | A synonym for @hPut@, for compatibilityh v
1455a1454
> hPutStr| VS.length:: Handlev ->< 1024= hPut ->h (IOv `(snoc)  ` 0x0a)
1455a1455
> hPutStr| otherwise= hPut           = hPut h v >> hPut h (singleton (0x0a)) -- don't copy
1457d1456
< {-# DEPRECATED hPutStrLn
1458d1456
<     "Use Data.Vector.Storable.ByteString.Char8.hPutStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"
1459d1456
<   #-}
1460d1456
< {-# DEPRECATED putStrLn
1461c1457
<     "Use Data.Vector.Storable.ByteString.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"
---
> {-# DEPRECATED-- | Write a ByteString to a handle, appending a newline bytehPutStrLn
1461a1458
> hPutStrLn"Use Data.Vector.Storable.ByteString.Char8.hPutStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)":: Handle -> ByteString -> IO ()
1461a1459
> hPutStrLn#-}     h v
1461a1460
> {-# DEPRECATED VS.lengthputStrLn < 1024 = hPut h (v `snoc` 0x0a)
1461a1461
>     |"Use Data.Vector.Storable.ByteString.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"          = hPut h v >> hPut h (singleton (0x0a)) -- don't copy
1463c1463
< 
---
> {-# DEPRECATED hPutStrLn
1465c1465
< -- is far more efficient than reading the characters into a 'String'
---
> -- is far more efficient than reading the characters into a 'String'#-}
1467c1467
< -- and the second is the number of bytes to read. It returns the bytes
---
> {-# DEPRECATED-- and the second is the number of bytes to read. It returns the bytes
1469c1469
< --
---
> --#-}
1471a1472
> -- If the handle is a pipe or socket, and the writing end-- | Read a 'ByteString' directly from the specified 'Handle'.  This
1471a1473
> -- is closed, 'hGet' will behave as if EOF was reached.-- is far more efficient than reading the characters into a 'String'
1471a1474
> ---- and then using 'pack'. First argument is the Handle to read from,
1471a1475
> hGet-- and the second is the number of bytes to read. It returns the bytes:: Handle -> Int -> IO ByteString
1471a1476
> hGet-- read, up to n, or 'null' if EOF has been reached.h i
1471a1477
> --  | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
1471a1478
> -- 'hGet' is implemented in terms of 'hGetBuf'.| i == 0    = return VS.empty
1471a1479
> --  | otherwise = illegalBufferSize h "hGet" i
1473d1480
< -- is closed, 'hGet' will behave as if EOF was reached.
1474d1480
< --
1475d1480
< hGet :: Handle -> Int -> IO ByteString
1476d1480
< hGet h i
1477c1481
<     | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
---
> -- is closed, 'hGet' will behave as if EOF was reached.-- | hGetNonBlocking is identical to 'hGet', except that it will never
1477a1482
> ---- block waiting for data to become available.  If there is no data
1477a1483
> hGet-- available to be read, 'hGetNonBlocking' returns 'null'.:: Handle -> Int -> IO ByteString
1477a1484
> hGet--   h i
1477a1485
> hGetNonBlocking i >  0    =::createAndTrimHandle -> Inti-> \IOp ->ByteString h p i
1477a1486
> hGetNonBlocking i == 0    = returni      VS.empty
1477a1487
>     | otherwisei >  0    = illegalBufferSizecreateAndTrim i $ hp"hGet"-> hGetBufNonBlocking               h p i
1479d1488
<     | otherwise = illegalBufferSize h "hGet" i
1480d1488
< 
1481c1489
< -- | hGetNonBlocking is identical to 'hGet', except that it will never
---
> -- | hGetNonBlocking is identical to 'hGet', except that it will never| otherwise = illegalBufferSize h "hGetNonBlocking" i
1483d1490
< -- available to be read, 'hGetNonBlocking' returns 'null'.
1484d1490
< --
1485d1490
< hGetNonBlocking :: Handle -> Int -> IO ByteString
1486d1490
< hGetNonBlocking h i
1487d1490
<     | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
1488d1490
<     | i == 0    = return VS.empty
1489d1490
<     | otherwise = illegalBufferSize h "hGetNonBlocking" i
1490d1490
< 
1491d1490
< -- | Like 'hGet', except that a shorter 'ByteString' may be returned
1492d1490
< -- if there are not enough bytes immediately available to satisfy the
1493d1490
< -- whole request.  'hGetSome' only blocks if there is no data
1494d1490
< -- available, and EOF has not yet been reached.
1495d1490
< --
1496d1490
< hGetSome :: Handle -> Int -> IO ByteString
1497c1491
< hGetSome hh i
---
> -- available to be read, 'hGetNonBlocking' returns 'null'.-- | Like 'hGet', except that a shorter 'ByteString' may be returned
1497a1492
> ---- if there are not enough bytes immediately available to satisfy the
1497a1493
> hGetNonBlocking-- whole request.  'hGetSome' only blocks if there is no data:: Handle -> Int -> IO ByteString
1497a1494
> hGetNonBlocking-- available, and EOF has not yet been reached. i
1497a1495
> --  | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
1497a1496
> hGetSome i ==::0Handle= return-> IntVS.empty-> IO ByteString
1497a1497
> hGetSome otherwisehh i   = illegalBufferSize h "hGetNonBlocking" i
1499c1499
<     | i == 0    = return VS.empty
---
> -- | Like 'hGet', except that a shorter 'ByteString' may be returned| i == 0    = return VS.empty
1499a1500
> -- if there are not enough bytes immediately available to satisfy the| otherwise = illegalBufferSize hh "hGetSome" i
1499a1501
> -- whole request.  'hGetSome' only blocks if there is no data
1499a1502
> illegalBufferSize-- available, and EOF has not yet been reached.:: Handle -> String -> Int -> IO a
1499a1503
> --illegalBufferSize handle fn sz =
1499a1504
> hGetSomeioError:: Handle(mkIOError-> IntillegalOperationErrorType-> IO ByteString       msg (Just handle) Nothing)
1499a1505
> hGetSome--TODO: System.IO uses InvalidArgument here, but it's not exported :-( i
1499a1506
>     |where > 0     = createAndTrim i $ \p -> hGetBufSome hh p i
1499a1507
>     | imsg=0fn ++= return": illegal ByteString size "              ++ showsPrec 9 sz []
1501d1508
< 
1502d1508
< illegalBufferSize :: Handle -> String -> Int -> IO a
1503d1508
< illegalBufferSize handle fn sz =
1504d1508
<     ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1505d1508
<     --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
1506d1508
<     where
1507d1508
<       msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1508d1508
< 
1510d1509
< --
1511d1509
< -- This function reads chunks at a time, doubling the chunksize on each
1512d1509
< -- read. The final buffer is then realloced to the appropriate size. For
1513d1509
< -- files > half of available memory, this may lead to memory exhaustion.
1514d1509
< -- Consider using 'readFile' in this case.
1515c1510
< --
---
> illegalBufferSize--                :: Handle -> String -> Int -> IO a
1515a1511
> illegalBufferSize-- This function reads chunks at a time, doubling the chunksize on each fn sz =
1515a1512
> -- read. The final buffer is then realloced to the appropriate size. For (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
1515a1513
> -- files > half of available memory, this may lead to memory exhaustion.--TODO: System.IO uses InvalidArgument here, but it's not exported :-(
1515a1514
> -- Consider using 'readFile' in this case.where
1515a1515
> --    msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
1517d1516
< -- be ISO-8859-1.
1518d1516
< --
1519d1516
< -- The Handle is closed once the contents have been read,
1520c1517
< -- or if an exception is thrown.
---
> -- be ISO-8859-1.-- | Read entire handle contents strictly into a 'ByteString'.
1522d1518
< hGetContents :: Handle -> IO ByteString
1523d1518
< hGetContents h = always (hClose h) $ do -- strict, so hClose
1524d1518
<     let start_size = 1024
1525d1518
<     p <- mallocBytes start_size
1526d1518
<     i <- hGetBuf h p start_size
1527d1518
<     if i < start_size
1528d1518
<         then do p' <- reallocBytes p i
1529d1518
<                 fp <- newForeignPtr finalizerFree p'
1530d1518
<                 return $! VS.unsafeFromForeignPtr0 fp i
1531d1518
<         else f p start_size
1532d1518
<     where
1533d1518
<         always = flip finally
1534d1518
<         f p s = do
1535c1519
<             let s' = 2 * s
---
> -- The Handle is closed once the contents have been read,-- This function reads chunks at a time, doubling the chunksize on each
1535a1520
> -- or if an exception is thrown.-- read. The final buffer is then realloced to the appropriate size. For
1535a1521
> ---- files > half of available memory, this may lead to memory exhaustion.
1535a1522
> hGetContents-- Consider using 'readFile' in this case.:: Handle -> IO ByteString
1535a1523
> --hGetContents h = always (hClose h) $ do -- strict, so hClose
1535a1524
> -- As with 'hGet', the string representation in the file is assumed tolet start_size = 1024
1535a1525
> -- be ISO-8859-1.p <- mallocBytes start_size
1535a1526
> --  i <- hGetBuf h p start_size
1535a1527
> -- The Handle is closed once the contents have been read,if i < start_size
1535a1528
> -- or if an exception is thrown.then do p' <- reallocBytes p i
1535a1529
> --              fp <- newForeignPtr finalizerFree p'
1535a1530
> hGetContents :: Handle       -> IOVS.unsafeFromForeignPtr0            fp i
1535a1531
> hGetContentselse h = alwaysstart_sizehClose h) $ do -- strict, so hClose
1535a1532
>     letwhere = 1024
1535a1533
>     p <-always= flipstart_sizefinally
1535a1534
>     i <-fhGetBufp s = do p start_size
1535a1535
>     if i < start_sizelet s' = 2 * s
1535a1536
>         thenp'<-reallocBytes<- reallocBytesp s'p i
1535a1537
>            i  <-hGetBuf<- newForeignPtrh (p' `plusPtr` s) s    p'
1535a1538
>            if ireturn< s   $! VS.unsafeFromForeignPtr0 fp i
1535a1539
>         else f pthendo let i' = s + i
1535a1540
>     where               p'' <- reallocBytes p' i'
1535a1541
>         always = flip finallyfp  <- newForeignPtr finalizerFree p''
1535a1542
>         f p s = do      return $! VS.unsafeFromForeignPtr0 fp i'
1535a1543
>             let s'else= 2 *p'ss'
1538d1545
<             if i < s
1539d1545
<                 then do let i' = s + i
1540c1546
<                         p'' <- reallocBytes p' i'
---
> -------------------------------------------------------------------------------- i < s
1540a1547
> -- Utils        then do let i' = s + i
1540a1548
> -------------------------------------------------------------------------------- <- reallocBytes p' i'
1542d1549
<                         return $! VS.unsafeFromForeignPtr0 fp i'
1543d1549
<                 else f p' s'
1544d1549
< 
1545d1549
< 
1546d1549
< --------------------------------------------------------------------------------
1547d1549
< -- Utils
1548d1549
< --------------------------------------------------------------------------------
1549d1549
< 
1550d1549
< -- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
1551c1550
< -- of the string if no element is found, rather than Nothing.
---
> -- | 'findIndexOrEnd' is a variant of findIndex, that returns the length $! VS.unsafeFromForeignPtr0 fp i'
1551a1551
> -- of the string if no element is found, rather than Nothing.else f p' s'
1554d1553
<   let end = p `plusPtr` l
1555d1553
<       go !ptr | ptr == end = return l
1556c1554
<               | otherwise = do
---
> --------------------------------------------------------------------------------let end = p `plusPtr` l
1556a1555
> -- Utilsgo !ptr | ptr == end = return l
1556a1556
> --------------------------------------------------------------------------------| otherwise = do
1558d1557
<                   if k w
1559d1557
<                     then return (ptr `minusPtr` p)
1560d1557
<                     else go (ptr `plusPtr` 1)
1561d1557
<   in go p
1562d1557
<     where
1563d1557
<       (fp, l) = VS.unsafeToForeignPtr0 v
1564d1557
< {-# INLINE findIndexOrEnd #-}
1565d1557
< 
1566d1557
< -- | Find from the end of the string using predicate
1567d1557
< findFromEndUntil :: (Word8 -> Bool) -> ByteString -> Int
1568d1557
< findFromEndUntil pred = go
1569d1557
<     where
1570d1557
<       go v | VS.null v              = 0
1571d1557
<            | pred (VS.unsafeLast v) = l
1572c1558
<            | otherwise              = go (VS.unsafeTake (l-1) v)
---
> -- | 'findIndexOrEnd' is a variant of findIndex, that returns the lengthif k w
1572a1559
> -- of the string if no element is found, rather than Nothing.then return (ptr `minusPtr` p)
1572a1560
> findIndexOrEnd :: (Word8else -> Bool(ptr)`->plusPtr` 1)   -> Int
1572a1561
> findIndexOrEndin go p      k v = unsafeInlineIO $  withForeignPtr fp $ \p ->
1572a1562
>   letwhere = p `plusPtr` l
1572a1563
>       go(fp!ptrl) | ptrVS.unsafeToForeignPtr0 end = return l  v
1572a1564
> {-# INLINE findIndexOrEnd otherwise =#-}
1572a1565
>                   w <- peek ptr
1572a1566
> -- | Find from the end of the string using predicate k w
1572a1567
> findFromEndUntil :: then(Word8-> Boolptr) ->minusPtrByteString` p)-> Int
1572a1568
> findFromEndUntil predelse= go (ptr `plusPtr` 1)
1572a1569
>   inwhere p
1572a1570
>     wherego v | VS.null v              = 0
1572a1571
>       (fp, l)pred= VS.unsafeToForeignPtr0(VS.unsafeLast v) = lv
1572a1572
> {-# INLINE findIndexOrEnd| otherwise    #-}       = go (VS.unsafeTake (l-1) v)
1574d1573
<              l = VS.length v
1575c1574
< {-# INLINE findFromEndUntil #-}
---
> -- | Find from the end of the string using predicatel = VS.length v
1575a1575
> findFromEndUntil{-# INLINE findFromEndUntil:: (Word8 ->#-}) -> ByteString -> Int
1575a1576
> findFromEndUntil pred = go
1575a1577
> moduleErrorwhere   :: String -> String -> a
1575a1578
> moduleError v |funmsg =verror $ "Data.Vector.Storable.ByteString."= 0                          ++
1575a1579
>            | pred (VS.unsafeLastfun)++= l':':' ':msg
1575a1580
> {-# NOINLINE otherwisemoduleError #-}        = go (VS.unsafeTake (l-1) v)
1577d1581
< moduleError :: String -> String -> a
1578d1581
< moduleError fun msg = error $ "Data.Vector.Storable.ByteString." ++
1579d1581
<                                fun ++ ':':' ':msg
1580d1581
< {-# NOINLINE moduleError #-}
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP
           , NoImplicitPrelude
           , BangPatterns
           , NamedFieldPuns
           , MagicHash
           , UnboxedTuples
  #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif

{-# OPTIONS_GHC -fno-warn-name-shadowing #-}

-- |
-- Module      : Data.Vector.Storable.ByteString
-- Copyright   : (c) The University of Glasgow 2001,
--               (c) David Roundy 2003-2005,
--               (c) Simon Marlow 2005
--               (c) Bjorn Bringert 2006
--               (c) Don Stewart 2005-2008
--               (c) Bas van Dijk 2011
--
--               Array fusion code:
--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
--
-- License     : BSD-style
--
-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental
--
-- A time and space-efficient implementation of byte vectors using
-- vectors of Word8, suitable for high performance use, both in terms
-- of large data quantities, or high speed requirements. Byte vectors
-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
-- and can be passed between C and Haskell with little effort.
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.Vector.Storable.ByteString as B
--
-- Original GHC implementation by Bryan O\'Sullivan.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
-- Polished and extended by Don Stewart.
-- Redefined ByteString as a Vector (from the vector package) of Word8s
-- by Bas van Dijk
--

module Data.Vector.Storable.ByteString (

        -- * The ByteString type
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating ByteStrings
        empty,                  -- :: ByteString
        singleton,              -- :: Word8   -> ByteString
        pack,                   -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]

        -- * Basic interface
        cons,                   -- :: Word8 -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Word8 -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString

        head,                   -- :: ByteString -> Word8
        uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)

        last,                   -- :: ByteString -> Word8
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int

        -- * Transforming ByteStrings
        map,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString

        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing ByteStrings (folds)
        foldl,                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        all,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanl1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
        scanr,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Generating and unfolding ByteStrings
        replicate,              -- :: Int -> Word8 -> ByteString
        unfoldr,                -- :: (a -> Maybe (Word8, a)) -> a -> ByteString
        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int -> ByteString -> ByteString
        drop,                   -- :: Int -> ByteString -> ByteString
        splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Word8 -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
        breakSubstring,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filter,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int -> Word8
        elemIndex,              -- :: Word8 -> ByteString -> Maybe Int
        elemIndices,            -- :: Word8 -> ByteString -> [Int]
        elemIndexEnd,           -- :: Word8 -> ByteString -> Maybe Int
        findIndex,              -- :: (Word8 -> Bool) -> ByteString -> Maybe Int
        findIndices,            -- :: (Word8 -> Bool) -> ByteString -> [Int]
        count,                  -- :: Word8 -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipWith,                -- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        sort,                   -- :: ByteString -> ByteString

        -- * Low level conversions
        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString

        -- ** Packing CStrings and pointers
        packCString,            -- :: CString -> IO ByteString
        packCStringLen,         -- :: CStringLen -> IO ByteString

        -- ** Using ByteStrings as CStrings
        useAsCString,           -- :: ByteString -> (CString    -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- * I\/O with ByteStrings

        -- ** Standard input and output
        getLine,                -- :: IO ByteString
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()

        -- ** I\/O with Handles
        hGetLine,               -- :: Handle -> IO ByteString
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetSome,               -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()

        breakByte
  ) where


--------------------------------------------------------------------------------
-- Imports
--------------------------------------------------------------------------------

-- from base:
import Control.Exception     ( finally )
import Control.Monad         ( (>>=), (=<<), (>>), return, void, when )
import Data.Bool             ( Bool(False, True), not, otherwise, (||) )
import Data.Char             ( ord )
import Data.Eq               ( (==), (/=) )
import Data.Function         ( (.), flip )
import Data.Functor          ( fmap )
import Data.IORef            ( readIORef, writeIORef )
import Data.Maybe            ( Maybe(Nothing, Just), isJust, listToMaybe )
import Data.Ord              ( min, (<), (>), (>=) )
import Data.Tuple            ( fst, snd )
import Data.Word             ( Word8 )
import Foreign.C.String      ( CString, CStringLen )
import Foreign.C.Types       ( CSize )
import Foreign.ForeignPtr    ( newForeignPtr, withForeignPtr )
import Foreign.Marshal.Alloc ( allocaBytes, mallocBytes
                             , reallocBytes, finalizerFree
                             )
import Foreign.Marshal.Array ( allocaArray )
import Foreign.Marshal.Utils ( copyBytes )
import Foreign.Ptr           ( nullPtr, plusPtr, minusPtr, castPtr )
import Foreign.Storable      ( peek, poke
                             , peekElemOff, pokeElemOff
                             , peekByteOff, pokeByteOff
                             , sizeOf
                             )
import Prelude               ( (+),(-),(*), ($), ($!)
                             , Int, fromIntegral, String, error, undefined
                             )
import System.IO             ( IO, FilePath, Handle
                             , IOMode(ReadMode, WriteMode, AppendMode)
                             , stdin, stdout
                             , hGetBuf, hGetBufSome, hGetBufNonBlocking
                             , hPutBuf, hPutBufNonBlocking, hFileSize
                             , withBinaryFile, hClose
                             )
import System.IO.Unsafe      ( unsafePerformIO )
import System.IO.Error       ( ioError, mkIOError, illegalOperationErrorType )
import Text.Show             ( show, showsPrec )

import qualified Data.List as L
    ( intersperse, transpose, map, reverse )
import Data.List ( (++) )

import GHC.IO.Handle.Internals ( wantReadableHandle_, flushCharReadBuffer
                               , ioe_EOF
                               )
import GHC.IO.Handle.Types     ( Handle__(..) )
import GHC.IO.Buffer           ( RawBuffer, Buffer(Buffer), bufRaw, bufL, bufR
                               , withRawBuffer, isEmptyBuffer, readWord8Buf
                               )
import GHC.IO.BufferedIO as Buffered ( fillReadBuffer )

-- from primitive:
import Control.Monad.Primitive ( unsafeInlineIO )

-- from vector:
import qualified Data.Vector.Storable as VS

-- from vector-bytestring (this package):
import Data.Vector.Storable.ByteString.Internal
    ( ByteString
    , create, unsafeCreate, createAndTrim, createAndTrim'
    , mallocByteString
    , memcpy, memset, memchr, memcmp
    , c_strlen, c_count, c_intersperse
    )


--------------------------------------------------------------------------------
-- * Introducing and eliminating 'ByteString's
--------------------------------------------------------------------------------

-- | /O(1)/ The empty 'ByteString'
empty :: ByteString
empty = VS.empty
{-# INLINE empty #-}

-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton :: Word8 -> ByteString
singleton = VS.singleton
{-# INLINE [1] singleton #-} -- Inline [1] for intercalate rule

-- | /O(n)/ Convert a @['Word8']@ into a 'ByteString'.
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck. In such cases, consider using packAddress (GHC only).
pack :: [Word8] -> ByteString
pack = VS.fromList
{-# INLINE pack #-}

-- | /O(n)/ Converts a 'ByteString' to a @['Word8']@.
unpack :: ByteString -> [Word8]
unpack = VS.toList
{-# INLINE unpack #-}


--------------------------------------------------------------------------------
--  * Basic interface
--------------------------------------------------------------------------------

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Word8 -> ByteString -> ByteString
cons = VS.cons
{-# INLINE cons #-}

-- | /O(n)/ Append a byte to the end of a 'ByteString'
snoc :: ByteString -> Word8 -> ByteString
snoc = VS.snoc
{-# INLINE snoc #-}

-- | /O(n)/ Append two ByteStrings
append :: ByteString -> ByteString -> ByteString
append = (VS.++)
{-# INLINE append #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.
head :: ByteString -> Word8
head = VS.head
{-# INLINE head #-}

-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.
tail :: ByteString -> ByteString
tail = VS.tail
{-# INLINE tail #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Word8, ByteString)
uncons v
    | VS.length v == 0 = Nothing
    | otherwise        = Just (VS.unsafeHead v, VS.unsafeTail v)
{-# INLINE uncons #-}

-- | /O(1)/ Extract the last element of a ByteString, which must be finite and non-empty.
-- An exception will be thrown in the case of an empty ByteString.
last :: ByteString -> Word8
last = VS.last
{-# INLINE last #-}

-- | /O(1)/ Return all the elements of a 'ByteString' except the last one.
-- An exception will be thrown in the case of an empty ByteString.
init :: ByteString -> ByteString
init = VS.init
{-# INLINE init #-}

-- | /O(1)/ Test whether a ByteString is empty.
null :: ByteString -> Bool
null = VS.null
{-# INLINE null #-}

-- | /O(1)/ 'length' returns the length of a ByteString as an 'Int'.
length :: ByteString -> Int
length = VS.length
{-# INLINE length #-}


--------------------------------------------------------------------------------
-- * Transforming ByteStrings
--------------------------------------------------------------------------------

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@. This function is subject to array fusion.
map :: (Word8 -> Word8) -> ByteString -> ByteString
map = VS.map
{-# INLINE map #-}

-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
reverse :: ByteString -> ByteString
reverse = VS.reverse
{-# INLINE reverse #-}

-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
-- 'ByteString' and \`intersperses\' that byte between the elements of
-- the 'ByteString'.  It is analogous to the intersperse function on
-- Lists.
intersperse :: Word8 -> ByteString -> ByteString
intersperse c v
    | l < 2     = v
    | otherwise = unsafeCreate (2*l-1) $ \p' -> withForeignPtr fp $ \p ->
                    c_intersperse p' p (fromIntegral l) c
    where
      (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE intersperse #-}

-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first
-- argument between each element of the list.
intercalate :: ByteString -> [ByteString] -> ByteString
intercalate s = VS.concat . L.intersperse s
{-# INLINE [1] intercalate #-}

{-# RULES
"ByteString specialise intercalate c -> intercalateByte" forall c s1 s2 .
    intercalate (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
  #-}

-- | /O(n)/ intercalateWithByte. An efficient way to join to two ByteStrings
-- with a char. Around 4 times faster than the generalised join.
intercalateWithByte :: Word8 -> ByteString -> ByteString -> ByteString
intercalateWithByte c v1 v2 =
    unsafeCreate (l1 + l2 + 1) $ \ptr ->
      withForeignPtr fp1 $ \p1 ->
        withForeignPtr fp2 $ \p2 -> do
          memcpy ptr p1 (fromIntegral l1)
          poke (ptr `plusPtr` l1) c
          memcpy (ptr `plusPtr` (l1 + 1)) p2 (fromIntegral l2)
        where
          (fp1, l1) = VS.unsafeToForeignPtr0 v1
          (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE intercalateWithByte #-}

-- | The 'transpose' function transposes the rows and columns of its
-- 'ByteString' argument.
transpose :: [ByteString] -> [ByteString]
transpose = L.map VS.fromList
          . L.transpose
          . L.map VS.toList
{-# INLINE transpose #-}


--------------------------------------------------------------------------------
-- * Reducing 'ByteString's (folds)
--------------------------------------------------------------------------------

foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl = VS.foldl
{-# INLINE foldl #-}

foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
foldl' = VS.foldl'
{-# INLINE foldl' #-}

foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1 = VS.foldl1
{-# INLINE foldl1 #-}

foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldl1' = VS.foldl1'
{-# INLINE foldl1' #-}

foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr = VS.foldr
{-# INLINE foldr #-}

foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
foldr' = VS.foldr'
{-# INLINE foldr' #-}

foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1 = VS.foldr1
{-# INLINE foldr1 #-}

foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
foldr1' = VS.foldr1'
{-# INLINE foldr1' #-}

--------------------------------------------------------------------------------
-- ** Special folds

-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat = VS.concat
{-# INLINE concat #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap = VS.concatMap
{-# INLINE concatMap #-}

-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Word8 -> Bool) -> ByteString -> Bool
any = VS.any
{-# INLINE any #-}

-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines
-- if all elements of the 'ByteString' satisfy the predicate.
all :: (Word8 -> Bool) -> ByteString -> Bool
all = VS.all
{-# INLINE all #-}

-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.
maximum :: ByteString -> Word8
maximum = VS.maximum
{-# INLINE maximum #-}

-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.
minimum :: ByteString -> Word8
minimum = VS.minimum
{-# INLINE minimum #-}


--------------------------------------------------------------------------------
-- * Building ByteStrings
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- ** Scans

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
--
scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanl = VS.scanl
{-# INLINE scanl #-}

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
-- This function will fuse.
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanl1 = VS.scanl1
{-# INLINE scanl1 #-}

-- | scanr is the right-to-left dual of scanl.
scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanr = VS.scanr
{-# INLINE scanr #-}

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanr1 = VS.scanr1
{-# INLINE scanr1 #-}

--------------------------------------------------------------------------------
-- ** Accumulating maps

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Word8 -> (acc, Word8))
          -> acc -> ByteString -> (acc, ByteString)
mapAccumL f acc v = unsafeInlineIO $ withForeignPtr fp $ \p -> do
    fp' <- mallocByteString l
    withForeignPtr fp' $ \p' ->
      let go !a !m
            | m >= l = return (a, VS.unsafeFromForeignPtr0 fp' l)
            | otherwise = do
                x <- peekByteOff p m
                let (a', y) = f a x
                pokeByteOff p' m y
                go a' (m+1)
      in go acc 0
          where
            (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE mapAccumL #-}

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Word8 -> (acc, Word8))
          -> acc -> ByteString -> (acc, ByteString)
mapAccumR f acc v = unsafeInlineIO $ withForeignPtr fp $ \p -> do
    fp' <- mallocByteString l
    withForeignPtr fp' $ \p' ->
      let go !a !m
            | m < 0     = return (a, VS.unsafeFromForeignPtr0 fp' l)
            | otherwise = do
                x <- peekByteOff p m
                let (a', y) = f a x
                pokeByteOff p' m y
                go a' (m-1)
      in go acc (l-1)
          where
            (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE mapAccumR #-}

--------------------------------------------------------------------------------
-- ** Generating and unfolding ByteStrings

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate n x = unfoldr n (\u -> Just (u,u)) x
--
replicate :: Int -> Word8 -> ByteString
replicate = VS.replicate
{-# INLINE replicate #-}

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
-- ByteString from a seed value.  The function takes the element and
-- returns 'Nothing' if it is done producing the ByteString or returns
-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
-- > == pack [0, 1, 2, 3, 4, 5]
--
unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
unfoldr = VS.unfoldr
{-# INLINE unfoldr #-}

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > snd (unfoldrN n f s) == take n (unfoldr f s)
--
-- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/
unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
unfoldrN i f x0
    | i < 0     = (VS.empty, Just x0)
    | otherwise = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
  where
    go !p !x !n =
        case f x of
          Nothing      -> return (0, n, Nothing)
          Just (w, x')
              | n == i    -> return (0, n, Just x)
              | otherwise -> do
                  poke p w
                  go (p `plusPtr` 1) x' (n+1)
{-# INLINE unfoldrN #-}


--------------------------------------------------------------------------------
-- * Substrings
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- ** Breaking strings

-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take :: Int -> ByteString -> ByteString
take = VS.take
{-# INLINE take #-}

-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@
-- elements, or @[]@ if @n > 'length' xs@.
drop  :: Int -> ByteString -> ByteString
drop = VS.drop
{-# INLINE drop #-}

-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.
splitAt :: Int -> ByteString -> (ByteString, ByteString)
splitAt = VS.splitAt
{-# INLINE splitAt #-}

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile f v = VS.unsafeTake (findIndexOrEnd (not . f) v) v
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile f v = VS.unsafeDrop (findIndexOrEnd (not . f) v) v
{-# INLINE dropWhile #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span = VS.span
{-# INLINE [1] span #-}

{-# RULES
"ByteString specialise span (x==)" forall x.
    span ((==) x) = spanByte x
"ByteString specialise span (==x)" forall x.
    span (==x) = spanByte x
  #-}

-- | 'spanByte' breaks its ByteString argument at the first
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte c v = unsafeInlineIO $ withForeignPtr fp $ \p ->
  let go !i | i >= l    = return (v, VS.empty)
            | otherwise = do
                c' <- peekByteOff p i
                if c /= c'
                  then return (VS.unsafeTake i v, VS.unsafeDrop i v)
                  else go (i+1)
  in go 0
      where
        (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE spanByte #-}

-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and
--
-- > spanEnd (not . isSpace) v
-- >    ==
-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
--
spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd p v = VS.splitAt (findFromEndUntil (not . p) v) v
{-# INLINE spanEnd #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
--
-- Under GHC, a rewrite rule will transform break (==) into a
-- call to the specialised breakByte:
--
-- > break ((==) x) = breakByte x
-- > break (==x) = breakByte x
--
break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break p v = (VS.unsafeTake n v, VS.unsafeDrop n v)
    where
      !n = findIndexOrEnd p v
{-# INLINE [1] break #-}

{-# RULES
"ByteString specialise break (x==)" forall x.
    break ((==) x) = breakByte x
"ByteString specialise break (==x)" forall x.
    break (==x) = breakByte x
  #-}

-- | 'breakByte' breaks its ByteString argument at the first occurence
-- of the specified byte. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"
--
breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
breakByte x v = case VS.elemIndex x v of
    Nothing -> (v, VS.empty)
    Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
{-# INLINE breakByte #-}

-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
--
-- breakEnd p == spanEnd (not.p)
breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd p v = VS.splitAt (findFromEndUntil p v) v
{-# INLINE breakEnd #-}

-- | The 'group' function takes a ByteString and returns a list of
-- ByteStrings such that the concatenation of the result is equal to the
-- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to
-- supply their own equality test. It is about 40% faster than
-- /groupBy (==)/
group :: ByteString -> [ByteString]
group v
    | VS.null v = []
    | otherwise = ys : group zs
    where
      (ys, zs) = spanByte (VS.unsafeHead v) v
{-# INLINE group #-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupBy  k v
    | VS.null v = []
    | otherwise = VS.unsafeTake n v : groupBy k (VS.unsafeDrop n v)
    where
      n = 1 + findIndexOrEnd (not . k (VS.unsafeHead v)) (VS.unsafeTail v)
{-# INLINE groupBy #-}

-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits :: ByteString -> [ByteString]
inits v = [VS.unsafeTake s v | s <- [0..VS.length v]]
{-# INLINE inits #-}

-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.
tails :: ByteString -> [ByteString]
tails v | VS.null v = [VS.empty]
        | otherwise = v : tails (VS.unsafeTail v)
{-# INLINE tails #-}

--------------------------------------------------------------------------------
-- ** Breaking into many substrings

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Word8 -> ByteString -> [ByteString]
split w v | l == 0    = []
          | otherwise = go 0
    where
      (fp, l) = VS.unsafeToForeignPtr0 v

      withFP = unsafeInlineIO . withForeignPtr fp

      go !n | q == nullPtr = vec l'    : []
            | otherwise    = vec (i-n) : go (i+1)
          where
            vec = VS.unsafeFromForeignPtr fp n

            q = withFP $ \p -> memchr (p `plusPtr` n) w (fromIntegral l')
            i = withFP $ \p -> return (q `minusPtr` p)

            l' = l - n
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
-- > splitWith (=='a') []        == []
--
splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith pred v
    | l == 0    = []
    | otherwise = splitWith0 0 l
    where
      (fp, l) = VS.unsafeToForeignPtr0 v

      splitWith0 !off !len = unsafeInlineIO $ withForeignPtr fp $ \p ->
        let vec = VS.unsafeFromForeignPtr fp off
            go !idx
                | idx >= len = return [vec idx]
                | otherwise = do
                    let sepIx = off + idx
                    w <- peekElemOff p sepIx
                    if pred w
                      then return (vec idx : splitWith0 (sepIx+1) (len-idx-1))
                      else go (idx+1)
        in go 0
{-# INLINE [1] splitWith #-}

{-# RULES
"ByteString specialise splitWith (x==)" forall x.
    splitWith ((==) x) = split x
"ByteString specialise splitWith (==x)" forall x.
    splitWith (==x) = split x
  #-}

--------------------------------------------------------------------------------
-- * Predicates
--------------------------------------------------------------------------------

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.
isPrefixOf :: ByteString -> ByteString -> Bool
isPrefixOf v1 v2
    | l1 == 0   = True
    | l2 < l1   = False
    | otherwise = unsafeInlineIO $
                    withForeignPtr fp1 $ \p1 ->
                      withForeignPtr fp2 $ \p2 -> do
                        i <- memcmp p1 p2 (fromIntegral l1)
                        return $! i == 0
    where
      (fp1, l1) = VS.unsafeToForeignPtr0 v1
      (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE isPrefixOf #-}

-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a suffix of the second.
--
-- The following holds:
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y
--
-- However, the real implemenation uses memcmp to compare the end of the
-- string only, with no reverse required..
isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf v1 v2
    | l1 == 0   = True
    | l2 < l1   = False
    | otherwise = unsafeInlineIO $
                    withForeignPtr fp1 $ \p1 ->
                      withForeignPtr fp2 $ \p2 -> do
        i <- memcmp p1 (p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
        return $! i == 0
    where
      (fp1, l1) = VS.unsafeToForeignPtr0 v1
      (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE isSuffixOf #-}

-- | Check whether one string is a substring of another. @isInfixOf
-- p s@ is equivalent to @not (null (findSubstrings p s))@.
isInfixOf :: ByteString -> ByteString -> Bool
isInfixOf v1 v2 = isJust (findSubstring v1 v2)
{-# INLINE isInfixOf #-}

--------------------------------------------------------------------------------
--  ** Search for arbitrary substrings

-- | Break a string on a substring, returning a pair of the part of the
-- string prior to the match, and the rest of the string.
--
-- The following relationships hold:
--
-- > break (== c) l == breakSubstring (singleton c) l
--
-- and:
--
-- > findSubstring s l ==
-- >    if null s then Just 0
-- >              else case breakSubstring s l of
-- >                       (x,y) | null y    -> Nothing
-- >                             | otherwise -> Just (length x)
--
-- For example, to tokenise a string, dropping delimiters:
--
-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
-- >     where (h,t) = breakSubstring x y
--
-- To skip to the first occurence of a string:
--
-- > snd (breakSubstring x y)
--
-- To take the parts of a string before a delimiter:
--
-- > fst (breakSubstring x y)
--
breakSubstring :: ByteString -- ^ String to search for
               -> ByteString -- ^ String to search in
               -> (ByteString, ByteString)
                             -- ^ Head and tail of string broken at substring
breakSubstring pat src = search 0 src
  where
    search !n !s
        | VS.null s          = (src, VS.empty) -- not found
        | pat `isPrefixOf` s = (VS.take n src, s)
        | otherwise          = search (n+1) (VS.unsafeTail s)
{-# INLINE breakSubstring #-}

-- | Get the first index of a substring in another string,
--   or 'Nothing' if the string is not found.
--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.
findSubstring :: ByteString -- ^ String to search for.
              -> ByteString -- ^ String to seach in.
              -> Maybe Int
findSubstring f i = listToMaybe (findSubstrings f i)
{-# INLINE findSubstring #-}

{-# DEPRECATED findSubstring "findSubstring is deprecated in favour of breakSubstring." #-}

-- | Find the indexes of all (possibly overlapping) occurances of a
-- substring in a string.
--
findSubstrings :: ByteString -- ^ String to search for.
               -> ByteString -- ^ String to seach in.
               -> [Int]
findSubstrings pat str
    | VS.null pat = [0 .. VS.length str]
    | otherwise   = search 0 str
  where
    search !ix !s
        | VS.null s          = []
        | pat `isPrefixOf` s = ix : ixs
        | otherwise          =      ixs
        where
          ixs = search (ix+1) (VS.unsafeTail s)
{-# INLINE findSubstrings #-}

{-# DEPRECATED findSubstrings "findSubstrings is deprecated in favour of breakSubstring." #-}


--------------------------------------------------------------------------------
-- * Searching ByteStrings
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- ** Searching by equality

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elem :: Word8 -> ByteString -> Bool
elem = VS.elem
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Word8 -> ByteString -> Bool
notElem = VS.notElem
{-# INLINE notElem #-}

--------------------------------------------------------------------------------
-- ** Searching with a predicate

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
--
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
--
find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
find = VS.find
{-# INLINE find #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate. This function is subject to array fusion.
filter :: (Word8 -> Bool) -> ByteString -> ByteString
filter = VS.filter
{-# INLINE filter #-}

-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
-- the pair of ByteStrings with elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p bs == (filter p xs, filter (not . p) xs)
--
partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition = VS.partition
{-# INLINE partition #-}


--------------------------------------------------------------------------------
-- * Indexing ByteStrings
--------------------------------------------------------------------------------

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Word8
index = (VS.!)
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element.
elemIndex :: Word8 -> ByteString -> Maybe Int
elemIndex = VS.elemIndex
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).
elemIndices :: Word8 -> ByteString -> [Int]
elemIndices x v = VS.toList $ VS.elemIndices x v
{-# INLINE elemIndices #-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Word8 -> ByteString -> Maybe Int
elemIndexEnd x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
    let go !i | i < 0     = return Nothing
              | otherwise = do
                  x' <- peekByteOff p i
                  if x == x'
                    then return $ Just i
                    else go (i-1)
    in go (l - 1)
        where
          (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE elemIndexEnd #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString
-- satisfying the predicate.
findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
findIndex = VS.findIndex
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
findIndices pred v = VS.toList $ VS.findIndices pred v
{-# INLINE findIndices #-}

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- But more efficiently than using length on the intermediate list.
count :: Word8 -> ByteString -> Int
count x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
    fmap fromIntegral $ c_count p (fromIntegral l) x
        where
          (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE count #-}


--------------------------------------------------------------------------------
-- * Zipping and unzipping ByteStrings
--------------------------------------------------------------------------------

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip v1 v2
    | VS.null v1 || VS.null v2 = []
    | otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
                : zip (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINE zip #-}

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of
-- corresponding sums.
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith f = go
    where
      go v1 v2
        | VS.null v1 || VS.null v2 = []
        | otherwise = f (VS.unsafeHead v1) (VS.unsafeHead v2)
                    : go (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINE [1] zipWith #-}

{-# RULES
"ByteString specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
    zipWith f p q = unpack (zipWith' f p q)
  #-}

-- | A specialised version of zipWith for the common case of a
-- simultaneous map over two bytestrings, to build a 3rd. Rewrite rules
-- are used to automatically covert zipWith into zipWith' when a pack is
-- performed on the result of zipWith.
zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
zipWith' f v1 v2 =
    unsafeInlineIO $
      withForeignPtr fp1 $ \p1 ->
         withForeignPtr fp2 $ \p2 ->
           create len $ \p ->
             let go !n
                     | n >= len = return ()
                     | otherwise = do
                         x <- peekByteOff p1 n
                         y <- peekByteOff p2 n
                         pokeByteOff p n (f x y)
                         go (n+1)
             in go 0
    where
      len = min l1 l2

      (fp1, l1) = VS.unsafeToForeignPtr0 v1
      (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE zipWith' #-}

-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
unzip ls = ( VS.fromList $ L.map fst ls
           , VS.fromList $ L.map snd ls
           )
{-# INLINE unzip #-}


--------------------------------------------------------------------------------
-- * Ordered ByteStrings
--------------------------------------------------------------------------------

-- | /O(n)/ Sort a ByteString efficiently, using counting sort.
sort :: ByteString -> ByteString
sort v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do

    -- Initialize counts array to all 0s:
    void $ memset (castPtr counts)
                  0
                  (256 * fromIntegral (sizeOf (undefined :: CSize)))

    -- Count occurrences:
    withForeignPtr fp $ \p ->
        let go !i | i == l    = return ()
                  | otherwise = do
                      k <- fromIntegral `fmap` peekElemOff p i
                      x <- peekElemOff counts k
                      pokeElemOff counts k (x + 1)
                      go (i + 1)
        in go 0

    -- Fill result array:
    let go 256 _   = return ()
        go !i !ptr = do
          n <- peekElemOff counts i
          when (n /= 0) $ void $ memset ptr (fromIntegral i) n
          go (i + 1) (ptr `plusPtr` fromIntegral n)
    go 0 p'
  where
    (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE sort #-}


--------------------------------------------------------------------------------
-- * Low level conversions
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- ** Copying ByteStrings

-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
-- This is mainly useful to allow the rest of the data pointed
-- to by the 'ByteString' to be garbage collected, for example
-- if a large string has been read in, and only a small part of it
-- is needed in the rest of the program.
--
copy :: ByteString -> ByteString
copy v = unsafeCreate l $ \p' ->
            withForeignPtr fp $ \p ->
                memcpy p' p (fromIntegral l)
    where
      (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE copy #-}

--------------------------------------------------------------------------------
--  ** Packing 'CString's and pointers

-- | /O(n)./ Construct a new @ByteString@ from a @CString@. The
-- resulting @ByteString@ is an immutable copy of the original
-- @CString@, and is managed on the Haskell heap. The original
-- @CString@ must be null terminated.
packCString :: CString -> IO ByteString
packCString cstr = do
    len <- c_strlen cstr
    packCStringLen (cstr, fromIntegral len)
{-# INLINE packCString #-}

-- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. The
-- resulting @ByteString@ is an immutable copy of the original @CStringLen@.
-- The @ByteString@ is a normal Haskell value and will be managed on the
-- Haskell heap.
packCStringLen :: CStringLen -> IO ByteString
packCStringLen (cstr, len) | len >= 0 = create len $ \p ->
    memcpy p (castPtr cstr) (fromIntegral len)
packCStringLen (_, len) =
    moduleError "packCStringLen" ("negative length: " ++ show len)
{-# INLINE packCStringLen #-}

--------------------------------------------------------------------------------
-- ** Using ByteStrings as 'CString's

-- | /O(n) construction/ Use a @ByteString@ with a function requiring a
-- null-terminated @CString@.  The @CString@ will be freed
-- automatically. This is a memcpy(3).
useAsCString :: ByteString -> (CString -> IO a) -> IO a
useAsCString v action = do
 allocaBytes (l+1) $ \buf ->
    withForeignPtr fp $ \p -> do
      memcpy buf p (fromIntegral l)
      pokeByteOff buf l (0::Word8)
      action (castPtr buf)
    where
      (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE useAsCString #-}

-- | /O(n) construction/ Use a @ByteString@ with a function requiring a @CStringLen@.
-- As for @useAsCString@ this function makes a copy of the original @ByteString@.
useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
useAsCStringLen v f = useAsCString v $ \cstr -> f (cstr, VS.length v)
{-# INLINE useAsCStringLen #-}


--------------------------------------------------------------------------------
--  * I\/O with 'ByteString's
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- ** Standard input and output

-- | Read a line from stdin.
getLine :: IO ByteString
getLine = hGetLine stdin

-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
-- The 'Handle' is closed after the contents have been read.
--
getContents :: IO ByteString
getContents = hGetContents stdin

-- | Write a ByteString to stdout
putStr :: ByteString -> IO ()
putStr = hPut stdout

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn = hPutStrLn stdout

-- | The interact function takes a function of type @ByteString -> ByteString@
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the
-- standard output device.
--
interact :: (ByteString -> ByteString) -> IO ()
interact transformer = putStr . transformer =<< getContents

--------------------------------------------------------------------------------
-- ** Files

-- | Read an entire file strictly into a 'ByteString'.  This is far more
-- efficient than reading the characters into a 'String' and then using
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet. Files are read using 'binary mode' on Windows,
-- for 'text mode' use the Char8 version of this function.
--
readFile :: FilePath -> IO ByteString
readFile f = withBinaryFile f ReadMode $ \h ->
               hFileSize h >>= hGet h . fromIntegral

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = withBinaryFile f WriteMode $ \h -> hPut h txt

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = withBinaryFile f AppendMode $ \h -> hPut h txt

--------------------------------------------------------------------------------
-- ** I\/O with Handles

-- | Read a line from a handle

hGetLine :: Handle -> IO ByteString
hGetLine h =
  wantReadableHandle_ "Data.Vector.Storable.ByteString.hGetLine" h $
    \ h_@Handle__{haByteBuffer} -> do
      flushCharReadBuffer h_
      buf <- readIORef haByteBuffer
      if isEmptyBuffer buf
        then fill    h_ buf 0 []
        else haveBuf h_ buf 0 []
 where
  fill h_@Handle__{haByteBuffer, haDevice} buf !len xss = do
    (r, buf') <- Buffered.fillReadBuffer haDevice buf
    if r == 0
       then do writeIORef haByteBuffer buf{ bufR=0, bufL=0 }
               if len > 0
                  then mkBigPS len xss
                  else ioe_EOF
       else haveBuf h_ buf' len xss

  haveBuf h_@Handle__{haByteBuffer}
          buf@Buffer{ bufRaw=raw, bufR=w, bufL=r }
          len xss = do
    off <- findEOL r w raw
    let new_len = len + off - r
    xs <- mkPS raw r off

    -- if eol == True, then off is the offset of the '\n'
    -- otherwise off == w and the buffer is now empty.
    if off /= w
      then do if (w == off + 1)
                then writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
                else writeIORef haByteBuffer buf{ bufL = off + 1 }
              mkBigPS new_len (xs:xss)
      else fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)

  -- find the end-of-line character, if there is one
  findEOL r w raw
      | r == w = return w
      | otherwise =  do
          c <- readWord8Buf raw r
          if c == fromIntegral (ord '\n')
            then return r -- NB. not r+1: don't include the '\n'
            else findEOL (r+1) w raw

mkPS :: RawBuffer Word8 -> Int -> Int -> IO ByteString
mkPS buf start end =
 create len $ \p ->
   withRawBuffer buf $ \pbuf -> do
   copyBytes p (pbuf `plusPtr` start) len
 where
   len = end - start

mkBigPS :: Int -> [ByteString] -> IO ByteString
mkBigPS _ [v] = return v
mkBigPS _ vs  = return $! VS.concat (L.reverse vs)

-- | Outputs a 'ByteString' to the specified 'Handle'.
hPut :: Handle -> ByteString -> IO ()
hPut h v
    | l == 0    = return ()
    | otherwise = withForeignPtr fp $ \p -> hPutBuf h p l
    where
      (fp, l) = VS.unsafeToForeignPtr0 v

-- | Similar to 'hPut' except that it will never block. Instead it returns
-- any tail that did not get written. This tail may be 'empty' in the case that
-- the whole string was written, or the whole original string if nothing was
-- written. Partial writes are also possible.
--
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hPut'.
--
hPutNonBlocking :: Handle -> ByteString -> IO ByteString
hPutNonBlocking h v = do
  bytesWritten <- withForeignPtr fp $ \p-> hPutBufNonBlocking h p l
  return $! VS.drop bytesWritten v
      where
        (fp, l) = VS.unsafeToForeignPtr0 v

-- | A synonym for @hPut@, for compatibility
hPutStr :: Handle -> ByteString -> IO ()
hPutStr = hPut

-- | Write a ByteString to a handle, appending a newline byte
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn h v
    | VS.length v < 1024 = hPut h (v `snoc` 0x0a)
    | otherwise          = hPut h v >> hPut h (singleton (0x0a)) -- don't copy

{-# DEPRECATED hPutStrLn
    "Use Data.Vector.Storable.ByteString.Char8.hPutStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"
  #-}
{-# DEPRECATED putStrLn
    "Use Data.Vector.Storable.ByteString.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"
  #-}

-- | Read a 'ByteString' directly from the specified 'Handle'.  This
-- is far more efficient than reading the characters into a 'String'
-- and then using 'pack'. First argument is the Handle to read from,
-- and the second is the number of bytes to read. It returns the bytes
-- read, up to n, or 'null' if EOF has been reached.
--
-- 'hGet' is implemented in terms of 'hGetBuf'.
--
-- If the handle is a pipe or socket, and the writing end
-- is closed, 'hGet' will behave as if EOF was reached.
--
hGet :: Handle -> Int -> IO ByteString
hGet h i
    | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
    | i == 0    = return VS.empty
    | otherwise = illegalBufferSize h "hGet" i

-- | hGetNonBlocking is identical to 'hGet', except that it will never
-- block waiting for data to become available.  If there is no data
-- available to be read, 'hGetNonBlocking' returns 'null'.
--
hGetNonBlocking :: Handle -> Int -> IO ByteString
hGetNonBlocking h i
    | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
    | i == 0    = return VS.empty
    | otherwise = illegalBufferSize h "hGetNonBlocking" i

-- | Like 'hGet', except that a shorter 'ByteString' may be returned
-- if there are not enough bytes immediately available to satisfy the
-- whole request.  'hGetSome' only blocks if there is no data
-- available, and EOF has not yet been reached.
--
hGetSome :: Handle -> Int -> IO ByteString
hGetSome hh i
    | i > 0     = createAndTrim i $ \p -> hGetBufSome hh p i
    | i == 0    = return VS.empty
    | otherwise = illegalBufferSize hh "hGetSome" i

illegalBufferSize :: Handle -> String -> Int -> IO a
illegalBufferSize handle fn sz =
    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
    where
      msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []

-- | Read entire handle contents strictly into a 'ByteString'.
--
-- This function reads chunks at a time, doubling the chunksize on each
-- read. The final buffer is then realloced to the appropriate size. For
-- files > half of available memory, this may lead to memory exhaustion.
-- Consider using 'readFile' in this case.
--
-- As with 'hGet', the string representation in the file is assumed to
-- be ISO-8859-1.
--
-- The Handle is closed once the contents have been read,
-- or if an exception is thrown.
--
hGetContents :: Handle -> IO ByteString
hGetContents h = always (hClose h) $ do -- strict, so hClose
    let start_size = 1024
    p <- mallocBytes start_size
    i <- hGetBuf h p start_size
    if i < start_size
        then do p' <- reallocBytes p i
                fp <- newForeignPtr finalizerFree p'
                return $! VS.unsafeFromForeignPtr0 fp i
        else f p start_size
    where
        always = flip finally
        f p s = do
            let s' = 2 * s
            p' <- reallocBytes p s'
            i  <- hGetBuf h (p' `plusPtr` s) s
            if i < s
                then do let i' = s + i
                        p'' <- reallocBytes p' i'
                        fp  <- newForeignPtr finalizerFree p''
                        return $! VS.unsafeFromForeignPtr0 fp i'
                else f p' s'


--------------------------------------------------------------------------------
-- Utils
--------------------------------------------------------------------------------

-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length
-- of the string if no element is found, rather than Nothing.
findIndexOrEnd :: (Word8 -> Bool) -> ByteString -> Int
findIndexOrEnd k v = unsafeInlineIO $  withForeignPtr fp $ \p ->
  let end = p `plusPtr` l
      go !ptr | ptr == end = return l
              | otherwise = do
                  w <- peek ptr
                  if k w
                    then return (ptr `minusPtr` p)
                    else go (ptr `plusPtr` 1)
  in go p
    where
      (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE findIndexOrEnd #-}

-- | Find from the end of the string using predicate
findFromEndUntil :: (Word8 -> Bool) -> ByteString -> Int
findFromEndUntil pred = go
    where
      go v | VS.null v              = 0
           | pred (VS.unsafeLast v) = l
           | otherwise              = go (VS.unsafeTake (l-1) v)
           where
             l = VS.length v
{-# INLINE findFromEndUntil #-}

moduleError :: String -> String -> a
moduleError fun msg = error $ "Data.Vector.Storable.ByteString." ++
                               fun ++ ':':' ':msg
{-# NOINLINE moduleError #-}
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP
           , NoImplicitPrelude
           , BangPatterns
           , NamedFieldPuns
           , MagicHash
           , UnboxedTuples
  #-}

#if __GLASGOW_HASKELL__ >= 704
{-# LANGUAGE Trustworthy #-}
#endif{-# LANGUAGE Trustworthy #-}

{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
-- |
-- |-- Module      : Data.Vector.Storable.ByteString
-- Module      : Data.Vector.Storable.ByteString-- Copyright   : (c) The University of Glasgow 2001,
--               (c) David Roundy 2003-2005,-- Copyright   : (c) The University of Glasgow 2001,
--               (c) Simon Marlow 2005--               (c) David Roundy 2003-2005,
--               (c) Simon Marlow 2005--               (c) Bjorn Bringert 2006
--               (c) Bjorn Bringert 2006--               (c) Don Stewart 2005-2008
--               (c) Bas van Dijk 2011--               (c) Don Stewart 2005-2008
----               (c) Bas van Dijk 2011
----               Array fusion code:
--               Array fusion code:--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller
--               (c) 2001,2002 Manuel M T Chakravarty & Gabriele Keller--               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
----               (c) 2006      Manuel M T Chakravarty & Roman Leshchinskiy
---- License     : BSD-style
---- License     : BSD-style
---- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
-- Stability   : experimental-- Maintainer  : Bas van Dijk <v.dijk.bas@gmail.com>
---- Stability   : experimental
---- A time and space-efficient implementation of byte vectors using
-- A time and space-efficient implementation of byte vectors using-- vectors of Word8, suitable for high performance use, both in terms
-- vectors of Word8, suitable for high performance use, both in terms
-- of large data quantities, or high speed requirements. Byte vectors-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
-- and can be passed between C and Haskell with little effort.-- are encoded as strict 'Word8' arrays of bytes, held in a 'ForeignPtr',
---- and can be passed between C and Haskell with little effort.
---- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.-- This module is intended to be imported @qualified@, to avoid name
---- clashes with "Prelude" functions.  eg.
---- > import qualified Data.Vector.Storable.ByteString as B
---- > import qualified Data.Vector.Storable.ByteString as B
---- Original GHC implementation by Bryan O\'Sullivan.
-- Original GHC implementation by Bryan O\'Sullivan.-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.
-- Rewritten to use 'Data.Array.Unboxed.UArray' by Simon Marlow.-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
-- Polished and extended by Don Stewart.-- Rewritten to support slices and use 'ForeignPtr' by David Roundy.
-- Polished and extended by Don Stewart.-- Redefined ByteString as a Vector (from the vector package) of Word8s
-- by Bas van Dijk-- Redefined ByteString as a Vector (from the vector package) of Word8s
---- by Bas van Dijk
--
module Data.Vector.Storable.ByteString (
module Data.Vector.Storable.ByteString (
        -- * The ByteString type
        ByteString-- * The ByteString type,             -- instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
        ByteString,             -- instances: Eq, Ord, Show, Read, Data, Typeable, Monoid
        -- * Introducing and eliminating ByteStrings
        empty-- * Introducing and eliminating ByteStrings,                  -- :: ByteString
        emptysingleton,   ,              -- :: ByteString-- :: Word8   -> ByteString
        singletonpack,    ,              -- :: Word8   -> ByteString
        packunpack, ,                 -- :: [Word8] -> ByteString
        unpack,                 -- :: ByteString -> [Word8]
        -- * Basic interface
        cons-- * Basic interface,                   -- :: Word8 -> ByteString -> ByteString
        cons,                   -- :: Word8 -> ByteString -> ByteString
        snocappend, ,                 -- :: ByteString -> Word8 -> ByteString-- :: ByteString -> ByteString -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Word8
        headuncons, ,                 -- :: ByteString -> Word8-- :: ByteString -> Maybe (Word8, ByteString)
        uncons,                 -- :: ByteString -> Maybe (Word8, ByteString)
        last,                   -- :: ByteString -> Word8
        last,                   -- :: ByteString -> Word8-- :: ByteString -> ByteString
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> Bool-- :: ByteString -> ByteString
        nulllength, ,                 -- :: ByteString -> Int-- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int
        -- * Transforming ByteStrings
        map-- * Transforming ByteStrings,                    -- :: (Word8 -> Word8) -> ByteString -> ByteString
        mapreverse,   ,                -- :: ByteString -> ByteString-- :: (Word8 -> Word8) -> ByteString -> ByteString
        reverseintersperse,   ,            -- :: ByteString -> ByteString-- :: Word8 -> ByteString -> ByteString
        intersperse,            -- :: Word8 -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        intercalatetranspose, ,            -- :: [ByteString] -> [ByteString]-- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]
        -- * Reducing ByteStrings (folds)
        foldl-- * Reducing ByteStrings (folds),                  -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldlfoldl',,                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Word8 -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1foldl1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldl1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr,                  -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldrfoldr',,                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Word8 -> a -> a) -> a -> ByteString -> a-- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr1foldr1',,                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        foldr1',                -- :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
        -- ** Special folds
        concat-- ** Special folds,                 -- :: [ByteString] -> ByteString
        concatconcatMap,  ,              -- :: [ByteString] -> ByteString-- :: (Word8 -> ByteString) -> ByteString -> ByteString
        concatMapany,     ,              -- :: (Word8 -> Bool) -> ByteString -> Bool-- :: (Word8 -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Word8 -> Bool) -> ByteString -> Bool
        allmaximum,   ,                -- :: ByteString -> Word8-- :: (Word8 -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Word8
        minimum,                -- :: ByteString -> Word8
        -- * Building ByteStrings
        -- ** Scans-- * Building ByteStrings
        scanl-- ** Scans,                  -- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanlscanl1,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanl1scanr,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanrscanr1,,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString-- :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
        scanr1,                 -- :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
        -- ** Accumulating maps
        mapAccumL-- ** Accumulating maps,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumL,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
        -- ** Generating and unfolding ByteStrings
        replicate-- ** Generating and unfolding ByteStrings,              -- :: Int -> Word8 -> ByteString
        replicateunfoldr, ,              -- :: Int -> Word8 -> ByteString-- :: (a -> Maybe (Word8, a)) -> a -> ByteString
        unfoldrunfoldrN,,               -- :: (a -> Maybe (Word8, a)) -> a -> ByteString-- :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
        unfoldrN,               -- :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
        -- * Substrings
        -- * Substrings
        -- ** Breaking strings
        take-- ** Breaking strings,                   -- :: Int -> ByteString -> ByteString
        take,                   -- :: Int -> ByteString -> ByteString
        dropsplitAt,  ,                -- :: Int -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
        splitAttakeWhile, ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Word8 -> Bool) -> ByteString -> ByteString
        dropWhilespan,    ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        spanspanEnd,  ,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEndbreak, ,                -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        breakbreakEnd,  ,               -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEndgroup,  ,               -- :: ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        groupgroupBy, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        groupByinits, ,                -- :: ByteString -> [ByteString]-- :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]
        -- ** Breaking into many substrings
        split-- ** Breaking into many substrings,                  -- :: Word8 -> ByteString -> [ByteString]
        splitsplitWith,   ,              -- :: Word8 -> ByteString -> [ByteString]-- :: (Word8 -> Bool) -> ByteString -> [ByteString]
        splitWith,              -- :: (Word8 -> Bool) -> ByteString -> [ByteString]
        -- * Predicates
        isPrefixOf-- * Predicates,             -- :: ByteString -> ByteString -> Bool
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOfisInfixOf,,             -- :: ByteString -> ByteString -> Bool
        isInfixOf,              -- :: ByteString -> ByteString -> Bool
        -- ** Search for arbitrary substrings
        breakSubstring-- ** Search for arbitrary substrings,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
        breakSubstringfindSubstring,,         -- :: ByteString -> ByteString -> Maybe Int-- :: ByteString -> ByteString -> (ByteString,ByteString)
        findSubstringfindSubstrings,,         -- :: ByteString -> ByteString -> [Int]-- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]
        -- * Searching ByteStrings
        -- * Searching ByteStrings
        -- ** Searching by equality
        elem-- ** Searching by equality,                   -- :: Word8 -> ByteString -> Bool
        elemnotElem,  ,                -- :: Word8 -> ByteString -> Bool
        notElem,                -- :: Word8 -> ByteString -> Bool
        -- ** Searching with a predicate
        find-- ** Searching with a predicate,                   -- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        findfilter, ,                 -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> Maybe Word8
        filterpartition,  ,              -- :: (Word8 -> Bool) -> ByteString -> ByteString-- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        partition,              -- :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
        -- * Indexing ByteStrings
        index-- * Indexing ByteStrings,                  -- :: ByteString -> Int -> Word8
        indexelemIndex,   ,              -- :: ByteString -> Int -> Word8-- :: Word8 -> ByteString -> Maybe Int
        elemIndexelemIndices, ,            -- :: Word8 -> ByteString -> [Int]-- :: Word8 -> ByteString -> Maybe Int
        elemIndiceselemIndexEnd,,           -- :: Word8 -> ByteString -> [Int]-- :: Word8 -> ByteString -> Maybe Int
        elemIndexEndfindIndex,  ,           -- :: Word8 -> ByteString -> Maybe Int-- :: (Word8 -> Bool) -> ByteString -> Maybe Int
        findIndexfindIndices, ,            -- :: (Word8 -> Bool) -> ByteString -> [Int]-- :: (Word8 -> Bool) -> ByteString -> Maybe Int
        findIndicescount,     ,            -- :: Word8 -> ByteString -> Int-- :: (Word8 -> Bool) -> ByteString -> [Int]
        count,                  -- :: Word8 -> ByteString -> Int
        -- * Zipping and unzipping ByteStrings
        zip-- * Zipping and unzipping ByteStrings,                    -- :: ByteString -> ByteString -> [(Word8,Word8)]
        zipzipWith,   ,                -- :: ByteString -> ByteString -> [(Word8,Word8)]-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        zipWithunzip, ,                -- :: [(Word8,Word8)] -> (ByteString,ByteString)-- :: (Word8 -> Word8 -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Word8,Word8)] -> (ByteString,ByteString)
        -- * Ordered ByteStrings
        sort-- * Ordered ByteStrings,                   -- :: ByteString -> ByteString
        sort,                   -- :: ByteString -> ByteString
        -- * Low level conversions
        -- ** Copying ByteStrings-- * Low level conversions
        copy-- ** Copying ByteStrings,                   -- :: ByteString -> ByteString
        copy,                   -- :: ByteString -> ByteString
        -- ** Packing CStrings and pointers
        packCString-- ** Packing CStrings and pointers,            -- :: CString -> IO ByteString
        packCStringpackCStringLen,  ,         -- :: CString -> IO ByteString-- :: CStringLen -> IO ByteString
        packCStringLen,         -- :: CStringLen -> IO ByteString
        -- ** Using ByteStrings as CStrings
        useAsCString-- ** Using ByteStrings as CStrings,           -- :: ByteString -> (CString    -> IO a) -> IO a
        useAsCStringuseAsCStringLen,  ,        -- :: ByteString -> (CString    -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a
        -- * I\/O with ByteStrings
        -- * I\/O with ByteStrings
        -- ** Standard input and output
        getLine-- ** Standard input and output,                -- :: IO ByteString
        getLinegetContents,   ,            -- :: IO ByteString
        getContentsputStr,    ,            -- :: IO ByteString-- :: ByteString -> IO ()
        putStrputStrLn, ,               -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()-- :: (ByteString -> ByteString) -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()
        -- ** Files
        readFile-- ** Files,               -- :: FilePath -> IO ByteString
        readFilewriteFile,,              -- :: FilePath -> IO ByteString-- :: FilePath -> ByteString -> IO ()
        writeFileappendFile,,             -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
        -- ** I\/O with Handles
        hGetLine-- ** I\/O with Handles,               -- :: Handle -> IO ByteString
        hGetLinehGetContents,   ,           -- :: Handle -> IO ByteString
        hGetContentshGet,       ,           -- :: Handle -> IO ByteString-- :: Handle -> Int -> IO ByteString
        hGethGetSome,   ,               -- :: Handle -> Int -> IO ByteString
        hGetSomehGetNonBlocking,      ,        -- :: Handle -> Int -> IO ByteString
        hGetNonBlockinghPut,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> Int -> IO ByteString
        hPuthPutNonBlocking,          ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        hPutNonBlockinghPutStr,       ,        -- :: Handle -> ByteString -> IO ()-- :: Handle -> ByteString -> IO ByteString
        hPutStrhPutStrLn, ,              -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()
        breakByte
  ) where
  ) where

--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
-- Imports--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- from base:
import-- from base:Control.Exception     ( finally )
import Control.ExceptionControl.Monad         ( finally(>>=), ()=<<), (>>), return, void, when )
import Control.MonadData.Bool             ( (Bool>>=),False=<<,),True>>)),not, otherwise, void,,when(||)))
import Data.Bool             ( Boolord (False, True), not, otherwise, (||) )
import Data.CharData.Eq               ( ord(==)) (/=) )
import Data.EqData.Function         ( (==.)),flip/=)))
import Data.FunctionData.Functor          ( (fmap.), flip)    )
import Data.FunctorData.IORef            ( fmapreadIORef)   , writeIORef )
import Data.IORef            ( readIORefMaybe(Nothing, writeIORef, Just), )isJust, listToMaybe )
import Data.MaybeData.Ord              ( Maybemin, (Nothing<), (>), Just(>=)), isJust, listToMaybe )
import Data.OrdData.Tuple            ( min, (snd<),)(>), (>=) )
import Data.TupleData.Word             ( fstWord8, snd)  )
import Data.WordForeign.C.String      ( Word8CString), CStringLen )
import Foreign.C.StringForeign.C.Types       ( CStringCSize ), CStringLen )
import Foreign.C.TypesForeign.ForeignPtr    ( CSizenewForeignPtr)      , withForeignPtr )
import Foreign.ForeignPtrForeign.Marshal.Alloc ( newForeignPtrallocaBytes, ,mallocBytes )
import Foreign.Marshal.Alloc ( allocaBytesreallocBytes,,mallocBytesfinalizerFree
                             , reallocBytes, finalizerFree
import Foreign.Marshal.Array ) allocaArray )
import Foreign.Marshal.Array ( allocaArraycopyBytes ) )
import Foreign.Marshal.UtilsForeign.Ptr           ( copyBytesnullPtr, plusPtr)     , minusPtr, castPtr )
import Foreign.PtrForeign.Storable      ( nullPtrpeek, poke, plusPtr, minusPtr, castPtr )
import Foreign.Storable      ( peekpeekElemOff, poke , pokeElemOff
                             , peekElemOff, pokeElemOff
                             , peekByteOffsizeOf     , pokeByteOff
                             , sizeOf
import Prelude               ) (+),(-),(*), ($), ($!)
import Prelude               ( (Int+),(-fromIntegral),(*), ($),,($!String)   , error, undefined
                             , Int, fromIntegral, String, error, undefined
import System.IO             ) IO, FilePath, Handle
import System.IO             ( IOIOMode, FilePath(ReadMode, Handle, WriteMode, AppendMode)
                             , IOModestdin,(ReadModestdout  , WriteMode, AppendMode)
                             , stdinhGetBuf, stdout, hGetBufSome, hGetBufNonBlocking
                             , hGetBuf, hGetBufSomehPutBufNonBlocking, hGetBufNonBlocking, hFileSize
                             , hPutBufwithBinaryFile, hPutBufNonBlocking, hClose     , hFileSize
                             , withBinaryFile, hClose
import System.IO.Unsafe      ) unsafePerformIO )
import System.IO.UnsafeSystem.IO.Error       ( unsafePerformIOioError, mkIOError) , illegalOperationErrorType )
import System.IO.ErrorText.Show             ( ioErrorshow, showsPrec, mkIOError) , illegalOperationErrorType )
import Text.Show             ( show, showsPrec )
import qualified Data.List as L
import( interspersequalified Data.List, transposeas, Lmap, reverse )
import intersperseData.List , transpose(++) )   , map, reverse )
import Data.List ( (++) )
import GHC.IO.Handle.Internals ( wantReadableHandle_, flushCharReadBuffer
import GHC.IO.Handle.Internals ( wantReadableHandle_ioe_EOF            , flushCharReadBuffer
                               , ioe_EOF
import GHC.IO.Handle.Types     ) Handle__(..) )
import GHC.IO.Handle.TypesGHC.IO.Buffer           ( Handle__RawBuffer(.., )Buffer)   (Buffer), bufRaw, bufL, bufR
import GHC.IO.Buffer           ( RawBufferwithRawBuffer, Buffer, isEmptyBuffer(Buffer), bufRaw, readWord8Buf, bufL, bufR
                               , withRawBuffer, isEmptyBuffer, readWord8Buf
import GHC.IO.BufferedIO as Buffered)     ( fillReadBuffer )
import GHC.IO.BufferedIO as Buffered ( fillReadBuffer )
-- from primitive:
import-- from primitive:Control.Monad.Primitive ( unsafeInlineIO )
import Control.Monad.Primitive ( unsafeInlineIO )
-- from vector:
import-- from vector:qualified Data.Vector.Storable as VS
import qualified Data.Vector.Storable as VS
-- from vector-bytestring (this package):
import-- from vector-bytestring (this package):Data.Vector.Storable.ByteString.Internal
import( ByteStringData.Vector.Storable.ByteString.Internal
    ( ByteStringcreate, unsafeCreate, createAndTrim, createAndTrim'
    , createmallocByteString, unsafeCreate, createAndTrim, createAndTrim'
    , mallocByteStringmemcpy, memset, memchr, memcmp
    , memcpyc_strlen, memset, c_count, memchr, c_intersperse, memcmp
    , c_strlen, c_count, c_intersperse
    )

--------------------------------------------------------------------------------
-- * Introducing and eliminating 'ByteString's--------------------------------------------------------------------------------
-- * Introducing and eliminating 'ByteString's--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- | /O(1)/ The empty 'ByteString'
empty-- | /O(1)/ The empty 'ByteString':: ByteString
empty ::= VS.empty
empty{-# INLINE= VS.emptyempty #-}
{-# INLINE empty #-}
-- | /O(1)/ Convert a 'Word8' into a 'ByteString'
singleton-- | /O(1)/ Convert a 'Word8' into a 'ByteString':: Word8 -> ByteString
singleton ::= VS.singleton -> ByteString
singleton{-# INLINE=[VS.singleton1] singleton #-} -- Inline [1] for intercalate rule
{-# INLINE [1] singleton #-} -- Inline [1] for intercalate rule
-- | /O(n)/ Convert a @['Word8']@ into a 'ByteString'.
---- | /O(n)/ Convert a @['Word8']@ into a 'ByteString'.
---- For applications with large numbers of string literals, pack can be a
-- bottleneck. In such cases, consider using packAddress (GHC only).-- For applications with large numbers of string literals, pack can be a
pack-- bottleneck. In such cases, consider using packAddress (GHC only).:: [Word8] -> ByteString
pack ::= VS.fromListWord8] -> ByteString
pack{-# INLINE= VS.fromListpack #-}
{-# INLINE pack #-}
-- | /O(n)/ Converts a 'ByteString' to a @['Word8']@.
unpack-- | /O(n)/ Converts a 'ByteString' to a @['Word8']@.:: ByteString -> [Word8]
unpack ::= VS.toList -> [Word8]
unpack{-# INLINE= VS.toListunpack #-}
{-# INLINE unpack #-}

--------------------------------------------------------------------------------
--  * Basic interface--------------------------------------------------------------------------------
--  * Basic interface--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
cons-- complexity, as it requires a memcpy.:: Word8 -> ByteString -> ByteString
cons ::= VS.cons -> ByteString -> ByteString
cons{-# INLINE= VS.conscons #-}
{-# INLINE cons #-}
-- | /O(n)/ Append a byte to the end of a 'ByteString'
snoc-- | /O(n)/ Append a byte to the end of a 'ByteString':: ByteString -> Word8 -> ByteString
snoc ::= VS.snoc -> Word8 -> ByteString
snoc{-# INLINE= VS.snocsnoc #-}
{-# INLINE snoc #-}
-- | /O(n)/ Append two ByteStrings
append-- | /O(n)/ Append two ByteStrings:: ByteString -> ByteString -> ByteString
append ::= (ByteStringVS.++)     -> ByteString -> ByteString
append{-# INLINE= (VS.++append)  #-}
{-# INLINE append #-}
-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> Word8
head ::= VS.head -> Word8
head{-# INLINE= VS.headhead #-}
{-# INLINE head #-}
-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the elements after the head of a ByteString, which must be non-empty.
tail-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> ByteString
tail ::= VS.tail -> ByteString
tail{-# INLINE= VS.tailtail #-}
{-# INLINE tail #-}
-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
uncons-- if it is empty.:: ByteString -> Maybe (Word8, ByteString)
uncons ::v  ByteString -> Maybe (Word8, ByteString)
uncons| VS.length        v == 0 = Nothing
    | VS.length v == 0 = NothingJust (VS.unsafeHead v, VS.unsafeTail v)
{-# INLINE otherwiseuncons #-}  = Just (VS.unsafeHead v, VS.unsafeTail v)
{-# INLINE uncons #-}
-- | /O(1)/ Extract the last element of a ByteString, which must be finite and non-empty.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Extract the last element of a ByteString, which must be finite and non-empty.
last-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> Word8
last ::= VS.last -> Word8
last{-# INLINE= VS.lastlast #-}
{-# INLINE last #-}
-- | /O(1)/ Return all the elements of a 'ByteString' except the last one.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(1)/ Return all the elements of a 'ByteString' except the last one.
init-- An exception will be thrown in the case of an empty ByteString.:: ByteString -> ByteString
init ::= VS.init -> ByteString
init{-# INLINE= VS.initinit #-}
{-# INLINE init #-}
-- | /O(1)/ Test whether a ByteString is empty.
null-- | /O(1)/ Test whether a ByteString is empty.:: ByteString -> Bool
null ::= VS.null -> Bool
null{-# INLINE= VS.nullnull #-}
{-# INLINE null #-}
-- | /O(1)/ 'length' returns the length of a ByteString as an 'Int'.
length-- | /O(1)/ 'length' returns the length of a ByteString as an 'Int'.:: ByteString -> Int
length ::= VS.length -> Int
length{-# INLINE= VS.lengthlength #-}
{-# INLINE length #-}

--------------------------------------------------------------------------------
-- * Transforming ByteStrings--------------------------------------------------------------------------------
-- * Transforming ByteStrings--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
-- element of @xs@. This function is subject to array fusion.-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each
map-- element of @xs@. This function is subject to array fusion.:: (Word8 -> Word8) -> ByteString -> ByteString
map ::= VS.mapWord8 -> Word8) -> ByteString -> ByteString
map{-# INLINE= VS.mapmap #-}
{-# INLINE map #-}
-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.
reverse-- | /O(n)/ 'reverse' @xs@ efficiently returns the elements of @xs@ in reverse order.:: ByteString -> ByteString
reverse ::= VS.reverse -> ByteString
reverse{-# INLINE= VS.reversereverse #-}
{-# INLINE reverse #-}
-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a
-- | /O(n)/ The 'intersperse' function takes a 'Word8' and a-- 'ByteString' and \`intersperses\' that byte between the elements of
-- the 'ByteString'.  It is analogous to the intersperse function on-- 'ByteString' and \`intersperses\' that byte between the elements of
-- Lists.-- the 'ByteString'.  It is analogous to the intersperse function on
-- Lists.intersperse :: Word8 -> ByteString -> ByteString
intersperse ::c vWord8 -> ByteString -> ByteString
intersperse| l < 2 c v = v
    | lotherwise 2     = vunsafeCreate (2*l-1) $ \p' -> withForeignPtr fp $ \p ->
    | otherwise = unsafeCreatec_intersperse2*lp'-1) $fromIntegralp' -> withForeignPtrl) c      fp $ \p ->
                where           c_intersperse p' p (fromIntegral l) c
    where(fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINEfp, lintersperse) = VS.unsafeToForeignPtr0#-}             v
{-# INLINE intersperse #-}
-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- 'ByteString's and concatenates the list after interspersing the first-- | /O(n)/ The 'intercalate' function takes a 'ByteString' and a list of
-- argument between each element of the list.-- 'ByteString's and concatenates the list after interspersing the first
intercalate-- argument between each element of the list.:: ByteString -> [ByteString] -> ByteString
intercalate ::s =ByteStringVS.concat ->. L.intersperseByteString] ->s  ByteString
intercalate{-# INLINE [s]=intercalate .#-} s
{-# INLINE [1] intercalate #-}
{-# RULES
{-# RULES"ByteString specialise intercalate c -> intercalateByte" forall c s1 s2 .
"ByteString specialise intercalate c -> intercalateByte"intercalate (singleton c) (s1 : s2 : []) = intercalateWithByteforall c s1c s2 .s2
  #-} (singleton c) (s1 : s2 : []) = intercalateWithByte c s1 s2
  #-}
-- | /O(n)/ intercalateWithByte. An efficient way to join to two ByteStrings
-- with a char. Around 4 times faster than the generalised join.
intercalateWithByte-- | /O(n)/ intercalateWithByte. An efficient way to join to two ByteStrings:: Word8 -> ByteString -> ByteString -> ByteString
intercalateWithByte-- with a char. Around 4 times faster than the generalised join.c v1 v2 =
intercalateWithByteunsafeCreate (l1::+ Word8l2 + 1->) $ByteString\ptr ->   -> ByteString -> ByteString
intercalateWithBytewithForeignPtrcfp1 v2$ \=p1 ->
    unsafeCreatewithForeignPtrl1 + l2fp2+$1)p2 \->ptrdo->
          withForeignPtrmemcpy ptr fp1p1 ($fromIntegralp1 ->     l1)
                     withForeignPtrpoke (ptr `plusPtr $`\p2)->c do
                         memcpy ptr(ptrp1`plusPtrfromIntegral` (l1 + l11)) p2 (fromIntegral l2)
                       where (ptr `plusPtr` l1) c
                         memcpy(fp1, l1ptr) = `VS.unsafeToForeignPtr0plusPtr` (l1 + 1)) p2 (v1fromIntegral l2)
        where(fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE(fp1intercalateWithByte, l1) = VS.unsafeToForeignPtr0#-}           v1
          (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE-- | The 'transpose' function transposes the rows and columns of its #-}
-- 'ByteString' argument.
transpose-- | The 'transpose' function transposes the rows and columns of its:: [ByteString] -> [ByteString]
transpose-- 'ByteString' argument.= L.map VS.fromList
transpose ::. L.transposeByteString] -> [ByteString]
transpose = L.map VS.fromListVS.toList
{-# INLINE.transpose#-}
          . L.map VS.toList
{-# INLINE transpose #-}
--------------------------------------------------------------------------------
-- * Reducing 'ByteString's (folds)
--------------------------------------------------------------------------------
-- * Reducing 'ByteString's (folds)
foldl--------------------------------------------------------------------------------:: (a -> Word8 -> a) -> a -> ByteString -> a
foldl = VS.foldl
foldl{-# INLINE:: (afoldl-> Word8#-} -> a) -> a -> ByteString -> a
foldl = VS.foldl
{-# INLINEfoldl' :: (foldla -> Word8#-}  -> a) -> a -> ByteString -> a
foldl' = VS.foldl'
foldl'{-# INLINE:: (afoldl'-> Word8#-} -> a) -> a -> ByteString -> a
foldl' = VS.foldl'
{-# INLINEfoldl1 :: (foldl'Word8 ->#-}Word8 -> Word8) -> ByteString -> Word8
foldl1 = VS.foldl1
foldl1{-# INLINE:: (Word8foldl1->#-} -> Word8) -> ByteString -> Word8
foldl1 = VS.foldl1
{-# INLINEfoldl1' :: foldl1(Word8 #-}-> Word8 -> Word8) -> ByteString -> Word8
foldl1' = VS.foldl1'
foldl1'{-# INLINE:: (foldl1'Word8 ->#-} -> Word8) -> ByteString -> Word8
foldl1' = VS.foldl1'
{-# INLINEfoldr :: (Word8-> #-}a -> a) -> a -> ByteString -> a
foldr = VS.foldr
foldr{-# INLINE:: (Word8foldr->#-} -> a) -> a -> ByteString -> a
foldr = VS.foldr
{-# INLINEfoldr' :: (foldr #-}-> a -> a) -> a -> ByteString -> a
foldr' = VS.foldr'
foldr'{-# INLINE:: (Word8foldr'->#-} -> a) -> a -> ByteString -> a
foldr' = VS.foldr'
{-# INLINEfoldr1 :: (foldr'Word8 ->#-}Word8 -> Word8) -> ByteString -> Word8
foldr1 = VS.foldr1
foldr1{-# INLINE:: (Word8foldr1->#-} -> Word8) -> ByteString -> Word8
foldr1 = VS.foldr1
{-# INLINEfoldr1' :: foldr1(Word8 #-}-> Word8 -> Word8) -> ByteString -> Word8
foldr1' = VS.foldr1'
foldr1'{-# INLINE:: (foldr1'Word8 ->#-} -> Word8) -> ByteString -> Word8
foldr1' = VS.foldr1'
{-# INLINE-------------------------------------------------------------------------------- #-}
-- ** Special folds
--------------------------------------------------------------------------------
-- ** Special folds-- | /O(n)/ Concatenate a list of ByteStrings.
concat :: [ByteString] -> ByteString
concat-- | /O(n)/ Concatenate a list of ByteStrings.= VS.concat
concat{-# INLINE:: [ByteStringconcat #-}] -> ByteString
concat = VS.concat
{-# INLINE-- | Map a function over a 'ByteString' and concatenate the results #-}
concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
concatMap-- | Map a function over a 'ByteString' and concatenate the results= VS.concatMap
concatMap{-# INLINE::concatMapWord8 ->#-}) -> ByteString -> ByteString
concatMap = VS.concatMap
{-# INLINE-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if #-}
-- any element of the 'ByteString' satisfies the predicate.
any-- | /O(n)/ Applied to a predicate and a ByteString, 'any' determines if:: (Word8 -> Bool) -> ByteString -> Bool
any-- any element of the 'ByteString' satisfies the predicate.= VS.any
any{-# INLINE:: (Word8any->#-}) -> ByteString -> Bool
any = VS.any
{-# INLINE-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines #-}
-- if all elements of the 'ByteString' satisfy the predicate.
all-- | /O(n)/ Applied to a predicate and a 'ByteString', 'all' determines:: (Word8 -> Bool) -> ByteString -> Bool
all-- if all elements of the 'ByteString' satisfy the predicate.= VS.all
all{-# INLINE:: (Word8all->#-}) -> ByteString -> Bool
all = VS.all
{-# INLINE-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString' #-}
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(n)/ 'maximum' returns the maximum value from a 'ByteString'
maximum-- This function will fuse.:: ByteString -> Word8
maximum-- An exception will be thrown in the case of an empty ByteString.= VS.maximum
maximum{-# INLINE:: ByteStringmaximum #-}-> Word8
maximum = VS.maximum
{-# INLINE-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString' #-}
-- This function will fuse.
-- An exception will be thrown in the case of an empty ByteString.-- | /O(n)/ 'minimum' returns the minimum value from a 'ByteString'
minimum-- This function will fuse.:: ByteString -> Word8
minimum-- An exception will be thrown in the case of an empty ByteString.= VS.minimum
minimum{-# INLINE:: ByteStringminimum #-}-> Word8
minimum = VS.minimum
{-# INLINE minimum #-}
--------------------------------------------------------------------------------
-- * Building ByteStrings
--------------------------------------------------------------------------------
-- * Building ByteStrings
--------------------------------------------------------------------------------
-- ** Scans
--------------------------------------------------------------------------------
-- ** Scans-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.
---- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left. This function will fuse.-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that-- > last (scanl f z xs) == foldl f z xs.
--
scanl-- > last (scanl f z xs) == foldl f z xs.:: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
--scanl = VS.scanl
scanl{-# INLINE:: (Word8scanl->#-} -> Word8) -> Word8 -> ByteString -> ByteString
scanl = VS.scanl
{-# INLINE-- | 'scanl1' is a variant of 'scanl' that has no starting value argument. #-}
-- This function will fuse.
---- | 'scanl1' is a variant of 'scanl' that has no starting value argument.
-- This function will fuse.-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanl1-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]= VS.scanl1
scanl1{-# INLINE:: (Word8scanl1->#-} -> Word8) -> ByteString -> ByteString
scanl1 = VS.scanl1
{-# INLINE-- | scanr is the right-to-left dual of scanl. #-}
scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
scanr-- | scanr is the right-to-left dual of scanl.= VS.scanr
scanr{-# INLINE:: (Word8scanr->#-} -> Word8) -> Word8 -> ByteString -> ByteString
scanr = VS.scanr
{-# INLINE-- | 'scanr1' is a variant of 'scanr' that has no starting value argument. #-}
scanr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
scanr1-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.= VS.scanr1
scanr1{-# INLINE:: (Word8scanr1->#-} -> Word8) -> ByteString -> ByteString
scanr1 = VS.scanr1
{-# INLINE-------------------------------------------------------------------------------- #-}
-- ** Accumulating maps
--------------------------------------------------------------------------------
-- ** Accumulating maps-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- | The 'mapAccumL' function behaves like a combination of 'map' and-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.-- 'foldl'; it applies a function to each element of a ByteString,
mapAccumL-- passing an accumulating parameter from left to right, and returning a:: (acc -> Word8 -> (acc, Word8))
-- final value of this accumulator together with the new list.-> acc -> ByteString -> (acc, ByteString)
mapAccumL ::f accaccv ->= unsafeInlineIO -> (acc,$Word8withForeignPtr))         fp $ \p -> do
    fp' <-->mallocByteString -> ByteStringl  -> (acc, ByteString)
mapAccumLwithForeignPtr acc v =fp'$ \p' ->    $ withForeignPtr fp $ \p -> do
fp'let<-go!a !m          l
withForeignPtr| m >= fp'l = $returnp' ->(a, VS.unsafeFromForeignPtr0 fp' l)
     let go|!aotherwise!m      = do
           | m >=x <- =peekByteOff (a,pVS.unsafeFromForeignPtr0m                       fp' l)
           | otherwiselet (a',=ydo) = f a x
               xpokeByteOff<- peekByteOffp' m p m
               letgo a'a'(,+y) = f a x
     in go acc pokeByteOff0           p' m y
         where go a' (m+1)
     in go acc(fp,0l) = VS.unsafeToForeignPtr0 v
{-# INLINEwheremapAccumL #-}
            (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE-- | The 'mapAccumR' function behaves like a combination of 'map' and #-}
-- 'foldr'; it applies a function to each element of a ByteString,
-- | The 'mapAccumR' function behaves like a combination of 'map' and-- passing an accumulating parameter from right to left, and returning a
-- 'foldr'; it applies a function to each element of a ByteString,-- final value of this accumulator together with the new ByteString.
mapAccumR-- passing an accumulating parameter from right to left, and returning a:: (acc -> Word8 -> (acc, Word8))
-- final value of this accumulator together with the new ByteString.-> acc -> ByteString -> (acc, ByteString)
mapAccumR ::f accaccv ->= unsafeInlineIO -> (acc,$Word8withForeignPtr))         fp $ \p -> do
    fp' <-->mallocByteString -> ByteStringl  -> (acc, ByteString)
mapAccumRwithForeignPtr acc v =fp'$ \p' ->    $ withForeignPtr fp $ \p -> do
fp'let<-go!a !m          l
withForeignPtr| m < 0fp' $=\p'return->  (a, VS.unsafeFromForeignPtr0 fp' l)
  let go|!aotherwise!m      = do
        | m <  0<- peekByteOff= return (a, VS.unsafeFromForeignPtr0 fp' l)
        | otherwiselet (a',=ydo) = f a x
            xpokeByteOff<- peekByteOffp' m p m
            letgo a'a'(,-y) = f a x
  in go acc pokeByteOff(l-1)       p' m y
      where go a' (m-1)
  in go acc(fp,(l-1) VS.unsafeToForeignPtr0 v
{-# INLINEwheremapAccumR #-}
            (fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE-------------------------------------------------------------------------------- #-}
-- ** Generating and unfolding ByteStrings
--------------------------------------------------------------------------------
-- ** Generating and unfolding ByteStrings-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
---- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
replicate-- > replicate n x = unfoldr n (\u -> Just (u,u)) x:: Int -> Word8 -> ByteString
--replicate = VS.replicate
replicate{-# INLINE::replicate -> Word8#-}  -> ByteString
replicate = VS.replicate
{-# INLINE-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr' #-}
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'-- ByteString from a seed value.  The function takes the element and
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a-- returns 'Nothing' if it is done producing the ByteString or returns
-- ByteString from a seed value.  The function takes the element and-- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
-- and @b@ is the seed value for further production.-- returns 'Nothing' if it is done producing the ByteString or returns
---- 'Just' @(a,b)@, in which case, @a@ is the next byte in the string,
-- Examples:-- and @b@ is the seed value for further production.
--
-- Examples:-- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
---- > == pack [0, 1, 2, 3, 4, 5]
---- >    unfoldr (\x -> if x <= 5 then Just (x, x + 1) else Nothing) 0
unfoldr-- > == pack [0, 1, 2, 3, 4, 5]:: (a -> Maybe (Word8, a)) -> a -> ByteString
--unfoldr = VS.unfoldr
unfoldr{-# INLINE:: (unfoldra -> Maybe#-} (Word8, a)) -> a -> ByteString
unfoldr = VS.unfoldr
{-# INLINE-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed #-}
-- value.  However, the length of the result is limited by the first
-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.-- value.  However, the length of the result is limited by the first
---- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > snd (unfoldrN n f s) == take n (unfoldr f s)-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > snd (unfoldrN n f s) == take n (unfoldr f s)-- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/
--unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
unfoldrN-- /Note: this function has a different type than @Data.Vector.Storable.'VS.unfoldrN'@!/i f x0
unfoldrN| i <::0 Int ->= ((VS.emptya -> Maybe, JustWord8x0), a)) -> a -> (ByteString, Maybe a)
unfoldrN| otherwise f x0 = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
  where i < 0     = (VS.empty, Just x0)
    |gootherwise!p !x !n = unsafePerformIO $ createAndTrim' i $ \p -> go p x0 0
  where case f x of
    go !p !Nothingx !n =      -> return (0, n, Nothing)
        caseJust xwof, x')
          Nothing| n == i -> return-> return0,(n, Nothingn, Just)x)
          Just|(wotherwise, x')    -> do
              | n ==poke p w-> return (0, n, Just x)
              | otherwisego (p `plusPtr-> do ` 1) x' (n+1)
{-# INLINE unfoldrN#-}p w
                  go (p `plusPtr` 1) x' (n+1)
{-# INLINE unfoldrN #-}
--------------------------------------------------------------------------------
-- * Substrings
--------------------------------------------------------------------------------
-- * Substrings
--------------------------------------------------------------------------------
-- ** Breaking strings
--------------------------------------------------------------------------------
-- ** Breaking strings-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix
-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.
take-- | /O(1)/ 'take' @n@, applied to a ByteString @xs@, returns the prefix:: Int -> ByteString -> ByteString
take-- of @xs@ of length @n@, or @xs@ itself if @n > 'length' xs@.= VS.take
take{-# INLINE:: Inttake-> ByteString#-}       -> ByteString
take = VS.take
{-# INLINE-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@ #-}
-- elements, or @[]@ if @n > 'length' xs@.
drop-- | /O(1)/ 'drop' @n xs@ returns the suffix of @xs@ after the first @n@:: Int -> ByteString -> ByteString
drop-- elements, or @[]@ if @n > 'length' xs@.= VS.drop
drop{-# INLINE:: Intdrop-> ByteString#-}        -> ByteString
drop = VS.drop
{-# INLINE-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@. #-}
splitAt :: Int -> ByteString -> (ByteString, ByteString)
splitAt-- | /O(1)/ 'splitAt' @n xs@ is equivalent to @('take' n xs, 'drop' n xs)@.= VS.splitAt
splitAt{-# INLINE:: IntsplitAt-> ByteString#-}       -> (ByteString, ByteString)
splitAt = VS.splitAt
{-# INLINE-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@, #-}
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
takeWhile-- returns the longest prefix (possibly empty) of @xs@ of elements that:: (Word8 -> Bool) -> ByteString -> ByteString
takeWhile-- satisfy @p@.f v = VS.unsafeTake (findIndexOrEnd (not . f) v) v
takeWhile{-# INLINE::takeWhileWord8 ->#-}) -> ByteString -> ByteString
takeWhile f v = VS.unsafeTake (findIndexOrEnd (not . f) v) v
{-# INLINE-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@. #-}
dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
dropWhile-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.f v = VS.unsafeDrop (findIndexOrEnd (not . f) v) v
dropWhile{-# INLINE::dropWhileWord8 ->#-}) -> ByteString -> ByteString
dropWhile f v = VS.unsafeDrop (findIndexOrEnd (not . f) v) v
{-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It is #-}
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span-- | 'span' @p xs@ breaks the ByteString into two segments. It is:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@= VS.span
span{-# INLINE:: (Word8[1] ->span#-}) -> ByteString -> (ByteString, ByteString)
span = VS.span
{-# INLINE{-# RULES  [1] span #-}
"ByteString specialise span (x==)" forall x.
{-# RULESspan ((==) x) = spanByte x
"ByteString specialise span (x==)" forall x.
    span ((====x) x)spanByte= spanBytex  x
"ByteString specialise span (==x)"#-}                              forall x.
    span (==x) = spanByte x
-- | 'spanByte' breaks its ByteString argument at the first#-}
-- occurence of a byte other than its argument. It is more efficient
-- than 'span (==)'
---- | 'spanByte' breaks its ByteString argument at the first
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"-- occurence of a byte other than its argument. It is more efficient
---- than 'span (==)'
--spanByte :: Word8 -> ByteString -> (ByteString, ByteString)
spanByte-- > span  (=='c') "abcd" == spanByte 'c' "abcd"c v = unsafeInlineIO $ withForeignPtr fp $ \p ->
--let go !i | i >= l    = return (v, VS.empty)
spanByte :: Word8| otherwise-> ByteString= do    -> (ByteString, ByteString)
spanByte c v = unsafeInlineIOc' <- peekByteOff withForeignPtrp i          fp $ \p ->
    let go !i | i >=   l /= =c'return (v, VS.empty)
              | otherwisethen return= do  (VS.unsafeTake i v, VS.unsafeDrop i v)
                  c'else<- peekByteOffgo (i+1)   p i
    in go 0       if c /= c'
        where       then return (VS.unsafeTake i v, VS.unsafeDrop i v)
          (fp, l) = elseVS.unsafeToForeignPtr0 (i+1)          v
  {-# INLINEin go 0  spanByte #-}
      where
-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE spanByte #-}
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
---- We have
---- and
---- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
---- > spanEnd (not . isSpace) v
-- and-- >    ==
---- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)
---- > spanEnd (not . isSpace) v
spanEnd-- >    ==:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd-- > let (x,y) = span (not.isSpace) (reverse v) in (reverse y, reverse x)p v = VS.splitAt (findFromEndUntil (not . p) v) v
--{-# INLINE spanEnd #-}
spanEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd-- | 'break' @p@ is equivalent to @'span' ('not' . p)@. v = VS.splitAt (findFromEndUntil (not . p) v) v
{-# INLINE--         spanEnd #-}
-- Under GHC, a rewrite rule will transform break (==) into a
-- call to the specialised breakByte:-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
--
-- > break ((==) x) = breakByte x-- Under GHC, a rewrite rule will transform break (==) into a
-- > break (==x) = breakByte x-- call to the specialised breakByte:
--
break-- > break ((==) x) = breakByte x:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
break-- > break (==x) = breakByte xp v = (VS.unsafeTake n v, VS.unsafeDrop n v)
--  where
break ::!n (Word8findIndexOrEnd-> Bool) ->p ByteStringv          -> (ByteString, ByteString)
break{-# INLINE v =[(VS.unsafeTake] break #-}   n v, VS.unsafeDrop n v)
    where
{-# RULESn = findIndexOrEnd p v
{-# INLINE"ByteString specialise break (x==)"[1] break #-}            forall x.
    break ((==) x) = breakByte x
{-# RULES"ByteString specialise break (==x)" forall x.
"ByteString specialise break (x==)"break (==x) = breakByte x       forall x.
  #-} ((==) x) = breakByte x
"ByteString specialise break (==x)" forall x.
-- | 'breakByte' breaks its ByteString argument at the first occurence (==x) = breakByte x
-- of the specified byte. It is more efficient than 'break' as it is#-}
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakByte 'c' "abcd"-- | 'breakByte' breaks its ByteString argument at the first occurence
---- of the specified byte. It is more efficient than 'break' as it is
breakByte-- implemented with @memchr(3)@. I.e.:: Word8 -> ByteString -> (ByteString, ByteString)
--breakByte x v = case VS.elemIndex x v of
-- > break (=='c') "abcd" == breakByte 'c' "abcd"Nothing -> (v, VS.empty)
--  Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
breakByte{-# INLINE::breakByte ->#-} -> (ByteString, ByteString)
breakByte x v = case VS.elemIndex x v of
-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString' -> (v, VS.empty)
--  Just n  -> (VS.unsafeTake n v, VS.unsafeDrop n v)
{-# INLINE-- breakEnd p == spanEnd (not.p) #-}
breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'p v = VS.splitAt (findFromEndUntil p v) v
--{-# INLINE breakEnd #-}
-- breakEnd p == spanEnd (not.p)
breakEnd-- | The 'group' function takes a ByteString and returns a list of:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd-- ByteStrings such that the concatenation of the result is equal to the v = VS.splitAt (findFromEndUntil p v) v
{-# INLINE-- argument.  Moreover, each sublist in the result contains only equal #-}
-- elements.  For example,
---- | The 'group' function takes a ByteString and returns a list of
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]-- ByteStrings such that the concatenation of the result is equal to the
---- argument.  Moreover, each sublist in the result contains only equal
-- elements.  For example,-- It is a special case of 'groupBy', which allows the programmer to
---- supply their own equality test. It is about 40% faster than
-- /groupBy (==)/-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--group :: ByteString -> [ByteString]
group-- It is a special case of 'groupBy', which allows the programmer tov
-- supply their own equality test. It is about 40% faster than| VS.null v = []
-- /groupBy (==)/| otherwise = ys : group zs
groupwhere:: ByteString -> [ByteString]
group v ys, zs) = spanByte (VS.unsafeHead v) v
{-# INLINE VS.nullgroup =#-}]
    | otherwise = ys : group zs
-- | The 'groupBy' function is the non-overloaded version of 'group'.where
groupByys::, zs(Word8) = spanByte-> Word8(VS.unsafeHead-> Bool) -> ByteString) v     -> [ByteString]
{-# INLINEgroupBy  k groupv     #-}
    | VS.null v = []
-- | The 'groupBy' function is the non-overloaded version of 'group'.| otherwise = VS.unsafeTake n v : groupBy k (VS.unsafeDrop n v)
groupBywhere:: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
groupByn =k1v+ findIndexOrEnd (not . k (VS.unsafeHead v)) (VS.unsafeTail v)
{-# INLINE VS.nullgroupBy = []#-}
    | otherwise = VS.unsafeTake n v : groupBy k (VS.unsafeDrop n v)
-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.where
inits n::=ByteString + findIndexOrEnd-> [ByteStringnot . k (VS.unsafeHead v)) (VS.unsafeTail v)
{-# INLINEinits v = [groupByVS.unsafeTake#-}   s v | s <- [0..VS.length v]]
{-# INLINE inits #-}
-- | /O(n)/ Return all initial segments of the given 'ByteString', shortest first.
inits-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.:: ByteString -> [ByteString]
inits v::=ByteStringVS.unsafeTake-> [ByteString v | s <-] [0..VS.length v]]
{-# INLINEtails v | VS.null #-}v = [VS.empty]
        | otherwise = v : tails (VS.unsafeTail v)
{-# INLINE-- | /O(n)/ Return all final segments of the given 'ByteString', longest first.tails #-}
tails :: ByteString -> [ByteString]
tails-------------------------------------------------------------------------------- | VS.null v = [VS.empty]
-- ** Breaking into many substrings otherwise = v : tails (VS.unsafeTail v)
{-# INLINE tails #-}
-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.--------------------------------------------------------------------------------
---- ** Breaking into many substrings
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- > split 'x'  "x"          == ["",""]-- argument, consuming the delimiter. I.e.
--
-- and-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > intercalate [c] . split c == id-- > split 'x'  "x"          == ["",""]
---- > split == splitWith . (==)
---- and
---- As for all splitting functions in this library, this function does
-- > intercalate [c] . split c == id-- not copy the substrings, it just constructs new 'ByteStrings' that
-- > split == splitWith . (==)
--
split-- As for all splitting functions in this library, this function does:: Word8 -> ByteString -> [ByteString]
split-- not copy the substrings, it just constructs new 'ByteStrings' thatw v | l == 0    = []
-- are slices of the original.| otherwise = go 0
--  where
split ::(fpWord8, l) =->VS.unsafeToForeignPtr0 -> [ByteStringv   ]
split w v | l == 0    = []
      withFP otherwise= unsafeInlineIO= go 0  . withForeignPtr fp
    where
      (gofp,nl) = VS.unsafeToForeignPtr0== nullPtr = vec l'    v []
            | otherwise    = vec (i-n) : go (i+1)
      withFPwhere= unsafeInlineIO . withForeignPtr fp
            vec = VS.unsafeFromForeignPtr fp n
      go !n | q == nullPtr = vec l'    : []
            |  otherwise= withFP $ \p=->memchri-n)(: go`plusPtri+1)` n) w (fromIntegral l')
          wherei = withFP $ \p -> return (q `minusPtr` p)
            vec = VS.unsafeFromForeignPtr fp n
            l' = l - n
{-# INLINE split = withFP#-}   $ \p -> memchr (p `plusPtr` n) w (fromIntegral l')
            i = withFP $ \p -> return (q `minusPtr` p)
-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element. = l - n
{-# INLINE-- The resulting components do not contain the separators.  Two adjacent #-}
-- separators result in an empty component in the output.  eg.
---- | /O(n)/ Splits a 'ByteString' into components delimited by
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]-- separators, where the predicate returns True for a separator element.
-- > splitWith (=='a') []        == []-- The resulting components do not contain the separators.  Two adjacent
---- separators result in an empty component in the output.  eg.
--splitWith :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]pred v
-- > splitWith (=='a') []        == []| l == 0    = []
--  | otherwise = splitWith0 0 l
splitWithwhere :: (Word8 -> Bool) -> ByteString -> [ByteString]
splitWith(fp,predl) =vVS.unsafeToForeignPtr0 v
    | l == 0    = []
    | otherwisesplitWith0=!splitWith0off !len = 0unsafeInlineIO            $ withForeignPtr fp $ \p ->
    wherelet vec = VS.unsafeFromForeignPtr fp off
      (fp, l)go=!VS.unsafeToForeignPtr0idx                    v
                | idx >= len = return [vec idx]
      splitWith0|!offotherwise!len ==unsafeInlineIOdo            $ withForeignPtr fp $ \p ->
             let vec = VS.unsafeFromForeignPtrlet sepIx = off + idx fp off
                 go !idx w <- peekElemOff p sepIx
                     | idxif>=predw= return [vec idx]
                     | otherwisethen return= do  (vec idx : splitWith0 (sepIx+1) (len-idx-1))
                         letelsego =idx+1+ idx
             in go 0     w <- peekElemOff p sepIx
     {-# INLINE [1] splitWith pred#-}w
                           then return (vec idx : splitWith0 (sepIx+1) (len-idx-1))
     {-# RULES             else go (idx+1)
     "ByteString specialise splitWith (x==)"in go 0                         forall x.
{-# INLINEsplitWith[1](splitWith(==) x) = #-}split x
"ByteString specialise splitWith (==x)" forall x.
{-# RULESsplitWith (==x) = split x
"ByteString specialise splitWith (x==)"#-}                                   forall x.
    splitWith ((==) x) = split x
"ByteString specialise splitWith (==x)"--------------------------------------------------------------------------------forall x.
-- * Predicates (==x) = split x
--------------------------------------------------------------------------------#-}

-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'
-- iff the first is a prefix of the second.--------------------------------------------------------------------------------
isPrefixOf-- * Predicates:: ByteString -> ByteString -> Bool
isPrefixOf--------------------------------------------------------------------------------v1 v2
    | l1 == 0   = True
-- | /O(n)/ The 'isPrefixOf' function takes two ByteStrings and returns 'True'| l2 < l1   = False
-- iff the first is a prefix of the second.| otherwise = unsafeInlineIO $
isPrefixOf :: ByteStringwithForeignPtr-> ByteStringfp1 ->$ \Boolp1 ->
isPrefixOf v1 v2      withForeignPtr fp2 $ \p2 -> do
    | l1 == 0   = True  i <- memcmp p1 p2 (fromIntegral l1)
    | l2 < l1   = False return $! i == 0
    |where = unsafeInlineIO $
      (fp1, l1) = VS.unsafeToForeignPtr0 fp1 $ \v1p1 ->
            (fp2, l2) = VS.unsafeToForeignPtr0 fp2 $v2\p2 -> do
          {-# INLINE isPrefixOf #-} <- memcmp p1 p2 (fromIntegral l1)
                                  return $! i == 0
-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'where
-- iff the first is a suffix of the second.fp1, l1) = VS.unsafeToForeignPtr0 v1
--    (fp2, l2) = VS.unsafeToForeignPtr0 v2
{-# INLINE-- The following holds: #-}
--
-- > isSuffixOf x y == reverse x `isPrefixOf` reverse y-- | /O(n)/ The 'isSuffixOf' function takes two ByteStrings and returns 'True'
---- iff the first is a suffix of the second.
---- However, the real implemenation uses memcmp to compare the end of the
-- The following holds:-- string only, with no reverse required..
--isSuffixOf :: ByteString -> ByteString -> Bool
isSuffixOf-- > isSuffixOf x y == reverse x `isPrefixOf` reverse yv1 v2
--  | l1 == 0   = True
-- However, the real implemenation uses memcmp to compare the end of the| l2 < l1   = False
-- string only, with no reverse required..| otherwise = unsafeInlineIO $
isSuffixOf :: ByteStringwithForeignPtr-> ByteStringfp1 ->$ \Boolp1 ->
isSuffixOf v1 v2      withForeignPtr fp2 $ \p2 -> do
    | l1i==<-0memcmp= Truep1 (p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
    | l2return l1  $!= Falsei == 0
    |where = unsafeInlineIO $
      (fp1, l1) = VS.unsafeToForeignPtr0 fp1 $ \v1p1 ->
            (fp2, l2) = VS.unsafeToForeignPtr0 fp2 $v2\p2 -> do
          {-# INLINE <-isSuffixOf p1#-}p2 `plusPtr` (l2 - l1)) (fromIntegral l1)
                  return $! i == 0
-- | Check whether one string is a substring of another. @isInfixOfwhere
-- p s@ is equivalent to @not (null (findSubstrings p s))@.fp1, l1) = VS.unsafeToForeignPtr0 v1
isInfixOffp2,::l2ByteString) = VS.unsafeToForeignPtr0-> ByteString -> v2Bool
{-# INLINEisInfixOf v1v2 = isJust#-}(findSubstring v1 v2)
{-# INLINE isInfixOf #-}
-- | Check whether one string is a substring of another. @isInfixOf
-- p s@ is equivalent to @not (null (findSubstrings p s))@.--------------------------------------------------------------------------------
isInfixOf--  ** Search for arbitrary substrings:: ByteString -> ByteString -> Bool
isInfixOf v1 v2 = isJust (findSubstring v1 v2)
{-# INLINE-- | Break a string on a substring, returning a pair of the part of the #-}
-- string prior to the match, and the rest of the string.
----------------------------------------------------------------------------------
-- The following relationships hold:--  ** Search for arbitrary substrings
--
-- > break (== c) l == breakSubstring (singleton c) l-- | Break a string on a substring, returning a pair of the part of the
---- string prior to the match, and the rest of the string.
---- and:
---- The following relationships hold:
---- > findSubstring s l ==
-- >    if null s then Just 0-- > break (== c) l == breakSubstring (singleton c) l
---- >              else case breakSubstring s l of
-- and:-- >                       (x,y) | null y    -> Nothing
---- >                             | otherwise -> Just (length x)
---- > findSubstring s l ==
-- >    if null s then Just 0-- For example, to tokenise a string, dropping delimiters:
---- >              else case breakSubstring s l of
-- >                       (x,y) | null y    -> Nothing-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
-- >     where (h,t) = breakSubstring x y-- >                             | otherwise -> Just (length x)
--
-- To skip to the first occurence of a string:-- For example, to tokenise a string, dropping delimiters:
--
-- > snd (breakSubstring x y)-- > tokenise x y = h : if null t then [] else tokenise x (drop (length x) t)
---- >     where (h,t) = breakSubstring x y
---- To take the parts of a string before a delimiter:
---- To skip to the first occurence of a string:
---- > fst (breakSubstring x y)
---- > snd (breakSubstring x y)
--breakSubstring :: ByteString -- ^ String to search for
-- To take the parts of a string before a delimiter:-> ByteString -- ^ String to search in
--             -> (ByteString, ByteString)
-- > fst (breakSubstring x y)-- ^ Head and tail of string broken at substring
--breakSubstring pat src = search 0 src
breakSubstringwhere        :: ByteString -- ^ String to search for
    search !n !->s  ByteString -- ^ String to search in
        | VS.null-> (ByteString, ByteString(src, VS.empty)   ) -- not found
        | pat `isPrefixOf` s =-- ^ Head and tail of string broken at substring(VS.take n src, s)
breakSubstring| otherwise src = search= search src (n+1) (VS.unsafeTail s)
{-# INLINEwhere    breakSubstring #-}
    search !n !s
-- | Get the first index of a substring in another string, VS.null s          = (src, VS.empty) -- not found
--   or 'Nothing' if the string is not found. pat `isPrefixOf` s = (VS.take n src, s)
--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@. otherwise          = search (n+1) (VS.unsafeTail s)
{-# INLINEfindSubstring:: ByteString#-}-- ^ String to search for.
              -> ByteString -- ^ String to seach in.
-- | Get the first index of a substring in another string,-> Maybe Int
findSubstring--   or 'Nothing' if the string is not found.f i = listToMaybe (findSubstrings f i)
{-# INLINE--   @findSubstring p s@ is equivalent to @listToMaybe (findSubstrings p s)@.findSubstring #-}
findSubstring :: ByteString -- ^ String to search for.
{-# DEPRECATED->findSubstring -- ^ String to seach in."findSubstring is deprecated in favour of breakSubstring." #-}
              -> Maybe Int
findSubstring-- | Find the indexes of all (possibly overlapping) occurances of a i = listToMaybe (findSubstrings f i)
{-# INLINE-- substring in a string. #-}
--
{-# DEPRECATED findSubstring:: ByteString "findSubstring is deprecated in favour of breakSubstring."-- ^ String to search for.                                 #-}
               -> ByteString -- ^ String to seach in.
-- | Find the indexes of all (possibly overlapping) occurances of a-> [Int]
findSubstrings-- substring in a string.pat str
--  | VS.null pat = [0 .. VS.length str]
findSubstrings| otherwise:: ByteString= search 0 str-- ^ String to search for.
  where        -> ByteString -- ^ String to seach in.
    search !ix ->!s [Int]
findSubstrings| VS.nullsstr       = []
    | VS.null| pat pat`isPrefixOf= [0 ..`VS.lengths = ix : str]
    | otherwise| otherwise= search 0 str=      ixs
  where where
    searchixs!ix=!ssearch (ix+1) (VS.unsafeTail s)
{-# INLINE VS.nullfindSubstrings       #-}= []
        | pat `isPrefixOf` s = ix : ixs
{-# DEPRECATED otherwisefindSubstrings="findSubstrings is deprecated in favour of breakSubstring."                                                   #-}
        where
          ixs = search (ix+1) (VS.unsafeTail s)
{-# INLINE-------------------------------------------------------------------------------- #-}
-- * Searching ByteStrings
{-# DEPRECATED-------------------------------------------------------------------------------- "findSubstrings is deprecated in favour of breakSubstring." #-}

--------------------------------------------------------------------------------
-- ** Searching by equality--------------------------------------------------------------------------------
-- * Searching ByteStrings
-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.--------------------------------------------------------------------------------
elem :: Word8 -> ByteString -> Bool
elem--------------------------------------------------------------------------------= VS.elem
{-# INLINE-- ** Searching by equalityelem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'-- | /O(n)/ 'elem' is the 'ByteString' membership predicate.
elemnotElem:: Word8:: Word8-> ByteString-> ByteString-> Bool-> Bool
elemnotElem= VS.elem= VS.notElem
{-# INLINE elemnotElem#-}#-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'--------------------------------------------------------------------------------
notElem-- ** Searching with a predicate:: Word8 -> ByteString -> Bool
notElem = VS.notElem
{-# INLINE-- | /O(n)/ The 'find' function takes a predicate and a ByteString, #-}
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.--------------------------------------------------------------------------------
---- ** Searching with a predicate
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
---- | /O(n)/ The 'find' function takes a predicate and a ByteString,
find-- and returns the first element in matching the predicate, or 'Nothing':: (Word8 -> Bool) -> ByteString -> Maybe Word8
find-- if there is no such element.= VS.find
--{-# INLINE find #-}
-- > find f p = case findIndex f p of Just n -> Just (p ! n) ; _ -> Nothing
---- | /O(n)/ 'filter', applied to a predicate and a ByteString,
find-- returns a ByteString containing those characters that satisfy the:: (Word8 -> Bool) -> ByteString -> Maybe Word8
find-- predicate. This function is subject to array fusion.= VS.find
{-# INLINEfilter :: (findWord8#-}-> Bool) -> ByteString -> ByteString
filter = VS.filter
{-# INLINE-- | /O(n)/ 'filter', applied to a predicate and a ByteString,filter #-}
-- returns a ByteString containing those characters that satisfy the
-- predicate. This function is subject to array fusion.-- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
filter-- the pair of ByteStrings with elements which do and do not satisfy the:: (Word8 -> Bool) -> ByteString -> ByteString
filter-- predicate, respectively; i.e.,= VS.filter
{-# INLINE--         filter #-}
-- > partition p bs == (filter p xs, filter (not . p) xs)
---- | /O(n)/ The 'partition' function takes a predicate a ByteString and returns
partition-- the pair of ByteStrings with elements which do and do not satisfy the:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition-- predicate, respectively; i.e.,= VS.partition
--{-# INLINE partition #-}
-- > partition p bs == (filter p xs, filter (not . p) xs)
--
partition--------------------------------------------------------------------------------:: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
partition-- * Indexing ByteStrings= VS.partition
{-# INLINE-------------------------------------------------------------------------------- #-}

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index--------------------------------------------------------------------------------:: ByteString -> Int -> Word8
index-- * Indexing ByteStrings= (VS.!)
{-# INLINE--------------------------------------------------------------------------------index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index-- element in the given 'ByteString' which is equal to the query:: ByteString -> Int -> Word8
index-- element, or 'Nothing' if there is no such element.= (VS.!)
{-# INLINEelemIndex ::Word8#-}-> ByteString -> Maybe Int
elemIndex = VS.elemIndex
{-# INLINE-- | /O(n)/ The 'elemIndex' function returns the index of the firstelemIndex #-}
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element.-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
elemIndex-- the indices of all elements equal to the query element, in ascending order.:: Word8 -> ByteString -> Maybe Int
elemIndex-- This implementation uses memchr(3).= VS.elemIndex
{-# INLINEelemIndiceselemIndex:: Word8 #-}-> ByteString -> [Int]
elemIndices x v = VS.toList $ VS.elemIndices x v
{-# INLINE-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returningelemIndices #-}
-- the indices of all elements equal to the query element, in ascending order.
-- This implementation uses memchr(3).-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
elemIndices-- element in the given 'ByteString' which is equal to the query:: Word8 -> ByteString -> [Int]
elemIndices-- element, or 'Nothing' if there is no such element. The following v = VS.toList $ VS.elemIndices x v
{-# INLINE-- holds:  elemIndices #-}
--
-- > elemIndexEnd c xs ==-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)-- element in the given 'ByteString' which is equal to the query
---- element, or 'Nothing' if there is no such element. The following
-- holds:elemIndexEnd :: Word8 -> ByteString -> Maybe Int
--elemIndexEnd x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
-- > elemIndexEnd c xs ==let go !i | i < 0     = return Nothing
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)| otherwise = do
--                x' <- peekByteOff p i
elemIndexEnd :: Word8if x->==ByteStringx'        -> Maybe Int
elemIndexEnd x v = unsafeInlineIOthen return $ $Justi           fp $ \p ->
let go !i | i < 0else go= return(i-1)  Nothing
in go (l -|1otherwise)         = do
    where     x' <- peekByteOff p i
      (fp, l) if= VS.unsafeToForeignPtr0 == x'               v
{-# INLINE elemIndexEndthen#-} $ Just i
                else go (i-1)
-- | The 'findIndex' function takes a predicate and a 'ByteString' andin go (l - 1)
-- returns the index of the first element in the ByteStringwhere
-- satisfying the predicate.fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINEfindIndex ::(Word8 -> Bool#-}) -> ByteString -> Maybe Int
findIndex = VS.findIndex
{-# INLINE-- | The 'findIndex' function takes a predicate and a 'ByteString' andfindIndex #-}
-- returns the index of the first element in the ByteString
-- satisfying the predicate.-- | The 'findIndices' function extends 'findIndex', by returning the
findIndex-- indices of all elements satisfying the predicate, in ascending order.:: (Word8 -> Bool) -> ByteString -> Maybe Int
findIndexfindIndices= VS.findIndex:: (Word8 -> Bool) -> ByteString -> [Int]
{-# INLINEfindIndicesfindIndexpred v = #-}VS.toList $ VS.findIndices pred v
{-# INLINE findIndices #-}
-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.-- | count returns the number of times its argument appears in the ByteString
findIndices--          :: (Word8 -> Bool) -> ByteString -> [Int]
findIndices-- > count = length . elemIndices v = VS.toList $ VS.findIndices pred v
{-# INLINE--         findIndices #-}
-- But more efficiently than using length on the intermediate list.
count-- | count returns the number of times its argument appears in the ByteString:: Word8 -> ByteString -> Int
--count x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
-- > count = length . elemIndicesfmap fromIntegral $ c_count p (fromIntegral l) x
--      where
-- But more efficiently than using length on the intermediate list.(fp, l) = VS.unsafeToForeignPtr0 v
count{-# INLINE:: Word8count->#-} -> Int
count x v = unsafeInlineIO $ withForeignPtr fp $ \p ->
    fmap fromIntegral $ c_count p (fromIntegral l) x
--------------------------------------------------------------------------------where
-- * Zipping and unzipping ByteStringsfp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE-------------------------------------------------------------------------------- #-}

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of bytes. If one input ByteString is short,--------------------------------------------------------------------------------
-- * Zipping and unzipping ByteStrings-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations.--------------------------------------------------------------------------------
zip :: ByteString -> ByteString -> [(Word8,Word8)]
zip-- | /O(n)/ 'zip' takes two ByteStrings and returns a list ofv1 v2
-- corresponding pairs of bytes. If one input ByteString is short,| VS.null v1 || VS.null v2 = []
-- excess elements of the longer ByteString are discarded. This is| otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
-- equivalent to a pair of 'unpack' operations.: zip (VS.unsafeTail v1) (VS.unsafeTail v2)
zip{-# INLINE:: ByteStringzip #-}-> ByteString -> [(Word8,Word8)]
zip v1 v2
-- | 'zipWith' generalises 'zip' by zipping with the function given as VS.null v1 || VS.null v2 = []
-- the first argument, instead of a tupling function.  For example, otherwise = (VS.unsafeHead v1, VS.unsafeHead v2)
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list of zip (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINE-- corresponding sums. #-}
zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
zipWith-- | 'zipWith' generalises 'zip' by zipping with the function given asf = go
-- the first argument, instead of a tupling function.  For example,where
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list ofgo v1 v2
-- corresponding sums.| VS.null v1 || VS.null v2 = []
zipWith ::| otherwiseWord8 ->=Word8f (VS.unsafeHead-> a) -> ByteStringv1) (VS.unsafeHead-> ByteStringv2)-> [a]
zipWith f = go      : go (VS.unsafeTail v1) (VS.unsafeTail v2)
{-# INLINEwhere  [1] zipWith #-}
      go v1 v2
{-# RULES VS.null v1 || VS.null v2 = []
"ByteString specialise zipWith" otherwise = f (VS.unsafeHeadforall v1(f)::VS.unsafeHeadWord8 -> Word8)-> Word8) p q .
    zipWith f p q = :unpack (VS.unsafeTail(zipWith' f pv1q) (VS.unsafeTail v2)
{-# INLINE#-}      [1] zipWith #-}

{-# RULES-- | A specialised version of zipWith for the common case of a
"ByteString specialise zipWith"-- simultaneous map over two bytestrings, to build a 3rd. Rewrite rulesforall (f :: Word8 -> Word8 -> Word8) p q .
-- are used to automatically covert zipWith into zipWith' when a pack is f p q = unpack (zipWith' f p q)
-- performed on the result of zipWith.#-}
zipWith' :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
zipWith' f v1 v2 =
-- | A specialised version of zipWith for the common case of aunsafeInlineIO $
-- simultaneous map over two bytestrings, to build a 3rd. Rewrite ruleswithForeignPtr fp1 $ \p1 ->
-- are used to automatically covert zipWith into zipWith' when a pack iswithForeignPtr fp2 $ \p2 ->
-- performed on the result of zipWith.create len $ \p ->
zipWith' :: (Word8let go->!nWord8 -> Word8) -> ByteString -> ByteString -> ByteString
zipWith' f v1 v2 =   | n >= len = return ()
    unsafeInlineIO $ | otherwise = do
      withForeignPtr fp1 $  \<-p1peekByteOff->         p1 n
         withForeignPtr fp2y <- \peekByteOffp2 ->      p2 n
           create len $ \ppokeByteOff->        p n (f x y)
             let go !n   go (n+1)
             in go 0 | n >= len = return ()
    where            | otherwise = do
      len = min l1 l2    x <- peekByteOff p1 n
                         y <- peekByteOff p2 n
      (fp1, l1) = VS.unsafeToForeignPtr0 p n (v1f x y)
      (fp2, l2) = VS.unsafeToForeignPtr0 (n+1)        v2
{-# INLINE zipWith'in go 0#-}
    where
-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair of = min l1 l2
-- ByteStrings. Note that this performs two 'pack' operations.
unzip (::fp1[,Word8) = VS.unsafeToForeignPtr0Word8)] -> (ByteString,v1ByteString)
unzip (lsfp2=,(l2VS.fromList) = VS.unsafeToForeignPtr0$ L.map fst ls  v2
{-# INLINE zipWith', VS.fromList#-}  $ L.map snd ls
           )
{-# INLINE-- | /O(n)/ 'unzip' transforms a list of pairs of bytes into a pair ofunzip #-}
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
unzip-------------------------------------------------------------------------------- = ( VS.fromList $ L.map fst ls
-- * Ordered ByteStrings, VS.fromList $ L.map snd ls
--------------------------------------------------------------------------------)
{-# INLINE unzip #-}
-- | /O(n)/ Sort a ByteString efficiently, using counting sort.
sort :: ByteString -> ByteString
sort--------------------------------------------------------------------------------v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do
-- * Ordered ByteStrings
---------------------------------------------------------------------------------- Initialize counts array to all 0s:
    void $ memset (castPtr counts)
-- | /O(n)/ Sort a ByteString efficiently, using counting sort.0
sort :: ByteString(->256ByteString* fromIntegral (sizeOf (undefined :: CSize)))
sort v = unsafeCreate l $ \p' -> allocaArray 256 $ \counts -> do
    -- Count occurrences:
    withForeignPtr-- Initialize counts array to all 0s:fp $ \p ->
    voidlet memsetgo !i (castPtri == l counts= return)     ()
                  0 otherwise = do
                  (256k*<-fromIntegralsizeOf`fmap`(undefinedpeekElemOff::pCSizei   )))
                      x <- peekElemOff counts k
    -- Count occurrences:pokeElemOff counts k (x + 1)
    withForeignPtr fp $go\pi->+ 1)
        letin go0!i | i == l    = return ()
                  | otherwise = do
    -- Fill result array: <- fromIntegral `fmap` peekElemOff p i
    let go 256 _   = return <- peekElemOff()         counts k
        go !i !ptr = do counts k (x + 1)
          n <- peekElemOff (icounts 1)  i
        inwhen 0(n /= 0) $ void $ memset ptr (fromIntegral i) n
          go (i + 1) (ptr `plusPtr` fromIntegral n)
    go-- Fill result array:0 p'
  where go 256 _   = return ()
    (fp,gol)!i !VS.unsafeToForeignPtr0ptr = do              v
{-# INLINEnsort<- peekElemOff#-}        counts i
          when (n /= 0) $ void $ memset ptr (fromIntegral i) n
          go (i + 1) (ptr `plusPtr` fromIntegral n)
-------------------------------------------------------------------------------- 0 p'
-- * Low level conversionswhere
--------------------------------------------------------------------------------fp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE sort #-}
--------------------------------------------------------------------------------
-- ** Copying ByteStrings
--------------------------------------------------------------------------------
-- * Low level conversions-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.
-- This is mainly useful to allow the rest of the data pointed--------------------------------------------------------------------------------
-- to by the 'ByteString' to be garbage collected, for example
-- if a large string has been read in, and only a small part of it--------------------------------------------------------------------------------
-- ** Copying ByteStrings-- is needed in the rest of the program.
--
copy-- | /O(n)/ Make a copy of the 'ByteString' with its own storage.:: ByteString -> ByteString
copy-- This is mainly useful to allow the rest of the data pointedv = unsafeCreate l $ \p' ->
-- to by the 'ByteString' to be garbage collected, for examplewithForeignPtr fp $ \p ->
-- if a large string has been read in, and only a small part of itmemcpy p' p (fromIntegral l)
-- is needed in the rest of the program.where
--    (fp, l) = VS.unsafeToForeignPtr0 v
copy{-# INLINE:: ByteStringcopy #-}-> ByteString
copy v = unsafeCreate l $ \p' ->
-------------------------------------------------------------------------------- fp $ \p ->
                                                      --  ** Packing 'CString's and pointers p' p (fromIntegral l)
    where
-- | /O(n)./ Construct a new @ByteString@ from a @CString@. Thefp, l) = VS.unsafeToForeignPtr0 v
{-# INLINE-- resulting @ByteString@ is an immutable copy of the original #-}
-- @CString@, and is managed on the Haskell heap. The original
-- @CString@ must be null terminated.--------------------------------------------------------------------------------
packCString--  ** Packing 'CString's and pointers:: CString -> IO ByteString
packCString cstr = do
-- | /O(n)./ Construct a new @ByteString@ from a @CString@. Thelen <- c_strlen cstr
-- resulting @ByteString@ is an immutable copy of the originalpackCStringLen (cstr, fromIntegral len)
{-# INLINE-- @CString@, and is managed on the Haskell heap. The originalpackCString #-}
-- @CString@ must be null terminated.
packCString-- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. The:: CString -> IO ByteString
packCString-- resulting @ByteString@ is an immutable copy of the original @CStringLen@. = do
-- The @ByteString@ is a normal Haskell value and will be managed on the <- c_strlen cstr
-- Haskell heap. (cstr, fromIntegral len)
{-# INLINEpackCStringLen:: CStringLen#-}   -> IO ByteString
packCStringLen (cstr, len) | len >= 0 = create len $ \p ->
-- | /O(n)./ Construct a new @ByteString@ from a @CStringLen@. Thememcpy p (castPtr cstr) (fromIntegral len)
packCStringLen-- resulting @ByteString@ is an immutable copy of the original @CStringLen@.(_, len) =
-- The @ByteString@ is a normal Haskell value and will be managed on themoduleError "packCStringLen" ("negative length: " ++ show len)
{-# INLINE-- Haskell heap.packCStringLen #-}
packCStringLen :: CStringLen -> IO ByteString
packCStringLen--------------------------------------------------------------------------------cstr, len) | len >= 0 = create len $ \p ->
                                                                -- ** Using ByteStrings as 'CString's p (castPtr cstr) (fromIntegral len)
packCStringLen (_, len) =
-- | /O(n) construction/ Use a @ByteString@ with a function requiring a "packCStringLen" ("negative length: " ++ show len)
{-# INLINE-- null-terminated @CString@.  The @CString@ will be freed #-}
-- automatically. This is a memcpy(3).
useAsCString--------------------------------------------------------------------------------:: ByteString -> (CString -> IO a) -> IO a
useAsCString-- ** Using ByteStrings as 'CString'sv action = do
 allocaBytes (l+1) $ \buf ->
-- | /O(n) construction/ Use a @ByteString@ with a function requiring awithForeignPtr fp $ \p -> do
-- null-terminated @CString@.  The @CString@ will be freedmemcpy buf p (fromIntegral l)
-- automatically. This is a memcpy(3).pokeByteOff buf l (0::Word8)
useAsCStringaction ::(castPtrbuf) -> (CString -> IO a) -> IO a
useAsCStringwhere    v action = do
 allocaBytes(fp, l)(l+1VS.unsafeToForeignPtr0) $ \buf ->           v
                     {-# INLINEuseAsCString $ \#-}p -> do
                     memcpy buf p (fromIntegral l)
               -- | /O(n) construction/ Use a @ByteString@ with a function requiring a @CStringLen@. buf l (0::Word8)
               -- As for @useAsCString@ this function makes a copy of the original @ByteString@. (castPtr buf)
useAsCStringLenwhere       :: ByteString -> (CStringLen -> IO a) -> IO a
useAsCStringLenfp, l) = VS.unsafeToForeignPtr0v f = useAsCString v $ vcstr -> f (cstr, VS.length v)
{-# INLINE useAsCStringuseAsCStringLen#-}#-}

-- | /O(n) construction/ Use a @ByteString@ with a function requiring a @CStringLen@.
---------------------------------------------------------------------------------- As for @useAsCString@ this function makes a copy of the original @ByteString@.
useAsCStringLen--  * I\/O with 'ByteString's:: ByteString -> (CStringLen -> IO a) -> IO a
useAsCStringLen-------------------------------------------------------------------------------- f = useAsCString v $ \cstr -> f (cstr, VS.length v)
{-# INLINE useAsCStringLen #-}
--------------------------------------------------------------------------------
-- ** Standard input and output
--------------------------------------------------------------------------------
-- | Read a line from stdin.--  * I\/O with 'ByteString's
getLine--------------------------------------------------------------------------------:: IO ByteString
getLine = hGetLine stdin
--------------------------------------------------------------------------------
-- ** Standard input and output-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
-- The 'Handle' is closed after the contents have been read.
---- | Read a line from stdin.
getLinegetContents:: IO::ByteStringIO ByteString
getLinegetContents= hGetLine= hGetContents   stdin

-- | Write a ByteString to stdout-- | getContents. Read stdin strictly. Equivalent to hGetContents stdin
putStr-- The 'Handle' is closed after the contents have been read.:: ByteString -> IO ()
--putStr = hPut stdout
getContents :: IO ByteString
getContents-- | Write a ByteString to stdout, appending a newline byte= hGetContents stdin
putStrLn :: ByteString -> IO ()
putStrLn-- | Write a ByteString to stdout= hPutStrLn stdout
putStr :: ByteString -> IO ()
putStr-- | The interact function takes a function of type @ByteString -> ByteString@= hPut stdout
-- as its argument. The entire input from the standard input device is passed
-- | Write a ByteString to stdout, appending a newline byte-- to this function as its argument, and the resulting string is output on the
putStrLn-- standard output device.:: ByteString -> IO ()
putStrLn--       = hPutStrLn stdout
interact :: (ByteString -> ByteString) -> IO ()
interact-- | The interact function takes a function of type @ByteString -> ByteString@transformer = putStr . transformer =<< getContents
-- as its argument. The entire input from the standard input device is passed
-- to this function as its argument, and the resulting string is output on the--------------------------------------------------------------------------------
-- ** Files-- standard output device.
--
interact-- | Read an entire file strictly into a 'ByteString'.  This is far more:: (ByteString -> ByteString) -> IO ()
interact-- efficient than reading the characters into a 'String' and then using = putStr . transformer =<< getContents
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet. Files are read using 'binary mode' on Windows,--------------------------------------------------------------------------------
-- ** Files-- for 'text mode' use the Char8 version of this function.
--
readFile-- | Read an entire file strictly into a 'ByteString'.  This is far more:: FilePath -> IO ByteString
readFile-- efficient than reading the characters into a 'String' and then usingf = withBinaryFile f ReadMode $ \h ->
-- 'pack'.  It also may be more efficient than opening the file andhFileSize h >>= hGet h . fromIntegral
-- reading it using hGet. Files are read using 'binary mode' on Windows,
-- | Write a 'ByteString' to a file.-- for 'text mode' use the Char8 version of this function.
--writeFile :: FilePath -> ByteString -> IO ()
readFilewriteFile::f FilePathtxt = withBinaryFile-> IO ByteStringf WriteMode $ \h -> hPut h txt
readFile f = withBinaryFile f ReadMode $ \h ->
-- | Append a 'ByteString' to a file. h >>= hGet h . fromIntegral
appendFile :: FilePath -> ByteString -> IO ()
appendFile-- | Write a 'ByteString' to a file.f txt = withBinaryFile f AppendMode $ \h -> hPut h txt
writeFile :: FilePath -> ByteString -> IO ()
writeFile-------------------------------------------------------------------------------- txt = withBinaryFile f WriteMode $ \h -> hPut h txt
-- ** I\/O with Handles
-- | Append a 'ByteString' to a file.
appendFile-- | Read a line from a handle:: FilePath -> ByteString -> IO ()
appendFile f txt = withBinaryFile f AppendMode $ \h -> hPut h txt
hGetLine :: Handle -> IO ByteString
hGetLine--------------------------------------------------------------------------------h =
-- ** I\/O with HandleswantReadableHandle_ "Data.Vector.Storable.ByteString.hGetLine" h $
    \ h_@Handle__{haByteBuffer} -> do
-- | Read a line from a handleflushCharReadBuffer h_
      buf <- readIORef haByteBuffer
hGetLineif ::isEmptyBuffer -> IObuf
hGetLinethen = fill    h_ buf 0 []
  wantReadableHandle_else haveBuf h_buf 0 []                                 h $
 where h_@Handle__{haByteBuffer} -> do
   fillflushCharReadBufferh_@Handle__{haByteBuffer   , haDevice} buf !len xss = do
     (rbuf, buf'<-)readIORef<- Buffered.fillReadBuffer      haDevice buf
     ififr isEmptyBuffer== 0          buf
        thenthendowriteIORef bufhaByteBuffer []       buf{ bufR=0, bufL=0 }
         else haveBufif lenh_> buf0   0 []
 where            then mkBigPS len xss
  fill h_@Handle__{elsehaByteBufferioe_EOF , haDevice} buf !len xss = do
    (r,else)haveBuf<- Buffered.fillReadBufferh_ buf' len xss      haDevice buf
    if r == 0
  haveBufthenh_do@Handle__{haByteBuffer}    buf{ bufR=0, bufL=0 }
            buf@Buffer len{ >bufRaw   =raw, bufR=w, bufL=r }
            len xss then= do mkBigPS len xss
      off <- findEOLelser w ioe_EOFraw
    letelsenew_len= len+buf'off len- r xss
    xs <- mkPS raw r off
  haveBuf h_@Handle__{haByteBuffer}
    -- if eol == True, then off is the offset of the '\n'@Buffer{ bufRaw=raw, bufR=w, bufL=r }
    -- otherwise off == w and the buffer is now empty. xss = do
    offif off<- findEOL/= w    r w raw
    letthendo if=(lenw ==+off+-1r
    xs <- mkPS rawthen offwriteIORef haByteBuffer buf{ bufL=0, bufR=0 }
                else writeIORef haByteBuffer buf{ bufL = off + 1 }
    -- if eol == True, then off is the offset of the '\n'mkBigPS new_len (xs:xss)
    -- otherwise off == w and the buffer is now empty.else fill h_ buf{ bufL=0, bufR=0 } new_len (xs:xss)
    if off /= w
  -- find the end-of-line character, if there is onethen do if (w == off + 1)
                                                findEOL r w rawthen writeIORef haByteBuffer buf{ bufL=0, bufR=0 }
                                                    | r == w =elsereturnw       haByteBuffer buf{ bufL = off + 1 }
                                                    | otherwise=  do (xs:xss)
      elsecfill<- readWord8Buf buf{ bufL=raw0, bufRr   =0 } new_len (xs:xss)
          if c == fromIntegral (ord '\n')
  -- find the end-of-line character, if there is onethen return r -- NB. not r+1: don't include the '\n'
  findEOL r welsefindEOL (r+1) w raw
      | r == w = return w
mkPS :: otherwise =Word8 -> Int -> Int -> IO ByteString
mkPS buf start <- readWord8Bufend =        raw r
 create len$c\==p -> (ord '\n')
   withRawBufferthen returnbuf $ \rpbuf-- NB. not r+1: don't include the '\n'-> do
   copyByteselsep (pbuf`plusPtrr+1) wstart) len
 where
mkPSlen::=RawBufferend - start -> Int -> Int -> IO ByteString
mkPS buf start end =
mkBigPS len:: Int \p->->[ByteString] -> IO ByteString
 mkBigPS_ [v] = return $ \pbuf -> do
mkBigPS_ vs p=(pbufreturnplusPtr$! VS.concat` start)L.reverse      vs)
 where
-- | Outputs a 'ByteString' to the specified 'Handle'. = end - start
hPut :: Handle -> ByteString -> IO ()
mkBigPShPut h v:: Int -> [ByteString] -> IO ByteString
mkBigPS| l _==[v] = return= return ()
mkBigPS| otherwise vs  = return= withForeignPtr VS.concatfp (L.reverse\p -> hPutBuf)  h p l
    where
-- | Outputs a 'ByteString' to the specified 'Handle'.(fp, l) = VS.unsafeToForeignPtr0 v
hPut :: Handle -> ByteString -> IO ()
hPut-- | Similar to 'hPut' except that it will never block. Instead it returns v
-- any tail that did not get written. This tail may be 'empty' in the case that l == 0    = return ()
-- the whole string was written, or the whole original string if nothing was otherwise = withForeignPtr fp $ \p -> hPutBuf h p l
-- written. Partial writes are also possible.where
--    (fp, l) = VS.unsafeToForeignPtr0 v
-- Note: on Windows and with Haskell implementation other than GHC, this
-- function does not work correctly; it behaves identically to 'hPut'.-- | Similar to 'hPut' except that it will never block. Instead it returns
---- any tail that did not get written. This tail may be 'empty' in the case that
hPutNonBlocking-- the whole string was written, or the whole original string if nothing was:: Handle -> ByteString -> IO ByteString
hPutNonBlocking-- written. Partial writes are also possible.h v = do
--bytesWritten <- withForeignPtr fp $ \p-> hPutBufNonBlocking h p l
-- Note: on Windows and with Haskell implementation other than GHC, thisreturn $! VS.drop bytesWritten v
-- function does not work correctly; it behaves identically to 'hPut'.where
--      (fp, l) = VS.unsafeToForeignPtr0 v
hPutNonBlocking :: Handle -> ByteString -> IO ByteString
hPutNonBlocking-- | A synonym for @hPut@, for compatibility v = do
hPutStr:: Handle<- withForeignPtr-> ByteString ->IO \p-> hPutBufNonBlocking h p l
hPutStr=$!hPut bytesWritten v
      where
-- | Write a ByteString to a handle, appending a newline bytefp, l) = VS.unsafeToForeignPtr0 v
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn-- | A synonym for @hPut@, for compatibilityh v
hPutStr| VS.length:: Handlev ->< 1024= hPut ->h (IOv `(snoc)  ` 0x0a)
hPutStr| otherwise= hPut           = hPut h v >> hPut h (singleton (0x0a)) -- don't copy

{-# DEPRECATED-- | Write a ByteString to a handle, appending a newline bytehPutStrLn
hPutStrLn"Use Data.Vector.Storable.ByteString.Char8.hPutStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)":: Handle -> ByteString -> IO ()
hPutStrLn#-}     h v
{-# DEPRECATED VS.lengthputStrLn < 1024 = hPut h (v `snoc` 0x0a)
    |"Use Data.Vector.Storable.ByteString.Char8.putStrLn instead. (Functions that rely on ASCII encodings belong in Data.Vector.Storable.ByteString.Char8)"          = hPut h v >> hPut h (singleton (0x0a)) -- don't copy
  #-}
{-# DEPRECATED hPutStrLn
-- | Read a 'ByteString' directly from the specified 'Handle'.  This
-- is far more efficient than reading the characters into a 'String'#-}
-- and then using 'pack'. First argument is the Handle to read from,
{-# DEPRECATED-- and the second is the number of bytes to read. It returns the bytes
-- read, up to n, or 'null' if EOF has been reached.
--#-}
-- 'hGet' is implemented in terms of 'hGetBuf'.
--
-- If the handle is a pipe or socket, and the writing end-- | Read a 'ByteString' directly from the specified 'Handle'.  This
-- is closed, 'hGet' will behave as if EOF was reached.-- is far more efficient than reading the characters into a 'String'
---- and then using 'pack'. First argument is the Handle to read from,
hGet-- and the second is the number of bytes to read. It returns the bytes:: Handle -> Int -> IO ByteString
hGet-- read, up to n, or 'null' if EOF has been reached.h i
--  | i >  0    = createAndTrim i $ \p -> hGetBuf h p i
-- 'hGet' is implemented in terms of 'hGetBuf'.| i == 0    = return VS.empty
--  | otherwise = illegalBufferSize h "hGet" i
-- If the handle is a pipe or socket, and the writing end
-- is closed, 'hGet' will behave as if EOF was reached.-- | hGetNonBlocking is identical to 'hGet', except that it will never
---- block waiting for data to become available.  If there is no data
hGet-- available to be read, 'hGetNonBlocking' returns 'null'.:: Handle -> Int -> IO ByteString
hGet--   h i
hGetNonBlocking i >  0    =::createAndTrimHandle -> Inti-> \IOp ->ByteString h p i
hGetNonBlocking i == 0    = returni      VS.empty
    | otherwisei >  0    = illegalBufferSizecreateAndTrim i $ hp"hGet"-> hGetBufNonBlocking               h p i
    | i == 0    = return VS.empty
-- | hGetNonBlocking is identical to 'hGet', except that it will never| otherwise = illegalBufferSize h "hGetNonBlocking" i
-- block waiting for data to become available.  If there is no data
-- available to be read, 'hGetNonBlocking' returns 'null'.-- | Like 'hGet', except that a shorter 'ByteString' may be returned
---- if there are not enough bytes immediately available to satisfy the
hGetNonBlocking-- whole request.  'hGetSome' only blocks if there is no data:: Handle -> Int -> IO ByteString
hGetNonBlocking-- available, and EOF has not yet been reached. i
--  | i >  0    = createAndTrim i $ \p -> hGetBufNonBlocking h p i
hGetSome i ==::0Handle= return-> IntVS.empty-> IO ByteString
hGetSome otherwisehh i   = illegalBufferSize h "hGetNonBlocking" i
    | i > 0     = createAndTrim i $ \p -> hGetBufSome hh p i
-- | Like 'hGet', except that a shorter 'ByteString' may be returned| i == 0    = return VS.empty
-- if there are not enough bytes immediately available to satisfy the| otherwise = illegalBufferSize hh "hGetSome" i
-- whole request.  'hGetSome' only blocks if there is no data
illegalBufferSize-- available, and EOF has not yet been reached.:: Handle -> String -> Int -> IO a
--illegalBufferSize handle fn sz =
hGetSomeioError:: Handle(mkIOError-> IntillegalOperationErrorType-> IO ByteString       msg (Just handle) Nothing)
hGetSome--TODO: System.IO uses InvalidArgument here, but it's not exported :-( i
    |where > 0     = createAndTrim i $ \p -> hGetBufSome hh p i
    | imsg=0fn ++= return": illegal ByteString size "              ++ showsPrec 9 sz []
    | otherwise = illegalBufferSize hh "hGetSome" i
-- | Read entire handle contents strictly into a 'ByteString'.
illegalBufferSize--                :: Handle -> String -> Int -> IO a
illegalBufferSize-- This function reads chunks at a time, doubling the chunksize on each fn sz =
-- read. The final buffer is then realloced to the appropriate size. For (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
-- files > half of available memory, this may lead to memory exhaustion.--TODO: System.IO uses InvalidArgument here, but it's not exported :-(
-- Consider using 'readFile' in this case.where
--    msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
-- As with 'hGet', the string representation in the file is assumed to
-- be ISO-8859-1.-- | Read entire handle contents strictly into a 'ByteString'.
--
-- The Handle is closed once the contents have been read,-- This function reads chunks at a time, doubling the chunksize on each
-- or if an exception is thrown.-- read. The final buffer is then realloced to the appropriate size. For
---- files > half of available memory, this may lead to memory exhaustion.
hGetContents-- Consider using 'readFile' in this case.:: Handle -> IO ByteString
--hGetContents h = always (hClose h) $ do -- strict, so hClose
-- As with 'hGet', the string representation in the file is assumed tolet start_size = 1024
-- be ISO-8859-1.p <- mallocBytes start_size
--  i <- hGetBuf h p start_size
-- The Handle is closed once the contents have been read,if i < start_size
-- or if an exception is thrown.then do p' <- reallocBytes p i
--              fp <- newForeignPtr finalizerFree p'
hGetContents :: Handle       -> IOVS.unsafeFromForeignPtr0            fp i
hGetContentselse h = alwaysstart_sizehClose h) $ do -- strict, so hClose
    letwhere = 1024
    p <-always= flipstart_sizefinally
    i <-fhGetBufp s = do p start_size
    if i < start_sizelet s' = 2 * s
        thenp'<-reallocBytes<- reallocBytesp s'p i
           i  <-hGetBuf<- newForeignPtrh (p' `plusPtr` s) s    p'
           if ireturn< s   $! VS.unsafeFromForeignPtr0 fp i
        else f pthendo let i' = s + i
    where               p'' <- reallocBytes p' i'
        always = flip finallyfp  <- newForeignPtr finalizerFree p''
        f p s = do      return $! VS.unsafeFromForeignPtr0 fp i'
            let s'else= 2 *p'ss'
            p' <- reallocBytes p s'
            i  <- hGetBuf h (p' `plusPtr` s) s
-------------------------------------------------------------------------------- i < s
-- Utils        then do let i' = s + i
-------------------------------------------------------------------------------- <- reallocBytes p' i'
                        fp  <- newForeignPtr finalizerFree p''
-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length $! VS.unsafeFromForeignPtr0 fp i'
-- of the string if no element is found, rather than Nothing.else f p' s'
findIndexOrEnd :: (Word8 -> Bool) -> ByteString -> Int
findIndexOrEnd k v = unsafeInlineIO $  withForeignPtr fp $ \p ->
--------------------------------------------------------------------------------let end = p `plusPtr` l
-- Utilsgo !ptr | ptr == end = return l
--------------------------------------------------------------------------------| otherwise = do
                  w <- peek ptr
-- | 'findIndexOrEnd' is a variant of findIndex, that returns the lengthif k w
-- of the string if no element is found, rather than Nothing.then return (ptr `minusPtr` p)
findIndexOrEnd :: (Word8else -> Bool(ptr)`->plusPtr` 1)   -> Int
findIndexOrEndin go p      k v = unsafeInlineIO $  withForeignPtr fp $ \p ->
  letwhere = p `plusPtr` l
      go(fp!ptrl) | ptrVS.unsafeToForeignPtr0 end = return l  v
{-# INLINE findIndexOrEnd otherwise =#-}
                  w <- peek ptr
-- | Find from the end of the string using predicate k w
findFromEndUntil :: then(Word8-> Boolptr) ->minusPtrByteString` p)-> Int
findFromEndUntil predelse= go (ptr `plusPtr` 1)
  inwhere p
    wherego v | VS.null v              = 0
      (fp, l)pred= VS.unsafeToForeignPtr0(VS.unsafeLast v) = lv
{-# INLINE findIndexOrEnd| otherwise    #-}       = go (VS.unsafeTake (l-1) v)
           where
-- | Find from the end of the string using predicatel = VS.length v
findFromEndUntil{-# INLINE findFromEndUntil:: (Word8 ->#-}) -> ByteString -> Int
findFromEndUntil pred = go
moduleErrorwhere   :: String -> String -> a
moduleError v |funmsg =verror $ "Data.Vector.Storable.ByteString."= 0                          ++
           | pred (VS.unsafeLastfun)++= l':':' ':msg
{-# NOINLINE otherwisemoduleError #-}        = go (VS.unsafeTake (l-1) v)

</pre>