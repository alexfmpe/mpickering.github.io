<a href="Hash.hs17195338081517273377.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Hash2.hs178448449274243042.out.html">next</a></br></br><pre>1a2
> module Data.Homeomorphic.Hash1(
1a3
> #define NAME Hash1, empty, insert, find, findOne
1a4
> #include "Include/Hash.hs") where
3d5
< #define NAME Hash1
4c6
< #include "Include/Hash.hs"
---
> import Data.Homeomorphic.Internal
4a7
> import Data.Maybe
5a9
> import Data.List(foldl')
5a10
> import qualified Data.Set as Set
5a11
> import qualified Data.IntMap as IntMap
7c13
< type Hash k = Set.Set (Int,k)
---
> -- important: calculate the hash of y only once per invokation
7a14
> data Homeomorphic k v = Homeomorphic [(Shell k, Hash k, v)]
9d15
< calcHash :: Ord k => Shell k -> Hash k
10d15
< calcHash = f Set.empty
11d15
<     where f x (Shell a b c) = foldl' f (Set.insert (b,a) x) c
13d16
< -- important: calculate the hash of y only once per invokation
14d16
< checkHash :: Ord k => Shell k -> Hash k -> Bool
15d16
< checkHash y = (`Set.isSubsetOf` calcHash y)
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}

#define NAME Hash1
#include "Include/Hash.hs"


type Hash k = Set.Set (Int,k)

calcHash :: Ord k => Shell k -> Hash k
calcHash = f Set.empty
    where f x (Shell a b c) = foldl' f (Set.insert (b,a) x) c

-- important: calculate the hash of y only once per invokation
checkHash :: Ord k => Shell k -> Hash k -> Bool
checkHash y = (`Set.isSubsetOf` calcHash y)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
module Data.Homeomorphic.Hash1(
#define NAME Hash1, empty, insert, find, findOne
#include "Include/Hash.hs") where

import Data.Homeomorphic.Internal
import Data.Maybe

import Data.List(foldl')
import qualified Data.Set as Set
import qualified Data.IntMap as IntMap

-- important: calculate the hash of y only once per invokation
data Homeomorphic k v = Homeomorphic [(Shell k, Hash k, v)]


</pre>