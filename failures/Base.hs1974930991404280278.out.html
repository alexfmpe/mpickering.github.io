<a href="Base.hs18171295601131570933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Base.hs340756291478446501.out.html">next</a></br></br><pre>7c7
< module Data.Vect.Flt.Base
---
> module Data.Vect.Float.BaseData.Vect.Flt.Base
80d79
<   mapVec    :: (Flt -> Flt) -> v -> v
81d79
<   scalarMul :: Flt -> v -> v
82d79
<   (*&) ::      Flt -> v -> v
83c80
<   (&*) ::      v -> Flt -> v
---
>   mapVec    :: (FloatFlt ->->Flt) ->)v->->vv-> v
83a81
>   scalarMul :: FloatFlt ->->v v->->v v
83a82
>   (*&) ::      FloatFlt ->->v v->->v v
83a83
>   (&*) ::      v -> FloatFlt ->->v v
96d95
<   (&.) :: v -> v -> Flt
97d95
<   norm    :: v -> Flt
98d95
<   normsqr :: v -> Flt
99d95
<   len     :: v -> Flt
100d95
<   lensqr  :: v -> Flt
101d95
<   len = norm
102d95
<   lensqr = normsqr
103d95
<   dotprod :: v -> v -> Flt
104d95
<   normsqr v = (v &. v)
105c96
<   norm = sqrt . lensqr
---
> class(&.)DotProd:: v ->vvwhere-> Flt
105a97
>   (norm&.) :: v::->v v->->Flt
105a98
>   normnormsqr :: v -> FloatFlt
105a99
>   normsqrlen     :: v -> FloatFlt
105a100
>   lenlensqr  :: v -> FloatFlt
105a101
>   lensqrlen = norm:: v -> Float
105a102
>   lenlensqr= norm= normsqr
105a103
>   lensqrdotprod=::v -> v -> Flt
105a104
>   dotprod ::v =v(->v &. ->v) Float
105a105
>   normsqrnorm = sqrt = (vlensqr v)
105a106
>   normdotprod= sqrt= (&.)lensqr
107d107
< 
109c109
< 
---
> infix 7 &.
111d110
< "len/square 1"   forall x.  (len x)*(len x) = lensqr x
112d110
< "len/square 2"   forall x.  (len x)^2 = lensqr x
113d110
< "norm/square 1"  forall x.  (norm x)*(norm x) = normsqr x
114c111
< "norm/square 2"  forall x.  (norm x)^2 = normsqr x
---
> {-# RULES"len/square 1"   forall x.  (len x)*(len x) = lensqr x
114a112
> "len/square 1"   forall x.  (len x)*(len= lensqr) = lensqrx     x
114a113
> "len/square 2""norm/square 1"  forall x.  (lennormx)^2(=normx) =xnormsqr x
114a114
> "norm/square 1"  forall x.  (norm x)*(norm= normsqr) = normsqrx      x
114a115
> "norm/square 2"#-}            forall x.  (norm x)^2 = normsqr x
116d116
< 
119d118
< 
120c119
< distance :: (Vector v, DotProd v) => v -> v -> Flt
---
> normalize :: (Vector v, DotProd v) => v -> v
120a120
> normalizedistance :: =Vectorv, DotProd1.0/(lenv) v=>))vv-> v -> Flt
122d121
< 
123c122
< -- | the angle between two vectors
---
> distance :: (Vector v, DotProd v) => v -> v -> Float
123a123
> distance-- | the angle between two vectors y = norm (x &- y)
125d124
< angle x y = acos $ (x &. y) / (norm x * norm y)
126d124
< 
127c125
< -- | the angle between two unit vectors
---
> angle-- | the angle between two vectorsx y = acos $ (x &. y) / (norm x * norm y)
127a126
> angle :: (Vector v, DotProd v) => v -> v -> Float
127a127
> angle-- | the angle between two unit vectors y = acos $ (x &. y) / (norm x * norm y)
129d128
< angle' x y = acos (fromNormal x &. fromNormal y)
130d128
< 
131c129
< {-# RULES
---
> angle'-- | the angle between two unit vectorsx y = acos (fromNormal x &. fromNormal y)
131a130
> angle' {- ' CPP is sensitive to primes -} :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Float
131a131
> angle'{-# RULES y = acos (fromNormal x &. fromNormal y)
133d132
<   #-}
134d132
< 
135c133
< class (Vector v, DotProd v) => UnitVector v u | v->u, u->v  where
---
> {-# RULES#-}
135a134
> "normalize is idempotent"  forall x. normalize (normalize x) = normalize x
135a135
> class#-} (Vector v, DotProd v) => UnitVector v u | v->u, u->v  where
137a138
> classfromNormalVector v, DotProd:: u ->)v=> UnitVector v u | v->u, u->v  where
137a139
>   mkNormalfromNormalRadius :: vFlt->-> u -> v-- ^ normalizes the input
137a140
>   toNormalUnsafefromNormalRadius ::t nv=->t u*& fromNormal-- ^ does not normalize the input!n
139d141
<   fromNormalRadius :: Flt -> u -> v
140d141
<   fromNormalRadius t n = t *& fromNormal n
141d141
< 
142d141
< -- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector
143c142
< project' :: (Vector v, UnitVector v u, DotProd v) => v -> u -> v
---
> -- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector :: Float -> u -> v
143a143
> project':: (Vectortvn =UnitVector *& fromNormalv u, DotProd     v) => v -> u -> v
145d144
< 
146d144
< -- | Direction (second argument) is assumed to be a /unit/ vector!
147c145
< projectUnsafe :: (Vector v, DotProd v) => v -> v -> v
---
> -- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector
147a146
> project'-- | Direction (second argument) is assumed to be a /unit/ vector!:: (Vector v, UnitVector v u, DotProd v) => v -> u -> v
147a147
> project'projectUnsafe dir:: (=Vectorv, DotProdv) (=>fromNormalv -> v ->dirv )
149d148
< 
150d148
< project :: (Vector v, DotProd v) => v -> v -> v
151c149
< project what dir = what &- dir &* ((what &. dir) / (dir &. dir))
---
> -- | Direction (second argument) is assumed to be a /unit/ vector!
151a150
> projectUnsafeproject :: (Vector:: (Vectorv, DotProd, DotProdv) => v)->=>vv->->vv -> v
151a151
> projectUnsafeproject what dir= dirwhat=&-dir&-&*dir((what (what&. dir) dir/ ()dir &. dir))
153d152
< -- | Since unit vectors are not a group, we need a separate function.
154c153
< flipNormal :: UnitVector v n => n -> n
---
> project-- | Since unit vectors are not a group, we need a separate function.:: (Vector v, DotProd v) => v -> v -> v
154a154
> projectflipNormal::dirUnitVector= what &-v dirn =>&*n (->(whatn   &. dir) / (dir &. dir))
156d155
< 
157d155
< -- | Cross product
158c156
< class CrossProd v where
---
> -- | Since unit vectors are not a group, we need a separate function.
158a157
> flipNormal-- | Cross product:: UnitVector v n => n -> n
158a158
> flipNormalclass CrossProd= toNormalUnsafev where     . neg . fromNormal
160d159
<   (&^)      :: v -> v -> v
161d159
<   (&^) = crossprod
162d159
< 
163d159
< -- | Pointwise multiplication
164c160
< class Pointwise v where
---
> -- | Cross product(&^)      :: v -> v -> v
164a161
> class(&^)CrossProd= crossprod where
164a162
>   crossprod :: v -> v -> v
164a163
> -- | Pointwise multiplication&^)      :: v -> v -> v
164a164
> class&^)Pointwise= crossprodv where
166d165
<   (&!)      :: v -> v -> v
167d165
<   (&!) = pointwise
168d165
< 
169d165
< infix 7 &^
170c166
< infix 7 &!
---
> -- | Pointwise multiplication(&!)      :: v -> v -> v
170a167
> class(&!)Pointwise= pointwise where
170a168
>   pointwise :: v -> v -> v
170a169
> infix&!)7 &^  :: v -> v -> v
170a170
> infix&!)7=&!
172c172
< class HasCoordinates v x | v->x where
---
> infix 7HasCoordinates           v x | v->x where
172a173
> infix_1 ::7 &!v -> x
172a174
>   _2 :: v -> x
172a175
> class_3 ::v -> x       v x | v->x where
175d177
<   _3 :: v -> x
176d177
<   _4 :: v -> x
177d177
< 
178d177
< -- | conversion between vectors (and matrices) of different dimensions
179c178
< class Extend u v where
---
> -- | conversion between vectors (and matrices) of different dimensions :: v -> x
179a179
> class ::Extend -> x v where
181d180
<   extendWith :: Flt -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
182d180
<   trim :: v -> u                -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@
183d180
< 
184d180
< -- | makes a diagonal matrix from a vector
185c181
< class Diagonal s t | t->s where
---
> -- | conversion between vectors (and matrices) of different dimensionsextendWith :: Flt -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
185a182
> classtrimExtend:: v -> v where          -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@
185a183
>   extendZero :: u -> v          -- ^ example: @extendZero (Vec2 5 6) = Vec4 5 6 0 0@
185a184
> -- | makes a diagonal matrix from a vector :: Float -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
185a185
> classDiagonal:: v -> u t | t->s where -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@
187d186
< 
188d186
< class Matrix m where
189c187
<   transpose :: m -> m
---
> -- | makes a diagonal matrix from a vector
189a188
> class DiagonalMatrix m swhere | t->s where
189a189
>   diagtranspose:: s -> t -> m
191d190
<   idmtx :: m
192d190
< 
193d190
< {-# RULES
194c191
< "transpose is an involution"  forall m. transpose (transpose m) = m
---
> classidmtx:: m m where
194a192
>   transpose :: m -> m
194a193
> {-# RULES :: m -> m
194a194
> "transpose is an involution" :: m                  forall m. transpose (transpose m) = m
196d195
<   #-}
197d195
< 
198d195
< class Matrix m => Orthogonal m o | m->o, o->m where
199c196
<   fromOrtho     :: o -> m
---
> {-# RULES#-}
199a197
> "transpose is an involution"  forall m. transpose (transpose m) = m
199a198
> "inverse is an involution"class Matrix m => Orthogonal mforallo | m->.,inverseo->m whereinverse m) = m
199a199
>   #-}fromOrtho     :: o -> m
202d201
< class (AbelianGroup m, Matrix m) => MatrixNorms m where
203d201
<   frobeniusNorm  :: m -> Flt       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
204c202
<   matrixDistance :: m -> m -> Flt  -- ^ euclidean distance in the space of matrices
---
> class Matrix(AbelianGroup => Orthogonalm, Matrixmmo |=>m->MatrixNormso, o->m wherem where
204a203
>   fromOrthofrobeniusNorm ::::om->->mFlt       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
204a204
>   toOrthoUnsafematrixDistance::::mm->->om -> Flt  -- ^ euclidean distance in the space of matrices
206d205
<   matrixDistance m n = frobeniusNorm (n &- m)
207c206
<   operatorNorm = error "operatorNorm: not implemented yet"
---
> classmatrixDistanceAbelianGroupm nm, MatrixfrobeniusNorm) => MatrixNorms(n &- m)   m where
207a207
>   frobeniusNormoperatorNorm = ::error ->"operatorNorm: not implemented yet"       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
207a208
>   matrixDistance :: m -> m -> Float  -- ^ euclidean distance in the space of matrices
207a209
> -- | Outer product (could be unified with Diagonal?)   :: m -> Float       -- ^ (euclidean) operator norm (not implemented yet)
207a210
> classTensor t v m n->=vfrobeniusNormwhere        (n &- m)
207a211
>   operatorNormouter :: v ->=verror-> t "operatorNorm: not implemented yet"
209d212
< -- | Outer product (could be unified with Diagonal?)
210c213
< class Tensor t v | t->v where
---
> class-- | Outer product (could be unified with Diagonal?)Determinant m where
210a214
> classdet Tensor:: m ->tFlt | t->v where
212d215
< 
213d215
< class Determinant m where
214d215
<   det :: m -> Flt
215d215
< 
217d216
<   dim :: a -> Int
218c217
< 
---
> classdim Determinant:: a -> Int m where
218a218
>   det :: m -> Float
220d219
< -- In plain words, it is the reflection to the hyperplane orthogonal to the input vector.
221c220
< householder :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
---
> class-- In plain words, it is the reflection to the hyperplane orthogonal to the input vector. a where
221a221
> householder :: a ->::Int(Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
222a223
> -- | Householder matrix, see <http://en.wikipedia.org/wiki/Householder_transformation>.where v = fromNormal u
222a224
> -- In plain words, it is the reflection to the hyperplane orthogonal to the input vector.
222a225
> householderhouseholderOrtho:: (Vector:: (Vector, UnitVectorv, UnitVector u, Matrixv u, Matrix, Vectorm, Vector, Tensorm, Tensor v) =>m vu ->Orthogonal       m o) => u -> o
222a226
> householderhouseholderOrtho = idmtx= toOrthoUnsafe (2 *& outer. householder v)
224d227
< 
225d227
< householderOrtho :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
226d227
< householderOrtho = toOrthoUnsafe . householder
227d227
< 
229d228
< -- is an any matrix, the bottom right corner is 1, and the top-right
230c229
< -- column is zero. These describe the affine orthogonal transformation of
---
> householderOrtho-- is an any matrix, the bottom right corner is 1, and the top-right:: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
230a230
> householderOrtho-- column is zero. These describe the affine orthogonal transformation of= toOrthoUnsafe . householder
232d231
< class (Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p
233d231
<     | m->p, p->m, p->o, o->p, p->n, n->p, p->v, v->p, n->o, n->v, v->n where
234d231
<   fromProjective     :: p -> m
235c232
<   toProjectiveUnsafe :: m -> p
---
> class-- | \"Projective\" matrices have the following form: the top left corner(Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p
235a233
> -- is an any matrix, the bottom right corner is 1, and the top-right| m->p, p->m, p->o, o->p, p->n, n->p, p->v, v->p, n->o, n->v, v->n where
235a234
> -- column is zero. These describe the affine orthogonal transformation offromProjective     :: p -> m
235a235
> -- the space one dimension less.toProjectiveUnsafe :: m -> p
235a236
> classorthogonalVector v, Orthogonal:: o ->npo, Diagonal v n) => Projective v n o m p
235a237
>   linear| m->p, p->m, p->o::, o->->p,pp->n, n->p, p->v, v->p, n->o, n->v, v->n where
235a238
>   fromProjectivetranslation        :: p -> m
235a239
>   toProjectiveUnsafescaling            :: m -> p
237d240
<   linear             :: n -> p
238c241
<   translation        :: v -> p
---
> --------------------------------------------------------------------------------             :: n -> p
238a242
> -- Vec / Mat datatypes        :: v -> p
240d243
< 
241d243
< --------------------------------------------------------------------------------
242d243
< -- Vec / Mat datatypes
243d243
< 
245d244
<   deriving (Read,Show)
246c245
< data Vec3 = Vec3 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
---
> --------------------------------------------------------------------------------deriving (Read,Show)
246a246
> data-- Vec / Mat datatypesVec3 = Vec3 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
248c248
< data Vec4 = Vec4 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
---
> data Vec2 = Vec2 {-# UNPACK #-} !FloatFlt {-# UNPACK #-}#-}!Flt!Float{-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
250d249
< 
251d249
< -- | The components are /row/ vectors
252d249
< data Mat2 = Mat2 !Vec2 !Vec2              deriving (Read,Show)
253c250
< data Mat3 = Mat3 !Vec3 !Vec3 !Vec3        deriving (Read,Show)
---
> data Vec3 = Vec3 {-# UNPACK #-} !Float {-# UNPACK #-} !Float {-# UNPACK #-} !Float
253a251
> -- | The components are /row/ vectors (Read,Show)
253a252
> data Vec4 = Vec4 {-# UNPACK!Vec2 !Vec2#-} !Float {-# UNPACKderiving#-}(Read!Float,Show{-# UNPACK)          #-} !Float {-# UNPACK #-} !Float
253a253
> dataMat3 =(Read,Show!Vec3) !Vec3 !Vec3        deriving (Read,Show)
255d254
< 
256d254
< -- | The assumption when dealing with these is always that they are of unit length.
257d254
< -- Also, interpolation works differently.
258c255
< newtype Normal2 = Normal2 Vec2 deriving (Read,Show,Storable,DotProd,Dimension)
---
> -- | The components are /row/ vectors
258a256
> data-- | The assumption when dealing with these is always that they are of unit length. = Mat2 !Vec2 !Vec2              deriving (Read,Show)
258a257
> data-- Also, interpolation works differently. = Mat3 !Vec3 !Vec3 !Vec3        deriving (Read,Show)
258a258
> datanewtypeNormal2= Mat4=!Vec4Normal2Vec4Vec2Vec4derivingVec4(Read,Show,(StorableRead,Show,DotProd)     ,Dimension)
260d259
< newtype Normal4 = Normal4 Vec4 deriving (Read,Show,Storable,DotProd,Dimension)
261d259
< 
262d259
< mkVec2 :: (Flt,Flt) -> Vec2
263d259
< mkVec3 :: (Flt,Flt,Flt) -> Vec3
264c260
< mkVec4 :: (Flt,Flt,Flt,Flt) -> Vec4
---
> newtype-- | The assumption when dealing with these is always that they are of unit length.Normal4 = Normal4 Vec4 deriving (Read,Show,Storable,DotProd,Dimension)
264a261
> -- Also, interpolation works differently.
264a262
> newtypemkVec2 ::(Flt,Flt= Normal2) -> Vec2 deriving (Read,Show,Storable,DotProd,Dimension)
264a263
> newtypemkVec3 ::(Flt,Flt= Normal3,Flt) ->Vec3Vec3deriving (Read,Show,Storable,DotProd,Dimension)
264a264
> newtypemkVec4 ::(Flt,Flt= Normal4,Flt,FltVec4) -> derivingVec4     (Read,Show,Storable,DotProd,Dimension)
266d265
< mkVec2 (x,y)     = Vec2 x y
267d265
< mkVec3 (x,y,z)   = Vec3 x y z
268c266
< mkVec4 (x,y,z,w) = Vec4 x y z w
---
> mkVec2 ::(x,(Float)    ,Float= Vec2) ->x yVec2
268a267
> mkVec3 ::(x,(Float,z)  ,Float= Vec3,Floatx y ) -> Vec3
268a268
> mkVec4 ::(x,(Float,z,w),Float= Vec4,Floatx y ,Floatw   ) -> Vec4
270d269
< -- | Orthogonal matrices.
271d269
< --
272c270
< -- Note: the "Random" instances generates orthogonal matrices with determinant 1
---
> mkVec2-- | Orthogonal matrices.x,y)     = Vec2 x y
272a271
> mkVec3--     (x,y,z)   = Vec3 x y z
272a272
> mkVec4-- Note: the "Random" instances generates orthogonal matrices with determinant 1x,y,z,w) = Vec4 x y z w
274d273
< newtype Ortho2 = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
275d273
< newtype Ortho3 = Ortho3 Mat3 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
276c274
< newtype Ortho4 = Ortho4 Mat4 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
---
> newtype-- | Orthogonal matrices.Ortho2 = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
276a275
> --newtype Ortho3 = Ortho3 Mat3 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
276a276
> newtype-- Note: the "Random" instances generates orthogonal matrices with determinant 1Ortho4 = Ortho4 Mat4 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
276a277
> -- (that is, orientation-preserving orthogonal transformations)!
276a278
> newtype-- | Projective matrices, encoding affine transformations in dimension one less. = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
276a279
> newtype Ortho3Proj3 ==Proj3Mat3deriving(Read(Read,Show,Show,Storable,Storable,MultSemiGroup,MultSemiGroup) ,Determinant,Dimension)
276a280
> newtype Ortho4Proj4 ==Proj4Mat4deriving(Read(Read,Show,Show,Storable,Storable,MultSemiGroup,MultSemiGroup) ,Determinant,Dimension)
279c283
< newtype Proj3 = Proj3 Mat3 deriving (Read,Show,Storable,MultSemiGroup)
---
> newtype-- Unit vectors = Proj3 Mat3 deriving (Read,Show,Storable,MultSemiGroup)
281d284
< 
282d284
< --------------------------------------------------------------------------------
283d284
< -- Unit vectors
284d284
< 
286d285
<   mkNormal v = Normal2 (normalize v)
287c286
<   fromNormal (Normal2 v) = v
---
> --------------------------------------------------------------------------------mkNormal v = Normal2 (normalize v)
287a287
> -- Unit vectorsfromNormal (Normal2 v) = v
289d288
< 
290d288
< instance UnitVector Vec3 Normal3 where
291d288
<   mkNormal v = Normal3 (normalize v)
292c289
<   fromNormal (Normal3 v) = v
---
> instance UnitVector Vec2 Normal2 where
292a290
> instanceUnitVector = Normal2Vec3normalizeNormal3 where)
292a291
>   fromNormalmkNormal v (Normal2Normal3v)normalize= v      v)
292a292
>   toNormalUnsafefromNormal (Normal3= Normal2v) = v
294d293
< 
295d293
< instance UnitVector Vec4 Normal4 where
296d293
<   mkNormal v = Normal4 (normalize v)
297c294
<   fromNormal (Normal4 v) = v
---
> instance UnitVector Vec3 Normal3 where
297a295
> instanceUnitVector = Normal3Vec4normalizeNormal4 where)
297a296
>   fromNormalmkNormal v (Normal3Normal4v)normalize= v      v)
297a297
>   toNormalUnsafefromNormal (Normal4= Normal3v) = v
299d298
< 
300d298
< _rndUnit :: (RandomGen g, Random v, Vector v, DotProd v) => g -> (v,g)
301d298
< _rndUnit g =
302c299
<   if d > 0.01
---
> instance UnitVector Vec4 Normal4 where
302a300
> _rndUnit::v(=RandomGen (normalize, Random vv)Vector v, DotProd v) => g -> (v,g)
302a301
> _rndUnitg = (Normal4 v) = v
302a302
>   toNormalUnsafeif d > 0.01    = Normal4
303a304
> _rndUnitelse ::_rndUnitRandomGenh    g, Random v, Vector v, DotProd v) => g -> (v,g)
303a305
> _rndUnitwhere  g =
303a306
>   if(d,>)0.01= random g
303a307
>     thend = norm v &*v  (1.0/d) , h )
305d308
<   where
306d308
<     (v,h) = random g
307c309
<     d = norm v
---
> instancewhere  Random Normal2 where
307a310
>   randomv,h)g==randomlet (vgh) = _rndUnit g in (Normal2 v, h)
307a311
>   randomR = norm_ =vrandom
317d320
< instance Random Normal4 where
318c321
<   random g = let (v,h) = _rndUnit g in (Normal4 v, h)
---
> instance RandomCrossProdNormal3wherewhere
318a322
>   randomcrossprod =(letNormal3v,h))=(_rndUnitNormal3 wg in= mkNormalNormal4(vcrossprod, h)     v w)
320d323
< 
321d323
< instance CrossProd Normal3 where
322d323
<   crossprod (Normal3 v) (Normal3 w) = mkNormal (crossprod v w)
323d323
< 
325c325
< -- Orthogonal matrices
---
> instance-- Orthogonal matrices Normal3 where
325a326
>   crossprod (Normal3 v) (Normal3 w) = mkNormal (crossprod v w)
325a327
> instance Orthogonal Mat2 Ortho2 where
325a328
> --------------------------------------------------------------------------------fromOrtho (Ortho2 o) = o
325a329
> -- Orthogonal matricestoOrthoUnsafe = Ortho2
335c339
< instance Orthogonal Mat4 Ortho4 where
---
> instance------   Orthogonal Mat4 Ortho4 where
337d340
<   toOrthoUnsafe = Ortho4
338d340
< 
339d340
< ------
340d340
< 
341c341
< instance Matrix Ortho2 where
---
> instanceMatrix =Ortho2where
343c343
<   idmtx = Ortho2 idmtx
---
> ------idmtx = Ortho2 idmtx
345c345
< 
---
> instance Matrix Ortho2 where
345a346
> instanceMatrixOrtho2Ortho3) =where (transpose o)
345a347
>   idmtxtranspose= Ortho2(Ortho3o) = Ortho3 (transpose o)
345a348
>   inverseidmtx = =Ortho3idmtx
345a349
>   inverse = transpose
347d350
<   transpose (Ortho3 o) = Ortho3 (transpose o)
348c351
<   idmtx = Ortho3 idmtx
---
> instanceMatrixOrtho3Ortho4) =where (transpose o)
348a352
>   idmtxtranspose= Ortho3(Ortho4o) = Ortho4 (transpose o)
348a353
>   inverseidmtx = =Ortho4idmtx
350d354
< 
352c356
<   transpose (Ortho4 o) = Ortho4 (transpose o)
---
> ------ (Ortho4 o) = Ortho4 (transpose o)
354d357
<   inverse = transpose
355d357
< 
356c358
< ------
---
> instanceRandom= transposeOrtho2 where
356a359
>   random g = let (o,h) = _rndOrtho2 g in (toOrthoUnsafe (_flip1stRow2 o), h)
356a360
> ------randomR _ = random
363c367
<   random g = let (o,h) = _rndOrtho3 g in (toOrthoUnsafe (             o), h)
---
>   random g = let (o,h) = _rndOrtho3 g in (toOrthoUnsafe (_flip1stRow4 o), h)
366c370
< instance Random Ortho4 where
---
> instance------   Random Ortho4 where
368d371
<   randomR _ = random
369d371
< 
370d371
< ------
371d371
< 
372c372
< -- determinant will be -1
---
> -- determinant will be -1 _ = random
374c374
< _rndOrtho2 g = (h2, g1) where
---
> ------_rndOrtho2 g = (h2, g1) where
376d375
<   (u2,g1) = random g
377d375
< 
378d375
< -- generates a uniformly random orthogonal 3x3 matrix
379d375
< -- /with determinant +1/, with respect to the Haar measure of SO3.
380c376
< --
---
> -- determinant will be -1(u2,g1) = random g
380a377
> _rndOrtho2 :: RandomGen g => g -> (Mat2, g)
380a378
> _rndOrtho2-- generates a uniformly random orthogonal 3x3 matrix = (h2, g1) where
380a379
> -- /with determinant +1/, with respect to the Haar measure of SO3. = householder u2 :: Mat2
380a380
> --(u2,g1) = random g
382d381
< -- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groups
383d381
< -- Notices of the AMS, May 2007 issue
384d381
< -- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>
385d381
< _rndOrtho3 :: RandomGen g => g -> (Mat3, g)
386d381
< _rndOrtho3 g = ( (h3 .*. m3), g2) where
387d381
<   m3 = (extendWith :: Flt -> Mat2 -> Mat3) 1 o2
388d381
<   h3 = householder u3 :: Mat3
389d381
<   (u3,g1) = random g
390d381
<   (o2,g2) = _rndOrtho2 g1
391d381
< 
392d381
< -- determinant will be -1
393d381
< _rndOrtho4 :: RandomGen g => g -> (Mat4, g)
394c382
< _rndOrtho4 g = ( (h4 .*. m4), g2) where
---
> -- generates a uniformly random orthogonal 3x3 matrix-- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groups
394a383
> -- Notices of the AMS, May 2007 issue-- /with determinant +1/, with respect to the Haar measure of SO3.
394a384
> ---- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>
394a385
> _rndOrtho3-- see Theorem 4 in::: RandomGen g => g -> (Mat3, g)
394a386
> _rndOrtho3-- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groupsg = ( (h3 .*. m3), g2) where
394a387
> -- Notices of the AMS, May 2007 issuem3 = (extendWith :: Flt -> Mat2 -> Mat3) 1 o2
394a388
> -- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>h3 = householder u3 :: Mat3
394a389
> _rndOrtho3(u3,g1) =::randomg    g => g -> (Mat3, g)
394a390
> _rndOrtho3(o2,g2) =g_rndOrtho2= ( (h3 .*.g1m3), g2) where
394a391
>   m3 = (extendWith :: Float -> Mat2 -> Mat3) 1 o2
394a392
> -- determinant will be -1 = householder u3 :: Mat3
394a393
> _rndOrtho4u3,g1) =::RandomGen    g => g -> (Mat4, g)
394a394
> _rndOrtho4o2,g2) =g_rndOrtho2= ( (h4 .*.m4), g2) where
396c396
<   h4 = householder u4 :: Mat4
---
> -- determinant will be -1h4 = householder u4 :: Mat4
396a397
> _rndOrtho4(u4,g1) =::randomg    g => g -> (Mat4, g)
396a398
> _rndOrtho4(o3,g2) =g_rndOrtho3= ( (h4 .*.g1m4), g2) where
396a399
>   m4 = (extendWith :: Float -> Mat3 -> Mat4) 1 o3
396a400
> ------ = householder u4 :: Mat4
398d401
<   (o3,g2) = _rndOrtho3 g1
399d401
< 
400d401
< ------
401d401
< 
402c402
< _flip1stRow2 :: Mat2 -> Mat2
---
> _flip1stRow2o3,g2) = _rndOrtho3:: Mat2 ->g1Mat2
404c404
< 
---
> ------
406d405
< _flip1stRow3 (Mat3 a b c) = Mat3 (neg a) b c
407c406
< 
---
> _flip1stRow2 ::(Mat3a ->b cMat2) = Mat3 (neg a) b c
407a407
> _flip1stRow2 (Mat2 a b) = Mat2 (neg a) b
409d408
< _flip1stRow4 (Mat4 a b c d) = Mat4 (neg a) b c d
410c409
< 
---
> _flip1stRow3 ::(Mat4a ->b cMat3d) = Mat4 (neg a) b c d
410a410
> _flip1stRow3 (Mat3 a b c) = Mat3 (neg a) b c
412d411
< -- projective matrices
413c412
< 
---
> _flip1stRow4-- projective matrices:: Mat4 -> Mat4
413a413
> _flip1stRow4 (Mat4 a b c d) = Mat4 (neg a) b c d
415d414
<   fromProjective (Proj3 m) = m
416c415
<   toProjectiveUnsafe = Proj3
---
> --------------------------------------------------------------------------------fromProjective (Proj3 m) = m
416a416
> -- projective matricestoProjectiveUnsafe = Proj3
418d417
<   linear     = Proj3 . extendWith 1
419d417
<   translation v = Proj3 $ Mat3 (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
420d417
<   scaling     v = Proj3 $ diag (extendWith 1 v)
421d417
< 
422d417
< instance Projective Vec3 Mat3 Ortho3 Mat4 Proj4 where
423d417
<   fromProjective (Proj4 m) = m
424c418
<   toProjectiveUnsafe = Proj4
---
> instancelinear Projective= Proj3Vec2. extendWith Ortho21  Mat3 Proj3 where
424a419
>   fromProjectivetranslation v =(Proj3 m)Mat3= m (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
424a420
>   toProjectiveUnsafescaling     v = Proj3= Proj3$ diag (extendWith 1 v)
424a421
>   orthogonal = Proj3 . extendWith 1 . fromOrtho
424a422
> instance Projective= Proj3Vec3 extendWithMat3 Ortho3  Mat4 Proj4 where
424a423
>   translationfromProjective =(Proj3 $)Mat3= m (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
424a424
>   scalingtoProjectiveUnsafe = Proj3= Proj4 diag (extendWith 1 v)
426d425
<   linear     = Proj4 . extendWith 1
427d425
<   translation v = Proj4 $ Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
428d425
<   scaling     v = Proj4 $ diag (extendWith 1 v)
429d425
< 
430d425
< instance Matrix Proj3 where
431d425
<   idmtx = Proj3 idmtx
432c426
<   transpose (Proj3 m) = Proj3 (transpose m)
---
> instancelinear Projective= Proj4Vec3. extendWith Ortho31  Mat4 Proj4 where
432a427
>   fromProjectivetranslation v =(Proj4 m)Mat4= m (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
432a428
>   toProjectiveUnsafescaling     v = Proj4= Proj4$ diag (extendWith 1 v)
432a429
>   orthogonal = Proj4 . extendWith 1 . fromOrtho
432a430
> instance Matrix= Proj4Proj3.where 1
432a431
>   translationidmtx = Proj3 =idmtx $ Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
432a432
>   scalingtranspose (Proj3 = Proj4m) = $Proj3((transposeextendWithm)1 v)
434d433
< 
435d433
< instance Matrix Proj4 where
436d433
<   idmtx = Proj4 idmtx
437c434
<   transpose (Proj4 m) = Proj4 (transpose m)
---
> instance Matrix Proj3 where
437a435
> instance =Matrix idmtx where
437a436
>   transposeidmtx = Proj4Proj3idmtx) = Proj3 (transpose m)
437a437
>   inversetranspose= _invertProj3(Proj4 m) = Proj4 (transpose m)
439d438
< 
440d438
< _invertProj3 :: Proj3 -> Proj3
441d438
< _invertProj3 (Proj3 mat@(Mat3 _ _ t)) =
442c439
<   Proj3 $ Mat3 (extendZero a) (extendZero b) (extendWith 1 t')
---
> instance Matrix Proj4 where
442a440
> _invertProj3 = Proj4:: idmtx -> Proj3
442a441
> _invertProj3 (Proj4(Proj3m)mat=@Proj4(Mat3 (transpose_ t)) =  m)
442a442
>   inverseProj3 $ =Mat3(extendZero a) (extendZero b) (extendWith 1 t')
444d443
<     t' = neg $ (trim t :: Vec2) .* invm2
445d443
<     invm2@(Mat2 a b) = inverse $ (trim mat :: Mat2)
446d443
< 
447d443
< -- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.
448d443
< -- We assume that the bottom-right corner is 1.
449c444
< _invertProj4 :: Proj4 -> Proj4
---
> _invertProj3t' = neg ::$ (Proj3trim t->::Proj3Vec2) .* invm2
449a445
> _invertProj3invm2@(Mat2Proj3a b)mat= @inverse(Mat3 _$_(ttrim)) =mat :: Mat2)
449a446
>   Proj3 $ Mat3 (extendZero a) (extendZero b) (extendWith 1 t')
449a447
> -- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.where
449a448
> -- We assume that the bottom-right corner is 1. = neg $ (trim t :: Vec2) .* invm2
449a449
> _invertProj4@(Mat2:: aProj4) =->Proj4 $ (trim mat :: Mat2)
450a451
> -- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.Proj4 $ Mat4 (extendZero a) (extendZero b) (extendZero c) (extendWith 1 t')
450a452
> -- We assume that the bottom-right corner is 1.where
450a453
> _invertProj4t' = neg ::$ (Proj4trim t->::Proj4Vec3) .* invm3
450a454
> _invertProj4invm3@(Mat3Proj4a b matc) @(Mat4inverse _$_(ttrim)) =mat :: Mat3)
452d455
<   where
453c456
<     t' = neg $ (trim t :: Vec3) .* invm3
---
> --------------------------------------------------------------------------------where
453a457
> -- Vec2 instances = neg $ (trim t :: Vec3) .* invm3
455d458
< 
456d458
< --------------------------------------------------------------------------------
457d458
< -- Vec2 instances
458d458
< 
460d459
<   _1 (Vec2 x _) = x
461c460
<   _2 (Vec2 _ y) = y
---
> --------------------------------------------------------------------------------_1 (Vec2 x _) = x
461a461
> -- Vec2 instances_2 (Vec2 _ y) = y
463d462
<   _4 _ = error "has only 2 coordinates"
464d462
< 
465d462
< instance AbelianGroup Vec2 where
466d462
<   (&+) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
467c463
<   (&-) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1-x2) (y1-y2)
---
> instance_4 _ = HasCoordinateserror "has only 2 coordinates" Float where
467a464
>   _1 (Vec2 x _) = x
467a465
> instance (Vec2AbelianGroup y) = y   Vec2 where
467a466
>   _3(&+_ =Vec2x1"has only 2 coordinates"y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
467a467
>   _4(&-_ =Vec2x1"has only 2 coordinates"y1) (Vec2 x2 y2) = Vec2 (x1-x2) (y1-y2)
469c469
<   zero = Vec2 0 0
---
> instancezero = AbelianGroupVec2 0 0     Vec2 where
469a470
>   (&+) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
469a471
> instance&-) (Vec2Vector y1Vec2) (Vec2wherex2 y2) = Vec2 (x1-x2) (y1-y2)
469a472
>   negscalarMulVec2sx(yVec2)   x y) = Vec2 (=*Vec2x) (s(-x) (-y)
469a473
>   zeromapVec= Vec2f 0Vec2   x y) = Vec2 (f x) (f y)
471d474
< instance Vector Vec2 where
472c475
<   scalarMul s (Vec2 x y) = Vec2 (s*x) (s*y)
---
> instance VectorDotProdVec2Vec2wherewhere
472a476
>   scalarMul(&.) (Vec2sx1Vec2y1) xVec2) =x2y2)(s*xx1)*(x2s*y)y1*y2
474d477
< 
475d477
< instance DotProd Vec2 where
476d477
<   (&.) (Vec2 x1 y1) (Vec2 x2 y2) = x1*x2 + y1*y2
477d477
< 
479d478
<   pointwise (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)
480c479
< 
---
> instancepointwise(Vec2Vec2x1 y1where) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)
480a480
>   (&.) (Vec2 x1 y1) (Vec2 x2 y2) = x1*x2 + y1*y2
481a482
> instancedet (Vec2x1 y1 ,Vec2Vec2wherex2 y2) = x1*y2 - x2*y1
481a483
>   pointwise (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)
481a484
> {-
481a485
> instance Show Vec2 where
481a486
>   show (Vec2 x y) = "( " ++ show x ++ " , " ++ show y ++ " )"
481a487
> -} Determinant (Vec2,Vec2) where
487d492
< -}
488d492
< 
489c493
< instance Random Vec2 where
---
> -}instance Random Vec2 where
493d496
<         (y,gen2) = randomR (b,d) gen1
494d496
<     in (Vec2 x y, gen2)
495d496
< 
496d496
< instance Storable Vec2 where
497d496
<   sizeOf    _ = 2 * sizeOf (undefined::Flt)
498c497
<   alignment _ = sizeOf (undefined::Flt)
---
> instance(Randomy,gen2)Vec2= randomRwhere (b,d) gen1
498a498
>   randomin (Vec2= randomRx y, gen2Vec2)  (-1) (-1),Vec2 1 1)
498a499
>   randomR (Vec2 a b, Vec2 c d) gen =
498a500
> instance (xStorable,gen1) =Vec2wherea,c) gen
498a501
>    sizeOf(y,gen2_ =)2=*randomRsizeOf (bundefined,d) gen1::Flt)
498a502
>       alignmentin (Vec2_x=y,sizeOf)(undefined::Flt)
500d503
<   peek q = do
501d503
<     let p = castPtr q :: Ptr Flt
502c504
<         k = sizeOf (undefined::Flt)
---
> instancepeek q Storable= do     Vec2 where
502a505
>   sizeOflet p = _castPtr= 2 * sizeOfq :: PtrundefinedFlt     ::Float)
502a506
>   alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
504d507
<     y <- peekByteOff p k
505d507
<     return (Vec2 x y)
506d507
< 
507d507
<   poke q (Vec2 x y) = do
508d507
<     let p = castPtr q :: Ptr Flt
509c508
<         k = sizeOf (undefined::Flt)
---
>   peeky <- =peekByteOff        p k
509a509
>     letreturn =(castPtrVec2 x yq :: Ptr Float
509a510
>         k = sizeOf (undefined::Float)
509a511
>   poke <-q peek(Vec2 x y) =pdo
509a512
>     ylet<-ppeekByteOff= castPtr qp:: Ptr Flt
509a513
>     returnk =(Vec2sizeOf y)undefined::Flt)
511d514
<     pokeByteOff p k y
512d514
< 
513d514
< instance Dimension Vec2 where dim _ = 2
514d514
< 
515c515
< --------------------------------------------------------------------------------
---
>   pokepokeByteOff (Vec2 xpy) = do
515a516
>     let p = castPtr q :: Ptr Float
515a517
> instancekDimension= sizeOf (Vec2undefinedwhere::dimFloat_ ) 2
515a518
>     poke        p   x
515a519
> -------------------------------------------------------------------------------- p k y
517c521
< 
---
> instance Dimension Vec2 where dim _ = 2
519d522
<   _1 (Mat2 x _) = x
520c523
<   _2 (Mat2 _ y) = y
---
> --------------------------------------------------------------------------------_1 (Mat2 x _) = x
520a524
> -- Mat2 instances_2 (Mat2 _ y) = y
522d525
<   _4 _ = error "has only 2 coordinates"
523d525
< 
524d525
< instance Matrix Mat2 where
525d525
<   transpose (Mat2 row1 row2) =
526c526
<     Mat2 (Vec2 (_1 row1) (_1 row2))
---
> instance_4 _ = HasCoordinateserror "has only 2 coordinates" Vec2 where
526a527
>   _1 (Mat2 x _) = x
526a528
> instance (Mat2Matrix y) =Mat2  where
526a529
>   _3transpose = error(Mat2row1 row2) =
526a530
>   _4Mat2 = error(Vec2 "has only 2 coordinates"(_1 row1) (_1 row2))
527a532
> instanceidmtx =MatrixMat2 (Mat2 where1 0) (Vec2 0 1)
527a533
>   transposeinverse (Mat2Mat2(Vec2arow2b) )Vec2=   c d)) =
527a534
>     Mat2 (Vec2 (_1d*rrow1) (-)*(_1)) row2(Vec2))(-c*r) (a*r))
527a535
>     where(Vec2r = 1.0_2/row1(a*) (_2b*row2c)  ))
529d536
<   inverse (Mat2 (Vec2 a b) (Vec2 c d)) =
530d536
<     Mat2 (Vec2 (d*r) (-b*r)) (Vec2 (-c*r) (a*r))
531d536
<     where r = 1.0 / (a*d - b*c)
532d536
< 
533d536
< instance AbelianGroup Mat2 where
534d536
<   (&+) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &+ s1) (r2 &+ s2)
535c537
<   (&-) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &- s1) (r2 &- s2)
---
> instanceAbelianGroupMat2 (Vec2 aMat2) (whereVec2 c d)) =
535a538
>   (&+) (Mat2Vec2r1(dr2*r)((Mat2-b*r)s1) (s2Vec2) = (Mat2-c*r)r1a*&+r))s1) (r2 &+ s2)
535a539
>   (&-where) (Mat2 =r1r2/ (aMat2*d -s1*cs2)) = Mat2 (r1 &- s1) (r2 &- s2)
537d540
<   zero = Mat2 zero zero
538d540
< 
539d540
< instance Vector Mat2 where
540d540
<   scalarMul s (Mat2 r1 r2) = Mat2 (g r1) (g r2) where g = scalarMul s
541c541
<   mapVec    f (Mat2 r1 r2) = Mat2 (g r1) (g r2) where g = mapVec f
---
> instancezero = AbelianGroupMat2 zero zero where
541a542
>   (&+) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &+ s1) (r2 &+ s2)
541a543
> instance&-) (Mat2Vector r2Mat2) (Mat2wheres1 s2) = Mat2 (r1 &- s1) (r2 &- s2)
541a544
>   negscalarMulMat2sr1(Mat2) r1 r2) = Mat2=(Mat2g r1)(neg(g r2))whereneg r2g ) scalarMul s
541a545
>   zeromapVec= Mat2f zero(Mat2zeror1 r2) = Mat2 (g r1) (g r2) where g = mapVec f
543d546
< instance MultSemiGroup Mat2 where
544d546
<   (.*.) (Mat2 r1 r2) n =
545c547
<     let (Mat2 c1 c2) = transpose n
---
> instance VectorMultSemiGroup whereMat2 where
545a548
>   scalarMul(.*.) (Mat2 (r1Mat2r2)r1n r2= ) = Mat2 (g r1) (g r2) where g = scalarMul s
545a549
>   mapVeclet (Mat2 (c1Mat2c2)r1= r2transpose) = Mat2n(g r1) (g r2) where g = mapVec f
546a551
> instance MultSemiGroup(Vec2 (r2 &.c1)where(r2 &. c2))
546a552
>   (one.*.) (idmtxMat2 r1 r2) n =
546a553
>     let (Mat2 c1 c2) = transpose n
546a554
> instancein Mat2RingVec2Mat2(r1 &. c1) (r1 &. c2))
548d555
<   one = idmtx
549d555
< 
550d555
< instance Ring Mat2
551d555
< 
552c556
< instance LeftModule Mat2 Vec2 where
---
> instance = idmtxLeftModule Mat2 Vec2 where
554c558
< 
---
> instance Ring Mat2
556d559
<   rmul v mt = lmul (transpose mt) v
557c560
< 
---
> instancermul v LeftModulemt = lmul (Mat2transpose wheremt) v
557a561
>   lmul (Mat2 row1 row2) v = Vec2 (row1 &. v) (row2 &. v)
559d562
<   diag (Vec2 x y) = Mat2 (Vec2 x 0) (Vec2 0 y)
560c563
< 
---
> instancediag (Vec2x y) = Mat2(Mat2 wherex 0) (Vec2 0 y)
560a564
>   rmul v mt = lmul (transpose mt) v
562d565
<   outer (Vec2 a b) (Vec2 x y) = Mat2
563c566
<     (Vec2 (a*x) (a*y))
---
> instanceouter (DiagonalVec2 a b)Vec2(Vec2x ywhere) = Mat2
563a567
>   diag(Vec2Vec2(a*x)y)a=yMat2))   (Vec2 x 0) (Vec2 0 y)
565d568
< 
566c569
< instance Determinant Mat2 where
---
> instance Tensor Mat2 Vec2 where
566a570
> instance (Vec2Determinant b) (Vec2Mat2xwhere) = Mat2
566a571
>   detVec2(Mat2a*xVec2) (a*y)) (Vec2 c d)) = a*d - b*c
566a572
>     (Vec2 (b*x) (b*y))
566a573
> {-
566a574
> instance Show Mat2 where
566a575
>   show (Mat2 r1 r2) = show r1 ++ "\n" ++ show r2
566a576
> -} Determinant Mat2 where
572d581
< -}
573d581
< 
574c582
< instance Storable Mat2 where
---
> -}instance Storable Mat2 where
578d585
<   peek q = do
579d585
<     let p = castPtr q :: Ptr Vec2
580c586
<         k = sizeOf (undefined::Vec2)
---
> instancepeek q Storable= do     Mat2 where
580a587
>   sizeOflet p = _castPtr= 2 * sizeOfq :: PtrundefinedVec2    ::Vec2)
580a588
>   alignmentk = _sizeOf= alignment(undefinedundefined::Vec2) ::Vec2)
582d589
<     r2 <- peekByteOff p k
583d589
<     return (Mat2 r1 r2)
584d589
< 
585d589
<   poke q (Mat2 r1 r2) = do
586c590
<     let p = castPtr q :: Ptr Vec2
---
>   peekr2 q<-=peekByteOff         p k
586a591
>     letreturn =(castPtrMat2 r1 qr2::)  Ptr Vec2
587a593
>   poke <-q (peek r1 r2) p do
587a594
>     r2let<-p peekByteOff= castPtr q p::kPtr Vec2
587a595
>     returnk =(Mat2sizeOf(r2undefined)      ::Vec2)
589d596
<     pokeByteOff p k r2
590d596
< 
591d596
< instance Random Mat2 where
592d596
<   random = randomR (Mat2 v1 v1 , Mat2 v2 v2) where
593c597
<     v1 = Vec2 (-1) (-1)
---
>   pokepokeByteOff (Mat2 r1p r2k )r2= do
593a598
>     let p = castPtr q :: Ptr Vec2
593a599
> instancekRandom= sizeOfMat2undefinedwhere   ::Vec2)
593a600
>   random = randomR  (r1Mat2 v1 v1 , Mat2 v2 v2) where
593a601
>     pokeByteOffv1 = Vec2 (-p)k(r2-1)
594a603
> instancerandomRRandom(Mat2 Mat2a b, whereMat2 c d) gen =
594a604
>   randomlet (=,randomRgen1) = (randomRMat2 v1(v1a,c, Mat2gen  v2 v2) where
594a605
>     v1 =(Vec2y,gen2-1) (randomR-1)    (b,d) gen1
594a606
>     v2 =Mat2x y1 gen2)
596d607
<     let (x,gen1) = randomR (a,c) gen
597d607
<         (y,gen2) = randomR (b,d) gen1
598d607
<     in (Mat2 x y, gen2)
599d607
< 
600d607
< instance Dimension Mat2 where dim _ = 2
601d607
< 
602c608
< instance MatrixNorms Mat2 where
---
> instance (xDimension,gen1) = randomRMat2 wherea,cdim) gen_ = 2
602a609
>          (y,gen2) = randomR (b,d) gen1
602a610
>     instancein (Mat2MatrixNorms y, gen2Mat2)   where
604c612
<     sqrt $
---
> instancesqrt Dimension$         Mat2 where dim _ = 2
605a614
> instancenormsqrr2     Mat2 where
605a615
>   frobeniusNorm (Mat2 r1 r2) =
605a616
> instance $Pointwise Mat2 where
605a617
>   pointwise(Mat2 +x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)
607d618
< 
608d618
< instance Pointwise Mat2 where
609d618
<   pointwise (Mat2 x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)
610d618
< 
612d619
< -- Vec3 instances
613c620
< 
---
> instance-- Vec3 instances Mat2 where
613a621
>   pointwise (Mat2 x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)
615d622
<   _1 (Vec3 x _ _) = x
616c623
<   _2 (Vec3 _ y _) = y
---
> --------------------------------------------------------------------------------_1 (Vec3 x _ _) = x
616a624
> -- Vec3 instances_2 (Vec3 _ y _) = y
618d625
<   _4 _ = error "has only 3 coordinates"
619d625
< 
620d625
< instance AbelianGroup Vec3 where
621d625
<   (&+) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
622c626
<   (&-) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
---
> instance_4 _ = HasCoordinateserror "has only 3 coordinates" Float where
622a627
>   _1 (Vec3 x _ _) = x
622a628
> instance (Vec3AbelianGroup y _) = y Vec3 where
622a629
>   _3(&+(Vec3(Vec3 _x1z)y1=z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
622a630
>   _4(&-_ =Vec3x1"has only 3 coordinates"y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
624c632
<   zero = Vec3 0 0 0
---
> instancezero = AbelianGroupVec3 0 0 0   Vec3 where
624a633
>   (&+) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
624a634
> instance&-) (Vec3Vector y1Vec3)whereVec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
624a635
>   negscalarMulVec3sx(yVec3) x y z) = Vec3 (s*x)=(Vec3s*y) (-x))(-y) (-z)
624a636
>   zeromapVec= Vec3f 0Vec3 0 x y z) = Vec3 (f x) (f y) (f z)
626d637
< instance Vector Vec3 where
627c638
<   scalarMul s (Vec3 x y z) = Vec3 (s*x) (s*y) (s*z)
---
> instance VectorDotProdVec3Vec3wherewhere
627a639
>   scalarMul(&.) (Vec3sx1Vec3y1 z1)y(zVec3) = Vec3x2 y2(sz2*x)=(sx1*y)x2(s*zy1)*y2 + z1*z2
629d640
< 
630d640
< instance DotProd Vec3 where
631d640
<   (&.) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = x1*x2 + y1*y2 + z1*z2
632d640
< 
633a642
> instancepointwise(Vec3Vec3x1 y1wherez1) (Vec3 x2 y2 z2) = Vec3 (x1*x2) (y1*y2) (z1*z2)
633a643
>   (&.) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = x1*x2 + y1*y2 + z1*z2
633a644
> {-
633a645
> instance Show Vec3 where
633a646
>   show (Vec3 x y z) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " )"
633a647
> -} Pointwise Vec3 where
639d652
< -}
640d652
< 
641c653
< instance Random Vec3 where
---
> -}instance Random Vec3 where
645d656
<         (y,gen2) = randomR (b,e) gen1
646c657
<         (z,gen3) = randomR (c,f) gen2
---
> instance(Randomy,gen2)Vec3= randomRwhere (b,e) gen1
646a658
>   random(=,randomRgen3) = (randomRVec3 (-1),(-1)gen2-1),Vec3 1 1 1)
646a659
>   randomRin (Vec3Vec3x yazb cgen3, Vec3)   d e f) gen =
646a660
>     let (x,gen1) = randomR (a,d) gen
646a661
> instance(yCrossProd,gen2) = randomRVec3 whereb,e) gen1
646a662
>   crossprodz,gen3(Vec3) =x1y1 z1)(c,Vec3f) gen2x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)
648d663
< 
649d663
< instance CrossProd Vec3 where
650d663
<   crossprod (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)
651d663
< 
653d664
<   det (u,v,w) = u &. (v &^ w)
654c665
< 
---
> instancedet (u,CrossProdv,w) = u &.(v where&^ w)
654a666
>   crossprod (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)
656d667
<   sizeOf    _ = 3 * sizeOf (undefined::Flt)
657c668
<   alignment _ = sizeOf (undefined::Flt)
---
> instancesizeOf Determinant_ = 3 * sizeOfVec3,Vec3(undefined,Vec3)::whereFlt)
657a669
>   detalignmentu,v,w) = usizeOf (v(&^undefined)    ::Flt)
659d670
<   peek q = do
660d670
<     let p = castPtr q :: Ptr Flt
661c671
<         k = sizeOf (undefined::Flt)
---
> instancepeek q Storable= do     Vec3 where
661a672
>   sizeOflet p = _castPtr= 3 * sizeOfq :: PtrundefinedFlt     ::Float)
661a673
>   alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
663d674
<     y <- peekByteOff p (k  )
664d674
<     z <- peekByteOff p (k+k)
665d674
<     return (Vec3 x y z)
666d674
< 
667d674
<   poke q (Vec3 x y z) = do
668d674
<     let p = castPtr q :: Ptr Flt
669c675
<         k = sizeOf (undefined::Flt)
---
>   peeky <- =peekByteOff        p (k  )
669a676
>     letz <-ppeekByteOff= castPtr qp::(kPtr+k) Float
669a677
>     return =(sizeOfVec3 x (undefinedz)      ::Float)
669a678
>     x <- peek        p
669a679
>   poke <-q peekByteOff(Vec3 x y z)p=(kdo )
669a680
>     zlet<-ppeekByteOff= castPtr qp::k+Ptrk) Flt
669a681
>     returnk =(Vec3sizeOf yundefined)      ::Flt)
670a683
>   pokepokeByteOff (Vec3 xpy(z) = doy
670a684
>     letpokeByteOff = castPtrp (kqk::) zPtr Float
670a685
>         k = sizeOf (undefined::Float)
670a686
> instance Dimension  Vec3 xwhere dim _ = 3
672d687
<     pokeByteOff p (k+k) z
673d687
< 
674d687
< instance Dimension Vec3 where dim _ = 3
675d687
< 
676c688
< --------------------------------------------------------------------------------
---
> -------------------------------------------------------------------------------- p (k+k) z
678c690
< 
---
> instance Dimension Vec3 where dim _ = 3
679a692
> --------------------------------------------------------------------------------_1 (Mat3 x _ _) = x
679a693
> -- Mat3 instances_2 (Mat3 _ y _) = y
679a694
>   _3 (Mat3 _ _ z) = z
679a695
> instance_4 _ = HasCoordinateserror "has only 3 coordinates" Vec3 where
681c697
<   _2 (Mat3 _ y _) = y
---
> instance (Mat3Matrix y _)Mat3= ywhere
683d698
<   _4 _ = error "has only 3 coordinates"
684d698
< 
685d698
< instance Matrix Mat3 where
686d698
< 
687c699
<   transpose (Mat3 row1 row2 row3) =
---
>   _4transpose = error(Mat3row1 row2 row3) =
689c701
<          (Vec3 (_2 row1) (_2 row2) (_2 row3))
---
> instance Matrix(Vec3 (Mat3_2 row1where) (_2 row2) (_2 row3))
691d702
< 
692d702
<   idmtx = Mat3 (Vec3 1 0 0) (Vec3 0 1 0) (Vec3 0 0 1)
693d702
< 
694c703
<   inverse (Mat3 (Vec3 a b c) (Vec3 e f g) (Vec3 i j k)) =
---
>   transpose (Mat3 row1 row2 row3) =
694a704
>   idmtx=(Vec3 (_1Vec31 ) (_1) (row2)0(_11 0row3) (Vec3))  0 0 1)
694a705
>          (Vec3 (_2 row1) (_2 row2) (_2 row3))
694a706
>   inverse(Vec3(Mat3(_3(Vec3a)b(_3c) row2(Vec3) (_3f row3g) ()Vec3)   i j k)) =
696c708
<          (Vec3 (d12*r) (d22*r) (d32*r))
---
>   idmtx =(Mat3 (Vec3d12*r1 0d22)*(Vec3) (d32*1)0) (Vec3 0 0 1)
698d709
<     where
699c710
<       r = 1.0 / ( a*d11 + b*d12 + c*d13 )
---
>   inversewhere (Mat3 (Vec3 a b c) (Vec3 e f g) (Vec3 i j k)) =
699a711
>     Mat3r =(Vec31.0 /(d11( a*rd11) (d21+ b*rd12) (d31+ c*rd13)) )
699a712
>          (Vec3 (d12*r) (d22*r) (d32*r))
699a713
>       d11(Vec3= f*k(d13- g*r) (d23*r) (d33*r))
699a714
>     whered12 = g*i - e*k
699a715
>       rd13= 1.0= e*/ ( a*d11i   + b*d12 + c*d13 )
709d724
<       d21 = c*j - b*k
710d724
<       d22 = a*k - c*i
711d724
<       d23 = b*i - a*j
712d724
< 
713d724
< instance AbelianGroup Mat3 where
714d724
<   (&+) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
715c725
<   (&-) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
---
> instanceAbelianGroup= c*j - b*k Mat3 where
715a726
>   (&+)d22(Mat3= a*r1k -r2c*r3i) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
715a727
>   (&-)d23(Mat3= b*r1i -r2a*r3j) (Mat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
717d728
<   zero = Mat3 zero zero zero
718d728
< 
719d728
< instance Vector Mat3 where
720d728
<   scalarMul s (Mat3 r1 r2 r3) = Mat3 (g r1) (g r2) (g r3) where g = scalarMul s
721c729
<   mapVec    f (Mat3 r1 r2 r3) = Mat3 (g r1) (g r2) (g r3) where g = mapVec f
---
> instancezero = AbelianGroupMat3 zero zerozerowhere
721a730
>   (&+) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
721a731
> instance&-) (Mat3Vector r2Mat3)whereMat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
721a732
>   negscalarMulMat3sr1(Mat3 r3r1) r2 r3) = Mat3 (g=r1) (g(negr2) r1(g)r3neg) where) ( neg= scalarMul)      s
721a733
>   zeromapVec= Mat3f zero(Mat3zeror1 r2r3) = Mat3 (g r1) (g r2) (g r3) where g = mapVec f
723d734
< instance MultSemiGroup Mat3 where
724d734
<   (.*.) (Mat3 r1 r2 r3) n =
725c735
<     let (Mat3 c1 c2 c3) = transpose n
---
> instance VectorMultSemiGroup whereMat3 where
725a736
>   scalarMul(.*.) (Mat3 (r1Mat3r2 r1)r2n r3= ) = Mat3 (g r1) (g r2) (g r3) where g = scalarMul s
725a737
>   mapVeclet (Mat3 (c1Mat3c2 r1)r2= r3transpose) = Mat3n(g r1) (g r2) (g r3) where g = mapVec f
727d738
<             (Vec3 (r2 &. c1) (r2 &. c2) (r2 &. c3))
728d738
<             (Vec3 (r3 &. c1) (r3 &. c2) (r3 &. c3))
729d738
<   one = idmtx
730d738
< 
731d738
< instance Ring Mat3
732d738
< 
733c739
< instance LeftModule Mat3 Vec3 where
---
> instance MultSemiGroup(Vec3 (r2 &.c1)where(r2 &. c2) (r2 &. c3))
733a740
>   (.*.) (Mat3(Vec3 r2(r3)&.nc1=) (r3 &. c2) (r3 &. c3))
733a741
>   one= (idmtxMat3 c1 c2 c3) = transpose n
733a742
>      in Mat3 (Vec3 (r1 &. c1) (r1 &. c2) (r1 &. c3))
733a743
>  instance RingVec3Mat3(r2 &. c1) (r2 &. c2) (r2 &. c3))
733a744
>              (Vec3 (r3 &. c1) (r3 &. c2) (r3 &. c3))
733a745
> instance = idmtxLeftModule Mat3 Vec3 where
735c747
< 
---
> instance Ring Mat3
737d748
<   rmul v mt = lmul (transpose mt) v
738c749
< 
---
> instancermul v LeftModulemt = lmul (Mat3transpose wheremt) v
738a750
>   lmul (Mat3 row1 row2 row3) v = Vec3 (row1 &. v) (row2 &. v) (row3 &. v)
740d751
<   diag (Vec3 x y z) = Mat3 (Vec3 x 0 0) (Vec3 0 y 0) (Vec3 0 0 z)
741c752
< 
---
> instancediag (Vec3x y z) =Vec3Mat3Mat3(Vec3wherex 0 0) (Vec3 0 y 0) (Vec3 0 0 z)
741a753
>   rmul v mt = lmul (transpose mt) v
743d754
<   outer (Vec3 a b c) (Vec3 x y z) = Mat3
744c755
<     (Vec3 (a*x) (a*y) (a*z))
---
> instanceouter (DiagonalVec3 a b Vec3c) (Vec3xwherey z) = Mat3
744a756
>   diag(Vec3Vec3(a*x)y(z)y= Mat3(a*z)(Vec3 x 0 0) (Vec3 0 y 0) (Vec3 0 0 z)
745a758
> instance(Vec3Tensor(c*x) Mat3(c*y)Vec3(c*zwhere))
745a759
>   outer (Vec3 a b c) (Vec3 x y z) = Mat3
745a760
> instanceVec3Determinanta*x) (a*y)Mat3a*z)where)
745a761
>   detVec3(Mat3b*r1x)r2b*r3y) (b*detz))(r1,r2,r3)
747d762
< 
748c763
< instance Determinant Mat3 where
---
> {-
748a764
> instance Show Mat3 where
748a765
>   show (Mat3 r1 r2 r3) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3
748a766
> -} Determinant Mat3 where
754d771
< -}
755d771
< 
756c772
< instance Storable Mat3 where
---
> -}instance Storable Mat3 where
760d775
<   peek q = do
761d775
<     let p = castPtr q :: Ptr Vec3
762c776
<         k = sizeOf (undefined::Vec3)
---
> instancepeek q Storable= do     Mat3 where
762a777
>   sizeOflet p = _castPtr= 3 * sizeOfq :: PtrundefinedVec3    ::Vec3)
762a778
>   alignmentk = _sizeOf= alignment(undefinedundefined::Vec3) ::Vec3)
764d779
<     r2 <- peekByteOff p (k  )
765d779
<     r3 <- peekByteOff p (k+k)
766d779
<     return (Mat3 r1 r2 r3)
767d779
< 
768d779
<   poke q (Mat3 r1 r2 r3) = do
769d779
<     let p = castPtr q :: Ptr Vec3
770c780
<         k = sizeOf (undefined::Vec3)
---
>   peekr2 q<-=peekByteOff         p (k  )
770a781
>     letr3 <- =peekByteOff q ::p (Ptrk+k)Vec3
770a782
>     return =(sizeOfMat3 r1(undefinedr2 r3)   ::Vec3)
770a783
>     r1 <- peek        p
770a784
>   poke <-q (peekByteOffMat3 r1 r2 r3)(k do)
770a785
>     r3let<-p peekByteOff= castPtr q p::(kPtr+k)Vec3
770a786
>     returnk =(Mat3sizeOf(r2undefined)   ::Vec3)
772d787
<     pokeByteOff p (k  ) r2
773d787
<     pokeByteOff p (k+k) r3
774d787
< 
775d787
< instance Random Mat3 where
776d787
<   random = randomR (Mat3 v1 v1 v1 , Mat3 v2 v2 v2) where
777c788
<     v1 = Vec3 (-1) (-1) (-1)
---
>   pokepokeByteOff (Mat3 r1p r2(k r3))r2= do
777a789
>     letpokeByteOff = castPtrp (kqk::) r3 Vec3
777a790
>         k = sizeOf (undefined::Vec3)
777a791
> instance Random pMat3 where
777a792
>   random= randomR (kMat3) r2v1 v1 v1 , Mat3 v2 v2 v2) where
777a793
>     pokeByteOffv1 = Vec3 (-p)(k+k) r3(-1)
779c795
<   randomR (Mat3 a b c, Mat3 d e f) gen =
---
> instancerandomRRandom(Mat3 Mat3a b cwhere, Mat3 d e f) gen =
779a796
>   randomlet (=,randomRgen1) = (randomRMat3 v1(v1a,dv1) gen, Mat3 v2 v2 v2) where
779a797
>     v1 =(Vec3y,gen2-1) (randomR-1) (-1)b,e) gen1
779a798
>     v2 =(Vec3z,gen3)1= randomR    1(c,f) gen2
779a799
>   randomRin (Mat3Mat3x yazb cgen3, Mat3)   d e f) gen =
781c801
<         (y,gen2) = randomR (b,e) gen1
---
> instance(yDimension,gen2) = randomRMat3 whereb,edim) gen1_ = 3
783d802
<     in (Mat3 x y z, gen3)
784d802
< 
785d802
< instance Dimension Mat3 where dim _ = 3
786d802
< 
787c803
< instance MatrixNorms Mat3 where
---
> instancein (Mat3MatrixNorms y z, gen3Mat3) where
789c805
<     sqrt $
---
> instancesqrt Dimension$         Mat3 where dim _ = 3
791c807
<       normsqr r2 +
---
> instancenormsqrr2 +   Mat3 where
791a808
>   frobeniusNormnormsqr r3(Mat3 r1 r2 r3)  =
791a809
>     sqrt $
791a810
> instancePointwise + Mat3 where
791a811
>   pointwise(Mat3 +x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)
793d812
< 
794d812
< instance Pointwise Mat3 where
795d812
<   pointwise (Mat3 x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)
796d812
< 
798d813
< -- Vec4 instances
799c814
< 
---
> instance-- Vec4 instances Mat3 where
799a815
>   pointwise (Mat3 x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)
801d816
<   _1 (Vec4 x _ _ _) = x
802c817
<   _2 (Vec4 _ y _ _) = y
---
> --------------------------------------------------------------------------------_1 (Vec4 x _ _ _) = x
802a818
> -- Vec4 instances_2 (Vec4 _ y _ _) = y
804d819
<   _4 (Vec4 _ _ _ w) = w
805d819
< 
806d819
< instance AbelianGroup Vec4 where
807d819
<   (&+) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
808c820
<   (&-) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
---
> instance_4 (Vec4_ _ _ w) = w Vec4 Float where
808a821
>   _1 (Vec4 x _ _ _) = x
808a822
> instance (Vec4AbelianGroup y _ _) = yVec4 where
808a823
>   _3(&+(Vec4(Vec4 _x1zy1)z1= zw1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
808a824
>   _4(&-(Vec4(Vec4 _x1_y1)z1= ww1) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
810c826
<   zero = Vec4 0 0 0 0
---
> instancezero = AbelianGroupVec4 0 0 0 0 Vec4 where
810a827
>   (&+) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
810a828
> instance&-) (Vec4Vector y1Vec4where) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
810a829
>   negscalarMulVec4sx(yVec4 w) y z w) = Vec4 (s*x) (s*=)Vec4(s*z(-x)*(-y) (-z) (-w)
810a830
>   zeromapVec= Vec4f 0Vec4 0 0 y z w) = Vec4 (f x) (f y) (f z) (f w)
812d831
< instance Vector Vec4 where
813c832
<   scalarMul s (Vec4 x y z w) = Vec4 (s*x) (s*y) (s*z) (s*w)
---
> instance VectorDotProdVec4Vec4wherewhere
813a833
>   scalarMul(&.) (Vec4sx1Vec4y1 z1 yw1z w)Vec4= Vec4x2 y2s*z2x)w2s*y)x1s*x2z)+(sy1*w)y2 + z1*z2 + w1*w2
815d834
< 
816d834
< instance DotProd Vec4 where
817d834
<   (&.) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = x1*x2 + y1*y2 + z1*z2 + w1*w2
818d834
< 
819a836
> instancepointwise(Vec4Vec4x1 y1wherez1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1*x2) (y1*y2) (z1*z2) (w1*w2)
819a837
>   (&.) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = x1*x2 + y1*y2 + z1*z2 + w1*w2
819a838
> {-
819a839
> instance Show Vec4 where
819a840
>   show (Vec4 x y z w) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " , " ++ show w ++ " )"
819a841
> -} Pointwise Vec4 where
825d846
< -}
826d846
< 
827c847
< instance Random Vec4 where
---
> -}instance Random Vec4 where
830a851
> instance(Randomy,gen2)Vec4= randomRwhere (b,f) gen1
830a852
>   random(=,randomRgen3) = (randomRVec4 (-1),(-1)gen2-1) (-1),Vec4 1 1 1 1)
830a853
>   randomR(w(Vec4)a=brandomR d, Vec4(d,e)fgen3 h) gen =
830a854
>     letin ((Vec4x,gen1x ) = randomRw, gen4)(a,e) gen
832d855
<         (z,gen3) = randomR (c,g) gen2
833d855
<         (w,gen4) = randomR (d,h) gen3
834d855
<     in (Vec4 x y z w, gen4)
835d855
< 
836d855
< instance Storable Vec4 where
837d855
<   sizeOf    _ = 4 * sizeOf (undefined::Flt)
838c856
<   alignment _ = sizeOf (undefined::Flt)
---
> instance(zStorable,gen3) =Vec4wherec,g) gen2
838a857
>   sizeOf(w,gen4_ =)4=*randomRsizeOf (dundefined,h) gen3::Flt)
838a858
>   alignmentin (Vec4_x=ysizeOf w, gen4(undefined)      ::Flt)
840d859
<   peek q = do
841d859
<     let p = castPtr q :: Ptr Flt
842c860
<         k = sizeOf (undefined::Flt)
---
> instancepeek q Storable= do     Vec4 where
842a861
>   sizeOflet p = _castPtr= 4 * sizeOfq :: PtrundefinedFlt     ::Float)
842a862
>   alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
843a864
>   peeky <- =peekByteOff        p (k  )
843a865
>     letz <-ppeekByteOff= castPtr qp::(kPtr+k) Float
843a866
>     w <-kpeekByteOff= sizeOf (undefinedp (3*k) ::Float)
843a867
>     xreturn<- peek(Vec4 x y p w)
845d868
<     z <- peekByteOff p (k+k)
846d868
<     w <- peekByteOff p (3*k)
847d868
<     return (Vec4 x y z w)
848d868
< 
849d868
<   poke q (Vec4 x y z w) = do
850d868
<     let p = castPtr q :: Ptr Flt
851c869
<         k = sizeOf (undefined::Flt)
---
>   poke <-q peekByteOff(Vec4 x y z p)(k+kdo)
851a870
>     wlet<-ppeekByteOff= castPtr qp::3*Ptrk) Flt
851a871
>     returnk =(Vec4sizeOf yundefined w)    ::Flt)
853c873
<     pokeByteOff p (k  ) y
---
>   pokepokeByteOff (Vec4 xpy(z w) = do
853a874
>     letpokeByteOff = castPtrp (kqk::) zPtr Float
853a875
>     pokeByteOff = sizeOfp ((undefined*k) w    ::Float)
853a876
>     poke        p       x
853a877
> instanceDimension (kVec4) ywhere dim _ = 4
855d878
<     pokeByteOff p (3*k) w
856d878
< 
857d878
< instance Dimension Vec4 where dim _ = 4
858d878
< 
859c879
< --------------------------------------------------------------------------------
---
> -------------------------------------------------------------------------------- p (3*k) w
861c881
< 
---
> instance Dimension Vec4 where dim _ = 4
863d882
<   _1 (Mat4 x _ _ _) = x
864c883
<   _2 (Mat4 _ y _ _) = y
---
> --------------------------------------------------------------------------------_1 (Mat4 x _ _ _) = x
864a884
> -- Mat4 instances_2 (Mat4 _ y _ _) = y
866d885
<   _4 (Mat4 _ _ _ w) = w
867d885
< 
868d885
< instance Matrix Mat4 where
869d885
<   transpose (Mat4 row1 row2 row3 row4) =
870c886
<     Mat4 (Vec4 (_1 row1) (_1 row2) (_1 row3) (_1 row4))
---
> instance_4 (Mat4_ _ _ w) = w Mat4 Vec4 where
870a887
>   _1 (Mat4 x _ _ _) = x
870a888
> instance (Mat4Matrix y _Mat4) =where
870a889
>   _3transposeMat4 _(_Mat4 _)row1= zrow2 row3 row4) =
870a890
>   _4Mat4Mat4(Vec4 _ __1)row1= w) (_1 row2) (_1 row3) (_1 row4))
871a892
> instance Matrix(Vec4 (Mat4_3 row1where) (_3 row2) (_3 row3) (_3 row4))
871a893
>   transpose(Vec4Mat4(_4row1row1row2) (_4row3row2row4) (_4) =row3) (_4 row4))
871a894
>   idmtx=(Vec4 (_1Vec41 ) (_10)row2(Vec4) (_10 1row30 0) (_1Vec40 ))1 0) (Vec4 0 0 0 1)
871a895
>   inverse(Vec4= error_2"inverse/Mat4: not implemented yet") (_2 row2) (_2 row3) (_2 row4))
873d896
<          (Vec4 (_4 row1) (_4 row2) (_4 row3) (_4 row4))
874d896
<   idmtx = Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (Vec4 0 0 0 1)
875d896
<   inverse = error "inverse/Mat4: not implemented yet"
876d896
< 
877d896
< instance AbelianGroup Mat4 where
878d896
<   (&+) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3) (r4 &+ s4)
879c897
<   (&-) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
---
> instance (AbelianGroupVec4 (_4 row1Mat4) (_4where) (_4 row3) (_4 row4))
879a898
>   idmtx(&+) (=Mat4r1(Vec4r2 r31r4)0(0Mat4) (Vec4s1 s2 1s30s4) (Vec4Mat40(0r11&+)s1Vec4) (r20&+ 0s21)(r3 &+ s3) (r4 &+ s4)
879a899
>   inverse(&-) (Mat4= errorr1 r2"inverse/Mat4: not implemented yet"r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
881d900
<   zero = Mat4 zero zero zero zero
882d900
< 
883d900
< instance Vector Mat4 where
884d900
<   scalarMul s (Mat4 r1 r2 r3 r4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = scalarMul s
885c901
<   mapVec    f (Mat4 r1 r2 r3 r4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = mapVec f
---
> instancezero = AbelianGroupMat4 zero zerozerowherezero
885a902
>   (&+) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3) (r4 &+ s4)
885a903
> instance&-) (Mat4Vector r2Mat4where) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
885a904
>   negscalarMulMat4sr1(Mat4 r3r1r4r2) r3 r4) = Mat4 (g r1= Mat4(g r2(neg(g r1) (negg r4r2) )whereneggr3=)scalarMulneg r4) s
885a905
>   zeromapVec= Mat4f zero(Mat4zeror1 r2r3 zeror4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = mapVec f
887d906
< instance MultSemiGroup Mat4 where
888d906
<   (.*.) (Mat4 r1 r2 r3 r4) n =
889c907
<     let (Mat4 c1 c2 c3 c4) = transpose n
---
> instance VectorMultSemiGroup whereMat4 where
889a908
>   scalarMul(.*.) (Mat4 (r1Mat4r2 r1 r2)r3n r4= ) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = scalarMul s
889a909
>   mapVeclet (Mat4 (c1Mat4c2 r1 r2)r3= r4transpose) = Mat4n(g r1) (g r2) (g r3) (g r4) where g = mapVec f
890a911
> instance MultSemiGroup(Vec4 (r2 &.c1)where(r2 &. c2) (r2 &. c3) (r2 &. c4))
890a912
>   (.*.) (Mat4(Vec4 r2(r3&.)c1n =r3 &. c2) (r3 &. c3) (r3 &. c4))
890a913
>     let (Mat4(Vec4 c2(r4&.)c1= transpose(r4 &. c2)n(r4 &. c3) (r4 &. c4))
890a914
>   onein=Mat4idmtxVec4 (r1 &. c1) (r1 &. c2) (r1 &. c3) (r1 &. c4))
892c916
<             (Vec4 (r3 &. c1) (r3 &. c2) (r3 &. c3) (r3 &. c4))
---
> instance RingVec4Mat4(r3 &. c1) (r3 &. c2) (r3 &. c3) (r3 &. c4))
894d917
<   one = idmtx
895d917
< 
896d917
< instance Ring Mat4
897d917
< 
898c918
< instance LeftModule Mat4 Vec4 where
---
> instance = idmtxLeftModule Mat4 Vec4 where
900c920
< 
---
> instance Ring Mat4
902d921
<   rmul v mt = lmul (transpose mt) v
903c922
< 
---
> instancermul v LeftModulemt = lmul (Mat4transpose wheremt) v
903a923
>   lmul (Mat4 row1 row2 row3 row4) v = Vec4 (row1 &. v) (row2 &. v) (row3 &. v) (row4 &. v)
905d924
<   diag (Vec4 x y z w) = Mat4 (Vec4 x 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)
906c925
< 
---
> instancediag (Vec4x y z w)Vec4= Mat4(Vec4wherex 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)
906a926
>   rmul v mt = lmul (transpose mt) v
908d927
<   outer (Vec4 a b c d) (Vec4 x y z w) = Mat4
909c928
<     (Vec4 (a*x) (a*y) (a*z) (a*w))
---
> instanceouter (DiagonalVec4 a b Vec4c d) Mat4(Vec4wherex y z w) = Mat4
909a929
>   diag(Vec4Vec4(a*x)y(z*w) =aMat4*z) ((Vec4*w)) x 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)
911d930
<     (Vec4 (c*x) (c*y) (c*z) (c*w))
912c931
<     (Vec4 (d*x) (d*y) (d*z) (d*w))
---
> instance(Vec4Tensor(c*x) Mat4(c*y)Vec4(c*zwhere) (c*w))
912a932
>   outer(Vec4Vec4(d*xa bdcyd)((Vec4*z) (x*y)z w) = Mat4
912a933
>     (Vec4 (a*x) (a*y) (a*z) (a*w))
912a934
> instanceVec4Determinantb*x) (b*y)Mat4b*z)whereb*w))
912a935
>   detVec4= errorc*x)"det/Mat4: not implemented yet"c*y) (c*z) (c*w))
912a936
>   -- det (Mat4 r1 r2 r3 r4) =Vec4 (d*x) (d*y) (d*z) (d*w))
914c938
< instance Determinant Mat4 where
---
> instance{-
914a939
> instance Show Mat4 where
914a940
>   show (Mat4 r1 r2 r3 r4) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3 ++ "\n" ++ show r4
914a941
> -}        Mat4 where
921d947
< -}
922d947
< 
923c948
< instance Storable Mat4 where
---
> -}instance Storable Mat4 where
927d951
<   peek q = do
928d951
<     let p = castPtr q :: Ptr Vec4
929c952
<         k = sizeOf (undefined::Vec4)
---
> instancepeek q Storable= do     Mat4 where
929a953
>   sizeOflet p = _castPtr= 4 * sizeOfq :: PtrundefinedVec4    ::Vec4)
929a954
>   alignmentk = _sizeOf= alignment(undefinedundefined::Vec4) ::Vec4)
930a956
>   peekr2 q<-=peekByteOff         p (k  )
930a957
>     letr3 <- =peekByteOff q ::p (Ptrk+k)Vec4
930a958
>     r4 <- =peekByteOff (undefinedp (3*k)::Vec4)
930a959
>     r1return<- peek(Mat4 r1 r2pr3 r4)
932d960
<     r3 <- peekByteOff p (k+k)
933d960
<     r4 <- peekByteOff p (3*k)
934d960
<     return (Mat4 r1 r2 r3 r4)
935d960
< 
936d960
<   poke q (Mat4 r1 r2 r3 r4) = do
937d960
<     let p = castPtr q :: Ptr Vec4
938c961
<         k = sizeOf (undefined::Vec4)
---
>   poke <-q (peekByteOffMat4 r1 r2 r3 (r4k+k) do
938a962
>     r4let<-p peekByteOff= castPtr q p::(3Ptr*k)Vec4
938a963
>     returnk =(Mat4sizeOf(r2undefined r4)::Vec4)
940d964
<     pokeByteOff p (k  ) r2
941d964
<     pokeByteOff p (k+k) r3
942d964
<     pokeByteOff p (3*k) r4
943d964
< 
944d964
< instance Random Mat4 where
945d964
<   random = randomR (Mat4 v1 v1 v1 v1, Mat4 v2 v2 v2 v2) where
946c965
<     v1 = Vec4 (-1) (-1) (-1) (-1)
---
>   pokepokeByteOff (Mat4 r1p r2(k r3) r4) = do
946a966
>     letpokeByteOff = castPtrp (kqk::) r3 Vec4
946a967
>     pokeByteOff = sizeOfp ((undefined*k) r4   ::Vec4)
946a968
>     poke        p       r1
946a969
> instanceRandom pMat4k where) r2
946a970
>   random= randomR (k+Mat4k) r3v1 v1 v1 v1, Mat4 v2 v2 v2 v2) where
946a971
>     pokeByteOffv1 = Vec4 (-p)(3*k) r4(-1) (-1)
948d972
<   randomR (Mat4 a b c d, Mat4 e f g h) gen =
949c973
<     let (x,gen1) = randomR (a,e) gen
---
> instancerandomRRandom(Mat4 Mat4a b cwhered, Mat4 e f g h) gen =
949a974
>   randomlet (=,randomRgen1) = (randomRMat4 v1(v1a,ev1) gen, Mat4 v2 v2 v2 v2) where
949a975
>     v1 =(Vec4y,gen2-1) (randomR-1) (-1)b(-1)gen1
949a976
>     v2 =(Vec4z,gen3)1= randomR    1(c,g1 gen2
949a977
>   randomR(w(Mat4)a=brandomR d, Mat4(d,e)fgen3 h) gen =
949a978
>     letin ((Mat4x,gen1x ) = randomRw, gen4)(a,e) gen
951c980
<         (z,gen3) = randomR (c,g) gen2
---
> instance(zDimension,gen3) = randomRMat4 wherec,gdim) gen2_ = 4
953d981
<     in (Mat4 x y z w, gen4)
954d981
< 
955d981
< instance Dimension Mat4 where dim _ = 4
956d981
< 
957c982
< instance MatrixNorms Mat4 where
---
> instancein (Mat4MatrixNorms y z w,Mat4)where
959c984
<     sqrt $
---
> instancesqrt Dimension$         Mat4 where dim _ = 4
961d985
<       normsqr r2 +
962c986
<       normsqr r3 +
---
> instancenormsqrr2 +   Mat4 where
962a987
>   frobeniusNormnormsqr r3(Mat4+    r1 r2 r3 r4) =
962a988
>     sqrtnormsqr    r4
962a989
>       normsqr r1 +
962a990
> instancePointwise + Mat4 where
962a991
>   pointwise(Mat4 +x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)
964d992
< 
965d992
< instance Pointwise Mat4 where
966d992
<   pointwise (Mat4 x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)
967d992
< 
969d993
< -- Extend instances
970c994
< 
---
> instance-- Extend instances Mat4 where
970a995
>   pointwise (Mat4 x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)
972d996
<   extendZero   (Vec2 x y) = Vec3 x y 0
973c997
<   extendWith t (Vec2 x y) = Vec3 x y t
---
> --------------------------------------------------------------------------------extendZero   (Vec2 x y) = Vec3 x y 0
973a998
> -- Extend instancesextendWith t (Vec2 x y) = Vec3 x y t
975d999
< 
976d999
< instance Extend Vec2 Vec4 where
977d999
<   extendZero   (Vec2 x y) = Vec4 x y 0 0
978d999
<   extendWith t (Vec2 x y) = Vec4 x y t t
979d999
<   trim (Vec4 x y _ _)     = Vec2 x y
980d999
< 
981d999
< instance Extend Vec3 Vec4 where
982d999
<   extendZero   (Vec3 x y z) = Vec4 x y z 0
983d999
<   extendWith t (Vec3 x y z) = Vec4 x y z t
984d999
<   trim (Vec4 x y z _)       = Vec3 x y z
985d999
< 
986d999
< instance Extend Mat2 Mat3 where
987d999
<   extendZero   (Mat2 p q) = Mat3 (extendZero p) (extendZero q) zero
988d999
<   extendWith w (Mat2 p q) = Mat3 (extendZero p) (extendZero q) (Vec3 0 0 w)
989d999
<   trim (Mat3 p q _) = Mat2 (trim p) (trim q)
990d999
< 
991d999
< instance Extend Mat2 Mat4 where
992d999
<   extendZero   (Mat2 p q) = Mat4 (extendZero p) (extendZero q) zero zero
993d999
<   extendWith w (Mat2 p q) = Mat4 (extendZero p) (extendZero q) (Vec4 0 0 w 0) (Vec4 0 0 0 w)
994d999
<   trim (Mat4 p q _ _) = Mat2 (trim p) (trim q)
995d999
< 
996d999
< instance Extend Mat3 Mat4 where
997d999
<   extendZero   (Mat3 p q r) = Mat4 (extendZero p) (extendZero q) (extendZero r) zero
998d999
<   extendWith w (Mat3 p q r) = Mat4 (extendZero p) (extendZero q) (extendZero r) (Vec4 0 0 0 w)
999d999
<   trim (Mat4 p q r _) = Mat3 (trim p) (trim q) (trim r)
1000d999
< 
1001d999
< --------------------------------------------------------------------------------
1002c1000
< 
---
> instance Extend Vec2 Vec3 where
1002a1001
> instanceExtend(Vec2 xVec4) =where x y 0
1002a1002
>   extendWith t (Vec2 x y) = Vec3 x y t 0
1002a1003
>   trimextendWithVec3 x yVec2)  x y) = Vec2 x y t t
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
#define Flt Float
#define VECT_Float

{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, GeneralizedNewtypeDeriving #-}

module Data.Vect.Flt.Base
  ( AbelianGroup(..) , vecSum
  , MultSemiGroup(..) , Ring , semigroupProduct
  , LeftModule(..) , RightModule(..)
  , Vector(..) , DotProd(..) , CrossProd(..)
  , normalize , distance , angle , angle'
  , UnitVector(..)
  , Pointwise(..)
  , Extend(..) , HasCoordinates(..) , Dimension(..)
  , Matrix(..) , Tensor(..) , Diagonal (..) , Determinant(..)
  , Orthogonal(..) , Projective(..) , MatrixNorms(..)
  , Vec2(..) , Vec3(..) , Vec4(..)
  , Mat2(..) , Mat3(..) , Mat4(..)
  , Ortho2 , Ortho3 , Ortho4
  , Normal2 , Normal3 , Normal4
  , Proj3 , Proj4
  , mkVec2 , mkVec3 , mkVec4
  , project , project' , projectUnsafe , flipNormal
  , householder, householderOrtho
  )
  where

import Control.Monad
import System.Random
import Foreign

--------------------------------------------------------------------------------
-- class declarations

class AbelianGroup g where
  (&+) :: g -> g -> g
  (&-) :: g -> g -> g
  neg  :: g -> g
  zero :: g

infixl 6 &+
infixl 6 &-

vecSum :: AbelianGroup g => [g] -> g
vecSum l = foldl (&+) zero l

class MultSemiGroup r where
  (.*.) :: r -> r -> r
  one   :: r

class (AbelianGroup r, MultSemiGroup r) => Ring r

infixl 7 .*.

-- was: ringProduct :: Ring r => [r] -> r
semigroupProduct :: MultSemiGroup r => [r] -> r
semigroupProduct l = foldl (.*.) one l

class LeftModule r m where
  lmul :: r -> m -> m
  (*.) :: r -> m -> m
  (*.) = lmul

class RightModule m r where
  rmul :: m -> r -> m
  (.*) :: m -> r -> m
  (.*) = rmul

-- I'm not really sure about this.. may actually degrade the performance in some cases?
{- RULES
"matrix multiplication left"   forall m n x.  (n .*. m) *. x = n *. (m *. x)
"matrix multiplication right"  forall m n x.  x .* (m .*. n) = (x .* m) .* n
  -}

infixr 7 *.
infixl 7 .*

class AbelianGroup v => Vector v where
  mapVec    :: (Flt -> Flt) -> v -> v
  scalarMul :: Flt -> v -> v
  (*&) ::      Flt -> v -> v
  (&*) ::      v -> Flt -> v
  (*&) s v = scalarMul s v
  (&*) v s = scalarMul s v

infixr 7 *&
infixl 7 &*

{-# RULES
"scalar multiplication left"   forall s t x.  t *& (s *& x) = (t*s) *& x
"scalar multiplication right"  forall s t x.  (x &* s) &* t = x &* (s*t)
  #-}

class DotProd v where
  (&.) :: v -> v -> Flt
  norm    :: v -> Flt
  normsqr :: v -> Flt
  len     :: v -> Flt
  lensqr  :: v -> Flt
  len = norm
  lensqr = normsqr
  dotprod :: v -> v -> Flt
  normsqr v = (v &. v)
  norm = sqrt . lensqr
  dotprod = (&.)

infix 7 &.

{-# RULES
"len/square 1"   forall x.  (len x)*(len x) = lensqr x
"len/square 2"   forall x.  (len x)^2 = lensqr x
"norm/square 1"  forall x.  (norm x)*(norm x) = normsqr x
"norm/square 2"  forall x.  (norm x)^2 = normsqr x
  #-}

normalize :: (Vector v, DotProd v) => v -> v
normalize v = scalarMul (1.0/(len v)) v

distance :: (Vector v, DotProd v) => v -> v -> Flt
distance x y = norm (x &- y)

-- | the angle between two vectors
angle :: (Vector v, DotProd v) => v -> v -> Flt
angle x y = acos $ (x &. y) / (norm x * norm y)

-- | the angle between two unit vectors
angle' {- ' CPP is sensitive to primes -} :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Flt
angle' x y = acos (fromNormal x &. fromNormal y)

{-# RULES
"normalize is idempotent"  forall x. normalize (normalize x) = normalize x
  #-}

class (Vector v, DotProd v) => UnitVector v u | v->u, u->v  where
  mkNormal         :: v -> u       -- ^ normalizes the input
  toNormalUnsafe   :: v -> u       -- ^ does not normalize the input!
  fromNormal       :: u -> v
  fromNormalRadius :: Flt -> u -> v
  fromNormalRadius t n = t *& fromNormal n

-- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector
project' :: (Vector v, UnitVector v u, DotProd v) => v -> u -> v
project' what dir = projectUnsafe what (fromNormal dir)

-- | Direction (second argument) is assumed to be a /unit/ vector!
projectUnsafe :: (Vector v, DotProd v) => v -> v -> v
projectUnsafe what dir = what &- dir &* (what &. dir)

project :: (Vector v, DotProd v) => v -> v -> v
project what dir = what &- dir &* ((what &. dir) / (dir &. dir))

-- | Since unit vectors are not a group, we need a separate function.
flipNormal :: UnitVector v n => n -> n
flipNormal = toNormalUnsafe . neg . fromNormal

-- | Cross product
class CrossProd v where
  crossprod :: v -> v -> v
  (&^)      :: v -> v -> v
  (&^) = crossprod

-- | Pointwise multiplication
class Pointwise v where
  pointwise :: v -> v -> v
  (&!)      :: v -> v -> v
  (&!) = pointwise

infix 7 &^
infix 7 &!

class HasCoordinates v x | v->x where
  _1 :: v -> x
  _2 :: v -> x
  _3 :: v -> x
  _4 :: v -> x

-- | conversion between vectors (and matrices) of different dimensions
class Extend u v where
  extendZero :: u -> v          -- ^ example: @extendZero (Vec2 5 6) = Vec4 5 6 0 0@
  extendWith :: Flt -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
  trim :: v -> u                -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@

-- | makes a diagonal matrix from a vector
class Diagonal s t | t->s where
  diag :: s -> t

class Matrix m where
  transpose :: m -> m
  inverse :: m -> m
  idmtx :: m

{-# RULES
"transpose is an involution"  forall m. transpose (transpose m) = m
"inverse is an involution"    forall m. inverse (inverse m) = m
  #-}

class Matrix m => Orthogonal m o | m->o, o->m where
  fromOrtho     :: o -> m
  toOrthoUnsafe :: m -> o

class (AbelianGroup m, Matrix m) => MatrixNorms m where
  frobeniusNorm  :: m -> Flt       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
  matrixDistance :: m -> m -> Flt  -- ^ euclidean distance in the space of matrices
  operatorNorm   :: m -> Flt       -- ^ (euclidean) operator norm (not implemented yet)
  matrixDistance m n = frobeniusNorm (n &- m)
  operatorNorm = error "operatorNorm: not implemented yet"

-- | Outer product (could be unified with Diagonal?)
class Tensor t v | t->v where
  outer :: v -> v -> t

class Determinant m where
  det :: m -> Flt

class Dimension a where
  dim :: a -> Int

-- | Householder matrix, see <http://en.wikipedia.org/wiki/Householder_transformation>.
-- In plain words, it is the reflection to the hyperplane orthogonal to the input vector.
householder :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
householder u = idmtx &- (2 *& outer v v)
  where v = fromNormal u

householderOrtho :: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
householderOrtho = toOrthoUnsafe . householder

-- | \"Projective\" matrices have the following form: the top left corner
-- is an any matrix, the bottom right corner is 1, and the top-right
-- column is zero. These describe the affine orthogonal transformation of
-- the space one dimension less.
class (Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p
    | m->p, p->m, p->o, o->p, p->n, n->p, p->v, v->p, n->o, n->v, v->n where
  fromProjective     :: p -> m
  toProjectiveUnsafe :: m -> p
  orthogonal         :: o -> p
  linear             :: n -> p
  translation        :: v -> p
  scaling            :: v -> p

--------------------------------------------------------------------------------
-- Vec / Mat datatypes

data Vec2 = Vec2 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
  deriving (Read,Show)
data Vec3 = Vec3 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
  deriving (Read,Show)
data Vec4 = Vec4 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
  deriving (Read,Show)

-- | The components are /row/ vectors
data Mat2 = Mat2 !Vec2 !Vec2              deriving (Read,Show)
data Mat3 = Mat3 !Vec3 !Vec3 !Vec3        deriving (Read,Show)
data Mat4 = Mat4 !Vec4 !Vec4 !Vec4 !Vec4  deriving (Read,Show)

-- | The assumption when dealing with these is always that they are of unit length.
-- Also, interpolation works differently.
newtype Normal2 = Normal2 Vec2 deriving (Read,Show,Storable,DotProd,Dimension)
newtype Normal3 = Normal3 Vec3 deriving (Read,Show,Storable,DotProd,Dimension)
newtype Normal4 = Normal4 Vec4 deriving (Read,Show,Storable,DotProd,Dimension)

mkVec2 :: (Flt,Flt) -> Vec2
mkVec3 :: (Flt,Flt,Flt) -> Vec3
mkVec4 :: (Flt,Flt,Flt,Flt) -> Vec4

mkVec2 (x,y)     = Vec2 x y
mkVec3 (x,y,z)   = Vec3 x y z
mkVec4 (x,y,z,w) = Vec4 x y z w

-- | Orthogonal matrices.
--
-- Note: the "Random" instances generates orthogonal matrices with determinant 1
-- (that is, orientation-preserving orthogonal transformations)!
newtype Ortho2 = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
newtype Ortho3 = Ortho3 Mat3 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
newtype Ortho4 = Ortho4 Mat4 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)

-- | Projective matrices, encoding affine transformations in dimension one less.
newtype Proj3 = Proj3 Mat3 deriving (Read,Show,Storable,MultSemiGroup)
newtype Proj4 = Proj4 Mat4 deriving (Read,Show,Storable,MultSemiGroup)

--------------------------------------------------------------------------------
-- Unit vectors

instance UnitVector Vec2 Normal2 where
  mkNormal v = Normal2 (normalize v)
  fromNormal (Normal2 v) = v
  toNormalUnsafe = Normal2

instance UnitVector Vec3 Normal3 where
  mkNormal v = Normal3 (normalize v)
  fromNormal (Normal3 v) = v
  toNormalUnsafe = Normal3

instance UnitVector Vec4 Normal4 where
  mkNormal v = Normal4 (normalize v)
  fromNormal (Normal4 v) = v
  toNormalUnsafe = Normal4

_rndUnit :: (RandomGen g, Random v, Vector v, DotProd v) => g -> (v,g)
_rndUnit g =
  if d > 0.01
    then ( v &* (1.0/d) , h )
    else _rndUnit h
  where
    (v,h) = random g
    d = norm v

instance Random Normal2 where
  random g = let (v,h) = _rndUnit g in (Normal2 v, h)
  randomR _ = random

instance Random Normal3 where
  random g = let (v,h) = _rndUnit g in (Normal3 v, h)
  randomR _ = random

instance Random Normal4 where
  random g = let (v,h) = _rndUnit g in (Normal4 v, h)
  randomR _ = random

instance CrossProd Normal3 where
  crossprod (Normal3 v) (Normal3 w) = mkNormal (crossprod v w)

--------------------------------------------------------------------------------
-- Orthogonal matrices

instance Orthogonal Mat2 Ortho2 where
  fromOrtho (Ortho2 o) = o
  toOrthoUnsafe = Ortho2

instance Orthogonal Mat3 Ortho3 where
  fromOrtho (Ortho3 o) = o
  toOrthoUnsafe = Ortho3

instance Orthogonal Mat4 Ortho4 where
  fromOrtho (Ortho4 o) = o
  toOrthoUnsafe = Ortho4

------

instance Matrix Ortho2 where
  transpose (Ortho2 o) = Ortho2 (transpose o)
  idmtx = Ortho2 idmtx
  inverse = transpose

instance Matrix Ortho3 where
  transpose (Ortho3 o) = Ortho3 (transpose o)
  idmtx = Ortho3 idmtx
  inverse = transpose

instance Matrix Ortho4 where
  transpose (Ortho4 o) = Ortho4 (transpose o)
  idmtx = Ortho4 idmtx
  inverse = transpose

------

instance Random Ortho2 where
  random g = let (o,h) = _rndOrtho2 g in (toOrthoUnsafe (_flip1stRow2 o), h)
  randomR _ = random

instance Random Ortho3 where
  random g = let (o,h) = _rndOrtho3 g in (toOrthoUnsafe (             o), h)
  randomR _ = random

instance Random Ortho4 where
  random g = let (o,h) = _rndOrtho4 g in (toOrthoUnsafe (_flip1stRow4 o), h)
  randomR _ = random

------

-- determinant will be -1
_rndOrtho2 :: RandomGen g => g -> (Mat2, g)
_rndOrtho2 g = (h2, g1) where
  h2 = householder u2 :: Mat2
  (u2,g1) = random g

-- generates a uniformly random orthogonal 3x3 matrix
-- /with determinant +1/, with respect to the Haar measure of SO3.
--
-- see Theorem 4 in:
-- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groups
-- Notices of the AMS, May 2007 issue
-- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>
_rndOrtho3 :: RandomGen g => g -> (Mat3, g)
_rndOrtho3 g = ( (h3 .*. m3), g2) where
  m3 = (extendWith :: Flt -> Mat2 -> Mat3) 1 o2
  h3 = householder u3 :: Mat3
  (u3,g1) = random g
  (o2,g2) = _rndOrtho2 g1

-- determinant will be -1
_rndOrtho4 :: RandomGen g => g -> (Mat4, g)
_rndOrtho4 g = ( (h4 .*. m4), g2) where
  m4 = (extendWith :: Flt -> Mat3 -> Mat4) 1 o3
  h4 = householder u4 :: Mat4
  (u4,g1) = random g
  (o3,g2) = _rndOrtho3 g1

------

_flip1stRow2 :: Mat2 -> Mat2
_flip1stRow2 (Mat2 a b) = Mat2 (neg a) b

_flip1stRow3 :: Mat3 -> Mat3
_flip1stRow3 (Mat3 a b c) = Mat3 (neg a) b c

_flip1stRow4 :: Mat4 -> Mat4
_flip1stRow4 (Mat4 a b c d) = Mat4 (neg a) b c d

--------------------------------------------------------------------------------
-- projective matrices

instance Projective Vec2 Mat2 Ortho2 Mat3 Proj3 where
  fromProjective (Proj3 m) = m
  toProjectiveUnsafe = Proj3
  orthogonal = Proj3 . extendWith 1 . fromOrtho
  linear     = Proj3 . extendWith 1
  translation v = Proj3 $ Mat3 (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
  scaling     v = Proj3 $ diag (extendWith 1 v)

instance Projective Vec3 Mat3 Ortho3 Mat4 Proj4 where
  fromProjective (Proj4 m) = m
  toProjectiveUnsafe = Proj4
  orthogonal = Proj4 . extendWith 1 . fromOrtho
  linear     = Proj4 . extendWith 1
  translation v = Proj4 $ Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
  scaling     v = Proj4 $ diag (extendWith 1 v)

instance Matrix Proj3 where
  idmtx = Proj3 idmtx
  transpose (Proj3 m) = Proj3 (transpose m)
  inverse = _invertProj3

instance Matrix Proj4 where
  idmtx = Proj4 idmtx
  transpose (Proj4 m) = Proj4 (transpose m)
  inverse = _invertProj4

_invertProj3 :: Proj3 -> Proj3
_invertProj3 (Proj3 mat@(Mat3 _ _ t)) =
  Proj3 $ Mat3 (extendZero a) (extendZero b) (extendWith 1 t')
  where
    t' = neg $ (trim t :: Vec2) .* invm2
    invm2@(Mat2 a b) = inverse $ (trim mat :: Mat2)

-- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.
-- We assume that the bottom-right corner is 1.
_invertProj4 :: Proj4 -> Proj4
_invertProj4 (Proj4 mat@(Mat4 _ _ _ t)) =
  Proj4 $ Mat4 (extendZero a) (extendZero b) (extendZero c) (extendWith 1 t')
  where
    t' = neg $ (trim t :: Vec3) .* invm3
    invm3@(Mat3 a b c) = inverse $ (trim mat :: Mat3)

--------------------------------------------------------------------------------
-- Vec2 instances

instance HasCoordinates Vec2 Flt where
  _1 (Vec2 x _) = x
  _2 (Vec2 _ y) = y
  _3 _ = error "has only 2 coordinates"
  _4 _ = error "has only 2 coordinates"

instance AbelianGroup Vec2 where
  (&+) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
  (&-) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1-x2) (y1-y2)
  neg  (Vec2 x y)                = Vec2 (-x) (-y)
  zero = Vec2 0 0

instance Vector Vec2 where
  scalarMul s (Vec2 x y) = Vec2 (s*x) (s*y)
  mapVec    f (Vec2 x y) = Vec2 (f x) (f y)

instance DotProd Vec2 where
  (&.) (Vec2 x1 y1) (Vec2 x2 y2) = x1*x2 + y1*y2

instance Pointwise Vec2 where
  pointwise (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)

instance Determinant (Vec2,Vec2) where
  det (Vec2 x1 y1 , Vec2 x2 y2) = x1*y2 - x2*y1

{-
instance Show Vec2 where
  show (Vec2 x y) = "( " ++ show x ++ " , " ++ show y ++ " )"
-}

instance Random Vec2 where
  random = randomR (Vec2 (-1) (-1),Vec2 1 1)
  randomR (Vec2 a b, Vec2 c d) gen =
    let (x,gen1) = randomR (a,c) gen
        (y,gen2) = randomR (b,d) gen1
    in (Vec2 x y, gen2)

instance Storable Vec2 where
  sizeOf    _ = 2 * sizeOf (undefined::Flt)
  alignment _ = sizeOf (undefined::Flt)

  peek q = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    x <- peek        p
    y <- peekByteOff p k
    return (Vec2 x y)

  poke q (Vec2 x y) = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    poke        p   x
    pokeByteOff p k y

instance Dimension Vec2 where dim _ = 2

--------------------------------------------------------------------------------
-- Mat2 instances

instance HasCoordinates Mat2 Vec2 where
  _1 (Mat2 x _) = x
  _2 (Mat2 _ y) = y
  _3 _ = error "has only 2 coordinates"
  _4 _ = error "has only 2 coordinates"

instance Matrix Mat2 where
  transpose (Mat2 row1 row2) =
    Mat2 (Vec2 (_1 row1) (_1 row2))
         (Vec2 (_2 row1) (_2 row2))
  idmtx = Mat2 (Vec2 1 0) (Vec2 0 1)
  inverse (Mat2 (Vec2 a b) (Vec2 c d)) =
    Mat2 (Vec2 (d*r) (-b*r)) (Vec2 (-c*r) (a*r))
    where r = 1.0 / (a*d - b*c)

instance AbelianGroup Mat2 where
  (&+) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &+ s1) (r2 &+ s2)
  (&-) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &- s1) (r2 &- s2)
  neg  (Mat2 r1 r2)              = Mat2 (neg r1) (neg r2)
  zero = Mat2 zero zero

instance Vector Mat2 where
  scalarMul s (Mat2 r1 r2) = Mat2 (g r1) (g r2) where g = scalarMul s
  mapVec    f (Mat2 r1 r2) = Mat2 (g r1) (g r2) where g = mapVec f

instance MultSemiGroup Mat2 where
  (.*.) (Mat2 r1 r2) n =
    let (Mat2 c1 c2) = transpose n
    in Mat2 (Vec2 (r1 &. c1) (r1 &. c2))
            (Vec2 (r2 &. c1) (r2 &. c2))
  one = idmtx

instance Ring Mat2

instance LeftModule Mat2 Vec2 where
  lmul (Mat2 row1 row2) v = Vec2 (row1 &. v) (row2 &. v)

instance RightModule Vec2 Mat2 where
  rmul v mt = lmul (transpose mt) v

instance Diagonal Vec2 Mat2 where
  diag (Vec2 x y) = Mat2 (Vec2 x 0) (Vec2 0 y)

instance Tensor Mat2 Vec2 where
  outer (Vec2 a b) (Vec2 x y) = Mat2
    (Vec2 (a*x) (a*y))
    (Vec2 (b*x) (b*y))

instance Determinant Mat2 where
  det (Mat2 (Vec2 a b) (Vec2 c d)) = a*d - b*c

{-
instance Show Mat2 where
  show (Mat2 r1 r2) = show r1 ++ "\n" ++ show r2
-}

instance Storable Mat2 where
  sizeOf    _ = 2 * sizeOf (undefined::Vec2)
  alignment _ = alignment  (undefined::Vec2)

  peek q = do
    let p = castPtr q :: Ptr Vec2
        k = sizeOf (undefined::Vec2)
    r1 <- peek        p
    r2 <- peekByteOff p k
    return (Mat2 r1 r2)

  poke q (Mat2 r1 r2) = do
    let p = castPtr q :: Ptr Vec2
        k = sizeOf (undefined::Vec2)
    poke        p   r1
    pokeByteOff p k r2

instance Random Mat2 where
  random = randomR (Mat2 v1 v1 , Mat2 v2 v2) where
    v1 = Vec2 (-1) (-1)
    v2 = Vec2   1    1
  randomR (Mat2 a b, Mat2 c d) gen =
    let (x,gen1) = randomR (a,c) gen
        (y,gen2) = randomR (b,d) gen1
    in (Mat2 x y, gen2)

instance Dimension Mat2 where dim _ = 2

instance MatrixNorms Mat2 where
  frobeniusNorm (Mat2 r1 r2) =
    sqrt $
      normsqr r1 +
      normsqr r2

instance Pointwise Mat2 where
  pointwise (Mat2 x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)

--------------------------------------------------------------------------------
-- Vec3 instances

instance HasCoordinates Vec3 Flt where
  _1 (Vec3 x _ _) = x
  _2 (Vec3 _ y _) = y
  _3 (Vec3 _ _ z) = z
  _4 _ = error "has only 3 coordinates"

instance AbelianGroup Vec3 where
  (&+) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
  (&-) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
  neg  (Vec3 x y z)                    = Vec3 (-x) (-y) (-z)
  zero = Vec3 0 0 0

instance Vector Vec3 where
  scalarMul s (Vec3 x y z) = Vec3 (s*x) (s*y) (s*z)
  mapVec    f (Vec3 x y z) = Vec3 (f x) (f y) (f z)

instance DotProd Vec3 where
  (&.) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = x1*x2 + y1*y2 + z1*z2

instance Pointwise Vec3 where
  pointwise (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1*x2) (y1*y2) (z1*z2)

{-
instance Show Vec3 where
  show (Vec3 x y z) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " )"
-}

instance Random Vec3 where
  random = randomR (Vec3 (-1) (-1) (-1),Vec3 1 1 1)
  randomR (Vec3 a b c, Vec3 d e f) gen =
    let (x,gen1) = randomR (a,d) gen
        (y,gen2) = randomR (b,e) gen1
        (z,gen3) = randomR (c,f) gen2
    in (Vec3 x y z, gen3)

instance CrossProd Vec3 where
  crossprod (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)

instance Determinant (Vec3,Vec3,Vec3) where
  det (u,v,w) = u &. (v &^ w)

instance Storable Vec3 where
  sizeOf    _ = 3 * sizeOf (undefined::Flt)
  alignment _ = sizeOf (undefined::Flt)

  peek q = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    x <- peek        p
    y <- peekByteOff p (k  )
    z <- peekByteOff p (k+k)
    return (Vec3 x y z)

  poke q (Vec3 x y z) = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    poke        p       x
    pokeByteOff p (k  ) y
    pokeByteOff p (k+k) z

instance Dimension Vec3 where dim _ = 3

--------------------------------------------------------------------------------
-- Mat3 instances

instance HasCoordinates Mat3 Vec3 where
  _1 (Mat3 x _ _) = x
  _2 (Mat3 _ y _) = y
  _3 (Mat3 _ _ z) = z
  _4 _ = error "has only 3 coordinates"

instance Matrix Mat3 where

  transpose (Mat3 row1 row2 row3) =
    Mat3 (Vec3 (_1 row1) (_1 row2) (_1 row3))
         (Vec3 (_2 row1) (_2 row2) (_2 row3))
         (Vec3 (_3 row1) (_3 row2) (_3 row3))

  idmtx = Mat3 (Vec3 1 0 0) (Vec3 0 1 0) (Vec3 0 0 1)

  inverse (Mat3 (Vec3 a b c) (Vec3 e f g) (Vec3 i j k)) =
    Mat3 (Vec3 (d11*r) (d21*r) (d31*r))
         (Vec3 (d12*r) (d22*r) (d32*r))
         (Vec3 (d13*r) (d23*r) (d33*r))
    where
      r = 1.0 / ( a*d11 + b*d12 + c*d13 )

      d11 = f*k - g*j
      d12 = g*i - e*k
      d13 = e*j - f*i

      d31 = b*g - c*f
      d32 = c*e - a*g
      d33 = a*f - b*e

      d21 = c*j - b*k
      d22 = a*k - c*i
      d23 = b*i - a*j

instance AbelianGroup Mat3 where
  (&+) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
  (&-) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
  neg  (Mat3 r1 r2 r3)                 = Mat3 (neg r1) (neg r2) (neg r3)
  zero = Mat3 zero zero zero

instance Vector Mat3 where
  scalarMul s (Mat3 r1 r2 r3) = Mat3 (g r1) (g r2) (g r3) where g = scalarMul s
  mapVec    f (Mat3 r1 r2 r3) = Mat3 (g r1) (g r2) (g r3) where g = mapVec f

instance MultSemiGroup Mat3 where
  (.*.) (Mat3 r1 r2 r3) n =
    let (Mat3 c1 c2 c3) = transpose n
    in Mat3 (Vec3 (r1 &. c1) (r1 &. c2) (r1 &. c3))
            (Vec3 (r2 &. c1) (r2 &. c2) (r2 &. c3))
            (Vec3 (r3 &. c1) (r3 &. c2) (r3 &. c3))
  one = idmtx

instance Ring Mat3

instance LeftModule Mat3 Vec3 where
  lmul (Mat3 row1 row2 row3) v = Vec3 (row1 &. v) (row2 &. v) (row3 &. v)

instance RightModule Vec3 Mat3 where
  rmul v mt = lmul (transpose mt) v

instance Diagonal Vec3 Mat3 where
  diag (Vec3 x y z) = Mat3 (Vec3 x 0 0) (Vec3 0 y 0) (Vec3 0 0 z)

instance Tensor Mat3 Vec3 where
  outer (Vec3 a b c) (Vec3 x y z) = Mat3
    (Vec3 (a*x) (a*y) (a*z))
    (Vec3 (b*x) (b*y) (b*z))
    (Vec3 (c*x) (c*y) (c*z))

instance Determinant Mat3 where
  det (Mat3 r1 r2 r3) = det (r1,r2,r3)

{-
instance Show Mat3 where
  show (Mat3 r1 r2 r3) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3
-}

instance Storable Mat3 where
  sizeOf    _ = 3 * sizeOf (undefined::Vec3)
  alignment _ = alignment  (undefined::Vec3)

  peek q = do
    let p = castPtr q :: Ptr Vec3
        k = sizeOf (undefined::Vec3)
    r1 <- peek        p
    r2 <- peekByteOff p (k  )
    r3 <- peekByteOff p (k+k)
    return (Mat3 r1 r2 r3)

  poke q (Mat3 r1 r2 r3) = do
    let p = castPtr q :: Ptr Vec3
        k = sizeOf (undefined::Vec3)
    poke        p       r1
    pokeByteOff p (k  ) r2
    pokeByteOff p (k+k) r3

instance Random Mat3 where
  random = randomR (Mat3 v1 v1 v1 , Mat3 v2 v2 v2) where
    v1 = Vec3 (-1) (-1) (-1)
    v2 = Vec3   1    1    1
  randomR (Mat3 a b c, Mat3 d e f) gen =
    let (x,gen1) = randomR (a,d) gen
        (y,gen2) = randomR (b,e) gen1
        (z,gen3) = randomR (c,f) gen2
    in (Mat3 x y z, gen3)

instance Dimension Mat3 where dim _ = 3

instance MatrixNorms Mat3 where
  frobeniusNorm (Mat3 r1 r2 r3)  =
    sqrt $
      normsqr r1 +
      normsqr r2 +
      normsqr r3

instance Pointwise Mat3 where
  pointwise (Mat3 x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)

--------------------------------------------------------------------------------
-- Vec4 instances

instance HasCoordinates Vec4 Flt where
  _1 (Vec4 x _ _ _) = x
  _2 (Vec4 _ y _ _) = y
  _3 (Vec4 _ _ z _) = z
  _4 (Vec4 _ _ _ w) = w

instance AbelianGroup Vec4 where
  (&+) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
  (&-) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
  neg  (Vec4 x y z w)                        = Vec4 (-x) (-y) (-z) (-w)
  zero = Vec4 0 0 0 0

instance Vector Vec4 where
  scalarMul s (Vec4 x y z w) = Vec4 (s*x) (s*y) (s*z) (s*w)
  mapVec    f (Vec4 x y z w) = Vec4 (f x) (f y) (f z) (f w)

instance DotProd Vec4 where
  (&.) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = x1*x2 + y1*y2 + z1*z2 + w1*w2

instance Pointwise Vec4 where
  pointwise (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1*x2) (y1*y2) (z1*z2) (w1*w2)

{-
instance Show Vec4 where
  show (Vec4 x y z w) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " , " ++ show w ++ " )"
-}

instance Random Vec4 where
  random = randomR (Vec4 (-1) (-1) (-1) (-1),Vec4 1 1 1 1)
  randomR (Vec4 a b c d, Vec4 e f g h) gen =
    let (x,gen1) = randomR (a,e) gen
        (y,gen2) = randomR (b,f) gen1
        (z,gen3) = randomR (c,g) gen2
        (w,gen4) = randomR (d,h) gen3
    in (Vec4 x y z w, gen4)

instance Storable Vec4 where
  sizeOf    _ = 4 * sizeOf (undefined::Flt)
  alignment _ = sizeOf (undefined::Flt)

  peek q = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    x <- peek        p
    y <- peekByteOff p (k  )
    z <- peekByteOff p (k+k)
    w <- peekByteOff p (3*k)
    return (Vec4 x y z w)

  poke q (Vec4 x y z w) = do
    let p = castPtr q :: Ptr Flt
        k = sizeOf (undefined::Flt)
    poke        p       x
    pokeByteOff p (k  ) y
    pokeByteOff p (k+k) z
    pokeByteOff p (3*k) w

instance Dimension Vec4 where dim _ = 4

--------------------------------------------------------------------------------
-- Mat4 instances

instance HasCoordinates Mat4 Vec4 where
  _1 (Mat4 x _ _ _) = x
  _2 (Mat4 _ y _ _) = y
  _3 (Mat4 _ _ z _) = z
  _4 (Mat4 _ _ _ w) = w

instance Matrix Mat4 where
  transpose (Mat4 row1 row2 row3 row4) =
    Mat4 (Vec4 (_1 row1) (_1 row2) (_1 row3) (_1 row4))
         (Vec4 (_2 row1) (_2 row2) (_2 row3) (_2 row4))
         (Vec4 (_3 row1) (_3 row2) (_3 row3) (_3 row4))
         (Vec4 (_4 row1) (_4 row2) (_4 row3) (_4 row4))
  idmtx = Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (Vec4 0 0 0 1)
  inverse = error "inverse/Mat4: not implemented yet"

instance AbelianGroup Mat4 where
  (&+) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3) (r4 &+ s4)
  (&-) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
  neg  (Mat4 r1 r2 r3 r4)                    = Mat4 (neg r1) (neg r2) (neg r3) (neg r4)
  zero = Mat4 zero zero zero zero

instance Vector Mat4 where
  scalarMul s (Mat4 r1 r2 r3 r4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = scalarMul s
  mapVec    f (Mat4 r1 r2 r3 r4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = mapVec f

instance MultSemiGroup Mat4 where
  (.*.) (Mat4 r1 r2 r3 r4) n =
    let (Mat4 c1 c2 c3 c4) = transpose n
    in Mat4 (Vec4 (r1 &. c1) (r1 &. c2) (r1 &. c3) (r1 &. c4))
            (Vec4 (r2 &. c1) (r2 &. c2) (r2 &. c3) (r2 &. c4))
            (Vec4 (r3 &. c1) (r3 &. c2) (r3 &. c3) (r3 &. c4))
            (Vec4 (r4 &. c1) (r4 &. c2) (r4 &. c3) (r4 &. c4))
  one = idmtx

instance Ring Mat4

instance LeftModule Mat4 Vec4 where
  lmul (Mat4 row1 row2 row3 row4) v = Vec4 (row1 &. v) (row2 &. v) (row3 &. v) (row4 &. v)

instance RightModule Vec4 Mat4 where
  rmul v mt = lmul (transpose mt) v

instance Diagonal Vec4 Mat4 where
  diag (Vec4 x y z w) = Mat4 (Vec4 x 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)

instance Tensor Mat4 Vec4 where
  outer (Vec4 a b c d) (Vec4 x y z w) = Mat4
    (Vec4 (a*x) (a*y) (a*z) (a*w))
    (Vec4 (b*x) (b*y) (b*z) (b*w))
    (Vec4 (c*x) (c*y) (c*z) (c*w))
    (Vec4 (d*x) (d*y) (d*z) (d*w))

instance Determinant Mat4 where
  det = error "det/Mat4: not implemented yet"
  -- det (Mat4 r1 r2 r3 r4) =

{-
instance Show Mat4 where
  show (Mat4 r1 r2 r3 r4) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3 ++ "\n" ++ show r4
-}

instance Storable Mat4 where
  sizeOf    _ = 4 * sizeOf (undefined::Vec4)
  alignment _ = alignment  (undefined::Vec4)

  peek q = do
    let p = castPtr q :: Ptr Vec4
        k = sizeOf (undefined::Vec4)
    r1 <- peek        p
    r2 <- peekByteOff p (k  )
    r3 <- peekByteOff p (k+k)
    r4 <- peekByteOff p (3*k)
    return (Mat4 r1 r2 r3 r4)

  poke q (Mat4 r1 r2 r3 r4) = do
    let p = castPtr q :: Ptr Vec4
        k = sizeOf (undefined::Vec4)
    poke        p       r1
    pokeByteOff p (k  ) r2
    pokeByteOff p (k+k) r3
    pokeByteOff p (3*k) r4

instance Random Mat4 where
  random = randomR (Mat4 v1 v1 v1 v1, Mat4 v2 v2 v2 v2) where
    v1 = Vec4 (-1) (-1) (-1) (-1)
    v2 = Vec4   1    1    1    1
  randomR (Mat4 a b c d, Mat4 e f g h) gen =
    let (x,gen1) = randomR (a,e) gen
        (y,gen2) = randomR (b,f) gen1
        (z,gen3) = randomR (c,g) gen2
        (w,gen4) = randomR (d,h) gen3
    in (Mat4 x y z w, gen4)

instance Dimension Mat4 where dim _ = 4

instance MatrixNorms Mat4 where
  frobeniusNorm (Mat4 r1 r2 r3 r4) =
    sqrt $
      normsqr r1 +
      normsqr r2 +
      normsqr r3 +
      normsqr r4

instance Pointwise Mat4 where
  pointwise (Mat4 x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)

--------------------------------------------------------------------------------
-- Extend instances

instance Extend Vec2 Vec3 where
  extendZero   (Vec2 x y) = Vec3 x y 0
  extendWith t (Vec2 x y) = Vec3 x y t
  trim (Vec3 x y _)       = Vec2 x y

instance Extend Vec2 Vec4 where
  extendZero   (Vec2 x y) = Vec4 x y 0 0
  extendWith t (Vec2 x y) = Vec4 x y t t
  trim (Vec4 x y _ _)     = Vec2 x y

instance Extend Vec3 Vec4 where
  extendZero   (Vec3 x y z) = Vec4 x y z 0
  extendWith t (Vec3 x y z) = Vec4 x y z t
  trim (Vec4 x y z _)       = Vec3 x y z

instance Extend Mat2 Mat3 where
  extendZero   (Mat2 p q) = Mat3 (extendZero p) (extendZero q) zero
  extendWith w (Mat2 p q) = Mat3 (extendZero p) (extendZero q) (Vec3 0 0 w)
  trim (Mat3 p q _) = Mat2 (trim p) (trim q)

instance Extend Mat2 Mat4 where
  extendZero   (Mat2 p q) = Mat4 (extendZero p) (extendZero q) zero zero
  extendWith w (Mat2 p q) = Mat4 (extendZero p) (extendZero q) (Vec4 0 0 w 0) (Vec4 0 0 0 w)
  trim (Mat4 p q _ _) = Mat2 (trim p) (trim q)

instance Extend Mat3 Mat4 where
  extendZero   (Mat3 p q r) = Mat4 (extendZero p) (extendZero q) (extendZero r) zero
  extendWith w (Mat3 p q r) = Mat4 (extendZero p) (extendZero q) (extendZero r) (Vec4 0 0 0 w)
  trim (Mat4 p q r _) = Mat3 (trim p) (trim q) (trim r)

--------------------------------------------------------------------------------


</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
#define Flt Float
#define VECT_Float

{-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, GeneralizedNewtypeDeriving #-}

module Data.Vect.Float.BaseData.Vect.Flt.Base
  ( AbelianGroup(..) , vecSum
  , MultSemiGroup(..) , Ring , semigroupProduct
  , LeftModule(..) , RightModule(..)
  , Vector(..) , DotProd(..) , CrossProd(..)
  , normalize , distance , angle , angle'
  , UnitVector(..)
  , Pointwise(..)
  , Extend(..) , HasCoordinates(..) , Dimension(..)
  , Matrix(..) , Tensor(..) , Diagonal (..) , Determinant(..)
  , Orthogonal(..) , Projective(..) , MatrixNorms(..)
  , Vec2(..) , Vec3(..) , Vec4(..)
  , Mat2(..) , Mat3(..) , Mat4(..)
  , Ortho2 , Ortho3 , Ortho4
  , Normal2 , Normal3 , Normal4
  , Proj3 , Proj4
  , mkVec2 , mkVec3 , mkVec4
  , project , project' , projectUnsafe , flipNormal
  , householder, householderOrtho
  )
  where

import Control.Monad
import System.Random
import Foreign

--------------------------------------------------------------------------------
-- class declarations

class AbelianGroup g where
  (&+) :: g -> g -> g
  (&-) :: g -> g -> g
  neg  :: g -> g
  zero :: g

infixl 6 &+
infixl 6 &-

vecSum :: AbelianGroup g => [g] -> g
vecSum l = foldl (&+) zero l

class MultSemiGroup r where
  (.*.) :: r -> r -> r
  one   :: r

class (AbelianGroup r, MultSemiGroup r) => Ring r

infixl 7 .*.

-- was: ringProduct :: Ring r => [r] -> r
semigroupProduct :: MultSemiGroup r => [r] -> r
semigroupProduct l = foldl (.*.) one l

class LeftModule r m where
  lmul :: r -> m -> m
  (*.) :: r -> m -> m
  (*.) = lmul

class RightModule m r where
  rmul :: m -> r -> m
  (.*) :: m -> r -> m
  (.*) = rmul

-- I'm not really sure about this.. may actually degrade the performance in some cases?
{- RULES
"matrix multiplication left"   forall m n x.  (n .*. m) *. x = n *. (m *. x)
"matrix multiplication right"  forall m n x.  x .* (m .*. n) = (x .* m) .* n
  -}

infixr 7 *.
infixl 7 .*

class AbelianGroup v => Vector v where
  mapVec    :: (FloatFlt ->->Flt) ->)v->->vv-> v
  scalarMul :: FloatFlt ->->v v->->v v
  (*&) ::      FloatFlt ->->v v->->v v
  (&*) ::      v -> FloatFlt ->->v v
  (*&) s v = scalarMul s v
  (&*) v s = scalarMul s v

infixr 7 *&
infixl 7 &*

{-# RULES
"scalar multiplication left"   forall s t x.  t *& (s *& x) = (t*s) *& x
"scalar multiplication right"  forall s t x.  (x &* s) &* t = x &* (s*t)
  #-}

class DotProd v where
class(&.)DotProd:: v ->vvwhere-> Flt
  (norm&.) :: v::->v v->->Flt
  normnormsqr :: v -> FloatFlt
  normsqrlen     :: v -> FloatFlt
  lenlensqr  :: v -> FloatFlt
  lensqrlen = norm:: v -> Float
  lenlensqr= norm= normsqr
  lensqrdotprod=::v -> v -> Flt
  dotprod ::v =v(->v &. ->v) Float
  normsqrnorm = sqrt = (vlensqr v)
  normdotprod= sqrt= (&.)lensqr
  dotprod = (&.)
infix 7 &.
infix 7 &.
{-# RULES
{-# RULES"len/square 1"   forall x.  (len x)*(len x) = lensqr x
"len/square 1"   forall x.  (len x)*(len= lensqr) = lensqrx     x
"len/square 2""norm/square 1"  forall x.  (lennormx)^2(=normx) =xnormsqr x
"norm/square 1"  forall x.  (norm x)*(norm= normsqr) = normsqrx      x
"norm/square 2"#-}            forall x.  (norm x)^2 = normsqr x
  #-}
normalize :: (Vector v, DotProd v) => v -> v
normalize v = scalarMul (1.0/(len v)) v
normalize :: (Vector v, DotProd v) => v -> v
normalizedistance :: =Vectorv, DotProd1.0/(lenv) v=>))vv-> v -> Flt
distance x y = norm (x &- y)
distance :: (Vector v, DotProd v) => v -> v -> Float
distance-- | the angle between two vectors y = norm (x &- y)
angle :: (Vector v, DotProd v) => v -> v -> Flt
angle-- | the angle between two vectorsx y = acos $ (x &. y) / (norm x * norm y)
angle :: (Vector v, DotProd v) => v -> v -> Float
angle-- | the angle between two unit vectors y = acos $ (x &. y) / (norm x * norm y)
angle' {- ' CPP is sensitive to primes -} :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Flt
angle'-- | the angle between two unit vectorsx y = acos (fromNormal x &. fromNormal y)
angle' {- ' CPP is sensitive to primes -} :: (Vector v, UnitVector v u, DotProd v) => u -> u -> Float
angle'{-# RULES y = acos (fromNormal x &. fromNormal y)
"normalize is idempotent"  forall x. normalize (normalize x) = normalize x
{-# RULES#-}
"normalize is idempotent"  forall x. normalize (normalize x) = normalize x
class#-} (Vector v, DotProd v) => UnitVector v u | v->u, u->v  where
  mkNormal         :: v -> u       -- ^ normalizes the input
  toNormalUnsafe   :: v -> u       -- ^ does not normalize the input!
classfromNormalVector v, DotProd:: u ->)v=> UnitVector v u | v->u, u->v  where
  mkNormalfromNormalRadius :: vFlt->-> u -> v-- ^ normalizes the input
  toNormalUnsafefromNormalRadius ::t nv=->t u*& fromNormal-- ^ does not normalize the input!n
  fromNormal       :: u -> v
-- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector :: Float -> u -> v
project':: (Vectortvn =UnitVector *& fromNormalv u, DotProd     v) => v -> u -> v
project' what dir = projectUnsafe what (fromNormal dir)
-- | Projects the first vector down to the hyperplane orthogonal to the second (unit) vector
project'-- | Direction (second argument) is assumed to be a /unit/ vector!:: (Vector v, UnitVector v u, DotProd v) => v -> u -> v
project'projectUnsafe dir:: (=Vectorv, DotProdv) (=>fromNormalv -> v ->dirv )
projectUnsafe what dir = what &- dir &* (what &. dir)
-- | Direction (second argument) is assumed to be a /unit/ vector!
projectUnsafeproject :: (Vector:: (Vectorv, DotProd, DotProdv) => v)->=>vv->->vv -> v
projectUnsafeproject what dir= dirwhat=&-dir&-&*dir((what (what&. dir) dir/ ()dir &. dir))

project-- | Since unit vectors are not a group, we need a separate function.:: (Vector v, DotProd v) => v -> v -> v
projectflipNormal::dirUnitVector= what &-v dirn =>&*n (->(whatn   &. dir) / (dir &. dir))
flipNormal = toNormalUnsafe . neg . fromNormal
-- | Since unit vectors are not a group, we need a separate function.
flipNormal-- | Cross product:: UnitVector v n => n -> n
flipNormalclass CrossProd= toNormalUnsafev where     . neg . fromNormal
  crossprod :: v -> v -> v
-- | Cross product(&^)      :: v -> v -> v
class(&^)CrossProd= crossprod where
  crossprod :: v -> v -> v
-- | Pointwise multiplication&^)      :: v -> v -> v
class&^)Pointwise= crossprodv where
  pointwise :: v -> v -> v
-- | Pointwise multiplication(&!)      :: v -> v -> v
class(&!)Pointwise= pointwise where
  pointwise :: v -> v -> v
infix&!)7 &^  :: v -> v -> v
infix&!)7=&!

infix 7HasCoordinates           v x | v->x where
infix_1 ::7 &!v -> x
  _2 :: v -> x
class_3 ::v -> x       v x | v->x where
  _1 :: v -> x
  _2 :: v -> x
-- | conversion between vectors (and matrices) of different dimensions :: v -> x
class ::Extend -> x v where
  extendZero :: u -> v          -- ^ example: @extendZero (Vec2 5 6) = Vec4 5 6 0 0@
-- | conversion between vectors (and matrices) of different dimensionsextendWith :: Flt -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
classtrimExtend:: v -> v where          -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@
  extendZero :: u -> v          -- ^ example: @extendZero (Vec2 5 6) = Vec4 5 6 0 0@
-- | makes a diagonal matrix from a vector :: Float -> u -> v   -- ^ example: @extendWith 1 (Vec2 5 6) = Vec4 5 6 1 1@
classDiagonal:: v -> u t | t->s where -- ^ example: @trim (Vec4 5 6 7 8) = Vec2 5 6@
  diag :: s -> t
-- | makes a diagonal matrix from a vector
class DiagonalMatrix m swhere | t->s where
  diagtranspose:: s -> t -> m
  inverse :: m -> m
classidmtx:: m m where
  transpose :: m -> m
{-# RULES :: m -> m
"transpose is an involution" :: m                  forall m. transpose (transpose m) = m
"inverse is an involution"    forall m. inverse (inverse m) = m
{-# RULES#-}
"transpose is an involution"  forall m. transpose (transpose m) = m
"inverse is an involution"class Matrix m => Orthogonal mforallo | m->.,inverseo->m whereinverse m) = m
  #-}fromOrtho     :: o -> m
  toOrthoUnsafe :: m -> o

class Matrix(AbelianGroup => Orthogonalm, Matrixmmo |=>m->MatrixNormso, o->m wherem where
  fromOrthofrobeniusNorm ::::om->->mFlt       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
  toOrthoUnsafematrixDistance::::mm->->om -> Flt  -- ^ euclidean distance in the space of matrices
  operatorNorm   :: m -> Flt       -- ^ (euclidean) operator norm (not implemented yet)
classmatrixDistanceAbelianGroupm nm, MatrixfrobeniusNorm) => MatrixNorms(n &- m)   m where
  frobeniusNormoperatorNorm = ::error ->"operatorNorm: not implemented yet"       -- ^ the frobenius norm (= euclidean norm in the space of matrices)
  matrixDistance :: m -> m -> Float  -- ^ euclidean distance in the space of matrices
-- | Outer product (could be unified with Diagonal?)   :: m -> Float       -- ^ (euclidean) operator norm (not implemented yet)
classTensor t v m n->=vfrobeniusNormwhere        (n &- m)
  operatorNormouter :: v ->=verror-> t "operatorNorm: not implemented yet"

class-- | Outer product (could be unified with Diagonal?)Determinant m where
classdet Tensor:: m ->tFlt | t->v where
  outer :: v -> v -> t
class Dimension a where
classdim Determinant:: a -> Int m where
  det :: m -> Float
-- | Householder matrix, see <http://en.wikipedia.org/wiki/Householder_transformation>.
class-- In plain words, it is the reflection to the hyperplane orthogonal to the input vector. a where
householder :: a ->::Int(Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v) => u -> m
householder u = idmtx &- (2 *& outer v v)
-- | Householder matrix, see <http://en.wikipedia.org/wiki/Householder_transformation>.where v = fromNormal u
-- In plain words, it is the reflection to the hyperplane orthogonal to the input vector.
householderhouseholderOrtho:: (Vector:: (Vector, UnitVectorv, UnitVector u, Matrixv u, Matrix, Vectorm, Vector, Tensorm, Tensor v) =>m vu ->Orthogonal       m o) => u -> o
householderhouseholderOrtho = idmtx= toOrthoUnsafe (2 *& outer. householder v)
  where v = fromNormal u
-- | \"Projective\" matrices have the following form: the top left corner
householderOrtho-- is an any matrix, the bottom right corner is 1, and the top-right:: (Vector v, UnitVector v u, Matrix m, Vector m, Tensor m v, Orthogonal m o) => u -> o
householderOrtho-- column is zero. These describe the affine orthogonal transformation of= toOrthoUnsafe . householder
-- the space one dimension less.
class-- | \"Projective\" matrices have the following form: the top left corner(Vector v, Orthogonal n o, Diagonal v n) => Projective v n o m p
-- is an any matrix, the bottom right corner is 1, and the top-right| m->p, p->m, p->o, o->p, p->n, n->p, p->v, v->p, n->o, n->v, v->n where
-- column is zero. These describe the affine orthogonal transformation offromProjective     :: p -> m
-- the space one dimension less.toProjectiveUnsafe :: m -> p
classorthogonalVector v, Orthogonal:: o ->npo, Diagonal v n) => Projective v n o m p
  linear| m->p, p->m, p->o::, o->->p,pp->n, n->p, p->v, v->p, n->o, n->v, v->n where
  fromProjectivetranslation        :: p -> m
  toProjectiveUnsafescaling            :: m -> p
  orthogonal         :: o -> p
--------------------------------------------------------------------------------             :: n -> p
-- Vec / Mat datatypes        :: v -> p
  scaling            :: v -> p
data Vec2 = Vec2 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
--------------------------------------------------------------------------------deriving (Read,Show)
data-- Vec / Mat datatypesVec3 = Vec3 {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
  deriving (Read,Show)
data Vec2 = Vec2 {-# UNPACK #-} !FloatFlt {-# UNPACK #-}#-}!Flt!Float{-# UNPACK #-} !Flt {-# UNPACK #-} !Flt
  deriving (Read,Show)
data Vec3 = Vec3 {-# UNPACK #-} !Float {-# UNPACK #-} !Float {-# UNPACK #-} !Float
-- | The components are /row/ vectors (Read,Show)
data Vec4 = Vec4 {-# UNPACK!Vec2 !Vec2#-} !Float {-# UNPACKderiving#-}(Read!Float,Show{-# UNPACK)          #-} !Float {-# UNPACK #-} !Float
dataMat3 =(Read,Show!Vec3) !Vec3 !Vec3        deriving (Read,Show)
data Mat4 = Mat4 !Vec4 !Vec4 !Vec4 !Vec4  deriving (Read,Show)
-- | The components are /row/ vectors
data-- | The assumption when dealing with these is always that they are of unit length. = Mat2 !Vec2 !Vec2              deriving (Read,Show)
data-- Also, interpolation works differently. = Mat3 !Vec3 !Vec3 !Vec3        deriving (Read,Show)
datanewtypeNormal2= Mat4=!Vec4Normal2Vec4Vec2Vec4derivingVec4(Read,Show,(StorableRead,Show,DotProd)     ,Dimension)
newtype Normal3 = Normal3 Vec3 deriving (Read,Show,Storable,DotProd,Dimension)
newtype-- | The assumption when dealing with these is always that they are of unit length.Normal4 = Normal4 Vec4 deriving (Read,Show,Storable,DotProd,Dimension)
-- Also, interpolation works differently.
newtypemkVec2 ::(Flt,Flt= Normal2) -> Vec2 deriving (Read,Show,Storable,DotProd,Dimension)
newtypemkVec3 ::(Flt,Flt= Normal3,Flt) ->Vec3Vec3deriving (Read,Show,Storable,DotProd,Dimension)
newtypemkVec4 ::(Flt,Flt= Normal4,Flt,FltVec4) -> derivingVec4     (Read,Show,Storable,DotProd,Dimension)

mkVec2 ::(x,(Float)    ,Float= Vec2) ->x yVec2
mkVec3 ::(x,(Float,z)  ,Float= Vec3,Floatx y ) -> Vec3
mkVec4 ::(x,(Float,z,w),Float= Vec4,Floatx y ,Floatw   ) -> Vec4

mkVec2-- | Orthogonal matrices.x,y)     = Vec2 x y
mkVec3--     (x,y,z)   = Vec3 x y z
mkVec4-- Note: the "Random" instances generates orthogonal matrices with determinant 1x,y,z,w) = Vec4 x y z w
-- (that is, orientation-preserving orthogonal transformations)!
newtype-- | Orthogonal matrices.Ortho2 = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
--newtype Ortho3 = Ortho3 Mat3 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
newtype-- Note: the "Random" instances generates orthogonal matrices with determinant 1Ortho4 = Ortho4 Mat4 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
-- (that is, orientation-preserving orthogonal transformations)!
newtype-- | Projective matrices, encoding affine transformations in dimension one less. = Ortho2 Mat2 deriving (Read,Show,Storable,MultSemiGroup,Determinant,Dimension)
newtype Ortho3Proj3 ==Proj3Mat3deriving(Read(Read,Show,Show,Storable,Storable,MultSemiGroup,MultSemiGroup) ,Determinant,Dimension)
newtype Ortho4Proj4 ==Proj4Mat4deriving(Read(Read,Show,Show,Storable,Storable,MultSemiGroup,MultSemiGroup) ,Determinant,Dimension)

-- | Projective matrices, encoding affine transformations in dimension one less.
newtype-- Unit vectors = Proj3 Mat3 deriving (Read,Show,Storable,MultSemiGroup)
newtype Proj4 = Proj4 Mat4 deriving (Read,Show,Storable,MultSemiGroup)
instance UnitVector Vec2 Normal2 where
--------------------------------------------------------------------------------mkNormal v = Normal2 (normalize v)
-- Unit vectorsfromNormal (Normal2 v) = v
  toNormalUnsafe = Normal2
instance UnitVector Vec2 Normal2 where
instanceUnitVector = Normal2Vec3normalizeNormal3 where)
  fromNormalmkNormal v (Normal2Normal3v)normalize= v      v)
  toNormalUnsafefromNormal (Normal3= Normal2v) = v
  toNormalUnsafe = Normal3
instance UnitVector Vec3 Normal3 where
instanceUnitVector = Normal3Vec4normalizeNormal4 where)
  fromNormalmkNormal v (Normal3Normal4v)normalize= v      v)
  toNormalUnsafefromNormal (Normal4= Normal3v) = v
  toNormalUnsafe = Normal4
instance UnitVector Vec4 Normal4 where
_rndUnit::v(=RandomGen (normalize, Random vv)Vector v, DotProd v) => g -> (v,g)
_rndUnitg = (Normal4 v) = v
  toNormalUnsafeif d > 0.01    = Normal4
    then ( v &* (1.0/d) , h )
_rndUnitelse ::_rndUnitRandomGenh    g, Random v, Vector v, DotProd v) => g -> (v,g)
_rndUnitwhere  g =
  if(d,>)0.01= random g
    thend = norm v &*v  (1.0/d) , h )
    else _rndUnit h
instancewhere  Random Normal2 where
  randomv,h)g==randomlet (vgh) = _rndUnit g in (Normal2 v, h)
  randomR = norm_ =vrandom

instance Random Normal2 where
  random g = let (v,h) = _rndUnit g in (Normal2 v, h)
  randomR _ = random

instance Random Normal3 where
  random g = let (v,h) = _rndUnit g in (Normal3 v, h)
  randomR _ = random

instance RandomCrossProdNormal3wherewhere
  randomcrossprod =(letNormal3v,h))=(_rndUnitNormal3 wg in= mkNormalNormal4(vcrossprod, h)     v w)
  randomR _ = random
--------------------------------------------------------------------------------
instance-- Orthogonal matrices Normal3 where
  crossprod (Normal3 v) (Normal3 w) = mkNormal (crossprod v w)
instance Orthogonal Mat2 Ortho2 where
--------------------------------------------------------------------------------fromOrtho (Ortho2 o) = o
-- Orthogonal matricestoOrthoUnsafe = Ortho2

instance Orthogonal Mat2 Ortho2 where
  fromOrtho (Ortho2 o) = o
  toOrthoUnsafe = Ortho2

instance Orthogonal Mat3 Ortho3 where
  fromOrtho (Ortho3 o) = o
  toOrthoUnsafe = Ortho3

instance------   Orthogonal Mat4 Ortho4 where
  fromOrtho (Ortho4 o) = o
instanceMatrix =Ortho2where
  transpose (Ortho2 o) = Ortho2 (transpose o)
------idmtx = Ortho2 idmtx
  inverse = transpose
instance Matrix Ortho2 where
instanceMatrixOrtho2Ortho3) =where (transpose o)
  idmtxtranspose= Ortho2(Ortho3o) = Ortho3 (transpose o)
  inverseidmtx = =Ortho3idmtx
  inverse = transpose
instance Matrix Ortho3 where
instanceMatrixOrtho3Ortho4) =where (transpose o)
  idmtxtranspose= Ortho3(Ortho4o) = Ortho4 (transpose o)
  inverseidmtx = =Ortho4idmtx
  inverse = transpose
instance Matrix Ortho4 where
------ (Ortho4 o) = Ortho4 (transpose o)
  idmtx = Ortho4 idmtx
instanceRandom= transposeOrtho2 where
  random g = let (o,h) = _rndOrtho2 g in (toOrthoUnsafe (_flip1stRow2 o), h)
------randomR _ = random

instance Random Ortho2 where
  random g = let (o,h) = _rndOrtho2 g in (toOrthoUnsafe (_flip1stRow2 o), h)
  randomR _ = random

instance Random Ortho3 where
  random g = let (o,h) = _rndOrtho3 g in (toOrthoUnsafe (_flip1stRow4 o), h)
  randomR _ = random

instance------   Random Ortho4 where
  random g = let (o,h) = _rndOrtho4 g in (toOrthoUnsafe (_flip1stRow4 o), h)
-- determinant will be -1 _ = random
_rndOrtho2 :: RandomGen g => g -> (Mat2, g)
------_rndOrtho2 g = (h2, g1) where
  h2 = householder u2 :: Mat2
-- determinant will be -1(u2,g1) = random g
_rndOrtho2 :: RandomGen g => g -> (Mat2, g)
_rndOrtho2-- generates a uniformly random orthogonal 3x3 matrix = (h2, g1) where
-- /with determinant +1/, with respect to the Haar measure of SO3. = householder u2 :: Mat2
--(u2,g1) = random g
-- see Theorem 4 in:
-- generates a uniformly random orthogonal 3x3 matrix-- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groups
-- Notices of the AMS, May 2007 issue-- /with determinant +1/, with respect to the Haar measure of SO3.
---- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>
_rndOrtho3-- see Theorem 4 in::: RandomGen g => g -> (Mat3, g)
_rndOrtho3-- Francesco Mezzadri: How to Generate Random Matrices from the Classical Compact Groupsg = ( (h3 .*. m3), g2) where
-- Notices of the AMS, May 2007 issuem3 = (extendWith :: Flt -> Mat2 -> Mat3) 1 o2
-- <http://www.ams.org/notices/200705/fea-mezzadri-web.ps>h3 = householder u3 :: Mat3
_rndOrtho3(u3,g1) =::randomg    g => g -> (Mat3, g)
_rndOrtho3(o2,g2) =g_rndOrtho2= ( (h3 .*.g1m3), g2) where
  m3 = (extendWith :: Float -> Mat2 -> Mat3) 1 o2
-- determinant will be -1 = householder u3 :: Mat3
_rndOrtho4u3,g1) =::RandomGen    g => g -> (Mat4, g)
_rndOrtho4o2,g2) =g_rndOrtho2= ( (h4 .*.m4), g2) where
  m4 = (extendWith :: Flt -> Mat3 -> Mat4) 1 o3
-- determinant will be -1h4 = householder u4 :: Mat4
_rndOrtho4(u4,g1) =::randomg    g => g -> (Mat4, g)
_rndOrtho4(o3,g2) =g_rndOrtho3= ( (h4 .*.g1m4), g2) where
  m4 = (extendWith :: Float -> Mat3 -> Mat4) 1 o3
------ = householder u4 :: Mat4
  (u4,g1) = random g
_flip1stRow2o3,g2) = _rndOrtho3:: Mat2 ->g1Mat2
_flip1stRow2 (Mat2 a b) = Mat2 (neg a) b
------
_flip1stRow3 :: Mat3 -> Mat3
_flip1stRow2 ::(Mat3a ->b cMat2) = Mat3 (neg a) b c
_flip1stRow2 (Mat2 a b) = Mat2 (neg a) b
_flip1stRow4 :: Mat4 -> Mat4
_flip1stRow3 ::(Mat4a ->b cMat3d) = Mat4 (neg a) b c d
_flip1stRow3 (Mat3 a b c) = Mat3 (neg a) b c
--------------------------------------------------------------------------------
_flip1stRow4-- projective matrices:: Mat4 -> Mat4
_flip1stRow4 (Mat4 a b c d) = Mat4 (neg a) b c d
instance Projective Vec2 Mat2 Ortho2 Mat3 Proj3 where
--------------------------------------------------------------------------------fromProjective (Proj3 m) = m
-- projective matricestoProjectiveUnsafe = Proj3
  orthogonal = Proj3 . extendWith 1 . fromOrtho
instancelinear Projective= Proj3Vec2. extendWith Ortho21  Mat3 Proj3 where
  fromProjectivetranslation v =(Proj3 m)Mat3= m (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
  toProjectiveUnsafescaling     v = Proj3= Proj3$ diag (extendWith 1 v)
  orthogonal = Proj3 . extendWith 1 . fromOrtho
instance Projective= Proj3Vec3 extendWithMat3 Ortho3  Mat4 Proj4 where
  translationfromProjective =(Proj3 $)Mat3= m (Vec3 1 0 0) (Vec3 0 1 0) (extendWith 1 v)
  scalingtoProjectiveUnsafe = Proj3= Proj4 diag (extendWith 1 v)
  orthogonal = Proj4 . extendWith 1 . fromOrtho
instancelinear Projective= Proj4Vec3. extendWith Ortho31  Mat4 Proj4 where
  fromProjectivetranslation v =(Proj4 m)Mat4= m (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
  toProjectiveUnsafescaling     v = Proj4= Proj4$ diag (extendWith 1 v)
  orthogonal = Proj4 . extendWith 1 . fromOrtho
instance Matrix= Proj4Proj3.where 1
  translationidmtx = Proj3 =idmtx $ Mat4 (Vec4 1 0 0 0) (Vec4 0 1 0 0) (Vec4 0 0 1 0) (extendWith 1 v)
  scalingtranspose (Proj3 = Proj4m) = $Proj3((transposeextendWithm)1 v)
  inverse = _invertProj3
instance Matrix Proj3 where
instance =Matrix idmtx where
  transposeidmtx = Proj4Proj3idmtx) = Proj3 (transpose m)
  inversetranspose= _invertProj3(Proj4 m) = Proj4 (transpose m)
  inverse = _invertProj4
instance Matrix Proj4 where
_invertProj3 = Proj4:: idmtx -> Proj3
_invertProj3 (Proj4(Proj3m)mat=@Proj4(Mat3 (transpose_ t)) =  m)
  inverseProj3 $ =Mat3(extendZero a) (extendZero b) (extendWith 1 t')
  where
_invertProj3t' = neg ::$ (Proj3trim t->::Proj3Vec2) .* invm2
_invertProj3invm2@(Mat2Proj3a b)mat= @inverse(Mat3 _$_(ttrim)) =mat :: Mat2)
  Proj3 $ Mat3 (extendZero a) (extendZero b) (extendWith 1 t')
-- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.where
-- We assume that the bottom-right corner is 1. = neg $ (trim t :: Vec2) .* invm2
_invertProj4@(Mat2:: aProj4) =->Proj4 $ (trim mat :: Mat2)
_invertProj4 (Proj4 mat@(Mat4 _ _ _ t)) =
-- Inverts a projective 4x4 matrix. But you can simply use "inverse" instead.Proj4 $ Mat4 (extendZero a) (extendZero b) (extendZero c) (extendWith 1 t')
-- We assume that the bottom-right corner is 1.where
_invertProj4t' = neg ::$ (Proj4trim t->::Proj4Vec3) .* invm3
_invertProj4invm3@(Mat3Proj4a b matc) @(Mat4inverse _$_(ttrim)) =mat :: Mat3)
  Proj4 $ Mat4 (extendZero a) (extendZero b) (extendZero c) (extendWith 1 t')
--------------------------------------------------------------------------------where
-- Vec2 instances = neg $ (trim t :: Vec3) .* invm3
    invm3@(Mat3 a b c) = inverse $ (trim mat :: Mat3)
instance HasCoordinates Vec2 Flt where
--------------------------------------------------------------------------------_1 (Vec2 x _) = x
-- Vec2 instances_2 (Vec2 _ y) = y
  _3 _ = error "has only 2 coordinates"
instance_4 _ = HasCoordinateserror "has only 2 coordinates" Float where
  _1 (Vec2 x _) = x
instance (Vec2AbelianGroup y) = y   Vec2 where
  _3(&+_ =Vec2x1"has only 2 coordinates"y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
  _4(&-_ =Vec2x1"has only 2 coordinates"y1) (Vec2 x2 y2) = Vec2 (x1-x2) (y1-y2)
  neg  (Vec2 x y)                = Vec2 (-x) (-y)
instancezero = AbelianGroupVec2 0 0     Vec2 where
  (&+) (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1+x2) (y1+y2)
instance&-) (Vec2Vector y1Vec2) (Vec2wherex2 y2) = Vec2 (x1-x2) (y1-y2)
  negscalarMulVec2sx(yVec2)   x y) = Vec2 (=*Vec2x) (s(-x) (-y)
  zeromapVec= Vec2f 0Vec2   x y) = Vec2 (f x) (f y)

instance VectorDotProdVec2Vec2wherewhere
  scalarMul(&.) (Vec2sx1Vec2y1) xVec2) =x2y2)(s*xx1)*(x2s*y)y1*y2
  mapVec    f (Vec2 x y) = Vec2 (f x) (f y)
instance Pointwise Vec2 where
instancepointwise(Vec2Vec2x1 y1where) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)
  (&.) (Vec2 x1 y1) (Vec2 x2 y2) = x1*x2 + y1*y2
instance Determinant (Vec2,Vec2) where
instancedet (Vec2x1 y1 ,Vec2Vec2wherex2 y2) = x1*y2 - x2*y1
  pointwise (Vec2 x1 y1) (Vec2 x2 y2) = Vec2 (x1*x2) (y1*y2)
{-
instance Show Vec2 where
  show (Vec2 x y) = "( " ++ show x ++ " , " ++ show y ++ " )"
-} Determinant (Vec2,Vec2) where
  det (Vec2 x1 y1 , Vec2 x2 y2) = x1*y2 - x2*y1

{-
instance Show Vec2 where
  show (Vec2 x y) = "( " ++ show x ++ " , " ++ show y ++ " )"
-}instance Random Vec2 where
  random = randomR (Vec2 (-1) (-1),Vec2 1 1)
  randomR (Vec2 a b, Vec2 c d) gen =
    let (x,gen1) = randomR (a,c) gen
instance(Randomy,gen2)Vec2= randomRwhere (b,d) gen1
  randomin (Vec2= randomRx y, gen2Vec2)  (-1) (-1),Vec2 1 1)
  randomR (Vec2 a b, Vec2 c d) gen =
instance (xStorable,gen1) =Vec2wherea,c) gen
   sizeOf(y,gen2_ =)2=*randomRsizeOf (bundefined,d) gen1::Flt)
      alignmentin (Vec2_x=y,sizeOf)(undefined::Flt)

instancepeek q Storable= do     Vec2 where
  sizeOflet p = _castPtr= 2 * sizeOfq :: PtrundefinedFlt     ::Float)
  alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
    x <- peek        p
  peeky <- =peekByteOff        p k
    letreturn =(castPtrVec2 x yq :: Ptr Float
        k = sizeOf (undefined::Float)
  poke <-q peek(Vec2 x y) =pdo
    ylet<-ppeekByteOff= castPtr qp:: Ptr Flt
    returnk =(Vec2sizeOf y)undefined::Flt)
    poke        p   x
  pokepokeByteOff (Vec2 xpy) = do
    let p = castPtr q :: Ptr Float
instancekDimension= sizeOf (Vec2undefinedwhere::dimFloat_ ) 2
    poke        p   x
-------------------------------------------------------------------------------- p k y
-- Mat2 instances
instance Dimension Vec2 where dim _ = 2
instance HasCoordinates Mat2 Vec2 where
--------------------------------------------------------------------------------_1 (Mat2 x _) = x
-- Mat2 instances_2 (Mat2 _ y) = y
  _3 _ = error "has only 2 coordinates"
instance_4 _ = HasCoordinateserror "has only 2 coordinates" Vec2 where
  _1 (Mat2 x _) = x
instance (Mat2Matrix y) =Mat2  where
  _3transpose = error(Mat2row1 row2) =
  _4Mat2 = error(Vec2 "has only 2 coordinates"(_1 row1) (_1 row2))
         (Vec2 (_2 row1) (_2 row2))
instanceidmtx =MatrixMat2 (Mat2 where1 0) (Vec2 0 1)
  transposeinverse (Mat2Mat2(Vec2arow2b) )Vec2=   c d)) =
    Mat2 (Vec2 (_1d*rrow1) (-)*(_1)) row2(Vec2))(-c*r) (a*r))
    where(Vec2r = 1.0_2/row1(a*) (_2b*row2c)  ))
  idmtx = Mat2 (Vec2 1 0) (Vec2 0 1)
instanceAbelianGroupMat2 (Vec2 aMat2) (whereVec2 c d)) =
  (&+) (Mat2Vec2r1(dr2*r)((Mat2-b*r)s1) (s2Vec2) = (Mat2-c*r)r1a*&+r))s1) (r2 &+ s2)
  (&-where) (Mat2 =r1r2/ (aMat2*d -s1*cs2)) = Mat2 (r1 &- s1) (r2 &- s2)
  neg  (Mat2 r1 r2)              = Mat2 (neg r1) (neg r2)
instancezero = AbelianGroupMat2 zero zero where
  (&+) (Mat2 r1 r2) (Mat2 s1 s2) = Mat2 (r1 &+ s1) (r2 &+ s2)
instance&-) (Mat2Vector r2Mat2) (Mat2wheres1 s2) = Mat2 (r1 &- s1) (r2 &- s2)
  negscalarMulMat2sr1(Mat2) r1 r2) = Mat2=(Mat2g r1)(neg(g r2))whereneg r2g ) scalarMul s
  zeromapVec= Mat2f zero(Mat2zeror1 r2) = Mat2 (g r1) (g r2) where g = mapVec f

instance VectorMultSemiGroup whereMat2 where
  scalarMul(.*.) (Mat2 (r1Mat2r2)r1n r2= ) = Mat2 (g r1) (g r2) where g = scalarMul s
  mapVeclet (Mat2 (c1Mat2c2)r1= r2transpose) = Mat2n(g r1) (g r2) where g = mapVec f
    in Mat2 (Vec2 (r1 &. c1) (r1 &. c2))
instance MultSemiGroup(Vec2 (r2 &.c1)where(r2 &. c2))
  (one.*.) (idmtxMat2 r1 r2) n =
    let (Mat2 c1 c2) = transpose n
instancein Mat2RingVec2Mat2(r1 &. c1) (r1 &. c2))
            (Vec2 (r2 &. c1) (r2 &. c2))
instance = idmtxLeftModule Mat2 Vec2 where
  lmul (Mat2 row1 row2) v = Vec2 (row1 &. v) (row2 &. v)
instance Ring Mat2
instance RightModule Vec2 Mat2 where
instancermul v LeftModulemt = lmul (Mat2transpose wheremt) v
  lmul (Mat2 row1 row2) v = Vec2 (row1 &. v) (row2 &. v)
instance Diagonal Vec2 Mat2 where
instancediag (Vec2x y) = Mat2(Mat2 wherex 0) (Vec2 0 y)
  rmul v mt = lmul (transpose mt) v
instance Tensor Mat2 Vec2 where
instanceouter (DiagonalVec2 a b)Vec2(Vec2x ywhere) = Mat2
  diag(Vec2Vec2(a*x)y)a=yMat2))   (Vec2 x 0) (Vec2 0 y)
    (Vec2 (b*x) (b*y))
instance Tensor Mat2 Vec2 where
instance (Vec2Determinant b) (Vec2Mat2xwhere) = Mat2
  detVec2(Mat2a*xVec2) (a*y)) (Vec2 c d)) = a*d - b*c
    (Vec2 (b*x) (b*y))
{-
instance Show Mat2 where
  show (Mat2 r1 r2) = show r1 ++ "\n" ++ show r2
-} Determinant Mat2 where
  det (Mat2 (Vec2 a b) (Vec2 c d)) = a*d - b*c

{-
instance Show Mat2 where
  show (Mat2 r1 r2) = show r1 ++ "\n" ++ show r2
-}instance Storable Mat2 where
  sizeOf    _ = 2 * sizeOf (undefined::Vec2)
  alignment _ = alignment  (undefined::Vec2)

instancepeek q Storable= do     Mat2 where
  sizeOflet p = _castPtr= 2 * sizeOfq :: PtrundefinedVec2    ::Vec2)
  alignmentk = _sizeOf= alignment(undefinedundefined::Vec2) ::Vec2)
    r1 <- peek        p
  peekr2 q<-=peekByteOff         p k
    letreturn =(castPtrMat2 r1 qr2::)  Ptr Vec2
        k = sizeOf (undefined::Vec2)
  poke <-q (peek r1 r2) p do
    r2let<-p peekByteOff= castPtr q p::kPtr Vec2
    returnk =(Mat2sizeOf(r2undefined)      ::Vec2)
    poke        p   r1
  pokepokeByteOff (Mat2 r1p r2k )r2= do
    let p = castPtr q :: Ptr Vec2
instancekRandom= sizeOfMat2undefinedwhere   ::Vec2)
  random = randomR  (r1Mat2 v1 v1 , Mat2 v2 v2) where
    pokeByteOffv1 = Vec2 (-p)k(r2-1)
    v2 = Vec2   1    1
instancerandomRRandom(Mat2 Mat2a b, whereMat2 c d) gen =
  randomlet (=,randomRgen1) = (randomRMat2 v1(v1a,c, Mat2gen  v2 v2) where
    v1 =(Vec2y,gen2-1) (randomR-1)    (b,d) gen1
    v2 =Mat2x y1 gen2)
  randomR (Mat2 a b, Mat2 c d) gen =
instance (xDimension,gen1) = randomRMat2 wherea,cdim) gen_ = 2
         (y,gen2) = randomR (b,d) gen1
    instancein (Mat2MatrixNorms y, gen2Mat2)   where
  frobeniusNorm (Mat2 r1 r2) =
instancesqrt Dimension$         Mat2 where dim _ = 2
      normsqr r1 +
instancenormsqrr2     Mat2 where
  frobeniusNorm (Mat2 r1 r2) =
instance $Pointwise Mat2 where
  pointwise(Mat2 +x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)
      normsqr r2
--------------------------------------------------------------------------------
instance-- Vec3 instances Mat2 where
  pointwise (Mat2 x1 y1) (Mat2 x2 y2) = Mat2 (x1 &! x2) (y1 &! y2)
instance HasCoordinates Vec3 Flt where
--------------------------------------------------------------------------------_1 (Vec3 x _ _) = x
-- Vec3 instances_2 (Vec3 _ y _) = y
  _3 (Vec3 _ _ z) = z
instance_4 _ = HasCoordinateserror "has only 3 coordinates" Float where
  _1 (Vec3 x _ _) = x
instance (Vec3AbelianGroup y _) = y Vec3 where
  _3(&+(Vec3(Vec3 _x1z)y1=z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
  _4(&-_ =Vec3x1"has only 3 coordinates"y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
  neg  (Vec3 x y z)                    = Vec3 (-x) (-y) (-z)
instancezero = AbelianGroupVec3 0 0 0   Vec3 where
  (&+) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1+x2) (y1+y2) (z1+z2)
instance&-) (Vec3Vector y1Vec3)whereVec3 x2 y2 z2) = Vec3 (x1-x2) (y1-y2) (z1-z2)
  negscalarMulVec3sx(yVec3) x y z) = Vec3 (s*x)=(Vec3s*y) (-x))(-y) (-z)
  zeromapVec= Vec3f 0Vec3 0 x y z) = Vec3 (f x) (f y) (f z)

instance VectorDotProdVec3Vec3wherewhere
  scalarMul(&.) (Vec3sx1Vec3y1 z1)y(zVec3) = Vec3x2 y2(sz2*x)=(sx1*y)x2(s*zy1)*y2 + z1*z2
  mapVec    f (Vec3 x y z) = Vec3 (f x) (f y) (f z)
instance Pointwise Vec3 where
instancepointwise(Vec3Vec3x1 y1wherez1) (Vec3 x2 y2 z2) = Vec3 (x1*x2) (y1*y2) (z1*z2)
  (&.) (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = x1*x2 + y1*y2 + z1*z2
{-
instance Show Vec3 where
  show (Vec3 x y z) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " )"
-} Pointwise Vec3 where
  pointwise (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (x1*x2) (y1*y2) (z1*z2)

{-
instance Show Vec3 where
  show (Vec3 x y z) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " )"
-}instance Random Vec3 where
  random = randomR (Vec3 (-1) (-1) (-1),Vec3 1 1 1)
  randomR (Vec3 a b c, Vec3 d e f) gen =
    let (x,gen1) = randomR (a,d) gen
instance(Randomy,gen2)Vec3= randomRwhere (b,e) gen1
  random(=,randomRgen3) = (randomRVec3 (-1),(-1)gen2-1),Vec3 1 1 1)
  randomRin (Vec3Vec3x yazb cgen3, Vec3)   d e f) gen =
    let (x,gen1) = randomR (a,d) gen
instance(yCrossProd,gen2) = randomRVec3 whereb,e) gen1
  crossprodz,gen3(Vec3) =x1y1 z1)(c,Vec3f) gen2x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)
    in (Vec3 x y z, gen3)
instance Determinant (Vec3,Vec3,Vec3) where
instancedet (u,CrossProdv,w) = u &.(v where&^ w)
  crossprod (Vec3 x1 y1 z1) (Vec3 x2 y2 z2) = Vec3 (y1*z2-y2*z1) (z1*x2-z2*x1) (x1*y2-x2*y1)
instance Storable Vec3 where
instancesizeOf Determinant_ = 3 * sizeOfVec3,Vec3(undefined,Vec3)::whereFlt)
  detalignmentu,v,w) = usizeOf (v(&^undefined)    ::Flt)

instancepeek q Storable= do     Vec3 where
  sizeOflet p = _castPtr= 3 * sizeOfq :: PtrundefinedFlt     ::Float)
  alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
    x <- peek        p
  peeky <- =peekByteOff        p (k  )
    letz <-ppeekByteOff= castPtr qp::(kPtr+k) Float
    return =(sizeOfVec3 x (undefinedz)      ::Float)
    x <- peek        p
  poke <-q peekByteOff(Vec3 x y z)p=(kdo )
    zlet<-ppeekByteOff= castPtr qp::k+Ptrk) Flt
    returnk =(Vec3sizeOf yundefined)      ::Flt)
    poke        p       x
  pokepokeByteOff (Vec3 xpy(z) = doy
    letpokeByteOff = castPtrp (kqk::) zPtr Float
        k = sizeOf (undefined::Float)
instance Dimension  Vec3 xwhere dim _ = 3
    pokeByteOff p (k  ) y
-------------------------------------------------------------------------------- p (k+k) z
-- Mat3 instances
instance Dimension Vec3 where dim _ = 3
instance HasCoordinates Mat3 Vec3 where
--------------------------------------------------------------------------------_1 (Mat3 x _ _) = x
-- Mat3 instances_2 (Mat3 _ y _) = y
  _3 (Mat3 _ _ z) = z
instance_4 _ = HasCoordinateserror "has only 3 coordinates" Vec3 where
  _1 (Mat3 x _ _) = x
instance (Mat3Matrix y _)Mat3= ywhere
  _3 (Mat3 _ _ z) = z
  _4transpose = error(Mat3row1 row2 row3) =
    Mat3 (Vec3 (_1 row1) (_1 row2) (_1 row3))
instance Matrix(Vec3 (Mat3_2 row1where) (_2 row2) (_2 row3))
         (Vec3 (_3 row1) (_3 row2) (_3 row3))
  transpose (Mat3 row1 row2 row3) =
  idmtx=(Vec3 (_1Vec31 ) (_1) (row2)0(_11 0row3) (Vec3))  0 0 1)
         (Vec3 (_2 row1) (_2 row2) (_2 row3))
  inverse(Vec3(Mat3(_3(Vec3a)b(_3c) row2(Vec3) (_3f row3g) ()Vec3)   i j k)) =
    Mat3 (Vec3 (d11*r) (d21*r) (d31*r))
  idmtx =(Mat3 (Vec3d12*r1 0d22)*(Vec3) (d32*1)0) (Vec3 0 0 1)
         (Vec3 (d13*r) (d23*r) (d33*r))
  inversewhere (Mat3 (Vec3 a b c) (Vec3 e f g) (Vec3 i j k)) =
    Mat3r =(Vec31.0 /(d11( a*rd11) (d21+ b*rd12) (d31+ c*rd13)) )
         (Vec3 (d12*r) (d22*r) (d32*r))
      d11(Vec3= f*k(d13- g*r) (d23*r) (d33*r))
    whered12 = g*i - e*k
      rd13= 1.0= e*/ ( a*d11i   + b*d12 + c*d13 )

      d11 = f*k - g*j
      d12 = g*i - e*k
      d13 = e*j - f*i

      d31 = b*g - c*f
      d32 = c*e - a*g
      d33 = a*f - b*e

instanceAbelianGroup= c*j - b*k Mat3 where
  (&+)d22(Mat3= a*r1k -r2c*r3i) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
  (&-)d23(Mat3= b*r1i -r2a*r3j) (Mat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
  neg  (Mat3 r1 r2 r3)                 = Mat3 (neg r1) (neg r2) (neg r3)
instancezero = AbelianGroupMat3 zero zerozerowhere
  (&+) (Mat3 r1 r2 r3) (Mat3 s1 s2 s3) = Mat3 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3)
instance&-) (Mat3Vector r2Mat3)whereMat3 s1 s2 s3) = Mat3 (r1 &- s1) (r2 &- s2) (r3 &- s3)
  negscalarMulMat3sr1(Mat3 r3r1) r2 r3) = Mat3 (g=r1) (g(negr2) r1(g)r3neg) where) ( neg= scalarMul)      s
  zeromapVec= Mat3f zero(Mat3zeror1 r2r3) = Mat3 (g r1) (g r2) (g r3) where g = mapVec f

instance VectorMultSemiGroup whereMat3 where
  scalarMul(.*.) (Mat3 (r1Mat3r2 r1)r2n r3= ) = Mat3 (g r1) (g r2) (g r3) where g = scalarMul s
  mapVeclet (Mat3 (c1Mat3c2 r1)r2= r3transpose) = Mat3n(g r1) (g r2) (g r3) where g = mapVec f
    in Mat3 (Vec3 (r1 &. c1) (r1 &. c2) (r1 &. c3))
instance MultSemiGroup(Vec3 (r2 &.c1)where(r2 &. c2) (r2 &. c3))
  (.*.) (Mat3(Vec3 r2(r3)&.nc1=) (r3 &. c2) (r3 &. c3))
  one= (idmtxMat3 c1 c2 c3) = transpose n
     in Mat3 (Vec3 (r1 &. c1) (r1 &. c2) (r1 &. c3))
 instance RingVec3Mat3(r2 &. c1) (r2 &. c2) (r2 &. c3))
             (Vec3 (r3 &. c1) (r3 &. c2) (r3 &. c3))
instance = idmtxLeftModule Mat3 Vec3 where
  lmul (Mat3 row1 row2 row3) v = Vec3 (row1 &. v) (row2 &. v) (row3 &. v)
instance Ring Mat3
instance RightModule Vec3 Mat3 where
instancermul v LeftModulemt = lmul (Mat3transpose wheremt) v
  lmul (Mat3 row1 row2 row3) v = Vec3 (row1 &. v) (row2 &. v) (row3 &. v)
instance Diagonal Vec3 Mat3 where
instancediag (Vec3x y z) =Vec3Mat3Mat3(Vec3wherex 0 0) (Vec3 0 y 0) (Vec3 0 0 z)
  rmul v mt = lmul (transpose mt) v
instance Tensor Mat3 Vec3 where
instanceouter (DiagonalVec3 a b Vec3c) (Vec3xwherey z) = Mat3
  diag(Vec3Vec3(a*x)y(z)y= Mat3(a*z)(Vec3 x 0 0) (Vec3 0 y 0) (Vec3 0 0 z)
    (Vec3 (b*x) (b*y) (b*z))
instance(Vec3Tensor(c*x) Mat3(c*y)Vec3(c*zwhere))
  outer (Vec3 a b c) (Vec3 x y z) = Mat3
instanceVec3Determinanta*x) (a*y)Mat3a*z)where)
  detVec3(Mat3b*r1x)r2b*r3y) (b*detz))(r1,r2,r3)
    (Vec3 (c*x) (c*y) (c*z))
{-
instance Show Mat3 where
  show (Mat3 r1 r2 r3) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3
-} Determinant Mat3 where
  det (Mat3 r1 r2 r3) = det (r1,r2,r3)

{-
instance Show Mat3 where
  show (Mat3 r1 r2 r3) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3
-}instance Storable Mat3 where
  sizeOf    _ = 3 * sizeOf (undefined::Vec3)
  alignment _ = alignment  (undefined::Vec3)

instancepeek q Storable= do     Mat3 where
  sizeOflet p = _castPtr= 3 * sizeOfq :: PtrundefinedVec3    ::Vec3)
  alignmentk = _sizeOf= alignment(undefinedundefined::Vec3) ::Vec3)
    r1 <- peek        p
  peekr2 q<-=peekByteOff         p (k  )
    letr3 <- =peekByteOff q ::p (Ptrk+k)Vec3
    return =(sizeOfMat3 r1(undefinedr2 r3)   ::Vec3)
    r1 <- peek        p
  poke <-q (peekByteOffMat3 r1 r2 r3)(k do)
    r3let<-p peekByteOff= castPtr q p::(kPtr+k)Vec3
    returnk =(Mat3sizeOf(r2undefined)   ::Vec3)
    poke        p       r1
  pokepokeByteOff (Mat3 r1p r2(k r3))r2= do
    letpokeByteOff = castPtrp (kqk::) r3 Vec3
        k = sizeOf (undefined::Vec3)
instance Random pMat3 where
  random= randomR (kMat3) r2v1 v1 v1 , Mat3 v2 v2 v2) where
    pokeByteOffv1 = Vec3 (-p)(k+k) r3(-1)
    v2 = Vec3   1    1    1
instancerandomRRandom(Mat3 Mat3a b cwhere, Mat3 d e f) gen =
  randomlet (=,randomRgen1) = (randomRMat3 v1(v1a,dv1) gen, Mat3 v2 v2 v2) where
    v1 =(Vec3y,gen2-1) (randomR-1) (-1)b,e) gen1
    v2 =(Vec3z,gen3)1= randomR    1(c,f) gen2
  randomRin (Mat3Mat3x yazb cgen3, Mat3)   d e f) gen =
    let (x,gen1) = randomR (a,d) gen
instance(yDimension,gen2) = randomRMat3 whereb,edim) gen1_ = 3
        (z,gen3) = randomR (c,f) gen2
instancein (Mat3MatrixNorms y z, gen3Mat3) where
  frobeniusNorm (Mat3 r1 r2 r3)  =
instancesqrt Dimension$         Mat3 where dim _ = 3
      normsqr r1 +
instancenormsqrr2 +   Mat3 where
  frobeniusNormnormsqr r3(Mat3 r1 r2 r3)  =
    sqrt $
instancePointwise + Mat3 where
  pointwise(Mat3 +x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)
      normsqr r3
--------------------------------------------------------------------------------
instance-- Vec4 instances Mat3 where
  pointwise (Mat3 x1 y1 z1) (Mat3 x2 y2 z2) = Mat3 (x1 &! x2) (y1 &! y2) (z1 &! z2)
instance HasCoordinates Vec4 Flt where
--------------------------------------------------------------------------------_1 (Vec4 x _ _ _) = x
-- Vec4 instances_2 (Vec4 _ y _ _) = y
  _3 (Vec4 _ _ z _) = z
instance_4 (Vec4_ _ _ w) = w Vec4 Float where
  _1 (Vec4 x _ _ _) = x
instance (Vec4AbelianGroup y _ _) = yVec4 where
  _3(&+(Vec4(Vec4 _x1zy1)z1= zw1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
  _4(&-(Vec4(Vec4 _x1_y1)z1= ww1) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
  neg  (Vec4 x y z w)                        = Vec4 (-x) (-y) (-z) (-w)
instancezero = AbelianGroupVec4 0 0 0 0 Vec4 where
  (&+) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1+x2) (y1+y2) (z1+z2) (w1+w2)
instance&-) (Vec4Vector y1Vec4where) (Vec4 x2 y2 z2 w2) = Vec4 (x1-x2) (y1-y2) (z1-z2) (w1-w2)
  negscalarMulVec4sx(yVec4 w) y z w) = Vec4 (s*x) (s*=)Vec4(s*z(-x)*(-y) (-z) (-w)
  zeromapVec= Vec4f 0Vec4 0 0 y z w) = Vec4 (f x) (f y) (f z) (f w)

instance VectorDotProdVec4Vec4wherewhere
  scalarMul(&.) (Vec4sx1Vec4y1 z1 yw1z w)Vec4= Vec4x2 y2s*z2x)w2s*y)x1s*x2z)+(sy1*w)y2 + z1*z2 + w1*w2
  mapVec    f (Vec4 x y z w) = Vec4 (f x) (f y) (f z) (f w)
instance Pointwise Vec4 where
instancepointwise(Vec4Vec4x1 y1wherez1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1*x2) (y1*y2) (z1*z2) (w1*w2)
  (&.) (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = x1*x2 + y1*y2 + z1*z2 + w1*w2
{-
instance Show Vec4 where
  show (Vec4 x y z w) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " , " ++ show w ++ " )"
-} Pointwise Vec4 where
  pointwise (Vec4 x1 y1 z1 w1) (Vec4 x2 y2 z2 w2) = Vec4 (x1*x2) (y1*y2) (z1*z2) (w1*w2)

{-
instance Show Vec4 where
  show (Vec4 x y z w) = "( " ++ show x ++ " , " ++ show y ++ " , " ++ show z ++ " , " ++ show w ++ " )"
-}instance Random Vec4 where
  random = randomR (Vec4 (-1) (-1) (-1) (-1),Vec4 1 1 1 1)
  randomR (Vec4 a b c d, Vec4 e f g h) gen =
    let (x,gen1) = randomR (a,e) gen
instance(Randomy,gen2)Vec4= randomRwhere (b,f) gen1
  random(=,randomRgen3) = (randomRVec4 (-1),(-1)gen2-1) (-1),Vec4 1 1 1 1)
  randomR(w(Vec4)a=brandomR d, Vec4(d,e)fgen3 h) gen =
    letin ((Vec4x,gen1x ) = randomRw, gen4)(a,e) gen
        (y,gen2) = randomR (b,f) gen1
instance(zStorable,gen3) =Vec4wherec,g) gen2
  sizeOf(w,gen4_ =)4=*randomRsizeOf (dundefined,h) gen3::Flt)
  alignmentin (Vec4_x=ysizeOf w, gen4(undefined)      ::Flt)

instancepeek q Storable= do     Vec4 where
  sizeOflet p = _castPtr= 4 * sizeOfq :: PtrundefinedFlt     ::Float)
  alignmentk = _sizeOf= sizeOf(undefinedundefined::Flt::)Float)
    x <- peek        p
  peeky <- =peekByteOff        p (k  )
    letz <-ppeekByteOff= castPtr qp::(kPtr+k) Float
    w <-kpeekByteOff= sizeOf (undefinedp (3*k) ::Float)
    xreturn<- peek(Vec4 x y p w)
    y <- peekByteOff p (k  )
  poke <-q peekByteOff(Vec4 x y z p)(k+kdo)
    wlet<-ppeekByteOff= castPtr qp::3*Ptrk) Flt
    returnk =(Vec4sizeOf yundefined w)    ::Flt)
    poke        p       x
  pokepokeByteOff (Vec4 xpy(z w) = do
    letpokeByteOff = castPtrp (kqk::) zPtr Float
    pokeByteOff = sizeOfp ((undefined*k) w    ::Float)
    poke        p       x
instanceDimension (kVec4) ywhere dim _ = 4
    pokeByteOff p (k+k) z
-------------------------------------------------------------------------------- p (3*k) w
-- Mat4 instances
instance Dimension Vec4 where dim _ = 4
instance HasCoordinates Mat4 Vec4 where
--------------------------------------------------------------------------------_1 (Mat4 x _ _ _) = x
-- Mat4 instances_2 (Mat4 _ y _ _) = y
  _3 (Mat4 _ _ z _) = z
instance_4 (Mat4_ _ _ w) = w Mat4 Vec4 where
  _1 (Mat4 x _ _ _) = x
instance (Mat4Matrix y _Mat4) =where
  _3transposeMat4 _(_Mat4 _)row1= zrow2 row3 row4) =
  _4Mat4Mat4(Vec4 _ __1)row1= w) (_1 row2) (_1 row3) (_1 row4))
         (Vec4 (_2 row1) (_2 row2) (_2 row3) (_2 row4))
instance Matrix(Vec4 (Mat4_3 row1where) (_3 row2) (_3 row3) (_3 row4))
  transpose(Vec4Mat4(_4row1row1row2) (_4row3row2row4) (_4) =row3) (_4 row4))
  idmtx=(Vec4 (_1Vec41 ) (_10)row2(Vec4) (_10 1row30 0) (_1Vec40 ))1 0) (Vec4 0 0 0 1)
  inverse(Vec4= error_2"inverse/Mat4: not implemented yet") (_2 row2) (_2 row3) (_2 row4))
         (Vec4 (_3 row1) (_3 row2) (_3 row3) (_3 row4))
instance (AbelianGroupVec4 (_4 row1Mat4) (_4where) (_4 row3) (_4 row4))
  idmtx(&+) (=Mat4r1(Vec4r2 r31r4)0(0Mat4) (Vec4s1 s2 1s30s4) (Vec4Mat40(0r11&+)s1Vec4) (r20&+ 0s21)(r3 &+ s3) (r4 &+ s4)
  inverse(&-) (Mat4= errorr1 r2"inverse/Mat4: not implemented yet"r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
  neg  (Mat4 r1 r2 r3 r4)                    = Mat4 (neg r1) (neg r2) (neg r3) (neg r4)
instancezero = AbelianGroupMat4 zero zerozerowherezero
  (&+) (Mat4 r1 r2 r3 r4) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &+ s1) (r2 &+ s2) (r3 &+ s3) (r4 &+ s4)
instance&-) (Mat4Vector r2Mat4where) (Mat4 s1 s2 s3 s4) = Mat4 (r1 &- s1) (r2 &- s2) (r3 &- s3) (r4 &- s4)
  negscalarMulMat4sr1(Mat4 r3r1r4r2) r3 r4) = Mat4 (g r1= Mat4(g r2(neg(g r1) (negg r4r2) )whereneggr3=)scalarMulneg r4) s
  zeromapVec= Mat4f zero(Mat4zeror1 r2r3 zeror4) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = mapVec f

instance VectorMultSemiGroup whereMat4 where
  scalarMul(.*.) (Mat4 (r1Mat4r2 r1 r2)r3n r4= ) = Mat4 (g r1) (g r2) (g r3) (g r4) where g = scalarMul s
  mapVeclet (Mat4 (c1Mat4c2 r1 r2)r3= r4transpose) = Mat4n(g r1) (g r2) (g r3) (g r4) where g = mapVec f
    in Mat4 (Vec4 (r1 &. c1) (r1 &. c2) (r1 &. c3) (r1 &. c4))
instance MultSemiGroup(Vec4 (r2 &.c1)where(r2 &. c2) (r2 &. c3) (r2 &. c4))
  (.*.) (Mat4(Vec4 r2(r3&.)c1n =r3 &. c2) (r3 &. c3) (r3 &. c4))
    let (Mat4(Vec4 c2(r4&.)c1= transpose(r4 &. c2)n(r4 &. c3) (r4 &. c4))
  onein=Mat4idmtxVec4 (r1 &. c1) (r1 &. c2) (r1 &. c3) (r1 &. c4))
            (Vec4 (r2 &. c1) (r2 &. c2) (r2 &. c3) (r2 &. c4))
instance RingVec4Mat4(r3 &. c1) (r3 &. c2) (r3 &. c3) (r3 &. c4))
            (Vec4 (r4 &. c1) (r4 &. c2) (r4 &. c3) (r4 &. c4))
instance = idmtxLeftModule Mat4 Vec4 where
  lmul (Mat4 row1 row2 row3 row4) v = Vec4 (row1 &. v) (row2 &. v) (row3 &. v) (row4 &. v)
instance Ring Mat4
instance RightModule Vec4 Mat4 where
instancermul v LeftModulemt = lmul (Mat4transpose wheremt) v
  lmul (Mat4 row1 row2 row3 row4) v = Vec4 (row1 &. v) (row2 &. v) (row3 &. v) (row4 &. v)
instance Diagonal Vec4 Mat4 where
instancediag (Vec4x y z w)Vec4= Mat4(Vec4wherex 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)
  rmul v mt = lmul (transpose mt) v
instance Tensor Mat4 Vec4 where
instanceouter (DiagonalVec4 a b Vec4c d) Mat4(Vec4wherex y z w) = Mat4
  diag(Vec4Vec4(a*x)y(z*w) =aMat4*z) ((Vec4*w)) x 0 0 0) (Vec4 0 y 0 0) (Vec4 0 0 z 0) (Vec4 0 0 0 w)
    (Vec4 (b*x) (b*y) (b*z) (b*w))
instance(Vec4Tensor(c*x) Mat4(c*y)Vec4(c*zwhere) (c*w))
  outer(Vec4Vec4(d*xa bdcyd)((Vec4*z) (x*y)z w) = Mat4
    (Vec4 (a*x) (a*y) (a*z) (a*w))
instanceVec4Determinantb*x) (b*y)Mat4b*z)whereb*w))
  detVec4= errorc*x)"det/Mat4: not implemented yet"c*y) (c*z) (c*w))
  -- det (Mat4 r1 r2 r3 r4) =Vec4 (d*x) (d*y) (d*z) (d*w))

instance{-
instance Show Mat4 where
  show (Mat4 r1 r2 r3 r4) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3 ++ "\n" ++ show r4
-}        Mat4 where
  det = error "det/Mat4: not implemented yet"
  -- det (Mat4 r1 r2 r3 r4) =

{-
instance Show Mat4 where
  show (Mat4 r1 r2 r3 r4) = show r1 ++ "\n" ++ show r2 ++ "\n" ++ show r3 ++ "\n" ++ show r4
-}instance Storable Mat4 where
  sizeOf    _ = 4 * sizeOf (undefined::Vec4)
  alignment _ = alignment  (undefined::Vec4)

instancepeek q Storable= do     Mat4 where
  sizeOflet p = _castPtr= 4 * sizeOfq :: PtrundefinedVec4    ::Vec4)
  alignmentk = _sizeOf= alignment(undefinedundefined::Vec4) ::Vec4)
    r1 <- peek        p
  peekr2 q<-=peekByteOff         p (k  )
    letr3 <- =peekByteOff q ::p (Ptrk+k)Vec4
    r4 <- =peekByteOff (undefinedp (3*k)::Vec4)
    r1return<- peek(Mat4 r1 r2pr3 r4)
    r2 <- peekByteOff p (k  )
  poke <-q (peekByteOffMat4 r1 r2 r3 (r4k+k) do
    r4let<-p peekByteOff= castPtr q p::(3Ptr*k)Vec4
    returnk =(Mat4sizeOf(r2undefined r4)::Vec4)
    poke        p       r1
  pokepokeByteOff (Mat4 r1p r2(k r3) r4) = do
    letpokeByteOff = castPtrp (kqk::) r3 Vec4
    pokeByteOff = sizeOfp ((undefined*k) r4   ::Vec4)
    poke        p       r1
instanceRandom pMat4k where) r2
  random= randomR (k+Mat4k) r3v1 v1 v1 v1, Mat4 v2 v2 v2 v2) where
    pokeByteOffv1 = Vec4 (-p)(3*k) r4(-1) (-1)
    v2 = Vec4   1    1    1    1
instancerandomRRandom(Mat4 Mat4a b cwhered, Mat4 e f g h) gen =
  randomlet (=,randomRgen1) = (randomRMat4 v1(v1a,ev1) gen, Mat4 v2 v2 v2 v2) where
    v1 =(Vec4y,gen2-1) (randomR-1) (-1)b(-1)gen1
    v2 =(Vec4z,gen3)1= randomR    1(c,g1 gen2
  randomR(w(Mat4)a=brandomR d, Mat4(d,e)fgen3 h) gen =
    letin ((Mat4x,gen1x ) = randomRw, gen4)(a,e) gen
        (y,gen2) = randomR (b,f) gen1
instance(zDimension,gen3) = randomRMat4 wherec,gdim) gen2_ = 4
        (w,gen4) = randomR (d,h) gen3
instancein (Mat4MatrixNorms y z w,Mat4)where
  frobeniusNorm (Mat4 r1 r2 r3 r4) =
instancesqrt Dimension$         Mat4 where dim _ = 4
      normsqr r1 +
instancenormsqrr2 +   Mat4 where
  frobeniusNormnormsqr r3(Mat4+    r1 r2 r3 r4) =
    sqrtnormsqr    r4
      normsqr r1 +
instancePointwise + Mat4 where
  pointwise(Mat4 +x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)
      normsqr r4
--------------------------------------------------------------------------------
instance-- Extend instances Mat4 where
  pointwise (Mat4 x1 y1 z1 w1) (Mat4 x2 y2 z2 w2) = Mat4 (x1 &! x2) (y1 &! y2) (z1 &! z2) (w1 &! w2)
instance Extend Vec2 Vec3 where
--------------------------------------------------------------------------------extendZero   (Vec2 x y) = Vec3 x y 0
-- Extend instancesextendWith t (Vec2 x y) = Vec3 x y t
  trim (Vec3 x y _)       = Vec2 x y
instance Extend Vec2 Vec3 where
instanceExtend(Vec2 xVec4) =where x y 0
  extendWith t (Vec2 x y) = Vec3 x y t 0
  trimextendWithVec3 x yVec2)  x y) = Vec2 x y t t

</pre>