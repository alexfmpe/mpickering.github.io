<a href="Gitson.hs8933518161505795335.out.html">prev</a></br><a href="failures.html">home</a></br><a href="GL.hs11909597451912844175.out.html">next</a></br></br><pre>17c17
< data Thing = Thing { val ∷ Int } deriving (Eq, Show, Ord)
---
> data Thing = Thing { val :: Int } deriving (Eq, Show, Ord)
20c20
< spec ∷ Spec
---
> spec :: Spec
31c31
<           first ← readFile "things/first-thing.json"
---
>           first <- readFile "things/first-thing.json"
33c33
<           second ← readFile "things/second-thing.json"
---
>           second <- readFile "things/second-thing.json"
35c35
<           commitMsg ← lastCommitText
---
>           commitMsg <- lastCommitText
44c44
<           first ← readFile "things/000001-hello.json"
---
>           first <- readFile "things/000001-hello.json"
46c46
<           second ← readFile "things/000002-world.json"
---
>           second <- readFile "things/000002-world.json"
52c52
<         _ ← liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
---
>         _ <- liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
56c56
<           second ← readFile "things/000004-second-thing.json"
---
>           second <- readFile "things/000004-second-thing.json"
62c62
<         _ ← liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
---
>         _ <- liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
66c66
<           second ← readFile "things/000004-second-thing.json"
---
>           second <- readFile "things/000004-second-thing.json"
72d71
<       _ ← writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
73c72
<       content ← readDocument "tmp/repo/things" "second-thing" ∷ IO (Maybe Thing)
---
>       _ <- writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
73a73
>       content <- readDocument "tmp/repo/things" "second-thing" :: IO (Maybe Thing)
77c77
<       content ← readDocument "tmp/repo/things" "totally-not-a-thing" ∷ IO (Maybe Thing)
---
>       content <- readDocument "tmp/repo/things" "totally-not-a-thing" :: IO (Maybe Thing)
83d82
<       _ ← writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
84c83
<       content ← readDocumentById "tmp/repo/things" 4 ∷ IO (Maybe Thing)
---
>       _ <- writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
84a84
>       content <- readDocumentById "tmp/repo/things" 4 :: IO (Maybe Thing)
88c88
<       content ← readDocumentById "tmp/repo/things" 1 ∷ IO (Maybe Thing)
---
>       content <- readDocumentById "tmp/repo/things" 1 :: IO (Maybe Thing)
94d93
<       _ ← writeFile "tmp/repo/things/000098-second-thing.json" "{\"val\":1}"
95c94
<       content ← readDocumentByName "tmp/repo/things" "second-thing" ∷ IO (Maybe Thing)
---
>       _ <- writeFile "tmp/repo/things/000098-second-thing.json" "{\"val\":1}"
95a95
>       content <- readDocumentByName "tmp/repo/things" "second-thing" :: IO (Maybe Thing)
99c99
<       content ← readDocumentByName "tmp/repo/things" "yolo" ∷ IO (Maybe Thing)
---
>       content <- readDocumentByName "tmp/repo/things" "yolo" :: IO (Maybe Thing)
105d104
<       _ ← writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
106c105
<       i ← documentIdFromName "tmp/repo/things" "some-thing"
---
>       _ <- writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
106a106
>       i <- documentIdFromName "tmp/repo/things" "some-thing"
110c110
<       i ← documentIdFromName "tmp/repo/things" "yolo"
---
>       i <- documentIdFromName "tmp/repo/things" "yolo"
116d115
<       _ ← writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
117c116
<       i ← documentNameFromId "tmp/repo/things" 98
---
>       _ <- writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
117a117
>       i <- documentNameFromId "tmp/repo/things" 98
121c121
<       i ← documentNameFromId "tmp/repo/things" 123
---
>       i <- documentNameFromId "tmp/repo/things" 123
127d126
<       _ ← writeFile "tmp/repo/things/first-thing.json" "{}"
128d126
<       _ ← writeFile "tmp/repo/things/second-thing.json" "{}"
129c127
<       list ← listDocumentKeys "tmp/repo/things"
---
>       _ <- writeFile "tmp/repo/things/first-thing.json" "{}"
129a128
>       _ <- writeFile "tmp/repo/things/second-thing.json" "{}"
129a129
>       list <- listDocumentKeys "tmp/repo/things"
133c133
<       list ← listDocumentKeys "nonsense"
---
>       list <- listDocumentKeys "nonsense"
139d138
<       _ ← writeFile "tmp/repo/things/first-thing.json" "{\"val\":1}"
140d138
<       _ ← writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
141c139
<       list ← listEntries "tmp/repo/things" ∷ IO [Thing]
---
>       _ <- writeFile "tmp/repo/things/first-thing.json" "{\"val\":1}"
141a140
>       _ <- writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
141a141
>       list <- listEntries "tmp/repo/things" :: IO [Thing]
145c145
<       list ← listEntries "nonsense" ∷ IO [Thing]
---
>       list <- listEntries "nonsense" :: IO [Thing]
153c153
<         list ← listCollections
---
>         list <- listCollections
159c159
<         list ← listCollections
---
>         list <- listCollections
162c162
< setup ∷ IO ()
---
> setup :: IO ()
165d164
< cleanup ∷ ActionWith ()
166c165
< cleanup () = void (try (removeDirectoryRecursive "tmp/repo") ∷ IO (Either IOException ()))
---
> cleanup :: ActionWith ()
166a166
> cleanup () = void (try (removeDirectoryRecursive "tmp/repo") :: IO (Either IOException ()))
166a167
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell, UnicodeSyntax #-}

module GitsonSpec (spec) where

import           Test.Hspec
import           System.Directory
import           Data.Aeson.TH
import           Data.List (sort)
import           Control.Exception
import           Control.Monad.IO.Class
import           Control.Monad (void)
import           Gitson
import           Gitson.Util (insideDirectory, lastCommitText)

{-# ANN module ("HLint: ignore Redundant do" :: String) #-}

data Thing = Thing { val ∷ Int } deriving (Eq, Show, Ord)
$(deriveJSON defaultOptions ''Thing)

spec ∷ Spec
spec = before setup $ after cleanup $ do
  context "transaction" $ do
    describe "saveDocument" $ do
      it "saves entries only after it's done" $ do
        transaction "tmp/repo" $ do
          saveDocument "things" "first-thing" Thing {val = 1}
          saveDocument "things" "second-thing" Thing {val = 2}
          liftIO $ readFile "things/first-thing.json" `shouldThrow` anyIOException
          liftIO $ readFile "things/second-thing.json" `shouldThrow` anyIOException
        insideDirectory "tmp/repo" $ do
          first ← readFile "things/first-thing.json"
          first `shouldBe` "{\n  \"val\": 1\n}"
          second ← readFile "things/second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"
          commitMsg ← lastCommitText
          commitMsg `shouldBe` "Gitson transaction"

    describe "saveNextDocument" $ do
      it "saves entries with next numeric ids" $ do
        transaction "tmp/repo" $ do
          saveNextDocument "things" "hello" Thing {val = 1}
          saveNextDocument "things" "world" Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          first ← readFile "things/000001-hello.json"
          first `shouldBe` "{\n  \"val\": 1\n}"
          second ← readFile "things/000002-world.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

    describe "saveDocumentById" $ do
      it "updates an entry by specified id" $ do
        createDirectoryIfMissing True "tmp/repo/things"
        _ ← liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
        transaction "tmp/repo" $ do
          saveDocumentById "things" 4 Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          second ← readFile "things/000004-second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

    describe "saveDocumentByName" $ do
      it "updates an entry by specified name" $ do
        createDirectoryIfMissing True "tmp/repo/things"
        _ ← liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
        transaction "tmp/repo" $ do
          saveDocumentByName "things" "second-thing" Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          second ← readFile "things/000004-second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

  describe "readDocument" $ do
    it "returns Just the document when reading an document by key" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
      content ← readDocument "tmp/repo/things" "second-thing" ∷ IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 2}

    it "returns Nothing when reading by a nonexistent key" $ do
      content ← readDocument "tmp/repo/things" "totally-not-a-thing" ∷ IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "readDocumentById" $ do
    it "returns Just the document when reading an document by id" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
      content ← readDocumentById "tmp/repo/things" 4 ∷ IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 1}

    it "returns Nothing when reading by a nonexistent id" $ do
      content ← readDocumentById "tmp/repo/things" 1 ∷ IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "readDocumentByName" $ do
    it "returns Just the document when reading an document by name" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/000098-second-thing.json" "{\"val\":1}"
      content ← readDocumentByName "tmp/repo/things" "second-thing" ∷ IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 1}

    it "returns Nothing when reading by a nonexistent name" $ do
      content ← readDocumentByName "tmp/repo/things" "yolo" ∷ IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "documentIdFromName" $ do
    it "returns Just the document id from the document's name" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
      i ← documentIdFromName "tmp/repo/things" "some-thing"
      i `shouldBe` Just 98

    it "returns Nothing when run with a nonexistent name" $ do
      i ← documentIdFromName "tmp/repo/things" "yolo"
      i `shouldBe` Nothing

  describe "documentNameFromId" $ do
    it "returns Just the document name from the document's id" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
      i ← documentNameFromId "tmp/repo/things" 98
      i `shouldBe` Just "some-thing"

    it "returns Nothing when run with a nonexistent id" $ do
      i ← documentNameFromId "tmp/repo/things" 123
      i `shouldBe` Nothing

  describe "listDocumentKeys" $ do
    it "returns a list of document keys when listing a collection" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/first-thing.json" "{}"
      _ ← writeFile "tmp/repo/things/second-thing.json" "{}"
      list ← listDocumentKeys "tmp/repo/things"
      sort list `shouldBe` ["first-thing", "second-thing"]

    it "returns an empty when listing a nonexistent collection" $ do
      list ← listDocumentKeys "nonsense"
      list `shouldBe` []

  describe "listEntries" $ do
    it "returns a list of entries when listing a collection" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ ← writeFile "tmp/repo/things/first-thing.json" "{\"val\":1}"
      _ ← writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
      list ← listEntries "tmp/repo/things" ∷ IO [Thing]
      sort list `shouldBe` [Thing {val = 1}, Thing {val = 2}]

    it "returns an empty list when listing a nonexistent collection" $ do
      list ← listEntries "nonsense" ∷ IO [Thing]
      list `shouldBe` []

  describe "listCollections" $ do
    it "returns a list of collections" $ do
      createDirectoryIfMissing True "tmp/repo/bits"
      createDirectoryIfMissing True "tmp/repo/pieces"
      insideDirectory "tmp/repo" $ do
        list ← listCollections
        sort list `shouldBe` ["bits", "pieces"]

    it "returns an empty list when listing an empty repo" $ do
      createDirectoryIfMissing True "tmp/repo"
      insideDirectory "tmp/repo" $ do
        list ← listCollections
        sort list `shouldBe` []

setup ∷ IO ()
setup = createRepo "tmp/repo"

cleanup ∷ ActionWith ()
cleanup () = void (try (removeDirectoryRecursive "tmp/repo") ∷ IO (Either IOException ()))
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell, UnicodeSyntax #-}

module GitsonSpec (spec) where

import           Test.Hspec
import           System.Directory
import           Data.Aeson.TH
import           Data.List (sort)
import           Control.Exception
import           Control.Monad.IO.Class
import           Control.Monad (void)
import           Gitson
import           Gitson.Util (insideDirectory, lastCommitText)

{-# ANN module ("HLint: ignore Redundant do" :: String) #-}

data Thing = Thing { val :: Int } deriving (Eq, Show, Ord)
$(deriveJSON defaultOptions ''Thing)

spec :: Spec
spec = before setup $ after cleanup $ do
  context "transaction" $ do
    describe "saveDocument" $ do
      it "saves entries only after it's done" $ do
        transaction "tmp/repo" $ do
          saveDocument "things" "first-thing" Thing {val = 1}
          saveDocument "things" "second-thing" Thing {val = 2}
          liftIO $ readFile "things/first-thing.json" `shouldThrow` anyIOException
          liftIO $ readFile "things/second-thing.json" `shouldThrow` anyIOException
        insideDirectory "tmp/repo" $ do
          first <- readFile "things/first-thing.json"
          first `shouldBe` "{\n  \"val\": 1\n}"
          second <- readFile "things/second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"
          commitMsg <- lastCommitText
          commitMsg `shouldBe` "Gitson transaction"

    describe "saveNextDocument" $ do
      it "saves entries with next numeric ids" $ do
        transaction "tmp/repo" $ do
          saveNextDocument "things" "hello" Thing {val = 1}
          saveNextDocument "things" "world" Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          first <- readFile "things/000001-hello.json"
          first `shouldBe` "{\n  \"val\": 1\n}"
          second <- readFile "things/000002-world.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

    describe "saveDocumentById" $ do
      it "updates an entry by specified id" $ do
        createDirectoryIfMissing True "tmp/repo/things"
        _ <- liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
        transaction "tmp/repo" $ do
          saveDocumentById "things" 4 Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          second <- readFile "things/000004-second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

    describe "saveDocumentByName" $ do
      it "updates an entry by specified name" $ do
        createDirectoryIfMissing True "tmp/repo/things"
        _ <- liftIO $ writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
        transaction "tmp/repo" $ do
          saveDocumentByName "things" "second-thing" Thing {val = 2}
        insideDirectory "tmp/repo" $ do
          second <- readFile "things/000004-second-thing.json"
          second `shouldBe` "{\n  \"val\": 2\n}"

  describe "readDocument" $ do
    it "returns Just the document when reading an document by key" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
      content <- readDocument "tmp/repo/things" "second-thing" :: IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 2}

    it "returns Nothing when reading by a nonexistent key" $ do
      content <- readDocument "tmp/repo/things" "totally-not-a-thing" :: IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "readDocumentById" $ do
    it "returns Just the document when reading an document by id" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/000004-second-thing.json" "{\"val\":1}"
      content <- readDocumentById "tmp/repo/things" 4 :: IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 1}

    it "returns Nothing when reading by a nonexistent id" $ do
      content <- readDocumentById "tmp/repo/things" 1 :: IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "readDocumentByName" $ do
    it "returns Just the document when reading an document by name" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/000098-second-thing.json" "{\"val\":1}"
      content <- readDocumentByName "tmp/repo/things" "second-thing" :: IO (Maybe Thing)
      content `shouldBe` Just Thing {val = 1}

    it "returns Nothing when reading by a nonexistent name" $ do
      content <- readDocumentByName "tmp/repo/things" "yolo" :: IO (Maybe Thing)
      content `shouldBe` Nothing

  describe "documentIdFromName" $ do
    it "returns Just the document id from the document's name" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
      i <- documentIdFromName "tmp/repo/things" "some-thing"
      i `shouldBe` Just 98

    it "returns Nothing when run with a nonexistent name" $ do
      i <- documentIdFromName "tmp/repo/things" "yolo"
      i `shouldBe` Nothing

  describe "documentNameFromId" $ do
    it "returns Just the document name from the document's id" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/000098-some-thing.json" "THIS SHOULD NOT BE READ"
      i <- documentNameFromId "tmp/repo/things" 98
      i `shouldBe` Just "some-thing"

    it "returns Nothing when run with a nonexistent id" $ do
      i <- documentNameFromId "tmp/repo/things" 123
      i `shouldBe` Nothing

  describe "listDocumentKeys" $ do
    it "returns a list of document keys when listing a collection" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/first-thing.json" "{}"
      _ <- writeFile "tmp/repo/things/second-thing.json" "{}"
      list <- listDocumentKeys "tmp/repo/things"
      sort list `shouldBe` ["first-thing", "second-thing"]

    it "returns an empty when listing a nonexistent collection" $ do
      list <- listDocumentKeys "nonsense"
      list `shouldBe` []

  describe "listEntries" $ do
    it "returns a list of entries when listing a collection" $ do
      createDirectoryIfMissing True "tmp/repo/things"
      _ <- writeFile "tmp/repo/things/first-thing.json" "{\"val\":1}"
      _ <- writeFile "tmp/repo/things/second-thing.json" "{\"val\":2}"
      list <- listEntries "tmp/repo/things" :: IO [Thing]
      sort list `shouldBe` [Thing {val = 1}, Thing {val = 2}]

    it "returns an empty list when listing a nonexistent collection" $ do
      list <- listEntries "nonsense" :: IO [Thing]
      list `shouldBe` []

  describe "listCollections" $ do
    it "returns a list of collections" $ do
      createDirectoryIfMissing True "tmp/repo/bits"
      createDirectoryIfMissing True "tmp/repo/pieces"
      insideDirectory "tmp/repo" $ do
        list <- listCollections
        sort list `shouldBe` ["bits", "pieces"]

    it "returns an empty list when listing an empty repo" $ do
      createDirectoryIfMissing True "tmp/repo"
      insideDirectory "tmp/repo" $ do
        list <- listCollections
        sort list `shouldBe` []

setup :: IO ()
setup = createRepo "tmp/repo"

cleanup :: ActionWith ()
cleanup () = void (try (removeDirectoryRecursive "tmp/repo") :: IO (Either IOException ()))

</pre>