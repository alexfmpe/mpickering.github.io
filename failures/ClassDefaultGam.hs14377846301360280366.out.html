<a href="ClassDefaultCollisionConfiguration.hs14951700531616927224.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ClassDevice.hs1212054001284660444.out.html">next</a></br></br><pre>21c21
< {-# LINE 32 "src/ehc/Gam/ClassDefaultGam.chs" #-}
---
> 
21a22
> 
21a23
> 
21a24
> 
21a25
> 
21a26
> 
21a27
> 
21a28
> 
21a29
> 
21a30
> 
21a31
> 
29c39
< {-# LINE 43 "src/ehc/Gam/ClassDefaultGam.chs" #-}
---
> 
29a40
> 
29a41
> 
29a42
> 
32c45
< {-# LINE 51 "src/ehc/Gam/ClassDefaultGam.chs" #-}
---
> 
32a46
> 
32a47
> 
32a48
> 
32a49
> 
32a50
> 
50c68
< {-# LINE 74 "src/ehc/Gam/ClassDefaultGam.chs" #-}
---
> 
50a69
> 
50a70
> 
50a71
> 
50a72
> 
50a73
> 
54a78
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Gam.ClassDefaultGam
( ClassDefaultGamInfo (..)
, ClassDefaultGam
, clDfGamLookupDefault )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty.FitsInCommon2
import UHC.Light.Compiler.Ty.FitsIn
import Data.Maybe
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize



{-# LINE 32 "src/ehc/Gam/ClassDefaultGam.chs" #-}
-- If this changes, also change {%{EH}ConfigInternalVersions}
data ClassDefaultGamInfo
  = ClassDefaultGamInfo
      { cldiDefaultTypes    :: [Ty]
      }
      deriving (Data,Typeable)

{-# LINE 43 "src/ehc/Gam/ClassDefaultGam.chs" #-}
type ClassDefaultGam = Gam HsName ClassDefaultGamInfo

{-# LINE 51 "src/ehc/Gam/ClassDefaultGam.chs" #-}
-- | Lookup a matching default for a predicate
clDfGamLookupDefault
  :: ( VarLookup gm TyVarId VarMpInfo
     -- , VarLookup gm Ty VarMpInfo
     , VarLookupCmb VarMp gm
     )
     => FIIn' gm -> Pred -> ClassDefaultGam
     -> Maybe VarMp
clDfGamLookupDefault fi pr clDfGam
  = case pr of
      Pred_Class t | isJust mbConArgs
        -> do (ClassDefaultGamInfo {cldiDefaultTypes = (tg:_)}) <- gamLookup nm clDfGam
              (_,tyVarMp) <- fitPredIntoPred fi pr (Pred_Class $ appCon1App nm tg)
              return tyVarMp
        where mbConArgs@(~(Just (nm,args))) = appMbConApp t
      _ -> Nothing

{-# LINE 74 "src/ehc/Gam/ClassDefaultGam.chs" #-}
instance Serialize ClassDefaultGamInfo where
  sput (ClassDefaultGamInfo a) = sput a
  sget = liftM ClassDefaultGamInfo sget

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Gam.ClassDefaultGam
( ClassDefaultGamInfo (..)
, ClassDefaultGam
, clDfGamLookupDefault )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Gam
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty.FitsInCommon2
import UHC.Light.Compiler.Ty.FitsIn
import Data.Maybe
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize














-- If this changes, also change {%{EH}ConfigInternalVersions}
data ClassDefaultGamInfo
  = ClassDefaultGamInfo
      { cldiDefaultTypes    :: [Ty]
      }
      deriving (Data,Typeable)





type ClassDefaultGam = Gam HsName ClassDefaultGamInfo







-- | Lookup a matching default for a predicate
clDfGamLookupDefault
  :: ( VarLookup gm TyVarId VarMpInfo
     -- , VarLookup gm Ty VarMpInfo
     , VarLookupCmb VarMp gm
     )
     => FIIn' gm -> Pred -> ClassDefaultGam
     -> Maybe VarMp
clDfGamLookupDefault fi pr clDfGam
  = case pr of
      Pred_Class t | isJust mbConArgs
        -> do (ClassDefaultGamInfo {cldiDefaultTypes = (tg:_)}) <- gamLookup nm clDfGam
              (_,tyVarMp) <- fitPredIntoPred fi pr (Pred_Class $ appCon1App nm tg)
              return tyVarMp
        where mbConArgs@(~(Just (nm,args))) = appMbConApp t
      _ -> Nothing







instance Serialize ClassDefaultGamInfo where
  sput (ClassDefaultGamInfo a) = sput a
  sget = liftM ClassDefaultGamInfo sget


</pre>