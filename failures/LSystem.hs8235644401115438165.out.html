<a href="LSystem.hs2035308228158374933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="LSystems.hs178448449274243042.out.html">next</a></br></br><pre>14c14
< data LSystem m = LSystem [LPrim m] (m -> [LPrim m])
---
> data LSystem m = LSystem [       ] (  -> [       ])
16c16
< data LPrim m = LPrim m | LStack [LPrim m]
---
> data LPrim m = LPrim   | LStack [       ]
24c24
< derive :: (m -> [LPrim m]) -> LPrim m -> [LPrim m]
---
> derive :: (  -> [       ]) ->         -> [       ]
31c31
< derivations :: LSystem m -> [ [LPrim m] ]
---
> derivations ::           -> [ [       ] ]
39c39
< interprete :: (m -> [LPrim TurtleModule]) -> [m] -> [LPrim TurtleModule]
---
> interprete :: (  -> [                  ]) -> [ ] -> [                  ]
44c44
< interpretations :: (m -> [LPrim TurtleModule]) -> [[LPrim m]] -> [[LPrim TurtleModule]]
---
> interpretations :: (  -> [                  ]) -> [[       ]] -> [[                  ]]
49a50
> 
</pre></br><h2>original</h2></br><pre>module LSystem (
  LSystem (..),
  LPrim (..),

  derivations,
  interprete,
  interpretations
  ) where

import Turtle


-- LSystem module = LSystem axiom ableitungsregeln
data LSystem m = LSystem [LPrim m] (m -> [LPrim m])

data LPrim m = LPrim m | LStack [LPrim m]



-------------------------------------------------------------------------------


-- Einzelnes, primitives Modul ableiten
derive :: (m -> [LPrim m]) -> LPrim m -> [LPrim m]
derive rules x = case x of
  LPrim p  -> rules p
  LStack s -> [LStack $ concatMap (derive rules) s]


-- Erzeugt Liste aller Ableitungen eines L-Systems
derivations :: LSystem m -> [ [LPrim m] ]
derivations (LSystem startword rules) = derivations'
  where
    derivations' = startword : map (concatMap $ derive rules) derivations'


-- Übersetzt ein Wort von Modulen des Typs m in ein Wort von Modulen des Typs
-- TurtleModule
interprete :: (m -> [LPrim TurtleModule]) -> [m] -> [LPrim TurtleModule]
interprete = concatMap


-- Wendet interprete auf eine Liste von Modulworten an
interpretations :: (m -> [LPrim TurtleModule]) -> [[LPrim m]] -> [[LPrim TurtleModule]]
interpretations rules = map (interprete intPrim)
  where
    intPrim x = case x of
      LPrim p  -> rules p
      LStack s -> [LStack $ (interprete intPrim) s]
</pre></br><h2>printed</h2></br><pre>module LSystem (
  LSystem (..),
  LPrim (..),

  derivations,
  interprete,
  interpretations
  ) where

import Turtle


-- LSystem module = LSystem axiom ableitungsregeln
data LSystem m = LSystem [       ] (  -> [       ])

data LPrim m = LPrim   | LStack [       ]



-------------------------------------------------------------------------------


-- Einzelnes, primitives Modul ableiten
derive :: (  -> [       ]) ->         -> [       ]
derive rules x = case x of
  LPrim p  -> rules p
  LStack s -> [LStack $ concatMap (derive rules) s]


-- Erzeugt Liste aller Ableitungen eines L-Systems
derivations ::           -> [ [       ] ]
derivations (LSystem startword rules) = derivations'
  where
    derivations' = startword : map (concatMap $ derive rules) derivations'


-- Übersetzt ein Wort von Modulen des Typs m in ein Wort von Modulen des Typs
-- TurtleModule
interprete :: (  -> [                  ]) -> [ ] -> [                  ]
interprete = concatMap


-- Wendet interprete auf eine Liste von Modulworten an
interpretations :: (  -> [                  ]) -> [[       ]] -> [[                  ]]
interpretations rules = map (interprete intPrim)
  where
    intPrim x = case x of
      LPrim p  -> rules p
      LStack s -> [LStack $ (interprete intPrim) s]

</pre>