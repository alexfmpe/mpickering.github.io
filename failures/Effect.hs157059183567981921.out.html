<a href="Effect.hs1264627439947712914.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Effect.hs3247357991078626766.out.html">next</a></br></br><pre>21c21
<    type Inv m f g = ()
---
>         Inv m f g   ()
38a39
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE KindSignatures, TypeFamilies, ConstraintKinds, PolyKinds, MultiParamTypeClasses #-}

module Control.Effect where

import Control.Effect.Helpers.Set
import Prelude hiding (Monad(..))
import GHC.Prim


{-| Specifies "parametric effect monads" which are essentially monads but
     annotated by a type-level monoid formed by 'Plus' and 'Unit' -}
class Effect (m :: k -> * -> *) where

   {-| Effect of a trivially effectful computation |-}
   type Unit m :: k
   {-| Cominbing effects of two subcomputations |-}
   type Plus m (f :: k) (g :: k) :: k

   {-| 'Inv' provides a way to give instances of 'Effect' their own constraints for '>>=' -}
   type Inv m (f :: k) (g :: k) :: Constraint
   type Inv m f g = ()

   {-| Effect-parameterised version of 'return'. Annotated with the 'Unit m' effect,
    denoting pure compuation -}
   return :: a -> m (Unit m) a

   {-| Effect-parameterise version of '>>=' (bind). Combines
    two effect annotations 'f' and 'g' on its parameter computations into 'Plus' -}
   (>>=) :: (Inv m f g) => m f a -> (a -> m g b) -> m (Plus m f g) b

   (>>) :: (Inv m f g) => m f a -> m g b -> m (Plus m f g) b
   x >> y = x >>= (\_ -> y)

fail = undefined

{-| Specifies subeffecting behaviour -}
class Subeffect (m :: k -> * -> *) f g where
    sub :: m f a -> m g a
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE KindSignatures, TypeFamilies, ConstraintKinds, PolyKinds, MultiParamTypeClasses #-}

module Control.Effect where

import Control.Effect.Helpers.Set
import Prelude hiding (Monad(..))
import GHC.Prim


{-| Specifies "parametric effect monads" which are essentially monads but
     annotated by a type-level monoid formed by 'Plus' and 'Unit' -}
class Effect (m :: k -> * -> *) where

   {-| Effect of a trivially effectful computation |-}
   type Unit m :: k
   {-| Cominbing effects of two subcomputations |-}
   type Plus m (f :: k) (g :: k) :: k

   {-| 'Inv' provides a way to give instances of 'Effect' their own constraints for '>>=' -}
   type Inv m (f :: k) (g :: k) :: Constraint
        Inv m f g   ()

   {-| Effect-parameterised version of 'return'. Annotated with the 'Unit m' effect,
    denoting pure compuation -}
   return :: a -> m (Unit m) a

   {-| Effect-parameterise version of '>>=' (bind). Combines
    two effect annotations 'f' and 'g' on its parameter computations into 'Plus' -}
   (>>=) :: (Inv m f g) => m f a -> (a -> m g b) -> m (Plus m f g) b

   (>>) :: (Inv m f g) => m f a -> m g b -> m (Plus m f g) b
   x >> y = x >>= (\_ -> y)

fail = undefined

{-| Specifies subeffecting behaviour -}
class Subeffect (m :: k -> * -> *) f g where
    sub :: m f a -> m g a

</pre>