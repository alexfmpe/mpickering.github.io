<a href="Internal.hs771515668357571490.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Internal.hs907225550605925150.out.html">next</a></br></br><pre>65c65
< type Lens σ τ α β = Functor φ ⇒ (α → φ β) → σ → φ τ
---
> type Lens σ τ α β = Functor φ => (α -> φ β) -> σ -> φ τ
74c74
< lens ∷ (σ → α) → (σ → β → τ) → Lens σ τ α β
---
> lens :: (σ -> α) -> (σ -> β -> τ) -> Lens σ τ α β
78c78
< over ∷ ((α → Identity β) → σ → Identity τ) → (α → β) → σ → τ
---
> over :: ((α -> Identity β) -> σ -> Identity τ) -> (α -> β) -> σ -> τ
82c82
< set ∷ ((α → Identity β) → σ → Identity τ) → β → σ → τ
---
> set :: ((α -> Identity β) -> σ -> Identity τ) -> β -> σ -> τ
86c86
< view ∷ MonadReader σ μ ⇒ ((α → Const α α) → σ → Const α σ) → μ α
---
> view :: MonadReader σ μ => ((α -> Const α α) -> σ -> Const α σ) -> μ α
95c95
< type Iso σ τ α β = (Profunctor π, Functor φ) ⇒ π α (φ β) → π σ (φ τ)
---
> type Iso σ τ α β = (Profunctor π, Functor φ) => π α (φ β) -> π σ (φ τ)
98c98
< iso ∷ (σ → α) → (β → τ) → Iso σ τ α β
---
> iso :: (σ -> α) -> (β -> τ) -> Iso σ τ α β
105c105
< (&) ∷ α → (α → β) → β
---
> (&) :: α -> (α -> β) -> β
109c109
< (<&>) ∷ Functor φ ⇒ φ α → (α → β) → φ β
---
> (<&>) :: Functor φ => φ α -> (α -> β) -> φ β
114d113
<     ∷ (Show α, IsString τ)
115d113
<     ⇒ α
116c114
<     → τ
---
>     :: (Show α, IsString τ)
116a115
>     => α
116a116
>     -> τ
121d120
<     ∷ Monad μ
122d120
<     ⇒ (ε → μ β)
123d120
<     → (α → μ β)
124d120
<     → ExceptT ε μ α
125c121
<     → μ β
---
>     :: Monad μ
125a122
>     => (ε -> μ β)
125a123
>     -> (α -> μ β)
125a124
>     -> ExceptT ε μ α
125a125
>     -> μ β
130d129
<     ∷ Monad μ
131d129
<     ⇒ ExceptT T.Text μ α
132d129
<     → μ α
133c130
< errorT = exceptT (\e → error ∘ T.unpack $ "Error: " ⊕ e) return
---
>     :: Monad μ
133a131
>     => ExceptT T.Text μ α
133a132
>     -> μ α
133a133
> errorT = exceptT (\e -> error ∘ T.unpack $ "Error: " ⊕ e) return
136c136
< fmapL ∷ (α → β) → Either α γ → Either β γ
---
> fmapL :: (α -> β) -> Either α γ -> Either β γ
139a140
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RankNTypes #-}

-- |
-- Module: Configuration.Utils.Interal
-- Description: Internal utilities of the configuration-tools package
-- Copyright: Copyright © 2014-2015 PivotCloud, Inc.
-- License: MIT
-- Maintainer: Lars Kuhtz <lkuhtz@pivotmail.com>
-- Stability: experimental
--
module Configuration.Utils.Internal
(
-- * Lenses
  lens
, over
, set
, view
, Lens'
, Lens
, Iso'
, Iso
, iso

-- * Misc Utils
, (&)
, (<&>)
, sshow
, exceptT
, errorT
, fmapL
) where

import Control.Applicative (Const(..))
import Control.Monad
import Control.Monad.Reader.Class
import Control.Monad.Except

import Data.Functor.Identity
import Data.Monoid.Unicode
import Data.Profunctor
import Data.Profunctor.Unsafe
import Data.String
import qualified Data.Text as T

import Prelude.Unicode

infixl 1 &, <&>

-- -------------------------------------------------------------------------- --
-- Lenses

-- Just what we need of van Laarhoven Lenses
--
-- These few lines of code do safe us a lot of dependencies

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Lens σ τ α β = Functor φ ⇒ (α → φ β) → σ → φ τ

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Lens' σ α = Lens σ σ α α

lens ∷ (σ → α) → (σ → β → τ) → Lens σ τ α β
lens getter setter lGetter s = setter s `fmap` lGetter (getter s)
{-# INLINE lens #-}

over ∷ ((α → Identity β) → σ → Identity τ) → (α → β) → σ → τ
over s f = runIdentity . s (Identity . f)
{-# INLINE over #-}

set ∷ ((α → Identity β) → σ → Identity τ) → β → σ → τ
set s a = runIdentity . s (const $ Identity a)
{-# INLINE set #-}

view ∷ MonadReader σ μ ⇒ ((α → Const α α) → σ → Const α σ) → μ α
view l = asks (getConst #. l Const)
{-# INLINE view #-}

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Iso σ τ α β = (Profunctor π, Functor φ) ⇒ π α (φ β) → π σ (φ τ)
type Iso' σ α = Iso σ σ α α

iso ∷ (σ → α) → (β → τ) → Iso σ τ α β
iso f g = dimap f (fmap g)
{-# INLINE iso #-}

-- -------------------------------------------------------------------------- --
-- Misc Utils

(&) ∷ α → (α → β) → β
(&) = flip ($)
{-# INLINE (&) #-}

(<&>) ∷ Functor φ ⇒ φ α → (α → β) → φ β
(<&>) = flip fmap
{-# INLINE (<&>) #-}

sshow
    ∷ (Show α, IsString τ)
    ⇒ α
    → τ
sshow = fromString ∘ show
{-# INLINE sshow #-}

exceptT
    ∷ Monad μ
    ⇒ (ε → μ β)
    → (α → μ β)
    → ExceptT ε μ α
    → μ β
exceptT a b = runExceptT >=> either a b
{-# INLINE exceptT #-}

errorT
    ∷ Monad μ
    ⇒ ExceptT T.Text μ α
    → μ α
errorT = exceptT (\e → error ∘ T.unpack $ "Error: " ⊕ e) return
{-# INLINE errorT #-}

fmapL ∷ (α → β) → Either α γ → Either β γ
fmapL f = either (Left ∘ f) Right
{-# INLINE fmapL #-}

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RankNTypes #-}

-- |
-- Module: Configuration.Utils.Interal
-- Description: Internal utilities of the configuration-tools package
-- Copyright: Copyright © 2014-2015 PivotCloud, Inc.
-- License: MIT
-- Maintainer: Lars Kuhtz <lkuhtz@pivotmail.com>
-- Stability: experimental
--
module Configuration.Utils.Internal
(
-- * Lenses
  lens
, over
, set
, view
, Lens'
, Lens
, Iso'
, Iso
, iso

-- * Misc Utils
, (&)
, (<&>)
, sshow
, exceptT
, errorT
, fmapL
) where

import Control.Applicative (Const(..))
import Control.Monad
import Control.Monad.Reader.Class
import Control.Monad.Except

import Data.Functor.Identity
import Data.Monoid.Unicode
import Data.Profunctor
import Data.Profunctor.Unsafe
import Data.String
import qualified Data.Text as T

import Prelude.Unicode

infixl 1 &, <&>

-- -------------------------------------------------------------------------- --
-- Lenses

-- Just what we need of van Laarhoven Lenses
--
-- These few lines of code do safe us a lot of dependencies

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Lens σ τ α β = Functor φ => (α -> φ β) -> σ -> φ τ

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Lens' σ α = Lens σ σ α α

lens :: (σ -> α) -> (σ -> β -> τ) -> Lens σ τ α β
lens getter setter lGetter s = setter s `fmap` lGetter (getter s)
{-# INLINE lens #-}

over :: ((α -> Identity β) -> σ -> Identity τ) -> (α -> β) -> σ -> τ
over s f = runIdentity . s (Identity . f)
{-# INLINE over #-}

set :: ((α -> Identity β) -> σ -> Identity τ) -> β -> σ -> τ
set s a = runIdentity . s (const $ Identity a)
{-# INLINE set #-}

view :: MonadReader σ μ => ((α -> Const α α) -> σ -> Const α σ) -> μ α
view l = asks (getConst #. l Const)
{-# INLINE view #-}

-- | This is the same type as the type from the lens library with the same name.
--
-- In case it is already import from the lens package this should be hidden
-- from the import.
--
type Iso σ τ α β = (Profunctor π, Functor φ) => π α (φ β) -> π σ (φ τ)
type Iso' σ α = Iso σ σ α α

iso :: (σ -> α) -> (β -> τ) -> Iso σ τ α β
iso f g = dimap f (fmap g)
{-# INLINE iso #-}

-- -------------------------------------------------------------------------- --
-- Misc Utils

(&) :: α -> (α -> β) -> β
(&) = flip ($)
{-# INLINE (&) #-}

(<&>) :: Functor φ => φ α -> (α -> β) -> φ β
(<&>) = flip fmap
{-# INLINE (<&>) #-}

sshow
    :: (Show α, IsString τ)
    => α
    -> τ
sshow = fromString ∘ show
{-# INLINE sshow #-}

exceptT
    :: Monad μ
    => (ε -> μ β)
    -> (α -> μ β)
    -> ExceptT ε μ α
    -> μ β
exceptT a b = runExceptT >=> either a b
{-# INLINE exceptT #-}

errorT
    :: Monad μ
    => ExceptT T.Text μ α
    -> μ α
errorT = exceptT (\e -> error ∘ T.unpack $ "Error: " ⊕ e) return
{-# INLINE errorT #-}

fmapL :: (α -> β) -> Either α γ -> Either β γ
fmapL f = either (Left ∘ f) Right
{-# INLINE fmapL #-}


</pre>