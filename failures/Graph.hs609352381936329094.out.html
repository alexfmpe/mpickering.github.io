<a href="Graph.hs340756291478446501.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Graph.hs6855834541351345223.out.html">next</a></br></br><pre>9d8
<     = Initiator   {out ∷ Port}
10d8
<     | Applicator  {inp, func, arg ∷ Port}
11d8
<     | Abstractor  {name ∷ String, inp, body, var ∷ Port}
12d8
<     | Primitive   {inp ∷ Port, name ∷ String}
13d8
<     | Eraser      {inp ∷ Port}
14d8
<     | Duplicator  {active ∷ Bool, inp, out1, out2 ∷ Port}
15c9
<     | Multiplexer {out ∷ Port, ins ∷ [Port]} -- only intermediate compilation result
---
>     = Initiator   {out :: Port}
15a10
>     | Applicator  {inp, func, arg :: Port}
15a11
>     | Abstractor  {name :: String, inp, body, var :: Port}
15a12
>     | Primitive   {inp :: Port, name :: String}
15a13
>     | Eraser      {inp :: Port}
15a14
>     | Duplicator  {active :: Bool, inp, out1, out2 :: Port}
15a15
>     | Multiplexer {out :: Port, ins :: [Port]} -- only intermediate compilation result
19d18
<         Initiator   {out = o}                       → [o]
20d18
<         Applicator  {inp = i, func = f, arg = a}    → [i,f,a]
21d18
<         Abstractor  {inp = i, body = b, var = v}    → [i,b,v]
22d18
<         Primitive   {inp = i}                       → [i]
23d18
<         Eraser      {inp = i}                       → [i]
24d18
<         Duplicator  {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
25c19
<         Multiplexer {out = o, ins = is}             → o:is
---
>         Initiator   {out = o}                       -> [o]
25a20
>         Applicator  {inp = i, func = f, arg = a}    -> [i,f,a]
25a21
>         Abstractor  {inp = i, body = b, var = v}    -> [i,b,v]
25a22
>         Primitive   {inp = i}                       -> [i]
25a23
>         Eraser      {inp = i}                       -> [i]
25a24
>         Duplicator  {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
25a25
>         Multiplexer {out = o, ins = is}             -> o:is
27d26
<         Initiator   {} → node {out = o}                       where [o]       = ports
28d26
<         Applicator  {} → node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
29d26
<         Abstractor  {} → node {inp = i, body = b, var = v}    where [i,b,v]   = ports
30d26
<         Primitive   {} → node {inp = i}                       where [i]       = ports
31d26
<         Eraser      {} → node {inp = i}                       where [i]       = ports
32d26
<         Duplicator  {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
33c27
<         Multiplexer {} → node {out = o, ins = is}             where o:is      = ports
---
>         Initiator   {} -> node {out = o}                       where [o]       = ports
33a28
>         Applicator  {} -> node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
33a29
>         Abstractor  {} -> node {inp = i, body = b, var = v}    where [i,b,v]   = ports
33a30
>         Primitive   {} -> node {inp = i}                       where [i]       = ports
33a31
>         Eraser      {} -> node {inp = i}                       where [i]       = ports
33a32
>         Duplicator  {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
33a33
>         Multiplexer {} -> node {out = o, ins = is}             where o:is      = ports
33a34
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Data.View
import GraphRewriting.Graph.Types


data NodeWW
    = Initiator   {out ∷ Port}
    | Applicator  {inp, func, arg ∷ Port}
    | Abstractor  {name ∷ String, inp, body, var ∷ Port}
    | Primitive   {inp ∷ Port, name ∷ String}
    | Eraser      {inp ∷ Port}
    | Duplicator  {active ∷ Bool, inp, out1, out2 ∷ Port}
    | Multiplexer {out ∷ Port, ins ∷ [Port]} -- only intermediate compilation result

instance View [Port] NodeWW where
    inspect node = case node of
        Initiator   {out = o}                       → [o]
        Applicator  {inp = i, func = f, arg = a}    → [i,f,a]
        Abstractor  {inp = i, body = b, var = v}    → [i,b,v]
        Primitive   {inp = i}                       → [i]
        Eraser      {inp = i}                       → [i]
        Duplicator  {inp = i, out1 = o1, out2 = o2} → [i,o1,o2]
        Multiplexer {out = o, ins = is}             → o:is
    update ports node = case node of
        Initiator   {} → node {out = o}                       where [o]       = ports
        Applicator  {} → node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
        Abstractor  {} → node {inp = i, body = b, var = v}    where [i,b,v]   = ports
        Primitive   {} → node {inp = i}                       where [i]       = ports
        Eraser      {} → node {inp = i}                       where [i]       = ports
        Duplicator  {} → node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Multiplexer {} → node {out = o, ins = is}             where o:is      = ports
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances, MultiParamTypeClasses #-}
module Graph where

import Data.View
import GraphRewriting.Graph.Types


data NodeWW
    = Initiator   {out :: Port}
    | Applicator  {inp, func, arg :: Port}
    | Abstractor  {name :: String, inp, body, var :: Port}
    | Primitive   {inp :: Port, name :: String}
    | Eraser      {inp :: Port}
    | Duplicator  {active :: Bool, inp, out1, out2 :: Port}
    | Multiplexer {out :: Port, ins :: [Port]} -- only intermediate compilation result

instance View [Port] NodeWW where
    inspect node = case node of
        Initiator   {out = o}                       -> [o]
        Applicator  {inp = i, func = f, arg = a}    -> [i,f,a]
        Abstractor  {inp = i, body = b, var = v}    -> [i,b,v]
        Primitive   {inp = i}                       -> [i]
        Eraser      {inp = i}                       -> [i]
        Duplicator  {inp = i, out1 = o1, out2 = o2} -> [i,o1,o2]
        Multiplexer {out = o, ins = is}             -> o:is
    update ports node = case node of
        Initiator   {} -> node {out = o}                       where [o]       = ports
        Applicator  {} -> node {inp = i, func = f, arg = a}    where [i,f,a]   = ports
        Abstractor  {} -> node {inp = i, body = b, var = v}    where [i,b,v]   = ports
        Primitive   {} -> node {inp = i}                       where [i]       = ports
        Eraser      {} -> node {inp = i}                       where [i]       = ports
        Duplicator  {} -> node {inp = i, out1 = o1, out2 = o2} where [i,o1,o2] = ports
        Multiplexer {} -> node {out = o, ins = is}             where o:is      = ports

</pre>