<a href="Instances.hs1075260298824938981.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Instances.hs19548990971636807826.out.html">next</a></br></br><pre>9c9
< 
---
> module Data.Generics.Fixplate.Test.Instances where
11c11
< 
---
> --------------------------------------------------------------------------------
13d12
< import Control.Monad hiding (mapM, mapM_, forM, forM_)
14d12
< import Data.List (sort)
15d12
< import Data.Foldable
16c13
< import Data.Traversable
---
> import Control.ApplicativeControl.Monad hiding (mapM, mapM_, forM, forM_)
16a14
> import Control.MonadData.List (sort)     (mapM, mapM_, forM, forM_)
16a15
> import Data.ListData.Foldablesort)
16a16
> import Data.FoldableData.Traversable
16a17
> import Data.TraversablePrelude hiding (foldl,foldr,mapM,mapM_,concat,concatMap)
18d18
< 
20c20
< import Data.Generics.Fixplate.Misc
---
> import Data.Generics.Fixplate.Base
20a21
> import Data.Generics.Fixplate.MiscData.Generics.Fixplate.Test.Tools
22d22
< 
24c24
< 
---
> import Test.QuickCheck
25a26
> -- * Misc--------------------------------------------------------------------------------
27d27
< 
29c29
< prop_forget tree =
---
> prop_forget ::tree=  (TreeF Label) Int -> Bool
29a30
> prop_forgetfromFixT (treeforget= tree) == fmap fst (fromAttr tree)
31d31
< 
33c33
< prop_fromToFixT tree =
---
> prop_fromToFixT ::tree=  Label -> Bool
33a34
> prop_fromToFixTtoFixT (fromFixTtree= ) == tree
35d35
< 
37c37
< prop_toFromFixT tree =
---
> prop_toFromFixT ::tree=  Label -> Bool
37a38
> prop_toFromFixTfromFixT (toFixTtree= ) == tree
39d39
< 
41c41
< prop_fromToAttr tree =
---
> prop_fromToAttr ::tree=  (TreeF Label) Int -> Bool
41a42
> prop_fromToAttrtoAttr (fromAttrtree= ) == tree
43d43
< 
45c45
< prop_toFromAttr tree =
---
> prop_toFromAttr ::tree=  (Label,Int) -> Bool
45a46
> prop_toFromAttrfromAttr (toAttrtree= ) == tree
47d47
< 
49c49
<   quickCheck prop_forget
---
> runtests_InstancesMiscquickCheck prop_forget= do
49a50
>   quickCheck prop_forgetprop_fromToFixT
54d54
< 
55a56
> -- * Read/Show.--------------------------------------------------------------------------------
57d57
< 
59c59
< prop_ReadShowMuInt     :: Mu (TreeF Int   ) -> Bool
---
> prop_ReadShowMuLabelprop_ReadShowMuInt     :: Mu (TreeF LabelInt   ) -> Bool
59a60
> prop_ReadShowMuIntprop_ReadShowMuString  :: Mu (TreeF IntString) -> Bool
61d61
< 
63c63
< prop_ReadShowMuInt    t = read (show t) == t
---
> prop_ReadShowMuLabelprop_ReadShowMuInt    t = read (show t) == t
63a64
> prop_ReadShowMuIntprop_ReadShowMuString t = read (show t) == t
65d65
< 
66a67
> prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel :: Attr (TreeF LabelString) IntLabel -> Bool
68d68
< 
69a70
> prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel t = read (show t) == t
71d71
< 
73d72
<   quickCheck prop_ReadShowMuLabel
74d72
<   quickCheck prop_ReadShowMuInt
75d72
<   quickCheck prop_ReadShowMuString
76c73
<   quickCheck prop_ReadShowAttrLabelInt
---
> runtests_ReadShowquickCheck prop_ReadShowMuLabel= do
76a74
>   quickCheck prop_ReadShowMuLabelprop_ReadShowMuInt
76a75
>   quickCheck prop_ReadShowMuIntprop_ReadShowMuString
76a76
>   quickCheck prop_ReadShowMuStringprop_ReadShowAttrLabelInt
76a77
>   quickCheck prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel
78d78
< 
79a80
> -- * Attrib wrapper.--------------------------------------------------------------------------------
81d81
< 
83d82
< prop_AttribFMap tree =
84c83
<   unAttrib (fmap f (Attrib tree)) == toAttr (fmap (id<#>f) (fromAttr tree))
---
> prop_AttribFMap ::tree=  (TreeF Label) Int -> Bool
84a84
> prop_AttribFMapunAttrib (fmaptreef (Attrib=     tree)) == toAttr (fmap (id<#>f) (fromAttr tree))
84a85
>   unAttribwhere f(fmapn = show (Attribn ++ "_")) == toAttr (fmap (id<#>f) (fromAttr tree))
86d86
< 
88c88
< 
---
> --------------------------------------------------------------------------------
90c90
< prop_AttribFoldr tree =
---
> prop_AttribFoldr ::tree=  (TreeF Label) Int -> Bool
90a91
> prop_AttribFoldrfoldr (:) [] (Attrib =tree) == map snd (foldr (:) [] (fromAttr tree))
92d92
< 
94c94
< prop_AttribFoldl tree =
---
> prop_AttribFoldl ::tree=  (TreeF Label) Int -> Bool
94a95
> prop_AttribFoldlfoldl (flip (:)tree) [] =Attrib tree) == map snd (foldl (flip (:)) [] (fromAttr tree))
96d96
< 
98c98
< 
---
> --------------------------------------------------------------------------------
100d99
< prop_AttribMapAccumL tree =
101d99
<   (id<#>unAttrib) (mapAccumL f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
102d99
<     f1 :: Integer -> Integer -> (Integer,String)
103d99
<     f1 old input = (new, show residue) where
104d99
<       new     = old*3 - input
105d99
<       residue = old*2 + input*7
106c100
<     f2 :: Integer -> (Label,Integer) -> (Integer,(Label,String))
---
> prop_AttribMapAccumL ::tree=  (TreeF Label) Integer -> Bool
106a101
> prop_AttribMapAccumL(id<#>unAttrib) (mapAccumL =  f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
106a102
>   (idf1<#>::unAttribInteger) (->mapAccumLInteger f1 666(IntegerAttrib,String))) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
106a103
>     f1 ::oldIntegerinput =->(new, show->residueInteger) where,String)
106a104
>     f1new input= old= (new3 -,input residue) where
106a105
>       newresidue = old*3 - input*7
106a106
>     f2residue:: Integer= old->*2(+Label,Integer*7    ) -> (Integer,(Label,String))
106a107
>     f2 ::oldInteger(x,input->) (Labellet , Integernew,res) ->= f1Integerold input,(Labelin ,Stringnew,(x))res))
108d108
< 
110d109
< prop_AttribMapAccumR tree =
111d109
<   (id<#>unAttrib) (mapAccumR f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
112d109
<     f1 :: Integer -> Integer -> (Integer,String)
113d109
<     f1 old input = (new, show residue) where
114d109
<       new     = old*3 - input
115d109
<       residue = old*2 + input*7
116c110
<     f2 :: Integer -> (Label,Integer) -> (Integer,(Label,String))
---
> prop_AttribMapAccumR ::tree=  (TreeF Label) Integer -> Bool
116a111
> prop_AttribMapAccumR(id<#>unAttrib) (mapAccumR =  f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
116a112
>   (idf1<#>::unAttribInteger) (->mapAccumRInteger f1 666(IntegerAttrib,String))) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
116a113
>     f1 ::oldIntegerinput =->(new, show->residueInteger) where,String)
116a114
>     f1new input= old= (new3 -,input residue) where
116a115
>       newresidue = old*3 - input*7
116a116
>     f2residue:: Integer= old->*2(+Label,Integer*7    ) -> (Integer,(Label,String))
116a117
>     f2 ::oldInteger(x,input->) (Labellet , Integernew,res) ->= f1Integerold input,(Labelin ,Stringnew,(x))res))
118d118
< 
120d119
< -- with our implementation (for Attrib).
121d119
< runtests_Attrib = do
122c120
<   quickCheck prop_AttribFMap
---
> -- with our implementation (for Attrib).-- | We compare GHC-derived Functor, Foldable and Traversable instances (for Tree)
122a121
> runtests_Attrib-- with our implementation (for Attrib).= do
122a122
> runtests_AttribquickCheck prop_AttribFMap= do
122a123
>   quickCheck prop_AttribFMapprop_AttribFoldr
124c125
<   quickCheck prop_AttribFoldl
---
>   quickCheck prop_AttribFoldlprop_AttribMapAccumL
127d127
< 
128a129
> --------------------------------------------------------------------------------
</pre></br><h2>original</h2></br><pre>

{-# LANGUAGE
      CPP,
      DeriveFunctor, DeriveFoldable, DeriveTraversable, StandaloneDeriving,
      FlexibleInstances
  #-}
module Data.Generics.Fixplate.Test.Instances where

--------------------------------------------------------------------------------

import Control.Applicative
import Control.Monad hiding (mapM, mapM_, forM, forM_)
import Data.List (sort)
import Data.Foldable
import Data.Traversable
import Prelude hiding (foldl,foldr,mapM,mapM_,concat,concatMap)

import Data.Generics.Fixplate.Base
import Data.Generics.Fixplate.Misc
import Data.Generics.Fixplate.Test.Tools

import Test.QuickCheck

--------------------------------------------------------------------------------
-- * Misc

prop_forget :: Attr (TreeF Label) Int -> Bool
prop_forget tree =
  fromFixT (forget tree) == fmap fst (fromAttr tree)

prop_fromToFixT :: FixT Label -> Bool
prop_fromToFixT tree =
  toFixT (fromFixT tree) == tree

prop_toFromFixT :: Tree Label -> Bool
prop_toFromFixT tree =
  fromFixT (toFixT tree) == tree

prop_fromToAttr :: Attr (TreeF Label) Int -> Bool
prop_fromToAttr tree =
  toAttr (fromAttr tree) == tree

prop_toFromAttr :: Tree (Label,Int) -> Bool
prop_toFromAttr tree =
  fromAttr (toAttr tree) == tree

runtests_InstancesMisc = do
  quickCheck prop_forget
  quickCheck prop_fromToFixT
  quickCheck prop_toFromFixT
  quickCheck prop_fromToAttr
  quickCheck prop_toFromAttr

--------------------------------------------------------------------------------
-- * Read/Show.

prop_ReadShowMuLabel   :: Mu (TreeF Label ) -> Bool
prop_ReadShowMuInt     :: Mu (TreeF Int   ) -> Bool
prop_ReadShowMuString  :: Mu (TreeF String) -> Bool

prop_ReadShowMuLabel  t = read (show t) == t
prop_ReadShowMuInt    t = read (show t) == t
prop_ReadShowMuString t = read (show t) == t

prop_ReadShowAttrLabelInt    :: Attr (TreeF Label ) Int   -> Bool
prop_ReadShowAttrStringLabel :: Attr (TreeF String) Label -> Bool

prop_ReadShowAttrLabelInt    t = read (show t) == t
prop_ReadShowAttrStringLabel t = read (show t) == t

runtests_ReadShow = do
  quickCheck prop_ReadShowMuLabel
  quickCheck prop_ReadShowMuInt
  quickCheck prop_ReadShowMuString
  quickCheck prop_ReadShowAttrLabelInt
  quickCheck prop_ReadShowAttrStringLabel

--------------------------------------------------------------------------------
-- * Attrib wrapper.

prop_AttribFMap :: Attr (TreeF Label) Int -> Bool
prop_AttribFMap tree =
  unAttrib (fmap f (Attrib tree)) == toAttr (fmap (id<#>f) (fromAttr tree))
    where f n = show n ++ "_"

--------------------------------------------------------------------------------

prop_AttribFoldr :: Attr (TreeF Label) Int -> Bool
prop_AttribFoldr tree =
  foldr (:) [] (Attrib tree) == map snd (foldr (:) [] (fromAttr tree))

prop_AttribFoldl :: Attr (TreeF Label) Int -> Bool
prop_AttribFoldl tree =
  foldl (flip (:)) [] (Attrib tree) == map snd (foldl (flip (:)) [] (fromAttr tree))

--------------------------------------------------------------------------------

prop_AttribMapAccumL :: Attr (TreeF Label) Integer -> Bool
prop_AttribMapAccumL tree =
  (id<#>unAttrib) (mapAccumL f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
    f1 :: Integer -> Integer -> (Integer,String)
    f1 old input = (new, show residue) where
      new     = old*3 - input
      residue = old*2 + input*7
    f2 :: Integer -> (Label,Integer) -> (Integer,(Label,String))
    f2 old (x,input) = let (new,res) = f1 old input in (new,(x,res))

prop_AttribMapAccumR :: Attr (TreeF Label) Integer -> Bool
prop_AttribMapAccumR tree =
  (id<#>unAttrib) (mapAccumR f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
    f1 :: Integer -> Integer -> (Integer,String)
    f1 old input = (new, show residue) where
      new     = old*3 - input
      residue = old*2 + input*7
    f2 :: Integer -> (Label,Integer) -> (Integer,(Label,String))
    f2 old (x,input) = let (new,res) = f1 old input in (new,(x,res))

-- | We compare GHC-derived Functor, Foldable and Traversable instances (for Tree)
-- with our implementation (for Attrib).
runtests_Attrib = do
  quickCheck prop_AttribFMap
  quickCheck prop_AttribFoldr
  quickCheck prop_AttribFoldl
  quickCheck prop_AttribMapAccumL
  quickCheck prop_AttribMapAccumR

--------------------------------------------------------------------------------

</pre></br><h2>printed</h2></br><pre>

{-# LANGUAGE
      CPP,
      DeriveFunctor, DeriveFoldable, DeriveTraversable, StandaloneDeriving,
      FlexibleInstances
  #-}
module Data.Generics.Fixplate.Test.Instances where
module Data.Generics.Fixplate.Test.Instances where
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
import Control.Applicative
import Control.ApplicativeControl.Monad hiding (mapM, mapM_, forM, forM_)
import Control.MonadData.List (sort)     (mapM, mapM_, forM, forM_)
import Data.ListData.Foldablesort)
import Data.FoldableData.Traversable
import Data.TraversablePrelude hiding (foldl,foldr,mapM,mapM_,concat,concatMap)
import Prelude hiding (foldl,foldr,mapM,mapM_,concat,concatMap)
import Data.Generics.Fixplate.Base
import Data.Generics.Fixplate.Base
import Data.Generics.Fixplate.MiscData.Generics.Fixplate.Test.Tools
import Data.Generics.Fixplate.Test.Tools
import Test.QuickCheck
import Test.QuickCheck
--------------------------------------------------------------------------------
-- * Misc--------------------------------------------------------------------------------
-- * Misc
prop_forget :: Attr (TreeF Label) Int -> Bool
prop_forget ::tree=  (TreeF Label) Int -> Bool
prop_forgetfromFixT (treeforget= tree) == fmap fst (fromAttr tree)
  fromFixT (forget tree) == fmap fst (fromAttr tree)
prop_fromToFixT :: FixT Label -> Bool
prop_fromToFixT ::tree=  Label -> Bool
prop_fromToFixTtoFixT (fromFixTtree= ) == tree
  toFixT (fromFixT tree) == tree
prop_toFromFixT :: Tree Label -> Bool
prop_toFromFixT ::tree=  Label -> Bool
prop_toFromFixTfromFixT (toFixTtree= ) == tree
  fromFixT (toFixT tree) == tree
prop_fromToAttr :: Attr (TreeF Label) Int -> Bool
prop_fromToAttr ::tree=  (TreeF Label) Int -> Bool
prop_fromToAttrtoAttr (fromAttrtree= ) == tree
  toAttr (fromAttr tree) == tree
prop_toFromAttr :: Tree (Label,Int) -> Bool
prop_toFromAttr ::tree=  (Label,Int) -> Bool
prop_toFromAttrfromAttr (toAttrtree= ) == tree
  fromAttr (toAttr tree) == tree
runtests_InstancesMisc = do
runtests_InstancesMiscquickCheck prop_forget= do
  quickCheck prop_forgetprop_fromToFixT
  quickCheck prop_fromToFixT
  quickCheck prop_toFromFixT
  quickCheck prop_fromToAttr
  quickCheck prop_toFromAttr
--------------------------------------------------------------------------------
-- * Read/Show.--------------------------------------------------------------------------------
-- * Read/Show.
prop_ReadShowMuLabel   :: Mu (TreeF Label ) -> Bool
prop_ReadShowMuLabelprop_ReadShowMuInt     :: Mu (TreeF LabelInt   ) -> Bool
prop_ReadShowMuIntprop_ReadShowMuString  :: Mu (TreeF IntString) -> Bool
prop_ReadShowMuString  :: Mu (TreeF String) -> Bool
prop_ReadShowMuLabel  t = read (show t) == t
prop_ReadShowMuLabelprop_ReadShowMuInt    t = read (show t) == t
prop_ReadShowMuIntprop_ReadShowMuString t = read (show t) == t
prop_ReadShowMuString t = read (show t) == t
prop_ReadShowAttrLabelInt    :: Attr (TreeF Label ) Int   -> Bool
prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel :: Attr (TreeF LabelString) IntLabel -> Bool
prop_ReadShowAttrStringLabel :: Attr (TreeF String) Label -> Bool
prop_ReadShowAttrLabelInt    t = read (show t) == t
prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel t = read (show t) == t
prop_ReadShowAttrStringLabel t = read (show t) == t
runtests_ReadShow = do
runtests_ReadShowquickCheck prop_ReadShowMuLabel= do
  quickCheck prop_ReadShowMuLabelprop_ReadShowMuInt
  quickCheck prop_ReadShowMuIntprop_ReadShowMuString
  quickCheck prop_ReadShowMuStringprop_ReadShowAttrLabelInt
  quickCheck prop_ReadShowAttrLabelIntprop_ReadShowAttrStringLabel
  quickCheck prop_ReadShowAttrStringLabel
--------------------------------------------------------------------------------
-- * Attrib wrapper.--------------------------------------------------------------------------------
-- * Attrib wrapper.
prop_AttribFMap :: Attr (TreeF Label) Int -> Bool
prop_AttribFMap ::tree=  (TreeF Label) Int -> Bool
prop_AttribFMapunAttrib (fmaptreef (Attrib=     tree)) == toAttr (fmap (id<#>f) (fromAttr tree))
  unAttribwhere f(fmapn = show (Attribn ++ "_")) == toAttr (fmap (id<#>f) (fromAttr tree))
    where f n = show n ++ "_"
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
prop_AttribFoldr :: Attr (TreeF Label) Int -> Bool
prop_AttribFoldr ::tree=  (TreeF Label) Int -> Bool
prop_AttribFoldrfoldr (:) [] (Attrib =tree) == map snd (foldr (:) [] (fromAttr tree))
  foldr (:) [] (Attrib tree) == map snd (foldr (:) [] (fromAttr tree))
prop_AttribFoldl :: Attr (TreeF Label) Int -> Bool
prop_AttribFoldl ::tree=  (TreeF Label) Int -> Bool
prop_AttribFoldlfoldl (flip (:)tree) [] =Attrib tree) == map snd (foldl (flip (:)) [] (fromAttr tree))
  foldl (flip (:)) [] (Attrib tree) == map snd (foldl (flip (:)) [] (fromAttr tree))
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
prop_AttribMapAccumL :: Attr (TreeF Label) Integer -> Bool
prop_AttribMapAccumL ::tree=  (TreeF Label) Integer -> Bool
prop_AttribMapAccumL(id<#>unAttrib) (mapAccumL =  f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
  (idf1<#>::unAttribInteger) (->mapAccumLInteger f1 666(IntegerAttrib,String))) == (id<#>toAttr) (mapAccumL f2 666 (fromAttr tree)) where
    f1 ::oldIntegerinput =->(new, show->residueInteger) where,String)
    f1new input= old= (new3 -,input residue) where
      newresidue = old*3 - input*7
    f2residue:: Integer= old->*2(+Label,Integer*7    ) -> (Integer,(Label,String))
    f2 ::oldInteger(x,input->) (Labellet , Integernew,res) ->= f1Integerold input,(Labelin ,Stringnew,(x))res))
    f2 old (x,input) = let (new,res) = f1 old input in (new,(x,res))
prop_AttribMapAccumR :: Attr (TreeF Label) Integer -> Bool
prop_AttribMapAccumR ::tree=  (TreeF Label) Integer -> Bool
prop_AttribMapAccumR(id<#>unAttrib) (mapAccumR =  f1 666 (Attrib tree)) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
  (idf1<#>::unAttribInteger) (->mapAccumRInteger f1 666(IntegerAttrib,String))) == (id<#>toAttr) (mapAccumR f2 666 (fromAttr tree)) where
    f1 ::oldIntegerinput =->(new, show->residueInteger) where,String)
    f1new input= old= (new3 -,input residue) where
      newresidue = old*3 - input*7
    f2residue:: Integer= old->*2(+Label,Integer*7    ) -> (Integer,(Label,String))
    f2 ::oldInteger(x,input->) (Labellet , Integernew,res) ->= f1Integerold input,(Labelin ,Stringnew,(x))res))
    f2 old (x,input) = let (new,res) = f1 old input in (new,(x,res))
-- | We compare GHC-derived Functor, Foldable and Traversable instances (for Tree)
-- with our implementation (for Attrib).-- | We compare GHC-derived Functor, Foldable and Traversable instances (for Tree)
runtests_Attrib-- with our implementation (for Attrib).= do
runtests_AttribquickCheck prop_AttribFMap= do
  quickCheck prop_AttribFMapprop_AttribFoldr
  quickCheck prop_AttribFoldr
  quickCheck prop_AttribFoldlprop_AttribMapAccumL
  quickCheck prop_AttribMapAccumL
  quickCheck prop_AttribMapAccumR
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

</pre>