<a href="Combat.hs578354438892053144.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Combinator.hs1974930991404280278.out.html">next</a></br></br><pre>25c25
< combinator ∷ GuessCombinator t HNil ⇒ t
---
> combinator :: GuessCombinator t HNil => t
30c30
<   ((combinator ∷ a → (a → b) → b) 'O' (:"K"), "OK")
---
>   ((combinator :: a -> (a -> b) -> b) 'O' (:"K"), "OK")
32d31
<   .*. ((combinator ∷ a → (a → b) → b) 1 (+2), 3)
33d31
<   .*. ((combinator ∷ (b → c) → (a → b) → a → c) Just Right True, Just (Right True))
34d31
<   .*. ((combinator ∷ a → b → a) 'a' 'b', 'a')
35d31
<   .*. ((combinator ∷ (t → t1) → t → t2 → t1) Just 1 'c', Just 1)
36d31
<   .*. ((combinator ∷ (b → c) → (a → b) → a → c) (:[]) ((,) True) 10, [(True, 10)])
37d31
<   .*. ((combinator ∷ (((a → b → c) → (a → b) → a → c)→ (t3 → t1 → t2 → t3) → t) → t) (\f g → f (g 1) (:[]) 2), 1)
38d31
<   .*. ((combinator ∷ ((a → b) → c) → (a → b) → c) ($2) (+3), 5)
39c32
<   .*. (combinator 'a' True ∷ Bool, True)
---
>   .*. ((combinator :: a -> (a -> b) -> b) 1 (+2), 3)
39a33
>   .*. ((combinator :: (b -> c) -> (a -> b) -> a -> c) Just Right True, Just (Right True))
39a34
>   .*. ((combinator :: a -> b -> a) 'a' 'b', 'a')
39a35
>   .*. ((combinator :: (t -> t1) -> t -> t2 -> t1) Just 1 'c', Just 1)
39a36
>   .*. ((combinator :: (b -> c) -> (a -> b) -> a -> c) (:[]) ((,) True) 10, [(True, 10)])
39a37
>   .*. ((combinator :: (((a -> b -> c) -> (a -> b) -> a -> c)-> (t3 -> t1 -> t2 -> t3) -> t) -> t) (\f g -> f (g 1) (:[]) 2), 1)
39a38
>   .*. ((combinator :: ((a -> b) -> c) -> (a -> b) -> c) ($2) (+3), 5)
39a39
>   .*. (combinator 'a' True :: Bool, True)
52c52
<     combinatorWith ∷ env → t
---
>     combinatorWith :: env -> t
56d55
<        ⇒ GuessCombinator t env where
57c56
<     combinatorWith = guessWith' (Proxy ∷ Proxy flag)
---
>        => GuessCombinator t env where
57a57
>     combinatorWith = guessWith' (Proxy :: Proxy flag)
60c60
<     guessWith' ∷ (Proxy flag) → env → t
---
>     guessWith' :: (Proxy flag) -> env -> t
67d66
<        ⇒ GuessWith' HTrue (x → y) env where
68d66
<   guessWith' _ env = \(v ∷ x) →
69c67
<              guessWith' (Proxy ∷ Proxy flagy) (((TypeToTermT v) ∷ TypeToTermT tlx x) .*. env)
---
>        => GuessWith' HTrue (x -> y) env where
69a68
>   guessWith' _ env = \(v :: x) ->
69a69
>              guessWith' (Proxy :: Proxy flagy) (((TypeToTermT v) :: TypeToTermT tlx x) .*. env)
73d72
<        ⇒ GuessWith' HFalse t env where
74c73
<     guessWith' _ env = rresolve env (Proxy ∷ Proxy ((t :*: HNil) :*: HNil)) HNil
---
>        => GuessWith' HFalse t env where
74a74
>     guessWith' _ env = rresolve env (Proxy :: Proxy ((t :*: HNil) :*: HNil)) HNil
84d83
< class RResolve env goals tl t | env goals tl → t where
85c84
<     rresolve ∷ env → (Proxy goals) → tl → t
---
> class RResolve env goals tl t | env goals tl -> t where
85a85
>     rresolve :: env -> (Proxy goals) -> tl -> t
94d93
< instance RResolve env HNil (t1 :*: tr) (t→r)
95d93
<        ⇒ RResolve env HNil (t :*: t1 :*: tr) r where
96c94
<     rresolve g _ (HCons t r) = (rresolve g (Proxy ∷ Proxy HNil) r) t
---
> instance RResolve env HNil (t1 :*: tr) (t->r)
96a95
>        => RResolve env HNil (t :*: t1 :*: tr) r where
96a96
>     rresolve g _ (HCons t r) = (rresolve g (Proxy :: Proxy HNil) r) t
105d104
<        ⇒ RResolve env ((g :*: HNil) :*: gr) pt t where
106c105
<     rresolve env _ pt = rresolve env (Proxy ∷ Proxy gr) (ra .*. pt)
---
>        => RResolve env ((g :*: HNil) :*: gr) pt t where
106a106
>     rresolve env _ pt = rresolve env (Proxy :: Proxy gr) (ra .*. pt)
108d107
<       TypeToTermT t1 = rhlookup (Proxy ∷ Proxy g) env
109c108
<       ra ∷ ra = rresolve env (Proxy ∷ Proxy assum') (t1 .*. HNil)
---
>       TypeToTermT t1 = rhlookup (Proxy :: Proxy g) env
109a109
>       ra   ra = rresolve env (Proxy :: Proxy assum') (t1 .*. HNil)
120d119
<          ⇒ RResolve env ((g :*: gc :*: gcr) :*: gr) pt t where
121c120
<   rresolve (env ∷ env) _ (pt ∷ pt) = rresolve env (Proxy ∷ Proxy gr) (f .*. pt)
---
>          => RResolve env ((g :*: gc :*: gcr) :*: gr) pt t where
121a121
>   rresolve (env :: env) _ (pt :: pt) = rresolve env (Proxy :: Proxy gr) (f .*. pt)
123d122
<       f ∷ f
124d122
<       f = extendEnv env (Proxy ∷ Proxy revr) $ \(env' ∷ env') →
125c123
<           rresolve env' (Proxy ∷ Proxy ((g :*: HNil) :*: HNil)) HNil
---
>       f :: f
125a124
>       f = extendEnv env (Proxy :: Proxy revr) $ \(env' :: env') ->
125a125
>            rresolve env' (Proxy :: Proxy ((g :*: HNil) :*: HNil)) HNil
136d135
< class ExtendEnv env vs ret env' fun | env vs ret → env' fun where
137c136
<   extendEnv ∷ env → (Proxy vs) → (env' → ret) → fun
---
> class ExtendEnv env vs ret env' fun | env vs ret -> env' fun where
137a137
>   extendEnv :: env -> (Proxy vs) -> (env' -> ret) -> fun
145c145
<   ⇒ ExtendEnv env (pt :*: rest) ret ((TypeToTermT pt t) :*: env') (t → fun)
---
>   => ExtendEnv env (pt :*: rest) ret ((TypeToTermT pt t) :*: env') (t -> fun)
147d146
<  extendEnv env _ f = \(t ∷ t) →
148d146
<    extendEnv env (Proxy ∷ Proxy rest) $ \env' →
149c147
<    f ((TypeToTermT t ∷ TypeToTermT pt t) .*. env')
---
>  extendEnv env _ f = \(t :: t) ->
149a148
>    extendEnv env (Proxy :: Proxy rest) $ \env' ->
149a149
>     f ((TypeToTermT t :: TypeToTermT pt t) .*. env')
153d152
< class RHLookup t l w | t l → w where
154c153
<     rhlookup ∷ (Proxy t) → l → w
---
> class RHLookup t l w | t l -> w where
154a154
>     rhlookup :: (Proxy t) -> l -> w
157d156
<     ⇒ RHLookup t ((TypeToTermT (t' :*: at) tt') :*: r) w where
158c157
<     rhlookup = rhlookup' (Proxy ∷ Proxy flag)
---
>     => RHLookup t ((TypeToTermT (t' :*: at) tt') :*: r) w where
158a158
>     rhlookup = rhlookup' (Proxy :: Proxy flag)
160d159
< class RHLookup' flag t l w | flag t l → w where
161c160
<     rhlookup' ∷ (Proxy flag) → (Proxy t) → l → w
---
> class RHLookup' flag t l w | flag t l -> w where
161a161
>     rhlookup' :: (Proxy flag) -> (Proxy t) -> l -> w
167c167
< instance RHLookup t r w ⇒ RHLookup' HFalse t ((TypeToTermT tl' t') :*: r) w where
---
> instance RHLookup t r w => RHLookup' HFalse t ((TypeToTermT tl' t') :*: r) w where
174c174
< consEnv ∷ FunToList t tl ⇒ t → env → TypeToTermT tl t :*: env
---
> consEnv :: FunToList t tl => t -> env -> TypeToTermT tl t :*: env
175a176
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
  UndecidableInstances,
  UnicodeSyntax, TypeOperators, ScopedTypeVariables, MultiParamTypeClasses,
  FunctionalDependencies, TypeSynonymInstances, FlexibleInstances,
  FlexibleContexts, NoMonomorphismRestriction #-}

-- | Guess a value for a combinator
--
-- Based on De-typechecker: converting from a type to a term
-- by <oleg at pobox.com>
-- http://www.haskell.org/pipermail/haskell/2005-March/015423.html

module Guess.Combinator (combinator) where

import Guess.Combinator.Lib

-- | Guess a combinator given its type
--
-- Example:
--
-- >>> let f = combinator :: (b -> c) -> (a -> b) -> a -> c
-- >>> f (:[]) ((,) True) 10
-- [(True, 10)]

combinator ∷ GuessCombinator t HNil ⇒ t
combinator = combinatorWith emptyEnv

-- | Tests
test =
  ((combinator ∷ a → (a → b) → b) 'O' (:"K"), "OK")
  .*. (combinator 'O' (:"K") :: String, "OK")
  .*. ((combinator ∷ a → (a → b) → b) 1 (+2), 3)
  .*. ((combinator ∷ (b → c) → (a → b) → a → c) Just Right True, Just (Right True))
  .*. ((combinator ∷ a → b → a) 'a' 'b', 'a')
  .*. ((combinator ∷ (t → t1) → t → t2 → t1) Just 1 'c', Just 1)
  .*. ((combinator ∷ (b → c) → (a → b) → a → c) (:[]) ((,) True) 10, [(True, 10)])
  .*. ((combinator ∷ (((a → b → c) → (a → b) → a → c)→ (t3 → t1 → t2 → t3) → t) → t) (\f g → f (g 1) (:[]) 2), 1)
  .*. ((combinator ∷ ((a → b) → c) → (a → b) → c) ($2) (+3), 5)
  .*. (combinator 'a' True ∷ Bool, True)
  .*. HNil

-- | A type/value pair
--
-- The list representation of the type is also kept.

newtype TypeToTermT tl t = TypeToTermT t deriving Show

-- | GuessCombinator +type +env
-- Guess a combinator given its type and an environment

class GuessCombinator t env where
    combinatorWith ∷ env → t

instance (IsFunction t flag,
          GuessWith' flag t env)
       ⇒ GuessCombinator t env where
    combinatorWith = guessWith' (Proxy ∷ Proxy flag)

class GuessWith' flag t env where
    guessWith' ∷ (Proxy flag) → env → t

-- | If its a function, add the argument to the environment and guess the result
instance (IsFunction x flagx,
          FunToList' flagx x tlx,
          IsFunction y flagy,
          GuessWith' flagy y ((TypeToTermT tlx x) :*: env))
       ⇒ GuessWith' HTrue (x → y) env where
  guessWith' _ env = \(v ∷ x) →
             guessWith' (Proxy ∷ Proxy flagy) (((TypeToTermT v) ∷ TypeToTermT tlx x) .*. env)

-- | If it's not a function, let RResolve find a suitable value
instance (RResolve env ((t :*: HNil) :*: HNil) HNil t)
       ⇒ GuessWith' HFalse t env where
    guessWith' _ env = rresolve env (Proxy ∷ Proxy ((t :*: HNil) :*: HNil)) HNil

-- | RResolve +env +goals +retlist -ret
-- Type-level SLD resolution algorithm
--
-- env: a list of TypeToTermT
-- goals: the tail of a flattened type
-- retlist: a function and arguments, reversed, such as any one of tails [a, b, b -> a -> ret]
-- ret: resulting type/value (a collapsed retlist)

class RResolve env goals tl t | env goals tl → t where
    rresolve ∷ env → (Proxy goals) → tl → t

-- | When there are no goals left and the retlist is a singleton, return it

instance RResolve env HNil (t :*: HNil) t where
    rresolve _ _ (HCons t HNil) = t

-- | When there are no goals left and the retlist is not a singleton, collapse the retlist

instance RResolve env HNil (t1 :*: tr) (t→r)
       ⇒ RResolve env HNil (t :*: t1 :*: tr) r where
    rresolve g _ (HCons t r) = (rresolve g (Proxy ∷ Proxy HNil) r) t

-- | When the type we want is not a function, look it up in the environment.
-- If we have a function that returns it, save the function and guess its arguments.

instance (RHLookup g env (TypeToTermT (g :*: assum) g'),
          HReverse assum assum',
          RResolve env assum' (g' :*: HNil) ra,
          RResolve env gr (ra :*: pt) t)
       ⇒ RResolve env ((g :*: HNil) :*: gr) pt t where
    rresolve env _ pt = rresolve env (Proxy ∷ Proxy gr) (ra .*. pt)
     where
      TypeToTermT t1 = rhlookup (Proxy ∷ Proxy g) env
      ra ∷ ra = rresolve env (Proxy ∷ Proxy assum') (t1 .*. HNil)

-- | The instance for improper combinators was left as an exercise.
--
-- When we need a function, build the function, add its arguments to the
-- environment and guess the result.

instance (HReverse (gc :*: gcr) revr,
          ExtendEnv env revr ra env' f,
          RResolve env' ((g :*: HNil) :*: HNil) HNil ra,
          RResolve env gr (f :*: pt) t)
         ⇒ RResolve env ((g :*: gc :*: gcr) :*: gr) pt t where
  rresolve (env ∷ env) _ (pt ∷ pt) = rresolve env (Proxy ∷ Proxy gr) (f .*. pt)
    where
      f ∷ f
      f = extendEnv env (Proxy ∷ Proxy revr) $ \(env' ∷ env') →
          rresolve env' (Proxy ∷ Proxy ((g :*: HNil) :*: HNil)) HNil

-- | Extend an environment with the arguments of a function.
--
-- The argument list must be the reverse of the tail of the flattened
-- function type.
--
-- Given a continutation, return a function that builds the environment.
-- For example:
-- extendEnv [] [[a] [b]] k = \a b -> k env'

class ExtendEnv env vs ret env' fun | env vs ret → env' fun where
  extendEnv ∷ env → (Proxy vs) → (env' → ret) → fun

instance ExtendEnv env HNil ret env ret where
  extendEnv env _ k = k env

instance
  (ExtendEnv env rest ret env' fun,
   ListToFun pt t)
  ⇒ ExtendEnv env (pt :*: rest) ret ((TypeToTermT pt t) :*: env') (t → fun)
   where
 extendEnv env _ f = \(t ∷ t) →
   extendEnv env (Proxy ∷ Proxy rest) $ \env' →
   f ((TypeToTermT t ∷ TypeToTermT pt t) .*. env')

-- | Lookup in the `associative' type-indexed list

class RHLookup t l w | t l → w where
    rhlookup ∷ (Proxy t) → l → w

instance (TypeEq t t' flag, RHLookup' flag t ((TypeToTermT (t' :*: at) tt') :*: r) w)
    ⇒ RHLookup t ((TypeToTermT (t' :*: at) tt') :*: r) w where
    rhlookup = rhlookup' (Proxy ∷ Proxy flag)

class RHLookup' flag t l w | flag t l → w where
    rhlookup' ∷ (Proxy flag) → (Proxy t) → l → w

instance RHLookup' HTrue t ((TypeToTermT (t :*: at) tt) :*: r)
                            (TypeToTermT (t :*: at) tt) where
    rhlookup' _ _ (HCons t _) = t

instance RHLookup t r w ⇒ RHLookup' HFalse t ((TypeToTermT tl' t') :*: r) w where
    rhlookup' _ t (HCons _ r) = rhlookup t r

-- | An empty environment.
emptyEnv = HNil

-- | Add a type/value to the environment
consEnv ∷ FunToList t tl ⇒ t → env → TypeToTermT tl t :*: env
consEnv x env = TypeToTermT x .*. env
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
  UndecidableInstances,
  UnicodeSyntax, TypeOperators, ScopedTypeVariables, MultiParamTypeClasses,
  FunctionalDependencies, TypeSynonymInstances, FlexibleInstances,
  FlexibleContexts, NoMonomorphismRestriction #-}

-- | Guess a value for a combinator
--
-- Based on De-typechecker: converting from a type to a term
-- by <oleg at pobox.com>
-- http://www.haskell.org/pipermail/haskell/2005-March/015423.html

module Guess.Combinator (combinator) where

import Guess.Combinator.Lib

-- | Guess a combinator given its type
--
-- Example:
--
-- >>> let f = combinator :: (b -> c) -> (a -> b) -> a -> c
-- >>> f (:[]) ((,) True) 10
-- [(True, 10)]

combinator :: GuessCombinator t HNil => t
combinator = combinatorWith emptyEnv

-- | Tests
test =
  ((combinator :: a -> (a -> b) -> b) 'O' (:"K"), "OK")
  .*. (combinator 'O' (:"K") :: String, "OK")
  .*. ((combinator :: a -> (a -> b) -> b) 1 (+2), 3)
  .*. ((combinator :: (b -> c) -> (a -> b) -> a -> c) Just Right True, Just (Right True))
  .*. ((combinator :: a -> b -> a) 'a' 'b', 'a')
  .*. ((combinator :: (t -> t1) -> t -> t2 -> t1) Just 1 'c', Just 1)
  .*. ((combinator :: (b -> c) -> (a -> b) -> a -> c) (:[]) ((,) True) 10, [(True, 10)])
  .*. ((combinator :: (((a -> b -> c) -> (a -> b) -> a -> c)-> (t3 -> t1 -> t2 -> t3) -> t) -> t) (\f g -> f (g 1) (:[]) 2), 1)
  .*. ((combinator :: ((a -> b) -> c) -> (a -> b) -> c) ($2) (+3), 5)
  .*. (combinator 'a' True :: Bool, True)
  .*. HNil

-- | A type/value pair
--
-- The list representation of the type is also kept.

newtype TypeToTermT tl t = TypeToTermT t deriving Show

-- | GuessCombinator +type +env
-- Guess a combinator given its type and an environment

class GuessCombinator t env where
    combinatorWith :: env -> t

instance (IsFunction t flag,
          GuessWith' flag t env)
       => GuessCombinator t env where
    combinatorWith = guessWith' (Proxy :: Proxy flag)

class GuessWith' flag t env where
    guessWith' :: (Proxy flag) -> env -> t

-- | If its a function, add the argument to the environment and guess the result
instance (IsFunction x flagx,
          FunToList' flagx x tlx,
          IsFunction y flagy,
          GuessWith' flagy y ((TypeToTermT tlx x) :*: env))
       => GuessWith' HTrue (x -> y) env where
  guessWith' _ env = \(v :: x) ->
             guessWith' (Proxy :: Proxy flagy) (((TypeToTermT v) :: TypeToTermT tlx x) .*. env)

-- | If it's not a function, let RResolve find a suitable value
instance (RResolve env ((t :*: HNil) :*: HNil) HNil t)
       => GuessWith' HFalse t env where
    guessWith' _ env = rresolve env (Proxy :: Proxy ((t :*: HNil) :*: HNil)) HNil

-- | RResolve +env +goals +retlist -ret
-- Type-level SLD resolution algorithm
--
-- env: a list of TypeToTermT
-- goals: the tail of a flattened type
-- retlist: a function and arguments, reversed, such as any one of tails [a, b, b -> a -> ret]
-- ret: resulting type/value (a collapsed retlist)

class RResolve env goals tl t | env goals tl -> t where
    rresolve :: env -> (Proxy goals) -> tl -> t

-- | When there are no goals left and the retlist is a singleton, return it

instance RResolve env HNil (t :*: HNil) t where
    rresolve _ _ (HCons t HNil) = t

-- | When there are no goals left and the retlist is not a singleton, collapse the retlist

instance RResolve env HNil (t1 :*: tr) (t->r)
       => RResolve env HNil (t :*: t1 :*: tr) r where
    rresolve g _ (HCons t r) = (rresolve g (Proxy :: Proxy HNil) r) t

-- | When the type we want is not a function, look it up in the environment.
-- If we have a function that returns it, save the function and guess its arguments.

instance (RHLookup g env (TypeToTermT (g :*: assum) g'),
          HReverse assum assum',
          RResolve env assum' (g' :*: HNil) ra,
          RResolve env gr (ra :*: pt) t)
       => RResolve env ((g :*: HNil) :*: gr) pt t where
    rresolve env _ pt = rresolve env (Proxy :: Proxy gr) (ra .*. pt)
     where
      TypeToTermT t1 = rhlookup (Proxy :: Proxy g) env
      ra   ra = rresolve env (Proxy :: Proxy assum') (t1 .*. HNil)

-- | The instance for improper combinators was left as an exercise.
--
-- When we need a function, build the function, add its arguments to the
-- environment and guess the result.

instance (HReverse (gc :*: gcr) revr,
          ExtendEnv env revr ra env' f,
          RResolve env' ((g :*: HNil) :*: HNil) HNil ra,
          RResolve env gr (f :*: pt) t)
         => RResolve env ((g :*: gc :*: gcr) :*: gr) pt t where
  rresolve (env :: env) _ (pt :: pt) = rresolve env (Proxy :: Proxy gr) (f .*. pt)
    where
      f :: f
      f = extendEnv env (Proxy :: Proxy revr) $ \(env' :: env') ->
           rresolve env' (Proxy :: Proxy ((g :*: HNil) :*: HNil)) HNil

-- | Extend an environment with the arguments of a function.
--
-- The argument list must be the reverse of the tail of the flattened
-- function type.
--
-- Given a continutation, return a function that builds the environment.
-- For example:
-- extendEnv [] [[a] [b]] k = \a b -> k env'

class ExtendEnv env vs ret env' fun | env vs ret -> env' fun where
  extendEnv :: env -> (Proxy vs) -> (env' -> ret) -> fun

instance ExtendEnv env HNil ret env ret where
  extendEnv env _ k = k env

instance
  (ExtendEnv env rest ret env' fun,
   ListToFun pt t)
  => ExtendEnv env (pt :*: rest) ret ((TypeToTermT pt t) :*: env') (t -> fun)
   where
 extendEnv env _ f = \(t :: t) ->
   extendEnv env (Proxy :: Proxy rest) $ \env' ->
    f ((TypeToTermT t :: TypeToTermT pt t) .*. env')

-- | Lookup in the `associative' type-indexed list

class RHLookup t l w | t l -> w where
    rhlookup :: (Proxy t) -> l -> w

instance (TypeEq t t' flag, RHLookup' flag t ((TypeToTermT (t' :*: at) tt') :*: r) w)
    => RHLookup t ((TypeToTermT (t' :*: at) tt') :*: r) w where
    rhlookup = rhlookup' (Proxy :: Proxy flag)

class RHLookup' flag t l w | flag t l -> w where
    rhlookup' :: (Proxy flag) -> (Proxy t) -> l -> w

instance RHLookup' HTrue t ((TypeToTermT (t :*: at) tt) :*: r)
                            (TypeToTermT (t :*: at) tt) where
    rhlookup' _ _ (HCons t _) = t

instance RHLookup t r w => RHLookup' HFalse t ((TypeToTermT tl' t') :*: r) w where
    rhlookup' _ t (HCons _ r) = rhlookup t r

-- | An empty environment.
emptyEnv = HNil

-- | Add a type/value to the environment
consEnv :: FunToList t tl => t -> env -> TypeToTermT tl t :*: env
consEnv x env = TypeToTermT x .*. env

</pre>