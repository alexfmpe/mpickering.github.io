<a href="Tag.hs410719545950951357.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Task.hs1068993879731933551.out.html">next</a></br></br><pre>37c37
< {-# LINE 78 "src/ehc/Base/Target.chs" #-}
---
> 
37a38
> 
37a39
> 
37a40
> 
37a41
> 
37a42
> 
37a43
> 
37a44
> 
37a45
> 
37a46
> 
37a47
> 
37a48
> 
37a49
> 
37a50
> 
37a51
> 
37a52
> 
37a53
> 
37a54
> 
37a55
> 
37a56
> 
37a57
> 
37a58
> 
37a59
> 
37a60
> 
37a61
> 
37a62
> 
37a63
> 
37a64
> 
37a65
> 
37a66
> 
37a67
> 
37a68
> 
37a69
> 
37a70
> 
37a71
> 
37a72
> 
37a73
> 
37a74
> 
37a75
> 
37a76
> 
37a77
> 
68c108
< {-# LINE 119 "src/ehc/Base/Target.chs" #-}
---
> 
68a109
> 
68a110
> 
68a111
> 
68a112
> 
68a113
> 
68a114
> 
68a115
> 
68a116
> 
68a117
> 
68a118
> 
83c133
< {-# LINE 142 "src/ehc/Base/Target.chs" #-}
---
> 
83a134
> 
83a135
> 
83a136
> 
83a137
> 
83a138
> 
83a139
> 
83a140
> 
83a141
> 
87c145
< {-# LINE 155 "src/ehc/Base/Target.chs" #-}
---
> 
87a146
> 
87a147
> 
87a148
> 
87a149
> 
87a150
> 
87a151
> 
87a152
> 
87a153
> 
87a154
> 
108c175
< {-# LINE 211 "src/ehc/Base/Target.chs" #-}
---
> 
108a176
> 
108a177
> 
108a178
> 
108a179
> 
108a180
> 
108a181
> 
108a182
> 
108a183
> 
108a184
> 
108a185
> 
108a186
> 
108a187
> 
108a188
> 
108a189
> 
108a190
> 
108a191
> 
108a192
> 
108a193
> 
108a194
> 
108a195
> 
108a196
> 
108a197
> 
108a198
> 
108a199
> 
108a200
> 
108a201
> 
108a202
> 
108a203
> 
108a204
> 
108a205
> 
108a206
> 
108a207
> 
108a208
> 
108a209
> 
108a210
> 
115c217
< {-# LINE 219 "src/ehc/Base/Target.chs" #-}
---
> 
115a218
> 
119c222
< {-# LINE 224 "src/ehc/Base/Target.chs" #-}
---
> 
119a223
> 
124c228
< {-# LINE 232 "src/ehc/Base/Target.chs" #-}
---
> 
124a229
> 
124a230
> 
124a231
> 
144c251
< {-# LINE 257 "src/ehc/Base/Target.chs" #-}
---
> 
144a252
> 
144a253
> 
144a254
> 
144a255
> 
144a256
> 
150c262
< {-# LINE 286 "src/ehc/Base/Target.chs" #-}
---
> 
150a263
> 
150a264
> 
150a265
> 
150a266
> 
150a267
> 
150a268
> 
150a269
> 
150a270
> 
150a271
> 
150a272
> 
150a273
> 
150a274
> 
150a275
> 
150a276
> 
150a277
> 
150a278
> 
150a279
> 
150a280
> 
150a281
> 
150a282
> 
150a283
> 
150a284
> 
150a285
> 
157c292
< {-# LINE 298 "src/ehc/Base/Target.chs" #-}
---
> 
157a293
> 
157a294
> 
157a295
> 
157a296
> 
157a297
> 
164c304
< {-# LINE 309 "src/ehc/Base/Target.chs" #-}
---
> 
164a305
> 
164a306
> 
164a307
> 
164a308
> 
171c315
< {-# LINE 321 "src/ehc/Base/Target.chs" #-}
---
> 
171a316
> 
171a317
> 
171a318
> 
171a319
> 
171a320
> 
178c327
< {-# LINE 335 "src/ehc/Base/Target.chs" #-}
---
> 
178a328
> 
178a329
> 
178a330
> 
178a331
> 
178a332
> 
178a333
> 
178a334
> 
185c341
< {-# LINE 346 "src/ehc/Base/Target.chs" #-}
---
> 
185a342
> 
185a343
> 
185a344
> 
185a345
> 
192c352
< {-# LINE 357 "src/ehc/Base/Target.chs" #-}
---
> 
192a353
> 
192a354
> 
192a355
> 
192a356
> 
202c366
< {-# LINE 370 "src/ehc/Base/Target.chs" #-}
---
> 
202a367
> 
202a368
> 
202a369
> 
210c377
< {-# LINE 381 "src/ehc/Base/Target.chs" #-}
---
> 
210a378
> 
210a379
> 
210a380
> 
218c388
< {-# LINE 390 "src/ehc/Base/Target.chs" #-}
---
> 
218a389
> 
225c396
< {-# LINE 401 "src/ehc/Base/Target.chs" #-}
---
> 
225a397
> 
225a398
> 
225a399
> 
225a400
> 
232c407
< {-# LINE 412 "src/ehc/Base/Target.chs" #-}
---
> 
232a408
> 
232a409
> 
232a410
> 
232a411
> 
239c418
< {-# LINE 423 "src/ehc/Base/Target.chs" #-}
---
> 
239a419
> 
239a420
> 
239a421
> 
239a422
> 
246c429
< {-# LINE 457 "src/ehc/Base/Target.chs" #-}
---
> 
246a430
> 
246a431
> 
246a432
> 
246a433
> 
246a434
> 
246a435
> 
246a436
> 
246a437
> 
246a438
> 
246a439
> 
246a440
> 
246a441
> 
246a442
> 
246a443
> 
246a444
> 
246a445
> 
246a446
> 
246a447
> 
246a448
> 
246a449
> 
246a450
> 
246a451
> 
246a452
> 
246a453
> 
246a454
> 
246a455
> 
246a456
> 
253c463
< {-# LINE 469 "src/ehc/Base/Target.chs" #-}
---
> 
253a464
> 
253a465
> 
253a466
> 
253a467
> 
253a468
> 
268c483
< {-# LINE 499 "src/ehc/Base/Target.chs" #-}
---
> 
268a484
> 
268a485
> 
268a486
> 
268a487
> 
268a488
> 
268a489
> 
268a490
> 
268a491
> 
268a492
> 
268a493
> 
268a494
> 
268a495
> 
268a496
> 
268a497
> 
268a498
> 
274c504
< {-# LINE 527 "src/ehc/Base/Target.chs" #-}
---
> 
274a505
> 
274a506
> 
274a507
> 
274a508
> 
274a509
> 
274a510
> 
274a511
> 
274a512
> 
274a513
> 
274a514
> 
274a515
> 
274a516
> 
274a517
> 
274a518
> 
274a519
> 
274a520
> 
274a521
> 
274a522
> 
274a523
> 
274a524
> 
274a525
> 
274a526
> 
282c534
< {-# LINE 536 "src/ehc/Base/Target.chs" #-}
---
> 
282a535
> 
290c543
< {-# LINE 549 "src/ehc/Base/Target.chs" #-}
---
> 
290a544
> 
290a545
> 
290a546
> 
290a547
> 
290a548
> 
300c558
< {-# LINE 564 "src/ehc/Base/Target.chs" #-}
---
> 
300a559
> 
300a560
> 
300a561
> 
300a562
> 
300a563
> 
325a589
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.Target
( Target (..)
, defaultTarget
, supportedTargetMp, showSupportedTargets', showSupportedTargets
, TargetFlavor (..)
, defaultTargetFlavor
, allTargetFlavorMp, showAllTargetFlavors', showAllTargetFlavors
, targetDoesHPTAnalysis
, targetIsViaGrin
, targetIsGrinBytecode
, targetAllowsGrinNodePtrMix
, targetIsC
, targetAllowsOLinking
, targetAllowsJarLinking
, targetIsCoreVariation
, targetIsCoreRun
, targetIsTyCore
, targetIsJVM
, targetIsViaGrinCmmJavaScript
, targetIsViaCoreJavaScript
, targetIsJavaScript
, targetIsOnUnixAndOrC
, FFIWay (..)
, ffiWayForPrim
, TargetInfo (..), TargInfoMp
, allTargetInfoMp, allFFIWays )
where
import qualified Data.Map as Map
import Data.List
import UHC.Util.Pretty
import UHC.Util.Utils
import UHC.Util.Binary
import UHC.Util.Serialize



{-# LINE 78 "src/ehc/Base/Target.chs" #-}
-- | All possible targets, even though they may not be configured (done in supportedTargetMp)
data Target
  = Target_None                             -- no codegen
  | Target_None_Core_AsIs                   -- only Core
  | Target_None_Core_CoreRun                -- CoreRun via Core
  | Target_None_TyCore_None                 -- only TyCore

  -- jazy
  | Target_Interpreter_Core_Jazy            -- java based on Core, using jazy library

  -- javascript
  | Target_Interpreter_Core_JavaScript      -- javascript based on Core
  | Target_Interpreter_GrinCmm_JavaScript   -- javascript based on Grin -> Cmm

  -- grin, wholeprogC
  | Target_FullProgAnal_Grin_C              -- full program analysis on grin, generating C

  -- grin, llvm, wholeprogC
  | Target_FullProgAnal_Grin_LLVM           -- full program analysis on grin, generating LLVM

  -- grin, jvm, wholeprogC
  | Target_FullProgAnal_Grin_JVM            -- full program analysis on grin, generating for Java VM

  -- grin
  | Target_Interpreter_Grin_C               -- no full program analysis, grin interpreter, generating C

  -- grin, clr, wholeprogC
  | Target_FullProgAnal_Grin_CLR            -- full program analysis on grin, generating for Common Language Runtime (.NET / Mono)
  deriving ( Eq, Ord, Enum )

{-# LINE 119 "src/ehc/Base/Target.chs" #-}
instance Show Target where
  show Target_None                          = "NONE"
  show Target_None_Core_AsIs                = "cr"
  show Target_None_Core_CoreRun             = "crr"
  show Target_None_TyCore_None              = "tycore"
  show Target_Interpreter_Core_Jazy         = "jazy"
  show Target_Interpreter_Core_JavaScript   = "js"
  show Target_Interpreter_GrinCmm_JavaScript= "cmmjs"
  show Target_FullProgAnal_Grin_C           = "C"
  show Target_FullProgAnal_Grin_LLVM        = "llvm"
  show Target_FullProgAnal_Grin_JVM         = "jvm"
  show Target_Interpreter_Grin_C            = "bc"
  show Target_FullProgAnal_Grin_CLR         = "clr"

{-# LINE 142 "src/ehc/Base/Target.chs" #-}
defaultTarget :: Target
defaultTarget = Target_None_Core_AsIs

{-# LINE 155 "src/ehc/Base/Target.chs" #-}
supportedTargetMp :: Map.Map String Target
(supportedTargetMp,allTargetInfoMp)
  = (Map.fromList ts, Map.fromList is)
  where (ts,is) = unzip
          [ ((show t, t),(t,i))
          | (t,i)
              <- []
                 ++ [ mk Target_None_Core_AsIs [] ]
                 -- ++ [ mk Target_None_Core_CoreRun [] ]
          ]
        mk t ffis = (t,TargetInfo (FFIWay_Prim : ffis))

showSupportedTargets' :: String -> String
showSupportedTargets'
  = showStringMapKeys supportedTargetMp

showSupportedTargets :: String
showSupportedTargets
  = showSupportedTargets' " "

{-# LINE 211 "src/ehc/Base/Target.chs" #-}
data TargetFlavor
  = TargetFlavor_Plain                      -- no special stuff
  | TargetFlavor_Debug                      -- debugging variant
  -- more: profiling, ....
  deriving (Eq,Ord,Enum)

{-# LINE 219 "src/ehc/Base/Target.chs" #-}
defaultTargetFlavor :: TargetFlavor
defaultTargetFlavor = TargetFlavor_Plain

{-# LINE 224 "src/ehc/Base/Target.chs" #-}
instance Show TargetFlavor where
  show TargetFlavor_Plain               = "plain"
  show TargetFlavor_Debug               = "debug"

{-# LINE 232 "src/ehc/Base/Target.chs" #-}
allTargetFlavorMp :: Map.Map String TargetFlavor
allTargetFlavorMp
  = Map.fromList ts
  where ts
          = [ (show t, t)
            | t <-
                  [ TargetFlavor_Plain
                  , TargetFlavor_Debug
                  ]
            ]

showAllTargetFlavors' :: String -> String
showAllTargetFlavors'
  = showStringMapKeys allTargetFlavorMp

showAllTargetFlavors :: String
showAllTargetFlavors
  = showAllTargetFlavors' " "

{-# LINE 257 "src/ehc/Base/Target.chs" #-}
targetDoesHPTAnalysis :: Target -> Bool
targetDoesHPTAnalysis t
  = case t of
      _                                 -> False

{-# LINE 286 "src/ehc/Base/Target.chs" #-}
targetIsViaGrin :: Target -> Bool
targetIsViaGrin t
  = case t of
      _                                 -> False
{-# INLINE targetIsViaGrin #-}

{-# LINE 298 "src/ehc/Base/Target.chs" #-}
targetIsGrinBytecode :: Target -> Bool
targetIsGrinBytecode t
  = case t of
      _                                 -> False
{-# INLINE targetIsGrinBytecode #-}

{-# LINE 309 "src/ehc/Base/Target.chs" #-}
targetAllowsGrinNodePtrMix :: Target -> Bool
targetAllowsGrinNodePtrMix t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsGrinNodePtrMix #-}

{-# LINE 321 "src/ehc/Base/Target.chs" #-}
targetIsC :: Target -> Bool
targetIsC t
  = case t of
      _                                 -> False
{-# INLINE targetIsC #-}

{-# LINE 335 "src/ehc/Base/Target.chs" #-}
targetAllowsOLinking :: Target -> Bool
targetAllowsOLinking t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsOLinking #-}

{-# LINE 346 "src/ehc/Base/Target.chs" #-}
targetAllowsJarLinking :: Target -> Bool
targetAllowsJarLinking t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsJarLinking #-}

{-# LINE 357 "src/ehc/Base/Target.chs" #-}
-- | Is a variation of direct Core running, without further platform dependent translation
targetIsCoreVariation :: Target -> Bool
targetIsCoreVariation t
  = case t of
      Target_None_Core_AsIs             -> True
      Target_None_Core_CoreRun          -> True
      _                                 -> False
{-# INLINE targetIsCoreVariation #-}

{-# LINE 370 "src/ehc/Base/Target.chs" #-}
-- | Is CoreRun target
targetIsCoreRun :: Target -> Bool
targetIsCoreRun t
  = case t of
      Target_None_Core_CoreRun          -> True
      _                                 -> False

{-# LINE 381 "src/ehc/Base/Target.chs" #-}
targetIsTyCore :: Target -> Bool
targetIsTyCore t
  = case t of
      Target_None_TyCore_None           -> True
      _                                 -> False
{-# INLINE targetIsTyCore #-}

{-# LINE 390 "src/ehc/Base/Target.chs" #-}
targetIsJVM :: Target -> Bool
targetIsJVM t
  = case t of
      _                                 -> False
{-# INLINE targetIsJVM #-}

{-# LINE 401 "src/ehc/Base/Target.chs" #-}
targetIsViaGrinCmmJavaScript :: Target -> Bool
targetIsViaGrinCmmJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsViaGrinCmmJavaScript #-}

{-# LINE 412 "src/ehc/Base/Target.chs" #-}
targetIsViaCoreJavaScript :: Target -> Bool
targetIsViaCoreJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsViaCoreJavaScript #-}

{-# LINE 423 "src/ehc/Base/Target.chs" #-}
targetIsJavaScript :: Target -> Bool
targetIsJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsJavaScript #-}

{-# LINE 457 "src/ehc/Base/Target.chs" #-}
-- | target runs on (possibly emulated) UNIX / C environment? this should coincide with flag EHC_CFG_USE_UNIX_AND_C in src/ehc/variant.mk
targetIsOnUnixAndOrC :: Target -> Bool
targetIsOnUnixAndOrC t
  = targetIsC t || targetIsJVM t
{-# INLINE targetIsOnUnixAndOrC #-}

{-# LINE 469 "src/ehc/Base/Target.chs" #-}
data FFIWay
  = FFIWay_Prim             -- as primitive
  | FFIWay_CCall            -- as C call
  | FFIWay_Jazy             -- as Java/Jazy
  deriving (Eq,Ord,Enum)

instance Show FFIWay where
  show FFIWay_Prim          = "prim"
  show FFIWay_CCall         = "ccall"
  show FFIWay_Jazy          = "jazy"

instance PP FFIWay where
  pp = pp . show

{-# LINE 499 "src/ehc/Base/Target.chs" #-}
ffiWayForPrim :: Target -> Maybe FFIWay
ffiWayForPrim t
  | targetIsC t                                     = Just FFIWay_CCall
  | otherwise                                       = Nothing

{-# LINE 527 "src/ehc/Base/Target.chs" #-}
data TargetInfo
  = TargetInfo
      { targiAllowedFFI     :: [FFIWay]
      }

type TargInfoMp = Map.Map Target TargetInfo

{-# LINE 536 "src/ehc/Base/Target.chs" #-}
allTargetInfoMp :: TargInfoMp

-- | All allowed platform dependent ways to do a FFI call, a primitive 'FFIWay_Prim' is always allowed even though there might be no backend for it.
-- This allows code still to compile when no target/backend is available.
allFFIWays :: [FFIWay]
allFFIWays = nub $ (FFIWay_Prim :) $ concatMap targiAllowedFFI $ Map.elems allTargetInfoMp

{-# LINE 549 "src/ehc/Base/Target.chs" #-}
deriving instance Typeable Target
deriving instance Data Target

deriving instance Typeable FFIWay
deriving instance Data FFIWay

deriving instance Typeable TargetFlavor
deriving instance Data TargetFlavor

{-# LINE 564 "src/ehc/Base/Target.chs" #-}
instance Binary Target where
  put = putEnum8
  get = getEnum8

instance Serialize Target where
  sput = sputPlain
  sget = sgetPlain

instance Binary FFIWay where
  put = putEnum8
  get = getEnum8

instance Serialize FFIWay where
  sput = sputPlain
  sget = sgetPlain

instance Binary TargetFlavor where
  put = putEnum8
  get = getEnum8

instance Serialize TargetFlavor where
  sput = sputPlain
  sget = sgetPlain


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.Target
( Target (..)
, defaultTarget
, supportedTargetMp, showSupportedTargets', showSupportedTargets
, TargetFlavor (..)
, defaultTargetFlavor
, allTargetFlavorMp, showAllTargetFlavors', showAllTargetFlavors
, targetDoesHPTAnalysis
, targetIsViaGrin
, targetIsGrinBytecode
, targetAllowsGrinNodePtrMix
, targetIsC
, targetAllowsOLinking
, targetAllowsJarLinking
, targetIsCoreVariation
, targetIsCoreRun
, targetIsTyCore
, targetIsJVM
, targetIsViaGrinCmmJavaScript
, targetIsViaCoreJavaScript
, targetIsJavaScript
, targetIsOnUnixAndOrC
, FFIWay (..)
, ffiWayForPrim
, TargetInfo (..), TargInfoMp
, allTargetInfoMp, allFFIWays )
where
import qualified Data.Map as Map
import Data.List
import UHC.Util.Pretty
import UHC.Util.Utils
import UHC.Util.Binary
import UHC.Util.Serialize












































-- | All possible targets, even though they may not be configured (done in supportedTargetMp)
data Target
  = Target_None                             -- no codegen
  | Target_None_Core_AsIs                   -- only Core
  | Target_None_Core_CoreRun                -- CoreRun via Core
  | Target_None_TyCore_None                 -- only TyCore

  -- jazy
  | Target_Interpreter_Core_Jazy            -- java based on Core, using jazy library

  -- javascript
  | Target_Interpreter_Core_JavaScript      -- javascript based on Core
  | Target_Interpreter_GrinCmm_JavaScript   -- javascript based on Grin -> Cmm

  -- grin, wholeprogC
  | Target_FullProgAnal_Grin_C              -- full program analysis on grin, generating C

  -- grin, llvm, wholeprogC
  | Target_FullProgAnal_Grin_LLVM           -- full program analysis on grin, generating LLVM

  -- grin, jvm, wholeprogC
  | Target_FullProgAnal_Grin_JVM            -- full program analysis on grin, generating for Java VM

  -- grin
  | Target_Interpreter_Grin_C               -- no full program analysis, grin interpreter, generating C

  -- grin, clr, wholeprogC
  | Target_FullProgAnal_Grin_CLR            -- full program analysis on grin, generating for Common Language Runtime (.NET / Mono)
  deriving ( Eq, Ord, Enum )












instance Show Target where
  show Target_None                          = "NONE"
  show Target_None_Core_AsIs                = "cr"
  show Target_None_Core_CoreRun             = "crr"
  show Target_None_TyCore_None              = "tycore"
  show Target_Interpreter_Core_Jazy         = "jazy"
  show Target_Interpreter_Core_JavaScript   = "js"
  show Target_Interpreter_GrinCmm_JavaScript= "cmmjs"
  show Target_FullProgAnal_Grin_C           = "C"
  show Target_FullProgAnal_Grin_LLVM        = "llvm"
  show Target_FullProgAnal_Grin_JVM         = "jvm"
  show Target_Interpreter_Grin_C            = "bc"
  show Target_FullProgAnal_Grin_CLR         = "clr"










defaultTarget :: Target
defaultTarget = Target_None_Core_AsIs











supportedTargetMp :: Map.Map String Target
(supportedTargetMp,allTargetInfoMp)
  = (Map.fromList ts, Map.fromList is)
  where (ts,is) = unzip
          [ ((show t, t),(t,i))
          | (t,i)
              <- []
                 ++ [ mk Target_None_Core_AsIs [] ]
                 -- ++ [ mk Target_None_Core_CoreRun [] ]
          ]
        mk t ffis = (t,TargetInfo (FFIWay_Prim : ffis))

showSupportedTargets' :: String -> String
showSupportedTargets'
  = showStringMapKeys supportedTargetMp

showSupportedTargets :: String
showSupportedTargets
  = showSupportedTargets' " "





































data TargetFlavor
  = TargetFlavor_Plain                      -- no special stuff
  | TargetFlavor_Debug                      -- debugging variant
  -- more: profiling, ....
  deriving (Eq,Ord,Enum)



defaultTargetFlavor :: TargetFlavor
defaultTargetFlavor = TargetFlavor_Plain



instance Show TargetFlavor where
  show TargetFlavor_Plain               = "plain"
  show TargetFlavor_Debug               = "debug"





allTargetFlavorMp :: Map.Map String TargetFlavor
allTargetFlavorMp
  = Map.fromList ts
  where ts
          = [ (show t, t)
            | t <-
                  [ TargetFlavor_Plain
                  , TargetFlavor_Debug
                  ]
            ]

showAllTargetFlavors' :: String -> String
showAllTargetFlavors'
  = showStringMapKeys allTargetFlavorMp

showAllTargetFlavors :: String
showAllTargetFlavors
  = showAllTargetFlavors' " "







targetDoesHPTAnalysis :: Target -> Bool
targetDoesHPTAnalysis t
  = case t of
      _                                 -> False

























targetIsViaGrin :: Target -> Bool
targetIsViaGrin t
  = case t of
      _                                 -> False
{-# INLINE targetIsViaGrin #-}







targetIsGrinBytecode :: Target -> Bool
targetIsGrinBytecode t
  = case t of
      _                                 -> False
{-# INLINE targetIsGrinBytecode #-}






targetAllowsGrinNodePtrMix :: Target -> Bool
targetAllowsGrinNodePtrMix t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsGrinNodePtrMix #-}







targetIsC :: Target -> Bool
targetIsC t
  = case t of
      _                                 -> False
{-# INLINE targetIsC #-}









targetAllowsOLinking :: Target -> Bool
targetAllowsOLinking t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsOLinking #-}






targetAllowsJarLinking :: Target -> Bool
targetAllowsJarLinking t
  = case t of
      _                                 -> False
{-# INLINE targetAllowsJarLinking #-}






-- | Is a variation of direct Core running, without further platform dependent translation
targetIsCoreVariation :: Target -> Bool
targetIsCoreVariation t
  = case t of
      Target_None_Core_AsIs             -> True
      Target_None_Core_CoreRun          -> True
      _                                 -> False
{-# INLINE targetIsCoreVariation #-}





-- | Is CoreRun target
targetIsCoreRun :: Target -> Bool
targetIsCoreRun t
  = case t of
      Target_None_Core_CoreRun          -> True
      _                                 -> False





targetIsTyCore :: Target -> Bool
targetIsTyCore t
  = case t of
      Target_None_TyCore_None           -> True
      _                                 -> False
{-# INLINE targetIsTyCore #-}



targetIsJVM :: Target -> Bool
targetIsJVM t
  = case t of
      _                                 -> False
{-# INLINE targetIsJVM #-}






targetIsViaGrinCmmJavaScript :: Target -> Bool
targetIsViaGrinCmmJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsViaGrinCmmJavaScript #-}






targetIsViaCoreJavaScript :: Target -> Bool
targetIsViaCoreJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsViaCoreJavaScript #-}






targetIsJavaScript :: Target -> Bool
targetIsJavaScript t
  = case t of
      _                                     -> False
{-# INLINE targetIsJavaScript #-}





























-- | target runs on (possibly emulated) UNIX / C environment? this should coincide with flag EHC_CFG_USE_UNIX_AND_C in src/ehc/variant.mk
targetIsOnUnixAndOrC :: Target -> Bool
targetIsOnUnixAndOrC t
  = targetIsC t || targetIsJVM t
{-# INLINE targetIsOnUnixAndOrC #-}







data FFIWay
  = FFIWay_Prim             -- as primitive
  | FFIWay_CCall            -- as C call
  | FFIWay_Jazy             -- as Java/Jazy
  deriving (Eq,Ord,Enum)

instance Show FFIWay where
  show FFIWay_Prim          = "prim"
  show FFIWay_CCall         = "ccall"
  show FFIWay_Jazy          = "jazy"

instance PP FFIWay where
  pp = pp . show

















ffiWayForPrim :: Target -> Maybe FFIWay
ffiWayForPrim t
  | targetIsC t                                     = Just FFIWay_CCall
  | otherwise                                       = Nothing
























data TargetInfo
  = TargetInfo
      { targiAllowedFFI     :: [FFIWay]
      }

type TargInfoMp = Map.Map Target TargetInfo



allTargetInfoMp :: TargInfoMp

-- | All allowed platform dependent ways to do a FFI call, a primitive 'FFIWay_Prim' is always allowed even though there might be no backend for it.
-- This allows code still to compile when no target/backend is available.
allFFIWays :: [FFIWay]
allFFIWays = nub $ (FFIWay_Prim :) $ concatMap targiAllowedFFI $ Map.elems allTargetInfoMp







deriving instance Typeable Target
deriving instance Data Target

deriving instance Typeable FFIWay
deriving instance Data FFIWay

deriving instance Typeable TargetFlavor
deriving instance Data TargetFlavor







instance Binary Target where
  put = putEnum8
  get = getEnum8

instance Serialize Target where
  sput = sputPlain
  sget = sgetPlain

instance Binary FFIWay where
  put = putEnum8
  get = getEnum8

instance Serialize FFIWay where
  sput = sputPlain
  sget = sgetPlain

instance Binary TargetFlavor where
  put = putEnum8
  get = getEnum8

instance Serialize TargetFlavor where
  sput = sputPlain
  sget = sgetPlain



</pre>