<a href="CoreToAlgebra.hs178425210905333258.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Counter.hs225419518464685718.out.html">next</a></br></br><pre>19d18
< type family n :+ m
20d18
< type instance n :+ Z     = n
21c19
< type instance n :+ (S m) = S (n :+ m)
---
> type family   :+    m
21a20
> type instance   :+    Z     = n
21a21
> type instance   :+    (S m) = S (n :+ m)
38a39
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TypeFamilies, EmptyDataDecls, TypeOperators #-}

module Control.Effect.Counter(Z, S, Counter, tick, (:+)) where

import Control.Effect
import Prelude hiding (Monad(..))

{-| Provides a way to 'count' in the type-level with a monadic interface
    to sum up the individual counts of subcomputations -}

{-| Define type constructors for natural numbers -}
data Z
data S n

{-| The counter has no semantic meaning -}
data Counter n a = Counter { forget :: a }

{-| Type-level addition -}
type family n :+ m
type instance n :+ Z     = n
type instance n :+ (S m) = S (n :+ m)

instance Effect Counter where
    type Inv Counter n m = ()

    {-| Trivial effect annotation is 0 -}
    type Unit Counter = Z
    {-| Compose effects by addition -}
    type Plus Counter n m = n :+ m

    return a = Counter a
    (Counter a) >>= k = Counter . forget $ k a

{-| A 'tick' provides a way to increment the counter -}
tick :: a -> Counter (S Z) a
tick x = Counter x


</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TypeFamilies, EmptyDataDecls, TypeOperators #-}

module Control.Effect.Counter(Z, S, Counter, tick, (:+)) where

import Control.Effect
import Prelude hiding (Monad(..))

{-| Provides a way to 'count' in the type-level with a monadic interface
    to sum up the individual counts of subcomputations -}

{-| Define type constructors for natural numbers -}
data Z
data S n

{-| The counter has no semantic meaning -}
data Counter n a = Counter { forget :: a }

{-| Type-level addition -}
type family   :+    m
type instance   :+    Z     = n
type instance   :+    (S m) = S (n :+ m)

instance Effect Counter where
    type Inv Counter n m = ()

    {-| Trivial effect annotation is 0 -}
    type Unit Counter = Z
    {-| Compose effects by addition -}
    type Plus Counter n m = n :+ m

    return a = Counter a
    (Counter a) >>= k = Counter . forget $ k a

{-| A 'tick' provides a way to increment the counter -}
tick :: a -> Counter (S Z) a
tick x = Counter x



</pre>