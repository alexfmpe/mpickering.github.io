<a href="FD.hs571540977194847408.out.html">prev</a></br><a href="failures.html">home</a></br><a href="FilePath.hs1486421564609960597.out.html">next</a></br></br><pre>161c161
< {-# DEPRECATED timeField "'timeField' currently defaults to an input of type=\"text\". In the next major release, it will default to type=\"time\". To opt in to the new functionality, use 'timeFieldTypeTime'. To keep the existing behavior, use 'timeFieldTypeText'. See 'https://github.com/yesodweb/yesod/pull/874' for details." #-}
---
> {-# DEPRECATED timeField "'timeField' currently defaults to an input of type="text". In the next major release, it will default to type="time". To opt in to the new functionality, use 'timeFieldTypeTime'. To keep the existing behavior, use 'timeFieldTypeText'. See 'https://github.com/yesodweb/yesod/pull/874' for details." #-}
198c198
<     { fieldParse = parseHelper $ Right . preEscapedText . sanitizeBalance
---
>     { fieldParse = parseHelper $ Right . preEscapedToMarkuppreEscapedText . sanitizeBalance sanitizeBalance
216d215
< instance ToHtml Textarea where
217c216
<     toHtml =
---
> instance ToMarkupToHtml Textareawherewhere
217a217
>     toMarkuptoHtml = =
497a498
> 
500d500
< -- | Creates an input with @type="radio"@ for selecting one option.
501d500
< radioField :: (Eq a, RenderMessage site FormMessage)
502d500
<            => HandlerT site IO (OptionList a)
503d500
<            -> Field (HandlerT site IO) a
504d500
< radioField = selectFieldHelper
505c501
<     (\theId _name _attrs inside -> [whamlet|
---
> -- | Creates an input with @type="radio"@ for selecting one option.}
505a502
> radioField-- | Creates an input with @type="radio"@ for selecting one option.:: (Eq a, RenderMessage site FormMessage)
505a503
> radioField :: (HandlerTEq a, RenderMessagesite IO (OptionList FormMessagea)      )
505a504
>            => HandlerTField (HandlerT IOsiteOptionListIO) a   a)
505a505
> radioField ->= selectFieldHelper (HandlerT site IO) a
505a506
> radioField(\theId=_name_attrs inside -> [whamlet|
508d508
< |])
509c509
<     (\theId name isSel -> [whamlet|
---
> |]  \theId _name _attrs inside -> [whamlet|
510a511
> <div ##{theId}>^{inside}
510a512
> |]) (\theId name isSel -> [whamlet|
510a513
> $newline never
515d517
< |])
516c518
<     (\theId name attrs value isSel text -> [whamlet|
---
> |]  \theId name isSel -> [whamlet|
517a520
> <label .radio for=#{theId}-none>
517a521
>     <div>
517a522
>         <input id=#{theId}-none type=radio name=#{name} value=none :isSel:checked>
517a523
>         _{MsgSelectNone}
517a524
> |]) (\theId name attrs value isSel text -> [whamlet|
517a525
> $newline never
521a530
> |]  \theId name attrs value isSel text -> [whamlet|
521a531
> $newline never
521a532
> <label .radio for=#{theId}-#{value}>
521a533
>     <div>
521a534
>         <input id=#{theId}-#{value} type=radio name=#{name} value=#{value} :isSel:checked *{attrs}>
521a535
>         \#{text}
523d536
< 
525d537
< --
526d537
< -- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
527d537
< --
528d537
< -- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
529d537
< --
530d537
< -- (Exact label titles will depend on localization).
531d537
< boolField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
532d537
< boolField = Field
533d537
<       { fieldParse = \e _ -> return $ boolParser e
534c538
<       , fieldView = \theId name attrs val isReq -> [whamlet|
---
> ---- | Creates a group of radio buttons to answer the question given in the message. Radio buttons are used to allow differentiating between an empty response (@Nothing@) and a no response (@Just False@). Consider using the simpler 'checkBoxField' if you don't need to make this distinction.
534a539
> ---- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
534a540
> ---- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
534a541
> ---- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
534a542
> ---- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
534a543
> ---- (Exact label titles will depend on localization).
534a544
> boolField-- (Exact label titles will depend on localization).:: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
534a545
> boolField ::= Field m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
534a546
> boolField{ fieldParse= Field  = \e _ -> return $ boolParser e
534a547
>       { fieldParsefieldView ==\\theIde _ ->nameattrs boolParserval isReq -> [whamlet|
546c559
< |]
---
> |]    , fieldView = \theId name attrs val isReq -> [whamlet|
546a560
> $newline never
546a561
>   $if not isReq
546a562
>       <input id=#{theId}-none *{attrs} type=radio name=#{name} value=none checked>
546a563
>       <label for=#{theId}-none>_{MsgSelectNone}
546a564
> 
546a565
> 
546a566
> <input id=#{theId}-yes *{attrs} type=radio name=#{name} value=yes :showVal id val:checked>
546a567
> <label for=#{theId}-yes>_{MsgBoolYes}
546a568
> 
546a569
> <input id=#{theId}-no *{attrs} type=radio name=#{name} value=no :showVal not val:checked>
546a570
> <label for=#{theId}-no>_{MsgBoolNo}
546a571
> |]  , fieldEnctype = UrlEncoded
548d572
<     }
549d572
<   where
550d572
<     boolParser [] = Right Nothing
551d572
<     boolParser (x:_) = case x of
552d572
<       "" -> Right Nothing
553d572
<       "none" -> Right Nothing
554d572
<       "yes" -> Right $ Just True
555d572
<       "on" -> Right $ Just True
556d572
<       "no" -> Right $ Just False
557d572
<       "true" -> Right $ Just True
558d572
<       "false" -> Right $ Just False
559c573
<       t -> Left $ SomeMessage $ MsgInvalidBool t
---
>   where}
559a574
>   whereboolParser [] = Right Nothing
559a575
>     boolParser []:=)Right= casex of
559a576
>     boolParser"" -> Rightx:_Nothing) = case x of
559a577
>       """none" Right-> RightNothing
559a578
>       "none""yes" ->Right$NothingJust True
559a579
>       "yes""on" ->Right$$JustTrue
559a580
>       "on" -> Right $ Just TrueFalse
559a581
>       "no""true"->Right Just$ JustTrue
559a582
>       "true""false"->->RightRight$$JustJustTrueFalse
559a583
>       "false"t -> Left$RightSomeMessage Just False$ MsgInvalidBool t
559a584
>     showVal -> Left= either SomeMessage(\_ -> False MsgInvalidBool)             t
561d585
< 
562a587
> -- | Creates an input with @type="checkbox"@.--   While the default @'boolField'@ implements a radio button so you
564d588
< --   can differentiate between an empty response (@Nothing@) and a no
565d588
< --   response (@Just False@), this simpler checkbox field returns an empty
566d588
< --   response as @Just False@.
567d588
< --
568d588
< --   Note that this makes the field always optional.
569d588
< --
570d588
< checkBoxField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
571d588
< checkBoxField = Field
572c589
<     { fieldParse = \e _ -> return $ checkBoxParser e
---
> --   can differentiate between an empty response (@Nothing@) and a no--   response (@Just False@), this simpler checkbox field returns an empty
572a590
> --   response as @Just False@.--   response (@Just False@), this simpler checkbox field returns an empty
572a591
> ----   response as @Just False@.
572a592
> ----   Note that this makes the field always optional.
572a593
> ----   Note that this makes the field always optional.
572a594
> --checkBoxField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
572a595
> checkBoxField ::= Field m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
572a596
> checkBoxField{ fieldParse= Field= \e _ -> return $ checkBoxParser e
572a597
>     { fieldParsefieldView  = \etheId ->nameattrs checkBoxParserval _ -> [whamlet|
572a598
> $newline never
572a599
> <input id=#{theId} *{attrs} type=checkbox name=#{name} value=yes :showVal id val:checked>
572a600
> |]                                                 
576c604
< |]
---
> |]  , fieldEnctype = UrlEncoded
579d606
< 
581d607
<         checkBoxParser [] = Right $ Just False
582d607
<         checkBoxParser (x:_) = case x of
583d607
<             "yes" -> Right $ Just True
584c608
<             "on" -> Right $ Just True
---
>     wherecheckBoxParser [] = Right $ Just False
584a609
>         checkBoxParser []:=)Right= case Justx of False
584a610
>         checkBoxParser"yes" -> Rightx:_) =JustTrue of
584a611
>             "yes""on" ->Right$$JustTrue
584a612
>             "on"_    ->->RightRight$$JustJustTrueFalse
586d613
< 
588c615
< 
---
>         showVal = either (\_ -> False)
590d616
< data OptionList a = OptionList
591c617
<     { olOptions :: [Option a]
---
> data-- | A structure holding a list of options. Typically you can use a convenience function like 'mkOptionList' or 'optionsPairs' instead of creating this directly.OptionList a = OptionList
591a618
> data{OptionListolOptions a::=[OptionListOption a]
591a619
>     { olOptionsolReadExternal:: [Option:: Text]-> Maybe a -- ^ A function mapping from the form's value ('optionExternalValue') to the selected Haskell value ('optionInternalValue').
593d620
<     }
594d620
< -- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.
595d620
< mkOptionList :: [Option a] -> OptionList a
596d620
< mkOptionList os = OptionList
597c621
<     { olOptions = os
---
> -- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.}
597a622
> mkOptionList-- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.:: [Option a] -> OptionList a
597a623
> mkOptionList :: [OptionOptionList] -> OptionList a
597a624
> mkOptionList{ olOptions = OptionListos
597a625
>     { olOptionsolReadExternal= os = flip Map.lookup $ Map.fromList $ map (optionExternalValue &&& optionInternalValue) os
600d627
< 
602d628
<     { optionDisplay :: Text -- ^ The user-facing label.
603c629
<     , optionInternalValue :: a -- ^ The Haskell value being selected.
---
> data{OptionoptionDisplay = Option:: Text -- ^ The user-facing label.
603a630
>     { optionDisplayoptionInternalValue:: Text::-- ^ The user-facing label.a -- ^ The Haskell value being selected.
603a631
>     , optionInternalValue :: aText-- ^ The Haskell value being selected.-- ^ The representation of this value stored in the form.
605d632
<     }
606d632
< -- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.
607d632
< optionsPairs :: (MonadHandler m, RenderMessage (HandlerSite m) msg)
608d632
<              => [(msg, a)] -> m (OptionList a)
609d632
< optionsPairs opts = do
610d632
<   mr <- getMessageRender
611d632
<   let mkOption external (display, internal) =
612d632
<           Option { optionDisplay       = mr display
613c633
<                  , optionInternalValue = internal
---
> -- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.}
613a634
> optionsPairs-- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.:: (MonadHandler m, RenderMessage (HandlerSite m) msg)
613a635
> optionsPairs :: (MonadHandler(msg, a)] -> m,(RenderMessageOptionList a) (HandlerSite m) msg)
613a636
> optionsPairs =>opts(msg= do, a)] -> m (OptionList a)
613a637
> optionsPairsmr <- getMessageRender = do
613a638
>   mrlet<-mkOptionexternal (display, internal) =
613a639
>   let mkOptionOption{ optionDisplaydisplay, internal= mr) =display
613a640
>           Option { optionDisplayoptionInternalValue = mrinternal
613a641
>                  , optionInternalValue = internalpack $ show external
615c643
<                  }
---
>   return $ mkOptionList}      (zipWith mkOption [1 :: Int ..] opts)
617d644
< 
619c646
< optionsEnum :: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
---
> optionsEnum-- | Creates an 'OptionList' from an 'Enum', using its 'Show' instance for the user-facing value.:: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
619a647
> optionsEnum ::= optionsPairsMonadHandler$ mmap, Show(\x a->, Enum(packa, Boundedshow x, a))=>[minBound (OptionList..maxBound) ]
621d648
< 
623d649
< --
624d649
< -- > Country
625d649
< -- >    name Text
626d649
< -- >    deriving Eq -- Must derive Eq
627d649
< --
628d649
< -- > data CountryForm = CountryForm
629d649
< -- >   { country :: Entity Country
630d649
< -- >   }
631d649
< -- >
632d649
< -- > countryNameForm :: AForm Handler CountryForm
633d649
< -- > countryNameForm = CountryForm
634d649
< -- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
635d649
< -- >         where
636d649
< -- >           countries = optionsPersist [] [Asc CountryName] countryName
637d649
< optionsPersist :: ( YesodPersist site, PersistEntity a
638d649
<                   , PersistQuery (PersistEntityBackend a)
639d649
<                   , PathPiece (Key a)
640c650
<                   , RenderMessage site msg
---
> ---- | Selects a list of 'Entity's with the given 'Filter' and 'SelectOpt's. The @(a -> msg)@ function is then used to derive the display value for an 'OptionList'. Example usage:
640a651
> ---- > Country
640a652
> -- > Country-- >    name Text
640a653
> -- >    name Text-- >    deriving Eq -- Must derive Eq
640a654
> ---- >    deriving Eq -- Must derive Eq
640a655
> ---- > data CountryForm = CountryForm
640a656
> -- >   { country :: Entity Country-- > data CountryForm = CountryForm
640a657
> -- >   }-- >   { country :: Entity Country
640a658
> -- >-- >   }
640a659
> -- >-- > countryNameForm :: AForm Handler CountryForm
640a660
> -- > countryNameForm = CountryForm-- > countryNameForm :: AForm Handler CountryForm
640a661
> -- > countryNameForm = CountryForm-- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
640a662
> -- >         where-- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
640a663
> -- >         where-- >           countries = optionsPersist [] [Asc CountryName] countryName
640a664
> optionsPersist-- >           countries = optionsPersist [] [Asc CountryName] countryName:: ( YesodPersist site, PersistEntity a
640a665
> optionsPersist :: ( YesodPersist site(PersistEntityBackend, PersistEntity a a)
640a666
>                   , PersistQueryPathPiece (KeyPersistEntityBackenda)                  a)
640a667
>                   , PathPieceRenderMessageKeysite)  msg
640a668
>                   , RenderMessageYesodPersistBackend msgsite ~ PersistEntityBackend a
642d669
<                   )
643d669
<                => [Filter a]
644d669
<                -> [SelectOpt a]
645d669
<                -> (a -> msg)
646d669
<                -> HandlerT site IO (OptionList (Entity a))
647d669
< optionsPersist filts ords toDisplay = fmap mkOptionList $ do
648d669
<     mr <- getMessageRender
649d669
<     pairs <- runDB $ selectList filts ords
650d669
<     return $ map (\(Entity key value) -> Option
651d669
<         { optionDisplay = mr (toDisplay value)
652d669
<         , optionInternalValue = Entity key value
653d669
<         , optionExternalValue = toPathPiece key
654d669
<         }) pairs
655c670
< 
---
>                => )Filter a]
655a671
>                => [FilterSelectOpt] a]
655a672
>                -> [SelectOpta -> msg) a]
655a673
>                -> (HandlerTa -> msg)site IO (OptionList (Entity a))
655a674
> optionsPersist ->filtsords toDisplay IO (OptionList= fmap mkOptionListEntity a))do
655a675
> optionsPersistmr <- getMessageRender ords toDisplay = fmap mkOptionList $ do
655a676
>     mrpairs<- getMessageRender<- runDB $ selectList filts ords
655a677
>     pairsreturn<-$ runDBmap (\$Entitykey value) ords-> Option
655a678
>     return{ optionDisplay map (\(Entity= mr(toDisplay) ->value)
655a679
>                    { optionDisplayoptionInternalValue= mr (toDisplay= Entity keyvalue)
655a680
>                    , optionInternalValue = EntitytoPathPiece valuekey
655a681
>                    ,)optionExternalValuepairs              = toPathPiece key
655a682
>                    }) pairs
657d683
< -- the entire 'Entity'.
658d683
< --
659d683
< -- Since 1.3.2
660d683
< optionsPersistKey
661d683
<   :: (YesodPersist site
662d683
<      , PersistEntity a
663d683
<      , PersistQuery (PersistEntityBackend a)
664d683
<      , PathPiece (Key a)
665c684
<      , RenderMessage site msg
---
> -- the entire 'Entity'.-- | An alternative to 'optionsPersist' which returns just the 'Key' instead of
665a685
> ---- the entire 'Entity'.
665a686
> ---- Since 1.3.2
665a687
> -- Since 1.3.2optionsPersistKey
665a688
> optionsPersistKey:: (YesodPersist site
665a689
>   :: (YesodPersistPersistEntitya
665a690
>      , PersistEntityPersistQuery (aPersistEntityBackend a)
665a691
>      , PersistQueryPathPiece (KeyPersistEntityBackenda)                  a)
665a692
>      , PathPieceRenderMessageKeysite)  msg
665a693
>      , RenderMessageYesodPersistBackend msgsite ~ PersistEntityBackend a
667d694
<      )
668d694
<   => [Filter a]
669d694
<   -> [SelectOpt a]
670c695
<   -> (a -> msg)
---
>   => )Filter a]
670a696
>   => [FilterSelectOpt] a]
670a697
>   -> [SelectOpta -> msg) a]
670a698
>   -> (HandlerTa -> msg)site IO (OptionList (Key a))
672d699
< 
674d700
<     mr <- getMessageRender
675d700
<     pairs <- runDB $ selectList filts ords
676d700
<     return $ map (\(Entity key value) -> Option
677d700
<         { optionDisplay = mr (toDisplay value)
678d700
<         , optionInternalValue = key
679d700
<         , optionExternalValue = toPathPiece key
680d700
<         }) pairs
681c701
< 
---
> optionsPersistKeymr <- getMessageRender ords toDisplay = fmap mkOptionList $ do
681a702
>     mrpairs<- getMessageRender<- runDB $ selectList filts ords
681a703
>     pairsreturn<-$ runDBmap (\$Entitykey value) ords-> Option
681a704
>     return{ optionDisplay map (\(Entity= mr(toDisplay) ->value)
681a705
>                    { optionDisplayoptionInternalValue= mr (toDisplay= key     value)
681a706
>                    , optionInternalValue = keytoPathPiece key
681a707
>                    ,)optionExternalValuepairs              = toPathPiece key
681a708
>                    }) pairs
683d709
<         :: (Eq a, RenderMessage site FormMessage)
684d709
<         => (Text -> Text -> [(Text, Text)] -> WidgetT site IO () -> WidgetT site IO ())
685d709
<         -> (Text -> Text -> Bool -> WidgetT site IO ())
686d709
<         -> (Text -> Text -> [(Text, Text)] -> Text -> Bool -> Text -> WidgetT site IO ())
687d709
<         -> HandlerT site IO (OptionList a)
688d709
<         -> Field (HandlerT site IO) a
689d709
< selectFieldHelper outside onOpt inside opts' = Field
690d709
<     { fieldParse = \x _ -> do
691d709
<         opts <- opts'
692d709
<         return $ selectParser opts x
693d709
<     , fieldView = \theId name attrs val isReq -> do
694d709
<         opts <- fmap olOptions $ handlerToWidget opts'
695d709
<         outside theId name attrs $ do
696d709
<             unless isReq $ onOpt theId name $ not $ render opts val `elem` map optionExternalValue opts
697d709
<             flip mapM_ opts $ \opt -> inside
698d709
<                 theId
699d709
<                 name
700d709
<                 ((if isReq then (("required", "required"):) else id) attrs)
701d709
<                 (optionExternalValue opt)
702d709
<                 ((render opts val) == optionExternalValue opt)
703c710
<                 (optionDisplay opt)
---
> selectFieldHelper:: (Eq a, RenderMessage site FormMessage)
703a711
>         :: (EqText,->Text -> [(Text, Text)] -> WidgetT)     site IO () -> WidgetT site IO ())
703a712
>         => (Text -> Text -> [Bool(Text->, TextWidgetT)] ->siteIO ()site)    IO () -> WidgetT site IO ())
703a713
>         -> (Text -> Text -> Bool[(Text->, WidgetTText)] ->Text->))Bool -> Text -> WidgetT site IO ())
703a714
>         -> (HandlerTText -> Text -> [(OptionListText, Text)] -> Text -> Bool -> Text -> WidgetT site IO ())
703a715
>         -> HandlerTField (HandlerT IOsiteOptionListIO) a   a)
703a716
> selectFieldHelper-> Field (HandlerToutside onOpt IOinside) a  opts' = Field
703a717
> selectFieldHelper{ fieldParse =outside\x _ ->onOptdo   inside opts' = Field
703a718
>     { fieldParseopts <- opts'= \x _ -> do
703a719
>             optsreturn<-$opts'selectParser opts x
703a720
>         , fieldView $=selectParser\theId name optsattrsxval isReq -> do
703a721
>     , fieldViewopts <- =fmaptheIdolOptions attrs$ handlerToWidget isReq -> doopts'
703a722
>          optsoutside<- fmaptheIdolOptionsname attrs handlerToWidget$ do            opts'
703a723
>          outsideunlessisReq$ attrs $theId  name $ not $ render opts val `elem` map optionExternalValue opts
703a724
>              unlessflip mapM_opts onOpt$ \opt-> inside $ not $ render opts val `elem` map optionExternalValue opts
703a725
>              fliptheId opts $ \opt -> inside
703a726
>                 theIdname
703a727
>                 name((if isReq then (("required", "required"):) else id) attrs)
703a728
>                 ((optionExternalValueif isReq then (("required"opt)   , "required"):) else id) attrs)
703a729
>                 (optionExternalValue(render opts val) ==optoptionExternalValue)                 opt)
703a730
>                 ((optionDisplayrender opts valopt))== optionExternalValue opt)
703a731
>     , fieldEnctypeoptionDisplay= UrlEncodedopt)
705d732
<     }
706d732
<   where
707d732
<     render _ (Left _) = ""
708d732
<     render opts (Right a) = maybe "" optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
709d732
<     selectParser _ [] = Right Nothing
710d732
<     selectParser opts (s:_) = case s of
711d732
<             "" -> Right Nothing
712d732
<             "none" -> Right Nothing
713d732
<             x -> case olReadExternal opts x of
714c733
<                     Nothing -> Left $ SomeMessage $ MsgInvalidEntry x
---
>   where}
714a734
>   whererender _ (Left _) = ""
714a735
>     render _optsLeft(Right) =a"") = maybe "" optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
714a736
>     renderselectParser (Right_ [] =a)Right= maybeNothing optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
714a737
>     selectParser _opts] =sRight:_) = Nothingcase s of
714a738
>     selectParser"" ->optsRights:Nothing_) = case s of
714a739
>             """none" Right-> RightNothing
714a740
>             "none"x -> case RightolReadExternal  opts x of
714a741
>             x -> caseNothing-> Left $optsSomeMessage of    $ MsgInvalidEntry x
714a742
>                     NothingJust y ->Right $ SomeMessageJust y      $ MsgInvalidEntry x
716d743
< 
718d744
< fileField :: (Monad m, RenderMessage (HandlerSite m) FormMessage)
719d744
<           => Field m FileInfo
720d744
< fileField = Field
721d744
<     { fieldParse = \_ files -> return $
722d744
<         case files of
723d744
<             [] -> Right Nothing
724d744
<             file:_ -> Right $ Just file
725c745
<     , fieldView = \id' name attrs _ isReq -> toWidget [hamlet|
---
> fileField-- | Creates an input with @type="file"@.:: (Monad m, RenderMessage (HandlerSite m) FormMessage)
725a746
> fileField :: (FieldMonadmm,FileInfo (HandlerSite m) FormMessage)
725a747
> fileField =>= Field m FileInfo
725a748
> fileField{ fieldParse= Field= \_ files -> return $
725a749
>     { fieldParsecase files= \of_ files -> return $
725a750
>          case[files] -> Rightof   Nothing
725a751
>              [file] ->:_Right-> Right$ Just file
725a752
>      , fieldView:_\->id'Rightname $attrs_fileisReq -> toWidget [hamlet|
727c754
<         |]
---
>         |], fieldView = \id' name attrs _ isReq -> toWidget [hamlet|
727a755
>             <input id=#{id'} name=#{name} *{attrs} type=file :isReq:required>
727a756
>         |], fieldEnctype = Multipart
730d758
< 
732d759
<              => FieldSettings (HandlerSite m) -> AForm m FileInfo
733d759
< fileAFormReq fs = AForm $ \(site, langs) menvs ints -> do
734d759
<     let (name, ints') =
735d759
<             case fsName fs of
736d759
<                 Just x -> (x, ints)
737d759
<                 Nothing ->
738d759
<                     let i' = incrInts ints
739d759
<                      in (pack $ 'f' : show i', i')
740d759
<     id' <- maybe newIdent return $ fsId fs
741d759
<     let (res, errs) =
742d759
<             case menvs of
743d759
<                 Nothing -> (FormMissing, Nothing)
744d759
<                 Just (_, fenv) ->
745d759
<                     case Map.lookup name fenv of
746d759
<                         Just (fi:_) -> (FormSuccess fi, Nothing)
747d759
<                         _ ->
748d759
<                             let t = renderMessage site langs MsgValueRequired
749d759
<                              in (FormFailure [t], Just $ toHtml t)
750d759
<     let fv = FieldView
751d759
<             { fvLabel = toHtml $ renderMessage site langs $ fsLabel fs
752d759
<             , fvTooltip = fmap (toHtml . renderMessage site langs) $ fsTooltip fs
753d759
<             , fvId = id'
754c760
<             , fvInput = [whamlet|
---
> fileAFormReq :: (FieldSettingsMonadHandler m,HandlerSitem) ->HandlerSiteAForm m FileInfo) FormMessage)
754a761
> fileAFormReq => FieldSettings= AForm $ \(siteHandlerSite, langs) menvs) ->ints-> mdoFileInfo
754a762
> fileAFormReqlet (namefs, ints'= AForm) = $ \(site, langs) menvs ints -> do
754a763
>         let (namecase, ints'fsName) = fs of
754a764
>                 caseJustx ->(ofx, ints)
754a765
>                     JustNothing ->->(x, ints)
754a766
>                     Nothinglet ->   = incrInts ints
754a767
>                         letin i'(pack= incrInts$ 'f' : ints i', i')
754a768
>         id' <- maybe newIdentin (packreturn 'f'$ fsId showfs i', i')
754a769
>         id' <-(res, errs) =     return $ fsId fs
754a770
>         let (res,casemenvs) =  of
754a771
>                 caseNothing of-> (FormMissing, Nothing)
754a772
>                     NothingJust (_,->fenvFormMissing) ->      , Nothing)
754a773
>                     Justcase_, fenvMap.lookup) ->   name fenv of
754a774
>                         caseJust(fi:_) name-> (FormSuccess of    fi, Nothing)
754a775
>                             Just_ -> (fi:_) -> (FormSuccess fi, Nothing)
754a776
>                             _ ->let t = renderMessage site langs MsgValueRequired
754a777
>                                 letin tFormFailure= renderMessage[t], site langs$ toHtmlt)
754a778
>         let fv = FieldView       in (FormFailure [t], Just $ toMarkup t)
754a779
>         let fv ={FieldViewfvLabel = toHtml $ renderMessage site langs $ fsLabel fs
754a780
>                 { fvLabelfvTooltip= toMarkup= fmap (toHtml renderMessage. renderMessage langssite $langs) $ fsTooltip       fs
754a781
>                 , fvTooltipfvId = id'= fmap (toMarkup . renderMessage site langs) $ fsTooltip fs
754a782
>                 , fvIdfvInput= id'= [whamlet|
757d784
< |]
758d784
<             , fvErrors = errs
759d784
<             , fvRequired = True
760d784
<             }
761d784
<     return (res, (fv :), ints', Multipart)
762c785
< 
---
> |]          , fvInput = [whamlet|
762a786
> $newline never
762a787
> <input type=file name=#{name} ##{id'} *{fsAttrs fs}>
762a788
> |]          , fvErrors = errs
762a789
>                 , fvErrorsfvRequired= errs= True
762a790
>                 , fvRequired = True
762a791
>         return (}res, (fv :), ints', Multipart)
762a792
>         return (res, (fv :), ints', Multipart)
763a794
> fileAFormOpt :: MonadHandlerRenderMessagem(HandlerSite m) FormMessage
765d795
<              => FieldSettings (HandlerSite m)
766d795
<              -> AForm m (Maybe FileInfo)
767d795
< fileAFormOpt fs = AForm $ \(master, langs) menvs ints -> do
768d795
<     let (name, ints') =
769d795
<             case fsName fs of
770d795
<                 Just x -> (x, ints)
771d795
<                 Nothing ->
772d795
<                     let i' = incrInts ints
773d795
<                      in (pack $ 'f' : show i', i')
774d795
<     id' <- maybe newIdent return $ fsId fs
775d795
<     let (res, errs) =
776d795
<             case menvs of
777d795
<                 Nothing -> (FormMissing, Nothing)
778d795
<                 Just (_, fenv) ->
779d795
<                     case Map.lookup name fenv of
780d795
<                         Just (fi:_) -> (FormSuccess $ Just fi, Nothing)
781d795
<                         _ -> (FormSuccess Nothing, Nothing)
782d795
<     let fv = FieldView
783d795
<             { fvLabel = toHtml $ renderMessage master langs $ fsLabel fs
784d795
<             , fvTooltip = fmap (toHtml . renderMessage master langs) $ fsTooltip fs
785d795
<             , fvId = id'
786c796
<             , fvInput = [whamlet|
---
>              => FieldSettingsAForm m (Maybe(HandlerSiteFileInfo)   m)
786a797
> fileAFormOpt -> AForm= AForm (Maybe\(master, langs) ) menvs ints -> do
786a798
> fileAFormOptlet (namefs, ints'= AForm) = $ \(master, langs) menvs ints -> do
786a799
>         let (namecase, ints'fsName) = fs of
786a800
>                 caseJustx ->(ofx, ints)
786a801
>                     JustNothing ->->(x, ints)
786a802
>                     Nothinglet ->   = incrInts ints
786a803
>                         letin i'(pack= incrInts$ 'f' : ints i', i')
786a804
>         id' <- maybe newIdentin (packreturn 'f'$ fsId showfs i', i')
786a805
>         id' <-(res, errs) =     return $ fsId fs
786a806
>         let (res,casemenvs) =  of
786a807
>                 caseNothing of-> (FormMissing, Nothing)
786a808
>                     NothingJust (_,->fenvFormMissing) ->      , Nothing)
786a809
>                     Justcase_, fenvMap.lookup) ->   name fenv of
786a810
>                         caseJust(fi:_) name-> (FormSuccess of    $ Just fi, Nothing)
786a811
>                             Just_ -> (fiFormSuccess:_) -> (FormSuccessNothing, Nothing Just)fi, Nothing)
786a812
>         let fv = FieldView  _ -> (FormSuccess Nothing, Nothing)
786a813
>         let fv ={FieldViewfvLabel = toHtml $ renderMessage master langs $ fsLabel fs
786a814
>                 { fvLabelfvTooltip= toMarkup= fmap (toHtml renderMessage. renderMessagemaster $langs) $ fsTooltip       fs
786a815
>                 , fvTooltipfvId = id'= fmap (toMarkup . renderMessage master langs) $ fsTooltip fs
786a816
>                 , fvIdfvInput= id'= [whamlet|
789d818
< |]
790d818
<             , fvErrors = errs
791d818
<             , fvRequired = False
792d818
<             }
793d818
<     return (res, (fv :), ints', Multipart)
794d818
< 
795d818
< incrInts :: Ints -> Ints
796d818
< incrInts (IntSingle i) = IntSingle $ i + 1
797d818
< incrInts (IntCons i is) = (i + 1) `IntCons` is
798d818
< 
799d818
< 
800d818
< -- | Adds a '0' to some text so that it may be recognized as a double.
801d818
< --   The read ftn does not recognize ".3" as 0.3 nor "-.3" as -0.3, so this
802d818
< --   function changes ".xxx" to "0.xxx" and "-.xxx" to "-0.xxx"
803d818
< 
804d818
< prependZero :: Text -> Text
805d818
< prependZero t0 = if T.null t1
806d818
<                  then t1
807d818
<                  else if T.head t1 == '.'
808d818
<                       then '0' `T.cons` t1
809d818
<                       else if "-." `T.isPrefixOf` t1
810d818
<                            then "-0." `T.append` (T.drop 2 t1)
811d818
<                            else t1
812d818
< 
813c819
<   where t1 = T.dropWhile ((==) ' ') t0
---
> |]          , fvInput = [whamlet|
813a820
> $newline never
815d821
< -- $optionsOverview
816d821
< -- These functions create inputs where one or more options can be selected from a list.
817d821
< --
818d821
< -- The basic datastructure used is an 'Option', which combines a user-facing display value, the internal Haskell value being selected, and an external 'Text' stored as the @value@ in the form (used to map back to the internal value). A list of these, together with a function mapping from an external value back to a Haskell value, form an 'OptionList', which several of these functions take as an argument.
819d821
< --
820d821
< -- Typically, you won't need to create an 'OptionList' directly and can instead make one with functions like 'optionsPairs' or 'optionsEnum'. Alternatively, you can use functions like 'selectFieldList', which use their @[(msg, a)]@ parameter to create an 'OptionList' themselves.
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE CPP #-}
-- | Field functions allow you to easily create and validate forms, cleanly handling the uncertainty of parsing user input.
--
-- When possible, the field functions use a specific input type (e.g. "number"), allowing supporting browsers to validate the input before form submission. Browsers can also improve usability with this information; for example, mobile browsers might present a specialized keyboard for an input of type "email" or "number".
--
-- See the Yesod book <http://www.yesodweb.com/book/forms chapter on forms> for a broader overview of forms in Yesod.
module Yesod.Form.Fields
    ( -- * i18n
      FormMessage (..)
    , defaultFormMessage
      -- * Fields
    , textField
    , passwordField
    , textareaField
    , hiddenField
    , intField
    , dayField
    , timeField
    , timeFieldTypeTime
    , timeFieldTypeText
    , htmlField
    , emailField
    , multiEmailField
    , searchField
    , AutoFocus
    , urlField
    , doubleField
    , parseDate
    , parseTime
    , Textarea (..)
    , boolField
    , checkBoxField
    , fileField
      -- * File 'AForm's
    , fileAFormReq
    , fileAFormOpt
      -- * Options
      -- $optionsOverview
    , selectField
    , selectFieldList
    , radioField
    , radioFieldList
    , checkboxesField
    , checkboxesFieldList
    , multiSelectField
    , multiSelectFieldList
    , Option (..)
    , OptionList (..)
    , mkOptionList
    , optionsPersist
    , optionsPersistKey
    , optionsPairs
    , optionsEnum
    ) where

import Yesod.Form.Types
import Yesod.Form.I18n.English
import Yesod.Form.Functions (parseHelper)
import Yesod.Core
import Text.Hamlet
import Text.Blaze (ToMarkup (toMarkup), unsafeByteString)
#define ToHtml ToMarkup
#define toHtml toMarkup
#define preEscapedText preEscapedToMarkup
import Text.Cassius
import Data.Time (Day, TimeOfDay(..))
import qualified Text.Email.Validate as Email
import Data.Text.Encoding (encodeUtf8, decodeUtf8With)
import Data.Text.Encoding.Error (lenientDecode)
import Network.URI (parseURI)
import Database.Persist.Sql (PersistField, PersistFieldSql (..))
import Database.Persist (Entity (..), SqlType (SqlString))
import Text.HTML.SanitizeXSS (sanitizeBalance)
import Control.Monad (when, unless)
import Data.Either (partitionEithers)
import Data.Maybe (listToMaybe, fromMaybe)

import qualified Blaze.ByteString.Builder.Html.Utf8 as B
import Blaze.ByteString.Builder (writeByteString, toLazyByteString)
import Blaze.ByteString.Builder.Internal.Write (fromWriteList)
import Database.Persist (PersistEntityBackend)

import Text.Blaze.Html.Renderer.String (renderHtml)
import qualified Data.ByteString as S
import qualified Data.ByteString.Lazy as L
import Data.Text as T ( Text, append, concat, cons, head
                      , intercalate, isPrefixOf, null, unpack, pack, splitOn
                      )
import qualified Data.Text as T (drop, dropWhile)
import qualified Data.Text.Read

import qualified Data.Map as Map
import Yesod.Persist (selectList, runDB, Filter, SelectOpt, Key, YesodPersist, PersistEntity, PersistQuery)
import Control.Arrow ((&&&))

import Control.Applicative ((<$>), (<|>))

import Data.Attoparsec.Text (Parser, char, string, digit, skipSpace, endOfInput, parseOnly)

import Yesod.Persist.Core

defaultFormMessage :: FormMessage -> Text
defaultFormMessage = englishFormMessage

-- | Creates a input with @type="number"@ and @step=1@.
intField :: (Monad m, Integral i, RenderMessage (HandlerSite m) FormMessage) => Field m i
intField = Field
    { fieldParse = parseHelper $ \s ->
        case Data.Text.Read.signed Data.Text.Read.decimal s of
            Right (a, "") -> Right a
            _ -> Left $ MsgInvalidInteger s

    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="number" step=1 :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where
    showVal = either id (pack . showI)
    showI x = show (fromIntegral x :: Integer)

-- | Creates a input with @type="number"@ and @step=any@.
doubleField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Double
doubleField = Field
    { fieldParse = parseHelper $ \s ->
        case Data.Text.Read.double (prependZero s) of
            Right (a, "") -> Right a
            _ -> Left $ MsgInvalidNumber s

    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="number" step=any :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . show)

-- | Creates an input with @type="date"@, validating the input using the 'parseDate' function.
--
-- Add the @time@ package and import the "Data.Time.Calendar" module to use this function.
dayField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Day
dayField = Field
    { fieldParse = parseHelper $ parseDate . unpack
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="date" :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . show)

-- | An alias for 'timeFieldTypeText'.
timeField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeField = timeFieldTypeText
{-# DEPRECATED timeField "'timeField' currently defaults to an input of type=\"text\". In the next major release, it will default to type=\"time\". To opt in to the new functionality, use 'timeFieldTypeTime'. To keep the existing behavior, use 'timeFieldTypeText'. See 'https://github.com/yesodweb/yesod/pull/874' for details." #-}

-- | Creates an input with @type="time"@. <http://caniuse.com/#search=time%20input%20type Browsers not supporting this type> will fallback to a text field, and Yesod will parse the time as described in 'timeFieldTypeText'.
--
-- Add the @time@ package and import the "Data.Time.LocalTime" module to use this function.
--
-- Since 1.4.2
timeFieldTypeTime :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeFieldTypeTime = timeFieldOfType "time"

-- | Creates an input with @type="text"@, parsing the time from an [H]H:MM[:SS] format, with an optional AM or PM (if not given, AM is assumed for compatibility with the 24 hour clock system).
--
-- Add the @time@ package and import the "Data.Time.LocalTime" module to use this function.
--
-- Since 1.4.2
timeFieldTypeText :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeFieldTypeText = timeFieldOfType "text"

timeFieldOfType :: Monad m => RenderMessage (HandlerSite m) FormMessage => Text -> Field m TimeOfDay
timeFieldOfType inputType = Field
    { fieldParse = parseHelper parseTime
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="#{inputType}" :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where
    showVal = either id (pack . show . roundFullSeconds)
    roundFullSeconds tod =
        TimeOfDay (todHour tod) (todMin tod) fullSec
      where
        fullSec = fromInteger $ floor $ todSec tod

-- | Creates a @\<textarea>@ tag whose input is sanitized to prevent XSS attacks and is validated for having balanced tags.
htmlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Html
htmlField = Field
    { fieldParse = parseHelper $ Right . preEscapedText . sanitizeBalance
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<textarea :isReq:required="" id="#{theId}" name="#{name}" *{attrs}>#{showVal val}
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . renderHtml)

-- | A newtype wrapper around a 'Text' whose 'ToMarkup' instance converts newlines to HTML @\<br>@ tags.
--
-- (When text is entered into a @\<textarea>@, newline characters are used to separate lines.
-- If this text is then placed verbatim into HTML, the lines won't be separated, thus the need for replacing with @\<br>@ tags).
-- If you don't need this functionality, simply use 'unTextarea' to access the raw text.
newtype Textarea = Textarea { unTextarea :: Text }
    deriving (Show, Read, Eq, PersistField, Ord, ToJSON, FromJSON)
instance PersistFieldSql Textarea where
    sqlType _ = SqlString
instance ToHtml Textarea where
    toHtml =
        unsafeByteString
        . S.concat
        . L.toChunks
        . toLazyByteString
        . fromWriteList writeHtmlEscapedChar
        . unpack
        . unTextarea
      where
        -- Taken from blaze-builder and modified with newline handling.
        writeHtmlEscapedChar '\n' = writeByteString "<br>"
        writeHtmlEscapedChar c    = B.writeHtmlEscapedChar c

-- | Creates a @\<textarea>@ tag whose returned value is wrapped in a 'Textarea'; see 'Textarea' for details.
textareaField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Textarea
textareaField = Field
    { fieldParse = parseHelper $ Right . Textarea
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<textarea id="#{theId}" name="#{name}" :isReq:required="" *{attrs}>#{either id unTextarea val}
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates an input with @type="hidden"@; you can use this to store information in a form that users shouldn't see (for example, Yesod stores CSRF tokens in a hidden field).
hiddenField :: (Monad m, PathPiece p, RenderMessage (HandlerSite m) FormMessage)
            => Field m p
hiddenField = Field
    { fieldParse = parseHelper $ maybe (Left MsgValueRequired) Right . fromPathPiece
    , fieldView = \theId name attrs val _isReq -> toWidget [hamlet|
$newline never
<input type="hidden" id="#{theId}" name="#{name}" *{attrs} value="#{either id toPathPiece val}">
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates a input with @type="text"@.
textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
textField = Field
    { fieldParse = parseHelper $ Right
    , fieldView = \theId name attrs val isReq ->
        [whamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="text" :isReq:required value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }
-- | Creates an input with @type="password"@.
passwordField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
passwordField = Field
    { fieldParse = parseHelper $ Right
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="password" :isReq:required="" value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }

readMay :: Read a => String -> Maybe a
readMay s = case filter (Prelude.null . snd) $ reads s of
                (x, _):_ -> Just x
                [] -> Nothing

-- | Parses a 'Day' from a 'String'.
parseDate :: String -> Either FormMessage Day
parseDate = maybe (Left MsgInvalidDay) Right
              . readMay . replace '/' '-'

-- | Replaces all instances of a value in a list by another value.
-- from http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/src/Network-CGI-Protocol.html#replace
replace :: Eq a => a -> a -> [a] -> [a]
replace x y = map (\z -> if z == x then y else z)

parseTime :: Text -> Either FormMessage TimeOfDay
parseTime = either (Left . fromMaybe MsgInvalidTimeFormat . readMay . drop 2 . dropWhile (/= ':')) Right . parseOnly timeParser

timeParser :: Parser TimeOfDay
timeParser = do
    skipSpace
    h <- hour
    _ <- char ':'
    m <- minsec MsgInvalidMinute
    hasSec <- (char ':' >> return True) <|> return False
    s <- if hasSec then minsec MsgInvalidSecond else return 0
    skipSpace
    isPM <-
        (string "am" >> return (Just False)) <|>
        (string "AM" >> return (Just False)) <|>
        (string "pm" >> return (Just True)) <|>
        (string "PM" >> return (Just True)) <|>
        return Nothing
    h' <-
        case isPM of
            Nothing -> return h
            Just x
                | h <= 0 || h > 12 -> fail $ show $ MsgInvalidHour $ pack $ show h
                | h == 12 -> return $ if x then 12 else 0
                | otherwise -> return $ h + (if x then 12 else 0)
    skipSpace
    endOfInput
    return $ TimeOfDay h' m s
  where
    hour = do
        x <- digit
        y <- (return <$> digit) <|> return []
        let xy = x : y
        let i = read xy
        if i < 0 || i >= 24
            then fail $ show $ MsgInvalidHour $ pack xy
            else return i
    minsec :: Num a => (Text -> FormMessage) -> Parser a
    minsec msg = do
        x <- digit
        y <- digit <|> fail (show $ msg $ pack [x])
        let xy = [x, y]
        let i = read xy
        if i < 0 || i >= 60
            then fail $ show $ msg $ pack xy
            else return $ fromIntegral (i :: Int)

-- | Creates an input with @type="email"@. Yesod will validate the email's correctness according to RFC5322 and canonicalize it by removing comments and whitespace (see "Text.Email.Validate").
emailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
emailField = Field
    { fieldParse = parseHelper $
        \s ->
            case Email.canonicalizeEmail $ encodeUtf8 s of
                Just e -> Right $ decodeUtf8With lenientDecode e
                Nothing -> Left $ MsgInvalidEmail s
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="email" :isReq:required="" value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates an input with @type="email"@ with the <http://www.w3.org/html/wg/drafts/html/master/forms.html#the-multiple-attribute multiple> attribute; browsers might implement this as taking a comma separated list of emails. Each email address is validated as described in 'emailField'.
--
-- Since 1.3.7
multiEmailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m [Text]
multiEmailField = Field
    { fieldParse = parseHelper $
        \s ->
            let addrs = map validate $ splitOn "," s
            in case partitionEithers addrs of
                ([], good) -> Right good
                (bad, _) -> Left $ MsgInvalidEmail $ cat bad
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="email" multiple :isReq:required="" value="#{either id cat val}">
|]
    , fieldEnctype = UrlEncoded
    }
    where
        -- report offending address along with error
        validate a = case Email.validate $ encodeUtf8 a of
                        Left e -> Left $ T.concat [a, " (",  pack e, ")"]
                        Right r -> Right $ emailToText r
        cat = intercalate ", "
        emailToText = decodeUtf8With lenientDecode . Email.toByteString

type AutoFocus = Bool
-- | Creates an input with @type="search"@. For <http://caniuse.com/#search=autofocus browsers without autofocus support>, a JS fallback is used if @AutoFocus@ is true.
searchField :: Monad m => RenderMessage (HandlerSite m) FormMessage => AutoFocus -> Field m Text
searchField autoFocus = Field
    { fieldParse = parseHelper Right
    , fieldView = \theId name attrs val isReq -> do
        [whamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="search" :isReq:required="" :autoFocus:autofocus="" value="#{either id id val}">
|]
        when autoFocus $ do
          -- we want this javascript to be placed immediately after the field
          [whamlet|
$newline never
<script>if (!('autofocus' in document.createElement('input'))) {document.getElementById('#{theId}').focus();}
|]
          toWidget [cassius|
            ##{theId}
              -webkit-appearance: textfield
            |]
    , fieldEnctype = UrlEncoded
    }
-- | Creates an input with @type="url"@, validating the URL according to RFC3986.
urlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
urlField = Field
    { fieldParse = parseHelper $ \s ->
        case parseURI $ unpack s of
            Nothing -> Left $ MsgInvalidUrl s
            Just _ -> Right s
    , fieldView = \theId name attrs val isReq ->
        [whamlet|<input ##{theId} name=#{name} *{attrs} type=url :isReq:required value=#{either id id val}>|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates a @\<select>@ tag for selecting one option. Example usage:
--
-- > areq (selectFieldList [("Value 1" :: Text, "value1"),("Value 2", "value2")]) "Which value?" Nothing
selectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
                => [(msg, a)]
                -> Field (HandlerT site IO) a
selectFieldList = selectField . optionsPairs

-- | Creates a @\<select>@ tag for selecting one option. Example usage:
--
-- > areq (selectField $ optionsPairs [(MsgValue1, "value1"),(MsgValue2, "value2")]) "Which value?" Nothing
selectField :: (Eq a, RenderMessage site FormMessage)
            => HandlerT site IO (OptionList a)
            -> Field (HandlerT site IO) a
selectField = selectFieldHelper
    (\theId name attrs inside -> [whamlet|
$newline never
<select ##{theId} name=#{name} *{attrs}>^{inside}
|]) -- outside
    (\_theId _name isSel -> [whamlet|
$newline never
<option value=none :isSel:selected>_{MsgSelectNone}
|]) -- onOpt
    (\_theId _name _attrs value isSel text -> [whamlet|
$newline never
<option value=#{value} :isSel:selected>#{text}
|]) -- inside

-- | Creates a @\<select>@ tag for selecting multiple options.
multiSelectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
                     => [(msg, a)]
                     -> Field (HandlerT site IO) [a]
multiSelectFieldList = multiSelectField . optionsPairs

-- | Creates a @\<select>@ tag for selecting multiple options.
multiSelectField :: (Eq a, RenderMessage site FormMessage)
                 => HandlerT site IO (OptionList a)
                 -> Field (HandlerT site IO) [a]
multiSelectField ioptlist =
    Field parse view UrlEncoded
  where
    parse [] _ = return $ Right Nothing
    parse optlist _ = do
        mapopt <- olReadExternal <$> ioptlist
        case mapM mapopt optlist of
             Nothing -> return $ Left "Error parsing values"
             Just res -> return $ Right $ Just res

    view theId name attrs val isReq = do
        opts <- fmap olOptions $ handlerToWidget ioptlist
        let selOpts = map (id &&& (optselected val)) opts
        [whamlet|
            <select ##{theId} name=#{name} :isReq:required multiple *{attrs}>
                $forall (opt, optsel) <- selOpts
                    <option value=#{optionExternalValue opt} :optsel:selected>#{optionDisplay opt}
                |]
        where
            optselected (Left _) _ = False
            optselected (Right vals) opt = (optionInternalValue opt) `elem` vals

-- | Creates an input with @type="radio"@ for selecting one option.
radioFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
               => [(msg, a)]
               -> Field (HandlerT site IO) a
radioFieldList = radioField . optionsPairs

-- | Creates an input with @type="checkbox"@ for selecting multiple options.
checkboxesFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)]
                     -> Field (HandlerT site IO) [a]
checkboxesFieldList = checkboxesField . optionsPairs

-- | Creates an input with @type="checkbox"@ for selecting multiple options.
checkboxesField :: (Eq a, RenderMessage site FormMessage)
                 => HandlerT site IO (OptionList a)
                 -> Field (HandlerT site IO) [a]
checkboxesField ioptlist = (multiSelectField ioptlist)
    { fieldView =
        \theId name attrs val isReq -> do
            opts <- fmap olOptions $ handlerToWidget ioptlist
            let optselected (Left _) _ = False
                optselected (Right vals) opt = (optionInternalValue opt) `elem` vals
            [whamlet|
                <span ##{theId}>
                    $forall opt <- opts
                        <label>
                            <input type=checkbox name=#{name} value=#{optionExternalValue opt} *{attrs} :optselected val opt:checked>
                            #{optionDisplay opt}
                |]
    }
-- | Creates an input with @type="radio"@ for selecting one option.
radioField :: (Eq a, RenderMessage site FormMessage)
           => HandlerT site IO (OptionList a)
           -> Field (HandlerT site IO) a
radioField = selectFieldHelper
    (\theId _name _attrs inside -> [whamlet|
$newline never
<div ##{theId}>^{inside}
|])
    (\theId name isSel -> [whamlet|
$newline never
<label .radio for=#{theId}-none>
    <div>
        <input id=#{theId}-none type=radio name=#{name} value=none :isSel:checked>
        _{MsgSelectNone}
|])
    (\theId name attrs value isSel text -> [whamlet|
$newline never
<label .radio for=#{theId}-#{value}>
    <div>
        <input id=#{theId}-#{value} type=radio name=#{name} value=#{value} :isSel:checked *{attrs}>
        \#{text}
|])

-- | Creates a group of radio buttons to answer the question given in the message. Radio buttons are used to allow differentiating between an empty response (@Nothing@) and a no response (@Just False@). Consider using the simpler 'checkBoxField' if you don't need to make this distinction.
--
-- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
--
-- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
--
-- (Exact label titles will depend on localization).
boolField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
boolField = Field
      { fieldParse = \e _ -> return $ boolParser e
      , fieldView = \theId name attrs val isReq -> [whamlet|
$newline never
  $if not isReq
      <input id=#{theId}-none *{attrs} type=radio name=#{name} value=none checked>
      <label for=#{theId}-none>_{MsgSelectNone}


<input id=#{theId}-yes *{attrs} type=radio name=#{name} value=yes :showVal id val:checked>
<label for=#{theId}-yes>_{MsgBoolYes}

<input id=#{theId}-no *{attrs} type=radio name=#{name} value=no :showVal not val:checked>
<label for=#{theId}-no>_{MsgBoolNo}
|]
    , fieldEnctype = UrlEncoded
    }
  where
    boolParser [] = Right Nothing
    boolParser (x:_) = case x of
      "" -> Right Nothing
      "none" -> Right Nothing
      "yes" -> Right $ Just True
      "on" -> Right $ Just True
      "no" -> Right $ Just False
      "true" -> Right $ Just True
      "false" -> Right $ Just False
      t -> Left $ SomeMessage $ MsgInvalidBool t
    showVal = either (\_ -> False)

-- | Creates an input with @type="checkbox"@.
--   While the default @'boolField'@ implements a radio button so you
--   can differentiate between an empty response (@Nothing@) and a no
--   response (@Just False@), this simpler checkbox field returns an empty
--   response as @Just False@.
--
--   Note that this makes the field always optional.
--
checkBoxField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
checkBoxField = Field
    { fieldParse = \e _ -> return $ checkBoxParser e
    , fieldView  = \theId name attrs val _ -> [whamlet|
$newline never
<input id=#{theId} *{attrs} type=checkbox name=#{name} value=yes :showVal id val:checked>
|]
    , fieldEnctype = UrlEncoded
    }

    where
        checkBoxParser [] = Right $ Just False
        checkBoxParser (x:_) = case x of
            "yes" -> Right $ Just True
            "on" -> Right $ Just True
            _     -> Right $ Just False

        showVal = either (\_ -> False)

-- | A structure holding a list of options. Typically you can use a convenience function like 'mkOptionList' or 'optionsPairs' instead of creating this directly.
data OptionList a = OptionList
    { olOptions :: [Option a]
    , olReadExternal :: Text -> Maybe a -- ^ A function mapping from the form's value ('optionExternalValue') to the selected Haskell value ('optionInternalValue').
    }
-- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.
mkOptionList :: [Option a] -> OptionList a
mkOptionList os = OptionList
    { olOptions = os
    , olReadExternal = flip Map.lookup $ Map.fromList $ map (optionExternalValue &&& optionInternalValue) os
    }

data Option a = Option
    { optionDisplay :: Text -- ^ The user-facing label.
    , optionInternalValue :: a -- ^ The Haskell value being selected.
    , optionExternalValue :: Text -- ^ The representation of this value stored in the form.
    }
-- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.
optionsPairs :: (MonadHandler m, RenderMessage (HandlerSite m) msg)
             => [(msg, a)] -> m (OptionList a)
optionsPairs opts = do
  mr <- getMessageRender
  let mkOption external (display, internal) =
          Option { optionDisplay       = mr display
                 , optionInternalValue = internal
                 , optionExternalValue = pack $ show external
                 }
  return $ mkOptionList (zipWith mkOption [1 :: Int ..] opts)

-- | Creates an 'OptionList' from an 'Enum', using its 'Show' instance for the user-facing value.
optionsEnum :: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
optionsEnum = optionsPairs $ map (\x -> (pack $ show x, x)) [minBound..maxBound]

-- | Selects a list of 'Entity's with the given 'Filter' and 'SelectOpt's. The @(a -> msg)@ function is then used to derive the display value for an 'OptionList'. Example usage:
--
-- > Country
-- >    name Text
-- >    deriving Eq -- Must derive Eq
--
-- > data CountryForm = CountryForm
-- >   { country :: Entity Country
-- >   }
-- >
-- > countryNameForm :: AForm Handler CountryForm
-- > countryNameForm = CountryForm
-- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
-- >         where
-- >           countries = optionsPersist [] [Asc CountryName] countryName
optionsPersist :: ( YesodPersist site, PersistEntity a
                  , PersistQuery (PersistEntityBackend a)
                  , PathPiece (Key a)
                  , RenderMessage site msg
                  , YesodPersistBackend site ~ PersistEntityBackend a
                  )
               => [Filter a]
               -> [SelectOpt a]
               -> (a -> msg)
               -> HandlerT site IO (OptionList (Entity a))
optionsPersist filts ords toDisplay = fmap mkOptionList $ do
    mr <- getMessageRender
    pairs <- runDB $ selectList filts ords
    return $ map (\(Entity key value) -> Option
        { optionDisplay = mr (toDisplay value)
        , optionInternalValue = Entity key value
        , optionExternalValue = toPathPiece key
        }) pairs

-- | An alternative to 'optionsPersist' which returns just the 'Key' instead of
-- the entire 'Entity'.
--
-- Since 1.3.2
optionsPersistKey
  :: (YesodPersist site
     , PersistEntity a
     , PersistQuery (PersistEntityBackend a)
     , PathPiece (Key a)
     , RenderMessage site msg
     , YesodPersistBackend site ~ PersistEntityBackend a
     )
  => [Filter a]
  -> [SelectOpt a]
  -> (a -> msg)
  -> HandlerT site IO (OptionList (Key a))

optionsPersistKey filts ords toDisplay = fmap mkOptionList $ do
    mr <- getMessageRender
    pairs <- runDB $ selectList filts ords
    return $ map (\(Entity key value) -> Option
        { optionDisplay = mr (toDisplay value)
        , optionInternalValue = key
        , optionExternalValue = toPathPiece key
        }) pairs

selectFieldHelper
        :: (Eq a, RenderMessage site FormMessage)
        => (Text -> Text -> [(Text, Text)] -> WidgetT site IO () -> WidgetT site IO ())
        -> (Text -> Text -> Bool -> WidgetT site IO ())
        -> (Text -> Text -> [(Text, Text)] -> Text -> Bool -> Text -> WidgetT site IO ())
        -> HandlerT site IO (OptionList a)
        -> Field (HandlerT site IO) a
selectFieldHelper outside onOpt inside opts' = Field
    { fieldParse = \x _ -> do
        opts <- opts'
        return $ selectParser opts x
    , fieldView = \theId name attrs val isReq -> do
        opts <- fmap olOptions $ handlerToWidget opts'
        outside theId name attrs $ do
            unless isReq $ onOpt theId name $ not $ render opts val `elem` map optionExternalValue opts
            flip mapM_ opts $ \opt -> inside
                theId
                name
                ((if isReq then (("required", "required"):) else id) attrs)
                (optionExternalValue opt)
                ((render opts val) == optionExternalValue opt)
                (optionDisplay opt)
    , fieldEnctype = UrlEncoded
    }
  where
    render _ (Left _) = ""
    render opts (Right a) = maybe "" optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
    selectParser _ [] = Right Nothing
    selectParser opts (s:_) = case s of
            "" -> Right Nothing
            "none" -> Right Nothing
            x -> case olReadExternal opts x of
                    Nothing -> Left $ SomeMessage $ MsgInvalidEntry x
                    Just y -> Right $ Just y

-- | Creates an input with @type="file"@.
fileField :: (Monad m, RenderMessage (HandlerSite m) FormMessage)
          => Field m FileInfo
fileField = Field
    { fieldParse = \_ files -> return $
        case files of
            [] -> Right Nothing
            file:_ -> Right $ Just file
    , fieldView = \id' name attrs _ isReq -> toWidget [hamlet|
            <input id=#{id'} name=#{name} *{attrs} type=file :isReq:required>
        |]
    , fieldEnctype = Multipart
    }

fileAFormReq :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage)
             => FieldSettings (HandlerSite m) -> AForm m FileInfo
fileAFormReq fs = AForm $ \(site, langs) menvs ints -> do
    let (name, ints') =
            case fsName fs of
                Just x -> (x, ints)
                Nothing ->
                    let i' = incrInts ints
                     in (pack $ 'f' : show i', i')
    id' <- maybe newIdent return $ fsId fs
    let (res, errs) =
            case menvs of
                Nothing -> (FormMissing, Nothing)
                Just (_, fenv) ->
                    case Map.lookup name fenv of
                        Just (fi:_) -> (FormSuccess fi, Nothing)
                        _ ->
                            let t = renderMessage site langs MsgValueRequired
                             in (FormFailure [t], Just $ toHtml t)
    let fv = FieldView
            { fvLabel = toHtml $ renderMessage site langs $ fsLabel fs
            , fvTooltip = fmap (toHtml . renderMessage site langs) $ fsTooltip fs
            , fvId = id'
            , fvInput = [whamlet|
$newline never
<input type=file name=#{name} ##{id'} *{fsAttrs fs}>
|]
            , fvErrors = errs
            , fvRequired = True
            }
    return (res, (fv :), ints', Multipart)

fileAFormOpt :: MonadHandler m
             => RenderMessage (HandlerSite m) FormMessage
             => FieldSettings (HandlerSite m)
             -> AForm m (Maybe FileInfo)
fileAFormOpt fs = AForm $ \(master, langs) menvs ints -> do
    let (name, ints') =
            case fsName fs of
                Just x -> (x, ints)
                Nothing ->
                    let i' = incrInts ints
                     in (pack $ 'f' : show i', i')
    id' <- maybe newIdent return $ fsId fs
    let (res, errs) =
            case menvs of
                Nothing -> (FormMissing, Nothing)
                Just (_, fenv) ->
                    case Map.lookup name fenv of
                        Just (fi:_) -> (FormSuccess $ Just fi, Nothing)
                        _ -> (FormSuccess Nothing, Nothing)
    let fv = FieldView
            { fvLabel = toHtml $ renderMessage master langs $ fsLabel fs
            , fvTooltip = fmap (toHtml . renderMessage master langs) $ fsTooltip fs
            , fvId = id'
            , fvInput = [whamlet|
$newline never
<input type=file name=#{name} ##{id'} *{fsAttrs fs}>
|]
            , fvErrors = errs
            , fvRequired = False
            }
    return (res, (fv :), ints', Multipart)

incrInts :: Ints -> Ints
incrInts (IntSingle i) = IntSingle $ i + 1
incrInts (IntCons i is) = (i + 1) `IntCons` is


-- | Adds a '0' to some text so that it may be recognized as a double.
--   The read ftn does not recognize ".3" as 0.3 nor "-.3" as -0.3, so this
--   function changes ".xxx" to "0.xxx" and "-.xxx" to "-0.xxx"

prependZero :: Text -> Text
prependZero t0 = if T.null t1
                 then t1
                 else if T.head t1 == '.'
                      then '0' `T.cons` t1
                      else if "-." `T.isPrefixOf` t1
                           then "-0." `T.append` (T.drop 2 t1)
                           else t1

  where t1 = T.dropWhile ((==) ' ') t0

-- $optionsOverview
-- These functions create inputs where one or more options can be selected from a list.
--
-- The basic datastructure used is an 'Option', which combines a user-facing display value, the internal Haskell value being selected, and an external 'Text' stored as the @value@ in the form (used to map back to the internal value). A list of these, together with a function mapping from an external value back to a Haskell value, form an 'OptionList', which several of these functions take as an argument.
--
-- Typically, you won't need to create an 'OptionList' directly and can instead make one with functions like 'optionsPairs' or 'optionsEnum'. Alternatively, you can use functions like 'selectFieldList', which use their @[(msg, a)]@ parameter to create an 'OptionList' themselves.
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE CPP #-}
-- | Field functions allow you to easily create and validate forms, cleanly handling the uncertainty of parsing user input.
--
-- When possible, the field functions use a specific input type (e.g. "number"), allowing supporting browsers to validate the input before form submission. Browsers can also improve usability with this information; for example, mobile browsers might present a specialized keyboard for an input of type "email" or "number".
--
-- See the Yesod book <http://www.yesodweb.com/book/forms chapter on forms> for a broader overview of forms in Yesod.
module Yesod.Form.Fields
    ( -- * i18n
      FormMessage (..)
    , defaultFormMessage
      -- * Fields
    , textField
    , passwordField
    , textareaField
    , hiddenField
    , intField
    , dayField
    , timeField
    , timeFieldTypeTime
    , timeFieldTypeText
    , htmlField
    , emailField
    , multiEmailField
    , searchField
    , AutoFocus
    , urlField
    , doubleField
    , parseDate
    , parseTime
    , Textarea (..)
    , boolField
    , checkBoxField
    , fileField
      -- * File 'AForm's
    , fileAFormReq
    , fileAFormOpt
      -- * Options
      -- $optionsOverview
    , selectField
    , selectFieldList
    , radioField
    , radioFieldList
    , checkboxesField
    , checkboxesFieldList
    , multiSelectField
    , multiSelectFieldList
    , Option (..)
    , OptionList (..)
    , mkOptionList
    , optionsPersist
    , optionsPersistKey
    , optionsPairs
    , optionsEnum
    ) where

import Yesod.Form.Types
import Yesod.Form.I18n.English
import Yesod.Form.Functions (parseHelper)
import Yesod.Core
import Text.Hamlet
import Text.Blaze (ToMarkup (toMarkup), unsafeByteString)
#define ToHtml ToMarkup
#define toHtml toMarkup
#define preEscapedText preEscapedToMarkup
import Text.Cassius
import Data.Time (Day, TimeOfDay(..))
import qualified Text.Email.Validate as Email
import Data.Text.Encoding (encodeUtf8, decodeUtf8With)
import Data.Text.Encoding.Error (lenientDecode)
import Network.URI (parseURI)
import Database.Persist.Sql (PersistField, PersistFieldSql (..))
import Database.Persist (Entity (..), SqlType (SqlString))
import Text.HTML.SanitizeXSS (sanitizeBalance)
import Control.Monad (when, unless)
import Data.Either (partitionEithers)
import Data.Maybe (listToMaybe, fromMaybe)

import qualified Blaze.ByteString.Builder.Html.Utf8 as B
import Blaze.ByteString.Builder (writeByteString, toLazyByteString)
import Blaze.ByteString.Builder.Internal.Write (fromWriteList)
import Database.Persist (PersistEntityBackend)

import Text.Blaze.Html.Renderer.String (renderHtml)
import qualified Data.ByteString as S
import qualified Data.ByteString.Lazy as L
import Data.Text as T ( Text, append, concat, cons, head
                      , intercalate, isPrefixOf, null, unpack, pack, splitOn
                      )
import qualified Data.Text as T (drop, dropWhile)
import qualified Data.Text.Read

import qualified Data.Map as Map
import Yesod.Persist (selectList, runDB, Filter, SelectOpt, Key, YesodPersist, PersistEntity, PersistQuery)
import Control.Arrow ((&&&))

import Control.Applicative ((<$>), (<|>))

import Data.Attoparsec.Text (Parser, char, string, digit, skipSpace, endOfInput, parseOnly)

import Yesod.Persist.Core

defaultFormMessage :: FormMessage -> Text
defaultFormMessage = englishFormMessage

-- | Creates a input with @type="number"@ and @step=1@.
intField :: (Monad m, Integral i, RenderMessage (HandlerSite m) FormMessage) => Field m i
intField = Field
    { fieldParse = parseHelper $ \s ->
        case Data.Text.Read.signed Data.Text.Read.decimal s of
            Right (a, "") -> Right a
            _ -> Left $ MsgInvalidInteger s

    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="number" step=1 :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where
    showVal = either id (pack . showI)
    showI x = show (fromIntegral x :: Integer)

-- | Creates a input with @type="number"@ and @step=any@.
doubleField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Double
doubleField = Field
    { fieldParse = parseHelper $ \s ->
        case Data.Text.Read.double (prependZero s) of
            Right (a, "") -> Right a
            _ -> Left $ MsgInvalidNumber s

    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="number" step=any :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . show)

-- | Creates an input with @type="date"@, validating the input using the 'parseDate' function.
--
-- Add the @time@ package and import the "Data.Time.Calendar" module to use this function.
dayField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Day
dayField = Field
    { fieldParse = parseHelper $ parseDate . unpack
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="date" :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . show)

-- | An alias for 'timeFieldTypeText'.
timeField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeField = timeFieldTypeText
{-# DEPRECATED timeField "'timeField' currently defaults to an input of type="text". In the next major release, it will default to type="time". To opt in to the new functionality, use 'timeFieldTypeTime'. To keep the existing behavior, use 'timeFieldTypeText'. See 'https://github.com/yesodweb/yesod/pull/874' for details." #-}

-- | Creates an input with @type="time"@. <http://caniuse.com/#search=time%20input%20type Browsers not supporting this type> will fallback to a text field, and Yesod will parse the time as described in 'timeFieldTypeText'.
--
-- Add the @time@ package and import the "Data.Time.LocalTime" module to use this function.
--
-- Since 1.4.2
timeFieldTypeTime :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeFieldTypeTime = timeFieldOfType "time"

-- | Creates an input with @type="text"@, parsing the time from an [H]H:MM[:SS] format, with an optional AM or PM (if not given, AM is assumed for compatibility with the 24 hour clock system).
--
-- Add the @time@ package and import the "Data.Time.LocalTime" module to use this function.
--
-- Since 1.4.2
timeFieldTypeText :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m TimeOfDay
timeFieldTypeText = timeFieldOfType "text"

timeFieldOfType :: Monad m => RenderMessage (HandlerSite m) FormMessage => Text -> Field m TimeOfDay
timeFieldOfType inputType = Field
    { fieldParse = parseHelper parseTime
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="#{inputType}" :isReq:required="" value="#{showVal val}">
|]
    , fieldEnctype = UrlEncoded
    }
  where
    showVal = either id (pack . show . roundFullSeconds)
    roundFullSeconds tod =
        TimeOfDay (todHour tod) (todMin tod) fullSec
      where
        fullSec = fromInteger $ floor $ todSec tod

-- | Creates a @\<textarea>@ tag whose input is sanitized to prevent XSS attacks and is validated for having balanced tags.
htmlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Html
htmlField = Field
    { fieldParse = parseHelper $ Right . preEscapedToMarkuppreEscapedText . sanitizeBalance sanitizeBalance
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<textarea :isReq:required="" id="#{theId}" name="#{name}" *{attrs}>#{showVal val}
|]
    , fieldEnctype = UrlEncoded
    }
  where showVal = either id (pack . renderHtml)

-- | A newtype wrapper around a 'Text' whose 'ToMarkup' instance converts newlines to HTML @\<br>@ tags.
--
-- (When text is entered into a @\<textarea>@, newline characters are used to separate lines.
-- If this text is then placed verbatim into HTML, the lines won't be separated, thus the need for replacing with @\<br>@ tags).
-- If you don't need this functionality, simply use 'unTextarea' to access the raw text.
newtype Textarea = Textarea { unTextarea :: Text }
    deriving (Show, Read, Eq, PersistField, Ord, ToJSON, FromJSON)
instance PersistFieldSql Textarea where
    sqlType _ = SqlString
instance ToMarkupToHtml Textareawherewhere
    toMarkuptoHtml = =
        unsafeByteString
        . S.concat
        . L.toChunks
        . toLazyByteString
        . fromWriteList writeHtmlEscapedChar
        . unpack
        . unTextarea
      where
        -- Taken from blaze-builder and modified with newline handling.
        writeHtmlEscapedChar '\n' = writeByteString "<br>"
        writeHtmlEscapedChar c    = B.writeHtmlEscapedChar c

-- | Creates a @\<textarea>@ tag whose returned value is wrapped in a 'Textarea'; see 'Textarea' for details.
textareaField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Textarea
textareaField = Field
    { fieldParse = parseHelper $ Right . Textarea
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<textarea id="#{theId}" name="#{name}" :isReq:required="" *{attrs}>#{either id unTextarea val}
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates an input with @type="hidden"@; you can use this to store information in a form that users shouldn't see (for example, Yesod stores CSRF tokens in a hidden field).
hiddenField :: (Monad m, PathPiece p, RenderMessage (HandlerSite m) FormMessage)
            => Field m p
hiddenField = Field
    { fieldParse = parseHelper $ maybe (Left MsgValueRequired) Right . fromPathPiece
    , fieldView = \theId name attrs val _isReq -> toWidget [hamlet|
$newline never
<input type="hidden" id="#{theId}" name="#{name}" *{attrs} value="#{either id toPathPiece val}">
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates a input with @type="text"@.
textField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
textField = Field
    { fieldParse = parseHelper $ Right
    , fieldView = \theId name attrs val isReq ->
        [whamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="text" :isReq:required value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }
-- | Creates an input with @type="password"@.
passwordField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
passwordField = Field
    { fieldParse = parseHelper $ Right
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="password" :isReq:required="" value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }

readMay :: Read a => String -> Maybe a
readMay s = case filter (Prelude.null . snd) $ reads s of
                (x, _):_ -> Just x
                [] -> Nothing

-- | Parses a 'Day' from a 'String'.
parseDate :: String -> Either FormMessage Day
parseDate = maybe (Left MsgInvalidDay) Right
              . readMay . replace '/' '-'

-- | Replaces all instances of a value in a list by another value.
-- from http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/src/Network-CGI-Protocol.html#replace
replace :: Eq a => a -> a -> [a] -> [a]
replace x y = map (\z -> if z == x then y else z)

parseTime :: Text -> Either FormMessage TimeOfDay
parseTime = either (Left . fromMaybe MsgInvalidTimeFormat . readMay . drop 2 . dropWhile (/= ':')) Right . parseOnly timeParser

timeParser :: Parser TimeOfDay
timeParser = do
    skipSpace
    h <- hour
    _ <- char ':'
    m <- minsec MsgInvalidMinute
    hasSec <- (char ':' >> return True) <|> return False
    s <- if hasSec then minsec MsgInvalidSecond else return 0
    skipSpace
    isPM <-
        (string "am" >> return (Just False)) <|>
        (string "AM" >> return (Just False)) <|>
        (string "pm" >> return (Just True)) <|>
        (string "PM" >> return (Just True)) <|>
        return Nothing
    h' <-
        case isPM of
            Nothing -> return h
            Just x
                | h <= 0 || h > 12 -> fail $ show $ MsgInvalidHour $ pack $ show h
                | h == 12 -> return $ if x then 12 else 0
                | otherwise -> return $ h + (if x then 12 else 0)
    skipSpace
    endOfInput
    return $ TimeOfDay h' m s
  where
    hour = do
        x <- digit
        y <- (return <$> digit) <|> return []
        let xy = x : y
        let i = read xy
        if i < 0 || i >= 24
            then fail $ show $ MsgInvalidHour $ pack xy
            else return i
    minsec :: Num a => (Text -> FormMessage) -> Parser a
    minsec msg = do
        x <- digit
        y <- digit <|> fail (show $ msg $ pack [x])
        let xy = [x, y]
        let i = read xy
        if i < 0 || i >= 60
            then fail $ show $ msg $ pack xy
            else return $ fromIntegral (i :: Int)

-- | Creates an input with @type="email"@. Yesod will validate the email's correctness according to RFC5322 and canonicalize it by removing comments and whitespace (see "Text.Email.Validate").
emailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
emailField = Field
    { fieldParse = parseHelper $
        \s ->
            case Email.canonicalizeEmail $ encodeUtf8 s of
                Just e -> Right $ decodeUtf8With lenientDecode e
                Nothing -> Left $ MsgInvalidEmail s
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="email" :isReq:required="" value="#{either id id val}">
|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates an input with @type="email"@ with the <http://www.w3.org/html/wg/drafts/html/master/forms.html#the-multiple-attribute multiple> attribute; browsers might implement this as taking a comma separated list of emails. Each email address is validated as described in 'emailField'.
--
-- Since 1.3.7
multiEmailField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m [Text]
multiEmailField = Field
    { fieldParse = parseHelper $
        \s ->
            let addrs = map validate $ splitOn "," s
            in case partitionEithers addrs of
                ([], good) -> Right good
                (bad, _) -> Left $ MsgInvalidEmail $ cat bad
    , fieldView = \theId name attrs val isReq -> toWidget [hamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="email" multiple :isReq:required="" value="#{either id cat val}">
|]
    , fieldEnctype = UrlEncoded
    }
    where
        -- report offending address along with error
        validate a = case Email.validate $ encodeUtf8 a of
                        Left e -> Left $ T.concat [a, " (",  pack e, ")"]
                        Right r -> Right $ emailToText r
        cat = intercalate ", "
        emailToText = decodeUtf8With lenientDecode . Email.toByteString

type AutoFocus = Bool
-- | Creates an input with @type="search"@. For <http://caniuse.com/#search=autofocus browsers without autofocus support>, a JS fallback is used if @AutoFocus@ is true.
searchField :: Monad m => RenderMessage (HandlerSite m) FormMessage => AutoFocus -> Field m Text
searchField autoFocus = Field
    { fieldParse = parseHelper Right
    , fieldView = \theId name attrs val isReq -> do
        [whamlet|
$newline never
<input id="#{theId}" name="#{name}" *{attrs} type="search" :isReq:required="" :autoFocus:autofocus="" value="#{either id id val}">
|]
        when autoFocus $ do
          -- we want this javascript to be placed immediately after the field
          [whamlet|
$newline never
<script>if (!('autofocus' in document.createElement('input'))) {document.getElementById('#{theId}').focus();}
|]
          toWidget [cassius|
            ##{theId}
              -webkit-appearance: textfield
            |]
    , fieldEnctype = UrlEncoded
    }
-- | Creates an input with @type="url"@, validating the URL according to RFC3986.
urlField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Text
urlField = Field
    { fieldParse = parseHelper $ \s ->
        case parseURI $ unpack s of
            Nothing -> Left $ MsgInvalidUrl s
            Just _ -> Right s
    , fieldView = \theId name attrs val isReq ->
        [whamlet|<input ##{theId} name=#{name} *{attrs} type=url :isReq:required value=#{either id id val}>|]
    , fieldEnctype = UrlEncoded
    }

-- | Creates a @\<select>@ tag for selecting one option. Example usage:
--
-- > areq (selectFieldList [("Value 1" :: Text, "value1"),("Value 2", "value2")]) "Which value?" Nothing
selectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
                => [(msg, a)]
                -> Field (HandlerT site IO) a
selectFieldList = selectField . optionsPairs

-- | Creates a @\<select>@ tag for selecting one option. Example usage:
--
-- > areq (selectField $ optionsPairs [(MsgValue1, "value1"),(MsgValue2, "value2")]) "Which value?" Nothing
selectField :: (Eq a, RenderMessage site FormMessage)
            => HandlerT site IO (OptionList a)
            -> Field (HandlerT site IO) a
selectField = selectFieldHelper
    (\theId name attrs inside -> [whamlet|
$newline never
<select ##{theId} name=#{name} *{attrs}>^{inside}
|]) -- outside
    (\_theId _name isSel -> [whamlet|
$newline never
<option value=none :isSel:selected>_{MsgSelectNone}
|]) -- onOpt
    (\_theId _name _attrs value isSel text -> [whamlet|
$newline never
<option value=#{value} :isSel:selected>#{text}
|]) -- inside

-- | Creates a @\<select>@ tag for selecting multiple options.
multiSelectFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
                     => [(msg, a)]
                     -> Field (HandlerT site IO) [a]
multiSelectFieldList = multiSelectField . optionsPairs

-- | Creates a @\<select>@ tag for selecting multiple options.
multiSelectField :: (Eq a, RenderMessage site FormMessage)
                 => HandlerT site IO (OptionList a)
                 -> Field (HandlerT site IO) [a]
multiSelectField ioptlist =
    Field parse view UrlEncoded
  where
    parse [] _ = return $ Right Nothing
    parse optlist _ = do
        mapopt <- olReadExternal <$> ioptlist
        case mapM mapopt optlist of
             Nothing -> return $ Left "Error parsing values"
             Just res -> return $ Right $ Just res

    view theId name attrs val isReq = do
        opts <- fmap olOptions $ handlerToWidget ioptlist
        let selOpts = map (id &&& (optselected val)) opts
        [whamlet|
            <select ##{theId} name=#{name} :isReq:required multiple *{attrs}>
                $forall (opt, optsel) <- selOpts
                    <option value=#{optionExternalValue opt} :optsel:selected>#{optionDisplay opt}
                |]
        where
            optselected (Left _) _ = False
            optselected (Right vals) opt = (optionInternalValue opt) `elem` vals

-- | Creates an input with @type="radio"@ for selecting one option.
radioFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg)
               => [(msg, a)]
               -> Field (HandlerT site IO) a
radioFieldList = radioField . optionsPairs

-- | Creates an input with @type="checkbox"@ for selecting multiple options.
checkboxesFieldList :: (Eq a, RenderMessage site FormMessage, RenderMessage site msg) => [(msg, a)]
                     -> Field (HandlerT site IO) [a]
checkboxesFieldList = checkboxesField . optionsPairs

-- | Creates an input with @type="checkbox"@ for selecting multiple options.
checkboxesField :: (Eq a, RenderMessage site FormMessage)
                 => HandlerT site IO (OptionList a)
                 -> Field (HandlerT site IO) [a]
checkboxesField ioptlist = (multiSelectField ioptlist)
    { fieldView =
        \theId name attrs val isReq -> do
            opts <- fmap olOptions $ handlerToWidget ioptlist
            let optselected (Left _) _ = False
                optselected (Right vals) opt = (optionInternalValue opt) `elem` vals
            [whamlet|
                <span ##{theId}>
                    $forall opt <- opts
                        <label>
                            <input type=checkbox name=#{name} value=#{optionExternalValue opt} *{attrs} :optselected val opt:checked>
                            #{optionDisplay opt}

                |]
    }
-- | Creates an input with @type="radio"@ for selecting one option.}
radioField-- | Creates an input with @type="radio"@ for selecting one option.:: (Eq a, RenderMessage site FormMessage)
radioField :: (HandlerTEq a, RenderMessagesite IO (OptionList FormMessagea)      )
           => HandlerTField (HandlerT IOsiteOptionListIO) a   a)
radioField ->= selectFieldHelper (HandlerT site IO) a
radioField(\theId=_name_attrs inside -> [whamlet|
$newline never
<div ##{theId}>^{inside}
|]  \theId _name _attrs inside -> [whamlet|
$newline never
<div ##{theId}>^{inside}
|]) (\theId name isSel -> [whamlet|
$newline never
<label .radio for=#{theId}-none>
    <div>
        <input id=#{theId}-none type=radio name=#{name} value=none :isSel:checked>
        _{MsgSelectNone}
|]  \theId name isSel -> [whamlet|
$newline never
<label .radio for=#{theId}-none>
    <div>
        <input id=#{theId}-none type=radio name=#{name} value=none :isSel:checked>
        _{MsgSelectNone}
|]) (\theId name attrs value isSel text -> [whamlet|
$newline never
<label .radio for=#{theId}-#{value}>
    <div>
        <input id=#{theId}-#{value} type=radio name=#{name} value=#{value} :isSel:checked *{attrs}>
        \#{text}
|]  \theId name attrs value isSel text -> [whamlet|
$newline never
<label .radio for=#{theId}-#{value}>
    <div>
        <input id=#{theId}-#{value} type=radio name=#{name} value=#{value} :isSel:checked *{attrs}>
        \#{text}
|])
-- | Creates a group of radio buttons to answer the question given in the message. Radio buttons are used to allow differentiating between an empty response (@Nothing@) and a no response (@Just False@). Consider using the simpler 'checkBoxField' if you don't need to make this distinction.
---- | Creates a group of radio buttons to answer the question given in the message. Radio buttons are used to allow differentiating between an empty response (@Nothing@) and a no response (@Just False@). Consider using the simpler 'checkBoxField' if you don't need to make this distinction.
---- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
---- If this field is optional, the first radio button is labeled "\<None>", the second \"Yes" and the third \"No".
---- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
---- If this field is required, the first radio button is labeled \"Yes" and the second \"No".
---- (Exact label titles will depend on localization).
boolField-- (Exact label titles will depend on localization).:: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
boolField ::= Field m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
boolField{ fieldParse= Field  = \e _ -> return $ boolParser e
      { fieldParsefieldView ==\\theIde _ ->nameattrs boolParserval isReq -> [whamlet|
$newline never
  $if not isReq
      <input id=#{theId}-none *{attrs} type=radio name=#{name} value=none checked>
      <label for=#{theId}-none>_{MsgSelectNone}


<input id=#{theId}-yes *{attrs} type=radio name=#{name} value=yes :showVal id val:checked>
<label for=#{theId}-yes>_{MsgBoolYes}

<input id=#{theId}-no *{attrs} type=radio name=#{name} value=no :showVal not val:checked>
<label for=#{theId}-no>_{MsgBoolNo}
|]    , fieldView = \theId name attrs val isReq -> [whamlet|
$newline never
  $if not isReq
      <input id=#{theId}-none *{attrs} type=radio name=#{name} value=none checked>
      <label for=#{theId}-none>_{MsgSelectNone}


<input id=#{theId}-yes *{attrs} type=radio name=#{name} value=yes :showVal id val:checked>
<label for=#{theId}-yes>_{MsgBoolYes}

<input id=#{theId}-no *{attrs} type=radio name=#{name} value=no :showVal not val:checked>
<label for=#{theId}-no>_{MsgBoolNo}
|]  , fieldEnctype = UrlEncoded
    , fieldEnctype = UrlEncoded
  where}
  whereboolParser [] = Right Nothing
    boolParser []:=)Right= casex of
    boolParser"" -> Rightx:_Nothing) = case x of
      """none" Right-> RightNothing
      "none""yes" ->Right$NothingJust True
      "yes""on" ->Right$$JustTrue
      "on" -> Right $ Just TrueFalse
      "no""true"->Right Just$ JustTrue
      "true""false"->->RightRight$$JustJustTrueFalse
      "false"t -> Left$RightSomeMessage Just False$ MsgInvalidBool t
    showVal -> Left= either SomeMessage(\_ -> False MsgInvalidBool)             t
    showVal = either (\_ -> False)
-- | Creates an input with @type="checkbox"@.
-- | Creates an input with @type="checkbox"@.--   While the default @'boolField'@ implements a radio button so you
--   While the default @'boolField'@ implements a radio button so you
--   can differentiate between an empty response (@Nothing@) and a no--   response (@Just False@), this simpler checkbox field returns an empty
--   response as @Just False@.--   response (@Just False@), this simpler checkbox field returns an empty
----   response as @Just False@.
----   Note that this makes the field always optional.
----   Note that this makes the field always optional.
--checkBoxField :: Monad m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
checkBoxField ::= Field m => RenderMessage (HandlerSite m) FormMessage => Field m Bool
checkBoxField{ fieldParse= Field= \e _ -> return $ checkBoxParser e
    { fieldParsefieldView  = \etheId ->nameattrs checkBoxParserval _ -> [whamlet|
$newline never
<input id=#{theId} *{attrs} type=checkbox name=#{name} value=yes :showVal id val:checked>
|]                                                 
    , fieldView  = \theId name attrs val _ -> [whamlet|
$newline never
<input id=#{theId} *{attrs} type=checkbox name=#{name} value=yes :showVal id val:checked>
|]  , fieldEnctype = UrlEncoded
    , fieldEnctype = UrlEncoded
    }
    where
    wherecheckBoxParser [] = Right $ Just False
        checkBoxParser []:=)Right= case Justx of False
        checkBoxParser"yes" -> Rightx:_) =JustTrue of
            "yes""on" ->Right$$JustTrue
            "on"_    ->->RightRight$$JustJustTrueFalse
            _     -> Right $ Just False
        showVal = either (\_ -> False)
        showVal = either (\_ -> False)
-- | A structure holding a list of options. Typically you can use a convenience function like 'mkOptionList' or 'optionsPairs' instead of creating this directly.
data-- | A structure holding a list of options. Typically you can use a convenience function like 'mkOptionList' or 'optionsPairs' instead of creating this directly.OptionList a = OptionList
data{OptionListolOptions a::=[OptionListOption a]
    { olOptionsolReadExternal:: [Option:: Text]-> Maybe a -- ^ A function mapping from the form's value ('optionExternalValue') to the selected Haskell value ('optionInternalValue').
    , olReadExternal :: Text -> Maybe a -- ^ A function mapping from the form's value ('optionExternalValue') to the selected Haskell value ('optionInternalValue').
-- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.}
mkOptionList-- | Creates an 'OptionList', using a 'Map' to implement the 'olReadExternal' function.:: [Option a] -> OptionList a
mkOptionList :: [OptionOptionList] -> OptionList a
mkOptionList{ olOptions = OptionListos
    { olOptionsolReadExternal= os = flip Map.lookup $ Map.fromList $ map (optionExternalValue &&& optionInternalValue) os
    , olReadExternal = flip Map.lookup $ Map.fromList $ map (optionExternalValue &&& optionInternalValue) os
    }
data Option a = Option
data{OptionoptionDisplay = Option:: Text -- ^ The user-facing label.
    { optionDisplayoptionInternalValue:: Text::-- ^ The user-facing label.a -- ^ The Haskell value being selected.
    , optionInternalValue :: aText-- ^ The Haskell value being selected.-- ^ The representation of this value stored in the form.
    , optionExternalValue :: Text -- ^ The representation of this value stored in the form.
-- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.}
optionsPairs-- | Creates an 'OptionList' from a list of (display-value, internal value) pairs.:: (MonadHandler m, RenderMessage (HandlerSite m) msg)
optionsPairs :: (MonadHandler(msg, a)] -> m,(RenderMessageOptionList a) (HandlerSite m) msg)
optionsPairs =>opts(msg= do, a)] -> m (OptionList a)
optionsPairsmr <- getMessageRender = do
  mrlet<-mkOptionexternal (display, internal) =
  let mkOptionOption{ optionDisplaydisplay, internal= mr) =display
          Option { optionDisplayoptionInternalValue = mrinternal
                 , optionInternalValue = internalpack $ show external
                 , optionExternalValue = pack $ show external
  return $ mkOptionList}      (zipWith mkOption [1 :: Int ..] opts)
  return $ mkOptionList (zipWith mkOption [1 :: Int ..] opts)
-- | Creates an 'OptionList' from an 'Enum', using its 'Show' instance for the user-facing value.
optionsEnum-- | Creates an 'OptionList' from an 'Enum', using its 'Show' instance for the user-facing value.:: (MonadHandler m, Show a, Enum a, Bounded a) => m (OptionList a)
optionsEnum ::= optionsPairsMonadHandler$ mmap, Show(\x a->, Enum(packa, Boundedshow x, a))=>[minBound (OptionList..maxBound) ]
optionsEnum = optionsPairs $ map (\x -> (pack $ show x, x)) [minBound..maxBound]
-- | Selects a list of 'Entity's with the given 'Filter' and 'SelectOpt's. The @(a -> msg)@ function is then used to derive the display value for an 'OptionList'. Example usage:
---- | Selects a list of 'Entity's with the given 'Filter' and 'SelectOpt's. The @(a -> msg)@ function is then used to derive the display value for an 'OptionList'. Example usage:
---- > Country
-- > Country-- >    name Text
-- >    name Text-- >    deriving Eq -- Must derive Eq
---- >    deriving Eq -- Must derive Eq
---- > data CountryForm = CountryForm
-- >   { country :: Entity Country-- > data CountryForm = CountryForm
-- >   }-- >   { country :: Entity Country
-- >-- >   }
-- >-- > countryNameForm :: AForm Handler CountryForm
-- > countryNameForm = CountryForm-- > countryNameForm :: AForm Handler CountryForm
-- > countryNameForm = CountryForm-- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
-- >         where-- >         <$> areq (selectField countries) "Which country do you live in?" Nothing
-- >         where-- >           countries = optionsPersist [] [Asc CountryName] countryName
optionsPersist-- >           countries = optionsPersist [] [Asc CountryName] countryName:: ( YesodPersist site, PersistEntity a
optionsPersist :: ( YesodPersist site(PersistEntityBackend, PersistEntity a a)
                  , PersistQueryPathPiece (KeyPersistEntityBackenda)                  a)
                  , PathPieceRenderMessageKeysite)  msg
                  , RenderMessageYesodPersistBackend msgsite ~ PersistEntityBackend a
                  , YesodPersistBackend site ~ PersistEntityBackend a
               => )Filter a]
               => [FilterSelectOpt] a]
               -> [SelectOpta -> msg) a]
               -> (HandlerTa -> msg)site IO (OptionList (Entity a))
optionsPersist ->filtsords toDisplay IO (OptionList= fmap mkOptionListEntity a))do
optionsPersistmr <- getMessageRender ords toDisplay = fmap mkOptionList $ do
    mrpairs<- getMessageRender<- runDB $ selectList filts ords
    pairsreturn<-$ runDBmap (\$Entitykey value) ords-> Option
    return{ optionDisplay map (\(Entity= mr(toDisplay) ->value)
                   { optionDisplayoptionInternalValue= mr (toDisplay= Entity keyvalue)
                   , optionInternalValue = EntitytoPathPiece valuekey
                   ,)optionExternalValuepairs              = toPathPiece key
                   }) pairs
-- | An alternative to 'optionsPersist' which returns just the 'Key' instead of
-- the entire 'Entity'.-- | An alternative to 'optionsPersist' which returns just the 'Key' instead of
---- the entire 'Entity'.
---- Since 1.3.2
-- Since 1.3.2optionsPersistKey
optionsPersistKey:: (YesodPersist site
  :: (YesodPersistPersistEntitya
     , PersistEntityPersistQuery (aPersistEntityBackend a)
     , PersistQueryPathPiece (KeyPersistEntityBackenda)                  a)
     , PathPieceRenderMessageKeysite)  msg
     , RenderMessageYesodPersistBackend msgsite ~ PersistEntityBackend a
     , YesodPersistBackend site ~ PersistEntityBackend a
  => )Filter a]
  => [FilterSelectOpt] a]
  -> [SelectOpta -> msg) a]
  -> (HandlerTa -> msg)site IO (OptionList (Key a))
  -> HandlerT site IO (OptionList (Key a))
optionsPersistKey filts ords toDisplay = fmap mkOptionList $ do
optionsPersistKeymr <- getMessageRender ords toDisplay = fmap mkOptionList $ do
    mrpairs<- getMessageRender<- runDB $ selectList filts ords
    pairsreturn<-$ runDBmap (\$Entitykey value) ords-> Option
    return{ optionDisplay map (\(Entity= mr(toDisplay) ->value)
                   { optionDisplayoptionInternalValue= mr (toDisplay= key     value)
                   , optionInternalValue = keytoPathPiece key
                   ,)optionExternalValuepairs              = toPathPiece key
                   }) pairs
selectFieldHelper
selectFieldHelper:: (Eq a, RenderMessage site FormMessage)
        :: (EqText,->Text -> [(Text, Text)] -> WidgetT)     site IO () -> WidgetT site IO ())
        => (Text -> Text -> [Bool(Text->, TextWidgetT)] ->siteIO ()site)    IO () -> WidgetT site IO ())
        -> (Text -> Text -> Bool[(Text->, WidgetTText)] ->Text->))Bool -> Text -> WidgetT site IO ())
        -> (HandlerTText -> Text -> [(OptionListText, Text)] -> Text -> Bool -> Text -> WidgetT site IO ())
        -> HandlerTField (HandlerT IOsiteOptionListIO) a   a)
selectFieldHelper-> Field (HandlerToutside onOpt IOinside) a  opts' = Field
selectFieldHelper{ fieldParse =outside\x _ ->onOptdo   inside opts' = Field
    { fieldParseopts <- opts'= \x _ -> do
            optsreturn<-$opts'selectParser opts x
        , fieldView $=selectParser\theId name optsattrsxval isReq -> do
    , fieldViewopts <- =fmaptheIdolOptions attrs$ handlerToWidget isReq -> doopts'
         optsoutside<- fmaptheIdolOptionsname attrs handlerToWidget$ do            opts'
         outsideunlessisReq$ attrs $theId  name $ not $ render opts val `elem` map optionExternalValue opts
             unlessflip mapM_opts onOpt$ \opt-> inside $ not $ render opts val `elem` map optionExternalValue opts
             fliptheId opts $ \opt -> inside
                theIdname
                name((if isReq then (("required", "required"):) else id) attrs)
                ((optionExternalValueif isReq then (("required"opt)   , "required"):) else id) attrs)
                (optionExternalValue(render opts val) ==optoptionExternalValue)                 opt)
                ((optionDisplayrender opts valopt))== optionExternalValue opt)
    , fieldEnctypeoptionDisplay= UrlEncodedopt)
    , fieldEnctype = UrlEncoded
  where}
  whererender _ (Left _) = ""
    render _optsLeft(Right) =a"") = maybe "" optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
    renderselectParser (Right_ [] =a)Right= maybeNothing optionExternalValue $ listToMaybe $ filter ((== a) . optionInternalValue) opts
    selectParser _opts] =sRight:_) = Nothingcase s of
    selectParser"" ->optsRights:Nothing_) = case s of
            """none" Right-> RightNothing
            "none"x -> case RightolReadExternal  opts x of
            x -> caseNothing-> Left $optsSomeMessage of    $ MsgInvalidEntry x
                    NothingJust y ->Right $ SomeMessageJust y      $ MsgInvalidEntry x
                    Just y -> Right $ Just y
-- | Creates an input with @type="file"@.
fileField-- | Creates an input with @type="file"@.:: (Monad m, RenderMessage (HandlerSite m) FormMessage)
fileField :: (FieldMonadmm,FileInfo (HandlerSite m) FormMessage)
fileField =>= Field m FileInfo
fileField{ fieldParse= Field= \_ files -> return $
    { fieldParsecase files= \of_ files -> return $
         case[files] -> Rightof   Nothing
             [file] ->:_Right-> Right$ Just file
     , fieldView:_\->id'Rightname $attrs_fileisReq -> toWidget [hamlet|
            <input id=#{id'} name=#{name} *{attrs} type=file :isReq:required>
        |], fieldView = \id' name attrs _ isReq -> toWidget [hamlet|
            <input id=#{id'} name=#{name} *{attrs} type=file :isReq:required>
        |], fieldEnctype = Multipart
    , fieldEnctype = Multipart
    }
fileAFormReq :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage)
fileAFormReq :: (FieldSettingsMonadHandler m,HandlerSitem) ->HandlerSiteAForm m FileInfo) FormMessage)
fileAFormReq => FieldSettings= AForm $ \(siteHandlerSite, langs) menvs) ->ints-> mdoFileInfo
fileAFormReqlet (namefs, ints'= AForm) = $ \(site, langs) menvs ints -> do
        let (namecase, ints'fsName) = fs of
                caseJustx ->(ofx, ints)
                    JustNothing ->->(x, ints)
                    Nothinglet ->   = incrInts ints
                        letin i'(pack= incrInts$ 'f' : ints i', i')
        id' <- maybe newIdentin (packreturn 'f'$ fsId showfs i', i')
        id' <-(res, errs) =     return $ fsId fs
        let (res,casemenvs) =  of
                caseNothing of-> (FormMissing, Nothing)
                    NothingJust (_,->fenvFormMissing) ->      , Nothing)
                    Justcase_, fenvMap.lookup) ->   name fenv of
                        caseJust(fi:_) name-> (FormSuccess of    fi, Nothing)
                            Just_ -> (fi:_) -> (FormSuccess fi, Nothing)
                            _ ->let t = renderMessage site langs MsgValueRequired
                                letin tFormFailure= renderMessage[t], site langs$ toHtmlt)
        let fv = FieldView       in (FormFailure [t], Just $ toMarkup t)
        let fv ={FieldViewfvLabel = toHtml $ renderMessage site langs $ fsLabel fs
                { fvLabelfvTooltip= toMarkup= fmap (toHtml renderMessage. renderMessage langssite $langs) $ fsTooltip       fs
                , fvTooltipfvId = id'= fmap (toMarkup . renderMessage site langs) $ fsTooltip fs
                , fvIdfvInput= id'= [whamlet|
$newline never
<input type=file name=#{name} ##{id'} *{fsAttrs fs}>
|]          , fvInput = [whamlet|
$newline never
<input type=file name=#{name} ##{id'} *{fsAttrs fs}>
|]          , fvErrors = errs
                , fvErrorsfvRequired= errs= True
                , fvRequired = True
        return (}res, (fv :), ints', Multipart)
        return (res, (fv :), ints', Multipart)
fileAFormOpt :: MonadHandler m
fileAFormOpt :: MonadHandlerRenderMessagem(HandlerSite m) FormMessage
             => RenderMessage (HandlerSite m) FormMessage
             => FieldSettingsAForm m (Maybe(HandlerSiteFileInfo)   m)
fileAFormOpt -> AForm= AForm (Maybe\(master, langs) ) menvs ints -> do
fileAFormOptlet (namefs, ints'= AForm) = $ \(master, langs) menvs ints -> do
        let (namecase, ints'fsName) = fs of
                caseJustx ->(ofx, ints)
                    JustNothing ->->(x, ints)
                    Nothinglet ->   = incrInts ints
                        letin i'(pack= incrInts$ 'f' : ints i', i')
        id' <- maybe newIdentin (packreturn 'f'$ fsId showfs i', i')
        id' <-(res, errs) =     return $ fsId fs
        let (res,casemenvs) =  of
                caseNothing of-> (FormMissing, Nothing)
                    NothingJust (_,->fenvFormMissing) ->      , Nothing)
                    Justcase_, fenvMap.lookup) ->   name fenv of
                        caseJust(fi:_) name-> (FormSuccess of    $ Just fi, Nothing)
                            Just_ -> (fiFormSuccess:_) -> (FormSuccessNothing, Nothing Just)fi, Nothing)
        let fv = FieldView  _ -> (FormSuccess Nothing, Nothing)
        let fv ={FieldViewfvLabel = toHtml $ renderMessage master langs $ fsLabel fs
                { fvLabelfvTooltip= toMarkup= fmap (toHtml renderMessage. renderMessagemaster $langs) $ fsTooltip       fs
                , fvTooltipfvId = id'= fmap (toMarkup . renderMessage master langs) $ fsTooltip fs
                , fvIdfvInput= id'= [whamlet|
$newline never
<input type=file name=#{name} ##{id'} *{fsAttrs fs}>
|]          , fvInput = [whamlet|
$newline never

</pre>