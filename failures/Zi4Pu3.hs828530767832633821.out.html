<a href="ZFS.hs1814652263297829547.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Zipper.hs964449474295741962.out.html">next</a></br></br><pre>1d0
< #!/usr/bin/env runhaskell
2a2
> 
53a54
> 
</pre></br><h2>original</h2></br><pre>#!/usr/bin/env runhaskell

 {- Feed this command a stream of UTF8 chars, and it will look up the
  - ones it can and just print the ones it can't.
  -
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}


{-# LANGUAGE ForeignFunctionInterface #-}

import Data.Char.CEDICT

import System.IO.UTF8
import Data.String.UTF8
import qualified Data.ByteString.Char8 as B
import Prelude hiding
  ( appendFile
  , getContents
  , getLine
  , print
  , putStr
  , putStrLn
  , readFile
  , readLn
  , writeFile
  )

import System.Environment
import Control.Monad
import Data.List


main                         =  do
  args                      <-  getArgs
  sequence_ $ map (putStrLn . lookUp . stringConverter) args


stringConverter              =  toString . fromRep . B.pack


lookUp s =
  case pindefs s of
    Nothing                 ->  "no leading match in " ++ s
    Just something          ->  format something


format ((m, r), [a, b])      =  unlines $ lookUpStat : repack
 where
  lookUpStat                 =  m ++ " from " ++ m ++ r
  repack                     =  map showPair $ zip a b
   where
    showPair (p, d)          =  unlines [" " ++ p, "  " ++ d]

</pre></br><h2>printed</h2></br><pre>

 {- Feed this command a stream of UTF8 chars, and it will look up the
  - ones it can and just print the ones it can't.
  -
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -}


{-# LANGUAGE ForeignFunctionInterface #-}

import Data.Char.CEDICT

import System.IO.UTF8
import Data.String.UTF8
import qualified Data.ByteString.Char8 as B
import Prelude hiding
  ( appendFile
  , getContents
  , getLine
  , print
  , putStr
  , putStrLn
  , readFile
  , readLn
  , writeFile
  )

import System.Environment
import Control.Monad
import Data.List


main                         =  do
  args                      <-  getArgs
  sequence_ $ map (putStrLn . lookUp . stringConverter) args


stringConverter              =  toString . fromRep . B.pack


lookUp s =
  case pindefs s of
    Nothing                 ->  "no leading match in " ++ s
    Just something          ->  format something


format ((m, r), [a, b])      =  unlines $ lookUpStat : repack
 where
  lookUpStat                 =  m ++ " from " ++ m ++ r
  repack                     =  map showPair $ zip a b
   where
    showPair (p, d)          =  unlines [" " ++ p, "  " ++ d]


</pre>