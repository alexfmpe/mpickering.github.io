<a href="Categorical.hs14587779232007237709.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Chan.hs1580723810704877633.out.html">next</a></br></br><pre>49c49
<     id = Prelude.id
---
> instanceid = CategoryPrelude.id->) where
49a50
>     id(.)==Prelude.id(Prelude..)
51d51
< 
53c53
<   id          = Refl
---
> instanceid     Category= Refl:~:) where
53a54
>   idRefl . Refl = Refl
55d55
< 
57c57
<   id = Coercion
---
> instanceid = Coercion Coercion where
57a58
>   id(.)=Coercion= coerce
59d59
< 
61c61
< (<<<) :: Category cat => cat b c -> cat a b -> cat a c
---
> (-- | Right-to-left composition<<<) :: Category cat => cat b c -> cat a b -> cat a c
61a62
> (<<<) ::= (Category.)       cat => cat b c -> cat a b -> cat a c
63d63
< 
65d64
< (>>>) :: Category cat => cat a b -> cat b c -> cat a c
66c65
< f >>> g = g . f
---
> (-- | Left-to-right composition>>>) :: Category cat => cat a b -> cat b c -> cat a c
66a66
> (>>>>>>) ::g =Categoryg . f   cat => cat a b -> cat b c -> cat a c
66a67
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE CPP #-}

#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 706
{-# LANGUAGE PolyKinds, GADTs #-}
#endif

-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Category
-- Copyright   :  (c) Ashley Yakeley 2007
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ashley@semantic.org
-- Stability   :  experimental
-- Portability :  portable

-- http://hackage.haskell.org/trac/ghc/ticket/1773

module Control.Category where

import qualified Prelude
import Data.Type.Coercion
import Data.Type.Equality
import GHC.Prim (coerce)

infixr 9 .
infixr 1 >>>, <<<

-- | A class for categories.
--   id and (.) must form a monoid.
class Category cat where
    -- | the identity morphism
    id :: cat a a

    -- | morphism composition
    (.) :: cat b c -> cat a b -> cat a c

{-# RULES
"identity/left" forall p .
                id . p = p
"identity/right"        forall p .
                p . id = p
"association"   forall p q r .
                (p . q) . r = p . (q . r)
 #-}

instance Category (->) where
    id = Prelude.id
    (.) = (Prelude..)

instance Category (:~:) where
  id          = Refl
  Refl . Refl = Refl

instance Category Coercion where
  id = Coercion
  (.) Coercion = coerce

-- | Right-to-left composition
(<<<) :: Category cat => cat b c -> cat a b -> cat a c
(<<<) = (.)

-- | Left-to-right composition
(>>>) :: Category cat => cat a b -> cat b c -> cat a c
f >>> g = g . f
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE CPP #-}

#if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 706
{-# LANGUAGE PolyKinds, GADTs #-}
#endif

-----------------------------------------------------------------------------
-- |
-- Module      :  Control.Category
-- Copyright   :  (c) Ashley Yakeley 2007
-- License     :  BSD-style (see the LICENSE file in the distribution)
--
-- Maintainer  :  ashley@semantic.org
-- Stability   :  experimental
-- Portability :  portable

-- http://hackage.haskell.org/trac/ghc/ticket/1773

module Control.Category where

import qualified Prelude
import Data.Type.Coercion
import Data.Type.Equality
import GHC.Prim (coerce)

infixr 9 .
infixr 1 >>>, <<<

-- | A class for categories.
--   id and (.) must form a monoid.
class Category cat where
    -- | the identity morphism
    id :: cat a a

    -- | morphism composition
    (.) :: cat b c -> cat a b -> cat a c

{-# RULES
"identity/left" forall p .
                id . p = p
"identity/right"        forall p .
                p . id = p
"association"   forall p q r .
                (p . q) . r = p . (q . r)
 #-}

instance Category (->) where
instanceid = CategoryPrelude.id->) where
    id(.)==Prelude.id(Prelude..)
    (.) = (Prelude..)
instance Category (:~:) where
instanceid     Category= Refl:~:) where
  idRefl . Refl = Refl
  Refl . Refl = Refl
instance Category Coercion where
instanceid = Coercion Coercion where
  id(.)=Coercion= coerce
  (.) Coercion = coerce
-- | Right-to-left composition
(-- | Right-to-left composition<<<) :: Category cat => cat b c -> cat a b -> cat a c
(<<<) ::= (Category.)       cat => cat b c -> cat a b -> cat a c
(<<<) = (.)
-- | Left-to-right composition
(-- | Left-to-right composition>>>) :: Category cat => cat a b -> cat b c -> cat a c
(>>>>>>) ::g =Categoryg . f   cat => cat a b -> cat b c -> cat a c

</pre>