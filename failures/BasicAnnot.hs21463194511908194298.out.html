<a href="BasicAnnot.hs16353394251654001669.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BasicInstances.hs1777724115269220094.out.html">next</a></br></br><pre>22c22
< {-# LINE 25 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
22a23
> 
22a24
> 
39c41
< {-# LINE 45 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
39a42
> 
39a43
> 
39a44
> 
43c48
< {-# LINE 53 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
43a49
> 
43a50
> 
43a51
> 
43a52
> 
56c65
< {-# LINE 69 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
56a66
> 
56a67
> 
56a68
> 
60c72
< {-# LINE 75 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
60a73
> 
60a74
> 
73c87
< {-# LINE 111 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
73a88
> 
73a89
> 
73a90
> 
73a91
> 
73a92
> 
73a93
> 
73a94
> 
73a95
> 
73a96
> 
73a97
> 
73a98
> 
73a99
> 
73a100
> 
73a101
> 
73a102
> 
73a103
> 
73a104
> 
73a105
> 
73a106
> 
73a107
> 
73a108
> 
73a109
> 
73a110
> 
81c118
< {-# LINE 120 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
81a119
> 
86c124
< {-# LINE 291 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
86a125
> 
86a126
> 
86a127
> 
86a128
> 
86a129
> 
86a130
> 
86a131
> 
86a132
> 
86a133
> 
86a134
> 
86a135
> 
86a136
> 
86a137
> 
86a138
> 
86a139
> 
86a140
> 
86a141
> 
86a142
> 
86a143
> 
86a144
> 
86a145
> 
86a146
> 
86a147
> 
86a148
> 
86a149
> 
86a150
> 
86a151
> 
86a152
> 
86a153
> 
86a154
> 
86a155
> 
86a156
> 
86a157
> 
86a158
> 
86a159
> 
86a160
> 
86a161
> 
86a162
> 
86a163
> 
86a164
> 
86a165
> 
86a166
> 
86a167
> 
86a168
> 
86a169
> 
86a170
> 
86a171
> 
86a172
> 
86a173
> 
86a174
> 
86a175
> 
86a176
> 
86a177
> 
86a178
> 
86a179
> 
86a180
> 
86a181
> 
86a182
> 
86a183
> 
86a184
> 
86a185
> 
86a186
> 
86a187
> 
86a188
> 
86a189
> 
86a190
> 
86a191
> 
86a192
> 
86a193
> 
86a194
> 
86a195
> 
86a196
> 
86a197
> 
86a198
> 
86a199
> 
86a200
> 
86a201
> 
86a202
> 
86a203
> 
86a204
> 
86a205
> 
86a206
> 
86a207
> 
86a208
> 
86a209
> 
86a210
> 
86a211
> 
86a212
> 
86a213
> 
86a214
> 
86a215
> 
86a216
> 
86a217
> 
86a218
> 
86a219
> 
86a220
> 
86a221
> 
86a222
> 
86a223
> 
86a224
> 
86a225
> 
86a226
> 
86a227
> 
86a228
> 
86a229
> 
86a230
> 
86a231
> 
86a232
> 
86a233
> 
86a234
> 
86a235
> 
86a236
> 
86a237
> 
86a238
> 
86a239
> 
86a240
> 
86a241
> 
86a242
> 
86a243
> 
86a244
> 
86a245
> 
86a246
> 
86a247
> 
86a248
> 
86a249
> 
86a250
> 
86a251
> 
86a252
> 
86a253
> 
86a254
> 
86a255
> 
86a256
> 
86a257
> 
86a258
> 
86a259
> 
86a260
> 
86a261
> 
86a262
> 
86a263
> 
86a264
> 
86a265
> 
86a266
> 
86a267
> 
86a268
> 
86a269
> 
86a270
> 
86a271
> 
86a272
> 
86a273
> 
86a274
> 
86a275
> 
86a276
> 
86a277
> 
86a278
> 
86a279
> 
86a280
> 
86a281
> 
86a282
> 
86a283
> 
86a284
> 
86a285
> 
86a286
> 
86a287
> 
86a288
> 
86a289
> 
86a290
> 
97c301
< {-# LINE 305 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
97a302
> 
97a303
> 
97a304
> 
101c308
< {-# LINE 313 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
101a309
> 
101a310
> 
101a311
> 
101a312
> 
110c321
< {-# LINE 325 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
110a322
> 
110a323
> 
110a324
> 
114c328
< {-# LINE 352 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
114a329
> 
114a330
> 
114a331
> 
114a332
> 
114a333
> 
114a334
> 
114a335
> 
114a336
> 
114a337
> 
114a338
> 
114a339
> 
114a340
> 
114a341
> 
114a342
> 
114a343
> 
114a344
> 
114a345
> 
114a346
> 
114a347
> 
114a348
> 
114a349
> 
114a350
> 
114a351
> 
119c356
< {-# LINE 411 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
119a357
> 
119a358
> 
119a359
> 
119a360
> 
119a361
> 
119a362
> 
119a363
> 
119a364
> 
119a365
> 
119a366
> 
119a367
> 
119a368
> 
119a369
> 
119a370
> 
119a371
> 
119a372
> 
119a373
> 
119a374
> 
119a375
> 
119a376
> 
119a377
> 
119a378
> 
119a379
> 
119a380
> 
119a381
> 
119a382
> 
119a383
> 
119a384
> 
119a385
> 
119a386
> 
119a387
> 
119a388
> 
119a389
> 
119a390
> 
119a391
> 
119a392
> 
119a393
> 
119a394
> 
119a395
> 
119a396
> 
119a397
> 
119a398
> 
119a399
> 
119a400
> 
119a401
> 
119a402
> 
119a403
> 
119a404
> 
119a405
> 
119a406
> 
119a407
> 
119a408
> 
119a409
> 
119a410
> 
123c414
< {-# LINE 424 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
123a415
> 
123a416
> 
123a417
> 
123a418
> 
123a419
> 
123a420
> 
123a421
> 
123a422
> 
123a423
> 
132c432
< {-# LINE 434 "src/ehc/CodeGen/BasicAnnot.chs" #-}
---
> 
132a433
> 
139a441
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.CodeGen.BasicAnnot
( BasicSize (..)
, basicSizeOf
, basicSizeIsSigned
, BasicTy (..)
, BasicAnnot (..)
, basicSizeDouble, basicSizeFloat )
where
import qualified Data.Map as Map
import Data.Bits
import Data.List
import UHC.Util.Pretty
import UHC.Util.Utils
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.CodeGen.Bits
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize



{-# LINE 25 "src/ehc/CodeGen/BasicAnnot.chs" #-}
data BasicSize
  = -- Word variants, bitsize explicit
    BasicSize_Word8
  | BasicSize_Word16
  | BasicSize_Word32
  | BasicSize_Word64
  -- Int variants, bitsize explicit
  | BasicSize_Int8
  | BasicSize_Int16
  | BasicSize_Int32
  | BasicSize_Int64
  -- Float variants, bitsize explicit
  | BasicSize_Float
  | BasicSize_Double
  deriving (Eq,Ord,Enum)

{-# LINE 45 "src/ehc/CodeGen/BasicAnnot.chs" #-}
deriving instance Typeable BasicSize
deriving instance Data BasicSize

{-# LINE 53 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance Show BasicSize where
  show BasicSize_Word8   = "w1"
  show BasicSize_Word16  = "w2"
  show BasicSize_Word32  = "w4"
  show BasicSize_Word64  = "w8"
  show BasicSize_Int8    = "i1"
  show BasicSize_Int16   = "i2"
  show BasicSize_Int32   = "i4"
  show BasicSize_Int64   = "i8"
  show BasicSize_Float   = "f4"
  show BasicSize_Double  = "f8"

{-# LINE 69 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance PP BasicSize where
  pp = pp . show

{-# LINE 75 "src/ehc/CodeGen/BasicAnnot.chs" #-}
basicSizeOfMp :: Map.Map Int BasicSize
basicSizeOfMp
  = Map.fromList
      [ (1, BasicSize_Word8 )
      , (2, BasicSize_Word16)
      , (4, BasicSize_Word32)
      , (8, BasicSize_Word64)
      ]

basicSizeOf :: Int -> BasicSize
basicSizeOf i = panicJust "BasicAnnot.basicSizeOf" $ Map.lookup i basicSizeOfMp

{-# LINE 111 "src/ehc/CodeGen/BasicAnnot.chs" #-}
basicSizeIsSigned :: BasicSize -> Bool
basicSizeIsSigned BasicSize_Int8  = True
basicSizeIsSigned BasicSize_Int16 = True
basicSizeIsSigned BasicSize_Int32 = True
basicSizeIsSigned BasicSize_Int64 = True
basicSizeIsSigned _               = False

{-# LINE 120 "src/ehc/CodeGen/BasicAnnot.chs" #-}
basicSizeDouble, basicSizeFloat :: BasicSize
basicSizeFloat  = BasicSize_Float
basicSizeDouble = BasicSize_Double

{-# LINE 291 "src/ehc/CodeGen/BasicAnnot.chs" #-}
-- the defs in basicTyGBTy must be at the beginning, as Enum uses the relative ordering
data BasicTy
  = BasicTy_Word                -- base case: pointer, word, int, ...
  | BasicTy_SWord               -- base case: signed word
  | BasicTy_SHWord              -- base case: signed half word
  | BasicTy_Float               -- C: float
  | BasicTy_Double              -- C: double
  | BasicTy_SignedHalfWord      -- as BasicTy_Word, but for FFI half the size of a word, and signed. Special case for sign extend.
  deriving (Eq,Ord,Enum)

{-# LINE 305 "src/ehc/CodeGen/BasicAnnot.chs" #-}
deriving instance Typeable BasicTy
deriving instance Data BasicTy

{-# LINE 313 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance Show BasicTy where
  show BasicTy_Word             = "word"
  show BasicTy_SWord            = "sword"
  show BasicTy_SHWord           = "shword"
  show BasicTy_Float            = "float"
  show BasicTy_Double           = "double"
  show BasicTy_SignedHalfWord   = "int"

{-# LINE 325 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance PP BasicTy where
  pp = pp . show

{-# LINE 352 "src/ehc/CodeGen/BasicAnnot.chs" #-}
data BasicAnnot
  = BasicAnnot_None
  deriving (Show,Eq)

{-# LINE 411 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance PP BasicAnnot where
  pp _                                     = pp "ANNOT"

{-# LINE 424 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance Serialize BasicTy where
  sput = sputEnum8
  sget = sgetEnum8

instance Serialize BasicSize where
  sput = sputEnum8
  sget = sgetEnum8

{-# LINE 434 "src/ehc/CodeGen/BasicAnnot.chs" #-}
instance Serialize BasicAnnot where
  sput (BasicAnnot_None                 ) = sputWord8 0
  sget = do
    t <- sgetWord8
    case t of
      0 -> return BasicAnnot_None

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.CodeGen.BasicAnnot
( BasicSize (..)
, basicSizeOf
, basicSizeIsSigned
, BasicTy (..)
, BasicAnnot (..)
, basicSizeDouble, basicSizeFloat )
where
import qualified Data.Map as Map
import Data.Bits
import Data.List
import UHC.Util.Pretty
import UHC.Util.Utils
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.CodeGen.Bits
import Control.Monad
import UHC.Util.Binary
import UHC.Util.Serialize






data BasicSize
  = -- Word variants, bitsize explicit
    BasicSize_Word8
  | BasicSize_Word16
  | BasicSize_Word32
  | BasicSize_Word64
  -- Int variants, bitsize explicit
  | BasicSize_Int8
  | BasicSize_Int16
  | BasicSize_Int32
  | BasicSize_Int64
  -- Float variants, bitsize explicit
  | BasicSize_Float
  | BasicSize_Double
  deriving (Eq,Ord,Enum)





deriving instance Typeable BasicSize
deriving instance Data BasicSize






instance Show BasicSize where
  show BasicSize_Word8   = "w1"
  show BasicSize_Word16  = "w2"
  show BasicSize_Word32  = "w4"
  show BasicSize_Word64  = "w8"
  show BasicSize_Int8    = "i1"
  show BasicSize_Int16   = "i2"
  show BasicSize_Int32   = "i4"
  show BasicSize_Int64   = "i8"
  show BasicSize_Float   = "f4"
  show BasicSize_Double  = "f8"





instance PP BasicSize where
  pp = pp . show




basicSizeOfMp :: Map.Map Int BasicSize
basicSizeOfMp
  = Map.fromList
      [ (1, BasicSize_Word8 )
      , (2, BasicSize_Word16)
      , (4, BasicSize_Word32)
      , (8, BasicSize_Word64)
      ]

basicSizeOf :: Int -> BasicSize
basicSizeOf i = panicJust "BasicAnnot.basicSizeOf" $ Map.lookup i basicSizeOfMp

























basicSizeIsSigned :: BasicSize -> Bool
basicSizeIsSigned BasicSize_Int8  = True
basicSizeIsSigned BasicSize_Int16 = True
basicSizeIsSigned BasicSize_Int32 = True
basicSizeIsSigned BasicSize_Int64 = True
basicSizeIsSigned _               = False



basicSizeDouble, basicSizeFloat :: BasicSize
basicSizeFloat  = BasicSize_Float
basicSizeDouble = BasicSize_Double








































































































































































-- the defs in basicTyGBTy must be at the beginning, as Enum uses the relative ordering
data BasicTy
  = BasicTy_Word                -- base case: pointer, word, int, ...
  | BasicTy_SWord               -- base case: signed word
  | BasicTy_SHWord              -- base case: signed half word
  | BasicTy_Float               -- C: float
  | BasicTy_Double              -- C: double
  | BasicTy_SignedHalfWord      -- as BasicTy_Word, but for FFI half the size of a word, and signed. Special case for sign extend.
  deriving (Eq,Ord,Enum)





deriving instance Typeable BasicTy
deriving instance Data BasicTy






instance Show BasicTy where
  show BasicTy_Word             = "word"
  show BasicTy_SWord            = "sword"
  show BasicTy_SHWord           = "shword"
  show BasicTy_Float            = "float"
  show BasicTy_Double           = "double"
  show BasicTy_SignedHalfWord   = "int"





instance PP BasicTy where
  pp = pp . show

























data BasicAnnot
  = BasicAnnot_None
  deriving (Show,Eq)
























































instance PP BasicAnnot where
  pp _                                     = pp "ANNOT"











instance Serialize BasicTy where
  sput = sputEnum8
  sget = sgetEnum8

instance Serialize BasicSize where
  sput = sputEnum8
  sget = sgetEnum8



instance Serialize BasicAnnot where
  sput (BasicAnnot_None                 ) = sputWord8 0
  sget = do
    t <- sgetWord8
    case t of
      0 -> return BasicAnnot_None


</pre>