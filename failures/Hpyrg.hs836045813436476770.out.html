<a href="hpack-stat.hs1752200983798669970.out.html">prev</a></br><a href="failures.html">home</a></br><a href="hscrtmpl.hs1021979358832861200.out.html">next</a></br></br><pre>19d18
<     Raw { _raw ∷ Text }
20d18
<   | Ok { _raw ∷ Text }
21d18
<   | Fail { _raw ∷ Text }
22c19
<   | Error { _raw ∷ Text }
---
>     Raw { _raw :: Text }
22a20
>   | Ok { _raw :: Text }
22a21
>   | Fail { _raw :: Text }
22a22
>   | Error { _raw :: Text }
29c29
< main ∷ IO ()
---
> main :: IO ()
42c42
< colorize ∷ Text → Chunk
---
> colorize :: Text -> Chunk
44d43
<   Right w → w
45c44
<   Left _ → Raw input
---
>   Right w -> w
45a45
>   Left _ -> Raw input
50d49
<   Raw r `mappend` w      = over raw (\s → r <> " " <> s) w
51d49
<   Ok l `mappend` Raw r   = over raw (\s → s <> " " <> r) (Ok l)
52d49
<   Ok r `mappend` w       = over raw (\s → r <> " " <> s) w
53d49
<   Fail l `mappend` Raw r = over raw (\s → s <> " " <> r) (Fail l)
54d49
<   Fail l `mappend` Ok r  = over raw (\s → s <> " " <> r) (Fail l)
55d49
<   Fail r `mappend` w     = over raw (\s → r <> " " <> s) w
56c50
<   Error r `mappend` w    = over raw (\s → s <> " " <> view raw w) (Error r)
---
>   Raw r `mappend` w      = over raw (\s -> r <> " " <> s) w
56a51
>   Ok l `mappend` Raw r   = over raw (\s -> s <> " " <> r) (Ok l)
56a52
>   Ok r `mappend` w       = over raw (\s -> r <> " " <> s) w
56a53
>   Fail l `mappend` Raw r = over raw (\s -> s <> " " <> r) (Fail l)
56a54
>   Fail l `mappend` Ok r  = over raw (\s -> s <> " " <> r) (Fail l)
56a55
>   Fail r `mappend` w     = over raw (\s -> r <> " " <> s) w
56a56
>   Error r `mappend` w    = over raw (\s -> s <> " " <> view raw w) (Error r)
59c59
< wrap ∷ Chunk → Text
---
> wrap :: Chunk -> Text
66c66
< word ∷ Parser Chunk
---
> word :: Parser Chunk
72a73
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UnicodeSyntax #-}
module Main where

import Control.Applicative ((<$>), (<|>), many)
import Data.Monoid (Monoid(..), (<>))

import           Control.Lens (makeLenses, over, view)
import           Data.Text.Lazy (Text)
import qualified Data.Text.Lazy    as T
import qualified Data.Text.Lazy.IO as T
import           Options.Applicative (execParser, fullDesc, header, helper, info, progDesc)
import           Text.Parsec (anyChar, parse, string, try)
import           Text.Parsec.Text.Lazy


data Chunk =
    Raw { _raw ∷ Text }
  | Ok { _raw ∷ Text }
  | Fail { _raw ∷ Text }
  | Error { _raw ∷ Text }
    deriving (Show, Read)


makeLenses ''Chunk


main ∷ IO ()
main = do
  execParser opts
  T.interact (T.unlines . map line . T.lines)
 where
  opts = info helper
    ( fullDesc
    <> progDesc "Colorize python unittest execution output"
    <> header "Hpyrg - Pyrg utility done right"
    )
  line = wrap . mconcat . map colorize . T.words


colorize ∷ Text → Chunk
colorize input = case parse word "(hpyrg)" input of
  Right w → w
  Left _ → Raw input


instance Monoid Chunk where
  mempty = Raw mempty
  Raw r `mappend` w      = over raw (\s → r <> " " <> s) w
  Ok l `mappend` Raw r   = over raw (\s → s <> " " <> r) (Ok l)
  Ok r `mappend` w       = over raw (\s → r <> " " <> s) w
  Fail l `mappend` Raw r = over raw (\s → s <> " " <> r) (Fail l)
  Fail l `mappend` Ok r  = over raw (\s → s <> " " <> r) (Fail l)
  Fail r `mappend` w     = over raw (\s → r <> " " <> s) w
  Error r `mappend` w    = over raw (\s → s <> " " <> view raw w) (Error r)


wrap ∷ Chunk → Text
wrap (Raw t)   = t
wrap (Ok t)    = "\ESC[32m"   <> t <> "\ESC[0m"
wrap (Fail t)  = "\ESC[1;33m" <> t <> "\ESC[0m"
wrap (Error t) = "\ESC[31m"   <> t <> "\ESC[0m"


word ∷ Parser Chunk
word =
  Ok . T.pack    <$> try (string "ok")    <|>
  Ok . T.pack    <$> try (string "OK")    <|>
  Fail . T.pack  <$> try (string "FAIL")  <|>
  Error . T.pack <$> try (string "ERROR") <|>
  Raw . T.pack   <$> many anyChar
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UnicodeSyntax #-}
module Main where

import Control.Applicative ((<$>), (<|>), many)
import Data.Monoid (Monoid(..), (<>))

import           Control.Lens (makeLenses, over, view)
import           Data.Text.Lazy (Text)
import qualified Data.Text.Lazy    as T
import qualified Data.Text.Lazy.IO as T
import           Options.Applicative (execParser, fullDesc, header, helper, info, progDesc)
import           Text.Parsec (anyChar, parse, string, try)
import           Text.Parsec.Text.Lazy


data Chunk =
    Raw { _raw :: Text }
  | Ok { _raw :: Text }
  | Fail { _raw :: Text }
  | Error { _raw :: Text }
    deriving (Show, Read)


makeLenses ''Chunk


main :: IO ()
main = do
  execParser opts
  T.interact (T.unlines . map line . T.lines)
 where
  opts = info helper
    ( fullDesc
    <> progDesc "Colorize python unittest execution output"
    <> header "Hpyrg - Pyrg utility done right"
    )
  line = wrap . mconcat . map colorize . T.words


colorize :: Text -> Chunk
colorize input = case parse word "(hpyrg)" input of
  Right w -> w
  Left _ -> Raw input


instance Monoid Chunk where
  mempty = Raw mempty
  Raw r `mappend` w      = over raw (\s -> r <> " " <> s) w
  Ok l `mappend` Raw r   = over raw (\s -> s <> " " <> r) (Ok l)
  Ok r `mappend` w       = over raw (\s -> r <> " " <> s) w
  Fail l `mappend` Raw r = over raw (\s -> s <> " " <> r) (Fail l)
  Fail l `mappend` Ok r  = over raw (\s -> s <> " " <> r) (Fail l)
  Fail r `mappend` w     = over raw (\s -> r <> " " <> s) w
  Error r `mappend` w    = over raw (\s -> s <> " " <> view raw w) (Error r)


wrap :: Chunk -> Text
wrap (Raw t)   = t
wrap (Ok t)    = "\ESC[32m"   <> t <> "\ESC[0m"
wrap (Fail t)  = "\ESC[1;33m" <> t <> "\ESC[0m"
wrap (Error t) = "\ESC[31m"   <> t <> "\ESC[0m"


word :: Parser Chunk
word =
  Ok . T.pack    <$> try (string "ok")    <|>
  Ok . T.pack    <$> try (string "OK")    <|>
  Fail . T.pack  <$> try (string "FAIL")  <|>
  Error . T.pack <$> try (string "ERROR") <|>
  Raw . T.pack   <$> many anyChar

</pre>