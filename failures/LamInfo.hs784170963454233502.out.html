<a href="LambdaCase.hs771761420192958060.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Lang.hs1158577467977260520.out.html">next</a></br></br><pre>32c32
< {-# LINE 68 "src/ehc/LamInfo.chs" #-}
---
> 
32a33
> 
32a34
> 
32a35
> 
32a36
> 
32a37
> 
32a38
> 
32a39
> 
32a40
> 
32a41
> 
32a42
> 
32a43
> 
32a44
> 
32a45
> 
32a46
> 
32a47
> 
32a48
> 
32a49
> 
32a50
> 
32a51
> 
32a52
> 
32a53
> 
32a54
> 
32a55
> 
32a56
> 
32a57
> 
32a58
> 
32a59
> 
32a60
> 
32a61
> 
32a62
> 
32a63
> 
32a64
> 
32a65
> 
32a66
> 
32a67
> 
41c76
< {-# LINE 80 "src/ehc/LamInfo.chs" #-}
---
> 
41a77
> 
41a78
> 
41a79
> 
51c89
< {-# LINE 91 "src/ehc/LamInfo.chs" #-}
---
> 
51a90
> 
56c95
< {-# LINE 97 "src/ehc/LamInfo.chs" #-}
---
> 
56a96
> 
78c118
< {-# LINE 129 "src/ehc/LamInfo.chs" #-}
---
> 
78a119
> 
78a120
> 
78a121
> 
78a122
> 
78a123
> 
78a124
> 
78a125
> 
78a126
> 
78a127
> 
78a128
> 
85c135
< {-# LINE 139 "src/ehc/LamInfo.chs" #-}
---
> 
85a136
> 
85a137
> 
85a138
> 
107c160
< {-# LINE 173 "src/ehc/LamInfo.chs" #-}
---
> 
107a161
> 
107a162
> 
107a163
> 
107a164
> 
107a165
> 
107a166
> 
107a167
> 
107a168
> 
107a169
> 
107a170
> 
107a171
> 
107a172
> 
111c176
< {-# LINE 178 "src/ehc/LamInfo.chs" #-}
---
> 
111a177
> 
116c182
< {-# LINE 190 "src/ehc/LamInfo.chs" #-}
---
> 
116a183
> 
116a184
> 
116a185
> 
116a186
> 
116a187
> 
116a188
> 
116a189
> 
122c195
< {-# LINE 197 "src/ehc/LamInfo.chs" #-}
---
> 
122a196
> 
130c204
< {-# LINE 206 "src/ehc/LamInfo.chs" #-}
---
> 
130a205
> 
140c215
< {-# LINE 228 "src/ehc/LamInfo.chs" #-}
---
> 
140a216
> 
140a217
> 
140a218
> 
140a219
> 
140a220
> 
140a221
> 
140a222
> 
140a223
> 
140a224
> 
140a225
> 
140a226
> 
140a227
> 
162c249
< {-# LINE 251 "src/ehc/LamInfo.chs" #-}
---
> 
162a250
> 
169c257
< {-# LINE 259 "src/ehc/LamInfo.chs" #-}
---
> 
169a258
> 
185c274
< {-# LINE 316 "src/ehc/LamInfo.chs" #-}
---
> 
185a275
> 
185a276
> 
185a277
> 
185a278
> 
185a279
> 
185a280
> 
185a281
> 
185a282
> 
185a283
> 
185a284
> 
185a285
> 
185a286
> 
185a287
> 
185a288
> 
185a289
> 
185a290
> 
185a291
> 
185a292
> 
185a293
> 
185a294
> 
185a295
> 
185a296
> 
185a297
> 
185a298
> 
185a299
> 
185a300
> 
185a301
> 
185a302
> 
185a303
> 
185a304
> 
185a305
> 
185a306
> 
185a307
> 
185a308
> 
185a309
> 
185a310
> 
185a311
> 
185a312
> 
185a313
> 
185a314
> 
185a315
> 
189c319
< {-# LINE 345 "src/ehc/LamInfo.chs" #-}
---
> 
189a320
> 
189a321
> 
189a322
> 
189a323
> 
189a324
> 
189a325
> 
189a326
> 
189a327
> 
189a328
> 
189a329
> 
189a330
> 
189a331
> 
189a332
> 
189a333
> 
189a334
> 
189a335
> 
189a336
> 
189a337
> 
189a338
> 
189a339
> 
189a340
> 
189a341
> 
189a342
> 
189a343
> 
189a344
> 
194c349
< {-# LINE 351 "src/ehc/LamInfo.chs" #-}
---
> 
194a350
> 
222a379
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.LamInfo
( StackTraceInfo (..)
, LamInfoBindAsp (..)
, LamInfo (..), emptyLamInfo, emptyLamInfo'
, LamMp, emptyLamMp
, lamMpUnionBindAspMp, lamMpUnionsBindAspMp
, lamMpMergeInto
, lamMpLookupAsp, lamMpLookupAsp2, lamMpLookupLam, lamMpLookupCaf
, lamMpFilterLam, lamMpFilterCaf
, lamMpMergeFrom
, initLamMp
, laminfo1stArgIsStackTrace
, FusionRole (..) )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.AnaDomain
import UHC.Util.Utils
import UHC.Util.Pretty
import UHC.Light.Compiler.AnaDomain.Pretty
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import UHC.Util.Serialize
import Data.Typeable
import Data.Generics (Data)



{-# LINE 68 "src/ehc/LamInfo.chs" #-}
data StackTraceInfo
  = StackTraceInfo_None
  | StackTraceInfo_HasStackTraceEquiv   HsName      -- has a stack traced equivalent
  | StackTraceInfo_IsStackTraceEquiv    HsName      -- is a stack traced equivalent
  deriving ( Show
           , Data, Typeable
           )

{-# LINE 80 "src/ehc/LamInfo.chs" #-}
-- | The role a value takes in fusion
data FusionRole
  = FusionRole_Fuse         -- fuse this, i.e. inline, turned on by 'fuse f' for f
  | FusionRole_BuildLeft    -- role of g in 'convert g,h'
  | FusionRole_BuildRight   -- role of h in 'convert g,h'
  deriving ( Enum, Show
           , Data,Typeable
           )

{-# LINE 91 "src/ehc/LamInfo.chs" #-}
instance PP FusionRole where
  pp r = pp $ drop l $ show r
       where l = length "FusionRole_"

{-# LINE 97 "src/ehc/LamInfo.chs" #-}
-- | per aspect info
data LamInfoBindAsp
  = LamInfoBindAsp_RelevTy                          -- relevance typing
      { libindaspRelevTy        :: !RelevTy
      }
  | LamInfoBindAsp_Ty                               -- plain good old type
      { libindaspTy             :: !Ty
      }
  | LamInfoBindAsp_Core                             -- actual Core, should go paired with Ty (?? maybe pair them directly)
      { libindaspMetaLev        :: !MetaLev
      , libindaspCore           :: !CExpr
      }
  | LamInfoBindAsp_FusionRole                       -- role in fusion
      { libindaspFusionRole     :: !FusionRole
      }
  deriving ( Show
           , Data, Typeable
           )

type LamInfoBindAspMp = Map.Map ACoreBindAspectKeyS LamInfoBindAsp

{-# LINE 129 "src/ehc/LamInfo.chs" #-}
instance PP LamInfoBindAsp where
  pp (LamInfoBindAsp_RelevTy    t) = "RTy"  >#< pp t
  pp (LamInfoBindAsp_Ty         t) = "Ty"   >#< pp t
  pp (LamInfoBindAsp_Core    ml c) = pp "Core" -- >#< pp c -- Core.Pretty uses LamInfo, so module cycle...
  pp (LamInfoBindAsp_FusionRole r) = "Fuse" >#< pp r

{-# LINE 139 "src/ehc/LamInfo.chs" #-}
-- | per lambda implementation info
data LamInfo
  = LamInfo
      { laminfoArity                :: !Int                         -- arity of function
      , laminfoStackTrace           :: !StackTraceInfo              -- stacktrace
      , laminfoBindAspMp            :: !LamInfoBindAspMp            -- info organized per/keyed on aspect
      }
  deriving ( Show
           , Data, Typeable
           )

emptyLamInfo' :: LamInfo
emptyLamInfo'
  = LamInfo 0 StackTraceInfo_None
            Map.empty

emptyLamInfo :: LamInfo
emptyLamInfo
  = LamInfo 0 StackTraceInfo_None
            Map.empty

{-# LINE 173 "src/ehc/LamInfo.chs" #-}
instance PP LamInfo where
  pp (LamInfo {laminfoBindAspMp=m}) = ppAssocL $ assocLMapKey ppACBaspKeyS $ Map.toList m

{-# LINE 178 "src/ehc/LamInfo.chs" #-}
laminfo1stArgIsStackTrace :: LamInfo -> Bool
laminfo1stArgIsStackTrace (LamInfo {laminfoStackTrace=StackTraceInfo_IsStackTraceEquiv _}) = True
laminfo1stArgIsStackTrace _                                                                = False

{-# LINE 190 "src/ehc/LamInfo.chs" #-}
type LamMp    = Map.Map HsName LamInfo

emptyLamMp :: LamMp
emptyLamMp = Map.empty

{-# LINE 197 "src/ehc/LamInfo.chs" #-}
-- union, including the aspect map, but arbitrary for the info itself
lamMpUnionBindAspMp :: LamMp -> LamMp -> LamMp
lamMpUnionBindAspMp = Map.unionWith (\i1 i2 -> i1 {laminfoBindAspMp = laminfoBindAspMp i1 `Map.union` laminfoBindAspMp i2})

lamMpUnionsBindAspMp :: [LamMp] -> LamMp
lamMpUnionsBindAspMp = foldr lamMpUnionBindAspMp Map.empty

{-# LINE 206 "src/ehc/LamInfo.chs" #-}
-- propagate from new (left) to prev (right), adding new entries if necessary, combining with mergeL2RInfo, finally combining/choosing maps with mergeL2RMp
lamMpMergeInto :: (LamInfo -> LamInfo -> LamInfo) -> (LamMp -> LamMp -> LamMp) -> LamMp -> LamMp -> LamMp
lamMpMergeInto mergeL2RInfo mergeL2RMp newMp prevMp
  = mergeL2RMp newMpMerge prevMp
  where newMpMerge
          = Map.mapWithKey
              (\n i -> maybe i (mergeL2RInfo i) $ Map.lookup n prevMp
              ) newMp

{-# LINE 228 "src/ehc/LamInfo.chs" #-}
lamMpLookupAsp :: HsName -> ACoreBindAspectKeyS -> LamMp -> Maybe LamInfoBindAsp
lamMpLookupAsp n a m
  = fmap snd $ mapLookup2' laminfoBindAspMp n a m

lamMpLookupAsp2 :: ACoreBindRef -> LamMp -> Maybe LamInfoBindAsp
lamMpLookupAsp2 (ACoreBindRef n (Just a)) m = lamMpLookupAsp n a m

lamMpLookupLam :: HsName -> LamMp -> Maybe Int
lamMpLookupLam n m
  = case Map.lookup n m of
      j@(Just (LamInfo {laminfoArity=a})) | a > 0
        -> Just a
      _ -> Nothing

lamMpLookupCaf :: HsName -> LamMp -> Maybe Int
lamMpLookupCaf n m
  = case Map.lookup n m of
      j@(Just (LamInfo {laminfoArity=a})) | a == 0
        -> Just a
      _ -> Nothing

{-# LINE 251 "src/ehc/LamInfo.chs" #-}
lamMpFilterLam :: LamMp -> LamMp
lamMpFilterLam = Map.filter ((>0) . laminfoArity)

lamMpFilterCaf :: LamMp -> LamMp
lamMpFilterCaf = Map.filter ((==0) . laminfoArity)

{-# LINE 259 "src/ehc/LamInfo.chs" #-}
-- | merge info from arbitrary map m into LamMp holding LamInfo's
lamMpMergeFrom
  :: (LamInfo -> Maybe x)                   -- extract relevant info from a LamInfo
     -> (Maybe x -> LamInfo -> LamInfo)     -- set the info
     -> (z -> x -> x)                       -- merge info from new map and old info
     -> LamInfo                             -- default, empty LamInfo
     -> Map.Map HsName z                    -- arbitrary map holding info to merge
     -> LamMp -> LamMp
lamMpMergeFrom get set merge empty m lm
  = Map.foldrWithKey (\n z lm -> Map.alter (Just . upd z) n lm)
                    lm m
  where upd z (Just i) = set (Just (merge z $ maybe emptyExtra id $ get i)) i
        upd z Nothing  = set (Just (merge z         emptyExtra           )) empty
        emptyExtra = panicJust "lamMpMergeFrom" $ get $ empty

{-# LINE 316 "src/ehc/LamInfo.chs" #-}
initLamMp :: LamMp
initLamMp = emptyLamMp

{-# LINE 345 "src/ehc/LamInfo.chs" #-}
instance Serialize FusionRole where
  sput = sputEnum8
  sget = sgetEnum8

{-# LINE 351 "src/ehc/LamInfo.chs" #-}
instance Serialize LamInfoBindAsp where
  sput (LamInfoBindAsp_RelevTy      a) = sputWord8 0 >> sput a
  sput (LamInfoBindAsp_Ty           a) = sputWord8 1 >> sput a
  sput (LamInfoBindAsp_Core       a b) = sputWord8 2 >> sput a >> sput b
  sput (LamInfoBindAsp_FusionRole   a) = sputWord8 3 >> sput a
  sget = do
    t <- sgetWord8
    case t of
      0 -> liftM  LamInfoBindAsp_RelevTy    sget
      1 -> liftM  LamInfoBindAsp_Ty         sget
      2 -> liftM2 LamInfoBindAsp_Core       sget sget
      3 -> liftM  LamInfoBindAsp_FusionRole sget

instance Serialize LamInfo where
  sput (LamInfo a b c) = sput a >> sput b >> sput c
  sget = liftM3 LamInfo  sget sget sget

instance Serialize StackTraceInfo where
  sput (StackTraceInfo_None                ) = sputWord8 0
  sput (StackTraceInfo_HasStackTraceEquiv a) = sputWord8 1 >> sput a
  sput (StackTraceInfo_IsStackTraceEquiv  a) = sputWord8 2 >> sput a
  sget
    = do t <- sgetWord8
         case t of
           0 -> return StackTraceInfo_None
           1 -> liftM  StackTraceInfo_HasStackTraceEquiv sget
           2 -> liftM  StackTraceInfo_IsStackTraceEquiv  sget

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.LamInfo
( StackTraceInfo (..)
, LamInfoBindAsp (..)
, LamInfo (..), emptyLamInfo, emptyLamInfo'
, LamMp, emptyLamMp
, lamMpUnionBindAspMp, lamMpUnionsBindAspMp
, lamMpMergeInto
, lamMpLookupAsp, lamMpLookupAsp2, lamMpLookupLam, lamMpLookupCaf
, lamMpFilterLam, lamMpFilterCaf
, lamMpMergeFrom
, initLamMp
, laminfo1stArgIsStackTrace
, FusionRole (..) )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.AbstractCore
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Core
import UHC.Light.Compiler.AnaDomain
import UHC.Util.Utils
import UHC.Util.Pretty
import UHC.Light.Compiler.AnaDomain.Pretty
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad
import UHC.Util.Serialize
import Data.Typeable
import Data.Generics (Data)







































data StackTraceInfo
  = StackTraceInfo_None
  | StackTraceInfo_HasStackTraceEquiv   HsName      -- has a stack traced equivalent
  | StackTraceInfo_IsStackTraceEquiv    HsName      -- is a stack traced equivalent
  deriving ( Show
           , Data, Typeable
           )





-- | The role a value takes in fusion
data FusionRole
  = FusionRole_Fuse         -- fuse this, i.e. inline, turned on by 'fuse f' for f
  | FusionRole_BuildLeft    -- role of g in 'convert g,h'
  | FusionRole_BuildRight   -- role of h in 'convert g,h'
  deriving ( Enum, Show
           , Data,Typeable
           )



instance PP FusionRole where
  pp r = pp $ drop l $ show r
       where l = length "FusionRole_"



-- | per aspect info
data LamInfoBindAsp
  = LamInfoBindAsp_RelevTy                          -- relevance typing
      { libindaspRelevTy        :: !RelevTy
      }
  | LamInfoBindAsp_Ty                               -- plain good old type
      { libindaspTy             :: !Ty
      }
  | LamInfoBindAsp_Core                             -- actual Core, should go paired with Ty (?? maybe pair them directly)
      { libindaspMetaLev        :: !MetaLev
      , libindaspCore           :: !CExpr
      }
  | LamInfoBindAsp_FusionRole                       -- role in fusion
      { libindaspFusionRole     :: !FusionRole
      }
  deriving ( Show
           , Data, Typeable
           )

type LamInfoBindAspMp = Map.Map ACoreBindAspectKeyS LamInfoBindAsp












instance PP LamInfoBindAsp where
  pp (LamInfoBindAsp_RelevTy    t) = "RTy"  >#< pp t
  pp (LamInfoBindAsp_Ty         t) = "Ty"   >#< pp t
  pp (LamInfoBindAsp_Core    ml c) = pp "Core" -- >#< pp c -- Core.Pretty uses LamInfo, so module cycle...
  pp (LamInfoBindAsp_FusionRole r) = "Fuse" >#< pp r





-- | per lambda implementation info
data LamInfo
  = LamInfo
      { laminfoArity                :: !Int                         -- arity of function
      , laminfoStackTrace           :: !StackTraceInfo              -- stacktrace
      , laminfoBindAspMp            :: !LamInfoBindAspMp            -- info organized per/keyed on aspect
      }
  deriving ( Show
           , Data, Typeable
           )

emptyLamInfo' :: LamInfo
emptyLamInfo'
  = LamInfo 0 StackTraceInfo_None
            Map.empty

emptyLamInfo :: LamInfo
emptyLamInfo
  = LamInfo 0 StackTraceInfo_None
            Map.empty














instance PP LamInfo where
  pp (LamInfo {laminfoBindAspMp=m}) = ppAssocL $ assocLMapKey ppACBaspKeyS $ Map.toList m



laminfo1stArgIsStackTrace :: LamInfo -> Bool
laminfo1stArgIsStackTrace (LamInfo {laminfoStackTrace=StackTraceInfo_IsStackTraceEquiv _}) = True
laminfo1stArgIsStackTrace _                                                                = False









type LamMp    = Map.Map HsName LamInfo

emptyLamMp :: LamMp
emptyLamMp = Map.empty



-- union, including the aspect map, but arbitrary for the info itself
lamMpUnionBindAspMp :: LamMp -> LamMp -> LamMp
lamMpUnionBindAspMp = Map.unionWith (\i1 i2 -> i1 {laminfoBindAspMp = laminfoBindAspMp i1 `Map.union` laminfoBindAspMp i2})

lamMpUnionsBindAspMp :: [LamMp] -> LamMp
lamMpUnionsBindAspMp = foldr lamMpUnionBindAspMp Map.empty



-- propagate from new (left) to prev (right), adding new entries if necessary, combining with mergeL2RInfo, finally combining/choosing maps with mergeL2RMp
lamMpMergeInto :: (LamInfo -> LamInfo -> LamInfo) -> (LamMp -> LamMp -> LamMp) -> LamMp -> LamMp -> LamMp
lamMpMergeInto mergeL2RInfo mergeL2RMp newMp prevMp
  = mergeL2RMp newMpMerge prevMp
  where newMpMerge
          = Map.mapWithKey
              (\n i -> maybe i (mergeL2RInfo i) $ Map.lookup n prevMp
              ) newMp














lamMpLookupAsp :: HsName -> ACoreBindAspectKeyS -> LamMp -> Maybe LamInfoBindAsp
lamMpLookupAsp n a m
  = fmap snd $ mapLookup2' laminfoBindAspMp n a m

lamMpLookupAsp2 :: ACoreBindRef -> LamMp -> Maybe LamInfoBindAsp
lamMpLookupAsp2 (ACoreBindRef n (Just a)) m = lamMpLookupAsp n a m

lamMpLookupLam :: HsName -> LamMp -> Maybe Int
lamMpLookupLam n m
  = case Map.lookup n m of
      j@(Just (LamInfo {laminfoArity=a})) | a > 0
        -> Just a
      _ -> Nothing

lamMpLookupCaf :: HsName -> LamMp -> Maybe Int
lamMpLookupCaf n m
  = case Map.lookup n m of
      j@(Just (LamInfo {laminfoArity=a})) | a == 0
        -> Just a
      _ -> Nothing



lamMpFilterLam :: LamMp -> LamMp
lamMpFilterLam = Map.filter ((>0) . laminfoArity)

lamMpFilterCaf :: LamMp -> LamMp
lamMpFilterCaf = Map.filter ((==0) . laminfoArity)



-- | merge info from arbitrary map m into LamMp holding LamInfo's
lamMpMergeFrom
  :: (LamInfo -> Maybe x)                   -- extract relevant info from a LamInfo
     -> (Maybe x -> LamInfo -> LamInfo)     -- set the info
     -> (z -> x -> x)                       -- merge info from new map and old info
     -> LamInfo                             -- default, empty LamInfo
     -> Map.Map HsName z                    -- arbitrary map holding info to merge
     -> LamMp -> LamMp
lamMpMergeFrom get set merge empty m lm
  = Map.foldrWithKey (\n z lm -> Map.alter (Just . upd z) n lm)
                    lm m
  where upd z (Just i) = set (Just (merge z $ maybe emptyExtra id $ get i)) i
        upd z Nothing  = set (Just (merge z         emptyExtra           )) empty
        emptyExtra = panicJust "lamMpMergeFrom" $ get $ empty











































initLamMp :: LamMp
initLamMp = emptyLamMp



























instance Serialize FusionRole where
  sput = sputEnum8
  sget = sgetEnum8



instance Serialize LamInfoBindAsp where
  sput (LamInfoBindAsp_RelevTy      a) = sputWord8 0 >> sput a
  sput (LamInfoBindAsp_Ty           a) = sputWord8 1 >> sput a
  sput (LamInfoBindAsp_Core       a b) = sputWord8 2 >> sput a >> sput b
  sput (LamInfoBindAsp_FusionRole   a) = sputWord8 3 >> sput a
  sget = do
    t <- sgetWord8
    case t of
      0 -> liftM  LamInfoBindAsp_RelevTy    sget
      1 -> liftM  LamInfoBindAsp_Ty         sget
      2 -> liftM2 LamInfoBindAsp_Core       sget sget
      3 -> liftM  LamInfoBindAsp_FusionRole sget

instance Serialize LamInfo where
  sput (LamInfo a b c) = sput a >> sput b >> sput c
  sget = liftM3 LamInfo  sget sget sget

instance Serialize StackTraceInfo where
  sput (StackTraceInfo_None                ) = sputWord8 0
  sput (StackTraceInfo_HasStackTraceEquiv a) = sputWord8 1 >> sput a
  sput (StackTraceInfo_IsStackTraceEquiv  a) = sputWord8 2 >> sput a
  sget
    = do t <- sgetWord8
         case t of
           0 -> return StackTraceInfo_None
           1 -> liftM  StackTraceInfo_HasStackTraceEquiv sget
           2 -> liftM  StackTraceInfo_IsStackTraceEquiv  sget


</pre>