<a href="Internal.hs12900672701165706778.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Internal.hs16056753271305712687.out.html">next</a></br></br><pre>35d34
< type family s :\ a where
36d34
<     '[] :\ a = '[]
37d34
<     (a ': s) :\ a = s :\ a
38c35
<     (a' ': s) :\ a = a' ': (s :\ a)
---
> type family   :\    a where
38a36
>         :\ a = 
38a37
>              :\a  : s)    a = s :\ a
38a38
>               :\a'  : s)    a = a'  : (s :\ a)
43d42
< instance '[] :< s
44d42
< instance (s :< s', Typeable a) => (a ': s) :< (a ': s')
45c43
< instance (s :< s', '[a] :< s', Typeable a) => (a ': s) :< s'
---
> instance     :< s
45a44
> instance (s :< s', Typeable a) => (a  : s) :< (a  : s')
45a45
> instance (s :< s',  '[a] :< s', Typeable a) => (a  : s) :< s'
53c53
< liftUnion :: (Typeable a, '[a] :< s) => a -> Union s
---
> liftUnion :: (Typeable a,  '[a] :< s) => a -> Union s
68c68
< typesExhausted :: Union '[] -> a
---
> typesExhausted :: Union     -> a
70a71
> 
</pre></br><h2>original</h2></br><pre>-- | Exposed internals for Data.OpenUnion
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE IncoherentInstances #-}
{-# LANGUAGE UndecidableInstances #-}
module Data.OpenUnion.Internal
    ( Union (..)
    , (:<)
    , (:\)
    , (@>)
    , liftUnion
    , reUnion
    , restrict
    , typesExhausted
    ) where

import Data.Dynamic

-- | The @Union@ type - the phantom parameter @s@ is a list of types
-- denoting what this @Union@ might contain.
-- The value contained is one of those types.
newtype Union (s :: [*]) = Union Dynamic

-- general note: try to keep from re-constructing Unions if an existing one
-- can just be type-coerced.

-- | Remove a type from anywhere in the list.
type family s :\ a where
    '[] :\ a = '[]
    (a ': s) :\ a = s :\ a
    (a' ': s) :\ a = a' ': (s :\ a)

-- | There exists a @s :< s'@ instance if every type in the list @s@
-- can be lifted to @s'@.
class (:<) (s :: [*]) (s' :: [*])
instance '[] :< s
instance (s :< s', Typeable a) => (a ': s) :< (a ': s')
instance (s :< s', '[a] :< s', Typeable a) => (a ': s) :< s'

-- | `restrict` in right-fixable style.
(@>) :: Typeable a => (a -> b) -> (Union (s :\ a) -> b) -> Union s -> b
r @> l = either l r . restrict
infixr 2 @>
{-# INLINE (@>) #-}

liftUnion :: (Typeable a, '[a] :< s) => a -> Union s
liftUnion = Union . toDyn
{-# INLINE liftUnion #-}

-- | Narrow down a @Union@.
restrict :: Typeable a => Union s -> Either (Union (s :\ a)) a
restrict (Union d) = maybe (Left $ Union d) Right $ fromDynamic d
{-# INLINE restrict #-}

-- | Generalize a @Union@.
reUnion :: (s :< s') => Union s -> Union s'
reUnion (Union d) = Union d
{-# INLINE reUnion #-}

-- | Use this in places where all the @Union@ed options have been exhausted.
typesExhausted :: Union '[] -> a
typesExhausted = error "Union types exhausted - empty Union"
{-# INLINE typesExhausted #-}
</pre></br><h2>printed</h2></br><pre>-- | Exposed internals for Data.OpenUnion
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE EmptyDataDecls #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverlappingInstances #-}
{-# LANGUAGE IncoherentInstances #-}
{-# LANGUAGE UndecidableInstances #-}
module Data.OpenUnion.Internal
    ( Union (..)
    , (:<)
    , (:\)
    , (@>)
    , liftUnion
    , reUnion
    , restrict
    , typesExhausted
    ) where

import Data.Dynamic

-- | The @Union@ type - the phantom parameter @s@ is a list of types
-- denoting what this @Union@ might contain.
-- The value contained is one of those types.
newtype Union (s :: [*]) = Union Dynamic

-- general note: try to keep from re-constructing Unions if an existing one
-- can just be type-coerced.

-- | Remove a type from anywhere in the list.
type family   :\    a where
        :\ a = 
             :\a  : s)    a = s :\ a
              :\a'  : s)    a = a'  : (s :\ a)

-- | There exists a @s :< s'@ instance if every type in the list @s@
-- can be lifted to @s'@.
class (:<) (s :: [*]) (s' :: [*])
instance     :< s
instance (s :< s', Typeable a) => (a  : s) :< (a  : s')
instance (s :< s',  '[a] :< s', Typeable a) => (a  : s) :< s'

-- | `restrict` in right-fixable style.
(@>) :: Typeable a => (a -> b) -> (Union (s :\ a) -> b) -> Union s -> b
r @> l = either l r . restrict
infixr 2 @>
{-# INLINE (@>) #-}

liftUnion :: (Typeable a,  '[a] :< s) => a -> Union s
liftUnion = Union . toDyn
{-# INLINE liftUnion #-}

-- | Narrow down a @Union@.
restrict :: Typeable a => Union s -> Either (Union (s :\ a)) a
restrict (Union d) = maybe (Left $ Union d) Right $ fromDynamic d
{-# INLINE restrict #-}

-- | Generalize a @Union@.
reUnion :: (s :< s') => Union s -> Union s'
reUnion (Union d) = Union d
{-# INLINE reUnion #-}

-- | Use this in places where all the @Union@ed options have been exhausted.
typesExhausted :: Union     -> a
typesExhausted = error "Union types exhausted - empty Union"
{-# INLINE typesExhausted #-}

</pre>