<a href="Model.hs874131563593550214.out.html">prev</a></br><a href="failures.html">home</a></br><a href="ModuleImportExportImpl.hs14783297222049325511.out.html">next</a></br></br><pre>38c38
< {-# LINE 55 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
38a39
> 
38a40
> 
38a41
> 
38a42
> 
38a43
> 
38a44
> 
38a45
> 
38a46
> 
38a47
> 
38a48
> 
38a49
> 
38a50
> 
38a51
> 
38a52
> 
38a53
> 
38a54
> 
50c66
< {-# LINE 75 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
50a67
> 
50a68
> 
50a69
> 
50a70
> 
50a71
> 
50a72
> 
50a73
> 
50a74
> 
61c85
< {-# LINE 87 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
61a86
> 
66c91
< {-# LINE 93 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
66a92
> 
71c97
< {-# LINE 103 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
71a98
> 
71a99
> 
71a100
> 
71a101
> 
71a102
> 
89c120
< {-# LINE 132 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
89a121
> 
89a122
> 
89a123
> 
89a124
> 
89a125
> 
89a126
> 
89a127
> 
89a128
> 
89a129
> 
89a130
> 
89a131
> 
107c149
< {-# LINE 151 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
107a150
> 
125c168
< {-# LINE 170 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
125a169
> 
200c244
< {-# LINE 270 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
200a245
> 
200a246
> 
200a247
> 
200a248
> 
200a249
> 
200a250
> 
200a251
> 
200a252
> 
200a253
> 
200a254
> 
200a255
> 
200a256
> 
200a257
> 
200a258
> 
200a259
> 
200a260
> 
200a261
> 
200a262
> 
200a263
> 
200a264
> 
200a265
> 
200a266
> 
200a267
> 
200a268
> 
200a269
> 
211c280
< {-# LINE 286 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
211a281
> 
211a282
> 
211a283
> 
211a284
> 
211a285
> 
229c303
< {-# LINE 309 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
229a304
> 
229a305
> 
229a306
> 
229a307
> 
229a308
> 
241c320
< {-# LINE 326 "src/ehc/EHC/CompilePhase/Module.chs" #-}
---
> 
241a321
> 
241a322
> 
241a323
> 
241a324
> 
241a325
> 
250a335
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Module
( cpCheckModsModWith
, cpCheckModsWithOrWithoutBuiltin
, cpCheckModsWithBuiltin
, cpCheckModsWithoutBuiltin
, GetMeta (..), allGetMeta
, cpGetCoreRunModnameAndImports
, cpGetCoreModnameAndImports
, cpGetHsModnameAndImports, cpGetHsMod, cpGetMetaInfo
, cpGetDummyCheckSrcMod
, cpUpdateModOffMp
, cpGenImpNmInfo
, cpUpdHiddenExports )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.Rel as Rel
import UHC.Util.Time
import UHC.Util.FPath
import System.Directory
import Control.Monad.State
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.Config as Cfg
import qualified UHC.Light.Compiler.HS.ModImpExp as HSSemMod
import qualified UHC.Light.Compiler.Core.Check as Core2ChkSem
import qualified UHC.Light.Compiler.CoreRun.Check as CoreRun2ChkSem
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.Base.Debug





{-# LINE 55 "src/ehc/EHC/CompilePhase/Module.chs" #-}
-- | Check module dependencies for given 'Mod'
cpCheckModsModWith :: EHCCompileRunner m => (HsName -> ModMpInfo) -> [Mod] -> EHCompilePhaseT m ()
cpCheckModsModWith dfltMod modL@(Mod {modName = modNm} : _)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug $ "cpCheckModsModWith modL: " ++ show modL
       ; let crsi   = crStateInfo cr
             (mm,e) = modMpCombine' dfltMod modL (crsiModMp crsi)
       ; cpUpdSI (\crsi -> crsi {crsiModMp = mm})
       ; cpSetLimitErrsWhen 5 "Module analysis" e
       }

{-# LINE 75 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpCheckModsWithOrWithoutBuiltin :: EHCCompileRunner m => Bool -> [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithOrWithoutBuiltin bltin modNmL@(modNm:_)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug $ "cpCheckModsWithOrWithoutBuiltin modNmL: " ++ show modNmL
       ; let modL   = [ addBuiltin $ ecuMod $ crCU n cr | n <- modNmL ]
       ; cpCheckModsModWith (\n -> panic $ "cpCheckModsWithOrWithoutBuiltin: " ++ show n) modL
       }
  where addBuiltin | bltin     = \m -> m { modImpL = modImpBuiltin : modImpL m }
                   | otherwise = id

{-# LINE 87 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpCheckModsWithBuiltin :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithBuiltin = cpCheckModsWithOrWithoutBuiltin True
{-# INLINE cpCheckModsWithBuiltin #-}

{-# LINE 93 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpCheckModsWithoutBuiltin :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithoutBuiltin = cpCheckModsWithOrWithoutBuiltin False
{-# INLINE cpCheckModsWithoutBuiltin #-}

{-# LINE 103 "src/ehc/EHC/CompilePhase/Module.chs" #-}
data GetMeta
  = GetMeta_Src
  | GetMeta_HI
  | GetMeta_Core
  | GetMeta_CoreRun
  | GetMeta_Dir
  deriving (Eq,Ord)

allGetMeta
  = [ GetMeta_Src
    , GetMeta_HI
    , GetMeta_Core
    , GetMeta_CoreRun
    , GetMeta_Dir
    ]


{-# LINE 132 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpGetCoreRunModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetCoreRunModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbCrSemMod = ecuMbCoreRunSemMod ecu
                 crSemMod   = panicJust "cpGetCoreRunModnameAndImports" mbCrSemMod
                 modNm'     = CoreRun2ChkSem.realModuleNm_Syn_AGItf crSemMod
         ;  cpMsg modNm VerboseDebug $ "cpGetCoreRunModnameAndImports: " ++ show modNm ++ " -> " ++ show modNm'
         ;  case mbCrSemMod of
              Just _ -> cpUpdCUWithKey modNm $ \_ ecu ->
                          ( modNm'
                          , ecuStoreHSDeclImpS (Set.fromList $ CoreRun2ChkSem.impModNmL_Syn_AGItf crSemMod )
                            $ cuUpdKey modNm' ecu
                          )
              _      -> return modNm
         }

{-# LINE 151 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpGetCoreModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetCoreModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbCrSemMod = ecuMbCoreSemMod ecu
                 crSemMod   = panicJust "cpGetCoreModnameAndImports" mbCrSemMod
                 modNm'     = Core2ChkSem.realModuleNm_Syn_CodeAGItf crSemMod
         ;  cpMsg modNm VerboseDebug $ "cpGetCoreModnameAndImports: " ++ show modNm ++ " -> " ++ show modNm'
         ;  case mbCrSemMod of
              Just _ -> cpUpdCUWithKey modNm $ \_ ecu ->
                          ( modNm'
                          , ecuStoreHSDeclImpS (Set.fromList $ Core2ChkSem.impModNmL_Syn_CodeAGItf crSemMod )
                            $ cuUpdKey modNm' ecu
                          )
              _      -> return modNm
         }

{-# LINE 170 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpGetHsModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetHsModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbHsSemMod = ecuMbHSSemMod ecu
                 hsSemMod   = panicJust "cpGetHsModnameAndImports" mbHsSemMod
                 modNm'     = HSSemMod.realModuleNm_Syn_AGItf hsSemMod
                 upd        = ecuStoreHSDeclImpS ( -- (\v -> tr "XX" (pp $ Set.toList v) v) $
                                                  HSSemMod.modImpNmS_Syn_AGItf hsSemMod)
         ;  case mbHsSemMod of
              Just _ | ecuIsTopMod ecu -> cpUpdCUWithKey modNm (\_ ecu -> (modNm', upd $ cuUpdKey modNm' ecu))
                     | otherwise       -> do { cpUpdCU modNm upd ; return modNm }
              _      -> return modNm
         }

cpGetHsMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpGetHsMod modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbHsSemMod = ecuMbHSSemMod ecu
                 hsSemMod   = panicJust "cpGetHsMod" mbHsSemMod
                 mod        = HSSemMod.mod_Syn_AGItf hsSemMod
         ;  when (ehcOptVerbosity opts >= VerboseDebug)
                 (do { cpMsg modNm VerboseDebug "cpGetHsMod"
                     ; liftIO $ putWidthPPLn 120 (pp mod)
                     })
         ;  when (isJust mbHsSemMod)
                 (cpUpdCU modNm (ecuStoreMod mod))
         }

cpGetMetaInfo :: EHCCompileRunner m => [GetMeta] -> HsName -> EHCompilePhaseT m ()
cpGetMetaInfo gm modNm
  =  do  {  cr <- get
         ;  let (ecu,_,opts,fp) = crBaseInfo modNm cr
         ;  when (GetMeta_Src `elem` gm)
                 (tm opts ecu ecuStoreSrcTime        (ecuSrcFilePath ecu))
         {-
         ;  when (GetMeta_HI `elem` gm)
                 (tm opts ecu ecuStoreHITime
                                              (mkInOrOutputFPathFor (InputFrom_Loc $ ecuFileLocation ecu) opts modNm fp "hi")
                 )
         -}
         ;  when (GetMeta_HI `elem` gm)
                 (tm opts ecu ecuStoreHIInfoTime
                                              (mkInOrOutputFPathFor (InputFrom_Loc $ ecuFileLocation ecu) opts modNm fp "hi")
                 )
         ;  when (GetMeta_Core `elem` gm)
                 (tm opts ecu ecuStoreCoreTime      (fpathSetSuff Cfg.suffixDotlessBinaryCore fp))
         ;  when (GetMeta_CoreRun `elem` gm)
                 (tm opts ecu ecuStoreCoreRunTime   (fpathSetSuff Cfg.suffixDotlessBinaryCoreRun fp))
         ;  when (GetMeta_Dir `elem` gm)
                 (wr opts ecu ecuStoreDirIsWritable (                         fp     ))
         }
  where tm :: EHCCompileRunner m => EHCOpts -> EHCompileUnit -> (ClockTime -> EHCompileUnit -> EHCompileUnit) -> FPath -> EHCompilePhaseT m ()
        tm opts ecu store fp
          = do { let n = fpathToStr fp
               ; nExists <- liftIO $ doesFileExist n
               ; when (ehcOptVerbosity opts >= VerboseDebug)
                      (do { liftIO $ putStrLn ("meta info of: " ++ show (ecuModNm ecu) ++ ", file: " ++ n ++ ", exists: " ++ show nExists)
                          })
               ; when nExists
                      (do { t <- liftIO $ fpathGetModificationTime fp
                          ; when (ehcOptVerbosity opts >= VerboseDebug)
                                 (do { liftIO $ putStrLn ("time stamp of: " ++ show (ecuModNm ecu) ++ ", time: " ++ show t)
                                     })
                          ; cpUpdCU modNm $ store t
                          })
               }
        wr opts ecu store fp
          = do { pm <- liftIO $ getPermissions (maybe "." id $ fpathMbDir fp)
               -- ; liftIO $ putStrLn (fpathToStr fp ++ " writ " ++ show (writable pm))
               ; cpUpdCU modNm $ store (writable pm)
               }

{-# LINE 270 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpGetDummyCheckSrcMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpGetDummyCheckSrcMod modNm
  = do { cr <- get
       ; let crsi   = crStateInfo cr
             mm     = crsiModMp crsi
             mod    = Mod modNm Nothing Nothing [] Rel.empty Rel.empty []
       ; cpUpdCU modNm (ecuStoreMod mod)
       ; cpUpdSI (\crsi -> crsi {crsiModMp = Map.insert modNm emptyModMpInfo mm})
       }

{-# LINE 286 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpUpdateModOffMp :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpUpdateModOffMp modNmL@(modNm:_)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug "cpUpdateModOffMp"
       ; let crsi   = crStateInfo cr
             offMp  = crsiModOffMp crsi
             (offMp',_)
                    = foldr add (offMp, Map.size offMp) modNmL
                    where add modNm (offMp, offset)
                            = case Map.lookup modNm offMp of
                                Just (o,_) -> (Map.insert modNm (o, new) offMp, offset )
                                _          -> (Map.insert modNm (o, new) offMp, offset')
                                           where (o, offset') = refGen1 offset 1 modNm
                            where new = crsiExpNmOffMp modNm crsi
       ; cpUpdSI (\crsi -> crsi {crsiModOffMp = offMp'})
       }

{-# LINE 309 "src/ehc/EHC/CompilePhase/Module.chs" #-}
-- | Compute imported module names
cpGenImpNmInfo :: EHCCompileRunner m => HsName -> EHCompilePhaseT m [HsName]
cpGenImpNmInfo modNm
  = do { cr <- get
       ; let (ecu,crsi,opts,fp) = crBaseInfo modNm cr
             isWholeProg = ehcOptOptimizationScope opts > OptimizationScope_PerModule
             impNmL     | isWholeProg = []
                        | otherwise   = ecuImpNmL ecu
       ; return impNmL
       }

{-# LINE 326 "src/ehc/EHC/CompilePhase/Module.chs" #-}
cpUpdHiddenExports :: EHCCompileRunner m => HsName -> [(HsName,IdOccKind)] -> EHCompilePhaseT m ()
cpUpdHiddenExports modNm exps
  = when (not $ null exps)
         (do { cpUpdSI (\crsi -> crsi { crsiModMp = modMpAddHiddenExps modNm exps $ crsiModMp crsi
                                      })
             ; cpUpdateModOffMp [modNm]
             })


</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.CompilePhase.Module
( cpCheckModsModWith
, cpCheckModsWithOrWithoutBuiltin
, cpCheckModsWithBuiltin
, cpCheckModsWithoutBuiltin
, GetMeta (..), allGetMeta
, cpGetCoreRunModnameAndImports
, cpGetCoreModnameAndImports
, cpGetHsModnameAndImports, cpGetHsMod, cpGetMetaInfo
, cpGetDummyCheckSrcMod
, cpUpdateModOffMp
, cpGenImpNmInfo
, cpUpdHiddenExports )
where
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified UHC.Util.Rel as Rel
import UHC.Util.Time
import UHC.Util.FPath
import System.Directory
import Control.Monad.State
import UHC.Light.Compiler.Base.Optimize
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.Module.ImportExport
import qualified UHC.Light.Compiler.Config as Cfg
import qualified UHC.Light.Compiler.HS.ModImpExp as HSSemMod
import qualified UHC.Light.Compiler.Core.Check as Core2ChkSem
import qualified UHC.Light.Compiler.CoreRun.Check as CoreRun2ChkSem
import UHC.Light.Compiler.CodeGen.RefGenerator
import UHC.Light.Compiler.Base.Debug






















-- | Check module dependencies for given 'Mod'
cpCheckModsModWith :: EHCCompileRunner m => (HsName -> ModMpInfo) -> [Mod] -> EHCompilePhaseT m ()
cpCheckModsModWith dfltMod modL@(Mod {modName = modNm} : _)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug $ "cpCheckModsModWith modL: " ++ show modL
       ; let crsi   = crStateInfo cr
             (mm,e) = modMpCombine' dfltMod modL (crsiModMp crsi)
       ; cpUpdSI (\crsi -> crsi {crsiModMp = mm})
       ; cpSetLimitErrsWhen 5 "Module analysis" e
       }










cpCheckModsWithOrWithoutBuiltin :: EHCCompileRunner m => Bool -> [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithOrWithoutBuiltin bltin modNmL@(modNm:_)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug $ "cpCheckModsWithOrWithoutBuiltin modNmL: " ++ show modNmL
       ; let modL   = [ addBuiltin $ ecuMod $ crCU n cr | n <- modNmL ]
       ; cpCheckModsModWith (\n -> panic $ "cpCheckModsWithOrWithoutBuiltin: " ++ show n) modL
       }
  where addBuiltin | bltin     = \m -> m { modImpL = modImpBuiltin : modImpL m }
                   | otherwise = id



cpCheckModsWithBuiltin :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithBuiltin = cpCheckModsWithOrWithoutBuiltin True
{-# INLINE cpCheckModsWithBuiltin #-}



cpCheckModsWithoutBuiltin :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpCheckModsWithoutBuiltin = cpCheckModsWithOrWithoutBuiltin False
{-# INLINE cpCheckModsWithoutBuiltin #-}







data GetMeta
  = GetMeta_Src
  | GetMeta_HI
  | GetMeta_Core
  | GetMeta_CoreRun
  | GetMeta_Dir
  deriving (Eq,Ord)

allGetMeta
  = [ GetMeta_Src
    , GetMeta_HI
    , GetMeta_Core
    , GetMeta_CoreRun
    , GetMeta_Dir
    ]














cpGetCoreRunModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetCoreRunModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbCrSemMod = ecuMbCoreRunSemMod ecu
                 crSemMod   = panicJust "cpGetCoreRunModnameAndImports" mbCrSemMod
                 modNm'     = CoreRun2ChkSem.realModuleNm_Syn_AGItf crSemMod
         ;  cpMsg modNm VerboseDebug $ "cpGetCoreRunModnameAndImports: " ++ show modNm ++ " -> " ++ show modNm'
         ;  case mbCrSemMod of
              Just _ -> cpUpdCUWithKey modNm $ \_ ecu ->
                          ( modNm'
                          , ecuStoreHSDeclImpS (Set.fromList $ CoreRun2ChkSem.impModNmL_Syn_AGItf crSemMod )
                            $ cuUpdKey modNm' ecu
                          )
              _      -> return modNm
         }



cpGetCoreModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetCoreModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbCrSemMod = ecuMbCoreSemMod ecu
                 crSemMod   = panicJust "cpGetCoreModnameAndImports" mbCrSemMod
                 modNm'     = Core2ChkSem.realModuleNm_Syn_CodeAGItf crSemMod
         ;  cpMsg modNm VerboseDebug $ "cpGetCoreModnameAndImports: " ++ show modNm ++ " -> " ++ show modNm'
         ;  case mbCrSemMod of
              Just _ -> cpUpdCUWithKey modNm $ \_ ecu ->
                          ( modNm'
                          , ecuStoreHSDeclImpS (Set.fromList $ Core2ChkSem.impModNmL_Syn_CodeAGItf crSemMod )
                            $ cuUpdKey modNm' ecu
                          )
              _      -> return modNm
         }



cpGetHsModnameAndImports :: EHCCompileRunner m => HsName -> EHCompilePhaseT m HsName
cpGetHsModnameAndImports modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbHsSemMod = ecuMbHSSemMod ecu
                 hsSemMod   = panicJust "cpGetHsModnameAndImports" mbHsSemMod
                 modNm'     = HSSemMod.realModuleNm_Syn_AGItf hsSemMod
                 upd        = ecuStoreHSDeclImpS ( -- (\v -> tr "XX" (pp $ Set.toList v) v) $
                                                  HSSemMod.modImpNmS_Syn_AGItf hsSemMod)
         ;  case mbHsSemMod of
              Just _ | ecuIsTopMod ecu -> cpUpdCUWithKey modNm (\_ ecu -> (modNm', upd $ cuUpdKey modNm' ecu))
                     | otherwise       -> do { cpUpdCU modNm upd ; return modNm }
              _      -> return modNm
         }

cpGetHsMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpGetHsMod modNm
  =  do  {  cr <- get
         ;  let  (ecu,_,opts,_) = crBaseInfo modNm cr
                 mbHsSemMod = ecuMbHSSemMod ecu
                 hsSemMod   = panicJust "cpGetHsMod" mbHsSemMod
                 mod        = HSSemMod.mod_Syn_AGItf hsSemMod
         ;  when (ehcOptVerbosity opts >= VerboseDebug)
                 (do { cpMsg modNm VerboseDebug "cpGetHsMod"
                     ; liftIO $ putWidthPPLn 120 (pp mod)
                     })
         ;  when (isJust mbHsSemMod)
                 (cpUpdCU modNm (ecuStoreMod mod))
         }

cpGetMetaInfo :: EHCCompileRunner m => [GetMeta] -> HsName -> EHCompilePhaseT m ()
cpGetMetaInfo gm modNm
  =  do  {  cr <- get
         ;  let (ecu,_,opts,fp) = crBaseInfo modNm cr
         ;  when (GetMeta_Src `elem` gm)
                 (tm opts ecu ecuStoreSrcTime        (ecuSrcFilePath ecu))
         {-
         ;  when (GetMeta_HI `elem` gm)
                 (tm opts ecu ecuStoreHITime
                                              (mkInOrOutputFPathFor (InputFrom_Loc $ ecuFileLocation ecu) opts modNm fp "hi")
                 )
         -}
         ;  when (GetMeta_HI `elem` gm)
                 (tm opts ecu ecuStoreHIInfoTime
                                              (mkInOrOutputFPathFor (InputFrom_Loc $ ecuFileLocation ecu) opts modNm fp "hi")
                 )
         ;  when (GetMeta_Core `elem` gm)
                 (tm opts ecu ecuStoreCoreTime      (fpathSetSuff Cfg.suffixDotlessBinaryCore fp))
         ;  when (GetMeta_CoreRun `elem` gm)
                 (tm opts ecu ecuStoreCoreRunTime   (fpathSetSuff Cfg.suffixDotlessBinaryCoreRun fp))
         ;  when (GetMeta_Dir `elem` gm)
                 (wr opts ecu ecuStoreDirIsWritable (                         fp     ))
         }
  where tm :: EHCCompileRunner m => EHCOpts -> EHCompileUnit -> (ClockTime -> EHCompileUnit -> EHCompileUnit) -> FPath -> EHCompilePhaseT m ()
        tm opts ecu store fp
          = do { let n = fpathToStr fp
               ; nExists <- liftIO $ doesFileExist n
               ; when (ehcOptVerbosity opts >= VerboseDebug)
                      (do { liftIO $ putStrLn ("meta info of: " ++ show (ecuModNm ecu) ++ ", file: " ++ n ++ ", exists: " ++ show nExists)
                          })
               ; when nExists
                      (do { t <- liftIO $ fpathGetModificationTime fp
                          ; when (ehcOptVerbosity opts >= VerboseDebug)
                                 (do { liftIO $ putStrLn ("time stamp of: " ++ show (ecuModNm ecu) ++ ", time: " ++ show t)
                                     })
                          ; cpUpdCU modNm $ store t
                          })
               }
        wr opts ecu store fp
          = do { pm <- liftIO $ getPermissions (maybe "." id $ fpathMbDir fp)
               -- ; liftIO $ putStrLn (fpathToStr fp ++ " writ " ++ show (writable pm))
               ; cpUpdCU modNm $ store (writable pm)
               }



























cpGetDummyCheckSrcMod :: EHCCompileRunner m => HsName -> EHCompilePhaseT m ()
cpGetDummyCheckSrcMod modNm
  = do { cr <- get
       ; let crsi   = crStateInfo cr
             mm     = crsiModMp crsi
             mod    = Mod modNm Nothing Nothing [] Rel.empty Rel.empty []
       ; cpUpdCU modNm (ecuStoreMod mod)
       ; cpUpdSI (\crsi -> crsi {crsiModMp = Map.insert modNm emptyModMpInfo mm})
       }







cpUpdateModOffMp :: EHCCompileRunner m => [HsName] -> EHCompilePhaseT m ()
cpUpdateModOffMp modNmL@(modNm:_)
  = do { cr <- get
       ; cpMsg modNm VerboseDebug "cpUpdateModOffMp"
       ; let crsi   = crStateInfo cr
             offMp  = crsiModOffMp crsi
             (offMp',_)
                    = foldr add (offMp, Map.size offMp) modNmL
                    where add modNm (offMp, offset)
                            = case Map.lookup modNm offMp of
                                Just (o,_) -> (Map.insert modNm (o, new) offMp, offset )
                                _          -> (Map.insert modNm (o, new) offMp, offset')
                                           where (o, offset') = refGen1 offset 1 modNm
                            where new = crsiExpNmOffMp modNm crsi
       ; cpUpdSI (\crsi -> crsi {crsiModOffMp = offMp'})
       }







-- | Compute imported module names
cpGenImpNmInfo :: EHCCompileRunner m => HsName -> EHCompilePhaseT m [HsName]
cpGenImpNmInfo modNm
  = do { cr <- get
       ; let (ecu,crsi,opts,fp) = crBaseInfo modNm cr
             isWholeProg = ehcOptOptimizationScope opts > OptimizationScope_PerModule
             impNmL     | isWholeProg = []
                        | otherwise   = ecuImpNmL ecu
       ; return impNmL
       }







cpUpdHiddenExports :: EHCCompileRunner m => HsName -> [(HsName,IdOccKind)] -> EHCompilePhaseT m ()
cpUpdHiddenExports modNm exps
  = when (not $ null exps)
         (do { cpUpdSI (\crsi -> crsi { crsiModMp = modMpAddHiddenExps modNm exps $ crsiModMp crsi
                                      })
             ; cpUpdateModOffMp [modNm]
             })



</pre>