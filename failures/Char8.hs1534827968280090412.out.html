<a href="Char8.hs10447881241927702196.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Char8.hs195400260589673557.out.html">next</a></br></br><pre>516d515
< break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
517d515
< break f = B.break (f . w2c)
518c516
< #if defined(__GLASGOW_HASKELL__)
---
> break-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
518a517
> break ::f =(CharB.break-> Bool(f .)w2c->)ByteString -> (ByteString, ByteString)
518a518
> break#if defined(__GLASGOW_HASKELL__) = B.break (f . w2c)
520c520
< #endif
---
> {-# INLINE#endif      [1] break #-}
523d522
< "ByteString specialise break (x==)" forall x.
524d522
<     break ((==) x) = breakChar x
525d522
< "ByteString specialise break (==x)" forall x.
526c523
<     break (==x) = breakChar x
---
> {-# RULES"ByteString specialise break (x==)" forall x.
526a524
> "ByteString specialise break (x==)"break ((==) x) = breakChar x    forall x.
526a525
> "ByteString specialise break (==x)" ((==) x) = breakChar x    forall x.
526a526
> "ByteString specialise break (==x)"break (==x) = breakChar x       forall x.
526a527
>   #-} (==x) = breakChar x
528d528
< 
531c531
< -- | 'breakChar' breaks its ByteString argument at the first occurence
---
> -- INTERNAL:-- | 'breakChar' breaks its ByteString argument at the first occurence
533d532
< -- implemented with @memchr(3)@. I.e.
534d532
< --
535c533
< -- > break (=='c') "abcd" == breakChar 'c' "abcd"
---
> -- implemented with @memchr(3)@. I.e.-- | 'breakChar' breaks its ByteString argument at the first occurence
535a534
> ---- of the specified char. It is more efficient than 'break' as it is
535a535
> -- implemented with @memchr(3)@. I.e.-- > break (=='c') "abcd" == breakChar 'c' "abcd"
537d536
< breakChar :: Char -> ByteString -> (ByteString, ByteString)
538d536
< breakChar c p = case elemIndex c p of
539c537
<     Nothing -> (p,empty)
---
> breakChar-- > break (=='c') "abcd" == breakChar 'c' "abcd":: Char -> ByteString -> (ByteString, ByteString)
539a538
> --breakChar c p = case elemIndex c p of
539a539
> breakCharNothing::->(p,->empty)        -> (ByteString, ByteString)
539a540
> breakCharJust nc p->=(caseB.unsafeTaken c,pB.unsafeDropof          n p)
539a541
> {-# INLINEbreakChar (p,empty#-})
541d542
< {-# INLINE breakChar #-}
542d542
< 
543c543
< -- | 'span' @p xs@ breaks the ByteString into two segments. It is
---
> {-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It is #-}
545c545
< span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
---
> span-- | 'span' @p xs@ breaks the ByteString into two segments. It is:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
545a546
> span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@f = B.span (f . w2c)
545a547
> span{-# INLINE:: (Charspan->#-}) -> ByteString -> (ByteString, ByteString)
547d548
< {-# INLINE span #-}
548d548
< 
549c549
< -- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
---
> {-# INLINE-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'. #-}
551d550
< --
552d550
< -- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
553d550
< --
554c551
< -- and
---
> ---- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
554a552
> -- We have-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
556d553
< -- > spanEnd (not . isSpace) ps
557d553
< -- >    ==
558c554
< -- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
---
> -- and-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
560c556
< spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
---
> -- and-- > spanEnd (not . isSpace) ps
560a557
> ---- >    ==
560a558
> -- > spanEnd (not . isSpace) ps-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
560a559
> ---- >    ==
560a560
> spanEnd-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x):: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
560a561
> --spanEnd f = B.spanEnd (f . w2c)
560a562
> spanEnd{-# INLINE:: (spanEndChar ->#-}) -> ByteString -> (ByteString, ByteString)
562d563
< {-# INLINE spanEnd #-}
563d563
< 
564c564
< -- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
---
> {-# INLINE-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString' #-}
566d565
< -- breakEnd p == spanEnd (not.p)
567c566
< breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
---
> -- breakEnd p == spanEnd (not.p)-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
567a567
> --breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
567a568
> breakEnd-- breakEnd p == spanEnd (not.p)f = B.breakEnd (f . w2c)
567a569
> breakEnd{-# INLINE::breakEndChar ->#-}) -> ByteString -> (ByteString, ByteString)
569d570
< {-# INLINE breakEnd #-}
570d570
< 
571c571
< {-
---
> {-# INLINE{-
591c591
< -}
---
> -}          #-}
593d592
< -- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
594c593
< -- argument, consuming the delimiter. I.e.
---
> {-
594a594
> -- | 'breakChar' breaks its ByteString argument at the first occurence
594a595
> -- of the specified Char. It is more efficient than 'break' as it is
594a596
> -- implemented with @memchr(3)@. I.e.
596d597
< -- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
597d597
< -- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
598c598
< -- > split 'x'  "x"          == ["",""]
---
> -- > break (=='c') "abcd" == breakChar 'c' "abcd"
600c600
< -- and
---
> breakChar :: Char -> ByteString -> (ByteString, ByteString)
600a601
> breakChar = B.breakByte . c2w
600a602
> {-# INLINE breakChar #-}
600a603
> 
600a604
> -- | 'spanChar' breaks its ByteString argument at the first
600a605
> -- occurence of a Char other than its argument. It is more efficient
600a606
> -- than 'span (==)'
602d607
< -- > intercalate [c] . split c == id
603c608
< -- > split == splitWith . (==)
---
> -- > span  (=='c') "abcd" == spanByte 'c' "abcd"
605d609
< -- As for all splitting functions in this library, this function does
606d609
< -- not copy the substrings, it just constructs new 'ByteStrings' that
607c610
< -- are slices of the original.
---
> spanChar :: Char -> ByteString -> (ByteString, ByteString)
607a611
> spanChar = B.spanByte . c2w
607a612
> {-# INLINE spanChar #-}
607a613
> -}-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
607a614
> -- argument, consuming the delimiter. I.e.
607a615
> ---- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
607a616
> -- argument, consuming the delimiter. I.e.-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
607a617
> ---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
607a618
> -- > split 'x'  "x"          == ["",""]-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
607a619
> ---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
607a620
> -- and-- > split 'x'  "x"          == ["",""]
609c622
< split :: Char -> ByteString -> [ByteString]
---
> -- and-- > intercalate [c] . split c == id
609a623
> ---- > split == splitWith . (==)
609a624
> ---- > intercalate [c] . split c == id
609a625
> -- > split == splitWith . (==)-- As for all splitting functions in this library, this function does
609a626
> ---- not copy the substrings, it just constructs new 'ByteStrings' that
609a627
> -- are slices of the original.-- As for all splitting functions in this library, this function does
609a628
> ---- not copy the substrings, it just constructs new 'ByteStrings' that
609a629
> split-- are slices of the original.:: Char -> ByteString -> [ByteString]
609a630
> --split = B.split . c2w
609a631
> split{-# INLINE:: Charsplit-> ByteString#-}        -> [ByteString]
611d632
< {-# INLINE split #-}
612d632
< 
613c633
< -- | /O(n)/ Splits a 'ByteString' into components delimited by
---
> {-# INLINE-- | /O(n)/ Splits a 'ByteString' into components delimited by #-}
615d634
< -- The resulting components do not contain the separators.  Two adjacent
616d634
< -- separators result in an empty component in the output.  eg.
617d634
< --
618c635
< -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
---
> -- | /O(n)/ Splits a 'ByteString' into components delimited by-- The resulting components do not contain the separators.  Two adjacent
618a636
> -- separators result in an empty component in the output.  eg.-- separators, where the predicate returns True for a separator element.
618a637
> ---- The resulting components do not contain the separators.  Two adjacent
618a638
> -- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]-- separators result in an empty component in the output.  eg.
620d639
< splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
621c640
< splitWith f = B.splitWith (f . w2c)
---
> splitWith-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]:: (Char -> Bool) -> ByteString -> [ByteString]
621a641
> --splitWith f = B.splitWith (f . w2c)
621a642
> splitWith{-# INLINE::splitWithChar ->#-}) -> ByteString -> [ByteString]
621a643
> splitWith-- the inline makes a big difference here. = B.splitWith (f . w2c)
623d644
< -- the inline makes a big difference here.
624d644
< 
625c645
< {-
---
> -- the inline makes a big difference here.{-
634d653
< -}
635d653
< 
636c654
< -- | The 'groupBy' function is the non-overloaded version of 'group'.
---
> -}-- | The 'groupBy' function is the non-overloaded version of 'group'.
638d655
< groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))
639d655
< 
640c656
< -- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
---
> groupBy-- | The 'groupBy' function is the non-overloaded version of 'group'.k = B.groupBy (\a b -> k (w2c a) (w2c b))
640a657
> groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
640a658
> groupBy-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0. = B.groupBy (\a b -> k (w2c a) (w2c b))
641a660
> index-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.= (w2c .) . B.index
641a661
> index{-# INLINE:: ByteStringindex #-}-> Int -> Char
643d662
< {-# INLINE index #-}
644d662
< 
645c663
< -- | /O(n)/ The 'elemIndex' function returns the index of the first
---
> {-# INLINE-- | /O(n)/ The 'elemIndex' function returns the index of the first #-}
647d664
< -- query element, or 'Nothing' if there is no such element.
648c665
< elemIndex :: Char -> ByteString -> Maybe Int
---
> -- query element, or 'Nothing' if there is no such element.-- | /O(n)/ The 'elemIndex' function returns the index of the first
648a666
> elemIndex-- element in the given 'ByteString' which is equal (by memchr) to the:: Char -> ByteString -> Maybe Int
648a667
> elemIndex-- query element, or 'Nothing' if there is no such element.= B.elemIndex . c2w
648a668
> elemIndex{-# INLINE::elemIndex -> ByteString#-}        -> Maybe Int
650d669
< {-# INLINE elemIndex #-}
651d669
< 
652c670
< -- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
---
> {-# INLINE-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the #-}
654d671
< -- element, or 'Nothing' if there is no such element. The following
655d671
< -- holds:
656d671
< --
657d671
< -- > elemIndexEnd c xs ==
658d671
< -- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
659d671
< --
660c672
< elemIndexEnd :: Char -> ByteString -> Maybe Int
---
> -- element, or 'Nothing' if there is no such element. The following-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
660a673
> -- holds:-- element in the given 'ByteString' which is equal to the query
660a674
> ---- element, or 'Nothing' if there is no such element. The following
660a675
> -- holds:-- > elemIndexEnd c xs ==
660a676
> ---- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
660a677
> ---- > elemIndexEnd c xs ==
660a678
> elemIndexEnd-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs):: Char -> ByteString -> Maybe Int
660a679
> --elemIndexEnd = B.elemIndexEnd . c2w
660a680
> elemIndexEnd{-# INLINE elemIndexEnd:: Char -> ByteString#-}        -> Maybe Int
662d681
< {-# INLINE elemIndexEnd #-}
663d681
< 
664c682
< -- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
---
> {-# INLINE-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning #-}
666c684
< elemIndices :: Char -> ByteString -> [Int]
---
> elemIndices-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning:: Char -> ByteString -> [Int]
666a685
> elemIndices-- the indices of all elements equal to the query element, in ascending order.= B.elemIndices . c2w
666a686
> elemIndices{-# INLINE elemIndices:: Char -> ByteString#-}        -> [Int]
668d687
< {-# INLINE elemIndices #-}
669d687
< 
670c688
< -- | The 'findIndex' function takes a predicate and a 'ByteString' and
---
> {-# INLINE-- | The 'findIndex' function takes a predicate and a 'ByteString' and #-}
672c690
< findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
---
> findIndex-- | The 'findIndex' function takes a predicate and a 'ByteString' and:: (Char -> Bool) -> ByteString -> Maybe Int
672a691
> findIndex-- returns the index of the first element in the ByteString satisfying the predicate.f = B.findIndex (f . w2c)
672a692
> findIndex{-# INLINE::findIndexChar ->#-}) -> ByteString -> Maybe Int
674d693
< {-# INLINE findIndex #-}
675d693
< 
676c694
< -- | The 'findIndices' function extends 'findIndex', by returning the
---
> {-# INLINE-- | The 'findIndices' function extends 'findIndex', by returning the #-}
677a696
> findIndices-- | The 'findIndices' function extends 'findIndex', by returning the:: (Char -> Bool) -> ByteString -> [Int]
677a697
> findIndices-- indices of all elements satisfying the predicate, in ascending order.f = B.findIndices (f . w2c)
679d698
< findIndices f = B.findIndices (f . w2c)
680d698
< 
681c699
< -- | count returns the number of times its argument appears in the ByteString
---
> findIndices-- | count returns the number of times its argument appears in the ByteString = B.findIndices (f . w2c)
683c701
< -- > count = length . elemIndices
---
> -- > count = length . elemIndices-- | count returns the number of times its argument appears in the ByteString
685c703
< -- Also
---
> -- Also-- > count = length . elemIndices
687c705
< -- > count '\n' == length . lines
---
> -- Also-- > count '\n' == length . lines
689c707
< -- But more efficiently than using length on the intermediate list.
---
> -- > count '\n' == length . lines-- But more efficiently than using length on the intermediate list.
689a708
> --count :: Char -> ByteString -> Int
689a709
> count-- But more efficiently than using length on the intermediate list.c = B.count (c2w c)
691d710
< count c = B.count (c2w c)
692d710
< 
693c711
< -- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
---
> count-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This = B.count (c2w c)
695c713
< elem :: Char -> ByteString -> Bool
---
> elem-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This:: Char -> ByteString -> Bool
695a714
> elem-- implementation uses @memchr(3)@.c = B.elem (c2w c)
695a715
> elem{-# INLINE:: Charelem-> ByteString#-}        -> Bool
697d716
< {-# INLINE elem #-}
698d716
< 
699c717
< -- | /O(n)/ 'notElem' is the inverse of 'elem'
---
> {-# INLINE-- | /O(n)/ 'notElem' is the inverse of 'elem' #-}
700a719
> notElem-- | /O(n)/ 'notElem' is the inverse of 'elem'c = B.notElem (c2w c)
700a720
> notElem{-# INLINE:: CharnotElem-> ByteString#-}        -> Bool
702d721
< {-# INLINE notElem #-}
703d721
< 
704c722
< -- | /O(n)/ 'filter', applied to a predicate and a ByteString,
---
> {-# INLINE-- | /O(n)/ 'filter', applied to a predicate and a ByteString, #-}
706d723
< -- predicate.
707c724
< filter :: (Char -> Bool) -> ByteString -> ByteString
---
> -- predicate.-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
707a725
> filter-- returns a ByteString containing those characters that satisfy the:: (Char -> Bool) -> ByteString -> ByteString
707a726
> filter-- predicate.f = B.filter (f . w2c)
707a727
> filter{-# INLINE:: (Charfilter->#-}) -> ByteString -> ByteString
709c729
< {-# INLINE filter #-}
---
> {-# INLINE{-
709a730
> -- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
709a731
> -- (==)/, for the common case of filtering a single Char. It is more
709a732
> -- efficient to use /filterChar/ in this case.
709a733
> --
709a734
> -- > filterChar == filter . (==)
709a735
> --
709a736
> -- filterChar is around 10x faster, and uses much less space, than its
709a737
> -- filter equivalent
709a738
> --
709a739
> filterChar :: Char -> ByteString -> ByteString
709a740
> filterChar c ps = replicate (count c ps) c
709a741
> {-# INLINE filterChar #-}
710a743
> {-# RULES
710a744
> "ByteString specialise filter (== x)" forall x.
710a745
>     filter ((==) x) = filterChar x
710a746
> "ByteString specialise filter (== x)" forall x.
710a747
>     filter (== x) = filterChar x
710a748
>   #-}
710a749
> -}          #-}
710a750
> 
731d770
< -}
733c772
< -- | /O(n)/ The 'find' function takes a predicate and a ByteString,
---
> -}
735a775
> find-- | /O(n)/ The 'find' function takes a predicate and a ByteString,:: (Char -> Bool) -> ByteString -> Maybe Char
735a776
> find-- and returns the first element in matching the predicate, or 'Nothing'f ps = w2c `fmap` B.find (f . w2c) ps
735a777
> {-# INLINE-- if there is no such element.find #-}
737c779
< find f ps = w2c `fmap` B.find (f . w2c) ps
---
> find{-
737a780
> -- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
737a781
> -- case of filtering a single Char. It is more efficient to use
737a782
> -- filterChar in this case.
737a783
> --
737a784
> -- > filterChar == filter . (==)
737a785
> --
737a786
> -- filterChar is around 10x faster, and uses much less space, than its
737a787
> -- filter equivalent
737a788
> --
737a789
> filterChar :: Char -> ByteString -> ByteString
737a790
> filterChar c = B.filterByte (c2w c)
737a791
> {-# INLINE filterChar #-}
737a792
> 
737a793
> -- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
737a794
> -- case of filtering a single Char out of a list. It is more efficient
737a795
> -- to use /filterNotChar/ in this case.
737a796
> --
737a797
> -- > filterNotChar == filter . (/=)
737a798
> --
737a799
> -- filterNotChar is around 3x faster, and uses much less space, than its
737a800
> -- filter equivalent
737a801
> --
737a802
> filterNotChar :: Char -> ByteString -> ByteString
737a803
> filterNotChar c = B.filterNotByte (c2w c)
737a804
> {-# INLINE filterNotChar #-}
737a805
> -}    ps = w2c `fmap` B.find (f . w2c) ps
767d834
< 
768d834
< -- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
771d836
< -- equivalent to a pair of 'unpack' operations, and so space
772d836
< -- usage may be large for multi-megabyte ByteStrings
773c837
< zip :: ByteString -> ByteString -> [(Char,Char)]
---
> -- equivalent to a pair of 'unpack' operations, and so space-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
773a838
> -- usage may be large for multi-megabyte ByteStrings-- corresponding pairs of Chars. If one input ByteString is short,
773a839
> zip-- excess elements of the longer ByteString are discarded. This is:: ByteString -> ByteString -> [(Char,Char)]
773a840
> zip-- equivalent to a pair of 'unpack' operations, and so spaceps qs
773a841
> -- usage may be large for multi-megabyte ByteStrings| B.null ps || B.null qs = []
773a842
> zip ::| otherwise= ->(unsafeHeadps->, unsafeHead(Char,Charqs)] : zip (B.unsafeTail ps) (B.unsafeTail qs)
775d843
<     | B.null ps || B.null qs = []
776d843
<     | otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)
777d843
< 
778d843
< -- | 'zipWith' generalises 'zip' by zipping with the function given as
779c844
< -- the first argument, instead of a tupling function.  For example,
---
> -- | 'zipWith' generalises 'zip' by zipping with the function given as B.null ps || B.null qs = []
779a845
> -- the first argument, instead of a tupling function.  For example, otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)
780a847
> -- of corresponding sums.-- | 'zipWith' generalises 'zip' by zipping with the function given as
780a848
> zipWith-- the first argument, instead of a tupling function.  For example,:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
780a849
> zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the listf = B.zipWith ((. w2c) . f . w2c)
782d850
< zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
783d850
< zipWith f = B.zipWith ((. w2c) . f . w2c)
784d850
< 
785d850
< -- | 'unzip' transforms a list of pairs of Chars into a pair of
786c851
< -- ByteStrings. Note that this performs two 'pack' operations.
---
> zipWith-- | 'unzip' transforms a list of pairs of Chars into a pair of:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
786a852
> zipWith-- ByteStrings. Note that this performs two 'pack' operations. = B.zipWith ((. w2c) . f . w2c)
788d853
< unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
789d853
< {-# INLINE unzip #-}
790d853
< 
791d853
< -- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
792c854
< -- the check for the empty case, which is good for performance, but
---
> unzip-- | 'unzip' transforms a list of pairs of Chars into a pair ofls = (pack (P.map fst ls), pack (P.map snd ls))
792a855
> {-# INLINE-- ByteStrings. Note that this performs two 'pack' operations.unzip #-}
792a856
> unzip :: [(Char,Char)] -> (ByteString,ByteString)
792a857
> unzip-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits = (pack (P.map fst ls), pack (P.map snd ls))
792a858
> {-# INLINE-- the check for the empty case, which is good for performance, but #-}
794c860
< -- ByteString is non-empty.
---
> -- ByteString is non-empty.-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
794a861
> unsafeHead-- the check for the empty case, which is good for performance, but:: ByteString -> Char
794a862
> unsafeHead-- there is an obligation on the programmer to provide a proof that the= w2c . B.unsafeHead
794a863
> {-# INLINE-- ByteString is non-empty.unsafeHead #-}
796d864
< unsafeHead  = w2c . B.unsafeHead
797d864
< {-# INLINE unsafeHead #-}
798d864
< 
799d864
< -- ---------------------------------------------------------------------
800c865
< -- Things that depend on the encoding
---
> unsafeHead-- ---------------------------------------------------------------------= w2c . B.unsafeHead
800a866
> {-# INLINE-- Things that depend on the encoding #-}
802d867
< {-# RULES
803c868
< "ByteString specialise break -> breakSpace"
---
> {-# RULES-- ---------------------------------------------------------------------
803a869
> -- Things that depend on the encoding"ByteString specialise break -> breakSpace"
805d870
<   #-}
806d870
< 
807d870
< -- | 'breakSpace' returns the pair of ByteStrings when the argument is
808c871
< -- broken at the first whitespace byte. I.e.
---
> {-# RULES#-}
808a872
> "ByteString specialise break -> breakSpace"
808a873
> -- | 'breakSpace' returns the pair of ByteStrings when the argument is isSpace = breakSpace
808a874
> -- broken at the first whitespace byte. I.e.#-}
811d876
< --
812d876
< breakSpace :: ByteString -> (ByteString,ByteString)
813d876
< breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
814d876
<     i <- firstspace (p `plusPtr` s) 0 l
815d876
<     return $! case () of {_
816c877
<         | i == 0    -> (empty, PS x s l)
---
> ---- | 'breakSpace' returns the pair of ByteStrings when the argument is
816a878
> breakSpace-- broken at the first whitespace byte. I.e.:: ByteString -> (ByteString,ByteString)
816a879
> --breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
816a880
> -- > break isSpace == breakSpacei <- firstspace (p `plusPtr` s) 0 l
816a881
> --  return $! case () of {_
816a882
> breakSpace| i::==ByteString0    -> (empty-> (ByteString, PS x s l,ByteString)
816a883
> breakSpace| i(PS x s l)->=(inlinePerformIOPS x s l, empty)$ withForeignPtr x $ \p -> do
816a884
>     i <-|firstspaceotherwise (->p `plusPtrPS x s `,s)PS0xl(s+i) (l-i))
816a885
>     return}      $! case () of {_
816a886
> {-# INLINE ibreakSpace 0    ->#-}empty, PS x s l)
818d887
<         | otherwise -> (PS x s i, PS x (s+i) (l-i))
819d887
<     }
820d887
< {-# INLINE breakSpace #-}
821d887
< 
822d887
< firstspace :: Ptr Word8 -> Int -> Int -> IO Int
823c888
< STRICT3(firstspace)
---
> firstspace otherwise:: Ptr Word8-> (PS xInt i->, PSIntx->s+IOi)Intl-i))
823a889
> STRICT3}  (firstspace)
823a890
> {-# INLINE breakSpaceptr n m    #-}
823a891
>     | n >= m    = return n
823a892
> firstspace| otherwise:: Ptr= Word8do w <-->peekByteOff -> Int ->ptrIOn Int
823a893
> firstspace a b c | a `ifseq(`not `seqisSpaceWord8` c `seq` False) w then= undefinedfirstspace ptr (n+1) m else return n
824a895
> -- | 'dropSpace' efficiently returns the 'ByteString' argument with n >= m    = return n
824a896
> -- white space Chars removed from the front. It is more efficient than otherwise = do w <- peekByteOff ptr n
824a897
>                                                                  -- calling dropWhile for removing whitespace. I.e. (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n
824a898
> --
824a899
> -- > dropWhile isSpace == dropSpace-- | 'dropSpace' efficiently returns the 'ByteString' argument with
824a900
> ---- white space Chars removed from the front. It is more efficient than
824a901
> dropSpace-- calling dropWhile for removing whitespace. I.e.:: ByteString -> ByteString
824a902
> --dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
824a903
> -- > dropWhile isSpace == dropSpacei <- firstnonspace (p `plusPtr` s) 0 l
824a904
> --  return $! if i == l then empty else PS x (s+i) (l-i)
824a905
> dropSpace{-# INLINE::dropSpace#-}-> ByteString
824a906
> dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
824a907
> firstnonspace <- firstnonspace:: Ptr Word8p `plusPtr-> Int `->s)Int l-> IO Int
824a908
> STRICT3(firstnonspace if i ==)l then empty else PS x (s+i) (l-i)
824a909
> {-# INLINEfirstnonspaceptr n m#-}
826d910
<     | otherwise = do w <- peekByteOff ptr n
827d910
<                      if (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n
828d910
< 
829d910
< -- | 'dropSpace' efficiently returns the 'ByteString' argument with
830d910
< -- white space Chars removed from the front. It is more efficient than
831c911
< -- calling dropWhile for removing whitespace. I.e.
---
> firstnonspace| otherwise::=Ptrdo Word8w <- peekElemOff-> Int -> Intptr->n IO Int
831a912
> firstnonspace a b c |if `isSpaceWord8seq` b `seq`wcthenseq`firstnonspace = undefinedptr (n+1) m else return n
831a913
> firstnonspace ptr n m
831a914
> {-
831a915
> -- | 'dropSpaceEnd' efficiently returns the 'ByteString' argument with
831a916
> -- white space removed from the end. I.e.
833c918
< -- > dropWhile isSpace == dropSpace
---
> -- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
835d919
< dropSpace :: ByteString -> ByteString
836d919
< dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
837d919
<     i <- firstnonspace (p `plusPtr` s) 0 l
838d919
<     return $! if i == l then empty else PS x (s+i) (l-i)
839c920
< {-# INLINE dropSpace #-}
---
> -- but it is more efficient than using multiple reverses.
839a921
> --
839a922
> dropSpaceEnd :: ByteString -> ByteString
839a923
> dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
839a924
>     i <- lastnonspace (p `plusPtr` s) (l-1)
839a925
>     return $! if i == (-1) then empty else PS x s (i+1)
839a926
> {-# INLINE dropSpaceEnd #-}
841d927
< firstnonspace :: Ptr Word8 -> Int -> Int -> IO Int
842d927
< STRICT3(firstnonspace)
843d927
< firstnonspace ptr n m
844c928
<     | n >= m    = return n
---
> lastnonspace :: Ptr Word8 -> Int -> IO Int
844a929
> STRICT2(lastnonspace)
844a930
> lastnonspace ptr n
844a931
>     | n < 0     = return n
845a933
>                      if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
845a934
> -}   n >= m    = return n
845a935
>     | otherwise = do w <- peekElemOff ptr n
863c953
< STRICT2(lastnonspace)
---
> lastnonspace a b | a `seq` b `seq` False = undefined
869d958
< 
870d958
< -- | 'lines' breaks a ByteString up into a list of ByteStrings at
874d961
< lines ps
875c962
<     | null ps = []
---
> lines-- | 'lines' breaks a ByteString up into a list of ByteStrings atps
875a963
> -- newline Chars. The resulting strings do not contain newlines.| null ps = []
875a964
> --  | otherwise = case search ps of
875a965
> lines :: ByteStringNothing->->[ByteString[ps]      ]
875a966
> lines ps     Just n  -> take n ps : lines (drop (n+1) ps)
875a967
>     |wheresearch = [] elemIndex '\n'
877c969
<              Nothing -> [ps]
---
> {-
877a970
> -- Just as fast, but more complex. Should be much faster, I thought.
877a971
> lines :: ByteString -> [ByteString]
877a972
> lines (PS _ _ 0) = []
877a973
> lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
877a974
>         let ptr = p `plusPtr` s
877a975
> 
877a976
>             STRICT1(loop)
877a977
>             loop n = do
877a978
>                 let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
877a979
>                 if q == nullPtr
877a980
>                     then return [PS x (s+n) (l-n)]
877a981
>                     else do let i = q `minusPtr` ptr
877a982
>                             ls <- loop (i+1)
877a983
>                             return $! PS x (s+n) (i-n) : ls
877a984
>         loop 0
877a985
> -}            -> [ps]
888c996
<             STRICT1(loop)
---
>             loop a | a `seq` False = undefined
898d1005
< 
899d1005
< -- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
903d1008
< unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
904d1008
<     where nl = singleton '\n'
905d1008
< 
906d1008
< -- | 'words' breaks a ByteString up into a list of words, which
907d1008
< -- were delimited by Chars representing white space.
908c1009
< words :: ByteString -> [ByteString]
---
> unlines-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
908a1010
> -- after appending a terminating newline to each.where nl = singleton '\n'
908a1011
> unlines :: [ByteString] -> ByteString
908a1012
> unlines-- | 'words' breaks a ByteString up into a list of words, which] = empty
908a1013
> unlines-- were delimited by Chars representing white space. = (concat $ List.intersperse nl ss) `append` nl -- half as much space
908a1014
> wordswhere:: ByteString = singleton-> [ByteString     ]
910d1015
< {-# INLINE words #-}
911d1015
< 
912d1015
< -- | The 'unwords' function is analogous to the 'unlines' function, on words.
913d1015
< unwords :: [ByteString] -> ByteString
914c1016
< unwords = intercalate (singleton ' ')
---
> {-# INLINE-- | 'words' breaks a ByteString up into a list of words, whichwords #-}
914a1017
> -- were delimited by Chars representing white space.
914a1018
> words-- | The 'unwords' function is analogous to the 'unlines' function, on words.:: ByteString -> [ByteString]
914a1019
> wordsunwords= P.filter:: [ByteStringnot . B.null-> ByteString) . B.splitWith isSpaceWord8
914a1020
> {-# INLINEunwords = intercalate #-}  (singleton ' ')
916d1021
< 
917d1021
< -- ---------------------------------------------------------------------
918d1021
< -- Reading from ByteStrings
919d1021
< 
920d1021
< -- | readInt reads an Int from the beginning of the ByteString.  If there is no
921d1021
< -- integer at the beginning of the string, it returns Nothing, otherwise
922d1021
< -- it just returns the int read, and the rest of the string.
923d1021
< readInt :: ByteString -> Maybe (Int, ByteString)
924d1021
< readInt as
925d1021
<     | null as   = Nothing
926d1021
<     | otherwise =
927d1021
<         case unsafeHead as of
928d1021
<             '-' -> loop True  0 0 (B.unsafeTail as)
929d1021
<             '+' -> loop False 0 0 (B.unsafeTail as)
930d1021
<             _   -> loop False 0 0 as
931d1021
< 
932d1021
<     where loop :: Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
933d1021
<           STRICT4(loop)
934d1021
<           loop neg i n ps
935d1021
<               | null ps   = end neg i n ps
936d1021
<               | otherwise =
937d1021
<                   case B.unsafeHead ps of
938d1021
<                     w | w >= 0x30
939d1021
<                      && w <= 0x39 -> loop neg (i+1)
940d1021
<                                           (n * 10 + (fromIntegral w - 0x30))
941d1021
<                                           (B.unsafeTail ps)
942d1021
<                       | otherwise -> end neg i n ps
943d1021
< 
944d1021
<           end _    0 _ _  = Nothing
945d1021
<           end True _ n ps = Just (negate n, ps)
946d1021
<           end _    _ n ps = Just (n, ps)
947d1021
< 
948d1021
< -- | readInteger reads an Integer from the beginning of the ByteString.  If
949d1021
< -- there is no integer at the beginning of the string, it returns Nothing,
950d1021
< -- otherwise it just returns the int read, and the rest of the string.
951d1021
< readInteger :: ByteString -> Maybe (Integer, ByteString)
952d1021
< readInteger as
953d1021
<     | null as   = Nothing
954d1021
<     | otherwise =
955d1021
<         case unsafeHead as of
956d1021
<             '-' -> first (B.unsafeTail as) >>= \(n, bs) -> return (-n, bs)
957d1021
<             '+' -> first (B.unsafeTail as)
958d1021
<             _   -> first as
959d1021
< 
960d1021
<     where first ps | null ps   = Nothing
961d1021
<                    | otherwise =
962d1021
<                        case B.unsafeHead ps of
963d1021
<                         w | w >= 0x30 && w <= 0x39 -> Just $
964d1021
<                             loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail ps)
965d1021
<                           | otherwise              -> Nothing
966d1021
< 
967d1021
<           loop :: Int -> Int -> [Integer]
968d1021
<                -> ByteString -> (Integer, ByteString)
969d1021
<           STRICT4(loop)
970d1021
<           loop d acc ns ps
971d1021
<               | null ps   = combine d acc ns empty
972d1021
<               | otherwise =
973d1021
<                   case B.unsafeHead ps of
974d1021
<                    w | w >= 0x30 && w <= 0x39 ->
975d1021
<                        if d == 9 then loop 1 (fromIntegral w - 0x30)
976d1021
<                                            (toInteger acc : ns)
977d1021
<                                            (B.unsafeTail ps)
978d1021
<                                  else loop (d+1)
979d1021
<                                            (10*acc + (fromIntegral w - 0x30))
980d1021
<                                            ns (B.unsafeTail ps)
981d1021
<                      | otherwise -> combine d acc ns ps
982d1021
< 
983d1021
<           combine _ acc [] ps = (toInteger acc, ps)
984d1021
<           combine d acc ns ps =
985d1021
<               ((10^d * combine1 1000000000 ns + toInteger acc), ps)
986d1021
< 
987d1021
<           combine1 _ [n] = n
988d1021
<           combine1 b ns  = combine1 (b*b) $ combine2 b ns
989d1021
< 
990d1021
<           combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
991d1021
<           combine2 _ ns       = ns
992d1021
< 
993d1021
< ------------------------------------------------------------------------
994d1021
< -- For non-binary text processing:
995d1021
< 
996d1021
< -- | Read an entire file strictly into a 'ByteString'.  This is far more
997d1021
< -- efficient than reading the characters into a 'String' and then using
998d1021
< -- 'pack'.  It also may be more efficient than opening the file and
999d1021
< -- reading it using hGet.
1000d1021
< readFile :: FilePath -> IO ByteString
1001d1021
< readFile f = bracket (openBinaryFile f ReadMode) hClose
1002d1021
<     (\h -> hFileSize h >>= hGet h . fromIntegral)
1003d1021
< 
1004d1021
< -- | Write a 'ByteString' to a file.
1005d1021
< writeFile :: FilePath -> ByteString -> IO ()
1006d1021
< writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
1007d1021
<     (\h -> hPut h txt)
1008d1021
< 
1009d1021
< -- | Append a 'ByteString' to a file.
1010d1021
< appendFile :: FilePath -> ByteString -> IO ()
1011d1021
< appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
1012d1021
<     (\h -> hPut h txt)
1013d1021
< 
1014d1021
< 
1015d1021
< -- | Write a ByteString to a handle, appending a newline byte
1016d1021
< hPutStrLn :: Handle -> ByteString -> IO ()
1017d1021
< hPutStrLn h ps
1018d1021
<     | length ps < 1024 = hPut h (ps `B.snoc` 0x0a)
1019c1022
<     | otherwise        = hPut h ps >> hPut h (B.singleton (0x0a)) -- don't copy
---
> -- | The 'unwords' function is analogous to the 'unlines' function, on words.
1019a1023
> unwords-- ---------------------------------------------------------------------:: [ByteString] -> ByteString
1021d1024
< -- | Write a ByteString to stdout, appending a newline byte
1022d1024
< putStrLn :: ByteString -> IO ()
1023d1024
< putStrLn = hPutStrLn stdout
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
#if __GLASGOW_HASKELL__
{-# LANGUAGE MagicHash, UnboxedTuples #-}
#endif
{-# OPTIONS_HADDOCK prune #-}
#if __GLASGOW_HASKELL__ >= 701
{-# LANGUAGE Trustworthy #-}
#endif

-- |
-- Module      : Data.ByteString.Char8
-- Copyright   : (c) Don Stewart 2006-2008
--               (c) Duncan Coutts 2006-2011
-- License     : BSD-style
--
-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org
-- Stability   : stable
-- Portability : portable
--
-- Manipulate 'ByteString's using 'Char' operations. All Chars will be
-- truncated to 8 bits. It can be expected that these functions will run
-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
--
-- More specifically these byte strings are taken to be in the
-- subset of Unicode covered by code points 0-255. This covers
-- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
--
-- See:
--
--  * <http://www.unicode.org/charts/>
--
--  * <http://www.unicode.org/charts/PDF/U0000.pdf>
--
--  * <http://www.unicode.org/charts/PDF/U0080.pdf>
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Char8 as C
--
-- The Char8 interface to bytestrings provides an instance of IsString
-- for the ByteString type, enabling you to use string literals, and
-- have them implicitly packed to ByteStrings.
-- Use @{-\# LANGUAGE OverloadedStrings \#-}@ to enable this.
--

module Data.ByteString.Char8 (

        -- * The @ByteString@ type
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        uncons,                 -- :: ByteString -> Maybe (Char, ByteString)
        unsnoc,                 -- :: ByteString -> Maybe (ByteString, Char)
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int

        -- * Transformating ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Char -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
        scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Generating and unfolding ByteStrings
        replicate,              -- :: Int -> Char -> ByteString
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString
        unfoldrN,               -- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int -> ByteString -> ByteString
        drop,                   -- :: Int -> ByteString -> ByteString
        splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,                -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
        breakSubstring,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int
        elemIndices,            -- :: Char -> ByteString -> [Int]
        elemIndexEnd,           -- :: Char -> ByteString -> Maybe Int
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int]
        count,                  -- :: Char -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        sort,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,                -- :: ByteString -> Maybe (Int, ByteString)
        readInteger,            -- :: ByteString -> Maybe (Integer, ByteString)

        -- * Low level CString conversions

        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString

        -- ** Packing CStrings and pointers
        packCString,            -- :: CString -> IO ByteString
        packCStringLen,         -- :: CStringLen -> IO ByteString

        -- ** Using ByteStrings as CStrings
        useAsCString,           -- :: ByteString -> (CString    -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- * I\/O with 'ByteString's
        -- | ByteString I/O uses binary mode, without any character decoding
        -- or newline conversion. The fact that it does not respect the Handle
        -- newline mode is considered a flaw and may be changed in a future version.

        -- ** Standard input and output
        getLine,                -- :: IO ByteString
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
--      mmapFile,               -- :: FilePath -> IO ByteString

        -- ** I\/O with Handles
        hGetLine,               -- :: Handle -> IO ByteString
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetSome,               -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()

  ) where

import qualified Prelude as P
import Prelude hiding           (reverse,head,tail,last,init,null
                                ,length,map,lines,foldl,foldr,unlines
                                ,concat,any,take,drop,splitAt,takeWhile
                                ,dropWhile,span,break,elem,filter,unwords
                                ,words,maximum,minimum,all,concatMap
                                ,scanl,scanl1,scanr,scanr1
                                ,appendFile,readFile,writeFile
                                ,foldl1,foldr1,replicate
                                ,getContents,getLine,putStr,putStrLn,interact
                                ,zip,zipWith,unzip,notElem)

import qualified Data.ByteString as B
import qualified Data.ByteString.Internal as B
import qualified Data.ByteString.Unsafe as B

-- Listy functions transparently exported
import Data.ByteString (empty,null,length,tail,init,append
                       ,inits,tails,reverse,transpose
                       ,concat,take,drop,splitAt,intercalate
                       ,sort,isPrefixOf,isSuffixOf,isInfixOf
                       ,findSubstring,findSubstrings,breakSubstring,copy,group

                       ,getLine, getContents, putStr, interact
                       ,hGetContents, hGet, hGetSome, hPut, hPutStr
                       ,hGetLine, hGetNonBlocking, hPutNonBlocking
                       ,packCString,packCStringLen
                       ,useAsCString,useAsCStringLen
                       )

import Data.ByteString.Internal

import Data.Char    ( isSpace )
import qualified Data.List as List (intersperse)

import System.IO    (Handle,stdout,openBinaryFile,hClose,hFileSize,IOMode(..))
#ifndef __NHC__
import Control.Exception        (bracket)
#else
import IO           (bracket)
#endif
import Foreign

#define STRICT1(f) f a | a `seq` False = undefined
#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined

------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = B.singleton . c2w
{-# INLINE singleton #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck.
pack :: String -> ByteString
pack = packChars
{-# INLINE pack #-}

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = B.unpackChars
{-# INLINE unpack #-}

infixr 5 `cons` --same as list (:)
infixl 5 `snoc`

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Char -> ByteString -> ByteString
cons = B.cons . c2w
{-# INLINE cons #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = B.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Char, ByteString)
uncons bs = case B.uncons bs of
                  Nothing -> Nothing
                  Just (w, bs') -> Just (w2c w, bs')
{-# INLINE uncons #-}

-- | /O(1)/ Extract the 'init' and 'last' of a ByteString, returning Nothing
-- if it is empty.
unsnoc :: ByteString -> Maybe (ByteString, Char)
unsnoc bs = case B.unsnoc bs of
                  Nothing -> Nothing
                  Just (bs', w) -> Just (bs', w2c w)
{-# INLINE unsnoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . B.head
{-# INLINE head #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . B.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = B.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = B.intersperse . c2w
{-# INLINE intersperse #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = B.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = B.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = B.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldr\'' is a strict variant of foldr
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr' f = B.foldr' (\c a -> f (w2c c) a)
{-# INLINE foldr' #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (B.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | A strict version of 'foldl1'
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (B.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1' #-}

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (B.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | A strict variant of foldr1
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr1' f ps = w2c (B.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1' #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = B.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = B.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = B.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . B.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . B.minimum
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = B.mapAccumL (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = B.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left:
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = B.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanl1 f = B.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr f z = B.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr1 f = B.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
--
-- This implemenation uses @memset(3)@
replicate :: Int -> Char -> ByteString
replicate w = B.replicate w . c2w
{-# INLINE replicate #-}

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
-- ByteString from a seed value.  The function takes the element and
-- returns 'Nothing' if it is done producing the ByteString or returns
-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f x0 = B.unfoldr (fmap k . f) x0
    where k (i, j) = (c2w i, j)

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > unfoldrN n f s == take n (unfoldr f s)
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
    where k (i,j) = (c2w i, j)
{-# INLINE unfoldrN #-}

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = B.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = B.dropWhile (f . w2c)
#if defined(__GLASGOW_HASKELL__)
{-# INLINE [1] dropWhile #-}
#endif

{-# RULES
"ByteString specialise dropWhile isSpace -> dropSpace"
    dropWhile isSpace = dropSpace
  #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break f = B.break (f . w2c)
#if defined(__GLASGOW_HASKELL__)
{-# INLINE [1] break #-}
#endif

{-# RULES
"ByteString specialise break (x==)" forall x.
    break ((==) x) = breakChar x
"ByteString specialise break (==x)" forall x.
    break (==x) = breakChar x
  #-}

-- INTERNAL:

-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar c p = case elemIndex c p of
    Nothing -> (p,empty)
    Just n  -> (B.unsafeTake n p, B.unsafeDrop n p)
{-# INLINE breakChar #-}

-- | 'span' @p xs@ breaks the ByteString into two segments. It is
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span f = B.span (f . w2c)
{-# INLINE span #-}

-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have
--
-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and
--
-- > spanEnd (not . isSpace) ps
-- >    ==
-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
--
spanEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
spanEnd f = B.spanEnd (f . w2c)
{-# INLINE spanEnd #-}

-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
--
-- breakEnd p == spanEnd (not.p)
breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd f = B.breakEnd (f . w2c)
{-# INLINE breakEnd #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = B.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = B.spanByte . c2w
{-# INLINE spanChar #-}
-}

-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
--
-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
-- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]
--
-- and
--
-- > intercalate [c] . split c == id
-- > split == splitWith . (==)
--
-- As for all splitting functions in this library, this function does
-- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.
--
split :: Char -> ByteString -> [ByteString]
split = B.split . c2w
{-# INLINE split #-}

-- | /O(n)/ Splits a 'ByteString' into components delimited by
-- separators, where the predicate returns True for a separator element.
-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.
--
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--
splitWith :: (Char -> Bool) -> ByteString -> [ByteString]
splitWith f = B.splitWith (f . w2c)
{-# INLINE splitWith #-}
-- the inline makes a big difference here.

{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Char -> Bool) -> ByteString -> [ByteString]
tokens f = B.tokens (f . w2c)
{-# INLINE tokens #-}
-}

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy k = B.groupBy (\a b -> k (w2c a) (w2c b))

-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.
index :: ByteString -> Int -> Char
index = (w2c .) . B.index
{-# INLINE index #-}

-- | /O(n)/ The 'elemIndex' function returns the index of the first
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.
elemIndex :: Char -> ByteString -> Maybe Int
elemIndex = B.elemIndex . c2w
{-# INLINE elemIndex #-}

-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following
-- holds:
--
-- > elemIndexEnd c xs ==
-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--
elemIndexEnd :: Char -> ByteString -> Maybe Int
elemIndexEnd = B.elemIndexEnd . c2w
{-# INLINE elemIndexEnd #-}

-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning
-- the indices of all elements equal to the query element, in ascending order.
elemIndices :: Char -> ByteString -> [Int]
elemIndices = B.elemIndices . c2w
{-# INLINE elemIndices #-}

-- | The 'findIndex' function takes a predicate and a 'ByteString' and
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex :: (Char -> Bool) -> ByteString -> Maybe Int
findIndex f = B.findIndex (f . w2c)
{-# INLINE findIndex #-}

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices :: (Char -> Bool) -> ByteString -> [Int]
findIndices f = B.findIndices (f . w2c)

-- | count returns the number of times its argument appears in the ByteString
--
-- > count = length . elemIndices
--
-- Also
--
-- > count '\n' == length . lines
--
-- But more efficiently than using length on the intermediate list.
count :: Char -> ByteString -> Int
count c = B.count (c2w c)

-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This
-- implementation uses @memchr(3)@.
elem :: Char -> ByteString -> Bool
elem    c = B.elem (c2w c)
{-# INLINE elem #-}

-- | /O(n)/ 'notElem' is the inverse of 'elem'
notElem :: Char -> ByteString -> Bool
notElem c = B.notElem (c2w c)
{-# INLINE notElem #-}

-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
-- returns a ByteString containing those characters that satisfy the
-- predicate.
filter :: (Char -> Bool) -> ByteString -> ByteString
filter f = B.filter (f . w2c)
{-# INLINE filter #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single Char. It is more
-- efficient to use /filterChar/ in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c ps = replicate (count c ps) c
{-# INLINE filterChar #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
    filter ((==) x) = filterChar x
"ByteString specialise filter (== x)" forall x.
    filter (== x) = filterChar x
  #-}
-}

-- | /O(n)/ The 'find' function takes a predicate and a ByteString,
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find :: (Char -> Bool) -> ByteString -> Maybe Char
find f ps = w2c `fmap` B.find (f . w2c) ps
{-# INLINE find #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = B.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = B.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}

-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space
-- usage may be large for multi-megabyte ByteStrings
zip :: ByteString -> ByteString -> [(Char,Char)]
zip ps qs
    | B.null ps || B.null qs = []
    | otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)

-- | 'zipWith' generalises 'zip' by zipping with the function given as
-- the first argument, instead of a tupling function.  For example,
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.
zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith f = B.zipWith ((. w2c) . f . w2c)

-- | 'unzip' transforms a list of pairs of Chars into a pair of
-- ByteStrings. Note that this performs two 'pack' operations.
unzip :: [(Char,Char)] -> (ByteString,ByteString)
unzip ls = (pack (P.map fst ls), pack (P.map snd ls))
{-# INLINE unzip #-}

-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
-- the check for the empty case, which is good for performance, but
-- there is an obligation on the programmer to provide a proof that the
-- ByteString is non-empty.
unsafeHead :: ByteString -> Char
unsafeHead  = w2c . B.unsafeHead
{-# INLINE unsafeHead #-}

-- ---------------------------------------------------------------------
-- Things that depend on the encoding

{-# RULES
"ByteString specialise break -> breakSpace"
    break isSpace = breakSpace
  #-}

-- | 'breakSpace' returns the pair of ByteStrings when the argument is
-- broken at the first whitespace byte. I.e.
--
-- > break isSpace == breakSpace
--
breakSpace :: ByteString -> (ByteString,ByteString)
breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- firstspace (p `plusPtr` s) 0 l
    return $! case () of {_
        | i == 0    -> (empty, PS x s l)
        | i == l    -> (PS x s l, empty)
        | otherwise -> (PS x s i, PS x (s+i) (l-i))
    }
{-# INLINE breakSpace #-}

firstspace :: Ptr Word8 -> Int -> Int -> IO Int
STRICT3(firstspace)
firstspace ptr n m
    | n >= m    = return n
    | otherwise = do w <- peekByteOff ptr n
                     if (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n

-- | 'dropSpace' efficiently returns the 'ByteString' argument with
-- white space Chars removed from the front. It is more efficient than
-- calling dropWhile for removing whitespace. I.e.
--
-- > dropWhile isSpace == dropSpace
--
dropSpace :: ByteString -> ByteString
dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- firstnonspace (p `plusPtr` s) 0 l
    return $! if i == l then empty else PS x (s+i) (l-i)
{-# INLINE dropSpace #-}

firstnonspace :: Ptr Word8 -> Int -> Int -> IO Int
STRICT3(firstnonspace)
firstnonspace ptr n m
    | n >= m    = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then firstnonspace ptr (n+1) m else return n

{-
-- | 'dropSpaceEnd' efficiently returns the 'ByteString' argument with
-- white space removed from the end. I.e.
--
-- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
--
-- but it is more efficient than using multiple reverses.
--
dropSpaceEnd :: ByteString -> ByteString
dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- lastnonspace (p `plusPtr` s) (l-1)
    return $! if i == (-1) then empty else PS x s (i+1)
{-# INLINE dropSpaceEnd #-}

lastnonspace :: Ptr Word8 -> Int -> IO Int
STRICT2(lastnonspace)
lastnonspace ptr n
    | n < 0     = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
-}

-- | 'lines' breaks a ByteString up into a list of ByteStrings at
-- newline Chars. The resulting strings do not contain newlines.
--
lines :: ByteString -> [ByteString]
lines ps
    | null ps = []
    | otherwise = case search ps of
             Nothing -> [ps]
             Just n  -> take n ps : lines (drop (n+1) ps)
    where search = elemIndex '\n'

{-
-- Just as fast, but more complex. Should be much faster, I thought.
lines :: ByteString -> [ByteString]
lines (PS _ _ 0) = []
lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
        let ptr = p `plusPtr` s

            STRICT1(loop)
            loop n = do
                let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
                if q == nullPtr
                    then return [PS x (s+n) (l-n)]
                    else do let i = q `minusPtr` ptr
                            ls <- loop (i+1)
                            return $! PS x (s+n) (i-n) : ls
        loop 0
-}

-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = empty
unlines ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
    where nl = singleton '\n'

-- | 'words' breaks a ByteString up into a list of words, which
-- were delimited by Chars representing white space.
words :: ByteString -> [ByteString]
words = P.filter (not . B.null) . B.splitWith isSpaceWord8
{-# INLINE words #-}

-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords :: [ByteString] -> ByteString
unwords = intercalate (singleton ' ')
{-# INLINE unwords #-}

-- ---------------------------------------------------------------------
-- Reading from ByteStrings

-- | readInt reads an Int from the beginning of the ByteString.  If there is no
-- integer at the beginning of the string, it returns Nothing, otherwise
-- it just returns the int read, and the rest of the string.
readInt :: ByteString -> Maybe (Int, ByteString)
readInt as
    | null as   = Nothing
    | otherwise =
        case unsafeHead as of
            '-' -> loop True  0 0 (B.unsafeTail as)
            '+' -> loop False 0 0 (B.unsafeTail as)
            _   -> loop False 0 0 as

    where loop :: Bool -> Int -> Int -> ByteString -> Maybe (Int, ByteString)
          STRICT4(loop)
          loop neg i n ps
              | null ps   = end neg i n ps
              | otherwise =
                  case B.unsafeHead ps of
                    w | w >= 0x30
                     && w <= 0x39 -> loop neg (i+1)
                                          (n * 10 + (fromIntegral w - 0x30))
                                          (B.unsafeTail ps)
                      | otherwise -> end neg i n ps

          end _    0 _ _  = Nothing
          end True _ n ps = Just (negate n, ps)
          end _    _ n ps = Just (n, ps)

-- | readInteger reads an Integer from the beginning of the ByteString.  If
-- there is no integer at the beginning of the string, it returns Nothing,
-- otherwise it just returns the int read, and the rest of the string.
readInteger :: ByteString -> Maybe (Integer, ByteString)
readInteger as
    | null as   = Nothing
    | otherwise =
        case unsafeHead as of
            '-' -> first (B.unsafeTail as) >>= \(n, bs) -> return (-n, bs)
            '+' -> first (B.unsafeTail as)
            _   -> first as

    where first ps | null ps   = Nothing
                   | otherwise =
                       case B.unsafeHead ps of
                        w | w >= 0x30 && w <= 0x39 -> Just $
                            loop 1 (fromIntegral w - 0x30) [] (B.unsafeTail ps)
                          | otherwise              -> Nothing

          loop :: Int -> Int -> [Integer]
               -> ByteString -> (Integer, ByteString)
          STRICT4(loop)
          loop d acc ns ps
              | null ps   = combine d acc ns empty
              | otherwise =
                  case B.unsafeHead ps of
                   w | w >= 0x30 && w <= 0x39 ->
                       if d == 9 then loop 1 (fromIntegral w - 0x30)
                                           (toInteger acc : ns)
                                           (B.unsafeTail ps)
                                 else loop (d+1)
                                           (10*acc + (fromIntegral w - 0x30))
                                           ns (B.unsafeTail ps)
                     | otherwise -> combine d acc ns ps

          combine _ acc [] ps = (toInteger acc, ps)
          combine d acc ns ps =
              ((10^d * combine1 1000000000 ns + toInteger acc), ps)

          combine1 _ [n] = n
          combine1 b ns  = combine1 (b*b) $ combine2 b ns

          combine2 b (n:m:ns) = let t = m*b + n in t `seq` (t : combine2 b ns)
          combine2 _ ns       = ns

------------------------------------------------------------------------
-- For non-binary text processing:

-- | Read an entire file strictly into a 'ByteString'.  This is far more
-- efficient than reading the characters into a 'String' and then using
-- 'pack'.  It also may be more efficient than opening the file and
-- reading it using hGet.
readFile :: FilePath -> IO ByteString
readFile f = bracket (openBinaryFile f ReadMode) hClose
    (\h -> hFileSize h >>= hGet h . fromIntegral)

-- | Write a 'ByteString' to a file.
writeFile :: FilePath -> ByteString -> IO ()
writeFile f txt = bracket (openBinaryFile f WriteMode) hClose
    (\h -> hPut h txt)

-- | Append a 'ByteString' to a file.
appendFile :: FilePath -> ByteString -> IO ()
appendFile f txt = bracket (openBinaryFile f AppendMode) hClose
    (\h -> hPut h txt)


-- | Write a ByteString to a handle, appending a newline byte
hPutStrLn :: Handle -> ByteString -> IO ()
hPutStrLn h ps
    | length ps < 1024 = hPut h (ps `B.snoc` 0x0a)
    | otherwise        = hPut h ps >> hPut h (B.singleton (0x0a)) -- don't copy

-- | Write a ByteString to stdout, appending a newline byte
putStrLn :: ByteString -> IO ()
putStrLn = hPutStrLn stdout
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
#if __GLASGOW_HASKELL__
{-# LANGUAGE MagicHash, UnboxedTuples #-}
#endif
{-# OPTIONS_HADDOCK prune #-}
#if __GLASGOW_HASKELL__ >= 701
{-# LANGUAGE Trustworthy #-}
#endif

-- |
-- Module      : Data.ByteString.Char8
-- Copyright   : (c) Don Stewart 2006-2008
--               (c) Duncan Coutts 2006-2011
-- License     : BSD-style
--
-- Maintainer  : dons00@gmail.com, duncan@community.haskell.org
-- Stability   : stable
-- Portability : portable
--
-- Manipulate 'ByteString's using 'Char' operations. All Chars will be
-- truncated to 8 bits. It can be expected that these functions will run
-- at identical speeds to their 'Word8' equivalents in "Data.ByteString".
--
-- More specifically these byte strings are taken to be in the
-- subset of Unicode covered by code points 0-255. This covers
-- Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.
--
-- See:
--
--  * <http://www.unicode.org/charts/>
--
--  * <http://www.unicode.org/charts/PDF/U0000.pdf>
--
--  * <http://www.unicode.org/charts/PDF/U0080.pdf>
--
-- This module is intended to be imported @qualified@, to avoid name
-- clashes with "Prelude" functions.  eg.
--
-- > import qualified Data.ByteString.Char8 as C
--
-- The Char8 interface to bytestrings provides an instance of IsString
-- for the ByteString type, enabling you to use string literals, and
-- have them implicitly packed to ByteStrings.
-- Use @{-\# LANGUAGE OverloadedStrings \#-}@ to enable this.
--

module Data.ByteString.Char8 (

        -- * The @ByteString@ type
        ByteString,             -- abstract, instances: Eq, Ord, Show, Read, Data, Typeable, Monoid

        -- * Introducing and eliminating 'ByteString's
        empty,                  -- :: ByteString
        singleton,              -- :: Char   -> ByteString
        pack,                   -- :: String -> ByteString
        unpack,                 -- :: ByteString -> String

        -- * Basic interface
        cons,                   -- :: Char -> ByteString -> ByteString
        snoc,                   -- :: ByteString -> Char -> ByteString
        append,                 -- :: ByteString -> ByteString -> ByteString
        head,                   -- :: ByteString -> Char
        uncons,                 -- :: ByteString -> Maybe (Char, ByteString)
        unsnoc,                 -- :: ByteString -> Maybe (ByteString, Char)
        last,                   -- :: ByteString -> Char
        tail,                   -- :: ByteString -> ByteString
        init,                   -- :: ByteString -> ByteString
        null,                   -- :: ByteString -> Bool
        length,                 -- :: ByteString -> Int

        -- * Transformating ByteStrings
        map,                    -- :: (Char -> Char) -> ByteString -> ByteString
        reverse,                -- :: ByteString -> ByteString
        intersperse,            -- :: Char -> ByteString -> ByteString
        intercalate,            -- :: ByteString -> [ByteString] -> ByteString
        transpose,              -- :: [ByteString] -> [ByteString]

        -- * Reducing 'ByteString's (folds)
        foldl,                  -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl',                 -- :: (a -> Char -> a) -> a -> ByteString -> a
        foldl1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldl1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        foldr,                  -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr',                 -- :: (Char -> a -> a) -> a -> ByteString -> a
        foldr1,                 -- :: (Char -> Char -> Char) -> ByteString -> Char
        foldr1',                -- :: (Char -> Char -> Char) -> ByteString -> Char

        -- ** Special folds
        concat,                 -- :: [ByteString] -> ByteString
        concatMap,              -- :: (Char -> ByteString) -> ByteString -> ByteString
        any,                    -- :: (Char -> Bool) -> ByteString -> Bool
        all,                    -- :: (Char -> Bool) -> ByteString -> Bool
        maximum,                -- :: ByteString -> Char
        minimum,                -- :: ByteString -> Char

        -- * Building ByteStrings
        -- ** Scans
        scanl,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanl1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString
        scanr,                  -- :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
        scanr1,                 -- :: (Char -> Char -> Char) -> ByteString -> ByteString

        -- ** Accumulating maps
        mapAccumL,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
        mapAccumR,              -- :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)

        -- ** Generating and unfolding ByteStrings
        replicate,              -- :: Int -> Char -> ByteString
        unfoldr,                -- :: (a -> Maybe (Char, a)) -> a -> ByteString
        unfoldrN,               -- :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)

        -- * Substrings

        -- ** Breaking strings
        take,                   -- :: Int -> ByteString -> ByteString
        drop,                   -- :: Int -> ByteString -> ByteString
        splitAt,                -- :: Int -> ByteString -> (ByteString, ByteString)
        takeWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        dropWhile,              -- :: (Char -> Bool) -> ByteString -> ByteString
        span,                   -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        spanEnd,                -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        break,                  -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        breakEnd,               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
        group,                  -- :: ByteString -> [ByteString]
        groupBy,                -- :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
        inits,                  -- :: ByteString -> [ByteString]
        tails,                  -- :: ByteString -> [ByteString]

        -- ** Breaking into many substrings
        split,                  -- :: Char -> ByteString -> [ByteString]
        splitWith,              -- :: (Char -> Bool) -> ByteString -> [ByteString]

        -- ** Breaking into lines and words
        lines,                  -- :: ByteString -> [ByteString]
        words,                  -- :: ByteString -> [ByteString]
        unlines,                -- :: [ByteString] -> ByteString
        unwords,                -- :: ByteString -> [ByteString]

        -- * Predicates
        isPrefixOf,             -- :: ByteString -> ByteString -> Bool
        isSuffixOf,             -- :: ByteString -> ByteString -> Bool
        isInfixOf,              -- :: ByteString -> ByteString -> Bool

        -- ** Search for arbitrary substrings
        breakSubstring,         -- :: ByteString -> ByteString -> (ByteString,ByteString)
        findSubstring,          -- :: ByteString -> ByteString -> Maybe Int
        findSubstrings,         -- :: ByteString -> ByteString -> [Int]

        -- * Searching ByteStrings

        -- ** Searching by equality
        elem,                   -- :: Char -> ByteString -> Bool
        notElem,                -- :: Char -> ByteString -> Bool

        -- ** Searching with a predicate
        find,                   -- :: (Char -> Bool) -> ByteString -> Maybe Char
        filter,                 -- :: (Char -> Bool) -> ByteString -> ByteString
--      partition               -- :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)

        -- * Indexing ByteStrings
        index,                  -- :: ByteString -> Int -> Char
        elemIndex,              -- :: Char -> ByteString -> Maybe Int
        elemIndices,            -- :: Char -> ByteString -> [Int]
        elemIndexEnd,           -- :: Char -> ByteString -> Maybe Int
        findIndex,              -- :: (Char -> Bool) -> ByteString -> Maybe Int
        findIndices,            -- :: (Char -> Bool) -> ByteString -> [Int]
        count,                  -- :: Char -> ByteString -> Int

        -- * Zipping and unzipping ByteStrings
        zip,                    -- :: ByteString -> ByteString -> [(Char,Char)]
        zipWith,                -- :: (Char -> Char -> c) -> ByteString -> ByteString -> [c]
        unzip,                  -- :: [(Char,Char)] -> (ByteString,ByteString)

        -- * Ordered ByteStrings
        sort,                   -- :: ByteString -> ByteString

        -- * Reading from ByteStrings
        readInt,                -- :: ByteString -> Maybe (Int, ByteString)
        readInteger,            -- :: ByteString -> Maybe (Integer, ByteString)

        -- * Low level CString conversions

        -- ** Copying ByteStrings
        copy,                   -- :: ByteString -> ByteString

        -- ** Packing CStrings and pointers
        packCString,            -- :: CString -> IO ByteString
        packCStringLen,         -- :: CStringLen -> IO ByteString

        -- ** Using ByteStrings as CStrings
        useAsCString,           -- :: ByteString -> (CString    -> IO a) -> IO a
        useAsCStringLen,        -- :: ByteString -> (CStringLen -> IO a) -> IO a

        -- * I\/O with 'ByteString's
        -- | ByteString I/O uses binary mode, without any character decoding
        -- or newline conversion. The fact that it does not respect the Handle
        -- newline mode is considered a flaw and may be changed in a future version.

        -- ** Standard input and output
        getLine,                -- :: IO ByteString
        getContents,            -- :: IO ByteString
        putStr,                 -- :: ByteString -> IO ()
        putStrLn,               -- :: ByteString -> IO ()
        interact,               -- :: (ByteString -> ByteString) -> IO ()

        -- ** Files
        readFile,               -- :: FilePath -> IO ByteString
        writeFile,              -- :: FilePath -> ByteString -> IO ()
        appendFile,             -- :: FilePath -> ByteString -> IO ()
--      mmapFile,               -- :: FilePath -> IO ByteString

        -- ** I\/O with Handles
        hGetLine,               -- :: Handle -> IO ByteString
        hGetContents,           -- :: Handle -> IO ByteString
        hGet,                   -- :: Handle -> Int -> IO ByteString
        hGetSome,               -- :: Handle -> Int -> IO ByteString
        hGetNonBlocking,        -- :: Handle -> Int -> IO ByteString
        hPut,                   -- :: Handle -> ByteString -> IO ()
        hPutNonBlocking,        -- :: Handle -> ByteString -> IO ByteString
        hPutStr,                -- :: Handle -> ByteString -> IO ()
        hPutStrLn,              -- :: Handle -> ByteString -> IO ()

  ) where

import qualified Prelude as P
import Prelude hiding           (reverse,head,tail,last,init,null
                                ,length,map,lines,foldl,foldr,unlines
                                ,concat,any,take,drop,splitAt,takeWhile
                                ,dropWhile,span,break,elem,filter,unwords
                                ,words,maximum,minimum,all,concatMap
                                ,scanl,scanl1,scanr,scanr1
                                ,appendFile,readFile,writeFile
                                ,foldl1,foldr1,replicate
                                ,getContents,getLine,putStr,putStrLn,interact
                                ,zip,zipWith,unzip,notElem)

import qualified Data.ByteString as B
import qualified Data.ByteString.Internal as B
import qualified Data.ByteString.Unsafe as B

-- Listy functions transparently exported
import Data.ByteString (empty,null,length,tail,init,append
                       ,inits,tails,reverse,transpose
                       ,concat,take,drop,splitAt,intercalate
                       ,sort,isPrefixOf,isSuffixOf,isInfixOf
                       ,findSubstring,findSubstrings,breakSubstring,copy,group

                       ,getLine, getContents, putStr, interact
                       ,hGetContents, hGet, hGetSome, hPut, hPutStr
                       ,hGetLine, hGetNonBlocking, hPutNonBlocking
                       ,packCString,packCStringLen
                       ,useAsCString,useAsCStringLen
                       )

import Data.ByteString.Internal

import Data.Char    ( isSpace )
import qualified Data.List as List (intersperse)

import System.IO    (Handle,stdout,openBinaryFile,hClose,hFileSize,IOMode(..))
#ifndef __NHC__
import Control.Exception        (bracket)
#else
import IO           (bracket)
#endif
import Foreign

#define STRICT1(f) f a | a `seq` False = undefined
#define STRICT2(f) f a b | a `seq` b `seq` False = undefined
#define STRICT3(f) f a b c | a `seq` b `seq` c `seq` False = undefined
#define STRICT4(f) f a b c d | a `seq` b `seq` c `seq` d `seq` False = undefined

------------------------------------------------------------------------

-- | /O(1)/ Convert a 'Char' into a 'ByteString'
singleton :: Char -> ByteString
singleton = B.singleton . c2w
{-# INLINE singleton #-}

-- | /O(n)/ Convert a 'String' into a 'ByteString'
--
-- For applications with large numbers of string literals, pack can be a
-- bottleneck.
pack :: String -> ByteString
pack = packChars
{-# INLINE pack #-}

-- | /O(n)/ Converts a 'ByteString' to a 'String'.
unpack :: ByteString -> [Char]
unpack = B.unpackChars
{-# INLINE unpack #-}

infixr 5 `cons` --same as list (:)
infixl 5 `snoc`

-- | /O(n)/ 'cons' is analogous to (:) for lists, but of different
-- complexity, as it requires a memcpy.
cons :: Char -> ByteString -> ByteString
cons = B.cons . c2w
{-# INLINE cons #-}

-- | /O(n)/ Append a Char to the end of a 'ByteString'. Similar to
-- 'cons', this function performs a memcpy.
snoc :: ByteString -> Char -> ByteString
snoc p = B.snoc p . c2w
{-# INLINE snoc #-}

-- | /O(1)/ Extract the head and tail of a ByteString, returning Nothing
-- if it is empty.
uncons :: ByteString -> Maybe (Char, ByteString)
uncons bs = case B.uncons bs of
                  Nothing -> Nothing
                  Just (w, bs') -> Just (w2c w, bs')
{-# INLINE uncons #-}

-- | /O(1)/ Extract the 'init' and 'last' of a ByteString, returning Nothing
-- if it is empty.
unsnoc :: ByteString -> Maybe (ByteString, Char)
unsnoc bs = case B.unsnoc bs of
                  Nothing -> Nothing
                  Just (bs', w) -> Just (bs', w2c w)
{-# INLINE unsnoc #-}

-- | /O(1)/ Extract the first element of a ByteString, which must be non-empty.
head :: ByteString -> Char
head = w2c . B.head
{-# INLINE head #-}

-- | /O(1)/ Extract the last element of a packed string, which must be non-empty.
last :: ByteString -> Char
last = w2c . B.last
{-# INLINE last #-}

-- | /O(n)/ 'map' @f xs@ is the ByteString obtained by applying @f@ to each element of @xs@
map :: (Char -> Char) -> ByteString -> ByteString
map f = B.map (c2w . f . w2c)
{-# INLINE map #-}

-- | /O(n)/ The 'intersperse' function takes a Char and a 'ByteString'
-- and \`intersperses\' that Char between the elements of the
-- 'ByteString'.  It is analogous to the intersperse function on Lists.
intersperse :: Char -> ByteString -> ByteString
intersperse = B.intersperse . c2w
{-# INLINE intersperse #-}

-- | 'foldl', applied to a binary operator, a starting value (typically
-- the left-identity of the operator), and a ByteString, reduces the
-- ByteString using the binary operator, from left to right.
foldl :: (a -> Char -> a) -> a -> ByteString -> a
foldl f = B.foldl (\a c -> f a (w2c c))
{-# INLINE foldl #-}

-- | 'foldl\'' is like foldl, but strict in the accumulator.
foldl' :: (a -> Char -> a) -> a -> ByteString -> a
foldl' f = B.foldl' (\a c -> f a (w2c c))
{-# INLINE foldl' #-}

-- | 'foldr', applied to a binary operator, a starting value
-- (typically the right-identity of the operator), and a packed string,
-- reduces the packed string using the binary operator, from right to left.
foldr :: (Char -> a -> a) -> a -> ByteString -> a
foldr f = B.foldr (\c a -> f (w2c c) a)
{-# INLINE foldr #-}

-- | 'foldr\'' is a strict variant of foldr
foldr' :: (Char -> a -> a) -> a -> ByteString -> a
foldr' f = B.foldr' (\c a -> f (w2c c) a)
{-# INLINE foldr' #-}

-- | 'foldl1' is a variant of 'foldl' that has no starting value
-- argument, and thus must be applied to non-empty 'ByteStrings'.
foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
foldl1 f ps = w2c (B.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1 #-}

-- | A strict version of 'foldl1'
foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
foldl1' f ps = w2c (B.foldl1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldl1' #-}

-- | 'foldr1' is a variant of 'foldr' that has no starting value argument,
-- and thus must be applied to non-empty 'ByteString's
foldr1 :: (Char -> Char -> Char) -> ByteString -> Char
foldr1 f ps = w2c (B.foldr1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1 #-}

-- | A strict variant of foldr1
foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
foldr1' f ps = w2c (B.foldr1' (\x y -> c2w (f (w2c x) (w2c y))) ps)
{-# INLINE foldr1' #-}

-- | Map a function over a 'ByteString' and concatenate the results
concatMap :: (Char -> ByteString) -> ByteString -> ByteString
concatMap f = B.concatMap (f . w2c)
{-# INLINE concatMap #-}

-- | Applied to a predicate and a ByteString, 'any' determines if
-- any element of the 'ByteString' satisfies the predicate.
any :: (Char -> Bool) -> ByteString -> Bool
any f = B.any (f . w2c)
{-# INLINE any #-}

-- | Applied to a predicate and a 'ByteString', 'all' determines if
-- all elements of the 'ByteString' satisfy the predicate.
all :: (Char -> Bool) -> ByteString -> Bool
all f = B.all (f . w2c)
{-# INLINE all #-}

-- | 'maximum' returns the maximum value from a 'ByteString'
maximum :: ByteString -> Char
maximum = w2c . B.maximum
{-# INLINE maximum #-}

-- | 'minimum' returns the minimum value from a 'ByteString'
minimum :: ByteString -> Char
minimum = w2c . B.minimum
{-# INLINE minimum #-}

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from left to right, and returning a
-- final value of this accumulator together with the new list.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumL f = B.mapAccumL (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a ByteString,
-- passing an accumulating parameter from right to left, and returning a
-- final value of this accumulator together with the new ByteString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
mapAccumR f = B.mapAccumR (\acc w -> case f acc (w2c w) of (acc', c) -> (acc', c2w c))

-- | 'scanl' is similar to 'foldl', but returns a list of successive
-- reduced values from the left:
--
-- > scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--
-- Note that
--
-- > last (scanl f z xs) == foldl f z xs.
scanl :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanl f z = B.scanl (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
--
-- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
scanl1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanl1 f = B.scanl1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> ByteString -> ByteString
scanr f z = B.scanr (\a b -> c2w (f (w2c a) (w2c b))) (c2w z)

-- | 'scanr1' is a variant of 'scanr' that has no starting value argument.
scanr1 :: (Char -> Char -> Char) -> ByteString -> ByteString
scanr1 f = B.scanr1 (\a b -> c2w (f (w2c a) (w2c b)))

-- | /O(n)/ 'replicate' @n x@ is a ByteString of length @n@ with @x@
-- the value of every element. The following holds:
--
-- > replicate w c = unfoldr w (\u -> Just (u,u)) c
--
-- This implemenation uses @memset(3)@
replicate :: Int -> Char -> ByteString
replicate w = B.replicate w . c2w
{-# INLINE replicate #-}

-- | /O(n)/, where /n/ is the length of the result.  The 'unfoldr'
-- function is analogous to the List \'unfoldr\'.  'unfoldr' builds a
-- ByteString from a seed value.  The function takes the element and
-- returns 'Nothing' if it is done producing the ByteString or returns
-- 'Just' @(a,b)@, in which case, @a@ is the next character in the string,
-- and @b@ is the seed value for further production.
--
-- Examples:
--
-- > unfoldr (\x -> if x <= '9' then Just (x, succ x) else Nothing) '0' == "0123456789"
unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
unfoldr f x0 = B.unfoldr (fmap k . f) x0
    where k (i, j) = (c2w i, j)

-- | /O(n)/ Like 'unfoldr', 'unfoldrN' builds a ByteString from a seed
-- value.  However, the length of the result is limited by the first
-- argument to 'unfoldrN'.  This function is more efficient than 'unfoldr'
-- when the maximum length of the result is known.
--
-- The following equation relates 'unfoldrN' and 'unfoldr':
--
-- > unfoldrN n f s == take n (unfoldr f s)
unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
unfoldrN n f w = B.unfoldrN n ((k `fmap`) . f) w
    where k (i,j) = (c2w i, j)
{-# INLINE unfoldrN #-}

-- | 'takeWhile', applied to a predicate @p@ and a ByteString @xs@,
-- returns the longest prefix (possibly empty) of @xs@ of elements that
-- satisfy @p@.
takeWhile :: (Char -> Bool) -> ByteString -> ByteString
takeWhile f = B.takeWhile (f . w2c)
{-# INLINE takeWhile #-}

-- | 'dropWhile' @p xs@ returns the suffix remaining after 'takeWhile' @p xs@.
dropWhile :: (Char -> Bool) -> ByteString -> ByteString
dropWhile f = B.dropWhile (f . w2c)
#if defined(__GLASGOW_HASKELL__)
{-# INLINE [1] dropWhile #-}
#endif

{-# RULES
"ByteString specialise dropWhile isSpace -> dropSpace"
    dropWhile isSpace = dropSpace
  #-}

-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.
break-- | 'break' @p@ is equivalent to @'span' ('not' . p)@.:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
break ::f =(CharB.break-> Bool(f .)w2c->)ByteString -> (ByteString, ByteString)
break#if defined(__GLASGOW_HASKELL__) = B.break (f . w2c)
{-# INLINE [1] break #-}
{-# INLINE#endif      [1] break #-}

{-# RULES
{-# RULES"ByteString specialise break (x==)" forall x.
"ByteString specialise break (x==)"break ((==) x) = breakChar x    forall x.
"ByteString specialise break (==x)" ((==) x) = breakChar x    forall x.
"ByteString specialise break (==x)"break (==x) = breakChar x       forall x.
  #-} (==x) = breakChar x
  #-}
-- INTERNAL:

-- INTERNAL:-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.-- | 'breakChar' breaks its ByteString argument at the first occurence
---- of the specified char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar-- > break (=='c') "abcd" == breakChar 'c' "abcd":: Char -> ByteString -> (ByteString, ByteString)
--breakChar c p = case elemIndex c p of
breakCharNothing::->(p,->empty)        -> (ByteString, ByteString)
breakCharJust nc p->=(caseB.unsafeTaken c,pB.unsafeDropof          n p)
{-# INLINEbreakChar (p,empty#-})
    Just n  -> (B.unsafeTake n p, B.unsafeDrop n p)
{-# INLINE-- | 'span' @p xs@ breaks the ByteString into two segments. It is #-}
-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@
span-- | 'span' @p xs@ breaks the ByteString into two segments. It is:: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
span-- equivalent to @('takeWhile' p xs, 'dropWhile' p xs)@f = B.span (f . w2c)
span{-# INLINE:: (Charspan->#-}) -> ByteString -> (ByteString, ByteString)
span f = B.span (f . w2c)
{-# INLINE-- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'. #-}
-- We have
---- | 'spanEnd' behaves like 'span' but from the end of the 'ByteString'.
-- We have-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and-- > spanEnd (not.isSpace) "x y z" == ("x y ","z")
--
-- and-- > spanEnd (not . isSpace) ps
---- >    ==
-- > spanEnd (not . isSpace) ps-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x)
---- >    ==
spanEnd-- > let (x,y) = span (not.isSpace) (reverse ps) in (reverse y, reverse x):: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
--spanEnd f = B.spanEnd (f . w2c)
spanEnd{-# INLINE:: (spanEndChar ->#-}) -> ByteString -> (ByteString, ByteString)
spanEnd f = B.spanEnd (f . w2c)
{-# INLINE-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString' #-}
--
-- breakEnd p == spanEnd (not.p)-- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
--breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
breakEnd-- breakEnd p == spanEnd (not.p)f = B.breakEnd (f . w2c)
breakEnd{-# INLINE::breakEndChar ->#-}) -> ByteString -> (ByteString, ByteString)
breakEnd f = B.breakEnd (f . w2c)
{-# INLINE{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = B.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = B.spanByte . c2w
{-# INLINE spanChar #-}
-}          #-}

{-
-- | 'breakChar' breaks its ByteString argument at the first occurence
-- of the specified Char. It is more efficient than 'break' as it is
-- implemented with @memchr(3)@. I.e.
--
-- > break (=='c') "abcd" == breakChar 'c' "abcd"
--
breakChar :: Char -> ByteString -> (ByteString, ByteString)
breakChar = B.breakByte . c2w
{-# INLINE breakChar #-}

-- | 'spanChar' breaks its ByteString argument at the first
-- occurence of a Char other than its argument. It is more efficient
-- than 'span (==)'
--
-- > span  (=='c') "abcd" == spanByte 'c' "abcd"
--
spanChar :: Char -> ByteString -> (ByteString, ByteString)
spanChar = B.spanByte . c2w
{-# INLINE spanChar #-}
-}-- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.
---- | /O(n)/ Break a 'ByteString' into pieces separated by the byte
-- argument, consuming the delimiter. I.e.-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- > split 'x'  "x"          == ["",""]-- > split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
---- > split 'a'  "aXaXaXa"    == ["","X","X","X",""]
-- and-- > split 'x'  "x"          == ["",""]
--
-- and-- > intercalate [c] . split c == id
---- > split == splitWith . (==)
---- > intercalate [c] . split c == id
-- > split == splitWith . (==)-- As for all splitting functions in this library, this function does
---- not copy the substrings, it just constructs new 'ByteStrings' that
-- are slices of the original.-- As for all splitting functions in this library, this function does
---- not copy the substrings, it just constructs new 'ByteStrings' that
split-- are slices of the original.:: Char -> ByteString -> [ByteString]
--split = B.split . c2w
split{-# INLINE:: Charsplit-> ByteString#-}        -> [ByteString]
split = B.split . c2w
{-# INLINE-- | /O(n)/ Splits a 'ByteString' into components delimited by #-}
-- separators, where the predicate returns True for a separator element.
-- | /O(n)/ Splits a 'ByteString' into components delimited by-- The resulting components do not contain the separators.  Two adjacent
-- separators result in an empty component in the output.  eg.-- separators, where the predicate returns True for a separator element.
---- The resulting components do not contain the separators.  Two adjacent
-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]-- separators result in an empty component in the output.  eg.
--
splitWith-- > splitWith (=='a') "aabbaca" == ["","","bb","c",""]:: (Char -> Bool) -> ByteString -> [ByteString]
--splitWith f = B.splitWith (f . w2c)
splitWith{-# INLINE::splitWithChar ->#-}) -> ByteString -> [ByteString]
splitWith-- the inline makes a big difference here. = B.splitWith (f . w2c)
{-# INLINE splitWith #-}
-- the inline makes a big difference here.{-
-- | Like 'splitWith', except that sequences of adjacent separators are
-- treated as a single separator. eg.
--
-- > tokens (=='a') "aabbaca" == ["bb","c"]
--
tokens :: (Char -> Bool) -> ByteString -> [ByteString]
tokens f = B.tokens (f . w2c)
{-# INLINE tokens #-}
-}-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy-- | The 'groupBy' function is the non-overloaded version of 'group'.k = B.groupBy (\a b -> k (w2c a) (w2c b))
groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
groupBy-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0. = B.groupBy (\a b -> k (w2c a) (w2c b))
index :: ByteString -> Int -> Char
index-- | /O(1)/ 'ByteString' index (subscript) operator, starting from 0.= (w2c .) . B.index
index{-# INLINE:: ByteStringindex #-}-> Int -> Char
index = (w2c .) . B.index
{-# INLINE-- | /O(n)/ The 'elemIndex' function returns the index of the first #-}
-- element in the given 'ByteString' which is equal (by memchr) to the
-- query element, or 'Nothing' if there is no such element.-- | /O(n)/ The 'elemIndex' function returns the index of the first
elemIndex-- element in the given 'ByteString' which is equal (by memchr) to the:: Char -> ByteString -> Maybe Int
elemIndex-- query element, or 'Nothing' if there is no such element.= B.elemIndex . c2w
elemIndex{-# INLINE::elemIndex -> ByteString#-}        -> Maybe Int
elemIndex = B.elemIndex . c2w
{-# INLINE-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the #-}
-- element in the given 'ByteString' which is equal to the query
-- element, or 'Nothing' if there is no such element. The following-- | /O(n)/ The 'elemIndexEnd' function returns the last index of the
-- holds:-- element in the given 'ByteString' which is equal to the query
---- element, or 'Nothing' if there is no such element. The following
-- holds:-- > elemIndexEnd c xs ==
---- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
---- > elemIndexEnd c xs ==
elemIndexEnd-- > (-) (length xs - 1) `fmap` elemIndex c (reverse xs):: Char -> ByteString -> Maybe Int
--elemIndexEnd = B.elemIndexEnd . c2w
elemIndexEnd{-# INLINE elemIndexEnd:: Char -> ByteString#-}        -> Maybe Int
elemIndexEnd = B.elemIndexEnd . c2w
{-# INLINE-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning #-}
-- the indices of all elements equal to the query element, in ascending order.
elemIndices-- | /O(n)/ The 'elemIndices' function extends 'elemIndex', by returning:: Char -> ByteString -> [Int]
elemIndices-- the indices of all elements equal to the query element, in ascending order.= B.elemIndices . c2w
elemIndices{-# INLINE elemIndices:: Char -> ByteString#-}        -> [Int]
elemIndices = B.elemIndices . c2w
{-# INLINE-- | The 'findIndex' function takes a predicate and a 'ByteString' and #-}
-- returns the index of the first element in the ByteString satisfying the predicate.
findIndex-- | The 'findIndex' function takes a predicate and a 'ByteString' and:: (Char -> Bool) -> ByteString -> Maybe Int
findIndex-- returns the index of the first element in the ByteString satisfying the predicate.f = B.findIndex (f . w2c)
findIndex{-# INLINE::findIndexChar ->#-}) -> ByteString -> Maybe Int
findIndex f = B.findIndex (f . w2c)
{-# INLINE-- | The 'findIndices' function extends 'findIndex', by returning the #-}
-- indices of all elements satisfying the predicate, in ascending order.
findIndices-- | The 'findIndices' function extends 'findIndex', by returning the:: (Char -> Bool) -> ByteString -> [Int]
findIndices-- indices of all elements satisfying the predicate, in ascending order.f = B.findIndices (f . w2c)
findIndices :: (Char -> Bool) -> ByteString -> [Int]
findIndices-- | count returns the number of times its argument appears in the ByteString = B.findIndices (f . w2c)
--
-- > count = length . elemIndices-- | count returns the number of times its argument appears in the ByteString
--
-- Also-- > count = length . elemIndices
--
-- Also-- > count '\n' == length . lines
--
-- > count '\n' == length . lines-- But more efficiently than using length on the intermediate list.
--count :: Char -> ByteString -> Int
count-- But more efficiently than using length on the intermediate list.c = B.count (c2w c)
count :: Char -> ByteString -> Int
count-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This = B.count (c2w c)
-- implementation uses @memchr(3)@.
elem-- | /O(n)/ 'elem' is the 'ByteString' membership predicate. This:: Char -> ByteString -> Bool
elem-- implementation uses @memchr(3)@.c = B.elem (c2w c)
elem{-# INLINE:: Charelem-> ByteString#-}        -> Bool
elem    c = B.elem (c2w c)
{-# INLINE-- | /O(n)/ 'notElem' is the inverse of 'elem' #-}
notElem :: Char -> ByteString -> Bool
notElem-- | /O(n)/ 'notElem' is the inverse of 'elem'c = B.notElem (c2w c)
notElem{-# INLINE:: CharnotElem-> ByteString#-}        -> Bool
notElem c = B.notElem (c2w c)
{-# INLINE-- | /O(n)/ 'filter', applied to a predicate and a ByteString, #-}
-- returns a ByteString containing those characters that satisfy the
-- predicate.-- | /O(n)/ 'filter', applied to a predicate and a ByteString,
filter-- returns a ByteString containing those characters that satisfy the:: (Char -> Bool) -> ByteString -> ByteString
filter-- predicate.f = B.filter (f . w2c)
filter{-# INLINE:: (Charfilter->#-}) -> ByteString -> ByteString
filter f = B.filter (f . w2c)
{-# INLINE{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single Char. It is more
-- efficient to use /filterChar/ in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c ps = replicate (count c ps) c
{-# INLINE filterChar #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
    filter ((==) x) = filterChar x
"ByteString specialise filter (== x)" forall x.
    filter (== x) = filterChar x
  #-}
-}          #-}

{-
-- | /O(n)/ and /O(n\/c) space/ A first order equivalent of /filter .
-- (==)/, for the common case of filtering a single Char. It is more
-- efficient to use /filterChar/ in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c ps = replicate (count c ps) c
{-# INLINE filterChar #-}

{-# RULES
"ByteString specialise filter (== x)" forall x.
    filter ((==) x) = filterChar x
"ByteString specialise filter (== x)" forall x.
    filter (== x) = filterChar x
  #-}

-}
-- and returns the first element in matching the predicate, or 'Nothing'
-- if there is no such element.
find-- | /O(n)/ The 'find' function takes a predicate and a ByteString,:: (Char -> Bool) -> ByteString -> Maybe Char
find-- and returns the first element in matching the predicate, or 'Nothing'f ps = w2c `fmap` B.find (f . w2c) ps
{-# INLINE-- if there is no such element.find #-}
find :: (Char -> Bool) -> ByteString -> Maybe Char
find{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = B.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = B.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}    ps = w2c `fmap` B.find (f . w2c) ps
{-# INLINE find #-}

{-
-- | /O(n)/ A first order equivalent of /filter . (==)/, for the common
-- case of filtering a single Char. It is more efficient to use
-- filterChar in this case.
--
-- > filterChar == filter . (==)
--
-- filterChar is around 10x faster, and uses much less space, than its
-- filter equivalent
--
filterChar :: Char -> ByteString -> ByteString
filterChar c = B.filterByte (c2w c)
{-# INLINE filterChar #-}

-- | /O(n)/ A first order equivalent of /filter . (\/=)/, for the common
-- case of filtering a single Char out of a list. It is more efficient
-- to use /filterNotChar/ in this case.
--
-- > filterNotChar == filter . (/=)
--
-- filterNotChar is around 3x faster, and uses much less space, than its
-- filter equivalent
--
filterNotChar :: Char -> ByteString -> ByteString
filterNotChar c = B.filterNotByte (c2w c)
{-# INLINE filterNotChar #-}
-}
-- corresponding pairs of Chars. If one input ByteString is short,
-- excess elements of the longer ByteString are discarded. This is
-- equivalent to a pair of 'unpack' operations, and so space-- | /O(n)/ 'zip' takes two ByteStrings and returns a list of
-- usage may be large for multi-megabyte ByteStrings-- corresponding pairs of Chars. If one input ByteString is short,
zip-- excess elements of the longer ByteString are discarded. This is:: ByteString -> ByteString -> [(Char,Char)]
zip-- equivalent to a pair of 'unpack' operations, and so spaceps qs
-- usage may be large for multi-megabyte ByteStrings| B.null ps || B.null qs = []
zip ::| otherwise= ->(unsafeHeadps->, unsafeHead(Char,Charqs)] : zip (B.unsafeTail ps) (B.unsafeTail qs)
zip ps qs
-- | 'zipWith' generalises 'zip' by zipping with the function given as B.null ps || B.null qs = []
-- the first argument, instead of a tupling function.  For example, otherwise = (unsafeHead ps, unsafeHead qs) : zip (B.unsafeTail ps) (B.unsafeTail qs)
-- @'zipWith' (+)@ is applied to two ByteStrings to produce the list
-- of corresponding sums.-- | 'zipWith' generalises 'zip' by zipping with the function given as
zipWith-- the first argument, instead of a tupling function.  For example,:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith-- @'zipWith' (+)@ is applied to two ByteStrings to produce the listf = B.zipWith ((. w2c) . f . w2c)
-- of corresponding sums.
zipWith-- | 'unzip' transforms a list of pairs of Chars into a pair of:: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
zipWith-- ByteStrings. Note that this performs two 'pack' operations. = B.zipWith ((. w2c) . f . w2c)
unzip :: [(Char,Char)] -> (ByteString,ByteString)
unzip-- | 'unzip' transforms a list of pairs of Chars into a pair ofls = (pack (P.map fst ls), pack (P.map snd ls))
{-# INLINE-- ByteStrings. Note that this performs two 'pack' operations.unzip #-}
unzip :: [(Char,Char)] -> (ByteString,ByteString)
unzip-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits = (pack (P.map fst ls), pack (P.map snd ls))
{-# INLINE-- the check for the empty case, which is good for performance, but #-}
-- there is an obligation on the programmer to provide a proof that the
-- ByteString is non-empty.-- | A variety of 'head' for non-empty ByteStrings. 'unsafeHead' omits
unsafeHead-- the check for the empty case, which is good for performance, but:: ByteString -> Char
unsafeHead-- there is an obligation on the programmer to provide a proof that the= w2c . B.unsafeHead
{-# INLINE-- ByteString is non-empty.unsafeHead #-}
unsafeHead :: ByteString -> Char
unsafeHead-- ---------------------------------------------------------------------= w2c . B.unsafeHead
{-# INLINE-- Things that depend on the encoding #-}

{-# RULES-- ---------------------------------------------------------------------
-- Things that depend on the encoding"ByteString specialise break -> breakSpace"
    break isSpace = breakSpace
{-# RULES#-}
"ByteString specialise break -> breakSpace"
-- | 'breakSpace' returns the pair of ByteStrings when the argument is isSpace = breakSpace
-- broken at the first whitespace byte. I.e.#-}
--
-- > break isSpace == breakSpace
---- | 'breakSpace' returns the pair of ByteStrings when the argument is
breakSpace-- broken at the first whitespace byte. I.e.:: ByteString -> (ByteString,ByteString)
--breakSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
-- > break isSpace == breakSpacei <- firstspace (p `plusPtr` s) 0 l
--  return $! case () of {_
breakSpace| i::==ByteString0    -> (empty-> (ByteString, PS x s l,ByteString)
breakSpace| i(PS x s l)->=(inlinePerformIOPS x s l, empty)$ withForeignPtr x $ \p -> do
    i <-|firstspaceotherwise (->p `plusPtrPS x s `,s)PS0xl(s+i) (l-i))
    return}      $! case () of {_
{-# INLINE ibreakSpace 0    ->#-}empty, PS x s l)
        | i == l    -> (PS x s l, empty)
firstspace otherwise:: Ptr Word8-> (PS xInt i->, PSIntx->s+IOi)Intl-i))
STRICT3}  (firstspace)
{-# INLINE breakSpaceptr n m    #-}
    | n >= m    = return n
firstspace| otherwise:: Ptr= Word8do w <-->peekByteOff -> Int ->ptrIOn Int
firstspace a b c | a `ifseq(`not `seqisSpaceWord8` c `seq` False) w then= undefinedfirstspace ptr (n+1) m else return n
firstspace ptr n m
-- | 'dropSpace' efficiently returns the 'ByteString' argument with n >= m    = return n
-- white space Chars removed from the front. It is more efficient than otherwise = do w <- peekByteOff ptr n
                                                                 -- calling dropWhile for removing whitespace. I.e. (not . isSpaceWord8) w then firstspace ptr (n+1) m else return n
--
-- > dropWhile isSpace == dropSpace-- | 'dropSpace' efficiently returns the 'ByteString' argument with
---- white space Chars removed from the front. It is more efficient than
dropSpace-- calling dropWhile for removing whitespace. I.e.:: ByteString -> ByteString
--dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
-- > dropWhile isSpace == dropSpacei <- firstnonspace (p `plusPtr` s) 0 l
--  return $! if i == l then empty else PS x (s+i) (l-i)
dropSpace{-# INLINE::dropSpace#-}-> ByteString
dropSpace (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
firstnonspace <- firstnonspace:: Ptr Word8p `plusPtr-> Int `->s)Int l-> IO Int
STRICT3(firstnonspace if i ==)l then empty else PS x (s+i) (l-i)
{-# INLINEfirstnonspaceptr n m#-}
    | n >= m    = return n
firstnonspace| otherwise::=Ptrdo Word8w <- peekElemOff-> Int -> Intptr->n IO Int
firstnonspace a b c |if `isSpaceWord8seq` b `seq`wcthenseq`firstnonspace = undefinedptr (n+1) m else return n
firstnonspace ptr n m
{-
-- | 'dropSpaceEnd' efficiently returns the 'ByteString' argument with
-- white space removed from the end. I.e.
--
-- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
--
-- but it is more efficient than using multiple reverses.
--
dropSpaceEnd :: ByteString -> ByteString
dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- lastnonspace (p `plusPtr` s) (l-1)
    return $! if i == (-1) then empty else PS x s (i+1)
{-# INLINE dropSpaceEnd #-}

lastnonspace :: Ptr Word8 -> Int -> IO Int
STRICT2(lastnonspace)
lastnonspace ptr n
    | n < 0     = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
-}   n >= m    = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then firstnonspace ptr (n+1) m else return n

{-
-- | 'dropSpaceEnd' efficiently returns the 'ByteString' argument with
-- white space removed from the end. I.e.
--
-- > reverse . (dropWhile isSpace) . reverse == dropSpaceEnd
--
-- but it is more efficient than using multiple reverses.
--
dropSpaceEnd :: ByteString -> ByteString
dropSpaceEnd (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
    i <- lastnonspace (p `plusPtr` s) (l-1)
    return $! if i == (-1) then empty else PS x s (i+1)
{-# INLINE dropSpaceEnd #-}

lastnonspace :: Ptr Word8 -> Int -> IO Int
lastnonspace a b | a `seq` b `seq` False = undefined
lastnonspace ptr n
    | n < 0     = return n
    | otherwise = do w <- peekElemOff ptr n
                     if isSpaceWord8 w then lastnonspace ptr (n-1) else return n
-}
-- newline Chars. The resulting strings do not contain newlines.
--
lines :: ByteString -> [ByteString]
lines-- | 'lines' breaks a ByteString up into a list of ByteStrings atps
-- newline Chars. The resulting strings do not contain newlines.| null ps = []
--  | otherwise = case search ps of
lines :: ByteStringNothing->->[ByteString[ps]      ]
lines ps     Just n  -> take n ps : lines (drop (n+1) ps)
    |wheresearch = [] elemIndex '\n'
    | otherwise = case search ps of
{-
-- Just as fast, but more complex. Should be much faster, I thought.
lines :: ByteString -> [ByteString]
lines (PS _ _ 0) = []
lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
        let ptr = p `plusPtr` s

            STRICT1(loop)
            loop n = do
                let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
                if q == nullPtr
                    then return [PS x (s+n) (l-n)]
                    else do let i = q `minusPtr` ptr
                            ls <- loop (i+1)
                            return $! PS x (s+n) (i-n) : ls
        loop 0
-}            -> [ps]
             Just n  -> take n ps : lines (drop (n+1) ps)
    where search = elemIndex '\n'

{-
-- Just as fast, but more complex. Should be much faster, I thought.
lines :: ByteString -> [ByteString]
lines (PS _ _ 0) = []
lines (PS x s l) = inlinePerformIO $ withForeignPtr x $ \p -> do
        let ptr = p `plusPtr` s

            loop a | a `seq` False = undefined
            loop n = do
                let q = memchr (ptr `plusPtr` n) 0x0a (fromIntegral (l-n))
                if q == nullPtr
                    then return [PS x (s+n) (l-n)]
                    else do let i = q `minusPtr` ptr
                            ls <- loop (i+1)
                            return $! PS x (s+n) (i-n) : ls
        loop 0
-}
-- after appending a terminating newline to each.
unlines :: [ByteString] -> ByteString
unlines [] = empty
unlines-- | 'unlines' is an inverse operation to 'lines'.  It joins lines,ss = (concat $ List.intersperse nl ss) `append` nl -- half as much space
-- after appending a terminating newline to each.where nl = singleton '\n'
unlines :: [ByteString] -> ByteString
unlines-- | 'words' breaks a ByteString up into a list of words, which] = empty
unlines-- were delimited by Chars representing white space. = (concat $ List.intersperse nl ss) `append` nl -- half as much space
wordswhere:: ByteString = singleton-> [ByteString     ]
words = P.filter (not . B.null) . B.splitWith isSpaceWord8
{-# INLINE-- | 'words' breaks a ByteString up into a list of words, whichwords #-}
-- were delimited by Chars representing white space.
words-- | The 'unwords' function is analogous to the 'unlines' function, on words.:: ByteString -> [ByteString]
wordsunwords= P.filter:: [ByteStringnot . B.null-> ByteString) . B.splitWith isSpaceWord8
{-# INLINEunwords = intercalate #-}  (singleton ' ')
{-# INLINE unwords #-}
-- | The 'unwords' function is analogous to the 'unlines' function, on words.
unwords-- ---------------------------------------------------------------------:: [ByteString] -> ByteString

</pre>