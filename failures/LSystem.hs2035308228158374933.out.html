<a href="LSystem.hs14587779232007237709.out.html">prev</a></br><a href="failures.html">home</a></br><a href="LSystem.hs8235644401115438165.out.html">next</a></br></br><pre>37c37
< > f {- algae -} "A" [('A',"AB"),('B',"A")] 5 == "ABAABABAABAAB"
---
> > f {- algae  "A" [('A',"AB"),('B',"A")] 5 == "ABAABABAABAAB"
39d38
< > f {- cantor -} "A" [('A',"ABA"),('B',"BBB")] 3 == "ABABBBABABBBBBBBBBABABBBABA"
40c39
< > f {- koch -} "F" [('F',"F+F-F-F+F")] 2 == "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
---
> > f {- cantor  "A" [('A',"ABA"),('B',"BBB")] 3 == "ABABBBABABBBBBBBBBABABBBABA"
40a40
> > f {- koch  "F" [('F',"F+F-F-F+F")] 2 == "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
75a76
> 
</pre></br><h2>original</h2></br><pre>-- | Lindenmayer system definition, expander and renderer.
module LSystem.LSystem where

import Data.CG.Minus {- hcg-minus -}
import LSystem.Turtle
import qualified Data.Map as M

-- | Element of 'Axiom'.
type Element = Char

-- | An axiom (sequence of 'Elements').
type Axiom = [Element]

-- | A 'M.Map' from 'Element's to 'Axiom's.
type Rules = M.Map Element Axiom

-- | An 'LSystem' is an 'Axiom' and a set of 'Rules'.
data LSystem = LSystem Axiom Rules deriving (Eq,Show)

-- | L-System constructor.
--
-- > lSystem "F+F+F" [('F',"F-F+F")]
lSystem :: Axiom -> [(Element,[Element])] -> LSystem
lSystem a rs = LSystem a (M.fromList rs)

-- | Rule lookup.
getRule :: Rules -> Element -> [Element]
getRule rs c = M.findWithDefault [c] c rs

-- | Rule application.
applyRule :: [Element] -> Rules -> [Element]
applyRule a rs = concatMap (getRule rs) a

{- | /n/ iterations of the specified 'LSystem'.

> let f p q n = expand (lSystem p q) n
> f {- algae -} "A" [('A',"AB"),('B',"A")] 5 == "ABAABABAABAAB"
> f "0" [('1',"11"),('0',"1[0]0")] 3 == "1111[11[1[0]0]1[0]0]11[1[0]0]1[0]0"
> f {- cantor -} "A" [('A',"ABA"),('B',"BBB")] 3 == "ABABBBABABBBBBBBBBABABBBABA"
> f {- koch -} "F" [('F',"F+F-F-F+F")] 2 == "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
> f "F+F+F" [('F',"F-F+F")] 1 == "F-F+F+F-F+F+F-F+F"

-}
expand :: LSystem -> Int -> [Element]
expand (LSystem a rs) n =
    case n of
      0 -> a
      _ -> expand (LSystem (applyRule a rs) rs) (n - 1)

-- | State transformer 'Turtle' commands.
stateT :: Element -> Turtle -> Turtle
stateT e =
    case e of
      '+' -> turnRight
      '-' -> turnLeft
      '|' -> turnBack
      '>' -> incrLine
      '<' -> decrLine
      '[' -> push
      ']' -> pop
      'f' -> forward
      _   -> id

-- | Operational 'Turtle' commands.
cmd :: (Turtle -> b -> (Turtle,b)) -> Element -> Turtle -> b -> (Turtle,b)
cmd f e t i =
    case e of
      'F' -> f t i
      _ -> (stateT e t, i)

-- | Fold over an expanded L-system using standard turtle commands.
render :: b -> (b -> Pt R -> Pt R -> b) -> [Element] -> Turtle -> b
render i f l t =
    let g (u,j) c = cmd (stepTurtle f) c u j
    in snd (foldl g (t, i) l)
</pre></br><h2>printed</h2></br><pre>-- | Lindenmayer system definition, expander and renderer.
module LSystem.LSystem where

import Data.CG.Minus {- hcg-minus -}
import LSystem.Turtle
import qualified Data.Map as M

-- | Element of 'Axiom'.
type Element = Char

-- | An axiom (sequence of 'Elements').
type Axiom = [Element]

-- | A 'M.Map' from 'Element's to 'Axiom's.
type Rules = M.Map Element Axiom

-- | An 'LSystem' is an 'Axiom' and a set of 'Rules'.
data LSystem = LSystem Axiom Rules deriving (Eq,Show)

-- | L-System constructor.
--
-- > lSystem "F+F+F" [('F',"F-F+F")]
lSystem :: Axiom -> [(Element,[Element])] -> LSystem
lSystem a rs = LSystem a (M.fromList rs)

-- | Rule lookup.
getRule :: Rules -> Element -> [Element]
getRule rs c = M.findWithDefault [c] c rs

-- | Rule application.
applyRule :: [Element] -> Rules -> [Element]
applyRule a rs = concatMap (getRule rs) a

{- | /n/ iterations of the specified 'LSystem'.

> let f p q n = expand (lSystem p q) n
> f {- algae  "A" [('A',"AB"),('B',"A")] 5 == "ABAABABAABAAB"
> f "0" [('1',"11"),('0',"1[0]0")] 3 == "1111[11[1[0]0]1[0]0]11[1[0]0]1[0]0"
> f {- cantor  "A" [('A',"ABA"),('B',"BBB")] 3 == "ABABBBABABBBBBBBBBABABBBABA"
> f {- koch  "F" [('F',"F+F-F-F+F")] 2 == "F+F-F-F+F+F+F-F-F+F-F+F-F-F+F-F+F-F-F+F+F+F-F-F+F"
> f "F+F+F" [('F',"F-F+F")] 1 == "F-F+F+F-F+F+F-F+F"

-}
expand :: LSystem -> Int -> [Element]
expand (LSystem a rs) n =
    case n of
      0 -> a
      _ -> expand (LSystem (applyRule a rs) rs) (n - 1)

-- | State transformer 'Turtle' commands.
stateT :: Element -> Turtle -> Turtle
stateT e =
    case e of
      '+' -> turnRight
      '-' -> turnLeft
      '|' -> turnBack
      '>' -> incrLine
      '<' -> decrLine
      '[' -> push
      ']' -> pop
      'f' -> forward
      _   -> id

-- | Operational 'Turtle' commands.
cmd :: (Turtle -> b -> (Turtle,b)) -> Element -> Turtle -> b -> (Turtle,b)
cmd f e t i =
    case e of
      'F' -> f t i
      _ -> (stateT e t, i)

-- | Fold over an expanded L-system using standard turtle commands.
render :: b -> (b -> Pt R -> Pt R -> b) -> [Element] -> Turtle -> b
render i f l t =
    let g (u,j) c = cmd (stepTurtle f) c u j
    in snd (foldl g (t, i) l)

</pre>