<a href="Tests.hs12893357351755699915.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Tests.hs1462789551711192801.out.html">next</a></br></br><pre>15c15
<                  in foldl (\vec -> \(i,e) -> SVM.insert vec i e) zeroes $ zip [0..(length vals-1)] vals
---
>                  in foldl (\vec ->        ->(i,e) -> SVM.insert vec i e) zeroes $ zip [0..(length vals-1)] vals
67a68
> 
</pre></br><h2>original</h2></br><pre>module Main(main) where
import Test.HUnit
import qualified Control.Parallel.ScanVectorMachine.ScanVectorMachine as SVM
import Control.Parallel.ScanVectorMachine.SerialScanVectorMachine
import System.Exit

ones :: SSVM Int
ones = SVM.distribute 1 20

count :: SSVM Int
count = SVM.scan SVM.Plus ones

mkLiteral :: [Int] -> SSVM Int
mkLiteral vals = let zeroes = SVM.distribute 0 (length vals)
                 in foldl (\vec -> \(i,e) -> SVM.insert vec i e) zeroes $ zip [0..(length vals-1)] vals


example_a = mkLiteral [5,1,3,4,3,9,2,6]
example_b = mkLiteral [2,5,3,8,1,3,6,2]
example_f = mkLiteral [1,0,0,0,1,1,0,1]
example_i = mkLiteral [2,5,4,3,1,6,0,7]

main = do result <-
              runTestTT $ TestList
                            -- section 4.1.2 of Blelloch's book
                            [  TestCase $ assertEqual "Ble90 4.1.2: A+B"
                                            "[7,6,6,12,4,12,8,8]"
                                            $ show $ SVM.op SVM.Plus example_a example_b
                            ,  TestCase $ assertEqual "Ble90 4.1.2: A*B"
                                            "[10,5,9,32,3,27,12,12]"
                                            $ show $ SVM.op SVM.Times example_a example_b
                            ,  TestCase $ assertEqual "Ble90 4.1.2: select(F,A,B)"
                                            "[5,5,3,8,3,9,6,6]"
                                            $ show $ SVM.select example_f example_a example_b

                            -- section 4.1.3 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.3: permute(A,I)"
                                            "[-6,-4,0,-3,-2,-1,-5,-7]"
                                            $ show $ SVM.permute (mkLiteral [0,-1,-2,-3,-4,-5,-6,-7]) example_i

                            -- section 4.1.4 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.4: A"
                                            "[5,1,3,4,3,9,2,6]"
                                            $ show example_a
                            ,  TestCase $ assertEqual "Ble90 4.1.4: +-scan(A)"
                                            "[0,5,6,9,13,16,25,27]"
                                            $ show $ SVM.scan SVM.Plus example_a
                            ,  TestCase $ assertEqual "Ble90 4.1.4: max-scan(A)"
                                            "[0,5,5,5,5,5,9,9]"
                                            $ show $ SVM.scan SVM.Max example_a

                            -- section 4.1.5 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.5: insert(A,3,999)"
                                            "[5,1,3,999,3,9,2,6]"
                                            $ show $ SVM.insert example_a 3 999
                            ,  TestCase $ assertEqual "Ble90 4.1.5: extract(A,3)"
                                            "4"
                                            $ show $ SVM.extract example_a 3
                            ,  TestCase $ assertEqual "Ble90 4.1.5: distribute(999,5)"
                                            "[999,999,999,999,999]"
                                            $ show $ (SVM.distribute 999 5 :: SSVM Int)
                            ,  TestCase $ assertEqual "Ble90 4.1.5: length(A)"
                                            "8"
                                            $ show $ SVM.length example_a
                            ]
          let bad = errors result + failures result
          System.Exit.exitWith $ if bad == 0 then ExitSuccess else ExitFailure bad
</pre></br><h2>printed</h2></br><pre>module Main(main) where
import Test.HUnit
import qualified Control.Parallel.ScanVectorMachine.ScanVectorMachine as SVM
import Control.Parallel.ScanVectorMachine.SerialScanVectorMachine
import System.Exit

ones :: SSVM Int
ones = SVM.distribute 1 20

count :: SSVM Int
count = SVM.scan SVM.Plus ones

mkLiteral :: [Int] -> SSVM Int
mkLiteral vals = let zeroes = SVM.distribute 0 (length vals)
                 in foldl (\vec ->        ->(i,e) -> SVM.insert vec i e) zeroes $ zip [0..(length vals-1)] vals


example_a = mkLiteral [5,1,3,4,3,9,2,6]
example_b = mkLiteral [2,5,3,8,1,3,6,2]
example_f = mkLiteral [1,0,0,0,1,1,0,1]
example_i = mkLiteral [2,5,4,3,1,6,0,7]

main = do result <-
              runTestTT $ TestList
                            -- section 4.1.2 of Blelloch's book
                            [  TestCase $ assertEqual "Ble90 4.1.2: A+B"
                                            "[7,6,6,12,4,12,8,8]"
                                            $ show $ SVM.op SVM.Plus example_a example_b
                            ,  TestCase $ assertEqual "Ble90 4.1.2: A*B"
                                            "[10,5,9,32,3,27,12,12]"
                                            $ show $ SVM.op SVM.Times example_a example_b
                            ,  TestCase $ assertEqual "Ble90 4.1.2: select(F,A,B)"
                                            "[5,5,3,8,3,9,6,6]"
                                            $ show $ SVM.select example_f example_a example_b

                            -- section 4.1.3 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.3: permute(A,I)"
                                            "[-6,-4,0,-3,-2,-1,-5,-7]"
                                            $ show $ SVM.permute (mkLiteral [0,-1,-2,-3,-4,-5,-6,-7]) example_i

                            -- section 4.1.4 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.4: A"
                                            "[5,1,3,4,3,9,2,6]"
                                            $ show example_a
                            ,  TestCase $ assertEqual "Ble90 4.1.4: +-scan(A)"
                                            "[0,5,6,9,13,16,25,27]"
                                            $ show $ SVM.scan SVM.Plus example_a
                            ,  TestCase $ assertEqual "Ble90 4.1.4: max-scan(A)"
                                            "[0,5,5,5,5,5,9,9]"
                                            $ show $ SVM.scan SVM.Max example_a

                            -- section 4.1.5 of Blelloch's book
                            ,  TestCase $ assertEqual "Ble90 4.1.5: insert(A,3,999)"
                                            "[5,1,3,999,3,9,2,6]"
                                            $ show $ SVM.insert example_a 3 999
                            ,  TestCase $ assertEqual "Ble90 4.1.5: extract(A,3)"
                                            "4"
                                            $ show $ SVM.extract example_a 3
                            ,  TestCase $ assertEqual "Ble90 4.1.5: distribute(999,5)"
                                            "[999,999,999,999,999]"
                                            $ show $ (SVM.distribute 999 5 :: SSVM Int)
                            ,  TestCase $ assertEqual "Ble90 4.1.5: length(A)"
                                            "8"
                                            $ show $ SVM.length example_a
                            ]
          let bad = errors result + failures result
          System.Exit.exitWith $ if bad == 0 then ExitSuccess else ExitFailure bad

</pre>