<a href="Monadic.hs10447881241927702196.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Monads.hs144128232716531729.out.html">next</a></br></br><pre>26c26
< genericLength ∷ (Monad m, Num n) ⇒ Stream m α → m n
---
> genericLength :: (Monad m, Num n) => Stream m α -> m n
28c28
< genericLength = foldl' (\n _ → n+1) 0
---
> genericLength = foldl' (\n _ -> n+1) 0
30c30
< genericTake ∷ (Monad m, Integral n) ⇒ n → Stream m α → Stream m α
---
> genericTake :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
32c32
< {-# RULES "genericTake → take" genericTake = take #-}
---
> {-# RULES "genericTake \8594 take" genericTake = take #-}
38c38
<               = do r ← step s
---
>               = do r <- step s
40d39
<                      Yield α s' → return $ Yield α (s', i+1)
41d39
<                      Skip    s' → return $ Skip    (s', i  )
42c40
<                      Done       → return Done
---
>                      Yield α s' -> return $ Yield α (s', i+1)
42a41
>                      Skip    s' -> return $ Skip    (s', i  )
42a42
>                      Done       -> return Done
46c46
< genericDrop ∷ (Monad m, Integral n) ⇒ n → Stream m α → Stream m α
---
> genericDrop :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
48c48
< {-# RULES "genericDrop → drop" genericDrop = drop #-}
---
> {-# RULES "genericDrop \8594 drop" genericDrop = drop #-}
54c54
<               = do r ← step s
---
>               = do r <- step s
56d55
<                      Yield _ s' → return $ Skip (s', Just (n-1))
57d55
<                      Skip    s' → return $ Skip (s', Just n)
58c56
<                      Done       → return Done
---
>                      Yield _ s' -> return $ Skip (s', Just (n-1))
58a57
>                      Skip    s' -> return $ Skip (s', Just n)
58a58
>                      Done       -> return Done
63c63
<           = do r ← step s
---
>           = do r <- step s
65d64
<                  Yield α s' → return $ Yield α (s', Nothing)
66d64
<                  Skip    s' → return $ Skip    (s', Nothing)
67c65
<                  Done       → return Done
---
>                  Yield α s' -> return $ Yield α (s', Nothing)
67a66
>                  Skip    s' -> return $ Skip    (s', Nothing)
67a67
>                  Done       -> return Done
69c69
< genericIndex ∷ (Monad m, Integral n, Show n) ⇒ Stream m α → n → m α
---
> genericIndex :: (Monad m, Integral n, Show n) => Stream m α -> n -> m α
71c71
< {-# RULES "genericIndex → (!!)" genericIndex = (!!) #-}
---
> {-# RULES "genericIndex \8594 (!!)" genericIndex = (!!) #-}
78c78
<           = do r ← step s
---
>           = do r <- step s
81d80
<                      | i ≡ i0    → return α
82d80
<                      | otherwise → index_loop s' (i+1)
83d80
<                  Skip    s'      → index_loop s' i
84c81
<                  Done            → fail ("genericIndex: out of range: " ⧺ show i)
---
>                      | i ≡ i0    -> return α
84a82
>                      | otherwise -> index_loop s' (i+1)
84a83
>                  Skip    s'      -> index_loop s' i
84a84
>                  Done            -> fail ("genericIndex: out of range: " ⧺ show i)
86c86
< genericReplicate ∷ (Monad m, Integral n) ⇒ n → α → Stream m α
---
> genericReplicate :: (Monad m, Integral n) => n -> α -> Stream m α
90c90
< genericReplicateM ∷ (Monad m, Integral n) ⇒ n → m α → Stream m α
---
> genericReplicateM :: (Monad m, Integral n) => n -> m α -> Stream m α
92c92
< {-# RULES "genericReplicateM → replicateM" genericReplicateM = replicateM #-}
---
> {-# RULES "genericReplicateM \8594 replicateM" genericReplicateM = replicateM #-}
97c97
<            | otherwise = do α ← mα
---
>            | otherwise = do α <- mα
100c100
< genericUnfoldrN ∷ (Monad m, Integral n) ⇒ n → (β → Maybe (α, β)) → β → Stream m α
---
> genericUnfoldrN :: (Monad m, Integral n) => n -> (β -> Maybe (α, β)) -> β -> Stream m α
104c104
< genericUnfoldrNM ∷ (Monad m, Integral n) ⇒ n → (β → m (Maybe (α, β))) → β → Stream m α
---
> genericUnfoldrNM :: (Monad m, Integral n) => n -> (β -> m (Maybe (α, β))) -> β -> Stream m α
106c106
< {-# RULES "genericUnfoldrNM → unfoldrNM" genericUnfoldrNM = unfoldrNM #-}
---
> {-# RULES "genericUnfoldrNM \8594 unfoldrNM" genericUnfoldrNM = unfoldrNM #-}
112d111
<           | otherwise = do r ← f β
113c112
<                            return $ do (α, β') ← r
---
>           | otherwise = do r <- f β
113a113
>                            return $ do (α, β') <- r
116c116
< genericFindIndex ∷ (Monad m, Integral n) ⇒ (α → Bool) → Stream m α → m (Maybe n)
---
> genericFindIndex :: (Monad m, Integral n) => (α -> Bool) -> Stream m α -> m (Maybe n)
120c120
< genericFindIndexM ∷ (Monad m, Integral n) ⇒ (α → m Bool) → Stream m α → m (Maybe n)
---
> genericFindIndexM :: (Monad m, Integral n) => (α -> m Bool) -> Stream m α -> m (Maybe n)
122c122
< {-# RULES "genericFindIndexM → findIndexM" genericFindIndexM = findIndexM #-}
---
> {-# RULES "genericFindIndexM \8594 findIndexM" genericFindIndexM = findIndexM #-}
127c127
<           = do r ← step s
---
>           = do r <- step s
129d128
<                  Yield α s' → do b ← f α
130d128
<                                  if b then return $ Just i
131d128
<                                       else findIndex_loop s' (i+1)
132d128
<                  Skip    s' → findIndex_loop s' i
133c129
<                  Done       → return Nothing
---
>                  Yield α s' -> do b <- f α
133a130
>                                   if b then return $ Just i
133a131
>                                        else findIndex_loop s' (i+1)
133a132
>                  Skip    s' -> findIndex_loop s' i
133a133
>                  Done       -> return Nothing
135c135
< genericIndexed ∷ (Monad m, Integral n) ⇒ Stream m α → Stream m (n, α)
---
> genericIndexed :: (Monad m, Integral n) => Stream m α -> Stream m (n, α)
137c137
< {-# RULES "genericIndexed → indexed" genericIndexed = indexed #-}
---
> {-# RULES "genericIndexed \8594 indexed" genericIndexed = indexed #-}
142c142
<           = do r ← step s
---
>           = do r <- step s
144d143
<                  Yield α s' → return $ Yield (i, α) (s', i+1)
145d143
<                  Skip    s' → return $ Skip         (s', i  )
146c144
<                  Done       → return Done
---
>                  Yield α s' -> return $ Yield (i, α) (s', i+1)
146a145
>                  Skip    s' -> return $ Skip         (s', i  )
146a146
>                  Done       -> return Done
146a147
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , UnicodeSyntax
  #-}
-- | Some functions currently missing from
-- "Data.Vector.Fusion.Stream.Monadic".
module Data.Bitstream.Fusion.Monadic
    ( genericLength
    , genericTake
    , genericDrop
    , genericIndex
    , genericReplicate
    , genericReplicateM
    , genericUnfoldrN
    , genericUnfoldrNM
    , genericFindIndex
    , genericFindIndexM
    , genericIndexed
    )
    where
import Data.Vector.Fusion.Stream.Monadic
import Data.Vector.Fusion.Stream.Size
import Prelude hiding ((!!), drop, replicate, take)
import Prelude.Unicode

genericLength ∷ (Monad m, Num n) ⇒ Stream m α → m n
{-# INLINE genericLength #-}
genericLength = foldl' (\n _ → n+1) 0

genericTake ∷ (Monad m, Integral n) ⇒ n → Stream m α → Stream m α
{-# INLINE [0] genericTake #-}
{-# RULES "genericTake → take" genericTake = take #-}
genericTake n (Stream step s0 sz) = Stream step' (s0, 0) (toMax sz)
    where
      {-# INLINE step' #-}
      step' (s, i)
          | i < n
              = do r ← step s
                   case r of
                     Yield α s' → return $ Yield α (s', i+1)
                     Skip    s' → return $ Skip    (s', i  )
                     Done       → return Done
          | otherwise
              = return Done

genericDrop ∷ (Monad m, Integral n) ⇒ n → Stream m α → Stream m α
{-# INLINE [0] genericDrop #-}
{-# RULES "genericDrop → drop" genericDrop = drop #-}
genericDrop n0 (Stream step s0 sz) = Stream step' (s0, Just n0) (toMax sz)
    where
      {-# INLINE step' #-}
      step' (s, Just n)
          | n > 0
              = do r ← step s
                   case r of
                     Yield _ s' → return $ Skip (s', Just (n-1))
                     Skip    s' → return $ Skip (s', Just n)
                     Done       → return Done
          | otherwise
              = return $ Skip (s, Nothing)

      step' (s, Nothing)
          = do r ← step s
               case r of
                 Yield α s' → return $ Yield α (s', Nothing)
                 Skip    s' → return $ Skip    (s', Nothing)
                 Done       → return Done

genericIndex ∷ (Monad m, Integral n, Show n) ⇒ Stream m α → n → m α
{-# INLINE [0] genericIndex #-}
{-# RULES "genericIndex → (!!)" genericIndex = (!!) #-}
genericIndex (Stream step s0 _) i0
    | i0 < 0    = fail ("genericIndex: out of range: " ⧺ show i0)
    | otherwise = index_loop s0 0
    where
      {-# INLINE index_loop #-}
      index_loop s i
          = do r ← step s
               case r of
                 Yield α s'
                     | i ≡ i0    → return α
                     | otherwise → index_loop s' (i+1)
                 Skip    s'      → index_loop s' i
                 Done            → fail ("genericIndex: out of range: " ⧺ show i)

genericReplicate ∷ (Monad m, Integral n) ⇒ n → α → Stream m α
{-# INLINE genericReplicate #-}
genericReplicate n = genericReplicateM n ∘ return

genericReplicateM ∷ (Monad m, Integral n) ⇒ n → m α → Stream m α
{-# INLINE [0] genericReplicateM #-}
{-# RULES "genericReplicateM → replicateM" genericReplicateM = replicateM #-}
genericReplicateM n0 mα = unfoldrM go n0
    where
      {-# INLINE go #-}
      go n | n ≤ 0     = return Nothing
           | otherwise = do α ← mα
                            return $ Just (α, n-1)

genericUnfoldrN ∷ (Monad m, Integral n) ⇒ n → (β → Maybe (α, β)) → β → Stream m α
{-# INLINE genericUnfoldrN #-}
genericUnfoldrN n f = genericUnfoldrNM n (return ∘ f)

genericUnfoldrNM ∷ (Monad m, Integral n) ⇒ n → (β → m (Maybe (α, β))) → β → Stream m α
{-# INLINE [0] genericUnfoldrNM #-}
{-# RULES "genericUnfoldrNM → unfoldrNM" genericUnfoldrNM = unfoldrNM #-}
genericUnfoldrNM n0 f β0 = unfoldrM go (n0, β0)
    where
      {-# INLINE go #-}
      go (!n, β)
          | n ≤ 0     = return Nothing
          | otherwise = do r ← f β
                           return $ do (α, β') ← r
                                       return (α, (n-1, β'))

genericFindIndex ∷ (Monad m, Integral n) ⇒ (α → Bool) → Stream m α → m (Maybe n)
{-# INLINE genericFindIndex #-}
genericFindIndex f = genericFindIndexM (return ∘ f)

genericFindIndexM ∷ (Monad m, Integral n) ⇒ (α → m Bool) → Stream m α → m (Maybe n)
{-# INLINE [0] genericFindIndexM #-}
{-# RULES "genericFindIndexM → findIndexM" genericFindIndexM = findIndexM #-}
genericFindIndexM f (Stream step s0 _) = findIndex_loop s0 0
    where
      {-# INLINE findIndex_loop #-}
      findIndex_loop s i
          = do r ← step s
               case r of
                 Yield α s' → do b ← f α
                                 if b then return $ Just i
                                      else findIndex_loop s' (i+1)
                 Skip    s' → findIndex_loop s' i
                 Done       → return Nothing

genericIndexed ∷ (Monad m, Integral n) ⇒ Stream m α → Stream m (n, α)
{-# INLINE [0] genericIndexed #-}
{-# RULES "genericIndexed → indexed" genericIndexed = indexed #-}
genericIndexed (Stream step s0 sz) = Stream step' (s0, 0) sz
    where
      {-# INLINE step' #-}
      step' (s, i)
          = do r ← step s
               case r of
                 Yield α s' → return $ Yield (i, α) (s', i+1)
                 Skip    s' → return $ Skip         (s', i  )
                 Done       → return Done
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
    BangPatterns
  , UnicodeSyntax
  #-}
-- | Some functions currently missing from
-- "Data.Vector.Fusion.Stream.Monadic".
module Data.Bitstream.Fusion.Monadic
    ( genericLength
    , genericTake
    , genericDrop
    , genericIndex
    , genericReplicate
    , genericReplicateM
    , genericUnfoldrN
    , genericUnfoldrNM
    , genericFindIndex
    , genericFindIndexM
    , genericIndexed
    )
    where
import Data.Vector.Fusion.Stream.Monadic
import Data.Vector.Fusion.Stream.Size
import Prelude hiding ((!!), drop, replicate, take)
import Prelude.Unicode

genericLength :: (Monad m, Num n) => Stream m α -> m n
{-# INLINE genericLength #-}
genericLength = foldl' (\n _ -> n+1) 0

genericTake :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
{-# INLINE [0] genericTake #-}
{-# RULES "genericTake \8594 take" genericTake = take #-}
genericTake n (Stream step s0 sz) = Stream step' (s0, 0) (toMax sz)
    where
      {-# INLINE step' #-}
      step' (s, i)
          | i < n
              = do r <- step s
                   case r of
                     Yield α s' -> return $ Yield α (s', i+1)
                     Skip    s' -> return $ Skip    (s', i  )
                     Done       -> return Done
          | otherwise
              = return Done

genericDrop :: (Monad m, Integral n) => n -> Stream m α -> Stream m α
{-# INLINE [0] genericDrop #-}
{-# RULES "genericDrop \8594 drop" genericDrop = drop #-}
genericDrop n0 (Stream step s0 sz) = Stream step' (s0, Just n0) (toMax sz)
    where
      {-# INLINE step' #-}
      step' (s, Just n)
          | n > 0
              = do r <- step s
                   case r of
                     Yield _ s' -> return $ Skip (s', Just (n-1))
                     Skip    s' -> return $ Skip (s', Just n)
                     Done       -> return Done
          | otherwise
              = return $ Skip (s, Nothing)

      step' (s, Nothing)
          = do r <- step s
               case r of
                 Yield α s' -> return $ Yield α (s', Nothing)
                 Skip    s' -> return $ Skip    (s', Nothing)
                 Done       -> return Done

genericIndex :: (Monad m, Integral n, Show n) => Stream m α -> n -> m α
{-# INLINE [0] genericIndex #-}
{-# RULES "genericIndex \8594 (!!)" genericIndex = (!!) #-}
genericIndex (Stream step s0 _) i0
    | i0 < 0    = fail ("genericIndex: out of range: " ⧺ show i0)
    | otherwise = index_loop s0 0
    where
      {-# INLINE index_loop #-}
      index_loop s i
          = do r <- step s
               case r of
                 Yield α s'
                     | i ≡ i0    -> return α
                     | otherwise -> index_loop s' (i+1)
                 Skip    s'      -> index_loop s' i
                 Done            -> fail ("genericIndex: out of range: " ⧺ show i)

genericReplicate :: (Monad m, Integral n) => n -> α -> Stream m α
{-# INLINE genericReplicate #-}
genericReplicate n = genericReplicateM n ∘ return

genericReplicateM :: (Monad m, Integral n) => n -> m α -> Stream m α
{-# INLINE [0] genericReplicateM #-}
{-# RULES "genericReplicateM \8594 replicateM" genericReplicateM = replicateM #-}
genericReplicateM n0 mα = unfoldrM go n0
    where
      {-# INLINE go #-}
      go n | n ≤ 0     = return Nothing
           | otherwise = do α <- mα
                            return $ Just (α, n-1)

genericUnfoldrN :: (Monad m, Integral n) => n -> (β -> Maybe (α, β)) -> β -> Stream m α
{-# INLINE genericUnfoldrN #-}
genericUnfoldrN n f = genericUnfoldrNM n (return ∘ f)

genericUnfoldrNM :: (Monad m, Integral n) => n -> (β -> m (Maybe (α, β))) -> β -> Stream m α
{-# INLINE [0] genericUnfoldrNM #-}
{-# RULES "genericUnfoldrNM \8594 unfoldrNM" genericUnfoldrNM = unfoldrNM #-}
genericUnfoldrNM n0 f β0 = unfoldrM go (n0, β0)
    where
      {-# INLINE go #-}
      go (!n, β)
          | n ≤ 0     = return Nothing
          | otherwise = do r <- f β
                           return $ do (α, β') <- r
                                       return (α, (n-1, β'))

genericFindIndex :: (Monad m, Integral n) => (α -> Bool) -> Stream m α -> m (Maybe n)
{-# INLINE genericFindIndex #-}
genericFindIndex f = genericFindIndexM (return ∘ f)

genericFindIndexM :: (Monad m, Integral n) => (α -> m Bool) -> Stream m α -> m (Maybe n)
{-# INLINE [0] genericFindIndexM #-}
{-# RULES "genericFindIndexM \8594 findIndexM" genericFindIndexM = findIndexM #-}
genericFindIndexM f (Stream step s0 _) = findIndex_loop s0 0
    where
      {-# INLINE findIndex_loop #-}
      findIndex_loop s i
          = do r <- step s
               case r of
                 Yield α s' -> do b <- f α
                                  if b then return $ Just i
                                       else findIndex_loop s' (i+1)
                 Skip    s' -> findIndex_loop s' i
                 Done       -> return Nothing

genericIndexed :: (Monad m, Integral n) => Stream m α -> Stream m (n, α)
{-# INLINE [0] genericIndexed #-}
{-# RULES "genericIndexed \8594 indexed" genericIndexed = indexed #-}
genericIndexed (Stream step s0 sz) = Stream step' (s0, 0) sz
    where
      {-# INLINE step' #-}
      step' (s, i)
          = do r <- step s
               case r of
                 Yield α s' -> return $ Yield (i, α) (s', i+1)
                 Skip    s' -> return $ Skip         (s', i  )
                 Done       -> return Done

</pre>