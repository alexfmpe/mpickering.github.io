<a href="Parser.hs13418536351808266298.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Parser.hs178448449274243042.out.html">next</a></br></br><pre>20c20
< strip ∷  String → String
---
> strip ::  String -> String
25c25
< pSpace ∷ TParser Char
---
> pSpace :: TParser Char
28c28
< pSpace' ∷ TParser String
---
> pSpace' :: TParser String
33c33
< pSpaces ∷ TParser String
---
> pSpaces :: TParser String
36c36
< pDeps ∷ TParser [String]
---
> pDeps :: TParser [String]
39c39
<     ws ← (many1 $ noneOf ",)\n\r") `sepBy` (char ',')
---
>     ws <- (many1 $ noneOf ",)\n\r") `sepBy` (char ',')
43c43
< pTags ∷ TParser [String]
---
> pTags :: TParser [String]
45c45
<     ts ← between (char '[') (char ']') $ word `sepBy1` pSpace
---
>     ts <- between (char '[') (char ']') $ word `sepBy1` pSpace
51c51
< pItem ∷ String → DateTime → TParser TodoItem
---
> pItem :: String -> DateTime -> TParser TodoItem
53c53
<     pr ← if null prefix
---
>     pr <- if null prefix
56c56
<                 w ← many1 (noneOf " \t\n\r")
---
>                 w <- many1 (noneOf " \t\n\r")
60d59
<     pos ← getPosition
61d59
<     s ← pSpaces
62d59
<     conf ← getState
63c60
<     stat ← if skipStatus conf
---
>     pos <- getPosition
63a61
>     s <- pSpaces
63a62
>     conf <- getState
63a63
>     stat <- if skipStatus conf
65d64
<                     Just fs → return fs
66c65
<                     Nothing → return "*"
---
>                     Just fs -> return fs
66a66
>                     Nothing -> return "*"
68c68
<                 rs ← pWord
---
>                 rs <- pWord
70d69
<                   Just fs → return fs
71d69
<                   Nothing → return rs
72d69
<     dates ← (try (pSpecDates date) <|> return [])
73d69
<     tags ← (try pTags <|> return [])
74c70
<     namew ← many1 pWord
---
>                   Just fs -> return fs
74a71
>                   Nothing -> return rs
74a72
>     dates <- (try (pSpecDates date) <|> return [])
74a73
>     tags <- (try pTags <|> return [])
74a74
>     namew <- many1 pWord
76c76
<     deps ← (try pDeps <|> return [])
---
>     deps <- (try pDeps <|> return [])
78c78
<     descr ← many (noneOf "\n\r")
---
>     descr <- many (noneOf "\n\r")
96c96
< pWord ∷ TParser String
---
> pWord :: TParser String
98c98
<     w ← many1 (noneOf " \t\n\r")
---
>     w <- many1 (noneOf " \t\n\r")
102c102
< pItems ∷ String → DateTime → TParser [TodoItem]
---
> pItems :: String -> DateTime -> TParser [TodoItem]
104c104
<   its ← many (pItem prefix date)
---
>   its <- many (pItem prefix date)
108c108
< unwords' ∷  String → [String] → String
---
> unwords' ::  String -> [String] -> String
113d112
<         [] → hd
114c113
<         _  → hd ⧺ "    {" ⧺ unwords addLines ⧺ "}"
---
>         [] -> hd
114a114
>         _  -> hd ⧺ "    {" ⧺ unwords addLines ⧺ "}"
116c116
< filterN ∷ (Num a, Enum a) ⇒ Int → String → [String] → ([a], [String])
---
> filterN :: (Num a, Enum a) => Int -> String -> [String] -> ([a], [String])
122c122
<       ans = map (unwords' prefix) [sub j n lst | j ← lns]
---
>       ans = map (unwords' prefix) [sub j n lst | j <- lns]
127c127
< makeRE ∷ String → String
---
> makeRE :: String -> String
130c130
< filterJoin ∷ Int → String → String → ([Int], String)
---
> filterJoin :: Int -> String -> String -> ([Int], String)
136d135
< parsePlain ∷ BaseConfig
137d135
<            → DateTime   -- ^ Current date/time
138d135
<            → SourceName -- ^ Source file name
139d135
<            → String     -- ^ String to parse
140c136
<            → [TodoItem]
---
> parsePlain :: BaseConfig
140a137
>            -> DateTime   -- ^ Current date/time
140a138
>            -> SourceName -- ^ Source file name
140a139
>            -> String     -- ^ String to parse
140a140
>            -> [TodoItem]
143d142
<       Right items → items
144c143
<       Left e → error $ show e
---
>       Right items -> items
144a144
>       Left e -> error $ show e
147d146
< parseAlternate ∷ BaseConfig
148d146
<                → Int        -- ^ Number of lines after matching to include to item's description
149d146
<                → String     -- ^ Prefix to match
150d146
<                → DateTime   -- ^ Current date/time
151d146
<                → SourceName -- ^ Source file name
152d146
<                → String     -- ^ String to parse
153c147
<                → [TodoItem]
---
> parseAlternate :: BaseConfig
153a148
>                -> Int        -- ^ Number of lines after matching to include to item's description
153a149
>                -> String     -- ^ Prefix to match
153a150
>                -> DateTime   -- ^ Current date/time
153a151
>                -> SourceName -- ^ Source file name
153a152
>                -> String     -- ^ String to parse
153a153
>                -> [TodoItem]
159d158
<        Right items → renumber items
160c159
<        Left e      → error $ show e
---
>        Right items -> renumber items
160a160
>        Left e      -> error $ show e
161a162
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, NoMonomorphismRestriction, TypeSynonymInstances, DeriveDataTypeable #-}
module Todos.Parser
    (parsePlain, parseAlternate)
    where

import Prelude hiding (putStrLn,readFile,getContents,print)
import Prelude.Unicode
import Data.List
import Text.Parsec
import Data.Char
import Data.Dates
import Text.Regex.PCRE

import Todos.Types
import Todos.Dates
import Todos.Config

type TParser a = Parsec String BaseConfig a

strip ∷  String → String
strip = reverse ∘ p ∘ reverse ∘ p
  where
    p = dropWhile isSpace

pSpace ∷ TParser Char
pSpace = oneOf " \t"

pSpace' ∷ TParser String
pSpace' = do
    pSpace
    return " "

pSpaces ∷ TParser String
pSpaces = many pSpace

pDeps ∷ TParser [String]
pDeps = do
    string "("
    ws ← (many1 $ noneOf ",)\n\r") `sepBy` (char ',')
    string ")"
    return $ map strip ws

pTags ∷ TParser [String]
pTags = do
    ts ← between (char '[') (char ']') $ word `sepBy1` pSpace
    pSpaces
    return ts
  where
    word = many1 (noneOf " \t\n\r]")

pItem ∷ String → DateTime → TParser TodoItem
pItem prefix date = do
    pr ← if null prefix
           then return ""
           else do
                w ← many1 (noneOf " \t\n\r")
                if w =~ prefix
                  then return w
                  else fail $ "Internal error: invalid prefix: " ⧺ w ⧺ " =~ " ⧺ prefix
    pos ← getPosition
    s ← pSpaces
    conf ← getState
    stat ← if skipStatus conf
            then case forcedStatus conf of
                    Just fs → return fs
                    Nothing → return "*"
            else do
                rs ← pWord
                case forcedStatus conf of
                  Just fs → return fs
                  Nothing → return rs
    dates ← (try (pSpecDates date) <|> return [])
    tags ← (try pTags <|> return [])
    namew ← many1 pWord
    pSpaces
    deps ← (try pDeps <|> return [])
    pSpaces
    descr ← many (noneOf "\n\r")
    pSpaces
    many $ oneOf "\n\r"
    return $ Item {
        itemLevel = fromIntegral $ length s,
        itemPrefix = pr,
        itemName = unwords namew,
        itemTags = tags,
        depends = deps,
        itemStatus = stat,
        itemDescr = descr,
        startDate = lookup StartDate dates,
        endDate = lookup EndDate dates,
        deadline = lookup Deadline dates,
        fileName = sourceName pos,
        lineNr = sourceLine pos,
        itemNumber = 0}

pWord ∷ TParser String
pWord = do
    w ← many1 (noneOf " \t\n\r")
    (try pSpace') <|> (return w)
    return w

pItems ∷ String → DateTime → TParser [TodoItem]
pItems prefix date = do
  its ← many (pItem prefix date)
  eof
  return its

unwords' ∷  String → [String] → String
unwords' prefix lst =
  let (hd:tl) = map (filter (/='\r')) lst
      addLines = filter (not ∘ (prefix `isPrefixOf`)) tl
  in  case addLines of
        [] → hd
        _  → hd ⧺ "    {" ⧺ unwords addLines ⧺ "}"

filterN ∷ (Num a, Enum a) ⇒ Int → String → [String] → ([a], [String])
filterN n prefix lst =
  let zipped = zip [0..] lst
      good   = filter (isGood ∘ snd) zipped
      lns    = map fst good
      sub k l = (take l) ∘ (drop k)
      ans = map (unwords' prefix) [sub j n lst | j ← lns]
      regex = makeRE prefix
      isGood x = x =~ regex
  in (map (+1) lns, ans)

makeRE ∷ String → String
makeRE x = "^(" ⧺ x ⧺ ")"

filterJoin ∷ Int → String → String → ([Int], String)
filterJoin n prefix str =
  let (ns, lns) = filterN n prefix (lines str)
  in  (ns, unlines lns)

-- | Read list of TODO items from plain format
parsePlain ∷ BaseConfig
           → DateTime   -- ^ Current date/time
           → SourceName -- ^ Source file name
           → String     -- ^ String to parse
           → [TodoItem]
parsePlain conf date path text =
  case runParser (pItems "" date) conf path text of
      Right items → items
      Left e → error $ show e

-- | Read list of TODO items from alternate format
parseAlternate ∷ BaseConfig
               → Int        -- ^ Number of lines after matching to include to item's description
               → String     -- ^ Prefix to match
               → DateTime   -- ^ Current date/time
               → SourceName -- ^ Source file name
               → String     -- ^ String to parse
               → [TodoItem]
parseAlternate conf next prefix date path text =
  let (ns, filtered) = filterJoin next prefix text
      renumber lst = zipWith renumber1 ns lst
      renumber1 n item = item {lineNr=n}
  in case runParser (pItems (makeRE prefix) date) conf path filtered of
       Right items → renumber items
       Left e      → error $ show e

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, NoMonomorphismRestriction, TypeSynonymInstances, DeriveDataTypeable #-}
module Todos.Parser
    (parsePlain, parseAlternate)
    where

import Prelude hiding (putStrLn,readFile,getContents,print)
import Prelude.Unicode
import Data.List
import Text.Parsec
import Data.Char
import Data.Dates
import Text.Regex.PCRE

import Todos.Types
import Todos.Dates
import Todos.Config

type TParser a = Parsec String BaseConfig a

strip ::  String -> String
strip = reverse ∘ p ∘ reverse ∘ p
  where
    p = dropWhile isSpace

pSpace :: TParser Char
pSpace = oneOf " \t"

pSpace' :: TParser String
pSpace' = do
    pSpace
    return " "

pSpaces :: TParser String
pSpaces = many pSpace

pDeps :: TParser [String]
pDeps = do
    string "("
    ws <- (many1 $ noneOf ",)\n\r") `sepBy` (char ',')
    string ")"
    return $ map strip ws

pTags :: TParser [String]
pTags = do
    ts <- between (char '[') (char ']') $ word `sepBy1` pSpace
    pSpaces
    return ts
  where
    word = many1 (noneOf " \t\n\r]")

pItem :: String -> DateTime -> TParser TodoItem
pItem prefix date = do
    pr <- if null prefix
           then return ""
           else do
                w <- many1 (noneOf " \t\n\r")
                if w =~ prefix
                  then return w
                  else fail $ "Internal error: invalid prefix: " ⧺ w ⧺ " =~ " ⧺ prefix
    pos <- getPosition
    s <- pSpaces
    conf <- getState
    stat <- if skipStatus conf
            then case forcedStatus conf of
                    Just fs -> return fs
                    Nothing -> return "*"
            else do
                rs <- pWord
                case forcedStatus conf of
                  Just fs -> return fs
                  Nothing -> return rs
    dates <- (try (pSpecDates date) <|> return [])
    tags <- (try pTags <|> return [])
    namew <- many1 pWord
    pSpaces
    deps <- (try pDeps <|> return [])
    pSpaces
    descr <- many (noneOf "\n\r")
    pSpaces
    many $ oneOf "\n\r"
    return $ Item {
        itemLevel = fromIntegral $ length s,
        itemPrefix = pr,
        itemName = unwords namew,
        itemTags = tags,
        depends = deps,
        itemStatus = stat,
        itemDescr = descr,
        startDate = lookup StartDate dates,
        endDate = lookup EndDate dates,
        deadline = lookup Deadline dates,
        fileName = sourceName pos,
        lineNr = sourceLine pos,
        itemNumber = 0}

pWord :: TParser String
pWord = do
    w <- many1 (noneOf " \t\n\r")
    (try pSpace') <|> (return w)
    return w

pItems :: String -> DateTime -> TParser [TodoItem]
pItems prefix date = do
  its <- many (pItem prefix date)
  eof
  return its

unwords' ::  String -> [String] -> String
unwords' prefix lst =
  let (hd:tl) = map (filter (/='\r')) lst
      addLines = filter (not ∘ (prefix `isPrefixOf`)) tl
  in  case addLines of
        [] -> hd
        _  -> hd ⧺ "    {" ⧺ unwords addLines ⧺ "}"

filterN :: (Num a, Enum a) => Int -> String -> [String] -> ([a], [String])
filterN n prefix lst =
  let zipped = zip [0..] lst
      good   = filter (isGood ∘ snd) zipped
      lns    = map fst good
      sub k l = (take l) ∘ (drop k)
      ans = map (unwords' prefix) [sub j n lst | j <- lns]
      regex = makeRE prefix
      isGood x = x =~ regex
  in (map (+1) lns, ans)

makeRE :: String -> String
makeRE x = "^(" ⧺ x ⧺ ")"

filterJoin :: Int -> String -> String -> ([Int], String)
filterJoin n prefix str =
  let (ns, lns) = filterN n prefix (lines str)
  in  (ns, unlines lns)

-- | Read list of TODO items from plain format
parsePlain :: BaseConfig
           -> DateTime   -- ^ Current date/time
           -> SourceName -- ^ Source file name
           -> String     -- ^ String to parse
           -> [TodoItem]
parsePlain conf date path text =
  case runParser (pItems "" date) conf path text of
      Right items -> items
      Left e -> error $ show e

-- | Read list of TODO items from alternate format
parseAlternate :: BaseConfig
               -> Int        -- ^ Number of lines after matching to include to item's description
               -> String     -- ^ Prefix to match
               -> DateTime   -- ^ Current date/time
               -> SourceName -- ^ Source file name
               -> String     -- ^ String to parse
               -> [TodoItem]
parseAlternate conf next prefix date path text =
  let (ns, filtered) = filterJoin next prefix text
      renumber lst = zipWith renumber1 ns lst
      renumber1 n item = item {lineNr=n}
  in case runParser (pItems (makeRE prefix) date) conf path filtered of
       Right items -> renumber items
       Left e      -> error $ show e


</pre>