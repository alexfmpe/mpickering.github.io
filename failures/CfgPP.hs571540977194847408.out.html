<a href="BuiltinSizeInfo.hs21187978011060806853.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Char.hs2035308228158374933.out.html">next</a></br></br><pre>19c19
< {-# LINE 39 "src/ehc/Base/CfgPP.chs" #-}
---
> 
19a20
> 
19a21
> 
19a22
> 
19a23
> 
19a24
> 
19a25
> 
19a26
> 
19a27
> 
19a28
> 
19a29
> 
19a30
> 
19a31
> 
19a32
> 
19a33
> 
19a34
> 
19a35
> 
19a36
> 
19a37
> 
19a38
> 
25c44
< {-# LINE 50 "src/ehc/Base/CfgPP.chs" #-}
---
> 
25a45
> 
25a46
> 
25a47
> 
25a48
> 
25a49
> 
47c71
< {-# LINE 73 "src/ehc/Base/CfgPP.chs" #-}
---
> 
47a72
> 
53c78
< {-# LINE 80 "src/ehc/Base/CfgPP.chs" #-}
---
> 
53a79
> 
56c82
< {-# LINE 84 "src/ehc/Base/CfgPP.chs" #-}
---
> 
56a83
> 
70c97
< {-# LINE 99 "src/ehc/Base/CfgPP.chs" #-}
---
> 
70a98
> 
76c104
< {-# LINE 106 "src/ehc/Base/CfgPP.chs" #-}
---
> 
76a105
> 
80c109
< {-# LINE 115 "src/ehc/Base/CfgPP.chs" #-}
---
> 
80a110
> 
80a111
> 
80a112
> 
80a113
> 
80a114
> 
84c118
< {-# LINE 124 "src/ehc/Base/CfgPP.chs" #-}
---
> 
84a119
> 
84a120
> 
84a121
> 
84a122
> 
84a123
> 
94c133
< {-# LINE 139 "src/ehc/Base/CfgPP.chs" #-}
---
> 
94a134
> 
94a135
> 
94a136
> 
94a137
> 
94a138
> 
111c155
< {-# LINE 157 "src/ehc/Base/CfgPP.chs" #-}
---
> 
111a156
> 
116a162
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Base.CfgPP
( ppScanoptsNm
, CfgPP (..)
, CfgPP_Plain (..), CfgPP_Core (..), CfgPP_Grin (..), CfgPP_TyCore (..)
, ppCoreNm
, ppCTag', ppCTagExtensive'
, ppCTagsMp )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName
import UHC.Light.Compiler.Opts.Base
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Scanner.Common
import Data.Char
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Util.ScanUtils

{-# LINE 39 "src/ehc/Base/CfgPP.chs" #-}
-- | Prettyprint 'HsName' with scanopts, taking care of properly escaping based on scan info (used when parsing)
ppScanoptsNm :: ScanOpts -> HsName -> PP_Doc
ppScanoptsNm copts n = fst $ ppHsnEscapeWith '$' (hsnOkChars '$' $ copts) (hsnNotOkStrs copts) (`Set.member` leaveAsIs) n
    where leaveAsIs = Set.fromList [hsnRowEmpty]

{-# LINE 50 "src/ehc/Base/CfgPP.chs" #-}
class CfgPP x where
  cfgppHsName       :: x -> HsName -> PP_Doc
  cfgppConHsName    :: x -> HsName -> PP_Doc
  cfgppUID          :: x -> UID    -> PP_Doc
  cfgppVarHsName    :: x -> Maybe HsName -> Maybe UID -> Maybe Int -> Maybe PP_Doc -> PP_Doc
  cfgppVarHsNameFallback
                    :: x -> Maybe HsName -> Maybe UID -> Maybe Int -> Maybe PP_Doc -> PP_Doc
  cfgppFollowAST    :: x -> Bool
  cfgppTyPPVarDflt  :: x -> String -> UID -> Maybe PP_Doc -> PP_Doc

  cfgppHsName    _                          = pp
  cfgppConHsName _                          = ppCon
  cfgppUID       _                          = pp
  cfgppVarHsName x mn mu mi mp              = cfgppVarHsNameFallback x mn mu mi mp
  cfgppVarHsNameFallback x _ _ _ (Just p)   = p
  cfgppVarHsNameFallback x _ _ (Just i) _   = cfgppHsName x $ mkHNm $ tnUniqRepr i
  cfgppVarHsNameFallback x (Just n) _ _ _   = cfgppHsName x n
  cfgppVarHsNameFallback x _ (Just u) _ _   = cfgppUID x u
  cfgppFollowAST _                          = False
  cfgppTyPPVarDflt                          = \x pre tv mbpp -> cfgppVarHsName x (Just $ mkHNm $ pre ++ "_" ++ show tv) (Just tv) Nothing mbpp

{-# LINE 73 "src/ehc/Base/CfgPP.chs" #-}
data CfgPP_Plain   = CfgPP_Plain
data CfgPP_Core    = CfgPP_Core
data CfgPP_TyCore  = CfgPP_TyCore
data CfgPP_Grin    = CfgPP_Grin

{-# LINE 80 "src/ehc/Base/CfgPP.chs" #-}
instance CfgPP CfgPP_Plain

{-# LINE 84 "src/ehc/Base/CfgPP.chs" #-}
instance CfgPP CfgPP_Core where
  {-
  cfgppHsName    _ n                = fst $ ppHsnEscapeWith '$' (hsnOkChars '$' $ copts) (hsnNotOkStrs copts) (`Set.member` leaveAsIs) n
    where copts = coreScanOpts emptyEHCOpts
          leaveAsIs = Set.fromList [hsnRowEmpty]
  -}
  cfgppHsName    _ n                = ppScanoptsNm (coreScanOpts emptyEHCOpts) n
  cfgppConHsName                    = cfgppHsName
  cfgppFollowAST                    = const True
  cfgppUID _       u                = ppUIDParseable u
  cfgppVarHsName x _ (Just u) _ _   = cfgppUID x u
  cfgppVarHsName x mn mu mi mp      = cfgppVarHsNameFallback x mn mu mi mp

{-# LINE 99 "src/ehc/Base/CfgPP.chs" #-}
ppNmTyCore = ppHsnEscaped (Right $ Set.fromList ['0'..'9']) '$' (hsnEscapeeChars '$' tycoreScanOpts)

instance CfgPP CfgPP_TyCore where
  cfgppHsName    _ = ppNmTyCore

{-# LINE 106 "src/ehc/Base/CfgPP.chs" #-}
instance CfgPP CfgPP_Grin where
  cfgppHsName    _ = ppHsnNonAlpha grinScanOpts

{-# LINE 115 "src/ehc/Base/CfgPP.chs" #-}
ppCoreNm :: HsName -> PP_Doc
ppCoreNm = cfgppHsName CfgPP_Core

{-# LINE 124 "src/ehc/Base/CfgPP.chs" #-}
tnUniqRepr :: Int -> String
tnUniqRepr
  = lrepr
  where lrepr i = if i <= 26
                  then  [repr i]
                  else  let  (d,r) = i `divMod` 26
                        in   (repr d : lrepr r)
        repr    = (chr . (97+))

{-# LINE 139 "src/ehc/Base/CfgPP.chs" #-}
-- intended for parsing
ppCTag' :: CfgPP x => x -> CTag -> PP_Doc
ppCTag' x t
  = case t of
      CTagRec                      -> ppCurly "Rec"
      CTag ty nm tag arity mxarity -> ppCurlysCommas' [ppNm ty, ppNm nm, pp tag {- , pp arity, pp mxarity -}]
  where ppNm n = cfgppHsName x n

-- intended for parsing
ppCTagExtensive' :: CfgPP x => x -> CTag -> PP_Doc
ppCTagExtensive' x t
  = case t of
      CTagRec                      -> ppCurly "Rec"
      CTag ty nm tag arity mxarity -> ppCurlysCommas' [ppNm ty, ppNm nm, pp tag, pp arity, pp mxarity]
  where ppNm n = cfgppHsName x n

{-# LINE 157 "src/ehc/Base/CfgPP.chs" #-}
ppCTagsMp :: CfgPP x => x -> CTagsMp -> PP_Doc
ppCTagsMp x
  = mkl (mkl (ppCTag' x))
  where mkl pe = ppCurlysSemisBlock . map (\(n,e) -> cfgppHsName x n >-< indent 1 ("=" >#< pe e))

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Base.CfgPP
( ppScanoptsNm
, CfgPP (..)
, CfgPP_Plain (..), CfgPP_Core (..), CfgPP_Grin (..), CfgPP_TyCore (..)
, ppCoreNm
, ppCTag', ppCTagExtensive'
, ppCTagsMp )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName
import UHC.Light.Compiler.Opts.Base
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Scanner.Common
import Data.Char
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Util.ScanUtils





















-- | Prettyprint 'HsName' with scanopts, taking care of properly escaping based on scan info (used when parsing)
ppScanoptsNm :: ScanOpts -> HsName -> PP_Doc
ppScanoptsNm copts n = fst $ ppHsnEscapeWith '$' (hsnOkChars '$' $ copts) (hsnNotOkStrs copts) (`Set.member` leaveAsIs) n
    where leaveAsIs = Set.fromList [hsnRowEmpty]







class CfgPP x where
  cfgppHsName       :: x -> HsName -> PP_Doc
  cfgppConHsName    :: x -> HsName -> PP_Doc
  cfgppUID          :: x -> UID    -> PP_Doc
  cfgppVarHsName    :: x -> Maybe HsName -> Maybe UID -> Maybe Int -> Maybe PP_Doc -> PP_Doc
  cfgppVarHsNameFallback
                    :: x -> Maybe HsName -> Maybe UID -> Maybe Int -> Maybe PP_Doc -> PP_Doc
  cfgppFollowAST    :: x -> Bool
  cfgppTyPPVarDflt  :: x -> String -> UID -> Maybe PP_Doc -> PP_Doc

  cfgppHsName    _                          = pp
  cfgppConHsName _                          = ppCon
  cfgppUID       _                          = pp
  cfgppVarHsName x mn mu mi mp              = cfgppVarHsNameFallback x mn mu mi mp
  cfgppVarHsNameFallback x _ _ _ (Just p)   = p
  cfgppVarHsNameFallback x _ _ (Just i) _   = cfgppHsName x $ mkHNm $ tnUniqRepr i
  cfgppVarHsNameFallback x (Just n) _ _ _   = cfgppHsName x n
  cfgppVarHsNameFallback x _ (Just u) _ _   = cfgppUID x u
  cfgppFollowAST _                          = False
  cfgppTyPPVarDflt                          = \x pre tv mbpp -> cfgppVarHsName x (Just $ mkHNm $ pre ++ "_" ++ show tv) (Just tv) Nothing mbpp



data CfgPP_Plain   = CfgPP_Plain
data CfgPP_Core    = CfgPP_Core
data CfgPP_TyCore  = CfgPP_TyCore
data CfgPP_Grin    = CfgPP_Grin



instance CfgPP CfgPP_Plain



instance CfgPP CfgPP_Core where
  {-
  cfgppHsName    _ n                = fst $ ppHsnEscapeWith '$' (hsnOkChars '$' $ copts) (hsnNotOkStrs copts) (`Set.member` leaveAsIs) n
    where copts = coreScanOpts emptyEHCOpts
          leaveAsIs = Set.fromList [hsnRowEmpty]
  -}
  cfgppHsName    _ n                = ppScanoptsNm (coreScanOpts emptyEHCOpts) n
  cfgppConHsName                    = cfgppHsName
  cfgppFollowAST                    = const True
  cfgppUID _       u                = ppUIDParseable u
  cfgppVarHsName x _ (Just u) _ _   = cfgppUID x u
  cfgppVarHsName x mn mu mi mp      = cfgppVarHsNameFallback x mn mu mi mp



ppNmTyCore = ppHsnEscaped (Right $ Set.fromList ['0'..'9']) '$' (hsnEscapeeChars '$' tycoreScanOpts)

instance CfgPP CfgPP_TyCore where
  cfgppHsName    _ = ppNmTyCore



instance CfgPP CfgPP_Grin where
  cfgppHsName    _ = ppHsnNonAlpha grinScanOpts







ppCoreNm :: HsName -> PP_Doc
ppCoreNm = cfgppHsName CfgPP_Core







tnUniqRepr :: Int -> String
tnUniqRepr
  = lrepr
  where lrepr i = if i <= 26
                  then  [repr i]
                  else  let  (d,r) = i `divMod` 26
                        in   (repr d : lrepr r)
        repr    = (chr . (97+))







-- intended for parsing
ppCTag' :: CfgPP x => x -> CTag -> PP_Doc
ppCTag' x t
  = case t of
      CTagRec                      -> ppCurly "Rec"
      CTag ty nm tag arity mxarity -> ppCurlysCommas' [ppNm ty, ppNm nm, pp tag {- , pp arity, pp mxarity -}]
  where ppNm n = cfgppHsName x n

-- intended for parsing
ppCTagExtensive' :: CfgPP x => x -> CTag -> PP_Doc
ppCTagExtensive' x t
  = case t of
      CTagRec                      -> ppCurly "Rec"
      CTag ty nm tag arity mxarity -> ppCurlysCommas' [ppNm ty, ppNm nm, pp tag, pp arity, pp mxarity]
  where ppNm n = cfgppHsName x n



ppCTagsMp :: CfgPP x => x -> CTagsMp -> PP_Doc
ppCTagsMp x
  = mkl (mkl (ppCTag' x))
  where mkl pe = ppCurlysSemisBlock . map (\(n,e) -> cfgppHsName x n >-< indent 1 ("=" >#< pe e))


</pre>