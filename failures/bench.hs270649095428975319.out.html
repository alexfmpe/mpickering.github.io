<a href="bench.hs20516216091606946231.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Bench.hs8849367161807130337.out.html">next</a></br></br><pre>41c41
< -}
---
> 
78a79
> 
</pre></br><h2>original</h2></br><pre>-----------------------------------------------------------------------------
-- |
-- Module      :
-- Copyright   :  (c) Marcel Fourné 20[09..13]
-- License     :  BSD3
-- Maintainer  :  Marcel Fourné (hecc@bitrot.dyndns.org)
--
-- benchmarking playground, not production quality
-- recommended:
-- $ ghc --make -O2 -feager-blackholing -fforce-recomp -fllvm -threaded bench.hs
-- best performance measured with just 1 thread
--
-----------------------------------------------------------------------------
{-# OPTIONS_GHC -O2 -fllvm -optlo-O3 -feager-blackholing -fforce-recomp #-}
{-# LANGUAGE ScopedTypeVariables #-}

import Codec.Crypto.ECC.Base
import Codec.Crypto.ECC.StandardCurves
import Control.Monad.Random
import Criterion
import Criterion.Main
-- import Data.Serialize
import qualified Data.F2 as F2

testfkt:: ECPF Integer -> Integer -> Int -> ECPF Integer
testfkt b k' n  = pmul b ((toInteger (n-n)) + k')

main::IO ()
main = do
{-
    let p = ECPp (ECi (stdc_l p256) (stdc_a p256) (stdc_b p256) (stdc_p p256) (stdc_r p256)) (stdc_xp p256) (stdc_yp p256) 1
--        k' = 78260987815077071890976764339238653408132491773166348437934213365482899760747
--        k' = 2^254+2^253+2^252+2^251+2^250+2^249
--        k' = 2^254+2^200+2^150+2^100+2^50+1
    k' <- evalRandIO $ getRandomR (1,stdc_p p256)
    defaultMain [ bench "NIST P-256" $ whnf (testfkt p k') 10]
{-
    case ((decode . encode) p) of
      Left msg -> print msg
      Right (pt::(ECPF Integer)) -> print pt
-}
-- -}
{-
    let p = ECPp (ECi (stdc_l p521, stdc_a p521, stdc_b p521,stdc_p p521,stdc_r p521),stdc_xp p521,stdc_yp p521,1)
--        k' = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984
    k' <- evalRandIO $ getRandomR (1,stdc_p p521)
    defaultMain [
            bench "NIST P-521" $ whnf (testfkt p k') 10
           ]
-- -}
-- {-
    let p = ECPpF2 (ECb (stdcF_l b283) (stdcF_a b283) (stdcF_b b283) (stdcF_p b283) (stdcF_r b283)) (stdcF_xp b283) (stdcF_yp b283) (fromInteger 1)
--        k' = 115792089210356248762697446949407573529996955224135760342422259061068512044368
--        k' = 2
--        k' = 3
        k' = 2^282
--    print p
--    print (pdouble p)
--    print $ modinv (F2.fromInteger 4) (F2.fromInteger 7)
    print $ pmul p k'
--    print $ ison p
-- -}

-- for this one the prerequisites are not ready
{-
    let p = 6277101735386680763835789423207666416083908700390324961279
        a = 6277101735386680763835789423207666416083908700390324961276
        b = 2455155546008943817740293915197451784769108058161191238065
        c = EC (a,b,p)
        x = 602046282375688656758213480587526111916698976636884684818
        y = 174050332293622031404857552280219410364023488927386650641
        alpha = EPa (x,y)
        kprivA = 5114103500503308041454439524093827019673558354999860770782
        kprivB = 1748161650263518407976227277807126651450677841379957675747
    in defaultMain [
            bench "ecdh" $ print [ (x,y)|x <-[1], y <- [(ecdh c alpha kprivA kprivB)]]
           ]
-- -}
</pre></br><h2>printed</h2></br><pre>-----------------------------------------------------------------------------
-- |
-- Module      :
-- Copyright   :  (c) Marcel Fourné 20[09..13]
-- License     :  BSD3
-- Maintainer  :  Marcel Fourné (hecc@bitrot.dyndns.org)
--
-- benchmarking playground, not production quality
-- recommended:
-- $ ghc --make -O2 -feager-blackholing -fforce-recomp -fllvm -threaded bench.hs
-- best performance measured with just 1 thread
--
-----------------------------------------------------------------------------
{-# OPTIONS_GHC -O2 -fllvm -optlo-O3 -feager-blackholing -fforce-recomp #-}
{-# LANGUAGE ScopedTypeVariables #-}

import Codec.Crypto.ECC.Base
import Codec.Crypto.ECC.StandardCurves
import Control.Monad.Random
import Criterion
import Criterion.Main
-- import Data.Serialize
import qualified Data.F2 as F2

testfkt:: ECPF Integer -> Integer -> Int -> ECPF Integer
testfkt b k' n  = pmul b ((toInteger (n-n)) + k')

main::IO ()
main = do
{-
    let p = ECPp (ECi (stdc_l p256) (stdc_a p256) (stdc_b p256) (stdc_p p256) (stdc_r p256)) (stdc_xp p256) (stdc_yp p256) 1
--        k' = 78260987815077071890976764339238653408132491773166348437934213365482899760747
--        k' = 2^254+2^253+2^252+2^251+2^250+2^249
--        k' = 2^254+2^200+2^150+2^100+2^50+1
    k' <- evalRandIO $ getRandomR (1,stdc_p p256)
    defaultMain [ bench "NIST P-256" $ whnf (testfkt p k') 10]
{-
    case ((decode . encode) p) of
      Left msg -> print msg
      Right (pt::(ECPF Integer)) -> print pt

-- -}
{-
    let p = ECPp (ECi (stdc_l p521, stdc_a p521, stdc_b p521,stdc_p p521,stdc_r p521),stdc_xp p521,stdc_yp p521,1)
--        k' = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984
    k' <- evalRandIO $ getRandomR (1,stdc_p p521)
    defaultMain [
            bench "NIST P-521" $ whnf (testfkt p k') 10
           ]
-- -}
-- {-
    let p = ECPpF2 (ECb (stdcF_l b283) (stdcF_a b283) (stdcF_b b283) (stdcF_p b283) (stdcF_r b283)) (stdcF_xp b283) (stdcF_yp b283) (fromInteger 1)
--        k' = 115792089210356248762697446949407573529996955224135760342422259061068512044368
--        k' = 2
--        k' = 3
        k' = 2^282
--    print p
--    print (pdouble p)
--    print $ modinv (F2.fromInteger 4) (F2.fromInteger 7)
    print $ pmul p k'
--    print $ ison p
-- -}

-- for this one the prerequisites are not ready
{-
    let p = 6277101735386680763835789423207666416083908700390324961279
        a = 6277101735386680763835789423207666416083908700390324961276
        b = 2455155546008943817740293915197451784769108058161191238065
        c = EC (a,b,p)
        x = 602046282375688656758213480587526111916698976636884684818
        y = 174050332293622031404857552280219410364023488927386650641
        alpha = EPa (x,y)
        kprivA = 5114103500503308041454439524093827019673558354999860770782
        kprivB = 1748161650263518407976227277807126651450677841379957675747
    in defaultMain [
            bench "ecdh" $ print [ (x,y)|x <-[1], y <- [(ecdh c alpha kprivA kprivB)]]
           ]
-- -}

</pre>