<a href="Dim4.hs823378840143542612.out.html">prev</a></br><a href="failures.html">home</a></br><a href="DisplayGraph.hs16807282475249.out.html">next</a></br></br><pre>73c73
<             bci_STKCHECK -> do
---
>             1bci_STKCHECK do      -> do
76c76
<             bci_PUSH_L -> do
---
>             2bci_PUSH_L do    -> do
79c79
<             bci_PUSH_LL -> do
---
>             3bci_PUSH_LL do     -> do
83c83
<             bci_PUSH_LLL -> do
---
>             4bci_PUSH_LLL do      -> do
88c88
<             bci_PUSH_G -> do
---
>             5bci_PUSH_G do    -> do
91c91
<             bci_PUSH_ALTS -> do
---
>             6bci_PUSH_ALTS do       -> do
94c94
<             bci_PUSH_ALTS_P -> do
---
>             7bci_PUSH_ALTS_P do         -> do
97c97
<             bci_PUSH_ALTS_N -> do
---
>             8bci_PUSH_ALTS_N do         -> do
100c100
<             bci_PUSH_ALTS_F -> do
---
>             9bci_PUSH_ALTS_F do         -> do
103c103
<             bci_PUSH_ALTS_D -> do
---
>             10bci_PUSH_ALTS_D do        -> do
106c106
<             bci_PUSH_ALTS_L -> do
---
>             11bci_PUSH_ALTS_L do        -> do
109c109
<             bci_PUSH_ALTS_V -> do
---
>             12bci_PUSH_ALTS_V do        -> do
112c112
<             bci_PUSH_UBX -> do
---
>             13bci_PUSH_UBX do     -> do
115c115
<             bci_PUSH_APPLY_N -> do
---
>             14bci_PUSH_APPLY_N do         -> do
117c117
<             bci_PUSH_APPLY_F -> do
---
>             15bci_PUSH_APPLY_F do         -> do
119c119
<             bci_PUSH_APPLY_D -> do
---
>             16bci_PUSH_APPLY_D do         -> do
121c121
<             bci_PUSH_APPLY_L -> do
---
>             17bci_PUSH_APPLY_L do         -> do
123c123
<             bci_PUSH_APPLY_V -> do
---
>             18bci_PUSH_APPLY_V do         -> do
125c125
<             bci_PUSH_APPLY_P -> do
---
>             19bci_PUSH_APPLY_P do         -> do
127c127
<             bci_PUSH_APPLY_PP -> do
---
>             20bci_PUSH_APPLY_PP do          -> do
129c129
<             bci_PUSH_APPLY_PPP -> do
---
>             21bci_PUSH_APPLY_PPP do           -> do
131c131
<             bci_PUSH_APPLY_PPPP -> do
---
>             22bci_PUSH_APPLY_PPPP do            -> do
133c133
<             bci_PUSH_APPLY_PPPPP -> do
---
>             23bci_PUSH_APPLY_PPPPP do             -> do
135c135
<             bci_PUSH_APPLY_PPPPPP -> do
---
>             24bci_PUSH_APPLY_PPPPPP do              -> do
137c137
<             bci_SLIDE -> do
---
>             26bci_SLIDE do  -> do
141c141
<             bci_ALLOC_AP -> do
---
>             27bci_ALLOC_AP do     -> do
144c144
<             bci_ALLOC_AP_NOUPD -> do
---
>             28bci_ALLOC_AP_NOUPD do           -> do
147c147
<             bci_ALLOC_PAP -> do
---
>             29bci_ALLOC_PAP do      -> do
151c151
<             bci_MKAP -> do
---
>             30bci_MKAP do -> do
155c155
<             bci_MKPAP -> do
---
>             31bci_MKPAP do  -> do
159c159
<             bci_UNPACK -> do
---
>             32bci_UNPACK do   -> do
162c162
<             bci_PACK -> do
---
>             33bci_PACK do -> do
166c166
<             bci_TESTLT_I -> do
---
>             34bci_TESTLT_I do     -> do
170c170
<             bci_TESTEQ_I -> do
---
>             35bci_TESTEQ_I do     -> do
174c174
<             bci_TESTLT_W -> do
---
>             55bci_TESTLT_W do     -> do
178c178
<             bci_TESTEQ_W -> do
---
>             56bci_TESTEQ_W do     -> do
182c182
<             bci_TESTLT_F -> do
---
>             36bci_TESTLT_F do     -> do
186c186
<             bci_TESTEQ_F -> do
---
>             37bci_TESTEQ_F do     -> do
190c190
<             bci_TESTLT_D -> do
---
>             38bci_TESTLT_D do     -> do
194c194
<             bci_TESTEQ_D -> do
---
>             39bci_TESTEQ_D do     -> do
198c198
<             bci_TESTLT_P -> do
---
>             40bci_TESTLT_P do     -> do
202c202
<             bci_TESTEQ_P -> do
---
>             41bci_TESTEQ_P do     -> do
206c206
<             bci_CASEFAIL -> do
---
>             42bci_CASEFAIL do     -> do
208c208
<             bci_JMP -> do
---
>             43bci_JMP do-> do
210c210
<             bci_CCALL -> do
---
>             44bci_CCALL do  -> do
213c213
<             bci_SWIZZLE -> do
---
>             45bci_SWIZZLE do    -> do
217c217
<             bci_ENTER -> do
---
>             46bci_ENTER do  -> do
219c219
<             bci_RETURN -> do
---
>             47bci_RETURN do   -> do
221c221
<             bci_RETURN_P -> do
---
>             48bci_RETURN_P do     -> do
223c223
<             bci_RETURN_N -> do
---
>             49bci_RETURN_N do     -> do
225c225
<             bci_RETURN_F -> do
---
>             50bci_RETURN_F do     -> do
227c227
<             bci_RETURN_D -> do
---
>             51bci_RETURN_D do     -> do
229c229
<             bci_RETURN_L -> do
---
>             52bci_RETURN_L do     -> do
231c231
<             bci_RETURN_V -> do
---
>             53bci_RETURN_V do     -> do
233c233
<             bci_BRK_FUN -> do
---
>             54bci_BRK_FUN do    -> do
306a307
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP, ScopedTypeVariables, DoAndIfThenElse, NondecreasingIndentation, DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
-- | A disassembler for ByteCode objects as used by GHCi.
module GHC.Disassembler (
    toBytes,
    disassemble,
    BCI(..) ) where

import qualified Data.ByteString.Lazy as BS
import Data.ByteString.Lazy (ByteString)
import Data.ByteString.Lazy.Builder
import Data.ByteString.Lazy.Builder.Extras
import Data.Binary.Get
import Data.Word
import Data.Int
import Data.Monoid
import Data.Bits
import Data.Functor
import Data.Foldable    ( Foldable )
import Data.Traversable ( Traversable )

#include "ghcautoconf.h"
#include "rts/Bytecodes.h"

-- | Converts the first @n@ bytes of this list of Words to a ByteString.
toBytes :: Word -> [Word] -> ByteString
toBytes n =
    BS.take (fromIntegral n) .
    toLazyByteString .
    mconcat .
    map (wordHost . fromIntegral)

-- | Given a list of pointers, a list of literals and a ByteString containing
-- byte code instructions, disassembles them into a list of byte code instructions.
disassemble :: forall box. [box] -> [Word] -> ByteString -> [BCI box]
disassemble ptrs lits = runGet $ do
#ifndef GHC_7_7
    -- Ignore length tag. Needs to be skipped with GHC versions with
    -- http://hackage.haskell.org/trac/ghc/ticket/7518 included
    _ <- getWord16host
#if SIZEOF_VOID_P == 8
    _ <- getWord16host
    _ <- getWord16host
#endif
    _n <- getWord16host
#endif
    nextInst
  where
    getLiteral :: Get Word
    getLiteral = ((!!) lits) . fromIntegral <$> getWord16host

    getLiterals = do
        p <- fromIntegral <$> getWord16host
        n <- fromIntegral <$> getWord16host
        return $ take n (drop p lits)

    getAddr :: Int -> box
    getAddr p = ptrs !! p

    getPtr :: Get box
    getPtr = getAddr . fromIntegral <$> getWord16host

    nextInst :: Get [BCI box]
    nextInst = do
        e <- isEmpty
        if e then return [] else do
        w <- getWord16host
        let large = 0 /= w .&. 0x8000

        let getLarge = if large then getWordhost else fromIntegral `fmap` getWord16host
        let getLargeInt = if large then getInthost else fromIntegral `fmap` getInt16host

        i <- case w .&. 0xff of
            bci_STKCHECK -> do
                n <- getLarge
                return $ BCISTKCHECK (n + 1)
            bci_PUSH_L -> do
                o1 <- getWord16host
                return $ BCIPUSH_L o1
            bci_PUSH_LL -> do
                o1 <- getWord16host
                o2 <- getWord16host
                return $ BCIPUSH_LL o1 o2
            bci_PUSH_LLL -> do
                o1 <- getWord16host
                o2 <- getWord16host
                o3 <- getWord16host
                return $ BCIPUSH_LLL o1 o2 o3
            bci_PUSH_G -> do
                p <- getPtr
                return $ BCIPUSH_G p
            bci_PUSH_ALTS -> do
                p <- getPtr
                return $ BCIPUSH_ALTS p
            bci_PUSH_ALTS_P -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_P p
            bci_PUSH_ALTS_N -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_N p
            bci_PUSH_ALTS_F -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_F p
            bci_PUSH_ALTS_D -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_D p
            bci_PUSH_ALTS_L -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_L p
            bci_PUSH_ALTS_V -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_V p
            bci_PUSH_UBX -> do
                ubx_lits <- getLiterals
                return $ BCIPUSH_UBX ubx_lits
            bci_PUSH_APPLY_N -> do
                return BCIPUSH_APPLY_N
            bci_PUSH_APPLY_F -> do
                return BCIPUSH_APPLY_F
            bci_PUSH_APPLY_D -> do
                return BCIPUSH_APPLY_D
            bci_PUSH_APPLY_L -> do
                return BCIPUSH_APPLY_L
            bci_PUSH_APPLY_V -> do
                return BCIPUSH_APPLY_V
            bci_PUSH_APPLY_P -> do
                return BCIPUSH_APPLY_P
            bci_PUSH_APPLY_PP -> do
                return BCIPUSH_APPLY_PP
            bci_PUSH_APPLY_PPP -> do
                return BCIPUSH_APPLY_PPP
            bci_PUSH_APPLY_PPPP -> do
                return BCIPUSH_APPLY_PPPP
            bci_PUSH_APPLY_PPPPP -> do
                return BCIPUSH_APPLY_PPPPP
            bci_PUSH_APPLY_PPPPPP -> do
                return BCIPUSH_APPLY_PPPPPP
            bci_SLIDE -> do
                p <- getWord16host
                n <- getWord16host
                return $ BCISLIDE p n
            bci_ALLOC_AP -> do
                n <- getWord16host
                return $ BCIALLOC_AP n
            bci_ALLOC_AP_NOUPD -> do
                n <- getWord16host
                return $ BCIALLOC_AP_NOUPD n
            bci_ALLOC_PAP -> do
                a <- getWord16host
                n <- getWord16host
                return $ BCIALLOC_PAP a n
            bci_MKAP -> do
                n <- getWord16host
                s <- getWord16host
                return $ BCIMKAP n s
            bci_MKPAP -> do
                n <- getWord16host
                s <- getWord16host
                return $ BCIMKPAP n s
            bci_UNPACK -> do
                n <- getWord16host
                return $ BCIUNPACK n
            bci_PACK -> do
                p <- getLiteral
                n <- getWord16host
                return $ BCIPACK p n
            bci_TESTLT_I -> do
                d <- getLargeInt
                t <- getLargeInt
                return $ BCITESTLT_I d t
            bci_TESTEQ_I -> do
                d <- getLargeInt
                t <- getLargeInt
                return $ BCITESTEQ_I d t
            bci_TESTLT_W -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_W d t
            bci_TESTEQ_W -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_W d t
            bci_TESTLT_F -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_F d t
            bci_TESTEQ_F -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_F d t
            bci_TESTLT_D -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_D d t
            bci_TESTEQ_D -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_D d t
            bci_TESTLT_P -> do
                d <- getWord16host
                t <- getLargeInt
                return $ BCITESTLT_P d t
            bci_TESTEQ_P -> do
                d <- getWord16host
                t <- getLargeInt
                return $ BCITESTEQ_P d t
            bci_CASEFAIL -> do
                return BCICASEFAIL
            bci_JMP -> do
                return BCIJMP
            bci_CCALL -> do
                p <- getLiteral
                return $ BCICCALL p
            bci_SWIZZLE -> do
                p <- getWord16host
                n <- getInt16host
                return $ BCISWIZZLE p n
            bci_ENTER -> do
                return BCIENTER
            bci_RETURN -> do
                return BCIRETURN
            bci_RETURN_P -> do
                return BCIRETURN_P
            bci_RETURN_N -> do
                return BCIRETURN_N
            bci_RETURN_F -> do
                return BCIRETURN_F
            bci_RETURN_D -> do
                return BCIRETURN_D
            bci_RETURN_L -> do
                return BCIRETURN_L
            bci_RETURN_V -> do
                return BCIRETURN_V
            bci_BRK_FUN -> do
                _ <- getWord16host
                _ <- getWord16host
                _ <- getWord16host
                return BCIBRK_FUN
            x -> error $ "Unknown opcode " ++ show x
        (i :) `fmap` nextInst


-- | The various byte code instructions that GHCi supports.
data BCI box
    = BCISTKCHECK Word
    | BCIPUSH_L Word16
    | BCIPUSH_LL Word16 Word16
    | BCIPUSH_LLL Word16 Word16 Word16
    | BCIPUSH_G box
    | BCIPUSH_ALTS box
    | BCIPUSH_ALTS_P box
    | BCIPUSH_ALTS_N box
    | BCIPUSH_ALTS_F box
    | BCIPUSH_ALTS_D box
    | BCIPUSH_ALTS_L box
    | BCIPUSH_ALTS_V box
    | BCIPUSH_UBX [Word]
    | BCIPUSH_APPLY_N
    | BCIPUSH_APPLY_F
    | BCIPUSH_APPLY_D
    | BCIPUSH_APPLY_L
    | BCIPUSH_APPLY_V
    | BCIPUSH_APPLY_P
    | BCIPUSH_APPLY_PP
    | BCIPUSH_APPLY_PPP
    | BCIPUSH_APPLY_PPPP
    | BCIPUSH_APPLY_PPPPP
    | BCIPUSH_APPLY_PPPPPP
/*     | BCIPUSH_APPLY_PPPPPPP */
    | BCISLIDE Word16 Word16
    | BCIALLOC_AP Word16
    | BCIALLOC_AP_NOUPD Word16
    | BCIALLOC_PAP Word16 Word16
    | BCIMKAP Word16 Word16
    | BCIMKPAP Word16 Word16
    | BCIUNPACK Word16
    | BCIPACK Word Word16
    | BCITESTLT_I Int Int
    | BCITESTEQ_I Int Int
    | BCITESTLT_F Word Int
    | BCITESTEQ_F Word Int
    | BCITESTLT_D Word Int
    | BCITESTEQ_D Word Int
    | BCITESTLT_P Word16 Int
    | BCITESTEQ_P Word16 Int
    | BCICASEFAIL
    | BCIJMP
    | BCICCALL Word
    | BCISWIZZLE Word16 Int16
    | BCIENTER
    | BCIRETURN
    | BCIRETURN_P
    | BCIRETURN_N
    | BCIRETURN_F
    | BCIRETURN_D
    | BCIRETURN_L
    | BCIRETURN_V
    | BCIBRK_FUN -- ^ We do not parse this opcode's arguments
    | BCITESTLT_W Word Int
    | BCITESTEQ_W Word Int
    deriving (Show, Functor, Traversable, Foldable)

getInthost :: Get Int
getInthost = fromIntegral <$> getWordhost

getInt16host :: Get Int16
getInt16host = fromIntegral <$> getWord16host
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP, ScopedTypeVariables, DoAndIfThenElse, NondecreasingIndentation, DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
-- | A disassembler for ByteCode objects as used by GHCi.
module GHC.Disassembler (
    toBytes,
    disassemble,
    BCI(..) ) where

import qualified Data.ByteString.Lazy as BS
import Data.ByteString.Lazy (ByteString)
import Data.ByteString.Lazy.Builder
import Data.ByteString.Lazy.Builder.Extras
import Data.Binary.Get
import Data.Word
import Data.Int
import Data.Monoid
import Data.Bits
import Data.Functor
import Data.Foldable    ( Foldable )
import Data.Traversable ( Traversable )

#include "ghcautoconf.h"
#include "rts/Bytecodes.h"

-- | Converts the first @n@ bytes of this list of Words to a ByteString.
toBytes :: Word -> [Word] -> ByteString
toBytes n =
    BS.take (fromIntegral n) .
    toLazyByteString .
    mconcat .
    map (wordHost . fromIntegral)

-- | Given a list of pointers, a list of literals and a ByteString containing
-- byte code instructions, disassembles them into a list of byte code instructions.
disassemble :: forall box. [box] -> [Word] -> ByteString -> [BCI box]
disassemble ptrs lits = runGet $ do
#ifndef GHC_7_7
    -- Ignore length tag. Needs to be skipped with GHC versions with
    -- http://hackage.haskell.org/trac/ghc/ticket/7518 included
    _ <- getWord16host
#if SIZEOF_VOID_P == 8
    _ <- getWord16host
    _ <- getWord16host
#endif
    _n <- getWord16host
#endif
    nextInst
  where
    getLiteral :: Get Word
    getLiteral = ((!!) lits) . fromIntegral <$> getWord16host

    getLiterals = do
        p <- fromIntegral <$> getWord16host
        n <- fromIntegral <$> getWord16host
        return $ take n (drop p lits)

    getAddr :: Int -> box
    getAddr p = ptrs !! p

    getPtr :: Get box
    getPtr = getAddr . fromIntegral <$> getWord16host

    nextInst :: Get [BCI box]
    nextInst = do
        e <- isEmpty
        if e then return [] else do
        w <- getWord16host
        let large = 0 /= w .&. 0x8000

        let getLarge = if large then getWordhost else fromIntegral `fmap` getWord16host
        let getLargeInt = if large then getInthost else fromIntegral `fmap` getInt16host

        i <- case w .&. 0xff of
            1bci_STKCHECK do      -> do
                n <- getLarge
                return $ BCISTKCHECK (n + 1)
            2bci_PUSH_L do    -> do
                o1 <- getWord16host
                return $ BCIPUSH_L o1
            3bci_PUSH_LL do     -> do
                o1 <- getWord16host
                o2 <- getWord16host
                return $ BCIPUSH_LL o1 o2
            4bci_PUSH_LLL do      -> do
                o1 <- getWord16host
                o2 <- getWord16host
                o3 <- getWord16host
                return $ BCIPUSH_LLL o1 o2 o3
            5bci_PUSH_G do    -> do
                p <- getPtr
                return $ BCIPUSH_G p
            6bci_PUSH_ALTS do       -> do
                p <- getPtr
                return $ BCIPUSH_ALTS p
            7bci_PUSH_ALTS_P do         -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_P p
            8bci_PUSH_ALTS_N do         -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_N p
            9bci_PUSH_ALTS_F do         -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_F p
            10bci_PUSH_ALTS_D do        -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_D p
            11bci_PUSH_ALTS_L do        -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_L p
            12bci_PUSH_ALTS_V do        -> do
                p <- getPtr
                return $ BCIPUSH_ALTS_V p
            13bci_PUSH_UBX do     -> do
                ubx_lits <- getLiterals
                return $ BCIPUSH_UBX ubx_lits
            14bci_PUSH_APPLY_N do         -> do
                return BCIPUSH_APPLY_N
            15bci_PUSH_APPLY_F do         -> do
                return BCIPUSH_APPLY_F
            16bci_PUSH_APPLY_D do         -> do
                return BCIPUSH_APPLY_D
            17bci_PUSH_APPLY_L do         -> do
                return BCIPUSH_APPLY_L
            18bci_PUSH_APPLY_V do         -> do
                return BCIPUSH_APPLY_V
            19bci_PUSH_APPLY_P do         -> do
                return BCIPUSH_APPLY_P
            20bci_PUSH_APPLY_PP do          -> do
                return BCIPUSH_APPLY_PP
            21bci_PUSH_APPLY_PPP do           -> do
                return BCIPUSH_APPLY_PPP
            22bci_PUSH_APPLY_PPPP do            -> do
                return BCIPUSH_APPLY_PPPP
            23bci_PUSH_APPLY_PPPPP do             -> do
                return BCIPUSH_APPLY_PPPPP
            24bci_PUSH_APPLY_PPPPPP do              -> do
                return BCIPUSH_APPLY_PPPPPP
            26bci_SLIDE do  -> do
                p <- getWord16host
                n <- getWord16host
                return $ BCISLIDE p n
            27bci_ALLOC_AP do     -> do
                n <- getWord16host
                return $ BCIALLOC_AP n
            28bci_ALLOC_AP_NOUPD do           -> do
                n <- getWord16host
                return $ BCIALLOC_AP_NOUPD n
            29bci_ALLOC_PAP do      -> do
                a <- getWord16host
                n <- getWord16host
                return $ BCIALLOC_PAP a n
            30bci_MKAP do -> do
                n <- getWord16host
                s <- getWord16host
                return $ BCIMKAP n s
            31bci_MKPAP do  -> do
                n <- getWord16host
                s <- getWord16host
                return $ BCIMKPAP n s
            32bci_UNPACK do   -> do
                n <- getWord16host
                return $ BCIUNPACK n
            33bci_PACK do -> do
                p <- getLiteral
                n <- getWord16host
                return $ BCIPACK p n
            34bci_TESTLT_I do     -> do
                d <- getLargeInt
                t <- getLargeInt
                return $ BCITESTLT_I d t
            35bci_TESTEQ_I do     -> do
                d <- getLargeInt
                t <- getLargeInt
                return $ BCITESTEQ_I d t
            55bci_TESTLT_W do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_W d t
            56bci_TESTEQ_W do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_W d t
            36bci_TESTLT_F do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_F d t
            37bci_TESTEQ_F do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_F d t
            38bci_TESTLT_D do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTLT_D d t
            39bci_TESTEQ_D do     -> do
                d <- getLarge
                t <- getLargeInt
                return $ BCITESTEQ_D d t
            40bci_TESTLT_P do     -> do
                d <- getWord16host
                t <- getLargeInt
                return $ BCITESTLT_P d t
            41bci_TESTEQ_P do     -> do
                d <- getWord16host
                t <- getLargeInt
                return $ BCITESTEQ_P d t
            42bci_CASEFAIL do     -> do
                return BCICASEFAIL
            43bci_JMP do-> do
                return BCIJMP
            44bci_CCALL do  -> do
                p <- getLiteral
                return $ BCICCALL p
            45bci_SWIZZLE do    -> do
                p <- getWord16host
                n <- getInt16host
                return $ BCISWIZZLE p n
            46bci_ENTER do  -> do
                return BCIENTER
            47bci_RETURN do   -> do
                return BCIRETURN
            48bci_RETURN_P do     -> do
                return BCIRETURN_P
            49bci_RETURN_N do     -> do
                return BCIRETURN_N
            50bci_RETURN_F do     -> do
                return BCIRETURN_F
            51bci_RETURN_D do     -> do
                return BCIRETURN_D
            52bci_RETURN_L do     -> do
                return BCIRETURN_L
            53bci_RETURN_V do     -> do
                return BCIRETURN_V
            54bci_BRK_FUN do    -> do
                _ <- getWord16host
                _ <- getWord16host
                _ <- getWord16host
                return BCIBRK_FUN
            x -> error $ "Unknown opcode " ++ show x
        (i :) `fmap` nextInst


-- | The various byte code instructions that GHCi supports.
data BCI box
    = BCISTKCHECK Word
    | BCIPUSH_L Word16
    | BCIPUSH_LL Word16 Word16
    | BCIPUSH_LLL Word16 Word16 Word16
    | BCIPUSH_G box
    | BCIPUSH_ALTS box
    | BCIPUSH_ALTS_P box
    | BCIPUSH_ALTS_N box
    | BCIPUSH_ALTS_F box
    | BCIPUSH_ALTS_D box
    | BCIPUSH_ALTS_L box
    | BCIPUSH_ALTS_V box
    | BCIPUSH_UBX [Word]
    | BCIPUSH_APPLY_N
    | BCIPUSH_APPLY_F
    | BCIPUSH_APPLY_D
    | BCIPUSH_APPLY_L
    | BCIPUSH_APPLY_V
    | BCIPUSH_APPLY_P
    | BCIPUSH_APPLY_PP
    | BCIPUSH_APPLY_PPP
    | BCIPUSH_APPLY_PPPP
    | BCIPUSH_APPLY_PPPPP
    | BCIPUSH_APPLY_PPPPPP
/*     | BCIPUSH_APPLY_PPPPPPP */
    | BCISLIDE Word16 Word16
    | BCIALLOC_AP Word16
    | BCIALLOC_AP_NOUPD Word16
    | BCIALLOC_PAP Word16 Word16
    | BCIMKAP Word16 Word16
    | BCIMKPAP Word16 Word16
    | BCIUNPACK Word16
    | BCIPACK Word Word16
    | BCITESTLT_I Int Int
    | BCITESTEQ_I Int Int
    | BCITESTLT_F Word Int
    | BCITESTEQ_F Word Int
    | BCITESTLT_D Word Int
    | BCITESTEQ_D Word Int
    | BCITESTLT_P Word16 Int
    | BCITESTEQ_P Word16 Int
    | BCICASEFAIL
    | BCIJMP
    | BCICCALL Word
    | BCISWIZZLE Word16 Int16
    | BCIENTER
    | BCIRETURN
    | BCIRETURN_P
    | BCIRETURN_N
    | BCIRETURN_F
    | BCIRETURN_D
    | BCIRETURN_L
    | BCIRETURN_V
    | BCIBRK_FUN -- ^ We do not parse this opcode's arguments
    | BCITESTLT_W Word Int
    | BCITESTEQ_W Word Int
    deriving (Show, Functor, Traversable, Foldable)

getInthost :: Get Int
getInthost = fromIntegral <$> getWordhost

getInt16host :: Get Int16
getInt16host = fromIntegral <$> getWord16host

</pre>