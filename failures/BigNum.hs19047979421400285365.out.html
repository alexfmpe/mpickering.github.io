<a href="BigNum.hs11477222941070477904.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BiMap.hs2020739063107554536.out.html">next</a></br></br><pre>23d22
< import "base"                       Data.Bool             ( otherwise )
24d22
< import "base"                       Data.Function         ( ($), const, fix )
25d22
< import "base"                       Data.Functor          ( (<$>) )
26d22
< import "base"                       Data.Maybe            ( Maybe(Nothing, Just) )
27d22
< import "base"                       Data.Monoid           ( Monoid )
28d22
< import "base"                       Data.String           ( IsString )
29d22
< import "base"                       Prelude               ( Integral )
30d22
< import "base-unicode-symbols"       Data.Eq.Unicode       ( (≡) )
31d22
< import "base-unicode-symbols"       Data.Function.Unicode ( (∘) )
32d22
< import "base-unicode-symbols"       Data.List.Unicode     ( (∈) )
33d22
< import "base-unicode-symbols"       Data.Monoid.Unicode   ( (⊕) )
34d22
< import "base-unicode-symbols"       Prelude.Unicode       ( ℤ )
35d22
< import "containers-unicode-symbols" Data.Map.Unicode      ( (∪) )
36d22
< import "this"                       Text.Numeral
37d22
< import qualified "containers" Data.Map as M ( Map, fromList, lookup )
38c23
< import qualified "this"       Text.Numeral.Exp.Classes as C
---
> import                        Data.Bool             ( otherwise )
38a24
> import                        Data.Function         ( ($), const, fix )
38a25
> import                        Data.Functor          ( (<$>) )
38a26
> import                        Data.Maybe            ( Maybe(Nothing, Just) )
38a27
> import                        Data.Monoid           ( Monoid )
38a28
> import                        Data.String           ( IsString )
38a29
> import                        Prelude               ( Integral )
38a30
> import        Data.Eq.Unicode       ( (≡) )
38a31
> import        Data.Function.Unicode ( (∘) )
38a32
> import        Data.List.Unicode     ( (∈) )
38a33
> import        Data.Monoid.Unicode   ( (⊕) )
38a34
> import        Prelude.Unicode       ( ℤ )
38a35
> import  Data.Map.Unicode      ( (∪) )
38a36
> import                        Text.Numeral
38a37
> import qualified  Data.Map as M ( Map, fromList, lookup )
38a38
> import qualified        Text.Numeral.Exp.Classes as C
45c45
< cardinal ∷ (Monoid s, IsString s, Integral α) ⇒ α → Maybe s
---
> cardinal :: (Monoid s, IsString s, Integral α) => α -> Maybe s
48c48
< rule ∷ (Integral α, C.Unknown β, C.Lit β, C.Add β, C.Mul β) ⇒ Rule α β
---
> rule :: (Integral α, C.Unknown β, C.Lit β, C.Add β, C.Mul β) => Rule α β
59c59
< cardinalRepr ∷ (Monoid s, IsString s) ⇒ Repr s
---
> cardinalRepr :: (Monoid s, IsString s) => Repr s
61d60
<     defaultRepr { reprValue = \n → M.lookup n symMap
62d60
<                 , reprAdd   = Just $ \_ _ _ → ""
63c61
<                 , reprMul   = Just $ \_ _ _ → ""
---
>     defaultRepr { reprValue = \n -> M.lookup n symMap
63a62
>                 , reprAdd   = Just $ \_ _ _ -> ""
63a63
>                 , reprMul   = Just $ \_ _ _ -> ""
66c66
< symMap ∷ (Integral α, IsString s) ⇒ M.Map α (Ctx Exp → s)
---
> symMap :: (Integral α, IsString s) => M.Map α (Ctx Exp -> s)
77d76
<          , (10, \c → case c of
78d76
<                        CtxAdd _ (Lit 100) _              → "deci"
79d76
<                        CtxMul _ _ (CtxAdd L (Lit 100) _) → "ginta"
80d76
<                        CtxMul {}                         → "gint"
81c77
<                        _                                 → "dec"
---
>          , (10, \c -> case c of
81a78
>                        CtxAdd _ (Lit 100) _              -> "deci"
81a79
>                        CtxMul _ _ (CtxAdd L (Lit 100) _) -> "ginta"
81a80
>                        CtxMul {}                         -> "gint"
81a81
>                        _                                 -> "dec"
83c83
<          , (100, \c → case c of
---
>          , (100, \c -> case c of
85d84
<                             | n ∈ [2,3,6] → "cent"
86d84
<                             | otherwise   → "gent"
87c85
<                         _                 → "cent"
---
>                             | n ∈ [2,3,6] -> "cent"
87a86
>                             | otherwise   -> "gent"
87a87
>                         _                 -> "cent"
93c93
< forms ∷ s → s → s → s → s → Ctx Exp → s
---
> forms :: s -> s -> s -> s -> s -> Ctx Exp -> s
96d95
<       CtxAdd _ (Lit 10)  _ → a1
97d95
<       CtxAdd {}            → a2
98d95
<       CtxMul _ (Lit 100) _ → m2
99d95
<       CtxMul {}            → m1
100c96
<       _                    → t
---
>       CtxAdd _ (Lit 10)  _ -> a1
100a97
>       CtxAdd {}            -> a2
100a98
>       CtxMul _ (Lit 100) _ -> m2
100a99
>       CtxMul {}            -> m1
100a100
>       _                    -> t
106d105
< scaleRepr ∷ (IsString s, Monoid s)
107d105
<           ⇒ s -- ^Postfix for singular names.
108d105
<           → s -- ^Postfix for plural names.
109d105
<           → [(ℤ, Ctx Exp → s)]
110c106
<           → ℤ → ℤ → Exp → Ctx Exp → Maybe s
---
> scaleRepr :: (IsString s, Monoid s)
110a107
>           => s -- ^Postfix for singular names.
110a108
>           -> s -- ^Postfix for plural names.
110a109
>           -> [(ℤ, Ctx Exp -> s)]
110a110
>           -> ℤ -> ℤ -> Exp -> Ctx Exp -> Maybe s
114d113
<              CtxMul _ (Lit 1) _ → s
115d113
<              CtxMul {}          → p
116d113
<              _                  → s
117c114
<       repr = cardinalRepr { reprValue = \n → M.lookup n syms' }
---
>              CtxMul _ (Lit 1) _ -> s
117a115
>              CtxMul {}          -> p
117a116
>              _                  -> s
117a117
>       repr = cardinalRepr { reprValue = \n -> M.lookup n syms' }
120d119
< pelletierRepr ∷ (IsString s, Monoid s)
121d119
<               ⇒ s -- ^Postfix for singular offset 0 names.
122d119
<               → s -- ^Postfix for singular offset 0 names.
123d119
<               → s -- ^Postfix for plural offset 3 names.
124d119
<               → s -- ^Postfix for plural offset 3 names.
125d119
<               → [(ℤ, Ctx Exp → s)]
126c120
<               → ℤ → ℤ → Exp → Ctx Exp → Maybe s
---
> pelletierRepr :: (IsString s, Monoid s)
126a121
>               => s -- ^Postfix for singular offset 0 names.
126a122
>               -> s -- ^Postfix for singular offset 0 names.
126a123
>               -> s -- ^Postfix for plural offset 3 names.
126a124
>               -> s -- ^Postfix for plural offset 3 names.
126a125
>               -> [(ℤ, Ctx Exp -> s)]
126a126
>               -> ℤ -> ℤ -> Exp -> Ctx Exp -> Maybe s
131a132
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , OverloadedStrings
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.BigNum
  ( cardinal
  , rule
  , cardinalRepr
  , symMap
  , forms

  , scaleRepr
  , pelletierRepr
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import "base"                       Data.Bool             ( otherwise )
import "base"                       Data.Function         ( ($), const, fix )
import "base"                       Data.Functor          ( (<$>) )
import "base"                       Data.Maybe            ( Maybe(Nothing, Just) )
import "base"                       Data.Monoid           ( Monoid )
import "base"                       Data.String           ( IsString )
import "base"                       Prelude               ( Integral )
import "base-unicode-symbols"       Data.Eq.Unicode       ( (≡) )
import "base-unicode-symbols"       Data.Function.Unicode ( (∘) )
import "base-unicode-symbols"       Data.List.Unicode     ( (∈) )
import "base-unicode-symbols"       Data.Monoid.Unicode   ( (⊕) )
import "base-unicode-symbols"       Prelude.Unicode       ( ℤ )
import "containers-unicode-symbols" Data.Map.Unicode      ( (∪) )
import "this"                       Text.Numeral
import qualified "containers" Data.Map as M ( Map, fromList, lookup )
import qualified "this"       Text.Numeral.Exp.Classes as C


--------------------------------------------------------------------------------
-- Language of Big Numbers
--------------------------------------------------------------------------------

cardinal ∷ (Monoid s, IsString s, Integral α) ⇒ α → Maybe s
cardinal = render cardinalRepr ∘ (pos $ fix rule)

rule ∷ (Integral α, C.Unknown β, C.Lit β, C.Add β, C.Mul β) ⇒ Rule α β
rule = findRule (   1, lit        )
              [ (  11, add  10 L  )
              , (  20, mul  10 L L)
              , ( 100, lit        )
              , ( 101, add 100 L  )
              , ( 200, mul 100 R L)
              , (1000, lit        )
              ]
                 1000

cardinalRepr ∷ (Monoid s, IsString s) ⇒ Repr s
cardinalRepr =
    defaultRepr { reprValue = \n → M.lookup n symMap
                , reprAdd   = Just $ \_ _ _ → ""
                , reprMul   = Just $ \_ _ _ → ""
                }

symMap ∷ (Integral α, IsString s) ⇒ M.Map α (Ctx Exp → s)
symMap = M.fromList
         [ (1, forms "m"     "un"       "un"       ""        "")
         , (2, forms "b"     "duo"      "duo"      "vi"      "du")
         , (3, forms "tr"    "tre"      "tres"     "tri"     "tre")
         , (4, forms "quadr" "quattuor" "quattuor" "quadra"  "quadri")
         , (5, forms "quint" "quin"     "quinqua"  "quinqua" "quin")
         , (6, forms "sext"  "sex"      "ses"      "sexa"    "ses")
         , (7, forms "sept"  "septen"   "septem"   "septua"  "septin")
         , (8, forms "oct"   "octo"     "octo"     "octo"    "octin")
         , (9, forms "non"   "novem"    "novem"    "nona"    "non")
         , (10, \c → case c of
                       CtxAdd _ (Lit 100) _              → "deci"
                       CtxMul _ _ (CtxAdd L (Lit 100) _) → "ginta"
                       CtxMul {}                         → "gint"
                       _                                 → "dec"
           )
         , (100, \c → case c of
                        CtxMul _ (Lit n) _
                            | n ∈ [2,3,6] → "cent"
                            | otherwise   → "gent"
                        _                 → "cent"
           )
         , (1000, const "millin")
         , (10000, const "myr")
         ]

forms ∷ s → s → s → s → s → Ctx Exp → s
forms t a1 a2 m1 m2 ctx =
    case ctx of
      CtxAdd _ (Lit 10)  _ → a1
      CtxAdd {}            → a2
      CtxMul _ (Lit 100) _ → m2
      CtxMul {}            → m1
      _                    → t

--------------------------------------------------------------------------------
-- Representations of scales
--------------------------------------------------------------------------------

scaleRepr ∷ (IsString s, Monoid s)
          ⇒ s -- ^Postfix for singular names.
          → s -- ^Postfix for plural names.
          → [(ℤ, Ctx Exp → s)]
          → ℤ → ℤ → Exp → Ctx Exp → Maybe s
scaleRepr s p syms _ _ e ctx = (⊕ pf) <$> render repr e
    where
      pf = case ctx of
             CtxMul _ (Lit 1) _ → s
             CtxMul {}          → p
             _                  → s
      repr = cardinalRepr { reprValue = \n → M.lookup n syms' }
      syms' = M.fromList syms ∪ symMap

pelletierRepr ∷ (IsString s, Monoid s)
              ⇒ s -- ^Postfix for singular offset 0 names.
              → s -- ^Postfix for singular offset 0 names.
              → s -- ^Postfix for plural offset 3 names.
              → s -- ^Postfix for plural offset 3 names.
              → [(ℤ, Ctx Exp → s)]
              → ℤ → ℤ → Exp → Ctx Exp → Maybe s
pelletierRepr s0 p0 s3 p3 syms
              b o e ctx | o ≡ 0 = scaleRepr s0 p0 syms b o e ctx
                        | o ≡ 3 = scaleRepr s3 p3 syms b o e ctx
                        | otherwise = Nothing

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE NoImplicitPrelude
           , OverloadedStrings
           , PackageImports
           , UnicodeSyntax
  #-}

module Text.Numeral.BigNum
  ( cardinal
  , rule
  , cardinalRepr
  , symMap
  , forms

  , scaleRepr
  , pelletierRepr
  ) where


-------------------------------------------------------------------------------
-- Imports
-------------------------------------------------------------------------------

import                        Data.Bool             ( otherwise )
import                        Data.Function         ( ($), const, fix )
import                        Data.Functor          ( (<$>) )
import                        Data.Maybe            ( Maybe(Nothing, Just) )
import                        Data.Monoid           ( Monoid )
import                        Data.String           ( IsString )
import                        Prelude               ( Integral )
import        Data.Eq.Unicode       ( (≡) )
import        Data.Function.Unicode ( (∘) )
import        Data.List.Unicode     ( (∈) )
import        Data.Monoid.Unicode   ( (⊕) )
import        Prelude.Unicode       ( ℤ )
import  Data.Map.Unicode      ( (∪) )
import                        Text.Numeral
import qualified  Data.Map as M ( Map, fromList, lookup )
import qualified        Text.Numeral.Exp.Classes as C


--------------------------------------------------------------------------------
-- Language of Big Numbers
--------------------------------------------------------------------------------

cardinal :: (Monoid s, IsString s, Integral α) => α -> Maybe s
cardinal = render cardinalRepr ∘ (pos $ fix rule)

rule :: (Integral α, C.Unknown β, C.Lit β, C.Add β, C.Mul β) => Rule α β
rule = findRule (   1, lit        )
              [ (  11, add  10 L  )
              , (  20, mul  10 L L)
              , ( 100, lit        )
              , ( 101, add 100 L  )
              , ( 200, mul 100 R L)
              , (1000, lit        )
              ]
                 1000

cardinalRepr :: (Monoid s, IsString s) => Repr s
cardinalRepr =
    defaultRepr { reprValue = \n -> M.lookup n symMap
                , reprAdd   = Just $ \_ _ _ -> ""
                , reprMul   = Just $ \_ _ _ -> ""
                }

symMap :: (Integral α, IsString s) => M.Map α (Ctx Exp -> s)
symMap = M.fromList
         [ (1, forms "m"     "un"       "un"       ""        "")
         , (2, forms "b"     "duo"      "duo"      "vi"      "du")
         , (3, forms "tr"    "tre"      "tres"     "tri"     "tre")
         , (4, forms "quadr" "quattuor" "quattuor" "quadra"  "quadri")
         , (5, forms "quint" "quin"     "quinqua"  "quinqua" "quin")
         , (6, forms "sext"  "sex"      "ses"      "sexa"    "ses")
         , (7, forms "sept"  "septen"   "septem"   "septua"  "septin")
         , (8, forms "oct"   "octo"     "octo"     "octo"    "octin")
         , (9, forms "non"   "novem"    "novem"    "nona"    "non")
         , (10, \c -> case c of
                       CtxAdd _ (Lit 100) _              -> "deci"
                       CtxMul _ _ (CtxAdd L (Lit 100) _) -> "ginta"
                       CtxMul {}                         -> "gint"
                       _                                 -> "dec"
           )
         , (100, \c -> case c of
                        CtxMul _ (Lit n) _
                            | n ∈ [2,3,6] -> "cent"
                            | otherwise   -> "gent"
                        _                 -> "cent"
           )
         , (1000, const "millin")
         , (10000, const "myr")
         ]

forms :: s -> s -> s -> s -> s -> Ctx Exp -> s
forms t a1 a2 m1 m2 ctx =
    case ctx of
      CtxAdd _ (Lit 10)  _ -> a1
      CtxAdd {}            -> a2
      CtxMul _ (Lit 100) _ -> m2
      CtxMul {}            -> m1
      _                    -> t

--------------------------------------------------------------------------------
-- Representations of scales
--------------------------------------------------------------------------------

scaleRepr :: (IsString s, Monoid s)
          => s -- ^Postfix for singular names.
          -> s -- ^Postfix for plural names.
          -> [(ℤ, Ctx Exp -> s)]
          -> ℤ -> ℤ -> Exp -> Ctx Exp -> Maybe s
scaleRepr s p syms _ _ e ctx = (⊕ pf) <$> render repr e
    where
      pf = case ctx of
             CtxMul _ (Lit 1) _ -> s
             CtxMul {}          -> p
             _                  -> s
      repr = cardinalRepr { reprValue = \n -> M.lookup n syms' }
      syms' = M.fromList syms ∪ symMap

pelletierRepr :: (IsString s, Monoid s)
              => s -- ^Postfix for singular offset 0 names.
              -> s -- ^Postfix for singular offset 0 names.
              -> s -- ^Postfix for plural offset 3 names.
              -> s -- ^Postfix for plural offset 3 names.
              -> [(ℤ, Ctx Exp -> s)]
              -> ℤ -> ℤ -> Exp -> Ctx Exp -> Maybe s
pelletierRepr s0 p0 s3 p3 syms
              b o e ctx | o ≡ 0 = scaleRepr s0 p0 syms b o e ctx
                        | o ≡ 3 = scaleRepr s3 p3 syms b o e ctx
                        | otherwise = Nothing


</pre>