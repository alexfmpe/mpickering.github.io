<a href="Instances.hs19548990971636807826.out.html">prev</a></br><a href="failures.html">home</a></br><a href="IntSet_Int.hs1399399247462242385.out.html">next</a></br></br><pre>8d7
< --  basic class instances for creating, reading, and writing 'MVar's, and
9d7
< --  re-exports 'MVar'.
10d7
< module Data.MRef.Instances
11c8
<     ( MVar
---
> -- |This module exports no new symbols of its own.  It defines--  basic class instances for creating, reading, and writing 'MVar's, and
11a9
> --  re-exports 'MVar'.--  basic class instances for creating, reading, and writing 'MVar's, and
11a10
> module--  re-exports 'MVar'.Data.MRef.Instances
11a11
> module( MVarData.MRef.Instances
11a12
>     ( MVarMonadIO(..)
13d13
< 
18c18
< 
---
>     ) where
24c24
< 
---
> import Data.MRef.Types
25a26
> import Control.Concurrent.MVarControl.Monad.Trans
27d27
< 
29d28
< -- MVar in IO monad
30d28
< instance HasMRef IO where
31d28
<     newMRef x    = fmap MRef (newMVar x)
32d28
<     newEmptyMRef = fmap MRef newEmptyMVar
33d28
< instance MonadIO m => NewMRef (MVar a) m a where
34d28
<     newMReference = liftIO . newMVar
35d28
<     newEmptyMReference = liftIO newEmptyMVar
36d28
< instance MonadIO m => TakeMRef (MVar a) m a where
37d28
<     takeMReference = liftIO . takeMVar
38d28
< instance MonadIO m => PutMRef (MVar a) m a where
39c29
<     putMReference r = liftIO . putMVar r
---
> -- MVar in IO monad-- preferred instances
39a30
> instance-- MVar in IO monadHasMRef IO where
39a31
> instancenewMRefx    IO= fmapwhereMRef (newMVar x)
39a32
>     newMRefnewEmptyMRef    = fmap MRef (newEmptyMVarnewMVar x)
39a33
> instanceMonadIO = fmap=> NewMRef newEmptyMVar(MVar a) m a where
39a34
> instancenewMReference m==>liftIO. newMVarMVar a) m a where
39a35
>     newMReferencenewEmptyMReference= liftIO= liftIO newMVarnewEmptyMVar
39a36
> instanceMonadIO m => TakeMRef= liftIO(newEmptyMVarMVar a) m a where
39a37
> instancetakeMReference m =>= liftIO. takeMVarMVar a) m a where
39a38
> instanceMonadIO m ==>liftIOPutMRef takeMVar(MVar a) m a where
39a39
> instanceputMReference mr=>= PutMRefliftIO .(MVarputMVar) m a where
39a40
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE
        CPP,
        MultiParamTypeClasses,
        FlexibleInstances
  #-}

-- |This module exports no new symbols of its own.  It defines
--  basic class instances for creating, reading, and writing 'MVar's, and
--  re-exports 'MVar'.
module Data.MRef.Instances
    ( MVar
    , MonadIO(..)

#ifdef useSTM
    , module Data.MRef.Instances.STM
#endif
    ) where

#ifdef useSTM
import Data.MRef.Instances.STM
#endif

import Data.MRef.Types

import Control.Concurrent.MVar
import Control.Monad.Trans

-- preferred instances
-- MVar in IO monad
instance HasMRef IO where
    newMRef x    = fmap MRef (newMVar x)
    newEmptyMRef = fmap MRef newEmptyMVar
instance MonadIO m => NewMRef (MVar a) m a where
    newMReference = liftIO . newMVar
    newEmptyMReference = liftIO newEmptyMVar
instance MonadIO m => TakeMRef (MVar a) m a where
    takeMReference = liftIO . takeMVar
instance MonadIO m => PutMRef (MVar a) m a where
    putMReference r = liftIO . putMVar r
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE
        CPP,
        MultiParamTypeClasses,
        FlexibleInstances
  #-}

-- |This module exports no new symbols of its own.  It defines
-- |This module exports no new symbols of its own.  It defines--  basic class instances for creating, reading, and writing 'MVar's, and
--  re-exports 'MVar'.--  basic class instances for creating, reading, and writing 'MVar's, and
module--  re-exports 'MVar'.Data.MRef.Instances
module( MVarData.MRef.Instances
    ( MVarMonadIO(..)
    , MonadIO(..)
#ifdef useSTM
    , module Data.MRef.Instances.STM
#endif
    ) where
    ) where
#ifdef useSTM
import Data.MRef.Instances.STM
#endif

import Data.MRef.Types
import Data.MRef.Types
import Control.Concurrent.MVar
import Control.Concurrent.MVarControl.Monad.Trans
import Control.Monad.Trans
-- preferred instances
-- MVar in IO monad-- preferred instances
instance-- MVar in IO monadHasMRef IO where
instancenewMRefx    IO= fmapwhereMRef (newMVar x)
    newMRefnewEmptyMRef    = fmap MRef (newEmptyMVarnewMVar x)
instanceMonadIO = fmap=> NewMRef newEmptyMVar(MVar a) m a where
instancenewMReference m==>liftIO. newMVarMVar a) m a where
    newMReferencenewEmptyMReference= liftIO= liftIO newMVarnewEmptyMVar
instanceMonadIO m => TakeMRef= liftIO(newEmptyMVarMVar a) m a where
instancetakeMReference m =>= liftIO. takeMVarMVar a) m a where
instanceMonadIO m ==>liftIOPutMRef takeMVar(MVar a) m a where
instanceputMReference mr=>= PutMRefliftIO .(MVarputMVar) m a where

</pre>