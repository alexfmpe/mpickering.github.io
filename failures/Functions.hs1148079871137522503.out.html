<a href="Font.hs14377846301360280366.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Functor.hs2111631616877819790.out.html">next</a></br></br><pre>159d158
<         { fvLabel = toHtml $ mr2 fsLabel
160c159
<         , fvTooltip = fmap toHtml $ fmap mr2 fsTooltip
---
>         { fvLabel = toMarkuptoHtml $ $mr2fsLabel
160a160
>         , fvTooltip = fmap toMarkuptoHtml $ $fmapmr2fsTooltip
165c165
<                 FormFailure [e] -> Just $ toHtml e
---
>                 FormFailure [e] -> Just $ toMarkuptoHtml e e
204c204
<             => (Html -> MForm m (FormResult a, xml))
---
>             => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
211c211
<             => (Html -> MForm m (FormResult a, xml))
---
>             => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
241c241
<     => (Html -> MForm m (FormResult a, xml))
---
>     => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
257c257
<                    => (Html -> MForm m a)
---
>                    => (MarkupHtml ->->MFormm m)a)
266c266
<            => (Html -> MForm m a)
---
>            => (MarkupHtml ->->MFormm m)a)
282c282
<     => (Html -> MForm m (FormResult a, xml))
---
>     => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
288c288
<                 => (Html -> MForm m a)
---
>                 => (MarkupHtml ->->MFormm m)a)
296c296
<           => (Html -> MForm m a)
---
>           => (MarkupHtml ->->MFormm m)a)
330d329
<   -> (Html -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ()))
331c330
<   -> (Html -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ()))
---
>   -> (MarkupHtml ->->MFormm mFormResultFormResulta,a,WidgetT(HandlerSiteHandlerSitem)m)IOIO()()))
331a331
>   -> (MarkupHtml ->->MFormm mFormResultFormResulta,a,WidgetT(HandlerSiteHandlerSitem)m)IOIO()()))
337a338
> 
341c342
<     mp <- askParams
---
>     mp-- Check if we got its value back.<- askParams
341a343
>     mplet<-missing= (mp >>= Map.lookup identifyFormKey) /= Just [identVal]
343d344
< 
345d345
<     -- data is missing, then do not provide any params to the
346d345
<     -- form, which will turn its result into FormMissing.  Also,
347d345
<     -- doing this avoids having lots of fields with red errors.
348d345
<     let eraseParams | missing   = local (\(_, h, l) -> (Nothing, h, l))
349c346
<                     | otherwise = id
---
>     -- Run the form proper (with our hidden <input>).  If the
349a347
>     -- data is missing, then do not provide any params to the-- form, which will turn its result into FormMissing.  Also,
349a348
>     -- doing this avoids having lots of fields with red errors.-- form, which will turn its result into FormMissing.  Also,
349a349
>     let-- doing this avoids having lots of fields with red errors.eraseParams | missing   = local (\(_, h, l) -> (Nothing, h, l))
349a350
>     let eraseParams | missingotherwise = localid    (\(_, h, l) -> (Nothing, h, l))
349a351
>     eraseParams (form otherwise)= id
351d352
< 
352a354
> identifyFormKey ::= "_formid"
355d356
< 
357d357
<        AForm m a
358c358
<     -> Html
---
> type FormRenderAForm m am a =
358a359
>     -> AFormHtml  m a
358a360
>     -> MarkupMForm m (FormResult a, WidgetT (HandlerSite m) IO ())
360d361
< 
362d362
< -- | Render a form into a series of tr tags. Note that, in order to allow
363d362
< -- you to add extra rows to the table, this function does /not/ wrap up
364d362
< -- the resulting HTML in a table tag; you must do that yourself.
365d362
< renderTable aform fragment = do
366d362
<     (res, views') <- aFormToForm aform
367c363
<     let views = views' []
---
> renderTable-- | Render a form into a series of tr tags. Note that, in order to allow, renderDivs, renderDivsNoLabels :: Monad m => FormRender m a
367a364
> -- you to add extra rows to the table, this function does /not/ wrap up-- | Render a form into a series of tr tags. Note that, in order to allow
367a365
> -- the resulting HTML in a table tag; you must do that yourself.-- you to add extra rows to the table, this function does /not/ wrap up
367a366
> renderTable-- the resulting HTML in a table tag; you must do that yourself.aform fragment = do
367a367
> renderTable(res, views') fragment<- aFormToForm= do  aform
367a368
>     (letres,views= )views'<- aFormToForm[]        aform
367a369
>     let viewswidget==views'[whamlet|
367a370
> $newline never
367a371
> $if null views
367a372
>     \#{fragment}
367a373
> $forall (isFirst, view) <- addIsFirst views
367a374
>     <tr :fvRequired view:.required :not $ fvRequired view:.optional>
367a375
>         <td>
367a376
>             $if isFirst
367a377
>                 \#{fragment}
367a378
>             <label for=#{fvId view}>#{fvLabel view}
367a379
>             $maybe tt <- fvTooltip view
367a380
>                 <div .tooltip>#{tt}
367a381
>         <td>^{fvInput view}
367a382
>         $maybe err <- fvErrors view
367a383
>             <td .errors>#{err}
367a384
> |]                     ]
383d399
< |]
384d399
<     return (res, widget)
385d399
<   where
386c400
<     addIsFirst [] = []
---
> |]  return (res, widget)
386a401
>   where (res, widget)
386a402
>   whereaddIsFirst [] = []
386a403
>     addIsFirst []:=)[] (True, x) : map (False, ) y
388d404
< 
389a406
> renderDivs-- | render a field inside a div= renderDivsMaybeLabels True
391d407
< 
392a409
> renderDivsNoLabels-- | render a field inside a div, not displaying any label= renderDivsMaybeLabels False
394d410
< 
396d411
< renderDivsMaybeLabels withLabels aform fragment = do
397d411
<     (res, views') <- aFormToForm aform
398c412
<     let views = views' []
---
> renderDivsMaybeLabels ::withLabels m =>aformfragment-> FormRender= do   m a
398a413
> renderDivsMaybeLabels(res, views') <- aFormToForm aform fragment = do
398a414
>     (letres,views= )views'<- aFormToForm[]        aform
398a415
>     let viewswidget==views'[whamlet|
398a416
> $newline never
398a417
> \#{fragment}
398a418
> $forall view <- views
398a419
>     <div :fvRequired view:.required :not $ fvRequired view:.optional>
398a420
>         $if withLabels
398a421
>                 <label for=#{fvId view}>#{fvLabel view}
398a422
>         $maybe tt <- fvTooltip view
398a423
>             <div .tooltip>#{tt}
398a424
>         ^{fvInput view}
398a425
>         $maybe err <- fvErrors view
398a426
>             <div .errors>#{err}
398a427
> |]                     ]
411c440
< |]
---
> |]  return (res, widget)
413d441
< 
415d442
< -- If you're using Bootstrap v3, then you should use the
416d442
< -- functions from module "Yesod.Form.Bootstrap3".
417d442
< --
418d442
< -- Sample Hamlet:
419d442
< --
420d442
< -- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
421d442
< -- >    <fieldset>
422d442
< -- >      <legend>_{MsgLegend}
423d442
< -- >      $case result
424d442
< -- >        $of FormFailure reasons
425d442
< -- >          $forall reason <- reasons
426d442
< -- >            <div .alert .alert-error>#{reason}
427d442
< -- >        $of _
428d442
< -- >      ^{formWidget}
429d442
< -- >      <div .form-actions>
430d442
< -- >        <input .btn .primary type=submit value=_{MsgSubmit}>
431d442
< --
432d442
< -- Since 1.3.14
433d442
< renderBootstrap2 :: Monad m => FormRender m a
434d442
< renderBootstrap2 aform fragment = do
435d442
<     (res, views') <- aFormToForm aform
436d442
<     let views = views' []
437d442
<         has (Just _) = True
438c443
<         has Nothing  = False
---
> -- If you're using Bootstrap v3, then you should use the-- | Render a form using Bootstrap v2-friendly shamlet syntax.
438a444
> -- functions from module "Yesod.Form.Bootstrap3".-- If you're using Bootstrap v3, then you should use the
438a445
> ---- functions from module "Yesod.Form.Bootstrap3".
438a446
> ---- Sample Hamlet:
438a447
> ---- Sample Hamlet:
438a448
> ---- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
438a449
> -- >    <fieldset>-- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
438a450
> -- >    <fieldset>-- >      <legend>_{MsgLegend}
438a451
> -- >      $case result-- >      <legend>_{MsgLegend}
438a452
> -- >      $case result-- >        $of FormFailure reasons
438a453
> -- >        $of FormFailure reasons-- >          $forall reason <- reasons
438a454
> -- >          $forall reason <- reasons-- >            <div .alert .alert-error>#{reason}
438a455
> -- >        $of _-- >            <div .alert .alert-error>#{reason}
438a456
> -- >        $of _-- >      ^{formWidget}
438a457
> -- >      ^{formWidget}-- >      <div .form-actions>
438a458
> -- >      <div .form-actions>-- >        <input .btn .primary type=submit value=_{MsgSubmit}>
438a459
> ---- >        <input .btn .primary type=submit value=_{MsgSubmit}>
438a460
> ---- Since 1.3.14
438a461
> -- Since 1.3.14renderBootstrap2 :: Monad m => FormRender m a
438a462
> renderBootstrap2 ::aformfragment => FormRender= do      m a
438a463
> renderBootstrap2(res, views')aform<- aFormToForm =aform
438a464
>     (letres,views= )views'<- aFormToForm[]        aform
438a465
>     let viewshas (Just= views'_) = [True]
438a466
>         has (NothingJust _) = TrueFalse
438a467
>     let haswidget= [whamlet|
438a468
>                 $newline never
438a469
>                 \#{fragment}
438a470
>                 $forall view <- views
438a471
>                     <div .control-group .clearfix :fvRequired view:.required :not $ fvRequired view:.optional :has $ fvErrors view:.error>
438a472
>                         <label .control-label for=#{fvId view}>#{fvLabel view}
438a473
>                         <div .controls .input>
438a474
>                             ^{fvInput view}
438a475
>                             $maybe tt <- fvTooltip view
438a476
>                                 <span .help-block>#{tt}
438a477
>                             $maybe err <- fvErrors view
438a478
>                                 <span .help-block>#{err}
438a479
>                 |]= False
451c492
<                 |]
---
>                 |]return (res, widget)
453d493
< 
455d494
< renderBootstrap :: Monad m => FormRender m a
456c495
< renderBootstrap = renderBootstrap2
---
> renderBootstrap-- | Deprecated synonym for 'renderBootstrap2'.:: Monad m => FormRender m a
456a496
> renderBootstrap ::= renderBootstrap2 m => FormRender m a
456a497
> renderBootstrap{-# DEPRECATED renderBootstrap= renderBootstrap2"Please use the Yesod.Form.Bootstrap3 module." #-}
458d498
< 
460d499
<       => (a -> Either msg a)
461c500
<       -> Field m a
---
> check :: (Monada -> Either, RenderMessagemsg a)     (HandlerSite m) msg)
461a501
>       => (Fielda -> Eitherm a    msg a)
462a503
> check ->f =FieldcheckM a return . f
464d504
< 
466d505
< checkBool :: (Monad m, RenderMessage (HandlerSite m) msg)
467c506
<           => (a -> Bool) -> msg -> Field m a -> Field m a
---
> checkBool-- | Return the given error message if the predicate is false.:: (Monad m, RenderMessage (HandlerSite m) msg)
467a507
> checkBool :: (Monada -> Bool, RenderMessage) -> msg -> FieldHandlerSitem a -> Field) msgm )
467a508
> checkBool =>b s(a ->check$)\->x ->if->b Fieldx thenmRight -> Fieldx elsemLeft   s
469d509
< 
471d510
<        => (a -> m (Either msg a))
472c511
<        -> Field m a
---
> checkM :: (Monada -> mm,Eithermsg a)) (HandlerSite m) msg)
472a512
>        => (Fielda -> m (Either msg a))
473a514
> checkM ->f =FieldcheckMMap a  f id
475d515
< 
477d516
< --
478d516
< -- In order to make this work, you must provide a function to convert back from
479d516
< -- the new datatype to the old one (the second argument to this function).
480d516
< --
481d516
< -- Since 1.1.2
482d516
< checkMMap :: (Monad m, RenderMessage (HandlerSite m) msg)
483d516
<           => (a -> m (Either msg b))
484c517
<           -> (b -> a)
---
> ---- | Same as 'checkM', but modifies the datatype.
484a518
> ---- In order to make this work, you must provide a function to convert back from
484a519
> -- the new datatype to the old one (the second argument to this function).-- In order to make this work, you must provide a function to convert back from
484a520
> ---- the new datatype to the old one (the second argument to this function).
484a521
> ---- Since 1.1.2
484a522
> checkMMap-- Since 1.1.2:: (Monad m, RenderMessage (HandlerSite m) msg)
484a523
> checkMMap :: (Monada -> mm,Eithermsg b)) (HandlerSite m) msg)
484a524
>           => (a -> m)(Either msg b))
484a525
>           -> (Fieldb -> a)a
486d526
<           -> Field m b
487d526
< checkMMap f inv field = field
488d526
<     { fieldParse = \ts fs -> do
489d526
<         e1 <- fieldParse field ts fs
490d526
<         case e1 of
491d526
<             Left msg -> return $ Left msg
492d526
<             Right Nothing -> return $ Right Nothing
493c527
<             Right (Just a) -> liftM (either (Left . SomeMessage) (Right . Just)) $ f a
---
> checkMMap ->f invfield b= field
493a528
> checkMMap{ fieldParse inv field= \ts=fs-> do
493a529
>     { fieldParsee1 <- fieldParse= \ts fsfield-> dots fs
493a530
>                e1case<-e1of       field ts fs
493a531
>                caseLeft ofmsg -> return $ Left msg
493a532
>                    LeftRightmsgNothing return-> return Left$ msgRight Nothing
493a533
>                    Right Nothing(Just a)->->returnliftM $either Nothing(Left . SomeMessage) (Right . Just)) $ f a
493a534
>            , fieldView= (Justi n aa)eres liftMreq ->(eitherfieldViewLeftfield SomeMessagei n a (fmap) (invRighteres)Justreq)) $ f a
496d536
< 
498d537
< customErrorMessage :: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a
499d537
< customErrorMessage msg field = field
500d537
<     { fieldParse = \ts fs ->
501d537
<         liftM (either (const $ Left msg) Right)
502c538
<       $ fieldParse field ts fs
---
> customErrorMessage-- | Allows you to overwrite the error message on parse error.:: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a
502a539
> customErrorMessage ::msgMonadfieldm==>field (HandlerSite m) -> Field m a -> Field m a
502a540
> customErrorMessage{ fieldParse = msg\ts fieldfs -> = field
502a541
>     { fieldParseliftM (either= \ts(fsconst-> $ Left msg) Right)
502a542
>           $ liftMfieldParseeitherfieldconstts fs Left msg) Right)
502a543
>         } $ fieldParse field ts fs
504d544
< 
506c546
< fieldSettingsLabel :: RenderMessage site msg => msg -> FieldSettings site
---
> fieldSettingsLabel-- | Generate a 'FieldSettings' from the given label.:: RenderMessage site msg => msg -> FieldSettings site
506a547
> fieldSettingsLabel ::msgRenderMessage= FieldSettings(SomeMessage => msg ->msgFieldSettings) Nothing NothingNothing []
508d548
< 
510d549
< --
511d549
< -- This is intended to help with the common case where a single input value is
512d549
< -- required, such as when parsing a text field.
513d549
< --
514d549
< -- Since 1.1
515d549
< parseHelper :: (Monad m, RenderMessage site FormMessage)
516d549
<             => (Text -> Either FormMessage a)
517d549
<             -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))
518d549
< parseHelper = parseHelperGen
519d549
< 
520d549
< -- | A generalized version of 'parseHelper', allowing any type for the message
521d549
< -- indicating a bad parse.
522d549
< --
523d549
< -- Since 1.3.6
524d549
< parseHelperGen :: (Monad m, RenderMessage site msg)
525d549
<                => (Text -> Either msg a)
526d549
<                -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))
527d549
< parseHelperGen _ [] _ = return $ Right Nothing
528d549
< parseHelperGen _ ("":_) _ = return $ Right Nothing
529c550
< parseHelperGen f (x:_) _ = return $ either (Left . SomeMessage) (Right . Just) $ f x
---
> ---- | A helper function for creating custom fields.
529a551
> ---- This is intended to help with the common case where a single input value is
529a552
> -- required, such as when parsing a text field.-- This is intended to help with the common case where a single input value is
529a553
> ---- required, such as when parsing a text field.
529a554
> ---- Since 1.1
529a555
> parseHelper-- Since 1.1:: (Monad m, RenderMessage site FormMessage)
531d556
< -- | Since a 'Field' cannot be a 'Functor', it is not obvious how to "reuse" a Field
532d556
< -- on a @newtype@ or otherwise equivalent type. This function allows you to convert
533d556
< -- a @Field m a@ to a @Field m b@ assuming you provide a bidireccional
534d556
< -- convertion among the two, through the first two functions.
535d556
< --
536d556
< -- A simple example:
537d556
< --
538d556
< -- > import Data.Monoid
539d556
< -- > sumField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m (Sum Int)
540d556
< -- > sumField = convertField Sum getSum intField
541d556
< --
542d556
< -- Another example, not using a newtype, but instead creating a Lazy Text field:
543d556
< --
544d556
< -- > import qualified Data.Text.Lazy as TL
545d556
< -- > TextField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m TL.Text
546d556
< -- > lazyTextField = convertField TL.fromStrict TL.toStrict textField
547d556
< --
548d556
< -- Since 1.3.16
549d556
< convertField :: (Functor m)
550d556
<              => (a -> b) -> (b -> a)
551d556
<              -> Field m a -> Field m b
552d556
< convertField to from (Field fParse fView fEnctype) = let
553d556
<   fParse' ts = fmap (fmap (fmap to)) . fParse ts
554d556
<   fView' ti tn at ei = fView ti tn at (fmap from ei)
555d556
<   in Field fParse' fView' fEnctype
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE CPP #-}
module Yesod.Form.Functions
    ( -- * Running in MForm monad
      newFormIdent
    , askParams
    , askFiles
      -- * Applicative/Monadic conversion
    , formToAForm
    , aFormToForm
      -- * Fields to Forms
    , mreq
    , mopt
    , areq
    , aopt
      -- * Run a form
    , runFormPost
    , runFormPostNoToken
    , runFormGet
      -- * Generate a blank form
    , generateFormPost
    , generateFormGet'
    , generateFormGet
      -- * More than one form on a handler
    , identifyForm
      -- * Rendering
    , FormRender
    , renderTable
    , renderDivs
    , renderDivsNoLabels
    , renderBootstrap
    , renderBootstrap2
      -- * Validation
    , check
    , checkBool
    , checkM
    , checkMMap
    , customErrorMessage
      -- * Utilities
    , fieldSettingsLabel
    , parseHelper
    , parseHelperGen
    , convertField
    ) where

import Yesod.Form.Types
import Data.Text (Text, pack)
import Control.Arrow (second)
import Control.Monad.Trans.RWS (ask, get, put, runRWST, tell, evalRWST, local)
import Control.Monad.Trans.Class
import Control.Monad (liftM, join)
import Data.Byteable (constEqBytes)
import Text.Blaze (Markup, toMarkup)
#define Html Markup
#define toHtml toMarkup
import Yesod.Core
import Network.Wai (requestMethod)
import Text.Hamlet (shamlet)
import Data.Monoid (mempty)
import Data.Maybe (listToMaybe, fromMaybe)
import qualified Data.Map as Map
import qualified Data.Text.Encoding as TE
import Control.Arrow (first)

-- | Get a unique identifier.
newFormIdent :: Monad m => MForm m Text
newFormIdent = do
    i <- get
    let i' = incrInts i
    put i'
    return $ pack $ 'f' : show i'
  where
    incrInts (IntSingle i) = IntSingle $ i + 1
    incrInts (IntCons i is) = (i + 1) `IntCons` is

formToAForm :: (HandlerSite m ~ site, Monad m)
            => MForm m (FormResult a, [FieldView site])
            -> AForm m a
formToAForm form = AForm $ \(site, langs) env ints -> do
    ((a, xmls), ints', enc) <- runRWST form (env, site, langs) ints
    return (a, (++) xmls, ints', enc)

aFormToForm :: (Monad m, HandlerSite m ~ site)
            => AForm m a
            -> MForm m (FormResult a, [FieldView site] -> [FieldView site])
aFormToForm (AForm aform) = do
    ints <- get
    (env, site, langs) <- ask
    (a, xml, ints', enc) <- lift $ aform (site, langs) env ints
    put ints'
    tell enc
    return (a, xml)

askParams :: Monad m => MForm m (Maybe Env)
askParams = do
    (x, _, _) <- ask
    return $ liftM fst x

askFiles :: Monad m => MForm m (Maybe FileEnv)
askFiles = do
    (x, _, _) <- ask
    return $ liftM snd x

-- | Converts a form field into monadic form. This field requires a value
-- and will return 'FormFailure' if left empty.
mreq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)
     => Field m a           -- ^ form field
     -> FieldSettings site  -- ^ settings for this field
     -> Maybe a             -- ^ optional default value
     -> MForm m (FormResult a, FieldView site)
mreq field fs mdef = mhelper field fs mdef (\m l -> FormFailure [renderMessage m l MsgValueRequired]) FormSuccess True

-- | Converts a form field into monadic form. This field is optional, i.e.
-- if filled in, it returns 'Just a', if left empty, it returns 'Nothing'.
-- Arguments are the same as for 'mreq' (apart from type of default value).
mopt :: (site ~ HandlerSite m, MonadHandler m)
     => Field m a
     -> FieldSettings site
     -> Maybe (Maybe a)
     -> MForm m (FormResult (Maybe a), FieldView site)
mopt field fs mdef = mhelper field fs (join mdef) (const $ const $ FormSuccess Nothing) (FormSuccess . Just) False

mhelper :: (site ~ HandlerSite m, MonadHandler m)
        => Field m a
        -> FieldSettings site
        -> Maybe a
        -> (site -> [Text] -> FormResult b) -- ^ on missing
        -> (a -> FormResult b) -- ^ on success
        -> Bool -- ^ is it required?
        -> MForm m (FormResult b, FieldView site)

mhelper Field {..} FieldSettings {..} mdef onMissing onFound isReq = do
    tell fieldEnctype
    mp <- askParams
    name <- maybe newFormIdent return fsName
    theId <- lift $ maybe newIdent return fsId
    (_, site, langs) <- ask
    let mr2 = renderMessage site langs
    (res, val) <-
        case mp of
            Nothing -> return (FormMissing, maybe (Left "") Right mdef)
            Just p -> do
                mfs <- askFiles
                let mvals = fromMaybe [] $ Map.lookup name p
                    files = fromMaybe [] $ mfs >>= Map.lookup name
                emx <- lift $ fieldParse mvals files
                return $ case emx of
                    Left (SomeMessage e) -> (FormFailure [renderMessage site langs e], maybe (Left "") Left (listToMaybe mvals))
                    Right mx ->
                        case mx of
                            Nothing -> (onMissing site langs, Left "")
                            Just x -> (onFound x, Right x)
    return (res, FieldView
        { fvLabel = toHtml $ mr2 fsLabel
        , fvTooltip = fmap toHtml $ fmap mr2 fsTooltip
        , fvId = theId
        , fvInput = fieldView theId name fsAttrs val isReq
        , fvErrors =
            case res of
                FormFailure [e] -> Just $ toHtml e
                _ -> Nothing
        , fvRequired = isReq
        })

-- | Applicative equivalent of 'mreq'.
areq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)
     => Field m a
     -> FieldSettings site
     -> Maybe a
     -> AForm m a
areq a b = formToAForm . liftM (second return) . mreq a b

-- | Applicative equivalent of 'mopt'.
aopt :: MonadHandler m
     => Field m a
     -> FieldSettings (HandlerSite m)
     -> Maybe (Maybe a)
     -> AForm m (Maybe a)
aopt a b = formToAForm . liftM (second return) . mopt a b

runFormGeneric :: Monad m
               => MForm m a
               -> HandlerSite m
               -> [Text]
               -> Maybe (Env, FileEnv)
               -> m (a, Enctype)
runFormGeneric form site langs env = evalRWST form (env, site, langs) (IntSingle 0)

-- | This function is used to both initially render a form and to later extract
-- results from it. Note that, due to CSRF protection and a few other issues,
-- forms submitted via GET and POST are slightly different. As such, be sure to
-- call the relevant function based on how the form will be submitted, /not/
-- the current request method.
--
-- For example, a common case is displaying a form on a GET request and having
-- the form submit to a POST page. In such a case, both the GET and POST
-- handlers should use 'runFormPost'.
runFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadResource m, MonadHandler m)
            => (Html -> MForm m (FormResult a, xml))
            -> m ((FormResult a, xml), Enctype)
runFormPost form = do
    env <- postEnv
    postHelper form env

postHelper  :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage)
            => (Html -> MForm m (FormResult a, xml))
            -> Maybe (Env, FileEnv)
            -> m ((FormResult a, xml), Enctype)
postHelper form env = do
    req <- getRequest
    let tokenKey = "_token"
    let token =
            case reqToken req of
                Nothing -> mempty
                Just n -> [shamlet|<input type=hidden name=#{tokenKey} value=#{n}>|]
    m <- getYesod
    langs <- languages
    ((res, xml), enctype) <- runFormGeneric (form token) m langs env
    let res' =
            case (res, env) of
                (FormSuccess{}, Just (params, _))
                    | not (Map.lookup tokenKey params === reqToken req) ->
                        FormFailure [renderMessage m langs MsgCsrfWarning]
                _ -> res
            where (Just [t1]) === (Just t2) = TE.encodeUtf8 t1 `constEqBytes` TE.encodeUtf8 t2
                  Nothing     === Nothing   = True   -- It's important to use constTimeEq
                  _           === _         = False  -- in order to avoid timing attacks.
    return ((res', xml), enctype)

-- | Similar to 'runFormPost', except it always ignores the currently available
-- environment. This is necessary in cases like a wizard UI, where a single
-- page will both receive and incoming form and produce a new, blank form. For
-- general usage, you can stick with @runFormPost@.
generateFormPost
    :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m)
    => (Html -> MForm m (FormResult a, xml))
    -> m (xml, Enctype)
generateFormPost form = first snd `liftM` postHelper form Nothing

postEnv :: (MonadHandler m, MonadResource m)
        => m (Maybe (Env, FileEnv))
postEnv = do
    req <- getRequest
    if requestMethod (reqWaiRequest req) == "GET"
        then return Nothing
        else do
            (p, f) <- runRequestBody
            let p' = Map.unionsWith (++) $ map (\(x, y) -> Map.singleton x [y]) p
            return $ Just (p', Map.unionsWith (++) $ map (\(k, v) -> Map.singleton k [v]) f)

runFormPostNoToken :: MonadHandler m
                   => (Html -> MForm m a)
                   -> m (a, Enctype)
runFormPostNoToken form = do
    langs <- languages
    m <- getYesod
    env <- postEnv
    runFormGeneric (form mempty) m langs env

runFormGet :: MonadHandler m
           => (Html -> MForm m a)
           -> m (a, Enctype)
runFormGet form = do
    gets <- liftM reqGetParams getRequest
    let env =
            case lookup getKey gets of
                Nothing -> Nothing
                Just _ -> Just (Map.unionsWith (++) $ map (\(x, y) -> Map.singleton x [y]) gets, Map.empty)
    getHelper form env

{- FIXME: generateFormGet' "Will be renamed to generateFormGet in next version of Yesod" -}
-- |
--
-- Since 1.3.11
generateFormGet'
    :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m)
    => (Html -> MForm m (FormResult a, xml))
    -> m (xml, Enctype)
generateFormGet' form = first snd `liftM` getHelper form Nothing

{-# DEPRECATED generateFormGet "Will require RenderMessage in next version of Yesod" #-}
generateFormGet :: MonadHandler m
                => (Html -> MForm m a)
                -> m (a, Enctype)
generateFormGet form = getHelper form Nothing

getKey :: Text
getKey = "_hasdata"

getHelper :: MonadHandler m
          => (Html -> MForm m a)
          -> Maybe (Env, FileEnv)
          -> m (a, Enctype)
getHelper form env = do
    let fragment = [shamlet|<input type=hidden name=#{getKey}>|]
    langs <- languages
    m <- getYesod
    runFormGeneric (form fragment) m langs env


-- | Creates a hidden field on the form that identifies it.  This
-- identification is then used to distinguish between /missing/
-- and /wrong/ form data when a single handler contains more than
-- one form.
--
-- For instance, if you have the following code on your handler:
--
-- > ((fooRes, fooWidget), fooEnctype) <- runFormPost fooForm
-- > ((barRes, barWidget), barEnctype) <- runFormPost barForm
--
-- Then replace it with
--
-- > ((fooRes, fooWidget), fooEnctype) <- runFormPost $ identifyForm "foo" fooForm
-- > ((barRes, barWidget), barEnctype) <- runFormPost $ identifyForm "bar" barForm
--
-- Note that it's your responsibility to ensure that the
-- identification strings are unique (using the same one twice on a
-- single handler will not generate any errors).  This allows you
-- to create a variable number of forms and still have them work
-- even if their number or order change between the HTML
-- generation and the form submission.
identifyForm
  :: Monad m
  => Text -- ^ Form identification string.
  -> (Html -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ()))
  -> (Html -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ()))
identifyForm identVal form = \fragment -> do
    -- Create hidden <input>.
    let fragment' =
          [shamlet|
            <input type=hidden name=#{identifyFormKey} value=#{identVal}>
            #{fragment}
          |]

    -- Check if we got its value back.
    mp <- askParams
    let missing = (mp >>= Map.lookup identifyFormKey) /= Just [identVal]

    -- Run the form proper (with our hidden <input>).  If the
    -- data is missing, then do not provide any params to the
    -- form, which will turn its result into FormMissing.  Also,
    -- doing this avoids having lots of fields with red errors.
    let eraseParams | missing   = local (\(_, h, l) -> (Nothing, h, l))
                    | otherwise = id
    eraseParams (form fragment')

identifyFormKey :: Text
identifyFormKey = "_formid"


type FormRender m a =
       AForm m a
    -> Html
    -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ())

renderTable, renderDivs, renderDivsNoLabels :: Monad m => FormRender m a
-- | Render a form into a series of tr tags. Note that, in order to allow
-- you to add extra rows to the table, this function does /not/ wrap up
-- the resulting HTML in a table tag; you must do that yourself.
renderTable aform fragment = do
    (res, views') <- aFormToForm aform
    let views = views' []
    let widget = [whamlet|
$newline never
$if null views
    \#{fragment}
$forall (isFirst, view) <- addIsFirst views
    <tr :fvRequired view:.required :not $ fvRequired view:.optional>
        <td>
            $if isFirst
                \#{fragment}
            <label for=#{fvId view}>#{fvLabel view}
            $maybe tt <- fvTooltip view
                <div .tooltip>#{tt}
        <td>^{fvInput view}
        $maybe err <- fvErrors view
            <td .errors>#{err}
|]
    return (res, widget)
  where
    addIsFirst [] = []
    addIsFirst (x:y) = (True, x) : map (False, ) y

-- | render a field inside a div
renderDivs = renderDivsMaybeLabels True

-- | render a field inside a div, not displaying any label
renderDivsNoLabels = renderDivsMaybeLabels False

renderDivsMaybeLabels :: Monad m => Bool -> FormRender m a
renderDivsMaybeLabels withLabels aform fragment = do
    (res, views') <- aFormToForm aform
    let views = views' []
    let widget = [whamlet|
$newline never
\#{fragment}
$forall view <- views
    <div :fvRequired view:.required :not $ fvRequired view:.optional>
        $if withLabels
                <label for=#{fvId view}>#{fvLabel view}
        $maybe tt <- fvTooltip view
            <div .tooltip>#{tt}
        ^{fvInput view}
        $maybe err <- fvErrors view
            <div .errors>#{err}
|]
    return (res, widget)

-- | Render a form using Bootstrap v2-friendly shamlet syntax.
-- If you're using Bootstrap v3, then you should use the
-- functions from module "Yesod.Form.Bootstrap3".
--
-- Sample Hamlet:
--
-- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
-- >    <fieldset>
-- >      <legend>_{MsgLegend}
-- >      $case result
-- >        $of FormFailure reasons
-- >          $forall reason <- reasons
-- >            <div .alert .alert-error>#{reason}
-- >        $of _
-- >      ^{formWidget}
-- >      <div .form-actions>
-- >        <input .btn .primary type=submit value=_{MsgSubmit}>
--
-- Since 1.3.14
renderBootstrap2 :: Monad m => FormRender m a
renderBootstrap2 aform fragment = do
    (res, views') <- aFormToForm aform
    let views = views' []
        has (Just _) = True
        has Nothing  = False
    let widget = [whamlet|
                $newline never
                \#{fragment}
                $forall view <- views
                    <div .control-group .clearfix :fvRequired view:.required :not $ fvRequired view:.optional :has $ fvErrors view:.error>
                        <label .control-label for=#{fvId view}>#{fvLabel view}
                        <div .controls .input>
                            ^{fvInput view}
                            $maybe tt <- fvTooltip view
                                <span .help-block>#{tt}
                            $maybe err <- fvErrors view
                                <span .help-block>#{err}
                |]
    return (res, widget)

-- | Deprecated synonym for 'renderBootstrap2'.
renderBootstrap :: Monad m => FormRender m a
renderBootstrap = renderBootstrap2
{-# DEPRECATED renderBootstrap "Please use the Yesod.Form.Bootstrap3 module." #-}

check :: (Monad m, RenderMessage (HandlerSite m) msg)
      => (a -> Either msg a)
      -> Field m a
      -> Field m a
check f = checkM $ return . f

-- | Return the given error message if the predicate is false.
checkBool :: (Monad m, RenderMessage (HandlerSite m) msg)
          => (a -> Bool) -> msg -> Field m a -> Field m a
checkBool b s = check $ \x -> if b x then Right x else Left s

checkM :: (Monad m, RenderMessage (HandlerSite m) msg)
       => (a -> m (Either msg a))
       -> Field m a
       -> Field m a
checkM f = checkMMap f id

-- | Same as 'checkM', but modifies the datatype.
--
-- In order to make this work, you must provide a function to convert back from
-- the new datatype to the old one (the second argument to this function).
--
-- Since 1.1.2
checkMMap :: (Monad m, RenderMessage (HandlerSite m) msg)
          => (a -> m (Either msg b))
          -> (b -> a)
          -> Field m a
          -> Field m b
checkMMap f inv field = field
    { fieldParse = \ts fs -> do
        e1 <- fieldParse field ts fs
        case e1 of
            Left msg -> return $ Left msg
            Right Nothing -> return $ Right Nothing
            Right (Just a) -> liftM (either (Left . SomeMessage) (Right . Just)) $ f a
    , fieldView = \i n a eres req -> fieldView field i n a (fmap inv eres) req
    }

-- | Allows you to overwrite the error message on parse error.
customErrorMessage :: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a
customErrorMessage msg field = field
    { fieldParse = \ts fs ->
        liftM (either (const $ Left msg) Right)
      $ fieldParse field ts fs
    }

-- | Generate a 'FieldSettings' from the given label.
fieldSettingsLabel :: RenderMessage site msg => msg -> FieldSettings site
fieldSettingsLabel msg = FieldSettings (SomeMessage msg) Nothing Nothing Nothing []

-- | A helper function for creating custom fields.
--
-- This is intended to help with the common case where a single input value is
-- required, such as when parsing a text field.
--
-- Since 1.1
parseHelper :: (Monad m, RenderMessage site FormMessage)
            => (Text -> Either FormMessage a)
            -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))
parseHelper = parseHelperGen

-- | A generalized version of 'parseHelper', allowing any type for the message
-- indicating a bad parse.
--
-- Since 1.3.6
parseHelperGen :: (Monad m, RenderMessage site msg)
               => (Text -> Either msg a)
               -> [Text] -> [FileInfo] -> m (Either (SomeMessage site) (Maybe a))
parseHelperGen _ [] _ = return $ Right Nothing
parseHelperGen _ ("":_) _ = return $ Right Nothing
parseHelperGen f (x:_) _ = return $ either (Left . SomeMessage) (Right . Just) $ f x

-- | Since a 'Field' cannot be a 'Functor', it is not obvious how to "reuse" a Field
-- on a @newtype@ or otherwise equivalent type. This function allows you to convert
-- a @Field m a@ to a @Field m b@ assuming you provide a bidireccional
-- convertion among the two, through the first two functions.
--
-- A simple example:
--
-- > import Data.Monoid
-- > sumField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m (Sum Int)
-- > sumField = convertField Sum getSum intField
--
-- Another example, not using a newtype, but instead creating a Lazy Text field:
--
-- > import qualified Data.Text.Lazy as TL
-- > TextField :: (Functor m, Monad m, RenderMessage (HandlerSite m) FormMessage) => Field m TL.Text
-- > lazyTextField = convertField TL.fromStrict TL.toStrict textField
--
-- Since 1.3.16
convertField :: (Functor m)
             => (a -> b) -> (b -> a)
             -> Field m a -> Field m b
convertField to from (Field fParse fView fEnctype) = let
  fParse' ts = fmap (fmap (fmap to)) . fParse ts
  fView' ti tn at ei = fView ti tn at (fmap from ei)
  in Field fParse' fView' fEnctype
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE CPP #-}
module Yesod.Form.Functions
    ( -- * Running in MForm monad
      newFormIdent
    , askParams
    , askFiles
      -- * Applicative/Monadic conversion
    , formToAForm
    , aFormToForm
      -- * Fields to Forms
    , mreq
    , mopt
    , areq
    , aopt
      -- * Run a form
    , runFormPost
    , runFormPostNoToken
    , runFormGet
      -- * Generate a blank form
    , generateFormPost
    , generateFormGet'
    , generateFormGet
      -- * More than one form on a handler
    , identifyForm
      -- * Rendering
    , FormRender
    , renderTable
    , renderDivs
    , renderDivsNoLabels
    , renderBootstrap
    , renderBootstrap2
      -- * Validation
    , check
    , checkBool
    , checkM
    , checkMMap
    , customErrorMessage
      -- * Utilities
    , fieldSettingsLabel
    , parseHelper
    , parseHelperGen
    , convertField
    ) where

import Yesod.Form.Types
import Data.Text (Text, pack)
import Control.Arrow (second)
import Control.Monad.Trans.RWS (ask, get, put, runRWST, tell, evalRWST, local)
import Control.Monad.Trans.Class
import Control.Monad (liftM, join)
import Data.Byteable (constEqBytes)
import Text.Blaze (Markup, toMarkup)
#define Html Markup
#define toHtml toMarkup
import Yesod.Core
import Network.Wai (requestMethod)
import Text.Hamlet (shamlet)
import Data.Monoid (mempty)
import Data.Maybe (listToMaybe, fromMaybe)
import qualified Data.Map as Map
import qualified Data.Text.Encoding as TE
import Control.Arrow (first)

-- | Get a unique identifier.
newFormIdent :: Monad m => MForm m Text
newFormIdent = do
    i <- get
    let i' = incrInts i
    put i'
    return $ pack $ 'f' : show i'
  where
    incrInts (IntSingle i) = IntSingle $ i + 1
    incrInts (IntCons i is) = (i + 1) `IntCons` is

formToAForm :: (HandlerSite m ~ site, Monad m)
            => MForm m (FormResult a, [FieldView site])
            -> AForm m a
formToAForm form = AForm $ \(site, langs) env ints -> do
    ((a, xmls), ints', enc) <- runRWST form (env, site, langs) ints
    return (a, (++) xmls, ints', enc)

aFormToForm :: (Monad m, HandlerSite m ~ site)
            => AForm m a
            -> MForm m (FormResult a, [FieldView site] -> [FieldView site])
aFormToForm (AForm aform) = do
    ints <- get
    (env, site, langs) <- ask
    (a, xml, ints', enc) <- lift $ aform (site, langs) env ints
    put ints'
    tell enc
    return (a, xml)

askParams :: Monad m => MForm m (Maybe Env)
askParams = do
    (x, _, _) <- ask
    return $ liftM fst x

askFiles :: Monad m => MForm m (Maybe FileEnv)
askFiles = do
    (x, _, _) <- ask
    return $ liftM snd x

-- | Converts a form field into monadic form. This field requires a value
-- and will return 'FormFailure' if left empty.
mreq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)
     => Field m a           -- ^ form field
     -> FieldSettings site  -- ^ settings for this field
     -> Maybe a             -- ^ optional default value
     -> MForm m (FormResult a, FieldView site)
mreq field fs mdef = mhelper field fs mdef (\m l -> FormFailure [renderMessage m l MsgValueRequired]) FormSuccess True

-- | Converts a form field into monadic form. This field is optional, i.e.
-- if filled in, it returns 'Just a', if left empty, it returns 'Nothing'.
-- Arguments are the same as for 'mreq' (apart from type of default value).
mopt :: (site ~ HandlerSite m, MonadHandler m)
     => Field m a
     -> FieldSettings site
     -> Maybe (Maybe a)
     -> MForm m (FormResult (Maybe a), FieldView site)
mopt field fs mdef = mhelper field fs (join mdef) (const $ const $ FormSuccess Nothing) (FormSuccess . Just) False

mhelper :: (site ~ HandlerSite m, MonadHandler m)
        => Field m a
        -> FieldSettings site
        -> Maybe a
        -> (site -> [Text] -> FormResult b) -- ^ on missing
        -> (a -> FormResult b) -- ^ on success
        -> Bool -- ^ is it required?
        -> MForm m (FormResult b, FieldView site)

mhelper Field {..} FieldSettings {..} mdef onMissing onFound isReq = do
    tell fieldEnctype
    mp <- askParams
    name <- maybe newFormIdent return fsName
    theId <- lift $ maybe newIdent return fsId
    (_, site, langs) <- ask
    let mr2 = renderMessage site langs
    (res, val) <-
        case mp of
            Nothing -> return (FormMissing, maybe (Left "") Right mdef)
            Just p -> do
                mfs <- askFiles
                let mvals = fromMaybe [] $ Map.lookup name p
                    files = fromMaybe [] $ mfs >>= Map.lookup name
                emx <- lift $ fieldParse mvals files
                return $ case emx of
                    Left (SomeMessage e) -> (FormFailure [renderMessage site langs e], maybe (Left "") Left (listToMaybe mvals))
                    Right mx ->
                        case mx of
                            Nothing -> (onMissing site langs, Left "")
                            Just x -> (onFound x, Right x)
    return (res, FieldView
        { fvLabel = toMarkuptoHtml $ $mr2fsLabel
        , fvTooltip = fmap toMarkuptoHtml $ $fmapmr2fsTooltip
        , fvId = theId
        , fvInput = fieldView theId name fsAttrs val isReq
        , fvErrors =
            case res of
                FormFailure [e] -> Just $ toMarkuptoHtml e e
                _ -> Nothing
        , fvRequired = isReq
        })

-- | Applicative equivalent of 'mreq'.
areq :: (RenderMessage site FormMessage, HandlerSite m ~ site, MonadHandler m)
     => Field m a
     -> FieldSettings site
     -> Maybe a
     -> AForm m a
areq a b = formToAForm . liftM (second return) . mreq a b

-- | Applicative equivalent of 'mopt'.
aopt :: MonadHandler m
     => Field m a
     -> FieldSettings (HandlerSite m)
     -> Maybe (Maybe a)
     -> AForm m (Maybe a)
aopt a b = formToAForm . liftM (second return) . mopt a b

runFormGeneric :: Monad m
               => MForm m a
               -> HandlerSite m
               -> [Text]
               -> Maybe (Env, FileEnv)
               -> m (a, Enctype)
runFormGeneric form site langs env = evalRWST form (env, site, langs) (IntSingle 0)

-- | This function is used to both initially render a form and to later extract
-- results from it. Note that, due to CSRF protection and a few other issues,
-- forms submitted via GET and POST are slightly different. As such, be sure to
-- call the relevant function based on how the form will be submitted, /not/
-- the current request method.
--
-- For example, a common case is displaying a form on a GET request and having
-- the form submit to a POST page. In such a case, both the GET and POST
-- handlers should use 'runFormPost'.
runFormPost :: (RenderMessage (HandlerSite m) FormMessage, MonadResource m, MonadHandler m)
            => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
            -> m ((FormResult a, xml), Enctype)
runFormPost form = do
    env <- postEnv
    postHelper form env

postHelper  :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage)
            => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
            -> Maybe (Env, FileEnv)
            -> m ((FormResult a, xml), Enctype)
postHelper form env = do
    req <- getRequest
    let tokenKey = "_token"
    let token =
            case reqToken req of
                Nothing -> mempty
                Just n -> [shamlet|<input type=hidden name=#{tokenKey} value=#{n}>|]
    m <- getYesod
    langs <- languages
    ((res, xml), enctype) <- runFormGeneric (form token) m langs env
    let res' =
            case (res, env) of
                (FormSuccess{}, Just (params, _))
                    | not (Map.lookup tokenKey params === reqToken req) ->
                        FormFailure [renderMessage m langs MsgCsrfWarning]
                _ -> res
            where (Just [t1]) === (Just t2) = TE.encodeUtf8 t1 `constEqBytes` TE.encodeUtf8 t2
                  Nothing     === Nothing   = True   -- It's important to use constTimeEq
                  _           === _         = False  -- in order to avoid timing attacks.
    return ((res', xml), enctype)

-- | Similar to 'runFormPost', except it always ignores the currently available
-- environment. This is necessary in cases like a wizard UI, where a single
-- page will both receive and incoming form and produce a new, blank form. For
-- general usage, you can stick with @runFormPost@.
generateFormPost
    :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m)
    => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
    -> m (xml, Enctype)
generateFormPost form = first snd `liftM` postHelper form Nothing

postEnv :: (MonadHandler m, MonadResource m)
        => m (Maybe (Env, FileEnv))
postEnv = do
    req <- getRequest
    if requestMethod (reqWaiRequest req) == "GET"
        then return Nothing
        else do
            (p, f) <- runRequestBody
            let p' = Map.unionsWith (++) $ map (\(x, y) -> Map.singleton x [y]) p
            return $ Just (p', Map.unionsWith (++) $ map (\(k, v) -> Map.singleton k [v]) f)

runFormPostNoToken :: MonadHandler m
                   => (MarkupHtml ->->MFormm m)a)
                   -> m (a, Enctype)
runFormPostNoToken form = do
    langs <- languages
    m <- getYesod
    env <- postEnv
    runFormGeneric (form mempty) m langs env

runFormGet :: MonadHandler m
           => (MarkupHtml ->->MFormm m)a)
           -> m (a, Enctype)
runFormGet form = do
    gets <- liftM reqGetParams getRequest
    let env =
            case lookup getKey gets of
                Nothing -> Nothing
                Just _ -> Just (Map.unionsWith (++) $ map (\(x, y) -> Map.singleton x [y]) gets, Map.empty)
    getHelper form env

{- FIXME: generateFormGet' "Will be renamed to generateFormGet in next version of Yesod" -}
-- |
--
-- Since 1.3.11
generateFormGet'
    :: (RenderMessage (HandlerSite m) FormMessage, MonadHandler m)
    => (MarkupHtml ->->MFormm mFormResultFormResulta,a,xml))))
    -> m (xml, Enctype)
generateFormGet' form = first snd `liftM` getHelper form Nothing

{-# DEPRECATED generateFormGet "Will require RenderMessage in next version of Yesod" #-}
generateFormGet :: MonadHandler m
                => (MarkupHtml ->->MFormm m)a)
                -> m (a, Enctype)
generateFormGet form = getHelper form Nothing

getKey :: Text
getKey = "_hasdata"

getHelper :: MonadHandler m
          => (MarkupHtml ->->MFormm m)a)
          -> Maybe (Env, FileEnv)
          -> m (a, Enctype)
getHelper form env = do
    let fragment = [shamlet|<input type=hidden name=#{getKey}>|]
    langs <- languages
    m <- getYesod
    runFormGeneric (form fragment) m langs env


-- | Creates a hidden field on the form that identifies it.  This
-- identification is then used to distinguish between /missing/
-- and /wrong/ form data when a single handler contains more than
-- one form.
--
-- For instance, if you have the following code on your handler:
--
-- > ((fooRes, fooWidget), fooEnctype) <- runFormPost fooForm
-- > ((barRes, barWidget), barEnctype) <- runFormPost barForm
--
-- Then replace it with
--
-- > ((fooRes, fooWidget), fooEnctype) <- runFormPost $ identifyForm "foo" fooForm
-- > ((barRes, barWidget), barEnctype) <- runFormPost $ identifyForm "bar" barForm
--
-- Note that it's your responsibility to ensure that the
-- identification strings are unique (using the same one twice on a
-- single handler will not generate any errors).  This allows you
-- to create a variable number of forms and still have them work
-- even if their number or order change between the HTML
-- generation and the form submission.
identifyForm
  :: Monad m
  => Text -- ^ Form identification string.
  -> (MarkupHtml ->->MFormm mFormResultFormResulta,a,WidgetT(HandlerSiteHandlerSitem)m)IOIO()()))
  -> (MarkupHtml ->->MFormm mFormResultFormResulta,a,WidgetT(HandlerSiteHandlerSitem)m)IOIO()()))
identifyForm identVal form = \fragment -> do
    -- Create hidden <input>.
    let fragment' =
          [shamlet|
            <input type=hidden name=#{identifyFormKey} value=#{identVal}>
            #{fragment}

          |]

    -- Check if we got its value back.
    mp-- Check if we got its value back.<- askParams
    mplet<-missing= (mp >>= Map.lookup identifyFormKey) /= Just [identVal]
    let missing = (mp >>= Map.lookup identifyFormKey) /= Just [identVal]
    -- Run the form proper (with our hidden <input>).  If the
    -- Run the form proper (with our hidden <input>).  If the
    -- data is missing, then do not provide any params to the-- form, which will turn its result into FormMissing.  Also,
    -- doing this avoids having lots of fields with red errors.-- form, which will turn its result into FormMissing.  Also,
    let-- doing this avoids having lots of fields with red errors.eraseParams | missing   = local (\(_, h, l) -> (Nothing, h, l))
    let eraseParams | missingotherwise = localid    (\(_, h, l) -> (Nothing, h, l))
    eraseParams (form otherwise)= id
    eraseParams (form fragment')
identifyFormKey :: Text
identifyFormKey ::= "_formid"
identifyFormKey = "_formid"

type FormRender m a =
type FormRenderAForm m am a =
    -> AFormHtml  m a
    -> MarkupMForm m (FormResult a, WidgetT (HandlerSite m) IO ())
    -> MForm m (FormResult a, WidgetT (HandlerSite m) IO ())
renderTable, renderDivs, renderDivsNoLabels :: Monad m => FormRender m a
renderTable-- | Render a form into a series of tr tags. Note that, in order to allow, renderDivs, renderDivsNoLabels :: Monad m => FormRender m a
-- you to add extra rows to the table, this function does /not/ wrap up-- | Render a form into a series of tr tags. Note that, in order to allow
-- the resulting HTML in a table tag; you must do that yourself.-- you to add extra rows to the table, this function does /not/ wrap up
renderTable-- the resulting HTML in a table tag; you must do that yourself.aform fragment = do
renderTable(res, views') fragment<- aFormToForm= do  aform
    (letres,views= )views'<- aFormToForm[]        aform
    let viewswidget==views'[whamlet|
$newline never
$if null views
    \#{fragment}
$forall (isFirst, view) <- addIsFirst views
    <tr :fvRequired view:.required :not $ fvRequired view:.optional>
        <td>
            $if isFirst
                \#{fragment}
            <label for=#{fvId view}>#{fvLabel view}
            $maybe tt <- fvTooltip view
                <div .tooltip>#{tt}
        <td>^{fvInput view}
        $maybe err <- fvErrors view
            <td .errors>#{err}
|]                     ]
    let widget = [whamlet|
$newline never
$if null views
    \#{fragment}
$forall (isFirst, view) <- addIsFirst views
    <tr :fvRequired view:.required :not $ fvRequired view:.optional>
        <td>
            $if isFirst
                \#{fragment}
            <label for=#{fvId view}>#{fvLabel view}
            $maybe tt <- fvTooltip view
                <div .tooltip>#{tt}
        <td>^{fvInput view}
        $maybe err <- fvErrors view
            <td .errors>#{err}
|]  return (res, widget)
  where (res, widget)
  whereaddIsFirst [] = []
    addIsFirst []:=)[] (True, x) : map (False, ) y
    addIsFirst (x:y) = (True, x) : map (False, ) y
-- | render a field inside a div
renderDivs-- | render a field inside a div= renderDivsMaybeLabels True
renderDivs = renderDivsMaybeLabels True
-- | render a field inside a div, not displaying any label
renderDivsNoLabels-- | render a field inside a div, not displaying any label= renderDivsMaybeLabels False
renderDivsNoLabels = renderDivsMaybeLabels False
renderDivsMaybeLabels :: Monad m => Bool -> FormRender m a
renderDivsMaybeLabels ::withLabels m =>aformfragment-> FormRender= do   m a
renderDivsMaybeLabels(res, views') <- aFormToForm aform fragment = do
    (letres,views= )views'<- aFormToForm[]        aform
    let viewswidget==views'[whamlet|
$newline never
\#{fragment}
$forall view <- views
    <div :fvRequired view:.required :not $ fvRequired view:.optional>
        $if withLabels
                <label for=#{fvId view}>#{fvLabel view}
        $maybe tt <- fvTooltip view
            <div .tooltip>#{tt}
        ^{fvInput view}
        $maybe err <- fvErrors view
            <div .errors>#{err}
|]                     ]
    let widget = [whamlet|
$newline never
\#{fragment}
$forall view <- views
    <div :fvRequired view:.required :not $ fvRequired view:.optional>
        $if withLabels
                <label for=#{fvId view}>#{fvLabel view}
        $maybe tt <- fvTooltip view
            <div .tooltip>#{tt}
        ^{fvInput view}
        $maybe err <- fvErrors view
            <div .errors>#{err}
|]  return (res, widget)
    return (res, widget)
-- | Render a form using Bootstrap v2-friendly shamlet syntax.
-- If you're using Bootstrap v3, then you should use the-- | Render a form using Bootstrap v2-friendly shamlet syntax.
-- functions from module "Yesod.Form.Bootstrap3".-- If you're using Bootstrap v3, then you should use the
---- functions from module "Yesod.Form.Bootstrap3".
---- Sample Hamlet:
---- Sample Hamlet:
---- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
-- >    <fieldset>-- >  <form .form-horizontal method=post action=@{ActionR} enctype=#{formEnctype}>
-- >    <fieldset>-- >      <legend>_{MsgLegend}
-- >      $case result-- >      <legend>_{MsgLegend}
-- >      $case result-- >        $of FormFailure reasons
-- >        $of FormFailure reasons-- >          $forall reason <- reasons
-- >          $forall reason <- reasons-- >            <div .alert .alert-error>#{reason}
-- >        $of _-- >            <div .alert .alert-error>#{reason}
-- >        $of _-- >      ^{formWidget}
-- >      ^{formWidget}-- >      <div .form-actions>
-- >      <div .form-actions>-- >        <input .btn .primary type=submit value=_{MsgSubmit}>
---- >        <input .btn .primary type=submit value=_{MsgSubmit}>
---- Since 1.3.14
-- Since 1.3.14renderBootstrap2 :: Monad m => FormRender m a
renderBootstrap2 ::aformfragment => FormRender= do      m a
renderBootstrap2(res, views')aform<- aFormToForm =aform
    (letres,views= )views'<- aFormToForm[]        aform
    let viewshas (Just= views'_) = [True]
        has (NothingJust _) = TrueFalse
    let haswidget= [whamlet|
                $newline never
                \#{fragment}
                $forall view <- views
                    <div .control-group .clearfix :fvRequired view:.required :not $ fvRequired view:.optional :has $ fvErrors view:.error>
                        <label .control-label for=#{fvId view}>#{fvLabel view}
                        <div .controls .input>
                            ^{fvInput view}
                            $maybe tt <- fvTooltip view
                                <span .help-block>#{tt}
                            $maybe err <- fvErrors view
                                <span .help-block>#{err}
                |]= False
    let widget = [whamlet|
                $newline never
                \#{fragment}
                $forall view <- views
                    <div .control-group .clearfix :fvRequired view:.required :not $ fvRequired view:.optional :has $ fvErrors view:.error>
                        <label .control-label for=#{fvId view}>#{fvLabel view}
                        <div .controls .input>
                            ^{fvInput view}
                            $maybe tt <- fvTooltip view
                                <span .help-block>#{tt}
                            $maybe err <- fvErrors view
                                <span .help-block>#{err}
                |]return (res, widget)
    return (res, widget)
-- | Deprecated synonym for 'renderBootstrap2'.
renderBootstrap-- | Deprecated synonym for 'renderBootstrap2'.:: Monad m => FormRender m a
renderBootstrap ::= renderBootstrap2 m => FormRender m a
renderBootstrap{-# DEPRECATED renderBootstrap= renderBootstrap2"Please use the Yesod.Form.Bootstrap3 module." #-}
{-# DEPRECATED renderBootstrap "Please use the Yesod.Form.Bootstrap3 module." #-}
check :: (Monad m, RenderMessage (HandlerSite m) msg)
check :: (Monada -> Either, RenderMessagemsg a)     (HandlerSite m) msg)
      => (Fielda -> Eitherm a    msg a)
      -> Field m a
check ->f =FieldcheckM a return . f
check f = checkM $ return . f
-- | Return the given error message if the predicate is false.
checkBool-- | Return the given error message if the predicate is false.:: (Monad m, RenderMessage (HandlerSite m) msg)
checkBool :: (Monada -> Bool, RenderMessage) -> msg -> FieldHandlerSitem a -> Field) msgm )
checkBool =>b s(a ->check$)\->x ->if->b Fieldx thenmRight -> Fieldx elsemLeft   s
checkBool b s = check $ \x -> if b x then Right x else Left s
checkM :: (Monad m, RenderMessage (HandlerSite m) msg)
checkM :: (Monada -> mm,Eithermsg a)) (HandlerSite m) msg)
       => (Fielda -> m (Either msg a))
       -> Field m a
checkM ->f =FieldcheckMMap a  f id
checkM f = checkMMap f id
-- | Same as 'checkM', but modifies the datatype.
---- | Same as 'checkM', but modifies the datatype.
---- In order to make this work, you must provide a function to convert back from
-- the new datatype to the old one (the second argument to this function).-- In order to make this work, you must provide a function to convert back from
---- the new datatype to the old one (the second argument to this function).
---- Since 1.1.2
checkMMap-- Since 1.1.2:: (Monad m, RenderMessage (HandlerSite m) msg)
checkMMap :: (Monada -> mm,Eithermsg b)) (HandlerSite m) msg)
          => (a -> m)(Either msg b))
          -> (Fieldb -> a)a
          -> Field m a
checkMMap ->f invfield b= field
checkMMap{ fieldParse inv field= \ts=fs-> do
    { fieldParsee1 <- fieldParse= \ts fsfield-> dots fs
               e1case<-e1of       field ts fs
               caseLeft ofmsg -> return $ Left msg
                   LeftRightmsgNothing return-> return Left$ msgRight Nothing
                   Right Nothing(Just a)->->returnliftM $either Nothing(Left . SomeMessage) (Right . Just)) $ f a
           , fieldView= (Justi n aa)eres liftMreq ->(eitherfieldViewLeftfield SomeMessagei n a (fmap) (invRighteres)Justreq)) $ f a
    , fieldView = \i n a eres req -> fieldView field i n a (fmap inv eres) req
    }
-- | Allows you to overwrite the error message on parse error.
customErrorMessage-- | Allows you to overwrite the error message on parse error.:: Monad m => SomeMessage (HandlerSite m) -> Field m a -> Field m a
customErrorMessage ::msgMonadfieldm==>field (HandlerSite m) -> Field m a -> Field m a
customErrorMessage{ fieldParse = msg\ts fieldfs -> = field
    { fieldParseliftM (either= \ts(fsconst-> $ Left msg) Right)
          $ liftMfieldParseeitherfieldconstts fs Left msg) Right)
        } $ fieldParse field ts fs
    }
-- | Generate a 'FieldSettings' from the given label.
fieldSettingsLabel-- | Generate a 'FieldSettings' from the given label.:: RenderMessage site msg => msg -> FieldSettings site
fieldSettingsLabel ::msgRenderMessage= FieldSettings(SomeMessage => msg ->msgFieldSettings) Nothing NothingNothing []
fieldSettingsLabel msg = FieldSettings (SomeMessage msg) Nothing Nothing Nothing []
-- | A helper function for creating custom fields.
---- | A helper function for creating custom fields.
---- This is intended to help with the common case where a single input value is
-- required, such as when parsing a text field.-- This is intended to help with the common case where a single input value is
---- required, such as when parsing a text field.
---- Since 1.1
parseHelper-- Since 1.1:: (Monad m, RenderMessage site FormMessage)

</pre>