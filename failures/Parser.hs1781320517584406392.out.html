<a href="Parser.hs1714891891809985650.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Parser.hs2018639011849905494.out.html">next</a></br></br><pre>28c28
< {-# LINE 41 "src/ehc/HS/Parser.chs" #-}
---
> 
28a29
> 
28a30
> 
28a31
> 
28a32
> 
28a33
> 
28a34
> 
28a35
> 
28a36
> 
28a37
> 
28a38
> 
28a39
> 
28a40
> 
41c53
< {-# LINE 55 "src/ehc/HS/Parser.chs" #-}
---
> 
41a54
> 
48c61
< {-# LINE 63 "src/ehc/HS/Parser.chs" #-}
---
> 
48a62
> 
52c66
< {-# LINE 72 "src/ehc/HS/Parser.chs" #-}
---
> 
52a67
> 
52a68
> 
52a69
> 
52a70
> 
52a71
> 
57c76
< {-# LINE 78 "src/ehc/HS/Parser.chs" #-}
---
> 
57a77
> 
62c82
< {-# LINE 88 "src/ehc/HS/Parser.chs" #-}
---
> 
62a83
> 
62a84
> 
62a85
> 
62a86
> 
62a87
> 
67c92
< {-# LINE 102 "src/ehc/HS/Parser.chs" #-}
---
> 
67a93
> 
67a94
> 
67a95
> 
67a96
> 
67a97
> 
67a98
> 
67a99
> 
67a100
> 
67a101
> 
78c112
< {-# LINE 118 "src/ehc/HS/Parser.chs" #-}
---
> 
78a113
> 
78a114
> 
78a115
> 
78a116
> 
78a117
> 
100c139
< {-# LINE 145 "src/ehc/HS/Parser.chs" #-}
---
> 
100a140
> 
100a141
> 
100a142
> 
100a143
> 
100a144
> 
109c153
< {-# LINE 171 "src/ehc/HS/Parser.chs" #-}
---
> 
109a154
> 
109a155
> 
109a156
> 
109a157
> 
109a158
> 
109a159
> 
109a160
> 
109a161
> 
109a162
> 
109a163
> 
109a164
> 
109a165
> 
109a166
> 
109a167
> 
109a168
> 
109a169
> 
109a170
> 
122c183
< {-# LINE 185 "src/ehc/HS/Parser.chs" #-}
---
> 
122a184
> 
135c197
< {-# LINE 199 "src/ehc/HS/Parser.chs" #-}
---
> 
135a198
> 
155c218
< {-# LINE 224 "src/ehc/HS/Parser.chs" #-}
---
> 
155a219
> 
155a220
> 
155a221
> 
155a222
> 
155a223
> 
165c233
< {-# LINE 239 "src/ehc/HS/Parser.chs" #-}
---
> 
165a234
> 
165a235
> 
165a236
> 
165a237
> 
165a238
> 
171c244
< {-# LINE 246 "src/ehc/HS/Parser.chs" #-}
---
> 
171a245
> 
175c249
< {-# LINE 251 "src/ehc/HS/Parser.chs" #-}
---
> 
175a250
> 
187c262
< {-# LINE 275 "src/ehc/HS/Parser.chs" #-}
---
> 
187a263
> 
187a264
> 
187a265
> 
187a266
> 
187a267
> 
187a268
> 
187a269
> 
187a270
> 
187a271
> 
187a272
> 
187a273
> 
187a274
> 
200c287
< {-# LINE 299 "src/ehc/HS/Parser.chs" #-}
---
> 
200a288
> 
200a289
> 
200a290
> 
200a291
> 
200a292
> 
200a293
> 
200a294
> 
200a295
> 
200a296
> 
200a297
> 
200a298
> 
210c308
< {-# LINE 314 "src/ehc/HS/Parser.chs" #-}
---
> 
210a309
> 
210a310
> 
210a311
> 
210a312
> 
210a313
> 
219c322
< {-# LINE 324 "src/ehc/HS/Parser.chs" #-}
---
> 
219a323
> 
229c333
< {-# LINE 339 "src/ehc/HS/Parser.chs" #-}
---
> 
229a334
> 
229a335
> 
229a336
> 
229a337
> 
229a338
> 
240c349
< {-# LINE 355 "src/ehc/HS/Parser.chs" #-}
---
> 
240a350
> 
240a351
> 
240a352
> 
240a353
> 
240a354
> 
284c398
< {-# LINE 410 "src/ehc/HS/Parser.chs" #-}
---
> 
284a399
> 
284a400
> 
284a401
> 
284a402
> 
284a403
> 
284a404
> 
284a405
> 
284a406
> 
284a407
> 
284a408
> 
284a409
> 
292c417
< {-# LINE 419 "src/ehc/HS/Parser.chs" #-}
---
> 
292a418
> 
301c427
< {-# LINE 431 "src/ehc/HS/Parser.chs" #-}
---
> 
301a428
> 
301a429
> 
301a430
> 
308c437
< {-# LINE 443 "src/ehc/HS/Parser.chs" #-}
---
> 
308a438
> 
308a439
> 
308a440
> 
308a441
> 
308a442
> 
337c471
< {-# LINE 495 "src/ehc/HS/Parser.chs" #-}
---
> 
337a472
> 
337a473
> 
337a474
> 
337a475
> 
337a476
> 
337a477
> 
337a478
> 
337a479
> 
337a480
> 
337a481
> 
337a482
> 
337a483
> 
337a484
> 
337a485
> 
337a486
> 
337a487
> 
337a488
> 
337a489
> 
337a490
> 
337a491
> 
337a492
> 
337a493
> 
337a494
> 
342c499
< {-# LINE 501 "src/ehc/HS/Parser.chs" #-}
---
> 
342a500
> 
347c505
< {-# LINE 507 "src/ehc/HS/Parser.chs" #-}
---
> 
347a506
> 
349c508
< {-# LINE 510 "src/ehc/HS/Parser.chs" #-}
---
> 
349a509
> 
355c515
< {-# LINE 517 "src/ehc/HS/Parser.chs" #-}
---
> 
355a516
> 
361c522
< {-# LINE 524 "src/ehc/HS/Parser.chs" #-}
---
> 
361a523
> 
366c528
< {-# LINE 530 "src/ehc/HS/Parser.chs" #-}
---
> 
366a529
> 
372c535
< {-# LINE 541 "src/ehc/HS/Parser.chs" #-}
---
> 
372a536
> 
372a537
> 
372a538
> 
372a539
> 
372a540
> 
384c552
< {-# LINE 560 "src/ehc/HS/Parser.chs" #-}
---
> 
384a553
> 
384a554
> 
384a555
> 
384a556
> 
384a557
> 
384a558
> 
384a559
> 
399c574
< {-# LINE 580 "src/ehc/HS/Parser.chs" #-}
---
> 
399a575
> 
399a576
> 
399a577
> 
399a578
> 
399a579
> 
405c585
< {-# LINE 587 "src/ehc/HS/Parser.chs" #-}
---
> 
405a586
> 
422c603
< {-# LINE 607 "src/ehc/HS/Parser.chs" #-}
---
> 
422a604
> 
422a605
> 
422a606
> 
430c614
< {-# LINE 620 "src/ehc/HS/Parser.chs" #-}
---
> 
430a615
> 
430a616
> 
430a617
> 
430a618
> 
430a619
> 
435d623
< {-# LINE 631 "src/ehc/HS/Parser.chs" #-}
436a625
> 
436a626
> 
436a627
> 
436a628
> 
436a629
> 
436a630
> 
436a631
> 
445c640
< {-# LINE 647 "src/ehc/HS/Parser.chs" #-}
---
> 
445a641
> 
445a642
> 
445a643
> 
445a644
> 
445a645
> 
445a646
> 
478c679
< {-# LINE 685 "src/ehc/HS/Parser.chs" #-}
---
> 
478a680
> 
478a681
> 
478a682
> 
478a683
> 
478a684
> 
536c742
< {-# LINE 775 "src/ehc/HS/Parser.chs" #-}
---
> 
536a743
> 
536a744
> 
536a745
> 
536a746
> 
536a747
> 
536a748
> 
536a749
> 
536a750
> 
536a751
> 
536a752
> 
536a753
> 
536a754
> 
536a755
> 
536a756
> 
536a757
> 
536a758
> 
536a759
> 
536a760
> 
536a761
> 
536a762
> 
536a763
> 
536a764
> 
536a765
> 
536a766
> 
536a767
> 
536a768
> 
536a769
> 
536a770
> 
536a771
> 
536a772
> 
536a773
> 
536a774
> 
552c790
< {-# LINE 796 "src/ehc/HS/Parser.chs" #-}
---
> 
552a791
> 
552a792
> 
552a793
> 
552a794
> 
552a795
> 
577c820
< {-# LINE 830 "src/ehc/HS/Parser.chs" #-}
---
> 
577a821
> 
577a822
> 
577a823
> 
577a824
> 
577a825
> 
577a826
> 
577a827
> 
577a828
> 
577a829
> 
583c835
< {-# LINE 837 "src/ehc/HS/Parser.chs" #-}
---
> 
583a836
> 
589c842
< {-# LINE 846 "src/ehc/HS/Parser.chs" #-}
---
> 
589a843
> 
589a844
> 
589a845
> 
596c852
< {-# LINE 858 "src/ehc/HS/Parser.chs" #-}
---
> 
596a853
> 
596a854
> 
596a855
> 
596a856
> 
596a857
> 
603c864
< {-# LINE 866 "src/ehc/HS/Parser.chs" #-}
---
> 
603a865
> 
609c871
< {-# LINE 879 "src/ehc/HS/Parser.chs" #-}
---
> 
609a872
> 
609a873
> 
609a874
> 
609a875
> 
609a876
> 
609a877
> 
609a878
> 
616c885
< {-# LINE 887 "src/ehc/HS/Parser.chs" #-}
---
> 
616a886
> 
623c893
< {-# LINE 901 "src/ehc/HS/Parser.chs" #-}
---
> 
623a894
> 
623a895
> 
623a896
> 
623a897
> 
623a898
> 
623a899
> 
623a900
> 
641c918
< {-# LINE 920 "src/ehc/HS/Parser.chs" #-}
---
> 
641a919
> 
651c929
< {-# LINE 943 "src/ehc/HS/Parser.chs" #-}
---
> 
651a930
> 
651a931
> 
651a932
> 
651a933
> 
651a934
> 
651a935
> 
651a936
> 
651a937
> 
651a938
> 
651a939
> 
651a940
> 
651a941
> 
651a942
> 
682c973
< {-# LINE 979 "src/ehc/HS/Parser.chs" #-}
---
> 
682a974
> 
682a975
> 
682a976
> 
682a977
> 
682a978
> 
687c983
< {-# LINE 985 "src/ehc/HS/Parser.chs" #-}
---
> 
687a984
> 
692c989
< {-# LINE 991 "src/ehc/HS/Parser.chs" #-}
---
> 
692a990
> 
701c999
< {-# LINE 1005 "src/ehc/HS/Parser.chs" #-}
---
> 
701a1000
> 
701a1001
> 
701a1002
> 
701a1003
> 
701a1004
> 
705c1008
< {-# LINE 1010 "src/ehc/HS/Parser.chs" #-}
---
> 
705a1009
> 
713c1017
< {-# LINE 1019 "src/ehc/HS/Parser.chs" #-}
---
> 
713a1018
> 
721c1026
< {-# LINE 1043 "src/ehc/HS/Parser.chs" #-}
---
> 
721a1027
> 
721a1028
> 
721a1029
> 
721a1030
> 
721a1031
> 
721a1032
> 
721a1033
> 
721a1034
> 
721a1035
> 
721a1036
> 
721a1037
> 
721a1038
> 
721a1039
> 
721a1040
> 
721a1041
> 
721a1042
> 
730c1051
< {-# LINE 1059 "src/ehc/HS/Parser.chs" #-}
---
> 
730a1052
> 
730a1053
> 
730a1054
> 
730a1055
> 
730a1056
> 
730a1057
> 
730a1058
> 
739c1067
< {-# LINE 1077 "src/ehc/HS/Parser.chs" #-}
---
> 
739a1068
> 
739a1069
> 
739a1070
> 
739a1071
> 
739a1072
> 
739a1073
> 
739a1074
> 
739a1075
> 
739a1076
> 
823c1160
< {-# LINE 1181 "src/ehc/HS/Parser.chs" #-}
---
> 
823a1161
> 
823a1162
> 
823a1163
> 
823a1164
> 
823a1165
> 
823a1166
> 
823a1167
> 
823a1168
> 
823a1169
> 
823a1170
> 
823a1171
> 
823a1172
> 
823a1173
> 
823a1174
> 
823a1175
> 
823a1176
> 
823a1177
> 
823a1178
> 
823a1179
> 
823a1180
> 
855c1212
< {-# LINE 1221 "src/ehc/HS/Parser.chs" #-}
---
> 
855a1213
> 
855a1214
> 
855a1215
> 
855a1216
> 
855a1217
> 
855a1218
> 
855a1219
> 
855a1220
> 
867c1232
< {-# LINE 1269 "src/ehc/HS/Parser.chs" #-}
---
> 
867a1233
> 
867a1234
> 
867a1235
> 
867a1236
> 
867a1237
> 
867a1238
> 
867a1239
> 
867a1240
> 
867a1241
> 
867a1242
> 
867a1243
> 
867a1244
> 
867a1245
> 
867a1246
> 
867a1247
> 
867a1248
> 
867a1249
> 
867a1250
> 
867a1251
> 
867a1252
> 
867a1253
> 
867a1254
> 
867a1255
> 
867a1256
> 
867a1257
> 
867a1258
> 
867a1259
> 
867a1260
> 
867a1261
> 
867a1262
> 
867a1263
> 
867a1264
> 
867a1265
> 
867a1266
> 
867a1267
> 
867a1268
> 
880c1281
< {-# LINE 1289 "src/ehc/HS/Parser.chs" #-}
---
> 
880a1282
> 
880a1283
> 
880a1284
> 
880a1285
> 
880a1286
> 
880a1287
> 
880a1288
> 
886c1294
< {-# LINE 1296 "src/ehc/HS/Parser.chs" #-}
---
> 
886a1295
> 
898c1307
< {-# LINE 1313 "src/ehc/HS/Parser.chs" #-}
---
> 
898a1308
> 
898a1309
> 
898a1310
> 
898a1311
> 
898a1312
> 
906c1320
< {-# LINE 1326 "src/ehc/HS/Parser.chs" #-}
---
> 
906a1321
> 
906a1322
> 
906a1323
> 
906a1324
> 
906a1325
> 
911c1330
< {-# LINE 1332 "src/ehc/HS/Parser.chs" #-}
---
> 
911a1331
> 
957c1377
< {-# LINE 1379 "src/ehc/HS/Parser.chs" #-}
---
> 
957a1378
> 
969c1390
< {-# LINE 1392 "src/ehc/HS/Parser.chs" #-}
---
> 
969a1391
> 
980c1402
< {-# LINE 1404 "src/ehc/HS/Parser.chs" #-}
---
> 
980a1403
> 
989c1412
< {-# LINE 1420 "src/ehc/HS/Parser.chs" #-}
---
> 
989a1413
> 
989a1414
> 
989a1415
> 
989a1416
> 
989a1417
> 
989a1418
> 
989a1419
> 
1006c1436
< {-# LINE 1444 "src/ehc/HS/Parser.chs" #-}
---
> 
1006a1437
> 
1006a1438
> 
1006a1439
> 
1006a1440
> 
1006a1441
> 
1006a1442
> 
1006a1443
> 
1013c1450
< {-# LINE 1456 "src/ehc/HS/Parser.chs" #-}
---
> 
1013a1451
> 
1013a1452
> 
1013a1453
> 
1013a1454
> 
1013a1455
> 
1022c1464
< {-# LINE 1470 "src/ehc/HS/Parser.chs" #-}
---
> 
1022a1465
> 
1022a1466
> 
1022a1467
> 
1022a1468
> 
1022a1469
> 
1050c1497
< {-# LINE 1508 "src/ehc/HS/Parser.chs" #-}
---
> 
1050a1498
> 
1050a1499
> 
1050a1500
> 
1050a1501
> 
1050a1502
> 
1050a1503
> 
1050a1504
> 
1050a1505
> 
1050a1506
> 
1050a1507
> 
1054c1511
< {-# LINE 1513 "src/ehc/HS/Parser.chs" #-}
---
> 
1054a1512
> 
1072c1530
< {-# LINE 1539 "src/ehc/HS/Parser.chs" #-}
---
> 
1072a1531
> 
1072a1532
> 
1072a1533
> 
1072a1534
> 
1072a1535
> 
1072a1536
> 
1072a1537
> 
1072a1538
> 
1079c1545
< {-# LINE 1547 "src/ehc/HS/Parser.chs" #-}
---
> 
1079a1546
> 
1086c1553
< {-# LINE 1557 "src/ehc/HS/Parser.chs" #-}
---
> 
1086a1554
> 
1086a1555
> 
1086a1556
> 
1093c1563
< {-# LINE 1565 "src/ehc/HS/Parser.chs" #-}
---
> 
1093a1564
> 
1102c1573
< {-# LINE 1575 "src/ehc/HS/Parser.chs" #-}
---
> 
1102a1574
> 
1114c1586
< {-# LINE 1590 "src/ehc/HS/Parser.chs" #-}
---
> 
1114a1587
> 
1114a1588
> 
1114a1589
> 
1123c1598
< {-# LINE 1604 "src/ehc/HS/Parser.chs" #-}
---
> 
1123a1599
> 
1123a1600
> 
1123a1601
> 
1123a1602
> 
1123a1603
> 
1130c1610
< {-# LINE 1614 "src/ehc/HS/Parser.chs" #-}
---
> 
1130a1611
> 
1130a1612
> 
1130a1613
> 
1136c1619
< {-# LINE 1621 "src/ehc/HS/Parser.chs" #-}
---
> 
1136a1620
> 
1141c1625
< {-# LINE 1631 "src/ehc/HS/Parser.chs" #-}
---
> 
1141a1626
> 
1141a1627
> 
1141a1628
> 
1141a1629
> 
1141a1630
> 
1148c1637
< {-# LINE 1653 "src/ehc/HS/Parser.chs" #-}
---
> 
1148a1638
> 
1148a1639
> 
1148a1640
> 
1148a1641
> 
1148a1642
> 
1148a1643
> 
1148a1644
> 
1148a1645
> 
1148a1646
> 
1148a1647
> 
1148a1648
> 
1148a1649
> 
1148a1650
> 
1148a1651
> 
1148a1652
> 
1156c1660
< {-# LINE 1666 "src/ehc/HS/Parser.chs" #-}
---
> 
1156a1661
> 
1156a1662
> 
1156a1663
> 
1156a1664
> 
1156a1665
> 
1160c1669
< {-# LINE 1673 "src/ehc/HS/Parser.chs" #-}
---
> 
1160a1670
> 
1160a1671
> 
1160a1672
> 
1164c1676
< {-# LINE 1678 "src/ehc/HS/Parser.chs" #-}
---
> 
1164a1677
> 
1171c1684
< {-# LINE 1688 "src/ehc/HS/Parser.chs" #-}
---
> 
1171a1685
> 
1171a1686
> 
1171a1687
> 
1183c1699
< {-# LINE 1701 "src/ehc/HS/Parser.chs" #-}
---
> 
1183a1700
> 
1215c1732
< {-# LINE 1740 "src/ehc/HS/Parser.chs" #-}
---
> 
1215a1733
> 
1215a1734
> 
1215a1735
> 
1215a1736
> 
1215a1737
> 
1215a1738
> 
1215a1739
> 
1236c1760
< {-# LINE 1767 "src/ehc/HS/Parser.chs" #-}
---
> 
1236a1761
> 
1236a1762
> 
1236a1763
> 
1236a1764
> 
1236a1765
> 
1236a1766
> 
1243c1773
< {-# LINE 1777 "src/ehc/HS/Parser.chs" #-}
---
> 
1243a1774
> 
1243a1775
> 
1243a1776
> 
1262c1795
< {-# LINE 1801 "src/ehc/HS/Parser.chs" #-}
---
> 
1262a1796
> 
1262a1797
> 
1262a1798
> 
1262a1799
> 
1262a1800
> 
1269c1807
< {-# LINE 1809 "src/ehc/HS/Parser.chs" #-}
---
> 
1269a1808
> 
1276c1815
< {-# LINE 1817 "src/ehc/HS/Parser.chs" #-}
---
> 
1276a1816
> 
1293c1833
< {-# LINE 1854 "src/ehc/HS/Parser.chs" #-}
---
> 
1293a1834
> 
1293a1835
> 
1293a1836
> 
1293a1837
> 
1293a1838
> 
1293a1839
> 
1293a1840
> 
1293a1841
> 
1293a1842
> 
1293a1843
> 
1293a1844
> 
1293a1845
> 
1293a1846
> 
1293a1847
> 
1293a1848
> 
1293a1849
> 
1293a1850
> 
1293a1851
> 
1293a1852
> 
1293a1853
> 
1299c1859
< {-# LINE 1865 "src/ehc/HS/Parser.chs" #-}
---
> 
1299a1860
> 
1299a1861
> 
1299a1862
> 
1299a1863
> 
1299a1864
> 
1308c1873
< {-# LINE 1877 "src/ehc/HS/Parser.chs" #-}
---
> 
1308a1874
> 
1308a1875
> 
1308a1876
> 
1315c1883
< {-# LINE 1885 "src/ehc/HS/Parser.chs" #-}
---
> 
1315a1884
> 
1330c1899
< {-# LINE 1905 "src/ehc/HS/Parser.chs" #-}
---
> 
1330a1900
> 
1330a1901
> 
1330a1902
> 
1330a1903
> 
1330a1904
> 
1337c1911
< {-# LINE 1913 "src/ehc/HS/Parser.chs" #-}
---
> 
1337a1912
> 
1347c1922
< {-# LINE 1929 "src/ehc/HS/Parser.chs" #-}
---
> 
1347a1923
> 
1347a1924
> 
1347a1925
> 
1347a1926
> 
1347a1927
> 
1347a1928
> 
1356c1937
< {-# LINE 1941 "src/ehc/HS/Parser.chs" #-}
---
> 
1356a1938
> 
1356a1939
> 
1356a1940
> 
1364c1948
< {-# LINE 1952 "src/ehc/HS/Parser.chs" #-}
---
> 
1364a1949
> 
1364a1950
> 
1364a1951
> 
1379c1966
< {-# LINE 1968 "src/ehc/HS/Parser.chs" #-}
---
> 
1379a1967
> 
1393c1981
< {-# LINE 1983 "src/ehc/HS/Parser.chs" #-}
---
> 
1393a1982
> 
1401c1990
< {-# LINE 1992 "src/ehc/HS/Parser.chs" #-}
---
> 
1401a1991
> 
1408c1998
< {-# LINE 2000 "src/ehc/HS/Parser.chs" #-}
---
> 
1408a1999
> 
1416c2007
< {-# LINE 2011 "src/ehc/HS/Parser.chs" #-}
---
> 
1416a2008
> 
1416a2009
> 
1416a2010
> 
1424c2018
< {-# LINE 2022 "src/ehc/HS/Parser.chs" #-}
---
> 
1424a2019
> 
1424a2020
> 
1424a2021
> 
1431c2028
< {-# LINE 2030 "src/ehc/HS/Parser.chs" #-}
---
> 
1431a2029
> 
1446c2044
< {-# LINE 2046 "src/ehc/HS/Parser.chs" #-}
---
> 
1446a2045
> 
1454c2053
< {-# LINE 2055 "src/ehc/HS/Parser.chs" #-}
---
> 
1454a2054
> 
1469c2069
< {-# LINE 2071 "src/ehc/HS/Parser.chs" #-}
---
> 
1469a2070
> 
1477c2078
< {-# LINE 2080 "src/ehc/HS/Parser.chs" #-}
---
> 
1477a2079
> 
1485c2087
< {-# LINE 2089 "src/ehc/HS/Parser.chs" #-}
---
> 
1485a2088
> 
1493c2096
< {-# LINE 2098 "src/ehc/HS/Parser.chs" #-}
---
> 
1493a2097
> 
1501c2105
< {-# LINE 2107 "src/ehc/HS/Parser.chs" #-}
---
> 
1501a2106
> 
1509c2114
< {-# LINE 2124 "src/ehc/HS/Parser.chs" #-}
---
> 
1509a2115
> 
1509a2116
> 
1509a2117
> 
1509a2118
> 
1509a2119
> 
1509a2120
> 
1509a2121
> 
1509a2122
> 
1509a2123
> 
1516c2130
< {-# LINE 2132 "src/ehc/HS/Parser.chs" #-}
---
> 
1516a2131
> 
1524c2139
< {-# LINE 2143 "src/ehc/HS/Parser.chs" #-}
---
> 
1524a2140
> 
1524a2141
> 
1524a2142
> 
1531c2149
< {-# LINE 2154 "src/ehc/HS/Parser.chs" #-}
---
> 
1531a2150
> 
1531a2151
> 
1531a2152
> 
1531a2153
> 
1539c2161
< {-# LINE 2165 "src/ehc/HS/Parser.chs" #-}
---
> 
1539a2162
> 
1539a2163
> 
1539a2164
> 
1547c2172
< {-# LINE 2174 "src/ehc/HS/Parser.chs" #-}
---
> 
1547a2173
> 
1555c2181
< {-# LINE 2183 "src/ehc/HS/Parser.chs" #-}
---
> 
1555a2182
> 
1563c2190
< {-# LINE 2192 "src/ehc/HS/Parser.chs" #-}
---
> 
1563a2191
> 
1571c2199
< {-# LINE 2201 "src/ehc/HS/Parser.chs" #-}
---
> 
1571a2200
> 
1593c2222
< {-# LINE 2226 "src/ehc/HS/Parser.chs" #-}
---
> 
1593a2223
> 
1593a2224
> 
1593a2225
> 
1600c2232
< {-# LINE 2234 "src/ehc/HS/Parser.chs" #-}
---
> 
1600a2233
> 
1607c2240
< {-# LINE 2242 "src/ehc/HS/Parser.chs" #-}
---
> 
1607a2241
> 
1614c2248
< {-# LINE 2250 "src/ehc/HS/Parser.chs" #-}
---
> 
1614a2249
> 
1622c2257
< {-# LINE 2261 "src/ehc/HS/Parser.chs" #-}
---
> 
1622a2258
> 
1622a2259
> 
1622a2260
> 
1628a2267
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.HS.Parser
( HSParser, HSParser'
, pAGItf
, pAGItfImport )
where
import UU.Parsing
import UU.Parsing.Offside
import UHC.Util.ParseUtils
import UU.Scanner.GenToken
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.HS
import System.IO
import UHC.Util.Utils
import UHC.Util.Pretty
import Data.Maybe
import UHC.Light.Compiler.Base.Target
import qualified UHC.Util.FastSeq as Seq





{-# LINE 41 "src/ehc/HS/Parser.chs" #-}
pPacked' :: HSParser Token -> HSParser Token -> HSParser (Range -> v) -> HSParser v
pPacked' pO pC pMk = (\o mk c -> mk (mkRange2 o c)) <$> pO <*> pMk <*> pC

pParens' :: HSParser (Range -> v) -> HSParser v
pParens' = pPacked' pOPAREN pCPAREN

pBracks' :: HSParser (Range -> v) -> HSParser v
pBracks' = pPacked' pOBRACK pCBRACK

pCurlys' :: HSParser (Range -> v) -> HSParser v
pCurlys' = pPacked' pOCURLY pCCURLY

{-# LINE 55 "src/ehc/HS/Parser.chs" #-}
pImpls' :: HSParser (Range -> v) -> HSParser v
pImpls' = pPacked' pOIMPL pCIMPL

pImpls :: IsParser p Token => p v -> p v
pImpls = pPacked pOIMPL pCIMPL

{-# LINE 63 "src/ehc/HS/Parser.chs" #-}
pApp            ::   AppLike a boundmeta => HSParser a -> HSParser a
pApp p          =    appTopApp <$> pList1 p

{-# LINE 72 "src/ehc/HS/Parser.chs" #-}
type HSParser         ep    =    LayoutParser Token ep
type HSParser2        ep    =    LayoutParser2 Token ep
type HSParser'        ep    =    PlainParser Token ep

{-# LINE 78 "src/ehc/HS/Parser.chs" #-}
pAGItf :: EHCOpts -> HSParser AGItf
pAGItf opts
  =   AGItf_AGItf <$> pModule opts pBody'

{-# LINE 88 "src/ehc/HS/Parser.chs" #-}
pAGItfImport :: EHCOpts -> HSParser AGItf
pAGItfImport opts
  =   AGItf_AGItf <$> pModule opts (\opts _ -> pBodyImport opts)

{-# LINE 102 "src/ehc/HS/Parser.chs" #-}
data Expression4Result
  = Expression4Result_Op                (Expression,Range)
  | Expression4Result_CommaList         [Expression]
  | Expression4Result_Typed
  | Expression4Result_NotOpPre
  -- deriving Eq

type Expression4 = (Expression,Int,[Expression4Result])


{-# LINE 118 "src/ehc/HS/Parser.chs" #-}
pPragma' :: (Range -> Pragma -> x) -> HSParser x
pPragma' mk
  = pPacked' pOPRAGMA pCPRAGMA
      (   (\t ps r -> mk r $ Pragma_Language   (mkRange1 t) ps)
          <$> pLANGUAGE_prag   <*> pCommas (tokMkQName <$>           conid)
      <|> (\t cl fld val r -> mk r $ Pragma_Derivable (mkRange1 t) (tokMkQName cl) (tokMkQName fld) (tokMkQName val))
          <$> pDERIVABLE_prag  <*> gtycon' tyconsym <*> var <*> qvar
      <|> (\t targ r -> mk r $ Pragma_ExcludeIfTarget (mkRange1 t) (map tokMkStr $ concat targ))
          <$> pEXCLUDEIFTARGET_prag  <*> pList1Sep pCOMMA (pList1 (conid <|> varid))
      <|> (\t targ r -> mk r $ Pragma_OptionsUHC (mkRange1 t) (tokMkStr targ))
          <$> pOPTIONSUHC_prag  <*> pStringTk
      )

pPragma :: HSParser Pragma
pPragma = pPragma' (flip const)

pDeclarationPragma :: HSParser Declaration
pDeclarationPragma
  = pPragma' Declaration_Pragma


{-# LINE 145 "src/ehc/HS/Parser.chs" #-}
pModule :: EHCOpts -> (EHCOpts -> (HSParser2 Declaration) -> HSParser Body) -> HSParser Module
pModule opts pBody
  = pList_gr pPragma
    <**> (   (\      b p -> Module_Module emptyRange   Nothing                 p Nothing b) <$> pBody opts id
         <|> (\t m e b p -> Module_Module (mkRange1 t) (Just $ tokMkQName $ m) p e       b) <$> pMODULE <*> modid <*> pMaybeExports <* pWHERE <*> pBody opts (\d -> d <|> pDeclarationPragma)
         )
  <?> "pModule"

{-# LINE 171 "src/ehc/HS/Parser.chs" #-}
pImportExport :: (Range -> Name -> ie,Range -> Name -> MaybeNames -> ie,Range -> Name -> ie) -> HSParser ie
pImportExport (sem_Var,sem_tOrC,sem_tOrC_complete)
  =   mkRngNm sem_Var <$> qvar
  <|> qtycon
      <**> (   pParens
                 (   (\c n -> mkRngNm sem_tOrC n (Just (tokMkQNames c))) <$> qcnames
                 <|> mkRngNm sem_tOrC_complete <$ pDOTDOT
                 )
           <|> pSucceed (\n -> mkRngNm sem_tOrC n Nothing)
           )
  <?> "pImportExport"

{-# LINE 185 "src/ehc/HS/Parser.chs" #-}
pExport :: HSParser Export
pExport
  =   (\t m -> Export_Module (mkRange1 t) (tokMkQName m)) <$> pMODULE <*> modid
  <|> pImportExport (Export_Variable,Export_TypeOrClass,Export_TypeOrClassComplete)
  <?> "pExport"

pMaybeExports :: HSParser MaybeExports
pMaybeExports
  =   Just <$> pParens (pListSep_ng pCOMMA pExport <* pMb pCOMMA)
  <|> pSucceed Nothing
  <?> "pMaybeExports"

{-# LINE 199 "src/ehc/HS/Parser.chs" #-}
pImport :: HSParser Import
pImport
  =   pImportExport (Import_Variable,Import_TypeOrClass,Import_TypeOrClassComplete)
  <?> "pImport"

pImportDeclaration :: HSParser ImportDeclaration
pImportDeclaration
  = (\q m a i -> ImportDeclaration_Import (mkRange1 m) q (tokMkQName m) (fmap tokMkQName a) i)
    <$  pIMPORT <*> (True <$ pQUALIFIED <|> pSucceed False)
    <*> modid
    <*> (Just <$ pAS <*> modid <|> pSucceed Nothing)
    <*> (Just <$> pImportSpecification <|> pSucceed Nothing)
  <?> "pImportDeclaration"
  where pImportSpecification :: HSParser ImportSpecification
        pImportSpecification
          = (True <$ pHIDING <|> pSucceed False)
            <**> pParens'
                   ((\i r h -> ImportSpecification_Import r h i) <$> pListSep_ng pCOMMA pImport <* pMb pCOMMA)

{-# LINE 224 "src/ehc/HS/Parser.chs" #-}
pLayoutList :: HSParser d -> HSParser [d]
pLayoutList pD
  =   pBlock pOCURLY pSEMI pCCURLY pD

pLayoutList1 :: HSParser d -> HSParser [d]
pLayoutList1 pD
  =   pBlock1 pOCURLY pSEMI pCCURLY pD


{-# LINE 239 "src/ehc/HS/Parser.chs" #-}
pBodyImport :: EHCOpts -> HSParser Body
pBodyImport opts
  =   (\d -> Body_Body emptyRange d []) <$> pLayoutList pImportDeclaration
  <?> "pBodyImport"

{-# LINE 246 "src/ehc/HS/Parser.chs" #-}
pBody :: EHCOpts -> HSParser Body
pBody opts = pBody' opts id

{-# LINE 251 "src/ehc/HS/Parser.chs" #-}
pBody' :: EHCOpts -> (HSParser2 Declaration) -> HSParser Body
pBody' opts addDecl
  =   (\ids -> let (i,d) = foldr cmbid ([],[]) ids in Body_Body emptyRange i d)
      <$> pLayoutList (   (\d -> ([],[d])) <$> (addDecl pTopDeclaration)
                      <|> (\i -> ([i],[])) <$> pImportDeclaration
                      )
  <?> "pBody"
  where
        cmbid ([i],_) (is,ds) = (i:is,ds)
        cmbid (_,[d]) (_ ,ds) = ([],d:ds)

{-# LINE 275 "src/ehc/HS/Parser.chs" #-}
        pDeclaration :: HSParser Declaration
        pDeclaration
          =   pDeclarationValue
          <|> pDeclarationTypeSignature
          <|> pDeclarationData
          <|> pDeclarationKindSignature
          <|> pDeclarationInstance
          <|> pDeclarationType
          <|> pDeclarationFusion
          <|> pDeclarationConversion
          <?> "pDeclaration"

{-# LINE 299 "src/ehc/HS/Parser.chs" #-}
        pTopDeclaration :: HSParser Declaration
        pTopDeclaration
          =   pDeclaration
          <|> pDeclarationFixity
          <|> pDeclarationForeign
          <|> pDeclarationClass
          <|> pDeclarationDefault
          <?> "pTopDeclaration"

{-# LINE 314 "src/ehc/HS/Parser.chs" #-}
        pDeclarations :: HSParser Declarations
        pDeclarations
          =   pLayoutList pDeclaration

        pDeclarations1 :: HSParser Declarations
        pDeclarations1
          =   pLayoutList1 pDeclaration

{-# LINE 324 "src/ehc/HS/Parser.chs" #-}
        pWhere'' :: HSParser d -> HSParser [d]
        pWhere'' pD = pWHERE *> pLayoutList pD

        pWhere' :: HSParser d -> HSParser (Maybe [d])
        pWhere' pD = pMb (pWhere'' pD)

        pWhere :: HSParser MaybeDeclarations
        pWhere = pWhere' pDeclaration

{-# LINE 339 "src/ehc/HS/Parser.chs" #-}
        pDeclarationFixity :: HSParser Declaration
        pDeclarationFixity
          = (\f p os@(o:_) -> Declaration_Fixity (mkRange1 o) f p (tokMkQNames os))
            <$> pFixity
            <*> ((Just . tokMkInt) <$> pInteger10Tk <|> pSucceed Nothing)
            <*> pList1Sep pCOMMA op

        pFixity :: HSParser' Fixity
        pFixity = Fixity_Infixl <$ pINFIXL <|> Fixity_Infixr <$ pINFIXR <|> Fixity_Infix <$ pINFIX

{-# LINE 355 "src/ehc/HS/Parser.chs" #-}
        pDeclarationTypeSignature :: HSParser Declaration
        pDeclarationTypeSignature
          =   (\(v:vs) t -> Declaration_TypeSignature (mkRange1 v) (tokMkQNames (v:vs)) t)
              <$> pList1Sep pCOMMA var <* pDCOLON <*> pType
          <?> "pDeclarationTypeSignature"

        pDeclarationValue :: HSParser Declaration
        pDeclarationValue
          =   mkF <$> pLhs <*> rhs
          <|> pPatternOp
              <**> (   (flip mkP) <$> rhs
                   <|> (\o r rhs l -> mkF (mkLI l o r) rhs)
                       <$> pVarOp <*> pPatternOp <*> rhs
                   )
          <?> "pDeclarationValue"
          where pVarOp :: HSParser Token
                pVarOp = if ehcOptBangPatterns opts then varop_no_bang else varop
                pLhsTail ::  HSParser [Pattern]
                pLhsTail =   pList1 pPatternBaseCon
                pLhs     ::  HSParser (Range,LeftHandSide)
                pLhs     =   (\v lhs -> let r = mkRange1 v in (r, LeftHandSide_Function r (tokMkQName v) lhs)) <$> var <*> pLhsTail
                         <|> pParens'
                               (   (\l r t -> (r, mkLP r l t))
                                   <$> pLhs
                               <|> (\pl o pr r t -> (r, mkLP r (mkLI pl o pr) t))
                                   <$> pPatternOp <*> varop <*> pPatternOp
                               )
                             <*> pLhsTail
                mkP  p     rhs = Declaration_PatternBinding emptyRange (p2p p) rhs'
                               where (p2p,rhs') = mkTyPat rhs
                mkF (r,lhs) rhs= Declaration_FunctionBindings r [FunctionBinding_FunctionBinding r (l2l lhs) rhs']
                               where (l2l,rhs') = mkTyLhs rhs
                mkLI l o rh    = (r, LeftHandSide_Infix r l (tokMkQName o) rh)
                               where r = mkRange1 o
                mkLP r (_,l) t = LeftHandSide_Parenthesized r l t
                rhs      =   pMbTy <+> pRhs pEQUAL
                pMbTy    ::  HSParser (Maybe (Token,Type))
                pMbTy    =   pMb (pDCOLON <+> pType)
                mkTyLhs (Just (tok,ty),rhs) = (\l -> LeftHandSide_Typed (mkRange1 tok) l ty,rhs)
                mkTyLhs (_            ,rhs) = (id                                          ,rhs)
                mkTyPat (Just (tok,ty),rhs) = (\p -> Pattern_Typed      (mkRange1 tok) p ty,rhs)
                mkTyPat (_            ,rhs) = (id                                          ,rhs)

{-# LINE 410 "src/ehc/HS/Parser.chs" #-}
        pDeclarationSimpleValue :: HSParser Declaration
        pDeclarationSimpleValue
          =   Declaration_PatternBinding emptyRange <$> lhs <*> rhs
          <?> "pDeclarationSimpleValue"
          where lhs = mkRngNm Pattern_Variable <$> var
                rhs = (\t e -> RightHandSide_Expression (mkRange1 t) e Nothing) <$> pEQUAL <*> pExpression

{-# LINE 419 "src/ehc/HS/Parser.chs" #-}
        pRhs :: HSParser Token -> HSParser RightHandSide
        pRhs pSep
          =   (RightHandSide_Expression . mkRange1) <$> pSep <*> pExpression <*> pWhere
          <|> RightHandSide_Guarded emptyRange
              <$> pList1 ((GuardedExpression_GuardedExpression . mkRange1) <$> pVBAR <*> pExpression <* pSep <*> pExpression)
              <*> pWhere
          <?> "pRhs"

{-# LINE 431 "src/ehc/HS/Parser.chs" #-}
        pDeclarationKindSignature :: HSParser Declaration
        pDeclarationKindSignature
          =   (\(v:vs) t -> Declaration_KindSignature (mkRange1 v) (tokMkQNames (v:vs)) t)
              <$> pList1Sep pCOMMA con <* pDCOLON <*> pKind
          <?> "pDeclarationKindSignature"

{-# LINE 443 "src/ehc/HS/Parser.chs" #-}
        pDeclarationData :: HSParser Declaration
        pDeclarationData
          =   pDATA
              <**> (pCtxt
              <**>  (pTypeLeftHandSide
              <**>   (   (\cs der lhs cx k -> mk Declaration_Data k cx lhs cs der)
                         <$> (pEQUAL *> pListSep pVBAR pDCon) <*> pDer
                     <|> (\cs der lhs cx k -> mk Declaration_Data k cx lhs cs der)
                         <$> pWhere'' (pGADTConstructor) <*> pDer
                     <|> pSucceed (\lhs cx k -> mk Declaration_Data k cx lhs [] [])
                   )))
          <|> pNEWTYPE
              <**> (   (\cx lhs c der k -> mk Declaration_Newtype k cx lhs c der)
                       <$> pCtxt <*> pTypeLeftHandSide <* pEQUAL <*> pNCon <*> pDer
                   )
          <?> "pDeclarationData"
          where mk sem =
                      \k cx lhs cs der
                         -> sem (mkRange1 k) cx lhs cs der
                -- TBD, for now: parse, but ignore quantifiers
                pDCon, pNCon :: HSParser Constructor
                pDCon = pList pTypeQuantPrefix *> pContextedConstructor
                pNCon = pList pTypeQuantPrefix *> pConstructor
                pCtxt :: HSParser ContextItems
                pCtxt = pContextItemsPrefixOpt
                pDer :: HSParser [Deriving]
                pDer = pDERIVING *> ((:[]) <$> pDeriving <|> pParens (pListSep pCOMMA pDeriving)) <|> pSucceed []

{-# LINE 495 "src/ehc/HS/Parser.chs" #-}
        pDeriving :: HSParser Deriving
        pDeriving
          = (\(n,u) t -> Deriving_Deriving (mkRange1 t) n u (tokMkQName t)) <$> pInstanceName <*> qconid

{-# LINE 501 "src/ehc/HS/Parser.chs" #-}
        pConstructor :: HSParser Constructor
        pConstructor
          =   con
              <**> (   (\ts c -> mkRngNm Constructor_Constructor c ts) <$> pList pTB
{-# LINE 507 "src/ehc/HS/Parser.chs" #-}
                   <|> pCurlys' ((\fs r c -> mkRngNm Constructor_Record c fs) <$> pListSep pCOMMA pFieldDeclaration)
{-# LINE 510 "src/ehc/HS/Parser.chs" #-}
                   )
          <|> (\l o r -> Constructor_Infix (mkRange1 o) l (tokMkQName o) r) <$> pT <*> conop <*> pT
          where pT  = pAnnotatedType pType
                pTB = pAnnotatedType pTypeBase

{-# LINE 517 "src/ehc/HS/Parser.chs" #-}
        pContextedConstructor :: HSParser Constructor
        pContextedConstructor
          =   Constructor_Contexted emptyRange <$> pContextItemsPrefix <*> pConstructor
          <|> pConstructor

{-# LINE 524 "src/ehc/HS/Parser.chs" #-}
        pGADTConstructor :: HSParser Constructor
        pGADTConstructor
          =   mkRngNm Constructor_GADTFunction <$> con <* pDCOLON <*> pType

{-# LINE 530 "src/ehc/HS/Parser.chs" #-}
        pFieldDeclaration :: HSParser FieldDeclaration
        pFieldDeclaration
          = (\vs@(v:_) -> FieldDeclaration_FieldDeclaration (mkRange1 v) (tokMkQNames vs))
            <$> pList1Sep pCOMMA var <* pDCOLON <*> pAnnotatedType pType

{-# LINE 541 "src/ehc/HS/Parser.chs" #-}
        pDeclarationForeign :: HSParser Declaration
        pDeclarationForeign
          = pFOREIGN
            <**> (   (\c s (i,n,t) r -> Declaration_ForeignImport (mkRange1 r) (fst c) s i (tokMkQName n) t)
                     <$ pIMPORT <*> pFFIWay <*> pSafety <*> pFSpec
                 <|> (\c (i,n,t) r -> Declaration_ForeignExport (mkRange1 r) (fst c) i (tokMkQName n) t)
                     <$ pEXPORT <*> pFFIWay <*> pFSpec
                 )
          where pSafety =  (Just . tokMkStr) <$> safety <|> pSucceed Nothing
                pFSpec = (,,) <$> ((Just . tokMkStr) <$> pStringTk <|> pSucceed Nothing) <*> var{-id_no_foreign-} <* pDCOLON <*> pType

{-# LINE 560 "src/ehc/HS/Parser.chs" #-}
        pDeclarationClass :: HSParser Declaration
        pDeclarationClass
          = (\t -> Declaration_Class (mkRange1 t))
            <$> pCLASS
            <*> pContextItemsPrefixOpt <*> pTypeLeftHandSide
            <*> (pVBAR *> pListSep pCOMMA pFunctionalDependency
                `opt` []
                )
            <*> pWhere' (pDeclarationValue <|> pDeclarationTypeSignature)
          where pFunctionalDependency :: HSParser FunctionalDependency
                pFunctionalDependency
                  = (\vs1@(v:_) vs2 -> FunctionalDependency_Dependency (mkRange1 v) (tokMkQNames vs1) (tokMkQNames vs2))
                    <$> pList1 tyvar <* pRARROW <*> pList1 tyvar

{-# LINE 580 "src/ehc/HS/Parser.chs" #-}
        pInstanceName :: HSParser (Maybe HsName,Bool)
        pInstanceName
          =   (\n e -> (Just (tokMkQName n),e)) <$> varid <*> (True <$ pLTCOLON <|> False <$ pDCOLON)
          <|> pSucceed (Nothing,True)

{-# LINE 587 "src/ehc/HS/Parser.chs" #-}
        pDeclarationInstance :: HSParser Declaration
        pDeclarationInstance
          =   pINSTANCE
              <**> (   -- (\((n,u),c,cl,ts) d t -> Declaration_Instance (mkRange1 t) InstNormal n u c (tokMkQName cl) ts d)
                       (\((n,u),c,h) d t -> Declaration_Instance (mkRange1 t) InstNormal n u c h d)
                       <$> pHeader
                       <*> pWhere' pDeclarationValue
                   <|> (\e cl ts t -> Declaration_InstanceUseImplicitly (mkRange1 t) e (tokMkQName cl) ts)
                       <$> pExpression <* pLTCOLON <*> qconid <*> pList1 pTypeBase
                   )
          <|> -- (\t ((n,u),c,cl,ts) -> Declaration_Instance (mkRange1 t) (InstDeriving InstDerivingFrom_Standalone) n u c (tokMkQName cl) ts Nothing)
              (\t ((n,u),c,h) -> Declaration_Instance (mkRange1 t) (InstDeriving InstDerivingFrom_Standalone) n u c h Nothing)
              <$> pDERIVING <* pINSTANCE <*> pHeader
          -- where pHeader = (,,,) <$> pInstanceName <*> pContextItemsPrefixOpt <*> qconid <*> pList1 pTypeBase
          where pHeader = (,,) <$> pInstanceName <*> pContextItemsPrefixOpt <*> pType' pTypeOpBase (\_ p -> p)

{-# LINE 607 "src/ehc/HS/Parser.chs" #-}
        pDeclarationDefault :: HSParser Declaration
        pDeclarationDefault
          = (Declaration_Default . mkRange1) <$> pDEFAULT <*> pMb (tokMkQName <$> qtyconid)
            <*> (   (:[]) <$> pTypeBase
                <|> pParens (pListSep pCOMMA pTypeBase)
                )

{-# LINE 620 "src/ehc/HS/Parser.chs" #-}
        pDeclarationType :: HSParser Declaration
        pDeclarationType
          =   (Declaration_Type . mkRange1) <$> pTYPE <*> pTypeLeftHandSide <* pEQUAL <*> pType

{-# LINE 631 "src/ehc/HS/Parser.chs" #-}

        pDeclarationFusion :: HSParser Declaration
        pDeclarationFusion
          = (Declaration_FusionDeclaration . mkRange1) <$> pFUSE <*> (tokMkQName <$> qvar) -- <* pWITH <*> (tokMkQName <$> qvar)

        pDeclarationConversion :: HSParser Declaration
        pDeclarationConversion
          = (Declaration_FusionConversion . mkRange1) <$> pCONVERT <*> (tokMkQName <$> qvar) <* pCOMMA <*> (tokMkQName <$> qvar)

{-# LINE 647 "src/ehc/HS/Parser.chs" #-}
        pKindBase :: HSParser Kind
        pKindBase
          =   mkRngNm Kind_Constructor <$> pSTAR
          <|> mkRngNm Kind_Variable <$> tyvar
          <|> pParens' pInParens
          <?> "pKindBase"
          where pInParens :: HSParser (Range -> Kind)
                pInParens
                  =   (pKind
                       <**> (   pSucceed (flip Kind_Parenthesized)
                      )     )

        pKind :: HSParser Kind
        pKind
          =   mkK <$> pK
          <?> "pKind"
          where pK ::  HSParser (Kind,Int)
                pK =   pKindBase
                       <**> (   pSucceed (\k -> (k,1))
                            <|> (\(op,rng) (r,opCnt) l -> (Kind_InfixApplication rng l op r,opCnt+1)) <$> pKindOp <*> pK
                            )
                   <|> (\p e -> (p $ mkK $ e,1)) <$> pKindPrefix <*> pK
                mkK (e,1) = e
                mkK (e,_) = {- Expression_InfixApplicationChainTop emptyRange -} e
                pKindOp :: HSParser (Kind,Range)
                pKindOp = mkRngNm' Kind_Constructor <$> pRARROW

        pKindPrefix :: HSParser (Kind -> Kind)
        pKindPrefix
          =  ((Kind_Forall . mkRange1) <$> pFORALL)
             <*> (tokMkQNames <$> pTyVarBinds) <* pDOT

{-# LINE 685 "src/ehc/HS/Parser.chs" #-}
        pTypeBaseCon :: HSParser Type
        pTypeBaseCon
          =   mkRngNm Type_Constructor <$> gtycon_no_delims_commas

        pTypeBase :: HSParser Type
        pTypeBase
          =   pTypeBaseCon
          <|> (Type_Wildcard . mkRange1) <$> pTDOT
          <|> (Type_MonoWildcard . mkRange1) <$> pQDOT
          <|> mkRngNm Type_Variable <$> var_no_ty
          <|> mkRngNm Type_NamedWildcard <$ pPERCENT <*> tyvar
          <|> pBracks'
                (   (\t r -> Type_NormalApplication r (Type_Constructor r hsnDataList) [t])
                    <$> pType
                <|> pSucceed (\r -> Type_Constructor r hsnDataList)
                )
          <|> pParens' pInParens
          <|> pPacked' pOROWROW pCROWROW
                (    pExtFlds Type_RowEmpty Type_RowUpdate
                <|> (\fs r -> Type_RowUpdate r (Type_RowEmpty r) fs) <$> pFlds
                )
          <|> pPacked' pOROWSUM pCROWSUM
                (    pExtFlds Type_RowSumEmpty Type_RowSumUpdate
                <|> (\fs r -> Type_RowSumUpdate r (Type_RowSumEmpty r) fs) <$> pFlds
                )
          where pInParens :: HSParser (Range -> Type)
                pInParens
                  =   (pType
                       <**> (   pSucceed (flip Type_Parenthesized)
                            <|> (\es e r -> Type_RowRecUpdate r (Type_RowRecEmpty r)
                                              (map (RowTypeUpdate_Extends r Nothing) (e:es)))
                                <$>  pList1 (pComma *> pType)
                            <|> (\(o,_) e r -> Type_SectionApplication r (Just e) o Nothing)
                                <$> pTypeOpBaseEq
                      )     )
                  <|> (pTypeOpBaseEq
                       <**> (   (\e (o,_) r -> Type_SectionApplication r Nothing o (Just e)) <$> pType
                            -- <|> pSucceed (\(o,_) r -> Type_SectionApplication r Nothing o Nothing)
                      )     )
                  <|> flip Type_TupleConstructor <$> commas_arity
                  <|> pSucceed (\r -> Type_RowRecEmpty r)
                  <|> (\fs r -> Type_RowRecUpdate r (Type_RowRecEmpty r) fs) <$> pFlds
                  <|> pExtFlds Type_RowRecEmpty Type_RowRecUpdate
                pFld :: HSParser (Type -> RowTypeUpdate)
                pFld = qvarid
                       <**> (   (\l -> RowTypeUpdate_Extends (mkRange1 l) (Just (tokMkQName l))) <$ pDCOLON
                            )
                pFlds :: HSParser [RowTypeUpdate]
                pFlds = pList1Sep pComma (pFld <*> pType)
                pExtFlds :: (Range -> Type) -> (Range -> Type -> [RowTypeUpdate] -> Type) -> HSParser (Range -> Type)
                pExtFlds semEmp semFromRow
                     = (\e fs r -> semFromRow r e fs)
                       <$> (   mkRngNm Type_Variable <$> qvarid
                           <|> pSucceed (semEmp emptyRange)
                           )
                       <*  pVBAR <*> pFlds

{-# LINE 775 "src/ehc/HS/Parser.chs" #-}
        pType' :: HSParser (Type,Range) -> (HSParser Type -> HSParser (Type,Int) -> HSParser (Type,Int)) -> HSParser Type
        pType' pOp extend
          = pT'
          where pT' :: HSParser Type
                pT' = mkT <$> pT
                pT :: HSParser (Type,Int)
                pT = extend pT'
                     $ pTypeApp
                        <**> (   pSucceed unit
                             <|> (\(op,rng) (r,cnt) l -> (Type_InfixApplication rng l op r,cnt+1)) <$> pOp <*> pT
                             )
                unit e    = (e,0)
                mkT (e,0) =  e
                mkT (e,_) =  Type_InfixApplicationChainTop emptyRange e

{-# LINE 796 "src/ehc/HS/Parser.chs" #-}
        pType ::  HSParser Type
        pType
          = pType'
              pTypeOp
              (\pT pTApp ->
                         pTApp
                     <|> (\c t -> unit $ Type_Qualified emptyRange [c] t) <$> pContextItemImpl <* pRARROW <*> pT
                     <|> unit <$> (pTypeQuantPrefix <*> pT)
              )
          where unit e    = (e,0)
{-
          = mkT <$> pT
          where pT :: HSParser (Type,Int)
                pT = pTypeApp
                      <**> (   pSucceed unit
                           <|> (\(op,rng) (r,cnt) l -> (Type_InfixApplication rng l op r,cnt+1)) <$> pTypeOp <*> pT
                           )
                     <|> (\c t -> unit $ Type_Qualified emptyRange [c] t) <$> pContextItemImpl <* pRARROW <*> pType
                     <|> unit <$> (pTypeQuantPrefix <*> pType)
                unit e    = (e,0)
                mkT (e,0) =  e
                mkT (e,_) =  Type_InfixApplicationChainTop emptyRange e
-}

{-# LINE 830 "src/ehc/HS/Parser.chs" #-}
        pTypeQuantPrefix :: HSParser (Type -> Type)
        pTypeQuantPrefix
          =  ((Type_Forall . mkRange1) <$> pFORALL <|> (Type_Exists . mkRange1) <$> pEXISTS)
             <*> (tokMkQNames <$> pTyVarBinds) <* pDOT

{-# LINE 837 "src/ehc/HS/Parser.chs" #-}
        pTypeOpPrefix :: HSParser (Type -> Type)
        pTypeOpPrefix
          =   (\l (op,rng) r -> Type_InfixApplication rng l op r) <$> pTypeApp <*> pTypeOp
          <|> (\c -> Type_Qualified emptyRange [c]) <$> pContextItemImpl <* pRARROW

{-# LINE 846 "src/ehc/HS/Parser.chs" #-}
        pTypeOp :: HSParser (Type,Range)
        pTypeOp
          =   pTypeOpBaseEq
          <|> mkRngNm' Type_Variable    <$> varop_no_ty
          <|> mkRngNm' Type_Constructor <$> pDARROW

{-# LINE 858 "src/ehc/HS/Parser.chs" #-}
        pTypeOpBase :: HSParser (Type,Range)
        pTypeOpBase
          = mkRngNm' Type_Constructor
            <$> (   gtycon_for_insection
                )

{-# LINE 866 "src/ehc/HS/Parser.chs" #-}
        pTypeOpBaseEq :: HSParser (Type,Range)
        pTypeOpBaseEq
          =   pTypeOpBase
          <|> mkRngNm' Type_Constructor <$> pTILDE

{-# LINE 879 "src/ehc/HS/Parser.chs" #-}
        pTypeApp :: HSParser Type
        pTypeApp
          =  pT <??> pA
          where pT = pTypeBase
                pA = (\es e -> Type_NormalApplication emptyRange e es) <$> pList1 pT

{-# LINE 887 "src/ehc/HS/Parser.chs" #-}
        pTyVarBind :: HSParser Token
        pTyVarBind =  tyvar

        pTyVarBinds :: HSParser [Token]
        pTyVarBinds =  pList1 pTyVarBind

{-# LINE 901 "src/ehc/HS/Parser.chs" #-}
        pTypeLeftHandSide :: HSParser TypeLeftHandSide
        pTypeLeftHandSide
          =   pLhs
          <|> (\c -> mkRngNm TypeLeftHandSide_Function c []) <$> gtycon' tyconsym
          <?> "pTypeLeftHandSide"
          where pLhs     :: HSParser TypeLeftHandSide
                pLhs     =   mkRngNm TypeLeftHandSide_Function <$> gtycon' tyconsym <*> pLhsTail
                         <|> pParens'
                               (   (\l r t -> TypeLeftHandSide_Parenthesized r l t)
                                   <$> pLhs
                               )
                             <*> pLhsTail
                         <|> (\l o r -> TypeLeftHandSide_Infix (mkRange1 o) l (tokMkQName o) r)
                             <$> pTypePatternBase <*> tyconop <*> pTypePatternBase
                pLhsTail ::  HSParser [TypePattern]
                pLhsTail =   pList1 pTypePatternBase

{-# LINE 920 "src/ehc/HS/Parser.chs" #-}
        pAnnotatedType :: HSParser Type -> HSParser Type
        pAnnotatedType pT
          =   (\(r,s) t -> if s
                           then Type_Annotate r TypeAnnotation_Strict t
                           else t
              )
              <$> ((\t -> (mkRange1 t,True)) <$> pBANG <|> pSucceed (emptyRange,False))
              <*> pT

{-# LINE 943 "src/ehc/HS/Parser.chs" #-}
        pContextItemsPrefix1 :: HSParser ContextItems
        pContextItemsPrefix1
          =   (:[]) <$> pContextItemImpl <* pRARROW

        pContextItemsPrefix2 :: HSParser ContextItems
        pContextItemsPrefix2
          =   (   (:[]) <$> (pContextItemBase <|> pContextItemImplWild)
              <|> pParens ((:) <$> pContextItemBase
                               <*> (   pImO
                                   <|> (++) <$> pList1 (pCOMMA *> pContextItemBase) <*> pImO
                                   )
                          <|> pSucceed []
                          )
              )
              <*  pDARROW
          where pImO  =  (:[]) <$ pCOMMA <*> pContextItemImplWild `opt` []
                pImO  :: HSParser ContextItems

        pContextItemsPrefix :: HSParser ContextItems
        pContextItemsPrefix
          =   pContextItemsPrefix1
          <|> pContextItemsPrefix2

        pContextItemsPrefixOpt :: HSParser ContextItems
        pContextItemsPrefixOpt = pContextItemsPrefix <|> pSucceed []

        pTypeContextPrefix :: HSParser (Type -> Type)
        pTypeContextPrefix
          = Type_Qualified emptyRange <$> pContextItemsPrefix

{-# LINE 979 "src/ehc/HS/Parser.chs" #-}
        pContextItemClass :: HSParser ContextItem
        pContextItemClass
          =    mkRngNm ContextItem_Class <$> qconid <*> pList1 pTypeBase

{-# LINE 985 "src/ehc/HS/Parser.chs" #-}
        pContextItemPrefix :: HSParser (ContextItem -> ContextItem)
        pContextItemPrefix
          =   (ContextItem_Forall . mkRange1) <$> pFORALL <*> (tokMkQNames <$> pTyVarBinds) <* pDOT

{-# LINE 991 "src/ehc/HS/Parser.chs" #-}
        pContextItem :: HSParser ContextItem
        pContextItem
          =   pContextItemBase
              <**> (   pSucceed id
                   <|> (\o r l -> ContextItem_Arrow (mkRange1 o) l r) <$> pDARROW <*> pContextItem
                   )
          <|> pContextItemPrefix <*> pContextItem

{-# LINE 1005 "src/ehc/HS/Parser.chs" #-}
        pContextItemImplWild :: HSParser ContextItem
        pContextItemImplWild = (ContextItem_Implicits . mkRange1) <$> pTDOT

{-# LINE 1010 "src/ehc/HS/Parser.chs" #-}
        pContextItemImpl :: HSParser ContextItem
        pContextItemImpl
          = pImpls'
              (    const <$> (pContextItem <|> pContextItemImplWild)
              <|>  pSucceed ContextItem_NoImplicits
              )

{-# LINE 1019 "src/ehc/HS/Parser.chs" #-}
        pContextItemBase ::   HSParser ContextItem
        pContextItemBase
          =   pContextItemClass
          <|> tyvar <**>  (    (\s tv -> mkRngNm ContextItem_RowLacksLabel tv (tokMkQName s))
                               <$ pLAM <*> pSelector
                          )

{-# LINE 1043 "src/ehc/HS/Parser.chs" #-}
        pLiteralNumber :: HSParser Literal
        pLiteralNumber
          =   mk  8 <$> pInteger8Tk
          <|> mk 10 <$> pInteger10Tk
          <|> mk 16 <$> pInteger16Tk
          <?> "pLiteralNumber"
          where mk b t = Literal_Int (mkRange1 t) b (tokMkStr t)

{-# LINE 1059 "src/ehc/HS/Parser.chs" #-}
        pLiteral :: HSParser Literal
        pLiteral
          =   pLiteralNumber
          <|> mkRngStr Literal_Char <$> pCharTk
          <|> mkRngStr Literal_String <$> pStringTk
          <|> mkRngStr Literal_Float  <$> pFractionTk
          <?> "pLiteral"

{-# LINE 1077 "src/ehc/HS/Parser.chs" #-}
        pExpressionMinusPrefix :: HSParser (Expression -> Expression)
        pExpressionMinusPrefix
          =   (Expression_Negate . mkRange1) <$> pMINUS

        pExpressionMbMinusPrefix :: HSParser (Expression -> Expression)
        pExpressionMbMinusPrefix
          =   pExpressionMinusPrefix
          <|> pSucceed id

        pExpressionBase :: HSParser Expression
        pExpressionBase
          =   Expression_Literal emptyRange  <$> pLiteral
          <|> mkRngNm Expression_Variable    <$> qvar
          <|> pExpressionList
          <|> pParens' pInParens
          <?> "pExpressionBase"
          where pInParens :: HSParser (Range -> Expression)
                pInParens
        {-
                  =   (\(e,res) r ->
                         let mk res e
                               = case res of
                                   Expression3OpSection_None
                                     -> Expression_Parenthesized r e
                                   Expression3OpSection_Op (o,_)
                                     -> Expression_SectionApplication r (Just e) o Nothing
                                   Expression3OpSection_CommaList es
                                     -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                                                   (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es))
                                   Expression3OpSection_Typed (t,r)
                                     -> Expression_Typed r e t
                         in foldr mk e $ reverse res
                      )
                      <$> pExpression3OpSection pOp pExpressionPreBase
        -}
        {-
        -}
                  =   (\(e,_,res) r ->
                         let chk ress e
                               = case ress of
                                   (Expression4Result_Op (o,_) : _)
                                     -> Expression_SectionApplication r (Just e) o Nothing
                                   (Expression4Result_CommaList es : _)
                                     -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                                                   (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es))
                                   _ -> Expression_Parenthesized r e
                         in chk res e
                      )
                      <$> pExpression4'' True pOp pExpressionPrefix pExpressionLayout
        {-
                  =   (pExpression <**>
                            (   (\(o,_) e r -> Expression_SectionApplication r (Just e) o Nothing)
                                <$> pOp
                            <|> pSucceed (flip Expression_Parenthesized)
                            <|> (\es e r -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                              (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es)))
                                <$> pList1 (pComma *> pExpression)
                      )     )
        -}
                  <|> flip Expression_TupleConstructor <$> commas_arity
                  <|> (pOpm
                       <**> (   (\e (o,_) r -> Expression_SectionApplication r Nothing o (Just e)) <$> pExpression
                            -- <|> pSucceed (\(o,_) r -> Expression_SectionApplication r Nothing o Nothing)
                      )     )
                  <|> pSucceed (\r -> Expression_RowRecordEmpty r)
                  <|> (\fs r -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r) fs) <$> pFlds
                  <|> pExtFlds
                  where pFld :: HSParser (Expression -> RowRecordExpressionUpdate)
                        pFld = qvarid
                               <**> (   (\l -> RowRecordExpressionUpdate_Extends (mkRange1 l) (Just (tokMkQName l))) <$ pEQUAL
                                    <|> mkRngNm RowRecordExpressionUpdate_Update <$ pCOLEQUAL
                                    )
                        pFlds :: HSParser [RowRecordExpressionUpdate]
                        pFlds = pList1Sep pComma (pFld <*> pExpression)
                        pExtFlds :: HSParser (Range -> Expression)
                        pExtFlds
                             = (\e fs r -> Expression_RowRecordUpdate r e fs)
                               <$> (   pParens' pExtFlds
                                   <|> mkRngNm Expression_Variable <$> qvarid
                                   <|> pSucceed (Expression_RowRecordEmpty emptyRange)
                                   )
                               <*  pVBAR <*> pFlds

{-# LINE 1181 "src/ehc/HS/Parser.chs" #-}
        pExpressionList :: HSParser Expression
        pExpressionList
          = pBracks'
              (pExpression
               <**> (   pDOTDOT
                        *> (     (\e3 e1 r -> Expression_Enum r e1 Nothing (Just e3)) <$> pExpression
                           `opt` (\   e1 r -> Expression_Enum r e1 Nothing  Nothing )
                           )
                    <|> pCOMMA
                        *> (pExpression
                            <**> (   pDOTDOT
                                     *> (     (\e3 e2 e1 r -> Expression_Enum r e1 (Just e2) (Just e3)) <$> pExpression
                                        `opt` (\   e2 e1 r -> Expression_Enum r e1 (Just e2)  Nothing )
                                        )
                                 <|> (\es e2 e1 r -> Expression_List r (e1:e2:es)) <$> pList (pComma *> pExpression)
                           )     )
                    <|> pVBAR
                        *> ((\c e r -> Expression_Comprehension r e (c ++ [Qualifier_Empty emptyRange])) <$> pListSep pCOMMA pQualifier)
                    `opt` flip one
                    )
              `opt` zero
              )
          <?> "pExpressionList"
          where zero r   = Expression_List r []
                one  r h = Expression_List r [h]
                pQualifier :: HSParser Qualifier
                pQualifier
                  =   Qualifier_Guard emptyRange <$> pExpressionNoLet
                  <|> (Qualifier_Let . mkRange1) <$> pLET <*> pDeclarations
                  <|> Qualifier_Generator emptyRange <$> pPattern <* pLARROW <*> pExpression

{-# LINE 1221 "src/ehc/HS/Parser.chs" #-}
        pExpressionDo :: HSParser Expression
        pExpressionDo
          =   (Expression_Do . mkRange1) <$> pDO <*> pBlock1 pOCURLY pSEMI pCCURLY pStatement
          <?> "pExpressionDo"
          where pStatement :: HSParser Statement
                pStatement
                  =   Statement_Expression emptyRange <$> pExpression {- pExpressionNoLet -}
                  <|> (\p t e -> Statement_Generator (mkRange1 t) p e) <$> pPattern <*> pLARROW <*> pExpression
                      -- common prefix with 'let x=e in e' dies out
                  <|> (Statement_Let . mkRange1) <$> pLET <*> pDeclarations

{-# LINE 1269 "src/ehc/HS/Parser.chs" #-}
        pExpressionConUpd :: HSParser Expression
        pExpressionConUpd
          =   qcon
              <**> (   pSucceed (mkRngNm Expression_Constructor)
                   <|> pCurlys' ((\bs _ c -> mkRngNm Expression_RecordConstruction c bs) <$> pListSep pCOMMA pRecordExpressionBinding)
                   )
          <|> pExpressionBase
              <**> ((\u e -> foldr ($) e u) <$> pList pU)
          <?> "pExpressionConUpd"
          where pU =   pCurlys' ((\bs r e -> Expression_RecordUpdate r e bs) <$> pList1Sep pCOMMA pRecordExpressionBinding)
                   <|> pRowRecordSelectionSuffix

{-# LINE 1289 "src/ehc/HS/Parser.chs" #-}
        pRecordExpressionBinding :: HSParser RecordExpressionBinding
        pRecordExpressionBinding
          =   mkRngNm RecordExpressionBinding_Binding <$> qvar <* pEQUAL <*> pExpression
          <?> "pRecordExpressionBinding"

{-# LINE 1296 "src/ehc/HS/Parser.chs" #-}
        pExpressionApp :: HSParser Expression
        pExpressionApp
          =   pE <**> ((\as e -> foldl (flip ($)) e as) <$> pList pA)
          <?> "pExpressionApp"
          where pE =   pExpressionConUpd
                pA =   (\es e -> Expression_NormalApplication emptyRange e es) <$> pList1 pE
                   <|> (\es e -> Expression_ImpredicativeApplication emptyRange e es) <$> pList1 (pTILDE *> pE)
                   <|> (\es e -> Expression_ImplicitApplication emptyRange e es) <$> pList1 (pImpls' pContextedExpression)
                   where pContextedExpression = (\e c r -> ContextedExpression_Contexted r e c) <$> pExpression <* pLTCOLON <*> pContextItem
                         pContextedExpression :: HSParser (Range -> ContextedExpression)

{-# LINE 1313 "src/ehc/HS/Parser.chs" #-}
        pExpressionLayout :: HSParser Expression
        pExpressionLayout
          =   pMaybe id id pExpressionMinusPrefix <*> pExpressionApp
          <|> (Expression_Case . mkRange1) <$> pCASE <*> pExpression <* pOptSEMISeparator <* pOF <*> pAlternatives
          <|> pExpressionDo
          <?> "pExpressionLayout"

{-# LINE 1326 "src/ehc/HS/Parser.chs" #-}
        pOp, pOpm :: HSParser (Expression,Range)
        pOp  = mkRngNm' Expression_Variable <$> qvarop          <|> mkRngNm' Expression_Constructor <$> qconop
        pOpm = mkRngNm' Expression_Variable <$> qvarop_no_minus <|> mkRngNm' Expression_Constructor <$> qconop

{-# LINE 1332 "src/ehc/HS/Parser.chs" #-}
        pExpression4'' :: Bool -> HSParser (Expression,Range) -> HSParser (Expression -> Expression) -> HSParser Expression -> HSParser Expression4
        pExpression4'' inParen pOp pPreNotOp pBase
          =   ((\(e,cnt,res) -> (mkC cnt e,0,res)) <$> pE)
              <**> (addCommaP $ addOpP
                    $ (   (addCommaP2
                           $ ((\c t (e,cnt,res) -> (Expression_Typed (mkRange1 c) (mkC cnt e) t, 0, Expression4Result_Typed : res))
                              <$> pDCOLON <*> pType
                          )  )
                      <|> pSucceed id
                   )  )
          where pE  ::  HSParser Expression4
                pE  =   pBase <**>
                          (   pSucceed (\e -> (e,0,[]))
                          <|> (\(op,rng) (r,opCnt,res) l -> (Expression_InfixApplication rng l op r, opCnt+1, res)) <$> pOp <*> pE
                          )
                    <|> (\p (e,cnt,res) -> (p $ mkC cnt $ e, 0, Expression4Result_NotOpPre : res))
                        <$> pPreNotOp <*> pE

                -- add trailing parsers, depending on being inside parenthesis
                addCommaP, addCommaP2, addOpP :: HSParser (Expression4 -> Expression4) -> HSParser (Expression4 -> Expression4)

                -- optionally add tuple expr remainder as choice
                addCommaP  p | inParen   = p <|> (\es (e,cnt,res) -> (mkC cnt e, 0, Expression4Result_CommaList es : res))
                                                 <$> pList1 (pComma *> pExpression)
                             | otherwise = p

                -- optionally add tuple expr remainder as following in a sequence
                addCommaP2 p | inParen   = (\mkecntres es ecntres ->
                                              let (e,cnt,res) = mkecntres ecntres
                                              in  (mkC cnt e, 0, (if null es then [] else [Expression4Result_CommaList es]) ++ res)
                                           )
                                           <$> p <*> pList (pComma *> pExpression)
                             | otherwise = p

                -- optionally add operator as choice
                addOpP     p | inParen   = p <|> (\o (e,cnt,res) -> (mkC cnt e, 0, Expression4Result_Op o : res))
                                                 <$> pOp
                             | otherwise = p

                -- add additional AST depending on nr of operators
                mkC cnt = if cnt > 0 then Expression_InfixApplicationChainTop emptyRange else id

        pExpression4' :: HSParser (Expression -> Expression) -> HSParser Expression
        pExpression4' pPreNotOp = (\(e,_,_) -> e) <$> pExpression4'' False pOp pPreNotOp pExpressionLayout

{-# LINE 1379 "src/ehc/HS/Parser.chs" #-}
        pExpressionPreBase :: HSParser Expression
        pExpressionPreBase = (\ps e -> foldr ($) e ps) <$> pList_gr pExpressionPrefix <*> pExpressionLayout

        pExpression :: HSParser Expression
        pExpression
          -- =   pExpression1' pExpressionPrefix
          -- =   pExpression2' pExpressionPrefix
          -- = pExpression3' pExpressionPreBase
          = pExpression4' pExpressionPrefix
            <?> "pExpression"

{-# LINE 1392 "src/ehc/HS/Parser.chs" #-}
        pExpressionNoLet :: HSParser Expression
        pExpressionNoLet
          -- =   pExpression' pExpressionNoLetPrefix
          -- =   pExpression2' pExpressionNoLetPrefix
          -- = pExpression3' pBase3
          =   pExpression4' pExpressionNoLetPrefix
            <?> "pExpressionNoLet"
          where pBase3 :: HSParser Expression
                pBase3 = (\ps e -> foldr ($) e ps) <$> pList pExpressionNoLetPrefix <*> pExpressionLayout

{-# LINE 1404 "src/ehc/HS/Parser.chs" #-}
        pExpressionLetPrefix :: HSParser (Expression -> Expression)
        pExpressionLetPrefix
          =   (\(s,t,d) -> Expression_Let (mkRange1 t) s d)
              <$> (   (,,) False <$> pLET       <*> pDeclarations                       <* pIN
                  <|> (,,) True  <$> pLETSTRICT <*> pLayoutList pDeclarationSimpleValue <* pIN
                  )
          <?> "pExpressionLetPrefix"

{-# LINE 1420 "src/ehc/HS/Parser.chs" #-}
        pExpressionNoLetPrefix :: HSParser (Expression -> Expression)
        pExpressionNoLetPrefix
          =   pLAM <**> pLamArgs
          <|> (Expression_If . mkRange1) <$> pIF <*> pExpression <* pOptSEMISeparator <* pTHEN <*> pExpression <* pOptSEMISeparator <* pELSE
          -- <|> pExpressionMinusPrefix
          <?> "pExpressionNoLetPrefix"
          where pLamArgs
                  =   (\a1 a2 t e -> a1 t (a2 t e))
                      <$> (   (\ps t e -> Expression_Lambda (mkRange1 t) ps e) <$> pList1 pPatternBaseCon
                          <|> (\ps t e -> Expression_ImplicitLambda (mkRange1 t) ps e) <$> pList1 (pImpls' pContextedPattern)
                          )
                      <*> pLamArgs
                  <|> (\_ e -> e) <$ pRARROW
                pContextedPattern = (\p c r -> ContextedPattern_Contexted r p c) <$> pPattern <* pLTCOLON <*> pContextItem
                pContextedPattern :: HSParser (Range -> ContextedPattern)

{-# LINE 1444 "src/ehc/HS/Parser.chs" #-}
        pExpressionPrefix :: HSParser (Expression -> Expression)
        pExpressionPrefix
          =   pExpressionLetPrefix
          <|> pExpressionNoLetPrefix
          <?> "pExpressionPrefix"

{-# LINE 1456 "src/ehc/HS/Parser.chs" #-}
        pAlternative :: HSParser Alternative
        pAlternative
          = Alternative_Alternative emptyRange <$> pPattern <*> pRhs pRARROW

        pAlternatives :: HSParser Alternatives
        pAlternatives
          = pBlock1 pOCURLY pSEMI pCCURLY pAlternative

{-# LINE 1470 "src/ehc/HS/Parser.chs" #-}
        pPatternBaseInParens :: HSParser (Range -> Pattern)
        pPatternBaseInParens
          =   (pPattern
               <**> (   pSucceed (flip Pattern_Parenthesized)
                    <|> (\es e r -> Pattern_RowRecordBinding r (Pattern_RowRecordEmpty r)
                                      (map (RowRecordPatternBinding_Binding r Nothing) (e:es)))
                        <$>  pList1 (pComma *> pPattern)
              )     )
          <|> (\v _ -> mkRngNm Pattern_Variable v) <$> qvarsym_for_inparens
          <|> pSucceed (\r -> Pattern_RowRecordEmpty r)
          <|> (\fs r -> Pattern_RowRecordBinding r (Pattern_RowRecordEmpty r) fs) <$> pFlds
          <|> pExtFlds
          <?> "pPatternBaseInParens"
          where pFld :: HSParser (Pattern -> RowRecordPatternBinding)
                pFld = qvarid
                       <**> (   (\l -> RowRecordPatternBinding_Binding (mkRange1 l) (Just (tokMkQName l))) <$ pEQUAL
                            )
                pFlds :: HSParser [RowRecordPatternBinding]
                pFlds = pList1Sep pComma (pFld <*> pPattern)
                pExtFlds :: HSParser (Range -> Pattern)
                pExtFlds
                     = (\e fs r -> Pattern_RowRecordBinding r e fs)
                       <$> (   mkRngNm Pattern_Variable <$> qvar
                           <|> pSucceed (Pattern_RowRecordEmpty emptyRange)
                           )
                       <*  pVBAR <*> pFlds

{-# LINE 1508 "src/ehc/HS/Parser.chs" #-}
        pPatternBaseMinusLiteral :: HSParser Pattern
        pPatternBaseMinusLiteral = (\m n -> Pattern_Literal (mkRange1 m) (-1) n) <$> pMINUS <*> pLiteralNumber

{-# LINE 1513 "src/ehc/HS/Parser.chs" #-}
        pPatternBaseNoParens :: HSParser Pattern
        pPatternBaseNoParens
          = (
              (if ehcOptBangPatterns opts
               then (\p -> p <|> (Pattern_Bang . mkRange1) <$> pBANG  <*> pPatternBaseCon)
               else id
              ) $
              (   qvarid
                  <**> (   (\a p v -> Pattern_As (mkRange1 a) (tokMkQName v) p) <$> pAT <*> pPatternBaseCon
                       <|> pSucceed (mkRngNm Pattern_Variable)
                       )
              <|> Pattern_Literal emptyRange 1 <$> pLiteral
              <|> pBracks' (flip Pattern_List <$> pListSep pCOMMA pPattern)
              <|> (Pattern_Irrefutable . mkRange1) <$> pTILDE <*> pPatternBaseCon
            ) )
          <?> "pPatternBaseNoParens"

{-# LINE 1539 "src/ehc/HS/Parser.chs" #-}
        pPatternBase :: HSParser Pattern
        pPatternBase
          =   pPatternBaseNoParens
          <|> pParens' pPatternBaseInParens
          <?> "pPatternBase"

{-# LINE 1547 "src/ehc/HS/Parser.chs" #-}
        pPatternConSuffix :: HSParser (Token -> Pattern)
        pPatternConSuffix
          =   pSucceed (\c -> mkRngNm Pattern_Constructor c [])
          <|> pCurlys' ((\bs _ c -> mkRngNm Pattern_Record c bs) <$> pListSep pCOMMA pRecordPatternBinding)
          <?> "pPatternConSuffix"

{-# LINE 1557 "src/ehc/HS/Parser.chs" #-}
        pPatternBaseCon :: HSParser Pattern
        pPatternBaseCon
          =   pPatternBase
          <|> qconid <**> pPatternConSuffix
          <?> "pPatternBaseCon"

{-# LINE 1565 "src/ehc/HS/Parser.chs" #-}
        pRecordPatternBinding :: HSParser RecordPatternBinding
        pRecordPatternBinding
          =   qvar
              <**> (   pSucceed (\v -> mkRngNm RecordPatternBinding_Pun v)
                   <|> (\p v -> mkRngNm RecordPatternBinding_Binding v p) <$ pEQUAL <*> pPattern
                   )
          <?> "pRecordPatternBinding"

{-# LINE 1575 "src/ehc/HS/Parser.chs" #-}
        pPatternApp :: HSParser Pattern
        pPatternApp
          =   pPatternBase
          <|> pPatternBaseMinusLiteral
          <|> qcon
              <**> (   (\l c -> mkRngNm Pattern_Constructor c l) <$> pList1 pPatternBaseCon
                   <|> pPatternConSuffix
                   )
          <|> (Pattern_Tuple emptyRange) <$> pParens commas_arity <*> pList1 pPatternBaseCon
          <?> "pPatternApp"

{-# LINE 1590 "src/ehc/HS/Parser.chs" #-}
        pPatternOp :: HSParser Pattern
        pPatternOp
          -- =   (\l rs -> foldr (\(o,r) mk -> \l -> o l (mk r)) id rs l) <$> pPatternApp <*> pList_ng (pOp <+> pPatternApp)
          = pChainr_ng pOp pPatternApp
          <?> "pPatternOp"
          where pOp =
                    ((\o l r -> Pattern_InfixConstructor (mkRange1 o) l (tokMkQName o) r) <$> qconop)

{-# LINE 1604 "src/ehc/HS/Parser.chs" #-}
        pPattern :: HSParser Pattern
        pPattern
          =   pPatternOp
              <??> ((\c t p -> Pattern_Typed (mkRange1 c) p t) <$> pDCOLON <*> pType)
          <?> "pPattern"

{-# LINE 1614 "src/ehc/HS/Parser.chs" #-}
        pRowRecordSelectionSuffix :: HSParser (Expression -> Expression)
        pRowRecordSelectionSuffix
          = (\lbls e -> foldl (\e l -> Expression_RowRecordSelect (mkRange1 l) e (tokMkQName l)) e lbls)
            <$> pList1 (pHASH *> pSelector)

{-# LINE 1621 "src/ehc/HS/Parser.chs" #-}
        pSelector :: HSParser Token
        pSelector
          =   qvarid <|> qconid <|> pIntegerTk

{-# LINE 1631 "src/ehc/HS/Parser.chs" #-}
        pTypePatternBase :: HSParser TypePattern
        pTypePatternBase
          =   mkRngNm TypePattern_Variable <$> var_no_ty
          <?> "pTypePatternBase"


{-# LINE 1653 "src/ehc/HS/Parser.chs" #-}
commas' :: HSParser [Token]
commas' = pList1 pCOMMA

commas :: HSParser Token
commas =  (map (\s -> strProd (length s + 1)) . foldr tokConcat tokEmpty) <$> commas'
  where map = tokenMap

{-# LINE 1666 "src/ehc/HS/Parser.chs" #-}
commas_arity :: HSParser Int
commas_arity =  (\ts -> length ts + 1) <$> commas'

{-# LINE 1673 "src/ehc/HS/Parser.chs" #-}
pOptSEMISeparator :: HSParser (Maybe ())
pOptSEMISeparator = pMb (pSeparator <|> () <$ pSEMI)

{-# LINE 1678 "src/ehc/HS/Parser.chs" #-}
modid :: HSParser Token
modid
  =   pCONID
  <|> pQCONID
  <?> "modid"

{-# LINE 1688 "src/ehc/HS/Parser.chs" #-}
qcnames :: HSParser [Token]
qcnames
  =   pListSep pCOMMA qcname
  <?> "qcnames"

qcname  :: HSParser Token   -- Variable or data constructor
qcname
  =   qvar
  <|> gcon
  <?> "qcname"

{-# LINE 1701 "src/ehc/HS/Parser.chs" #-}
identifier :: HSParser Token
identifier
  =   qvar
  <|> gcon
  <|> qop
  <?> "identifier"

depreclist :: HSParser [Token]
depreclist
  = pList1Sep pCOMMA deprec_var

deprec_var :: HSParser Token
deprec_var
  =   var
  <|> tyconid
  <?> "deprec_var"

gcon    :: HSParser Token   -- Data constructor namespace
gcon
  =   sysdcon
  <|> qcon
-- the case of '[:' ':]' is part of the production `parr'
  <?> "gcon"

sysdcon :: HSParser Token   -- Wired in data constructors
sysdcon
  =   pParens commas
  <|> tokConcat <$> pOBRACK <*> pCBRACK
  <?> "sysdcon"


{-# LINE 1740 "src/ehc/HS/Parser.chs" #-}
qcon    :: HSParser Token
qcon
  =   qconid
  <|> pParens qconsym
  <?> "qcon"



conop :: HSParser Token
conop
  =   consym
  <|> pBACKQUOTE *> conid <* pBACKQUOTE
  <?> "conop"

qconop :: HSParser Token
qconop
  =   qconsym
  <|> pBACKQUOTE *> qconid <* pBACKQUOTE
  <?> "qconop"

{-# LINE 1767 "src/ehc/HS/Parser.chs" #-}
qconid :: HSParser Token    -- Qualified or unqualifiedb
qconid
  =   conid
  <|> pQCONID
  <?> "qconid"

{-# LINE 1777 "src/ehc/HS/Parser.chs" #-}
conid_nopragma   :: HSParser Token
conid_nopragma
  =   pCONID
  <?> "conid_nopragma"

conid   :: HSParser Token
conid
  =   conid_nopragma
  <|> pLANGUAGE_prag
  <|> pDERIVABLE_prag
  <?> "conid"

qconsym :: HSParser Token   -- Qualified or unqualified
qconsym
  =   consym
  <|> pQCONSYM
  <?> "qconsym"

{-# LINE 1801 "src/ehc/HS/Parser.chs" #-}
consym :: HSParser Token
consym
  =   pCONSYM
  <|> pCOLON -- ':' means only list cons
  <?> "consym"

{-# LINE 1809 "src/ehc/HS/Parser.chs" #-}
con :: HSParser Token
con
  =   conid
  <|> pParens consym
  <?> "con"

{-# LINE 1817 "src/ehc/HS/Parser.chs" #-}
-----------------------------------------------------------------------------
-- Any operator

op  :: HSParser Token   -- used in infix decls
op
  =   varop
  <|> conop
  <?> "op"

qop :: HSParser Token   -- used in sections
qop
  =   qvarop
  <|> qconop
  <?> "qop"


{-# LINE 1854 "src/ehc/HS/Parser.chs" #-}
tyvar   :: HSParser Token
tyvar
  =   varid_no_ty
  <?> "tyvar"

{-# LINE 1865 "src/ehc/HS/Parser.chs" #-}
-- | special identifier: FFI safety
safety :: HSParser Token
safety
  =   pSAFE
  <|> pUNSAFE
  <|> pTHREADSAFE
  <?> "safety"

{-# LINE 1877 "src/ehc/HS/Parser.chs" #-}
-- | special identifier: FFI calling convention
callconv :: HSParser Token
callconv
  =   snd <$> pFFIWay
  <?> "callconv"

{-# LINE 1885 "src/ehc/HS/Parser.chs" #-}
-- These special_ids are treated as keywords in various places,
-- but as ordinary ids elsewhere.   'special_id' collects all these
-- except 'unsafe' and 'forall' whose treatment differs depending on context
-- | special identifier: some context sensitive meaningful
special_id_no_callconv :: HSParser Token
special_id_no_callconv
  =   pLABEL
  <|> pEXPORT
  <|> pAS
  <|> pQUALIFIED
  <|> pHIDING
  <|> pDYNAMIC
  <?> "special_id_no_callconv"

{-# LINE 1905 "src/ehc/HS/Parser.chs" #-}
special_id :: HSParser Token
special_id
  =   special_id_no_callconv
  <|> callconv
  <?> "special_id"

{-# LINE 1913 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified value/function, e.g.: f, except type related keywords
varid_no_ty :: HSParser Token
varid_no_ty
  =   pVARID
  <|> special_id_no_callconv
  <|> callconv
  <|> safety
  <?> "varid_no_ty"

{-# LINE 1929 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified value/function, e.g.: f
varid :: HSParser Token
varid
  =   varid_no_ty
  <|> pFORALL
  <|> pEXISTS
  <?> "varid"

{-# LINE 1941 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified value/function, e.g.: X.f
qvarid :: HSParser Token
qvarid
  =   varid
  <|> pQVARID
  <?> "qvarid"

{-# LINE 1952 "src/ehc/HS/Parser.chs" #-}
-- | See comments with special_id
special_sym_no_bang :: HSParser Token
special_sym_no_bang
  =   pDOT
  <|> pSTAR
  <|> pPERCENT
  <?> "special_sym_no_bang"

special_sym :: HSParser Token
special_sym
  =   pBANG
  <|> special_sym_no_bang
  <?> "special_sym"

{-# LINE 1968 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified operator, e.g.: +, except -, !
varsym_no_minus_bang :: HSParser Token
varsym_no_minus_bang
  =   pVARSYM
  <|> special_sym_no_bang
  <?> "varsym_no_minus_bang"

varsym_no_minus :: HSParser Token
varsym_no_minus
  =   pVARSYM
  <|> special_sym
  <?> "varsym_no_minus"

{-# LINE 1983 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified operator, e.g.: +
varsym :: HSParser Token
varsym
  =   varsym_no_minus
  <|> pMINUS
  <?> "varsym"

{-# LINE 1992 "src/ehc/HS/Parser.chs" #-}
-- | Qualified operator, e.g.: X.+, only base
qvarsym_base :: HSParser Token
qvarsym_base
  =   pQVARSYM
  <?> "qvarsym1"

{-# LINE 2000 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: X.+, except -
qvarsym_no_minus :: HSParser Token
qvarsym_no_minus
  =   varsym_no_minus
  <|> qvarsym_base
  <?> "qvarsym_no_minus"

{-# LINE 2011 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: X.+, for use inside parens
qvarsym_for_inparens :: HSParser Token
qvarsym_for_inparens
  =   varsym
  <|> qvarsym_base
  <?> "qvarsym_for_inparens"

{-# LINE 2022 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: X.+
qvarsym :: HSParser Token
qvarsym
  =   qvarsym_for_inparens
  <?> "qvarsym"

{-# LINE 2030 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: +, `f`, except -, !
varop_no_minus_bang   :: HSParser Token
varop_no_minus_bang
  =   varsym_no_minus_bang
  <|> pBACKQUOTE *> varid <* pBACKQUOTE
  <?> "varop_no_minus_bang"

-- | (Un)qualified operator, e.g.: +, `f`, except -
varop_no_minus   :: HSParser Token
varop_no_minus
  =   varsym_no_minus
  <|> pBACKQUOTE *> varid <* pBACKQUOTE
  <?> "varop_no_minus"

{-# LINE 2046 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: +, `f`, except type related keywords
varop_no_ty   :: HSParser Token
varop_no_ty
  =   varsym
  <|> pBACKQUOTE *> varid_no_ty <* pBACKQUOTE
  <?> "varop_no_minus"

{-# LINE 2055 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: +, `f`, except !
varop_no_bang   :: HSParser Token
varop_no_bang
  =   varop_no_minus_bang
  <|> pMINUS
  <?> "varop_no_bang"

-- | (Un)qualified operator, e.g.: +, `f`
varop   :: HSParser Token
varop
  =   varop_no_minus
  <|> pMINUS
  <?> "varop"

{-# LINE 2071 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: X.+, `X.f`, except -
qvarop_no_minus :: HSParser Token
qvarop_no_minus
  =   qvarsym_no_minus
  <|> pBACKQUOTE *> qvarid <* pBACKQUOTE
  <?> "qvarop_no_minus"

{-# LINE 2080 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified operator, e.g.: X.+, `X.f`
qvarop :: HSParser Token
qvarop
  =   qvarsym
  <|> pBACKQUOTE *> qvarid <* pBACKQUOTE
  <?> "qvarop"

{-# LINE 2089 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified value/function, e.g.: f, (+), except type related keywords
var_no_ty     :: HSParser Token
var_no_ty
  =   varid_no_ty
  <|> pParens varsym
  <?> "var"

{-# LINE 2098 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified value/function, e.g.: f, (+)
var     :: HSParser Token
var
  =   varid
  <|> pParens varsym
  <?> "var"

{-# LINE 2107 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified value/function, e.g.: X.f, (X.+)
qvar    :: HSParser Token
qvar
  =   qvarid
  <|> pParens qvarsym_for_inparens
  <?> "qvar"

{-# LINE 2124 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified type constructor, e.g.: :+:
tyconsym :: HSParser Token
tyconsym
  =   pCONSYM
  <?> "tyconsym"

{-# LINE 2132 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified type constructor, e.g.: X.:+:
qtyconsym :: HSParser Token
qtyconsym
  =   tyconsym
  <|> pQCONSYM
  <?> "qtyconsym"

{-# LINE 2143 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified type constructor, e.g.: Either
tyconid   :: HSParser Token
tyconid
  =   pCONID
  <?> "tyconid"

{-# LINE 2154 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified type constructor, e.g.: X.Either
qtyconid :: HSParser Token
qtyconid
  =   tyconid
  <|> pQCONID
  <?> "qtyconid"

{-# LINE 2165 "src/ehc/HS/Parser.chs" #-}
-- | Unqualified infix type operator, e.g.: `Either`, :+:
tyconop :: HSParser Token   -- Unqualified
tyconop
  =   tyconsym
  <|> pBACKQUOTE *> tyconid <* pBACKQUOTE
  <?> "tyconop"

{-# LINE 2174 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified infix type operator, e.g.: `X.Either`, X.:+:
qtyconop :: HSParser Token
qtyconop
  =   qtyconsym
  <|> pBACKQUOTE *> qtyconid <* pBACKQUOTE
  <?> "qtyconop"

{-# LINE 2183 "src/ehc/HS/Parser.chs" #-}
-- | (Un)qualified prefix type constructor, e.g.: X.Either, (X.:+:)
qtycon :: HSParser Token
qtycon
  =   qtyconid
  <|> pParens qtyconsym
  <?> "qtycon"

{-# LINE 2192 "src/ehc/HS/Parser.chs" #-}
-- | General (un)qualified prefix type constructor, no delimiting brackets (e.g. []), to be parameterized with the part inside parenthesis (the general part)
gtycon_no_delims' :: HSParser Token -> HSParser Token
gtycon_no_delims' pInParens
  =   qtyconid
  <|> pParens pInParens
  <?> "gtycon_no_delims"

{-# LINE 2201 "src/ehc/HS/Parser.chs" #-}
-- | Inside parenthesis part for gtycon
gtycon_for_inparens_arrow :: HSParser Token
gtycon_for_inparens_arrow
  =   pRARROW
  <|> qtyconsym
  <?> "gtycon_for_inparens_arrow"

-- | Inside parenthesis part for gtycon
gtycon_for_inparens_arrow_commas :: HSParser Token
gtycon_for_inparens_arrow_commas
  =   gtycon_for_inparens_arrow
  <|> commas
  <?> "gtycon_for_inparens_arrow"

-- | Inside parenthesis part for type sections
gtycon_for_insection :: HSParser Token
gtycon_for_insection
  =   pRARROW
  <|> qtyconop
  <?> "gtycon_for_insection"

{-# LINE 2226 "src/ehc/HS/Parser.chs" #-}
-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (->)
gtycon_no_delims_commas :: HSParser Token
gtycon_no_delims_commas
  =   gtycon_no_delims' gtycon_for_inparens_arrow
  <?> "gtycon_no_delims_commas"

{-# LINE 2234 "src/ehc/HS/Parser.chs" #-}
-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (,,,), (->)
gtycon_no_delims :: HSParser Token   -- A "general" qualified tycon
gtycon_no_delims
  =   gtycon_no_delims' gtycon_for_inparens_arrow_commas
  <?> "gtycon_no_delims"

{-# LINE 2242 "src/ehc/HS/Parser.chs" #-}
gtycon_only_bracks :: HSParser Token   -- A "general" qualified tycon
gtycon_only_bracks
  =   tokConcat <$> pOBRACK <*> pCBRACK
  -- <|> tokConcat <$> pOPABRACK <*> pCPABRACK
  <?> "gtycon_only_delims"

{-# LINE 2250 "src/ehc/HS/Parser.chs" #-}
-- | General (un)qualified prefix type constructor, including delimiting brackets, to be parameterized with the part inside parenthesis (the general part)
gtycon' :: HSParser Token -> HSParser Token
gtycon' pInParens
  =   gtycon_no_delims' pInParens
  <|> gtycon_only_bracks
  <?> "gtycon'"

{-# LINE 2261 "src/ehc/HS/Parser.chs" #-}
-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (,,,), (->), []
gtycon :: HSParser Token   -- A "general" qualified tycon
gtycon
  =   gtycon' gtycon_for_inparens_arrow_commas
  <?> "gtycon"

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.HS.Parser
( HSParser, HSParser'
, pAGItf
, pAGItfImport )
where
import UU.Parsing
import UU.Parsing.Offside
import UHC.Util.ParseUtils
import UU.Scanner.GenToken
import UHC.Util.ScanUtils
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Base.HsName.Builtin
import UHC.Light.Compiler.Scanner.Common
import UHC.Light.Compiler.Base.TermLike
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.HS
import System.IO
import UHC.Util.Utils
import UHC.Util.Pretty
import Data.Maybe
import UHC.Light.Compiler.Base.Target
import qualified UHC.Util.FastSeq as Seq


















pPacked' :: HSParser Token -> HSParser Token -> HSParser (Range -> v) -> HSParser v
pPacked' pO pC pMk = (\o mk c -> mk (mkRange2 o c)) <$> pO <*> pMk <*> pC

pParens' :: HSParser (Range -> v) -> HSParser v
pParens' = pPacked' pOPAREN pCPAREN

pBracks' :: HSParser (Range -> v) -> HSParser v
pBracks' = pPacked' pOBRACK pCBRACK

pCurlys' :: HSParser (Range -> v) -> HSParser v
pCurlys' = pPacked' pOCURLY pCCURLY



pImpls' :: HSParser (Range -> v) -> HSParser v
pImpls' = pPacked' pOIMPL pCIMPL

pImpls :: IsParser p Token => p v -> p v
pImpls = pPacked pOIMPL pCIMPL



pApp            ::   AppLike a boundmeta => HSParser a -> HSParser a
pApp p          =    appTopApp <$> pList1 p







type HSParser         ep    =    LayoutParser Token ep
type HSParser2        ep    =    LayoutParser2 Token ep
type HSParser'        ep    =    PlainParser Token ep



pAGItf :: EHCOpts -> HSParser AGItf
pAGItf opts
  =   AGItf_AGItf <$> pModule opts pBody'







pAGItfImport :: EHCOpts -> HSParser AGItf
pAGItfImport opts
  =   AGItf_AGItf <$> pModule opts (\opts _ -> pBodyImport opts)











data Expression4Result
  = Expression4Result_Op                (Expression,Range)
  | Expression4Result_CommaList         [Expression]
  | Expression4Result_Typed
  | Expression4Result_NotOpPre
  -- deriving Eq

type Expression4 = (Expression,Int,[Expression4Result])








pPragma' :: (Range -> Pragma -> x) -> HSParser x
pPragma' mk
  = pPacked' pOPRAGMA pCPRAGMA
      (   (\t ps r -> mk r $ Pragma_Language   (mkRange1 t) ps)
          <$> pLANGUAGE_prag   <*> pCommas (tokMkQName <$>           conid)
      <|> (\t cl fld val r -> mk r $ Pragma_Derivable (mkRange1 t) (tokMkQName cl) (tokMkQName fld) (tokMkQName val))
          <$> pDERIVABLE_prag  <*> gtycon' tyconsym <*> var <*> qvar
      <|> (\t targ r -> mk r $ Pragma_ExcludeIfTarget (mkRange1 t) (map tokMkStr $ concat targ))
          <$> pEXCLUDEIFTARGET_prag  <*> pList1Sep pCOMMA (pList1 (conid <|> varid))
      <|> (\t targ r -> mk r $ Pragma_OptionsUHC (mkRange1 t) (tokMkStr targ))
          <$> pOPTIONSUHC_prag  <*> pStringTk
      )

pPragma :: HSParser Pragma
pPragma = pPragma' (flip const)

pDeclarationPragma :: HSParser Declaration
pDeclarationPragma
  = pPragma' Declaration_Pragma








pModule :: EHCOpts -> (EHCOpts -> (HSParser2 Declaration) -> HSParser Body) -> HSParser Module
pModule opts pBody
  = pList_gr pPragma
    <**> (   (\      b p -> Module_Module emptyRange   Nothing                 p Nothing b) <$> pBody opts id
         <|> (\t m e b p -> Module_Module (mkRange1 t) (Just $ tokMkQName $ m) p e       b) <$> pMODULE <*> modid <*> pMaybeExports <* pWHERE <*> pBody opts (\d -> d <|> pDeclarationPragma)
         )
  <?> "pModule"



















pImportExport :: (Range -> Name -> ie,Range -> Name -> MaybeNames -> ie,Range -> Name -> ie) -> HSParser ie
pImportExport (sem_Var,sem_tOrC,sem_tOrC_complete)
  =   mkRngNm sem_Var <$> qvar
  <|> qtycon
      <**> (   pParens
                 (   (\c n -> mkRngNm sem_tOrC n (Just (tokMkQNames c))) <$> qcnames
                 <|> mkRngNm sem_tOrC_complete <$ pDOTDOT
                 )
           <|> pSucceed (\n -> mkRngNm sem_tOrC n Nothing)
           )
  <?> "pImportExport"



pExport :: HSParser Export
pExport
  =   (\t m -> Export_Module (mkRange1 t) (tokMkQName m)) <$> pMODULE <*> modid
  <|> pImportExport (Export_Variable,Export_TypeOrClass,Export_TypeOrClassComplete)
  <?> "pExport"

pMaybeExports :: HSParser MaybeExports
pMaybeExports
  =   Just <$> pParens (pListSep_ng pCOMMA pExport <* pMb pCOMMA)
  <|> pSucceed Nothing
  <?> "pMaybeExports"



pImport :: HSParser Import
pImport
  =   pImportExport (Import_Variable,Import_TypeOrClass,Import_TypeOrClassComplete)
  <?> "pImport"

pImportDeclaration :: HSParser ImportDeclaration
pImportDeclaration
  = (\q m a i -> ImportDeclaration_Import (mkRange1 m) q (tokMkQName m) (fmap tokMkQName a) i)
    <$  pIMPORT <*> (True <$ pQUALIFIED <|> pSucceed False)
    <*> modid
    <*> (Just <$ pAS <*> modid <|> pSucceed Nothing)
    <*> (Just <$> pImportSpecification <|> pSucceed Nothing)
  <?> "pImportDeclaration"
  where pImportSpecification :: HSParser ImportSpecification
        pImportSpecification
          = (True <$ pHIDING <|> pSucceed False)
            <**> pParens'
                   ((\i r h -> ImportSpecification_Import r h i) <$> pListSep_ng pCOMMA pImport <* pMb pCOMMA)







pLayoutList :: HSParser d -> HSParser [d]
pLayoutList pD
  =   pBlock pOCURLY pSEMI pCCURLY pD

pLayoutList1 :: HSParser d -> HSParser [d]
pLayoutList1 pD
  =   pBlock1 pOCURLY pSEMI pCCURLY pD








pBodyImport :: EHCOpts -> HSParser Body
pBodyImport opts
  =   (\d -> Body_Body emptyRange d []) <$> pLayoutList pImportDeclaration
  <?> "pBodyImport"



pBody :: EHCOpts -> HSParser Body
pBody opts = pBody' opts id



pBody' :: EHCOpts -> (HSParser2 Declaration) -> HSParser Body
pBody' opts addDecl
  =   (\ids -> let (i,d) = foldr cmbid ([],[]) ids in Body_Body emptyRange i d)
      <$> pLayoutList (   (\d -> ([],[d])) <$> (addDecl pTopDeclaration)
                      <|> (\i -> ([i],[])) <$> pImportDeclaration
                      )
  <?> "pBody"
  where
        cmbid ([i],_) (is,ds) = (i:is,ds)
        cmbid (_,[d]) (_ ,ds) = ([],d:ds)














        pDeclaration :: HSParser Declaration
        pDeclaration
          =   pDeclarationValue
          <|> pDeclarationTypeSignature
          <|> pDeclarationData
          <|> pDeclarationKindSignature
          <|> pDeclarationInstance
          <|> pDeclarationType
          <|> pDeclarationFusion
          <|> pDeclarationConversion
          <?> "pDeclaration"













        pTopDeclaration :: HSParser Declaration
        pTopDeclaration
          =   pDeclaration
          <|> pDeclarationFixity
          <|> pDeclarationForeign
          <|> pDeclarationClass
          <|> pDeclarationDefault
          <?> "pTopDeclaration"







        pDeclarations :: HSParser Declarations
        pDeclarations
          =   pLayoutList pDeclaration

        pDeclarations1 :: HSParser Declarations
        pDeclarations1
          =   pLayoutList1 pDeclaration



        pWhere'' :: HSParser d -> HSParser [d]
        pWhere'' pD = pWHERE *> pLayoutList pD

        pWhere' :: HSParser d -> HSParser (Maybe [d])
        pWhere' pD = pMb (pWhere'' pD)

        pWhere :: HSParser MaybeDeclarations
        pWhere = pWhere' pDeclaration







        pDeclarationFixity :: HSParser Declaration
        pDeclarationFixity
          = (\f p os@(o:_) -> Declaration_Fixity (mkRange1 o) f p (tokMkQNames os))
            <$> pFixity
            <*> ((Just . tokMkInt) <$> pInteger10Tk <|> pSucceed Nothing)
            <*> pList1Sep pCOMMA op

        pFixity :: HSParser' Fixity
        pFixity = Fixity_Infixl <$ pINFIXL <|> Fixity_Infixr <$ pINFIXR <|> Fixity_Infix <$ pINFIX







        pDeclarationTypeSignature :: HSParser Declaration
        pDeclarationTypeSignature
          =   (\(v:vs) t -> Declaration_TypeSignature (mkRange1 v) (tokMkQNames (v:vs)) t)
              <$> pList1Sep pCOMMA var <* pDCOLON <*> pType
          <?> "pDeclarationTypeSignature"

        pDeclarationValue :: HSParser Declaration
        pDeclarationValue
          =   mkF <$> pLhs <*> rhs
          <|> pPatternOp
              <**> (   (flip mkP) <$> rhs
                   <|> (\o r rhs l -> mkF (mkLI l o r) rhs)
                       <$> pVarOp <*> pPatternOp <*> rhs
                   )
          <?> "pDeclarationValue"
          where pVarOp :: HSParser Token
                pVarOp = if ehcOptBangPatterns opts then varop_no_bang else varop
                pLhsTail ::  HSParser [Pattern]
                pLhsTail =   pList1 pPatternBaseCon
                pLhs     ::  HSParser (Range,LeftHandSide)
                pLhs     =   (\v lhs -> let r = mkRange1 v in (r, LeftHandSide_Function r (tokMkQName v) lhs)) <$> var <*> pLhsTail
                         <|> pParens'
                               (   (\l r t -> (r, mkLP r l t))
                                   <$> pLhs
                               <|> (\pl o pr r t -> (r, mkLP r (mkLI pl o pr) t))
                                   <$> pPatternOp <*> varop <*> pPatternOp
                               )
                             <*> pLhsTail
                mkP  p     rhs = Declaration_PatternBinding emptyRange (p2p p) rhs'
                               where (p2p,rhs') = mkTyPat rhs
                mkF (r,lhs) rhs= Declaration_FunctionBindings r [FunctionBinding_FunctionBinding r (l2l lhs) rhs']
                               where (l2l,rhs') = mkTyLhs rhs
                mkLI l o rh    = (r, LeftHandSide_Infix r l (tokMkQName o) rh)
                               where r = mkRange1 o
                mkLP r (_,l) t = LeftHandSide_Parenthesized r l t
                rhs      =   pMbTy <+> pRhs pEQUAL
                pMbTy    ::  HSParser (Maybe (Token,Type))
                pMbTy    =   pMb (pDCOLON <+> pType)
                mkTyLhs (Just (tok,ty),rhs) = (\l -> LeftHandSide_Typed (mkRange1 tok) l ty,rhs)
                mkTyLhs (_            ,rhs) = (id                                          ,rhs)
                mkTyPat (Just (tok,ty),rhs) = (\p -> Pattern_Typed      (mkRange1 tok) p ty,rhs)
                mkTyPat (_            ,rhs) = (id                                          ,rhs)













        pDeclarationSimpleValue :: HSParser Declaration
        pDeclarationSimpleValue
          =   Declaration_PatternBinding emptyRange <$> lhs <*> rhs
          <?> "pDeclarationSimpleValue"
          where lhs = mkRngNm Pattern_Variable <$> var
                rhs = (\t e -> RightHandSide_Expression (mkRange1 t) e Nothing) <$> pEQUAL <*> pExpression



        pRhs :: HSParser Token -> HSParser RightHandSide
        pRhs pSep
          =   (RightHandSide_Expression . mkRange1) <$> pSep <*> pExpression <*> pWhere
          <|> RightHandSide_Guarded emptyRange
              <$> pList1 ((GuardedExpression_GuardedExpression . mkRange1) <$> pVBAR <*> pExpression <* pSep <*> pExpression)
              <*> pWhere
          <?> "pRhs"





        pDeclarationKindSignature :: HSParser Declaration
        pDeclarationKindSignature
          =   (\(v:vs) t -> Declaration_KindSignature (mkRange1 v) (tokMkQNames (v:vs)) t)
              <$> pList1Sep pCOMMA con <* pDCOLON <*> pKind
          <?> "pDeclarationKindSignature"







        pDeclarationData :: HSParser Declaration
        pDeclarationData
          =   pDATA
              <**> (pCtxt
              <**>  (pTypeLeftHandSide
              <**>   (   (\cs der lhs cx k -> mk Declaration_Data k cx lhs cs der)
                         <$> (pEQUAL *> pListSep pVBAR pDCon) <*> pDer
                     <|> (\cs der lhs cx k -> mk Declaration_Data k cx lhs cs der)
                         <$> pWhere'' (pGADTConstructor) <*> pDer
                     <|> pSucceed (\lhs cx k -> mk Declaration_Data k cx lhs [] [])
                   )))
          <|> pNEWTYPE
              <**> (   (\cx lhs c der k -> mk Declaration_Newtype k cx lhs c der)
                       <$> pCtxt <*> pTypeLeftHandSide <* pEQUAL <*> pNCon <*> pDer
                   )
          <?> "pDeclarationData"
          where mk sem =
                      \k cx lhs cs der
                         -> sem (mkRange1 k) cx lhs cs der
                -- TBD, for now: parse, but ignore quantifiers
                pDCon, pNCon :: HSParser Constructor
                pDCon = pList pTypeQuantPrefix *> pContextedConstructor
                pNCon = pList pTypeQuantPrefix *> pConstructor
                pCtxt :: HSParser ContextItems
                pCtxt = pContextItemsPrefixOpt
                pDer :: HSParser [Deriving]
                pDer = pDERIVING *> ((:[]) <$> pDeriving <|> pParens (pListSep pCOMMA pDeriving)) <|> pSucceed []

























        pDeriving :: HSParser Deriving
        pDeriving
          = (\(n,u) t -> Deriving_Deriving (mkRange1 t) n u (tokMkQName t)) <$> pInstanceName <*> qconid



        pConstructor :: HSParser Constructor
        pConstructor
          =   con
              <**> (   (\ts c -> mkRngNm Constructor_Constructor c ts) <$> pList pTB


                   <|> pCurlys' ((\fs r c -> mkRngNm Constructor_Record c fs) <$> pListSep pCOMMA pFieldDeclaration)


                   )
          <|> (\l o r -> Constructor_Infix (mkRange1 o) l (tokMkQName o) r) <$> pT <*> conop <*> pT
          where pT  = pAnnotatedType pType
                pTB = pAnnotatedType pTypeBase



        pContextedConstructor :: HSParser Constructor
        pContextedConstructor
          =   Constructor_Contexted emptyRange <$> pContextItemsPrefix <*> pConstructor
          <|> pConstructor



        pGADTConstructor :: HSParser Constructor
        pGADTConstructor
          =   mkRngNm Constructor_GADTFunction <$> con <* pDCOLON <*> pType



        pFieldDeclaration :: HSParser FieldDeclaration
        pFieldDeclaration
          = (\vs@(v:_) -> FieldDeclaration_FieldDeclaration (mkRange1 v) (tokMkQNames vs))
            <$> pList1Sep pCOMMA var <* pDCOLON <*> pAnnotatedType pType







        pDeclarationForeign :: HSParser Declaration
        pDeclarationForeign
          = pFOREIGN
            <**> (   (\c s (i,n,t) r -> Declaration_ForeignImport (mkRange1 r) (fst c) s i (tokMkQName n) t)
                     <$ pIMPORT <*> pFFIWay <*> pSafety <*> pFSpec
                 <|> (\c (i,n,t) r -> Declaration_ForeignExport (mkRange1 r) (fst c) i (tokMkQName n) t)
                     <$ pEXPORT <*> pFFIWay <*> pFSpec
                 )
          where pSafety =  (Just . tokMkStr) <$> safety <|> pSucceed Nothing
                pFSpec = (,,) <$> ((Just . tokMkStr) <$> pStringTk <|> pSucceed Nothing) <*> var{-id_no_foreign-} <* pDCOLON <*> pType









        pDeclarationClass :: HSParser Declaration
        pDeclarationClass
          = (\t -> Declaration_Class (mkRange1 t))
            <$> pCLASS
            <*> pContextItemsPrefixOpt <*> pTypeLeftHandSide
            <*> (pVBAR *> pListSep pCOMMA pFunctionalDependency
                `opt` []
                )
            <*> pWhere' (pDeclarationValue <|> pDeclarationTypeSignature)
          where pFunctionalDependency :: HSParser FunctionalDependency
                pFunctionalDependency
                  = (\vs1@(v:_) vs2 -> FunctionalDependency_Dependency (mkRange1 v) (tokMkQNames vs1) (tokMkQNames vs2))
                    <$> pList1 tyvar <* pRARROW <*> pList1 tyvar







        pInstanceName :: HSParser (Maybe HsName,Bool)
        pInstanceName
          =   (\n e -> (Just (tokMkQName n),e)) <$> varid <*> (True <$ pLTCOLON <|> False <$ pDCOLON)
          <|> pSucceed (Nothing,True)



        pDeclarationInstance :: HSParser Declaration
        pDeclarationInstance
          =   pINSTANCE
              <**> (   -- (\((n,u),c,cl,ts) d t -> Declaration_Instance (mkRange1 t) InstNormal n u c (tokMkQName cl) ts d)
                       (\((n,u),c,h) d t -> Declaration_Instance (mkRange1 t) InstNormal n u c h d)
                       <$> pHeader
                       <*> pWhere' pDeclarationValue
                   <|> (\e cl ts t -> Declaration_InstanceUseImplicitly (mkRange1 t) e (tokMkQName cl) ts)
                       <$> pExpression <* pLTCOLON <*> qconid <*> pList1 pTypeBase
                   )
          <|> -- (\t ((n,u),c,cl,ts) -> Declaration_Instance (mkRange1 t) (InstDeriving InstDerivingFrom_Standalone) n u c (tokMkQName cl) ts Nothing)
              (\t ((n,u),c,h) -> Declaration_Instance (mkRange1 t) (InstDeriving InstDerivingFrom_Standalone) n u c h Nothing)
              <$> pDERIVING <* pINSTANCE <*> pHeader
          -- where pHeader = (,,,) <$> pInstanceName <*> pContextItemsPrefixOpt <*> qconid <*> pList1 pTypeBase
          where pHeader = (,,) <$> pInstanceName <*> pContextItemsPrefixOpt <*> pType' pTypeOpBase (\_ p -> p)





        pDeclarationDefault :: HSParser Declaration
        pDeclarationDefault
          = (Declaration_Default . mkRange1) <$> pDEFAULT <*> pMb (tokMkQName <$> qtyconid)
            <*> (   (:[]) <$> pTypeBase
                <|> pParens (pListSep pCOMMA pTypeBase)
                )







        pDeclarationType :: HSParser Declaration
        pDeclarationType
          =   (Declaration_Type . mkRange1) <$> pTYPE <*> pTypeLeftHandSide <* pEQUAL <*> pType









        pDeclarationFusion :: HSParser Declaration
        pDeclarationFusion
          = (Declaration_FusionDeclaration . mkRange1) <$> pFUSE <*> (tokMkQName <$> qvar) -- <* pWITH <*> (tokMkQName <$> qvar)

        pDeclarationConversion :: HSParser Declaration
        pDeclarationConversion
          = (Declaration_FusionConversion . mkRange1) <$> pCONVERT <*> (tokMkQName <$> qvar) <* pCOMMA <*> (tokMkQName <$> qvar)








        pKindBase :: HSParser Kind
        pKindBase
          =   mkRngNm Kind_Constructor <$> pSTAR
          <|> mkRngNm Kind_Variable <$> tyvar
          <|> pParens' pInParens
          <?> "pKindBase"
          where pInParens :: HSParser (Range -> Kind)
                pInParens
                  =   (pKind
                       <**> (   pSucceed (flip Kind_Parenthesized)
                      )     )

        pKind :: HSParser Kind
        pKind
          =   mkK <$> pK
          <?> "pKind"
          where pK ::  HSParser (Kind,Int)
                pK =   pKindBase
                       <**> (   pSucceed (\k -> (k,1))
                            <|> (\(op,rng) (r,opCnt) l -> (Kind_InfixApplication rng l op r,opCnt+1)) <$> pKindOp <*> pK
                            )
                   <|> (\p e -> (p $ mkK $ e,1)) <$> pKindPrefix <*> pK
                mkK (e,1) = e
                mkK (e,_) = {- Expression_InfixApplicationChainTop emptyRange -} e
                pKindOp :: HSParser (Kind,Range)
                pKindOp = mkRngNm' Kind_Constructor <$> pRARROW

        pKindPrefix :: HSParser (Kind -> Kind)
        pKindPrefix
          =  ((Kind_Forall . mkRange1) <$> pFORALL)
             <*> (tokMkQNames <$> pTyVarBinds) <* pDOT







        pTypeBaseCon :: HSParser Type
        pTypeBaseCon
          =   mkRngNm Type_Constructor <$> gtycon_no_delims_commas

        pTypeBase :: HSParser Type
        pTypeBase
          =   pTypeBaseCon
          <|> (Type_Wildcard . mkRange1) <$> pTDOT
          <|> (Type_MonoWildcard . mkRange1) <$> pQDOT
          <|> mkRngNm Type_Variable <$> var_no_ty
          <|> mkRngNm Type_NamedWildcard <$ pPERCENT <*> tyvar
          <|> pBracks'
                (   (\t r -> Type_NormalApplication r (Type_Constructor r hsnDataList) [t])
                    <$> pType
                <|> pSucceed (\r -> Type_Constructor r hsnDataList)
                )
          <|> pParens' pInParens
          <|> pPacked' pOROWROW pCROWROW
                (    pExtFlds Type_RowEmpty Type_RowUpdate
                <|> (\fs r -> Type_RowUpdate r (Type_RowEmpty r) fs) <$> pFlds
                )
          <|> pPacked' pOROWSUM pCROWSUM
                (    pExtFlds Type_RowSumEmpty Type_RowSumUpdate
                <|> (\fs r -> Type_RowSumUpdate r (Type_RowSumEmpty r) fs) <$> pFlds
                )
          where pInParens :: HSParser (Range -> Type)
                pInParens
                  =   (pType
                       <**> (   pSucceed (flip Type_Parenthesized)
                            <|> (\es e r -> Type_RowRecUpdate r (Type_RowRecEmpty r)
                                              (map (RowTypeUpdate_Extends r Nothing) (e:es)))
                                <$>  pList1 (pComma *> pType)
                            <|> (\(o,_) e r -> Type_SectionApplication r (Just e) o Nothing)
                                <$> pTypeOpBaseEq
                      )     )
                  <|> (pTypeOpBaseEq
                       <**> (   (\e (o,_) r -> Type_SectionApplication r Nothing o (Just e)) <$> pType
                            -- <|> pSucceed (\(o,_) r -> Type_SectionApplication r Nothing o Nothing)
                      )     )
                  <|> flip Type_TupleConstructor <$> commas_arity
                  <|> pSucceed (\r -> Type_RowRecEmpty r)
                  <|> (\fs r -> Type_RowRecUpdate r (Type_RowRecEmpty r) fs) <$> pFlds
                  <|> pExtFlds Type_RowRecEmpty Type_RowRecUpdate
                pFld :: HSParser (Type -> RowTypeUpdate)
                pFld = qvarid
                       <**> (   (\l -> RowTypeUpdate_Extends (mkRange1 l) (Just (tokMkQName l))) <$ pDCOLON
                            )
                pFlds :: HSParser [RowTypeUpdate]
                pFlds = pList1Sep pComma (pFld <*> pType)
                pExtFlds :: (Range -> Type) -> (Range -> Type -> [RowTypeUpdate] -> Type) -> HSParser (Range -> Type)
                pExtFlds semEmp semFromRow
                     = (\e fs r -> semFromRow r e fs)
                       <$> (   mkRngNm Type_Variable <$> qvarid
                           <|> pSucceed (semEmp emptyRange)
                           )
                       <*  pVBAR <*> pFlds


































        pType' :: HSParser (Type,Range) -> (HSParser Type -> HSParser (Type,Int) -> HSParser (Type,Int)) -> HSParser Type
        pType' pOp extend
          = pT'
          where pT' :: HSParser Type
                pT' = mkT <$> pT
                pT :: HSParser (Type,Int)
                pT = extend pT'
                     $ pTypeApp
                        <**> (   pSucceed unit
                             <|> (\(op,rng) (r,cnt) l -> (Type_InfixApplication rng l op r,cnt+1)) <$> pOp <*> pT
                             )
                unit e    = (e,0)
                mkT (e,0) =  e
                mkT (e,_) =  Type_InfixApplicationChainTop emptyRange e







        pType ::  HSParser Type
        pType
          = pType'
              pTypeOp
              (\pT pTApp ->
                         pTApp
                     <|> (\c t -> unit $ Type_Qualified emptyRange [c] t) <$> pContextItemImpl <* pRARROW <*> pT
                     <|> unit <$> (pTypeQuantPrefix <*> pT)
              )
          where unit e    = (e,0)
{-
          = mkT <$> pT
          where pT :: HSParser (Type,Int)
                pT = pTypeApp
                      <**> (   pSucceed unit
                           <|> (\(op,rng) (r,cnt) l -> (Type_InfixApplication rng l op r,cnt+1)) <$> pTypeOp <*> pT
                           )
                     <|> (\c t -> unit $ Type_Qualified emptyRange [c] t) <$> pContextItemImpl <* pRARROW <*> pType
                     <|> unit <$> (pTypeQuantPrefix <*> pType)
                unit e    = (e,0)
                mkT (e,0) =  e
                mkT (e,_) =  Type_InfixApplicationChainTop emptyRange e
-}











        pTypeQuantPrefix :: HSParser (Type -> Type)
        pTypeQuantPrefix
          =  ((Type_Forall . mkRange1) <$> pFORALL <|> (Type_Exists . mkRange1) <$> pEXISTS)
             <*> (tokMkQNames <$> pTyVarBinds) <* pDOT



        pTypeOpPrefix :: HSParser (Type -> Type)
        pTypeOpPrefix
          =   (\l (op,rng) r -> Type_InfixApplication rng l op r) <$> pTypeApp <*> pTypeOp
          <|> (\c -> Type_Qualified emptyRange [c]) <$> pContextItemImpl <* pRARROW





        pTypeOp :: HSParser (Type,Range)
        pTypeOp
          =   pTypeOpBaseEq
          <|> mkRngNm' Type_Variable    <$> varop_no_ty
          <|> mkRngNm' Type_Constructor <$> pDARROW







        pTypeOpBase :: HSParser (Type,Range)
        pTypeOpBase
          = mkRngNm' Type_Constructor
            <$> (   gtycon_for_insection
                )



        pTypeOpBaseEq :: HSParser (Type,Range)
        pTypeOpBaseEq
          =   pTypeOpBase
          <|> mkRngNm' Type_Constructor <$> pTILDE









        pTypeApp :: HSParser Type
        pTypeApp
          =  pT <??> pA
          where pT = pTypeBase
                pA = (\es e -> Type_NormalApplication emptyRange e es) <$> pList1 pT



        pTyVarBind :: HSParser Token
        pTyVarBind =  tyvar

        pTyVarBinds :: HSParser [Token]
        pTyVarBinds =  pList1 pTyVarBind









        pTypeLeftHandSide :: HSParser TypeLeftHandSide
        pTypeLeftHandSide
          =   pLhs
          <|> (\c -> mkRngNm TypeLeftHandSide_Function c []) <$> gtycon' tyconsym
          <?> "pTypeLeftHandSide"
          where pLhs     :: HSParser TypeLeftHandSide
                pLhs     =   mkRngNm TypeLeftHandSide_Function <$> gtycon' tyconsym <*> pLhsTail
                         <|> pParens'
                               (   (\l r t -> TypeLeftHandSide_Parenthesized r l t)
                                   <$> pLhs
                               )
                             <*> pLhsTail
                         <|> (\l o r -> TypeLeftHandSide_Infix (mkRange1 o) l (tokMkQName o) r)
                             <$> pTypePatternBase <*> tyconop <*> pTypePatternBase
                pLhsTail ::  HSParser [TypePattern]
                pLhsTail =   pList1 pTypePatternBase



        pAnnotatedType :: HSParser Type -> HSParser Type
        pAnnotatedType pT
          =   (\(r,s) t -> if s
                           then Type_Annotate r TypeAnnotation_Strict t
                           else t
              )
              <$> ((\t -> (mkRange1 t,True)) <$> pBANG <|> pSucceed (emptyRange,False))
              <*> pT















        pContextItemsPrefix1 :: HSParser ContextItems
        pContextItemsPrefix1
          =   (:[]) <$> pContextItemImpl <* pRARROW

        pContextItemsPrefix2 :: HSParser ContextItems
        pContextItemsPrefix2
          =   (   (:[]) <$> (pContextItemBase <|> pContextItemImplWild)
              <|> pParens ((:) <$> pContextItemBase
                               <*> (   pImO
                                   <|> (++) <$> pList1 (pCOMMA *> pContextItemBase) <*> pImO
                                   )
                          <|> pSucceed []
                          )
              )
              <*  pDARROW
          where pImO  =  (:[]) <$ pCOMMA <*> pContextItemImplWild `opt` []
                pImO  :: HSParser ContextItems

        pContextItemsPrefix :: HSParser ContextItems
        pContextItemsPrefix
          =   pContextItemsPrefix1
          <|> pContextItemsPrefix2

        pContextItemsPrefixOpt :: HSParser ContextItems
        pContextItemsPrefixOpt = pContextItemsPrefix <|> pSucceed []

        pTypeContextPrefix :: HSParser (Type -> Type)
        pTypeContextPrefix
          = Type_Qualified emptyRange <$> pContextItemsPrefix







        pContextItemClass :: HSParser ContextItem
        pContextItemClass
          =    mkRngNm ContextItem_Class <$> qconid <*> pList1 pTypeBase



        pContextItemPrefix :: HSParser (ContextItem -> ContextItem)
        pContextItemPrefix
          =   (ContextItem_Forall . mkRange1) <$> pFORALL <*> (tokMkQNames <$> pTyVarBinds) <* pDOT



        pContextItem :: HSParser ContextItem
        pContextItem
          =   pContextItemBase
              <**> (   pSucceed id
                   <|> (\o r l -> ContextItem_Arrow (mkRange1 o) l r) <$> pDARROW <*> pContextItem
                   )
          <|> pContextItemPrefix <*> pContextItem







        pContextItemImplWild :: HSParser ContextItem
        pContextItemImplWild = (ContextItem_Implicits . mkRange1) <$> pTDOT



        pContextItemImpl :: HSParser ContextItem
        pContextItemImpl
          = pImpls'
              (    const <$> (pContextItem <|> pContextItemImplWild)
              <|>  pSucceed ContextItem_NoImplicits
              )



        pContextItemBase ::   HSParser ContextItem
        pContextItemBase
          =   pContextItemClass
          <|> tyvar <**>  (    (\s tv -> mkRngNm ContextItem_RowLacksLabel tv (tokMkQName s))
                               <$ pLAM <*> pSelector
                          )


















        pLiteralNumber :: HSParser Literal
        pLiteralNumber
          =   mk  8 <$> pInteger8Tk
          <|> mk 10 <$> pInteger10Tk
          <|> mk 16 <$> pInteger16Tk
          <?> "pLiteralNumber"
          where mk b t = Literal_Int (mkRange1 t) b (tokMkStr t)









        pLiteral :: HSParser Literal
        pLiteral
          =   pLiteralNumber
          <|> mkRngStr Literal_Char <$> pCharTk
          <|> mkRngStr Literal_String <$> pStringTk
          <|> mkRngStr Literal_Float  <$> pFractionTk
          <?> "pLiteral"











        pExpressionMinusPrefix :: HSParser (Expression -> Expression)
        pExpressionMinusPrefix
          =   (Expression_Negate . mkRange1) <$> pMINUS

        pExpressionMbMinusPrefix :: HSParser (Expression -> Expression)
        pExpressionMbMinusPrefix
          =   pExpressionMinusPrefix
          <|> pSucceed id

        pExpressionBase :: HSParser Expression
        pExpressionBase
          =   Expression_Literal emptyRange  <$> pLiteral
          <|> mkRngNm Expression_Variable    <$> qvar
          <|> pExpressionList
          <|> pParens' pInParens
          <?> "pExpressionBase"
          where pInParens :: HSParser (Range -> Expression)
                pInParens
        {-
                  =   (\(e,res) r ->
                         let mk res e
                               = case res of
                                   Expression3OpSection_None
                                     -> Expression_Parenthesized r e
                                   Expression3OpSection_Op (o,_)
                                     -> Expression_SectionApplication r (Just e) o Nothing
                                   Expression3OpSection_CommaList es
                                     -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                                                   (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es))
                                   Expression3OpSection_Typed (t,r)
                                     -> Expression_Typed r e t
                         in foldr mk e $ reverse res
                      )
                      <$> pExpression3OpSection pOp pExpressionPreBase
        -}
        {-
        -}
                  =   (\(e,_,res) r ->
                         let chk ress e
                               = case ress of
                                   (Expression4Result_Op (o,_) : _)
                                     -> Expression_SectionApplication r (Just e) o Nothing
                                   (Expression4Result_CommaList es : _)
                                     -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                                                   (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es))
                                   _ -> Expression_Parenthesized r e
                         in chk res e
                      )
                      <$> pExpression4'' True pOp pExpressionPrefix pExpressionLayout
        {-
                  =   (pExpression <**>
                            (   (\(o,_) e r -> Expression_SectionApplication r (Just e) o Nothing)
                                <$> pOp
                            <|> pSucceed (flip Expression_Parenthesized)
                            <|> (\es e r -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r)
                                              (map (RowRecordExpressionUpdate_Extends r Nothing) (e:es)))
                                <$> pList1 (pComma *> pExpression)
                      )     )
        -}
                  <|> flip Expression_TupleConstructor <$> commas_arity
                  <|> (pOpm
                       <**> (   (\e (o,_) r -> Expression_SectionApplication r Nothing o (Just e)) <$> pExpression
                            -- <|> pSucceed (\(o,_) r -> Expression_SectionApplication r Nothing o Nothing)
                      )     )
                  <|> pSucceed (\r -> Expression_RowRecordEmpty r)
                  <|> (\fs r -> Expression_RowRecordUpdate r (Expression_RowRecordEmpty r) fs) <$> pFlds
                  <|> pExtFlds
                  where pFld :: HSParser (Expression -> RowRecordExpressionUpdate)
                        pFld = qvarid
                               <**> (   (\l -> RowRecordExpressionUpdate_Extends (mkRange1 l) (Just (tokMkQName l))) <$ pEQUAL
                                    <|> mkRngNm RowRecordExpressionUpdate_Update <$ pCOLEQUAL
                                    )
                        pFlds :: HSParser [RowRecordExpressionUpdate]
                        pFlds = pList1Sep pComma (pFld <*> pExpression)
                        pExtFlds :: HSParser (Range -> Expression)
                        pExtFlds
                             = (\e fs r -> Expression_RowRecordUpdate r e fs)
                               <$> (   pParens' pExtFlds
                                   <|> mkRngNm Expression_Variable <$> qvarid
                                   <|> pSucceed (Expression_RowRecordEmpty emptyRange)
                                   )
                               <*  pVBAR <*> pFlds






















        pExpressionList :: HSParser Expression
        pExpressionList
          = pBracks'
              (pExpression
               <**> (   pDOTDOT
                        *> (     (\e3 e1 r -> Expression_Enum r e1 Nothing (Just e3)) <$> pExpression
                           `opt` (\   e1 r -> Expression_Enum r e1 Nothing  Nothing )
                           )
                    <|> pCOMMA
                        *> (pExpression
                            <**> (   pDOTDOT
                                     *> (     (\e3 e2 e1 r -> Expression_Enum r e1 (Just e2) (Just e3)) <$> pExpression
                                        `opt` (\   e2 e1 r -> Expression_Enum r e1 (Just e2)  Nothing )
                                        )
                                 <|> (\es e2 e1 r -> Expression_List r (e1:e2:es)) <$> pList (pComma *> pExpression)
                           )     )
                    <|> pVBAR
                        *> ((\c e r -> Expression_Comprehension r e (c ++ [Qualifier_Empty emptyRange])) <$> pListSep pCOMMA pQualifier)
                    `opt` flip one
                    )
              `opt` zero
              )
          <?> "pExpressionList"
          where zero r   = Expression_List r []
                one  r h = Expression_List r [h]
                pQualifier :: HSParser Qualifier
                pQualifier
                  =   Qualifier_Guard emptyRange <$> pExpressionNoLet
                  <|> (Qualifier_Let . mkRange1) <$> pLET <*> pDeclarations
                  <|> Qualifier_Generator emptyRange <$> pPattern <* pLARROW <*> pExpression










        pExpressionDo :: HSParser Expression
        pExpressionDo
          =   (Expression_Do . mkRange1) <$> pDO <*> pBlock1 pOCURLY pSEMI pCCURLY pStatement
          <?> "pExpressionDo"
          where pStatement :: HSParser Statement
                pStatement
                  =   Statement_Expression emptyRange <$> pExpression {- pExpressionNoLet -}
                  <|> (\p t e -> Statement_Generator (mkRange1 t) p e) <$> pPattern <*> pLARROW <*> pExpression
                      -- common prefix with 'let x=e in e' dies out
                  <|> (Statement_Let . mkRange1) <$> pLET <*> pDeclarations






































        pExpressionConUpd :: HSParser Expression
        pExpressionConUpd
          =   qcon
              <**> (   pSucceed (mkRngNm Expression_Constructor)
                   <|> pCurlys' ((\bs _ c -> mkRngNm Expression_RecordConstruction c bs) <$> pListSep pCOMMA pRecordExpressionBinding)
                   )
          <|> pExpressionBase
              <**> ((\u e -> foldr ($) e u) <$> pList pU)
          <?> "pExpressionConUpd"
          where pU =   pCurlys' ((\bs r e -> Expression_RecordUpdate r e bs) <$> pList1Sep pCOMMA pRecordExpressionBinding)
                   <|> pRowRecordSelectionSuffix









        pRecordExpressionBinding :: HSParser RecordExpressionBinding
        pRecordExpressionBinding
          =   mkRngNm RecordExpressionBinding_Binding <$> qvar <* pEQUAL <*> pExpression
          <?> "pRecordExpressionBinding"



        pExpressionApp :: HSParser Expression
        pExpressionApp
          =   pE <**> ((\as e -> foldl (flip ($)) e as) <$> pList pA)
          <?> "pExpressionApp"
          where pE =   pExpressionConUpd
                pA =   (\es e -> Expression_NormalApplication emptyRange e es) <$> pList1 pE
                   <|> (\es e -> Expression_ImpredicativeApplication emptyRange e es) <$> pList1 (pTILDE *> pE)
                   <|> (\es e -> Expression_ImplicitApplication emptyRange e es) <$> pList1 (pImpls' pContextedExpression)
                   where pContextedExpression = (\e c r -> ContextedExpression_Contexted r e c) <$> pExpression <* pLTCOLON <*> pContextItem
                         pContextedExpression :: HSParser (Range -> ContextedExpression)







        pExpressionLayout :: HSParser Expression
        pExpressionLayout
          =   pMaybe id id pExpressionMinusPrefix <*> pExpressionApp
          <|> (Expression_Case . mkRange1) <$> pCASE <*> pExpression <* pOptSEMISeparator <* pOF <*> pAlternatives
          <|> pExpressionDo
          <?> "pExpressionLayout"







        pOp, pOpm :: HSParser (Expression,Range)
        pOp  = mkRngNm' Expression_Variable <$> qvarop          <|> mkRngNm' Expression_Constructor <$> qconop
        pOpm = mkRngNm' Expression_Variable <$> qvarop_no_minus <|> mkRngNm' Expression_Constructor <$> qconop



        pExpression4'' :: Bool -> HSParser (Expression,Range) -> HSParser (Expression -> Expression) -> HSParser Expression -> HSParser Expression4
        pExpression4'' inParen pOp pPreNotOp pBase
          =   ((\(e,cnt,res) -> (mkC cnt e,0,res)) <$> pE)
              <**> (addCommaP $ addOpP
                    $ (   (addCommaP2
                           $ ((\c t (e,cnt,res) -> (Expression_Typed (mkRange1 c) (mkC cnt e) t, 0, Expression4Result_Typed : res))
                              <$> pDCOLON <*> pType
                          )  )
                      <|> pSucceed id
                   )  )
          where pE  ::  HSParser Expression4
                pE  =   pBase <**>
                          (   pSucceed (\e -> (e,0,[]))
                          <|> (\(op,rng) (r,opCnt,res) l -> (Expression_InfixApplication rng l op r, opCnt+1, res)) <$> pOp <*> pE
                          )
                    <|> (\p (e,cnt,res) -> (p $ mkC cnt $ e, 0, Expression4Result_NotOpPre : res))
                        <$> pPreNotOp <*> pE

                -- add trailing parsers, depending on being inside parenthesis
                addCommaP, addCommaP2, addOpP :: HSParser (Expression4 -> Expression4) -> HSParser (Expression4 -> Expression4)

                -- optionally add tuple expr remainder as choice
                addCommaP  p | inParen   = p <|> (\es (e,cnt,res) -> (mkC cnt e, 0, Expression4Result_CommaList es : res))
                                                 <$> pList1 (pComma *> pExpression)
                             | otherwise = p

                -- optionally add tuple expr remainder as following in a sequence
                addCommaP2 p | inParen   = (\mkecntres es ecntres ->
                                              let (e,cnt,res) = mkecntres ecntres
                                              in  (mkC cnt e, 0, (if null es then [] else [Expression4Result_CommaList es]) ++ res)
                                           )
                                           <$> p <*> pList (pComma *> pExpression)
                             | otherwise = p

                -- optionally add operator as choice
                addOpP     p | inParen   = p <|> (\o (e,cnt,res) -> (mkC cnt e, 0, Expression4Result_Op o : res))
                                                 <$> pOp
                             | otherwise = p

                -- add additional AST depending on nr of operators
                mkC cnt = if cnt > 0 then Expression_InfixApplicationChainTop emptyRange else id

        pExpression4' :: HSParser (Expression -> Expression) -> HSParser Expression
        pExpression4' pPreNotOp = (\(e,_,_) -> e) <$> pExpression4'' False pOp pPreNotOp pExpressionLayout



        pExpressionPreBase :: HSParser Expression
        pExpressionPreBase = (\ps e -> foldr ($) e ps) <$> pList_gr pExpressionPrefix <*> pExpressionLayout

        pExpression :: HSParser Expression
        pExpression
          -- =   pExpression1' pExpressionPrefix
          -- =   pExpression2' pExpressionPrefix
          -- = pExpression3' pExpressionPreBase
          = pExpression4' pExpressionPrefix
            <?> "pExpression"



        pExpressionNoLet :: HSParser Expression
        pExpressionNoLet
          -- =   pExpression' pExpressionNoLetPrefix
          -- =   pExpression2' pExpressionNoLetPrefix
          -- = pExpression3' pBase3
          =   pExpression4' pExpressionNoLetPrefix
            <?> "pExpressionNoLet"
          where pBase3 :: HSParser Expression
                pBase3 = (\ps e -> foldr ($) e ps) <$> pList pExpressionNoLetPrefix <*> pExpressionLayout



        pExpressionLetPrefix :: HSParser (Expression -> Expression)
        pExpressionLetPrefix
          =   (\(s,t,d) -> Expression_Let (mkRange1 t) s d)
              <$> (   (,,) False <$> pLET       <*> pDeclarations                       <* pIN
                  <|> (,,) True  <$> pLETSTRICT <*> pLayoutList pDeclarationSimpleValue <* pIN
                  )
          <?> "pExpressionLetPrefix"









        pExpressionNoLetPrefix :: HSParser (Expression -> Expression)
        pExpressionNoLetPrefix
          =   pLAM <**> pLamArgs
          <|> (Expression_If . mkRange1) <$> pIF <*> pExpression <* pOptSEMISeparator <* pTHEN <*> pExpression <* pOptSEMISeparator <* pELSE
          -- <|> pExpressionMinusPrefix
          <?> "pExpressionNoLetPrefix"
          where pLamArgs
                  =   (\a1 a2 t e -> a1 t (a2 t e))
                      <$> (   (\ps t e -> Expression_Lambda (mkRange1 t) ps e) <$> pList1 pPatternBaseCon
                          <|> (\ps t e -> Expression_ImplicitLambda (mkRange1 t) ps e) <$> pList1 (pImpls' pContextedPattern)
                          )
                      <*> pLamArgs
                  <|> (\_ e -> e) <$ pRARROW
                pContextedPattern = (\p c r -> ContextedPattern_Contexted r p c) <$> pPattern <* pLTCOLON <*> pContextItem
                pContextedPattern :: HSParser (Range -> ContextedPattern)









        pExpressionPrefix :: HSParser (Expression -> Expression)
        pExpressionPrefix
          =   pExpressionLetPrefix
          <|> pExpressionNoLetPrefix
          <?> "pExpressionPrefix"







        pAlternative :: HSParser Alternative
        pAlternative
          = Alternative_Alternative emptyRange <$> pPattern <*> pRhs pRARROW

        pAlternatives :: HSParser Alternatives
        pAlternatives
          = pBlock1 pOCURLY pSEMI pCCURLY pAlternative







        pPatternBaseInParens :: HSParser (Range -> Pattern)
        pPatternBaseInParens
          =   (pPattern
               <**> (   pSucceed (flip Pattern_Parenthesized)
                    <|> (\es e r -> Pattern_RowRecordBinding r (Pattern_RowRecordEmpty r)
                                      (map (RowRecordPatternBinding_Binding r Nothing) (e:es)))
                        <$>  pList1 (pComma *> pPattern)
              )     )
          <|> (\v _ -> mkRngNm Pattern_Variable v) <$> qvarsym_for_inparens
          <|> pSucceed (\r -> Pattern_RowRecordEmpty r)
          <|> (\fs r -> Pattern_RowRecordBinding r (Pattern_RowRecordEmpty r) fs) <$> pFlds
          <|> pExtFlds
          <?> "pPatternBaseInParens"
          where pFld :: HSParser (Pattern -> RowRecordPatternBinding)
                pFld = qvarid
                       <**> (   (\l -> RowRecordPatternBinding_Binding (mkRange1 l) (Just (tokMkQName l))) <$ pEQUAL
                            )
                pFlds :: HSParser [RowRecordPatternBinding]
                pFlds = pList1Sep pComma (pFld <*> pPattern)
                pExtFlds :: HSParser (Range -> Pattern)
                pExtFlds
                     = (\e fs r -> Pattern_RowRecordBinding r e fs)
                       <$> (   mkRngNm Pattern_Variable <$> qvar
                           <|> pSucceed (Pattern_RowRecordEmpty emptyRange)
                           )
                       <*  pVBAR <*> pFlds












        pPatternBaseMinusLiteral :: HSParser Pattern
        pPatternBaseMinusLiteral = (\m n -> Pattern_Literal (mkRange1 m) (-1) n) <$> pMINUS <*> pLiteralNumber



        pPatternBaseNoParens :: HSParser Pattern
        pPatternBaseNoParens
          = (
              (if ehcOptBangPatterns opts
               then (\p -> p <|> (Pattern_Bang . mkRange1) <$> pBANG  <*> pPatternBaseCon)
               else id
              ) $
              (   qvarid
                  <**> (   (\a p v -> Pattern_As (mkRange1 a) (tokMkQName v) p) <$> pAT <*> pPatternBaseCon
                       <|> pSucceed (mkRngNm Pattern_Variable)
                       )
              <|> Pattern_Literal emptyRange 1 <$> pLiteral
              <|> pBracks' (flip Pattern_List <$> pListSep pCOMMA pPattern)
              <|> (Pattern_Irrefutable . mkRange1) <$> pTILDE <*> pPatternBaseCon
            ) )
          <?> "pPatternBaseNoParens"










        pPatternBase :: HSParser Pattern
        pPatternBase
          =   pPatternBaseNoParens
          <|> pParens' pPatternBaseInParens
          <?> "pPatternBase"



        pPatternConSuffix :: HSParser (Token -> Pattern)
        pPatternConSuffix
          =   pSucceed (\c -> mkRngNm Pattern_Constructor c [])
          <|> pCurlys' ((\bs _ c -> mkRngNm Pattern_Record c bs) <$> pListSep pCOMMA pRecordPatternBinding)
          <?> "pPatternConSuffix"





        pPatternBaseCon :: HSParser Pattern
        pPatternBaseCon
          =   pPatternBase
          <|> qconid <**> pPatternConSuffix
          <?> "pPatternBaseCon"



        pRecordPatternBinding :: HSParser RecordPatternBinding
        pRecordPatternBinding
          =   qvar
              <**> (   pSucceed (\v -> mkRngNm RecordPatternBinding_Pun v)
                   <|> (\p v -> mkRngNm RecordPatternBinding_Binding v p) <$ pEQUAL <*> pPattern
                   )
          <?> "pRecordPatternBinding"



        pPatternApp :: HSParser Pattern
        pPatternApp
          =   pPatternBase
          <|> pPatternBaseMinusLiteral
          <|> qcon
              <**> (   (\l c -> mkRngNm Pattern_Constructor c l) <$> pList1 pPatternBaseCon
                   <|> pPatternConSuffix
                   )
          <|> (Pattern_Tuple emptyRange) <$> pParens commas_arity <*> pList1 pPatternBaseCon
          <?> "pPatternApp"





        pPatternOp :: HSParser Pattern
        pPatternOp
          -- =   (\l rs -> foldr (\(o,r) mk -> \l -> o l (mk r)) id rs l) <$> pPatternApp <*> pList_ng (pOp <+> pPatternApp)
          = pChainr_ng pOp pPatternApp
          <?> "pPatternOp"
          where pOp =
                    ((\o l r -> Pattern_InfixConstructor (mkRange1 o) l (tokMkQName o) r) <$> qconop)







        pPattern :: HSParser Pattern
        pPattern
          =   pPatternOp
              <??> ((\c t p -> Pattern_Typed (mkRange1 c) p t) <$> pDCOLON <*> pType)
          <?> "pPattern"





        pRowRecordSelectionSuffix :: HSParser (Expression -> Expression)
        pRowRecordSelectionSuffix
          = (\lbls e -> foldl (\e l -> Expression_RowRecordSelect (mkRange1 l) e (tokMkQName l)) e lbls)
            <$> pList1 (pHASH *> pSelector)



        pSelector :: HSParser Token
        pSelector
          =   qvarid <|> qconid <|> pIntegerTk







        pTypePatternBase :: HSParser TypePattern
        pTypePatternBase
          =   mkRngNm TypePattern_Variable <$> var_no_ty
          <?> "pTypePatternBase"


















commas' :: HSParser [Token]
commas' = pList1 pCOMMA

commas :: HSParser Token
commas =  (map (\s -> strProd (length s + 1)) . foldr tokConcat tokEmpty) <$> commas'
  where map = tokenMap







commas_arity :: HSParser Int
commas_arity =  (\ts -> length ts + 1) <$> commas'





pOptSEMISeparator :: HSParser (Maybe ())
pOptSEMISeparator = pMb (pSeparator <|> () <$ pSEMI)



modid :: HSParser Token
modid
  =   pCONID
  <|> pQCONID
  <?> "modid"





qcnames :: HSParser [Token]
qcnames
  =   pListSep pCOMMA qcname
  <?> "qcnames"

qcname  :: HSParser Token   -- Variable or data constructor
qcname
  =   qvar
  <|> gcon
  <?> "qcname"



identifier :: HSParser Token
identifier
  =   qvar
  <|> gcon
  <|> qop
  <?> "identifier"

depreclist :: HSParser [Token]
depreclist
  = pList1Sep pCOMMA deprec_var

deprec_var :: HSParser Token
deprec_var
  =   var
  <|> tyconid
  <?> "deprec_var"

gcon    :: HSParser Token   -- Data constructor namespace
gcon
  =   sysdcon
  <|> qcon
-- the case of '[:' ':]' is part of the production `parr'
  <?> "gcon"

sysdcon :: HSParser Token   -- Wired in data constructors
sysdcon
  =   pParens commas
  <|> tokConcat <$> pOBRACK <*> pCBRACK
  <?> "sysdcon"










qcon    :: HSParser Token
qcon
  =   qconid
  <|> pParens qconsym
  <?> "qcon"



conop :: HSParser Token
conop
  =   consym
  <|> pBACKQUOTE *> conid <* pBACKQUOTE
  <?> "conop"

qconop :: HSParser Token
qconop
  =   qconsym
  <|> pBACKQUOTE *> qconid <* pBACKQUOTE
  <?> "qconop"








qconid :: HSParser Token    -- Qualified or unqualifiedb
qconid
  =   conid
  <|> pQCONID
  <?> "qconid"





conid_nopragma   :: HSParser Token
conid_nopragma
  =   pCONID
  <?> "conid_nopragma"

conid   :: HSParser Token
conid
  =   conid_nopragma
  <|> pLANGUAGE_prag
  <|> pDERIVABLE_prag
  <?> "conid"

qconsym :: HSParser Token   -- Qualified or unqualified
qconsym
  =   consym
  <|> pQCONSYM
  <?> "qconsym"







consym :: HSParser Token
consym
  =   pCONSYM
  <|> pCOLON -- ':' means only list cons
  <?> "consym"



con :: HSParser Token
con
  =   conid
  <|> pParens consym
  <?> "con"



-----------------------------------------------------------------------------
-- Any operator

op  :: HSParser Token   -- used in infix decls
op
  =   varop
  <|> conop
  <?> "op"

qop :: HSParser Token   -- used in sections
qop
  =   qvarop
  <|> qconop
  <?> "qop"























tyvar   :: HSParser Token
tyvar
  =   varid_no_ty
  <?> "tyvar"







-- | special identifier: FFI safety
safety :: HSParser Token
safety
  =   pSAFE
  <|> pUNSAFE
  <|> pTHREADSAFE
  <?> "safety"





-- | special identifier: FFI calling convention
callconv :: HSParser Token
callconv
  =   snd <$> pFFIWay
  <?> "callconv"



-- These special_ids are treated as keywords in various places,
-- but as ordinary ids elsewhere.   'special_id' collects all these
-- except 'unsafe' and 'forall' whose treatment differs depending on context
-- | special identifier: some context sensitive meaningful
special_id_no_callconv :: HSParser Token
special_id_no_callconv
  =   pLABEL
  <|> pEXPORT
  <|> pAS
  <|> pQUALIFIED
  <|> pHIDING
  <|> pDYNAMIC
  <?> "special_id_no_callconv"







special_id :: HSParser Token
special_id
  =   special_id_no_callconv
  <|> callconv
  <?> "special_id"



-- | Unqualified value/function, e.g.: f, except type related keywords
varid_no_ty :: HSParser Token
varid_no_ty
  =   pVARID
  <|> special_id_no_callconv
  <|> callconv
  <|> safety
  <?> "varid_no_ty"








-- | Unqualified value/function, e.g.: f
varid :: HSParser Token
varid
  =   varid_no_ty
  <|> pFORALL
  <|> pEXISTS
  <?> "varid"





-- | (Un)qualified value/function, e.g.: X.f
qvarid :: HSParser Token
qvarid
  =   varid
  <|> pQVARID
  <?> "qvarid"





-- | See comments with special_id
special_sym_no_bang :: HSParser Token
special_sym_no_bang
  =   pDOT
  <|> pSTAR
  <|> pPERCENT
  <?> "special_sym_no_bang"

special_sym :: HSParser Token
special_sym
  =   pBANG
  <|> special_sym_no_bang
  <?> "special_sym"



-- | Unqualified operator, e.g.: +, except -, !
varsym_no_minus_bang :: HSParser Token
varsym_no_minus_bang
  =   pVARSYM
  <|> special_sym_no_bang
  <?> "varsym_no_minus_bang"

varsym_no_minus :: HSParser Token
varsym_no_minus
  =   pVARSYM
  <|> special_sym
  <?> "varsym_no_minus"



-- | Unqualified operator, e.g.: +
varsym :: HSParser Token
varsym
  =   varsym_no_minus
  <|> pMINUS
  <?> "varsym"



-- | Qualified operator, e.g.: X.+, only base
qvarsym_base :: HSParser Token
qvarsym_base
  =   pQVARSYM
  <?> "qvarsym1"



-- | (Un)qualified operator, e.g.: X.+, except -
qvarsym_no_minus :: HSParser Token
qvarsym_no_minus
  =   varsym_no_minus
  <|> qvarsym_base
  <?> "qvarsym_no_minus"





-- | (Un)qualified operator, e.g.: X.+, for use inside parens
qvarsym_for_inparens :: HSParser Token
qvarsym_for_inparens
  =   varsym
  <|> qvarsym_base
  <?> "qvarsym_for_inparens"





-- | (Un)qualified operator, e.g.: X.+
qvarsym :: HSParser Token
qvarsym
  =   qvarsym_for_inparens
  <?> "qvarsym"



-- | (Un)qualified operator, e.g.: +, `f`, except -, !
varop_no_minus_bang   :: HSParser Token
varop_no_minus_bang
  =   varsym_no_minus_bang
  <|> pBACKQUOTE *> varid <* pBACKQUOTE
  <?> "varop_no_minus_bang"

-- | (Un)qualified operator, e.g.: +, `f`, except -
varop_no_minus   :: HSParser Token
varop_no_minus
  =   varsym_no_minus
  <|> pBACKQUOTE *> varid <* pBACKQUOTE
  <?> "varop_no_minus"



-- | (Un)qualified operator, e.g.: +, `f`, except type related keywords
varop_no_ty   :: HSParser Token
varop_no_ty
  =   varsym
  <|> pBACKQUOTE *> varid_no_ty <* pBACKQUOTE
  <?> "varop_no_minus"



-- | (Un)qualified operator, e.g.: +, `f`, except !
varop_no_bang   :: HSParser Token
varop_no_bang
  =   varop_no_minus_bang
  <|> pMINUS
  <?> "varop_no_bang"

-- | (Un)qualified operator, e.g.: +, `f`
varop   :: HSParser Token
varop
  =   varop_no_minus
  <|> pMINUS
  <?> "varop"



-- | (Un)qualified operator, e.g.: X.+, `X.f`, except -
qvarop_no_minus :: HSParser Token
qvarop_no_minus
  =   qvarsym_no_minus
  <|> pBACKQUOTE *> qvarid <* pBACKQUOTE
  <?> "qvarop_no_minus"



-- | (Un)qualified operator, e.g.: X.+, `X.f`
qvarop :: HSParser Token
qvarop
  =   qvarsym
  <|> pBACKQUOTE *> qvarid <* pBACKQUOTE
  <?> "qvarop"



-- | Unqualified value/function, e.g.: f, (+), except type related keywords
var_no_ty     :: HSParser Token
var_no_ty
  =   varid_no_ty
  <|> pParens varsym
  <?> "var"



-- | Unqualified value/function, e.g.: f, (+)
var     :: HSParser Token
var
  =   varid
  <|> pParens varsym
  <?> "var"



-- | (Un)qualified value/function, e.g.: X.f, (X.+)
qvar    :: HSParser Token
qvar
  =   qvarid
  <|> pParens qvarsym_for_inparens
  <?> "qvar"











-- | Unqualified type constructor, e.g.: :+:
tyconsym :: HSParser Token
tyconsym
  =   pCONSYM
  <?> "tyconsym"



-- | (Un)qualified type constructor, e.g.: X.:+:
qtyconsym :: HSParser Token
qtyconsym
  =   tyconsym
  <|> pQCONSYM
  <?> "qtyconsym"





-- | Unqualified type constructor, e.g.: Either
tyconid   :: HSParser Token
tyconid
  =   pCONID
  <?> "tyconid"






-- | (Un)qualified type constructor, e.g.: X.Either
qtyconid :: HSParser Token
qtyconid
  =   tyconid
  <|> pQCONID
  <?> "qtyconid"





-- | Unqualified infix type operator, e.g.: `Either`, :+:
tyconop :: HSParser Token   -- Unqualified
tyconop
  =   tyconsym
  <|> pBACKQUOTE *> tyconid <* pBACKQUOTE
  <?> "tyconop"



-- | (Un)qualified infix type operator, e.g.: `X.Either`, X.:+:
qtyconop :: HSParser Token
qtyconop
  =   qtyconsym
  <|> pBACKQUOTE *> qtyconid <* pBACKQUOTE
  <?> "qtyconop"



-- | (Un)qualified prefix type constructor, e.g.: X.Either, (X.:+:)
qtycon :: HSParser Token
qtycon
  =   qtyconid
  <|> pParens qtyconsym
  <?> "qtycon"



-- | General (un)qualified prefix type constructor, no delimiting brackets (e.g. []), to be parameterized with the part inside parenthesis (the general part)
gtycon_no_delims' :: HSParser Token -> HSParser Token
gtycon_no_delims' pInParens
  =   qtyconid
  <|> pParens pInParens
  <?> "gtycon_no_delims"



-- | Inside parenthesis part for gtycon
gtycon_for_inparens_arrow :: HSParser Token
gtycon_for_inparens_arrow
  =   pRARROW
  <|> qtyconsym
  <?> "gtycon_for_inparens_arrow"

-- | Inside parenthesis part for gtycon
gtycon_for_inparens_arrow_commas :: HSParser Token
gtycon_for_inparens_arrow_commas
  =   gtycon_for_inparens_arrow
  <|> commas
  <?> "gtycon_for_inparens_arrow"

-- | Inside parenthesis part for type sections
gtycon_for_insection :: HSParser Token
gtycon_for_insection
  =   pRARROW
  <|> qtyconop
  <?> "gtycon_for_insection"





-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (->)
gtycon_no_delims_commas :: HSParser Token
gtycon_no_delims_commas
  =   gtycon_no_delims' gtycon_for_inparens_arrow
  <?> "gtycon_no_delims_commas"



-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (,,,), (->)
gtycon_no_delims :: HSParser Token   -- A "general" qualified tycon
gtycon_no_delims
  =   gtycon_no_delims' gtycon_for_inparens_arrow_commas
  <?> "gtycon_no_delims"



gtycon_only_bracks :: HSParser Token   -- A "general" qualified tycon
gtycon_only_bracks
  =   tokConcat <$> pOBRACK <*> pCBRACK
  -- <|> tokConcat <$> pOPABRACK <*> pCPABRACK
  <?> "gtycon_only_delims"



-- | General (un)qualified prefix type constructor, including delimiting brackets, to be parameterized with the part inside parenthesis (the general part)
gtycon' :: HSParser Token -> HSParser Token
gtycon' pInParens
  =   gtycon_no_delims' pInParens
  <|> gtycon_only_bracks
  <?> "gtycon'"





-- | General (un)qualified prefix type constructor, e.g.: X.Either, (X.:+:), and (,,,), (->), []
gtycon :: HSParser Token   -- A "general" qualified tycon
gtycon
  =   gtycon' gtycon_for_inparens_arrow_commas
  <?> "gtycon"


</pre>