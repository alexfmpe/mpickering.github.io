<a href="Dates.hs12648177091998097157.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Datum.hs571540977194847408.out.html">next</a></br></br><pre>61c61
< weekdayToInterval ∷ WeekDay → DateInterval
---
> weekdayToInterval :: WeekDay -> DateInterval
65c65
< weekdayNumber ∷ WeekDay → Int
---
> weekdayNumber :: WeekDay -> Int
69c69
< intToWeekday ∷ Int → WeekDay
---
> intToWeekday :: Int -> WeekDay
72c72
< lastMonday ∷ DateTime → DateTime
---
> lastMonday :: DateTime -> DateTime
75c75
< nextMonday ∷ DateTime → DateTime
---
> nextMonday :: DateTime -> DateTime
79c79
< getCurrentDateTime ∷  IO DateTime
---
> getCurrentDateTime ::  IO DateTime
81c81
<   zt ← getZonedTime
---
>   zt <- getZonedTime
92c92
< dateWeekDay ∷ DateTime → WeekDay
---
> dateWeekDay :: DateTime -> WeekDay
97c97
< uppercase ∷ String → String
---
> uppercase :: String -> String
100c100
< isPrefixOfI ∷  String → String → Bool
---
> isPrefixOfI ::  String -> String -> Bool
103c103
< lookupS ∷ String → [(String,a)] → Maybe a
---
> lookupS :: String -> [(String,a)] -> Maybe a
108c108
< monthsN ∷ [(String,Int)]
---
> monthsN :: [(String,Int)]
111c111
< lookupMonth ∷ String → Maybe Int
---
> lookupMonth :: String -> Maybe Int
114c114
< date ∷  Int → Int → Int → DateTime
---
> date ::  Int -> Int -> Int -> DateTime
117c117
< addTime ∷  DateTime → Time → DateTime
---
> addTime ::  DateTime -> Time -> DateTime
123c123
< euroNumDate ∷ Stream s m Char => ParsecT s st m DateTime
---
> euroNumDate :: Stream s m Char => ParsecT s st m DateTime
125c125
<   d ← pDay
---
>   d <- pDay
127c127
<   m ← pMonth
---
>   m <- pMonth
129c129
<   y ← pYear
---
>   y <- pYear
132c132
< americanDate ∷ Stream s m Char => ParsecT s st m DateTime
---
> americanDate :: Stream s m Char => ParsecT s st m DateTime
134c134
<   y ← pYear
---
>   y <- pYear
136c136
<   m ← pMonth
---
>   m <- pMonth
138c138
<   d ← pDay
---
>   d <- pDay
141c141
< euroNumDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
---
> euroNumDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
143c143
<   d ← pDay
---
>   d <- pDay
145c145
<   m ← pMonth
---
>   m <- pMonth
148c148
< americanDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
---
> americanDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
150c150
<   m ← pMonth
---
>   m <- pMonth
152c152
<   d ← pDay
---
>   d <- pDay
155c155
< strDate ∷ Stream s m Char => ParsecT s st m DateTime
---
> strDate :: Stream s m Char => ParsecT s st m DateTime
157c157
<   d ← pDay
---
>   d <- pDay
159c159
<   ms ← many1 letter
---
>   ms <- many1 letter
161d160
<     Nothing → fail $ "unknown month: "++ms
162c161
<     Just m  → do
---
>     Nothing -> fail $ "unknown month: "++ms
162a162
>     Just m  -> do
164c164
<       y ← pYear
---
>       y <- pYear
168c168
< strDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
---
> strDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
170c170
<   d ← pDay
---
>   d <- pDay
172c172
<   ms ← many1 letter
---
>   ms <- many1 letter
174d173
<     Nothing → fail $ "unknown month: "++ms
175c174
<     Just m  → return $ date year m d
---
>     Nothing -> fail $ "unknown month: "++ms
175a175
>     Just m  -> return $ date year m d
177c177
< time24 ∷ Stream s m Char => ParsecT s st m Time
---
> time24 :: Stream s m Char => ParsecT s st m Time
179c179
<   h ← number 2 23
---
>   h <- number 2 23
181d180
<   m ← number 2 59
182c181
<   x ← optionMaybe $ char ':'
---
>   m <- number 2 59
182a182
>   x <- optionMaybe $ char ':'
184d183
<     Nothing → return $ Time h m 0
185d183
<     Just _ → do
186c184
<       s ← number 2 59
---
>     Nothing -> return $ Time h m 0
186a185
>     Just _ -> do
186a186
>       s <- number 2 59
190c190
< ampm ∷ Stream s m Char => ParsecT s st m Int
---
> ampm :: Stream s m Char => ParsecT s st m Int
192c192
<   s ← many1 letter
---
>   s <- many1 letter
194d193
<     "AM" → return 0
195d193
<     "PM" → return 12
196c194
<     _ → fail "AM/PM expected"
---
>     "AM" -> return 0
196a195
>     "PM" -> return 12
196a196
>     _ -> fail "AM/PM expected"
198c198
< time12 ∷ Stream s m Char => ParsecT s st m Time
---
> time12 :: Stream s m Char => ParsecT s st m Time
200c200
<   h ← number 2 12
---
>   h <- number 2 12
202d201
<   m ← number 2 59
203d201
<   x ← optionMaybe $ char ':'
204d201
<   s ← case x of
205d201
<             Nothing → return 0
206c202
<             Just _  → number 2 59
---
>   m <- number 2 59
206a203
>   x <- optionMaybe $ char ':'
206a204
>   s <- case x of
206a205
>             Nothing -> return 0
206a206
>             Just _  -> number 2 59
208c208
<   hd ← ampm
---
>   hd <- ampm
211c211
< pTime ∷ Stream s m Char => ParsecT s st m Time
---
> pTime :: Stream s m Char => ParsecT s st m Time
214c214
< pAbsDateTime ∷ Stream s m Char => Int → ParsecT s st m DateTime
---
> pAbsDateTime :: Stream s m Char => Int -> ParsecT s st m DateTime
216c216
<   date ← choice $ map try $ map ($ year) $ [
---
>   date <- choice $ map try $ map ($ year) $ [
224c224
<   s ← optionMaybe space
---
>   s <- optionMaybe space
226d225
<     Nothing → return date
227d225
<     Just _ → do
228c226
<       t ← pTime
---
>     Nothing -> return date
228a227
>     Just _ -> do
228a228
>       t <- pTime
231c231
< pAbsDate ∷ Stream s m Char => Int → ParsecT s st m DateTime
---
> pAbsDate :: Stream s m Char => Int -> ParsecT s st m DateTime
242c242
< dateTimeToDay ∷  DateTime → Day
---
> dateTimeToDay ::  DateTime -> Day
246c246
< dayToDateTime ∷  Day → DateTime
---
> dayToDateTime ::  Day -> DateTime
252c252
< modifyDate ∷  (t → Day → Day) → t → DateTime → DateTime
---
> modifyDate ::  (t -> Day -> Day) -> t -> DateTime -> DateTime
260c260
< addInterval ∷  DateTime → DateInterval → DateTime
---
> addInterval ::  DateTime -> DateInterval -> DateTime
267c267
< negateInterval ∷ DateInterval → DateInterval
---
> negateInterval :: DateInterval -> DateInterval
274c274
< minusInterval ∷ DateTime → DateInterval → DateTime
---
> minusInterval :: DateTime -> DateInterval -> DateTime
278c278
< datesDifference ∷ DateTime → DateTime → Integer
---
> datesDifference :: DateTime -> DateTime -> Integer
283c283
< maybePlural ∷ Stream s m Char => String → ParsecT s st m String
---
> maybePlural :: Stream s m Char => String -> ParsecT s st m String
285c285
<   r ← string str
---
>   r <- string str
289c289
< pDateIntervalType ∷ Stream s m Char => ParsecT s st m DateIntervalType
---
> pDateIntervalType :: Stream s m Char => ParsecT s st m DateIntervalType
291c291
<   s ← choice $ map maybePlural ["day", "week", "month", "year"]
---
>   s <- choice $ map maybePlural ["day", "week", "month", "year"]
293d292
<     'd' → return Day
294d292
<     'w' → return Week
295d292
<     'm' → return Month
296d292
<     'y' → return Year
297c293
<     _ → fail $ "Unknown date interval type: " ++ s
---
>     'd' -> return Day
297a294
>     'w' -> return Week
297a295
>     'm' -> return Month
297a296
>     'y' -> return Year
297a297
>     _ -> fail $ "Unknown date interval type: " ++ s
299c299
< pDateInterval ∷ Stream s m Char => ParsecT s st m DateInterval
---
> pDateInterval :: Stream s m Char => ParsecT s st m DateInterval
301c301
<   n ← many1 digit
---
>   n <- many1 digit
303c303
<   tp ← pDateIntervalType
---
>   tp <- pDateIntervalType
305d304
<     Day →   Days   `fmap` tryReadInt n
306d304
<     Week →  Weeks  `fmap` tryReadInt n
307d304
<     Month → Months `fmap` tryReadInt n
308c305
<     Year →  Years  `fmap` tryReadInt n
---
>     Day ->   Days   `fmap` tryReadInt n
308a306
>     Week ->  Weeks  `fmap` tryReadInt n
308a307
>     Month -> Months `fmap` tryReadInt n
308a308
>     Year ->  Years  `fmap` tryReadInt n
310c310
< pRelDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
---
> pRelDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
312c312
<   offs ← try futureDate
---
>   offs <- try futureDate
319c319
< lastDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
---
> lastDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
326c326
<       wd ← try (string "week" >> return Monday) <|> pWeekDay
---
>       wd <- try (string "week" >> return Monday) <|> pWeekDay
341c341
< nextDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
---
> nextDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
348c348
<       wd ← try (string "week" >> return Monday) <|> pWeekDay
---
>       wd <- try (string "week" >> return Monday) <|> pWeekDay
363c363
< pWeekDay ∷ Stream s m Char => ParsecT s st m WeekDay
---
> pWeekDay :: Stream s m Char => ParsecT s st m WeekDay
365c365
<   w ← many1 (oneOf "mondaytueswnhrfi")
---
>   w <- many1 (oneOf "mondaytueswnhrfi")
367d366
<     "monday"    → return Monday
368d366
<     "tuesday"   → return Tuesday
369d366
<     "wednesday" → return Wednesday
370d366
<     "thursday"  → return Thursday
371d366
<     "friday"    → return Friday
372d366
<     "saturday"  → return Saturday
373d366
<     "sunday"    → return Sunday
374c367
<     _           → fail $ "Unknown weekday: " ++ w
---
>     "monday"    -> return Monday
374a368
>     "tuesday"   -> return Tuesday
374a369
>     "wednesday" -> return Wednesday
374a370
>     "thursday"  -> return Thursday
374a371
>     "friday"    -> return Friday
374a372
>     "saturday"  -> return Saturday
374a373
>     "sunday"    -> return Sunday
374a374
>     _           -> fail $ "Unknown weekday: " ++ w
376c376
< futureDate ∷ Stream s m Char => ParsecT s st m DateInterval
---
> futureDate :: Stream s m Char => ParsecT s st m DateInterval
379c379
<   n ← many1 digit
---
>   n <- many1 digit
381c381
<   tp ← pDateIntervalType
---
>   tp <- pDateIntervalType
383d382
<     Day →   Days   `fmap` tryReadInt n
384d382
<     Week →  Weeks  `fmap` tryReadInt n
385d382
<     Month → Months `fmap` tryReadInt n
386c383
<     Year →  Years  `fmap` tryReadInt n
---
>     Day ->   Days   `fmap` tryReadInt n
386a384
>     Week ->  Weeks  `fmap` tryReadInt n
386a385
>     Month -> Months `fmap` tryReadInt n
386a386
>     Year ->  Years  `fmap` tryReadInt n
388c388
< passDate ∷ Stream s m Char => ParsecT s st m DateInterval
---
> passDate :: Stream s m Char => ParsecT s st m DateInterval
390c390
<   n ← many1 digit
---
>   n <- many1 digit
392c392
<   tp ← pDateIntervalType
---
>   tp <- pDateIntervalType
395d394
<     Day →   (Days   . negate) `fmap` tryReadInt n
396d394
<     Week →  (Weeks  . negate) `fmap` tryReadInt n
397d394
<     Month → (Months . negate) `fmap` tryReadInt n
398c395
<     Year →  (Years  . negate) `fmap` tryReadInt n
---
>     Day ->   (Days   . negate) `fmap` tryReadInt n
398a396
>     Week ->  (Weeks  . negate) `fmap` tryReadInt n
398a397
>     Month -> (Months . negate) `fmap` tryReadInt n
398a398
>     Year ->  (Years  . negate) `fmap` tryReadInt n
400c400
< today ∷ Stream s m Char => ParsecT s st m DateInterval
---
> today :: Stream s m Char => ParsecT s st m DateInterval
405c405
< tomorrow ∷ Stream s m Char => ParsecT s st m DateInterval
---
> tomorrow :: Stream s m Char => ParsecT s st m DateInterval
410c410
< yesterday ∷ Stream s m Char => ParsecT s st m DateInterval
---
> yesterday :: Stream s m Char => ParsecT s st m DateInterval
415c415
< pByWeek ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
---
> pByWeek :: Stream s m Char => DateTime -> ParsecT s st m DateTime
420d419
< pDateTime ∷ Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
421c420
<           → ParsecT s st m DateTime
---
> pDateTime :: Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
421a421
>           -> ParsecT s st m DateTime
428d427
< pDate ∷ Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
429c428
<           → ParsecT s st m DateTime
---
> pDate :: Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
429a429
>           -> ParsecT s st m DateTime
436d435
< parseDate ∷ DateTime  -- ^ Current date / time, to use as base for relative dates
437d435
<           → String    -- ^ String to parse
438c436
<           → Either ParseError DateTime
---
> parseDate :: DateTime  -- ^ Current date / time, to use as base for relative dates
438a437
>           -> String    -- ^ String to parse
438a438
>           -> Either ParseError DateTime
440a441
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, DeriveDataTypeable, FlexibleContexts #-}
-- | Operations with dates
module Data.Dates
  (DateTime (..),
   Time (..),
   WeekDay (..),
   parseDate,
   pDate, pDateTime, pTime,
   pDateInterval,
   getCurrentDateTime,
   tryRead, tryReadInt,
   DateIntervalType (..),
   DateInterval (..),
   dayToDateTime, dateTimeToDay,
   weekdayToInterval,
   weekdayNumber,
   intToWeekday,
   dateWeekDay,
   lastMonday, nextMonday,
   modifyDate,
   datesDifference,
   addInterval, negateInterval, minusInterval,
   addTime
  ) where

import Prelude.Unicode
import Data.Char (toUpper)
import Data.List
import Data.Time.Calendar
import Data.Time.Calendar.WeekDate
import Data.Time.LocalTime
import Text.Parsec
import Data.Generics
import Data.Char (toLower)

import Data.Dates.Types
import Data.Dates.Internal

data DateIntervalType = Day | Week | Month | Year
  deriving (Eq,Show,Read,Data,Typeable)

data DateInterval = Days ℤ
                  | Weeks ℤ
                  | Months ℤ
                  | Years ℤ
  deriving (Eq,Show,Data,Typeable)

data WeekDay =
    Monday
  | Tuesday
  | Wednesday
  | Thursday
  | Friday
  | Saturday
  | Sunday
  deriving (Eq, Show, Read, Ord, Enum, Bounded, Data, Typeable)

-- | Weekday as interval from Monday, so that
-- weekdayToInterval Monday == 0 and
-- weekdayToInterval Sunday == 6.
weekdayToInterval ∷ WeekDay → DateInterval
weekdayToInterval wd = Days (fromIntegral $ fromEnum wd)

-- | Number of weekday, with Monday == 1 and Sunday == 7.
weekdayNumber ∷ WeekDay → Int
weekdayNumber wd = fromEnum wd + 1

-- | Reverse for weekdayNumber
intToWeekday ∷ Int → WeekDay
intToWeekday i = toEnum (i - 1)

lastMonday ∷ DateTime → DateTime
lastMonday dt = dt `minusInterval` weekdayToInterval (dateWeekDay dt)

nextMonday ∷ DateTime → DateTime
nextMonday dt = lastMonday dt `addInterval` Weeks 1

-- | Get current date and time.
getCurrentDateTime ∷  IO DateTime
getCurrentDateTime = do
  zt ← getZonedTime
  let lt = zonedTimeToLocalTime zt
      ld = localDay lt
      ltod = localTimeOfDay lt
      (y,m,d) = toGregorian ld
      h = todHour ltod
      mins = todMin ltod
      s = round $ todSec ltod
  return $ DateTime (fromIntegral y) m d h mins s

-- | Get weekday of given date.
dateWeekDay ∷ DateTime → WeekDay
dateWeekDay dt =
  let (_,_,wd) = toWeekDate (dateTimeToDay dt)
  in  intToWeekday wd

uppercase ∷ String → String
uppercase = map toUpper

isPrefixOfI ∷  String → String → Bool
p `isPrefixOfI` s = (uppercase p) `isPrefixOf` (uppercase s)

lookupS ∷ String → [(String,a)] → Maybe a
lookupS _ [] = Nothing
lookupS k ((k',v):other) | k `isPrefixOfI` k' = Just v
                         | otherwise          = lookupS k other

monthsN ∷ [(String,Int)]
monthsN = zip months [1..]

lookupMonth ∷ String → Maybe Int
lookupMonth n = lookupS n monthsN

date ∷  Int → Int → Int → DateTime
date y m d = DateTime y m d 0 0 0

addTime ∷  DateTime → Time → DateTime
addTime dt t = dt {
                 hour = tHour t + hour dt,
                 minute = tMinute t + minute dt,
                 second = tSecond t + second dt }

euroNumDate ∷ Stream s m Char => ParsecT s st m DateTime
euroNumDate = do
  d ← pDay
  char '.'
  m ← pMonth
  char '.'
  y ← pYear
  return $ date y m d

americanDate ∷ Stream s m Char => ParsecT s st m DateTime
americanDate = do
  y ← pYear
  char '/'
  m ← pMonth
  char '/'
  d ← pDay
  return $ date y m d

euroNumDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
euroNumDate' year = do
  d ← pDay
  char '.'
  m ← pMonth
  return $ date year m d

americanDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
americanDate' year = do
  m ← pMonth
  char '/'
  d ← pDay
  return $ date year m d

strDate ∷ Stream s m Char => ParsecT s st m DateTime
strDate = do
  d ← pDay
  space
  ms ← many1 letter
  case lookupMonth ms of
    Nothing → fail $ "unknown month: "++ms
    Just m  → do
      space
      y ← pYear
      notFollowedBy $ char ':'
      return $ date y m d

strDate' ∷ Stream s m Char => Int → ParsecT s st m DateTime
strDate' year = do
  d ← pDay
  space
  ms ← many1 letter
  case lookupMonth ms of
    Nothing → fail $ "unknown month: "++ms
    Just m  → return $ date year m d

time24 ∷ Stream s m Char => ParsecT s st m Time
time24 = do
  h ← number 2 23
  char ':'
  m ← number 2 59
  x ← optionMaybe $ char ':'
  case x of
    Nothing → return $ Time h m 0
    Just _ → do
      s ← number 2 59
      notFollowedBy letter
      return $ Time h m s

ampm ∷ Stream s m Char => ParsecT s st m Int
ampm = do
  s ← many1 letter
  case map toUpper s of
    "AM" → return 0
    "PM" → return 12
    _ → fail "AM/PM expected"

time12 ∷ Stream s m Char => ParsecT s st m Time
time12 = do
  h ← number 2 12
  char ':'
  m ← number 2 59
  x ← optionMaybe $ char ':'
  s ← case x of
            Nothing → return 0
            Just _  → number 2 59
  optional space
  hd ← ampm
  return $ Time (h+hd) m s

pTime ∷ Stream s m Char => ParsecT s st m Time
pTime = choice $ map try [time12, time24]

pAbsDateTime ∷ Stream s m Char => Int → ParsecT s st m DateTime
pAbsDateTime year = do
  date ← choice $ map try $ map ($ year) $ [
                              const euroNumDate,
                              const americanDate,
                              const strDate,
                              strDate',
                              euroNumDate',
                              americanDate']
  optional $ char ','
  s ← optionMaybe space
  case s of
    Nothing → return date
    Just _ → do
      t ← pTime
      return $ date `addTime` t

pAbsDate ∷ Stream s m Char => Int → ParsecT s st m DateTime
pAbsDate year =
  choice $ map try $ map ($ year) $ [
                          const euroNumDate,
                          const americanDate,
                          const strDate,
                          strDate',
                          euroNumDate',
                          americanDate']

-- | Convert date from DateTime to Day
dateTimeToDay ∷  DateTime → Day
dateTimeToDay dt = fromGregorian (fromIntegral $ year dt) (month dt) (day dt)

-- | Convert date from Day to DateTime
dayToDateTime ∷  Day → DateTime
dayToDateTime dt =
  let (y,m,d) = toGregorian dt
  in  date (fromIntegral y) m d

-- | Modify DateTime with pure function on Day
modifyDate ∷  (t → Day → Day) → t → DateTime → DateTime
modifyDate fn x dt =
  let date = dayToDateTime $ fn x $ dateTimeToDay dt
  in  date {hour   = hour   dt,
            minute = minute dt,
            second = second dt}

-- | Add date interval to DateTime
addInterval ∷  DateTime → DateInterval → DateTime
addInterval dt (Days ds) = modifyDate addDays ds dt
addInterval dt (Weeks ws) = modifyDate addDays (ws*7) dt
addInterval dt (Months ms) = modifyDate addGregorianMonthsClip ms dt
addInterval dt (Years ys) = modifyDate addGregorianYearsClip ys dt

-- | Negate DateInterval value: Days 3 → Days (-3).
negateInterval ∷ DateInterval → DateInterval
negateInterval (Days n)   = Days (negate n)
negateInterval (Weeks n)  = Weeks (negate n)
negateInterval (Months n) = Months (negate n)
negateInterval (Years n)  = Years (negate n)

-- | Subtract DateInterval from DateTime.
minusInterval ∷ DateTime → DateInterval → DateTime
minusInterval date int = date `addInterval` negateInterval int

-- | Number of days between two dates
datesDifference ∷ DateTime → DateTime → Integer
datesDifference d1 d2 =
  abs $ toModifiedJulianDay (dateTimeToDay d1) -
        toModifiedJulianDay (dateTimeToDay d2)

maybePlural ∷ Stream s m Char => String → ParsecT s st m String
maybePlural str = do
  r ← string str
  optional $ char 's'
  return (capitalize r)

pDateIntervalType ∷ Stream s m Char => ParsecT s st m DateIntervalType
pDateIntervalType = do
  s ← choice $ map maybePlural ["day", "week", "month", "year"]
  case toLower (head s) of
    'd' → return Day
    'w' → return Week
    'm' → return Month
    'y' → return Year
    _ → fail $ "Unknown date interval type: " ++ s

pDateInterval ∷ Stream s m Char => ParsecT s st m DateInterval
pDateInterval = do
  n ← many1 digit
  spaces
  tp ← pDateIntervalType
  case tp of
    Day →   Days   `fmap` tryReadInt n
    Week →  Weeks  `fmap` tryReadInt n
    Month → Months `fmap` tryReadInt n
    Year →  Years  `fmap` tryReadInt n

pRelDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
pRelDate date = do
  offs ← try futureDate
     <|> try passDate
     <|> try today
     <|> try tomorrow
     <|> yesterday
  return $ date `addInterval` offs

lastDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
lastDate now = do
    string "last"
    spaces
    try byweek <|> try bymonth <|> byyear
  where
    byweek = do
      wd ← try (string "week" >> return Monday) <|> pWeekDay
      let monday = lastMonday now
          monday' = if wd > dateWeekDay now
                      then monday `minusInterval` Weeks 1
                      else monday
      return $ monday' `addInterval` weekdayToInterval wd

    bymonth = do
      string "month"
      return $ now {day = 1}

    byyear = do
      string "year"
      return $ now {month = 1, day = 1}

nextDate ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
nextDate now = do
    string "next"
    spaces
    try byweek <|> try bymonth <|> byyear
  where
    byweek = do
      wd ← try (string "week" >> return Monday) <|> pWeekDay
      let monday = nextMonday now
          monday' = if wd > dateWeekDay now
                      then monday `minusInterval` Weeks 1
                      else monday
      return $ monday' `addInterval` weekdayToInterval wd

    bymonth = do
      string "month"
      return (now `addInterval` Months 1) {day = 1}

    byyear = do
      string "year"
      return (now `addInterval` Years 1) {month = 1, day = 1}

pWeekDay ∷ Stream s m Char => ParsecT s st m WeekDay
pWeekDay = do
  w ← many1 (oneOf "mondaytueswnhrfi")
  case map toLower w of
    "monday"    → return Monday
    "tuesday"   → return Tuesday
    "wednesday" → return Wednesday
    "thursday"  → return Thursday
    "friday"    → return Friday
    "saturday"  → return Saturday
    "sunday"    → return Sunday
    _           → fail $ "Unknown weekday: " ++ w

futureDate ∷ Stream s m Char => ParsecT s st m DateInterval
futureDate = do
  string "in "
  n ← many1 digit
  char ' '
  tp ← pDateIntervalType
  case tp of
    Day →   Days   `fmap` tryReadInt n
    Week →  Weeks  `fmap` tryReadInt n
    Month → Months `fmap` tryReadInt n
    Year →  Years  `fmap` tryReadInt n

passDate ∷ Stream s m Char => ParsecT s st m DateInterval
passDate = do
  n ← many1 digit
  char ' '
  tp ← pDateIntervalType
  string " ago"
  case tp of
    Day →   (Days   . negate) `fmap` tryReadInt n
    Week →  (Weeks  . negate) `fmap` tryReadInt n
    Month → (Months . negate) `fmap` tryReadInt n
    Year →  (Years  . negate) `fmap` tryReadInt n

today ∷ Stream s m Char => ParsecT s st m DateInterval
today = do
  string "today" <|> string "now"
  return $ Days 0

tomorrow ∷ Stream s m Char => ParsecT s st m DateInterval
tomorrow = do
  string "tomorrow"
  return $ Days 1

yesterday ∷ Stream s m Char => ParsecT s st m DateInterval
yesterday = do
  string "yesterday"
  return $ Days (-1)

pByWeek ∷ Stream s m Char => DateTime → ParsecT s st m DateTime
pByWeek date =
  try (lastDate date) <|> nextDate date

-- | Parsec parser for DateTime.
pDateTime ∷ Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
          → ParsecT s st m DateTime
pDateTime date =
      (try $ pRelDate date)
  <|> (try $ pByWeek date)
  <|> (try $ pAbsDateTime $ year date)

-- | Parsec parser for Date only.
pDate ∷ Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
          → ParsecT s st m DateTime
pDate date =
      (try $ pRelDate date)
  <|> (try $ pByWeek date)
  <|> (try $ pAbsDate $ year date)

-- | Parse date/time
parseDate ∷ DateTime  -- ^ Current date / time, to use as base for relative dates
          → String    -- ^ String to parse
          → Either ParseError DateTime
parseDate date s = runParser (pDate date) () "" s

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, DeriveDataTypeable, FlexibleContexts #-}
-- | Operations with dates
module Data.Dates
  (DateTime (..),
   Time (..),
   WeekDay (..),
   parseDate,
   pDate, pDateTime, pTime,
   pDateInterval,
   getCurrentDateTime,
   tryRead, tryReadInt,
   DateIntervalType (..),
   DateInterval (..),
   dayToDateTime, dateTimeToDay,
   weekdayToInterval,
   weekdayNumber,
   intToWeekday,
   dateWeekDay,
   lastMonday, nextMonday,
   modifyDate,
   datesDifference,
   addInterval, negateInterval, minusInterval,
   addTime
  ) where

import Prelude.Unicode
import Data.Char (toUpper)
import Data.List
import Data.Time.Calendar
import Data.Time.Calendar.WeekDate
import Data.Time.LocalTime
import Text.Parsec
import Data.Generics
import Data.Char (toLower)

import Data.Dates.Types
import Data.Dates.Internal

data DateIntervalType = Day | Week | Month | Year
  deriving (Eq,Show,Read,Data,Typeable)

data DateInterval = Days ℤ
                  | Weeks ℤ
                  | Months ℤ
                  | Years ℤ
  deriving (Eq,Show,Data,Typeable)

data WeekDay =
    Monday
  | Tuesday
  | Wednesday
  | Thursday
  | Friday
  | Saturday
  | Sunday
  deriving (Eq, Show, Read, Ord, Enum, Bounded, Data, Typeable)

-- | Weekday as interval from Monday, so that
-- weekdayToInterval Monday == 0 and
-- weekdayToInterval Sunday == 6.
weekdayToInterval :: WeekDay -> DateInterval
weekdayToInterval wd = Days (fromIntegral $ fromEnum wd)

-- | Number of weekday, with Monday == 1 and Sunday == 7.
weekdayNumber :: WeekDay -> Int
weekdayNumber wd = fromEnum wd + 1

-- | Reverse for weekdayNumber
intToWeekday :: Int -> WeekDay
intToWeekday i = toEnum (i - 1)

lastMonday :: DateTime -> DateTime
lastMonday dt = dt `minusInterval` weekdayToInterval (dateWeekDay dt)

nextMonday :: DateTime -> DateTime
nextMonday dt = lastMonday dt `addInterval` Weeks 1

-- | Get current date and time.
getCurrentDateTime ::  IO DateTime
getCurrentDateTime = do
  zt <- getZonedTime
  let lt = zonedTimeToLocalTime zt
      ld = localDay lt
      ltod = localTimeOfDay lt
      (y,m,d) = toGregorian ld
      h = todHour ltod
      mins = todMin ltod
      s = round $ todSec ltod
  return $ DateTime (fromIntegral y) m d h mins s

-- | Get weekday of given date.
dateWeekDay :: DateTime -> WeekDay
dateWeekDay dt =
  let (_,_,wd) = toWeekDate (dateTimeToDay dt)
  in  intToWeekday wd

uppercase :: String -> String
uppercase = map toUpper

isPrefixOfI ::  String -> String -> Bool
p `isPrefixOfI` s = (uppercase p) `isPrefixOf` (uppercase s)

lookupS :: String -> [(String,a)] -> Maybe a
lookupS _ [] = Nothing
lookupS k ((k',v):other) | k `isPrefixOfI` k' = Just v
                         | otherwise          = lookupS k other

monthsN :: [(String,Int)]
monthsN = zip months [1..]

lookupMonth :: String -> Maybe Int
lookupMonth n = lookupS n monthsN

date ::  Int -> Int -> Int -> DateTime
date y m d = DateTime y m d 0 0 0

addTime ::  DateTime -> Time -> DateTime
addTime dt t = dt {
                 hour = tHour t + hour dt,
                 minute = tMinute t + minute dt,
                 second = tSecond t + second dt }

euroNumDate :: Stream s m Char => ParsecT s st m DateTime
euroNumDate = do
  d <- pDay
  char '.'
  m <- pMonth
  char '.'
  y <- pYear
  return $ date y m d

americanDate :: Stream s m Char => ParsecT s st m DateTime
americanDate = do
  y <- pYear
  char '/'
  m <- pMonth
  char '/'
  d <- pDay
  return $ date y m d

euroNumDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
euroNumDate' year = do
  d <- pDay
  char '.'
  m <- pMonth
  return $ date year m d

americanDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
americanDate' year = do
  m <- pMonth
  char '/'
  d <- pDay
  return $ date year m d

strDate :: Stream s m Char => ParsecT s st m DateTime
strDate = do
  d <- pDay
  space
  ms <- many1 letter
  case lookupMonth ms of
    Nothing -> fail $ "unknown month: "++ms
    Just m  -> do
      space
      y <- pYear
      notFollowedBy $ char ':'
      return $ date y m d

strDate' :: Stream s m Char => Int -> ParsecT s st m DateTime
strDate' year = do
  d <- pDay
  space
  ms <- many1 letter
  case lookupMonth ms of
    Nothing -> fail $ "unknown month: "++ms
    Just m  -> return $ date year m d

time24 :: Stream s m Char => ParsecT s st m Time
time24 = do
  h <- number 2 23
  char ':'
  m <- number 2 59
  x <- optionMaybe $ char ':'
  case x of
    Nothing -> return $ Time h m 0
    Just _ -> do
      s <- number 2 59
      notFollowedBy letter
      return $ Time h m s

ampm :: Stream s m Char => ParsecT s st m Int
ampm = do
  s <- many1 letter
  case map toUpper s of
    "AM" -> return 0
    "PM" -> return 12
    _ -> fail "AM/PM expected"

time12 :: Stream s m Char => ParsecT s st m Time
time12 = do
  h <- number 2 12
  char ':'
  m <- number 2 59
  x <- optionMaybe $ char ':'
  s <- case x of
            Nothing -> return 0
            Just _  -> number 2 59
  optional space
  hd <- ampm
  return $ Time (h+hd) m s

pTime :: Stream s m Char => ParsecT s st m Time
pTime = choice $ map try [time12, time24]

pAbsDateTime :: Stream s m Char => Int -> ParsecT s st m DateTime
pAbsDateTime year = do
  date <- choice $ map try $ map ($ year) $ [
                              const euroNumDate,
                              const americanDate,
                              const strDate,
                              strDate',
                              euroNumDate',
                              americanDate']
  optional $ char ','
  s <- optionMaybe space
  case s of
    Nothing -> return date
    Just _ -> do
      t <- pTime
      return $ date `addTime` t

pAbsDate :: Stream s m Char => Int -> ParsecT s st m DateTime
pAbsDate year =
  choice $ map try $ map ($ year) $ [
                          const euroNumDate,
                          const americanDate,
                          const strDate,
                          strDate',
                          euroNumDate',
                          americanDate']

-- | Convert date from DateTime to Day
dateTimeToDay ::  DateTime -> Day
dateTimeToDay dt = fromGregorian (fromIntegral $ year dt) (month dt) (day dt)

-- | Convert date from Day to DateTime
dayToDateTime ::  Day -> DateTime
dayToDateTime dt =
  let (y,m,d) = toGregorian dt
  in  date (fromIntegral y) m d

-- | Modify DateTime with pure function on Day
modifyDate ::  (t -> Day -> Day) -> t -> DateTime -> DateTime
modifyDate fn x dt =
  let date = dayToDateTime $ fn x $ dateTimeToDay dt
  in  date {hour   = hour   dt,
            minute = minute dt,
            second = second dt}

-- | Add date interval to DateTime
addInterval ::  DateTime -> DateInterval -> DateTime
addInterval dt (Days ds) = modifyDate addDays ds dt
addInterval dt (Weeks ws) = modifyDate addDays (ws*7) dt
addInterval dt (Months ms) = modifyDate addGregorianMonthsClip ms dt
addInterval dt (Years ys) = modifyDate addGregorianYearsClip ys dt

-- | Negate DateInterval value: Days 3 → Days (-3).
negateInterval :: DateInterval -> DateInterval
negateInterval (Days n)   = Days (negate n)
negateInterval (Weeks n)  = Weeks (negate n)
negateInterval (Months n) = Months (negate n)
negateInterval (Years n)  = Years (negate n)

-- | Subtract DateInterval from DateTime.
minusInterval :: DateTime -> DateInterval -> DateTime
minusInterval date int = date `addInterval` negateInterval int

-- | Number of days between two dates
datesDifference :: DateTime -> DateTime -> Integer
datesDifference d1 d2 =
  abs $ toModifiedJulianDay (dateTimeToDay d1) -
        toModifiedJulianDay (dateTimeToDay d2)

maybePlural :: Stream s m Char => String -> ParsecT s st m String
maybePlural str = do
  r <- string str
  optional $ char 's'
  return (capitalize r)

pDateIntervalType :: Stream s m Char => ParsecT s st m DateIntervalType
pDateIntervalType = do
  s <- choice $ map maybePlural ["day", "week", "month", "year"]
  case toLower (head s) of
    'd' -> return Day
    'w' -> return Week
    'm' -> return Month
    'y' -> return Year
    _ -> fail $ "Unknown date interval type: " ++ s

pDateInterval :: Stream s m Char => ParsecT s st m DateInterval
pDateInterval = do
  n <- many1 digit
  spaces
  tp <- pDateIntervalType
  case tp of
    Day ->   Days   `fmap` tryReadInt n
    Week ->  Weeks  `fmap` tryReadInt n
    Month -> Months `fmap` tryReadInt n
    Year ->  Years  `fmap` tryReadInt n

pRelDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
pRelDate date = do
  offs <- try futureDate
     <|> try passDate
     <|> try today
     <|> try tomorrow
     <|> yesterday
  return $ date `addInterval` offs

lastDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
lastDate now = do
    string "last"
    spaces
    try byweek <|> try bymonth <|> byyear
  where
    byweek = do
      wd <- try (string "week" >> return Monday) <|> pWeekDay
      let monday = lastMonday now
          monday' = if wd > dateWeekDay now
                      then monday `minusInterval` Weeks 1
                      else monday
      return $ monday' `addInterval` weekdayToInterval wd

    bymonth = do
      string "month"
      return $ now {day = 1}

    byyear = do
      string "year"
      return $ now {month = 1, day = 1}

nextDate :: Stream s m Char => DateTime -> ParsecT s st m DateTime
nextDate now = do
    string "next"
    spaces
    try byweek <|> try bymonth <|> byyear
  where
    byweek = do
      wd <- try (string "week" >> return Monday) <|> pWeekDay
      let monday = nextMonday now
          monday' = if wd > dateWeekDay now
                      then monday `minusInterval` Weeks 1
                      else monday
      return $ monday' `addInterval` weekdayToInterval wd

    bymonth = do
      string "month"
      return (now `addInterval` Months 1) {day = 1}

    byyear = do
      string "year"
      return (now `addInterval` Years 1) {month = 1, day = 1}

pWeekDay :: Stream s m Char => ParsecT s st m WeekDay
pWeekDay = do
  w <- many1 (oneOf "mondaytueswnhrfi")
  case map toLower w of
    "monday"    -> return Monday
    "tuesday"   -> return Tuesday
    "wednesday" -> return Wednesday
    "thursday"  -> return Thursday
    "friday"    -> return Friday
    "saturday"  -> return Saturday
    "sunday"    -> return Sunday
    _           -> fail $ "Unknown weekday: " ++ w

futureDate :: Stream s m Char => ParsecT s st m DateInterval
futureDate = do
  string "in "
  n <- many1 digit
  char ' '
  tp <- pDateIntervalType
  case tp of
    Day ->   Days   `fmap` tryReadInt n
    Week ->  Weeks  `fmap` tryReadInt n
    Month -> Months `fmap` tryReadInt n
    Year ->  Years  `fmap` tryReadInt n

passDate :: Stream s m Char => ParsecT s st m DateInterval
passDate = do
  n <- many1 digit
  char ' '
  tp <- pDateIntervalType
  string " ago"
  case tp of
    Day ->   (Days   . negate) `fmap` tryReadInt n
    Week ->  (Weeks  . negate) `fmap` tryReadInt n
    Month -> (Months . negate) `fmap` tryReadInt n
    Year ->  (Years  . negate) `fmap` tryReadInt n

today :: Stream s m Char => ParsecT s st m DateInterval
today = do
  string "today" <|> string "now"
  return $ Days 0

tomorrow :: Stream s m Char => ParsecT s st m DateInterval
tomorrow = do
  string "tomorrow"
  return $ Days 1

yesterday :: Stream s m Char => ParsecT s st m DateInterval
yesterday = do
  string "yesterday"
  return $ Days (-1)

pByWeek :: Stream s m Char => DateTime -> ParsecT s st m DateTime
pByWeek date =
  try (lastDate date) <|> nextDate date

-- | Parsec parser for DateTime.
pDateTime :: Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
          -> ParsecT s st m DateTime
pDateTime date =
      (try $ pRelDate date)
  <|> (try $ pByWeek date)
  <|> (try $ pAbsDateTime $ year date)

-- | Parsec parser for Date only.
pDate :: Stream s m Char => DateTime       -- ^ Current date / time, to use as base for relative dates
          -> ParsecT s st m DateTime
pDate date =
      (try $ pRelDate date)
  <|> (try $ pByWeek date)
  <|> (try $ pAbsDate $ year date)

-- | Parse date/time
parseDate :: DateTime  -- ^ Current date / time, to use as base for relative dates
          -> String    -- ^ String to parse
          -> Either ParseError DateTime
parseDate date s = runParser (pDate date) () "" s


</pre>