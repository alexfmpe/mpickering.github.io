<a href="Call.hs17195338081517273377.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Capture.hs19027373351127401868.out.html">next</a></br></br><pre>43d42
<   do $expect $ left' (mkPath' "diro/")
44d42
<      $expect $ left' (mkPath' "dir.txt")
45d42
<      $expect $ left' (mkPath' "dir/ab/../../dir/ab/./../file1.tx")
46c43
<      $expect $ left' (mkPath' deepFile)
---
>   do expect $ left' (mkPath' "diro/")
46a44
>      expect $ left' (mkPath' "dir.txt")
46a45
>      expect $ left' (mkPath' "dir/ab/../../dir/ab/./../file1.tx")
46a46
>      expect $ left' (mkPath' deepFile)
51d50
<   do $expect $ check "dir/" "dir"
52d50
<      $expect $ check "dir" "dir"
53c51
<      $expect $ check "file" "file"
---
>   do expect $ check "dir/" "dir"
53a52
>      expect $ check "dir" "dir"
53a53
>      expect $ check "file" "file"
56d55
<      $expect $ check "dir/file1.txt" "dir/file1.txt"
57d55
<      $expect $ check "dir/ab/" "dir/ab"
58d55
<      $expect $ check "dir/file" "dir/file"
59d55
<      $expect $ check "dir/ab/../file" "dir/file"
60d55
<      $expect $ check "dir/ab/../ab/" "dir/ab"
61d55
<      $expect $ check "dir/ab/./file2.txt" "dir/ab/file2.txt"
62c56
<      $expect $ check "dir/ab/../../dir/ab/./../file1.txt" "dir/file1.txt"
---
>      expect $ check "dir/file1.txt" "dir/file1.txt"
62a57
>      expect $ check "dir/ab/" "dir/ab"
62a58
>      expect $ check "dir/file" "dir/file"
62a59
>      expect $ check "dir/ab/../file" "dir/file"
62a60
>      expect $ check "dir/ab/../ab/" "dir/ab"
62a61
>      expect $ check "dir/ab/./file2.txt" "dir/ab/file2.txt"
62a62
>      expect $ check "dir/ab/../../dir/ab/./../file1.txt" "dir/file1.txt"
67d66
<   do $expect $ equal' (mkPath "$HOME/") (mkPath "~/")
68c67
<      $expect $ right' (mkPath "$TMPDIR")
---
>   do expect $ equal' (mkPath "$HOME/") (mkPath "~/")
68a68
>      expect $ right' (mkPath "$TMPDIR")
110a111
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

module Main (main) where

import           BasicPrelude
import qualified Control.Arrow as Arrow(right)
import           Filesystem.CanonicalPath
import           Filesystem.CanonicalPath.Directory
import           Test.Chell

main :: IO ()
main =
  do createTestFiles
     defaultMain [testCanonicalPath]

createTestFiles :: IO ()
createTestFiles =
  do r <- canonicalPathE rootdir
     either (\_ -> return ()) removeDirectoryRecursive r
     wd <- getCurrentDirectory
     root <- createDirectory wd rootdir
     d1 <- createDirectory root "dir"
     d2 <- createDirectory d1 "ab"
     createDirectory_ root "file-or-dir"
     writeFile' root "file" ""
     writeFile' d1 "file" ""
     writeFile' d1 "file1.txt" ""
     writeFile' d2 "file2.txt" ""
     return ()

testCanonicalPath :: Suite
testCanonicalPath =
  suite "canonical path constructors" $
  [testLeftSide
  ,testRightSide
  ,testVariables]

testLeftSide :: Test
testLeftSide =
  assertions "test for expected lefts" $
  do $expect $ left' (mkPath' "diro/")
     $expect $ left' (mkPath' "dir.txt")
     $expect $ left' (mkPath' "dir/ab/../../dir/ab/./../file1.tx")
     $expect $ left' (mkPath' deepFile)

testRightSide :: Test
testRightSide =
  assertions "test for expected rights" $
  do $expect $ check "dir/" "dir"
     $expect $ check "dir" "dir"
     $expect $ check "file" "file"
     -- check "file/" "file" will fail on linux
     -- but will not fail on os x
     $expect $ check "dir/file1.txt" "dir/file1.txt"
     $expect $ check "dir/ab/" "dir/ab"
     $expect $ check "dir/file" "dir/file"
     $expect $ check "dir/ab/../file" "dir/file"
     $expect $ check "dir/ab/../ab/" "dir/ab"
     $expect $ check "dir/ab/./file2.txt" "dir/ab/file2.txt"
     $expect $ check "dir/ab/../../dir/ab/./../file1.txt" "dir/file1.txt"

testVariables :: Test
testVariables =
  assertions "test for extracting environment variables" $
  do $expect $ equal' (mkPath "$HOME/") (mkPath "~/")
     $expect $ right' (mkPath "$TMPDIR")

-- Chell helpers

left' :: (Show b, Monad m) => m (Either a b) -> m Assertion
left' v = v >>= \v' -> return $ left v'

right' :: (Show a, Monad m) => m (Either a b) -> m Assertion
right' v = v >>= \v' -> return $ right v'

equal' :: (Show a, Monad m, Eq a) => m a -> m a -> m Assertion
equal' v w = do
  v' <- v
  w' <- w
  return $ equal v' w'

check :: FilePath -> FilePath -> IO Assertion
check p1 p2 = equal' (mkPath' p1) (liftM Right $ inCurrentDir p2)

-- Helper functions

mkPath :: FilePath -> IO (Either Text CanonicalPath)
mkPath = canonicalPathE

mkPath' :: FilePath -> IO (Either Text FilePath)
mkPath' p = inCurrentDir p >>= liftM unsafe . mkPath

unsafe :: Either Text CanonicalPath -> Either Text FilePath
unsafe = Arrow.right unsafePath

currentDir :: IO FilePath
currentDir = liftM ((</> rootdir) . unsafePath) getCurrentDirectory

inCurrentDir :: FilePath -> IO FilePath
inCurrentDir p =
  do h <- currentDir
     return $ h </> p

deepFile :: FilePath
deepFile = concat $ replicate 500 "deep-hell"

rootdir :: IsString a => a
rootdir = "test-root"
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

module Main (main) where

import           BasicPrelude
import qualified Control.Arrow as Arrow(right)
import           Filesystem.CanonicalPath
import           Filesystem.CanonicalPath.Directory
import           Test.Chell

main :: IO ()
main =
  do createTestFiles
     defaultMain [testCanonicalPath]

createTestFiles :: IO ()
createTestFiles =
  do r <- canonicalPathE rootdir
     either (\_ -> return ()) removeDirectoryRecursive r
     wd <- getCurrentDirectory
     root <- createDirectory wd rootdir
     d1 <- createDirectory root "dir"
     d2 <- createDirectory d1 "ab"
     createDirectory_ root "file-or-dir"
     writeFile' root "file" ""
     writeFile' d1 "file" ""
     writeFile' d1 "file1.txt" ""
     writeFile' d2 "file2.txt" ""
     return ()

testCanonicalPath :: Suite
testCanonicalPath =
  suite "canonical path constructors" $
  [testLeftSide
  ,testRightSide
  ,testVariables]

testLeftSide :: Test
testLeftSide =
  assertions "test for expected lefts" $
  do expect $ left' (mkPath' "diro/")
     expect $ left' (mkPath' "dir.txt")
     expect $ left' (mkPath' "dir/ab/../../dir/ab/./../file1.tx")
     expect $ left' (mkPath' deepFile)

testRightSide :: Test
testRightSide =
  assertions "test for expected rights" $
  do expect $ check "dir/" "dir"
     expect $ check "dir" "dir"
     expect $ check "file" "file"
     -- check "file/" "file" will fail on linux
     -- but will not fail on os x
     expect $ check "dir/file1.txt" "dir/file1.txt"
     expect $ check "dir/ab/" "dir/ab"
     expect $ check "dir/file" "dir/file"
     expect $ check "dir/ab/../file" "dir/file"
     expect $ check "dir/ab/../ab/" "dir/ab"
     expect $ check "dir/ab/./file2.txt" "dir/ab/file2.txt"
     expect $ check "dir/ab/../../dir/ab/./../file1.txt" "dir/file1.txt"

testVariables :: Test
testVariables =
  assertions "test for extracting environment variables" $
  do expect $ equal' (mkPath "$HOME/") (mkPath "~/")
     expect $ right' (mkPath "$TMPDIR")

-- Chell helpers

left' :: (Show b, Monad m) => m (Either a b) -> m Assertion
left' v = v >>= \v' -> return $ left v'

right' :: (Show a, Monad m) => m (Either a b) -> m Assertion
right' v = v >>= \v' -> return $ right v'

equal' :: (Show a, Monad m, Eq a) => m a -> m a -> m Assertion
equal' v w = do
  v' <- v
  w' <- w
  return $ equal v' w'

check :: FilePath -> FilePath -> IO Assertion
check p1 p2 = equal' (mkPath' p1) (liftM Right $ inCurrentDir p2)

-- Helper functions

mkPath :: FilePath -> IO (Either Text CanonicalPath)
mkPath = canonicalPathE

mkPath' :: FilePath -> IO (Either Text FilePath)
mkPath' p = inCurrentDir p >>= liftM unsafe . mkPath

unsafe :: Either Text CanonicalPath -> Either Text FilePath
unsafe = Arrow.right unsafePath

currentDir :: IO FilePath
currentDir = liftM ((</> rootdir) . unsafePath) getCurrentDirectory

inCurrentDir :: FilePath -> IO FilePath
inCurrentDir p =
  do h <- currentDir
     return $ h </> p

deepFile :: FilePath
deepFile = concat $ replicate 500 "deep-hell"

rootdir :: IsString a => a
rootdir = "test-root"

</pre>