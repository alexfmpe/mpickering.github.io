<a href="Templates.hs12609736711815859901.out.html">prev</a></br><a href="failures.html">home</a></br><a href="TermLike.hs1732378755506449259.out.html">next</a></br></br><pre>45c45
<     instance MonadRoom m => MonadRoom ($sx m) where
---
>     instance MonadRoom m => MonadRoom (sx m) where
53c53
<     instance (MonadError $ex m) => MonadError $ex ($sx m) where
---
>     instance (MonadError ex m) => MonadError ex (sx m) where
62c62
<     instance MonadDungeon m => MonadDungeon ($sx m) where
---
>     instance MonadDungeon m => MonadDungeon (sx m) where
65c65
<     instance (MonadDungeon m,ChChannelPrinter PlayerId m) => ChBroadcaster PlayerId ($sx m) where
---
>     instance (MonadDungeon m,ChChannelPrinter PlayerId m) => ChBroadcaster PlayerId (sx m) where
72c72
<     instance MonadObject m => MonadObject ($sx m) where
---
>     instance MonadObject m => MonadObject (sx m) where
80c80
<     instance MonadPlayer m => MonadPlayer ($sx m) where
---
>     instance MonadPlayer m => MonadPlayer (sx m) where
88c88
<     instance MonadIO m => MonadIO ($sx m) where
---
>     instance MonadIO m => MonadIO (sx m) where
95c95
<     instance MonadVocab m => MonadVocab ($sx m) where
---
>     instance MonadVocab m => MonadVocab (sx m) where
100a101
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE TemplateHaskell, QuasiQuotes, FlexibleInstances, MultiParamTypeClasses, TypeSynonymInstances, FlexibleContexts, UndecidableInstances #-}

{-
  This module is part of Antisplice.
  Copyleft (c) 2014 Marvin Cohrs

  All wrongs reversed. Sharing is an act of love, not crime.
  Please share Antisplice with everyone you like.

  Antisplice is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Antisplice is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with Antisplice. If not, see <http://www.gnu.org/licenses/>.
-}

-- | Provides (chatty-compatible) templates for automatical instance derivation.
module Game.Antisplice.Templates where

import Language.Haskell.TH
import Text.Chatty.Templates
import Text.Chatty.Channel.Printer
import Text.Chatty.Channel.Broadcast
import Data.Chatty.Fail
import Data.Chatty.Counter
import Game.Antisplice.Monad.Dungeon
import Game.Antisplice.Monad.Vocab
import Data.Chatty.Atoms
import Control.Monad.Error.Class
import Control.Monad.Trans.Class
import Control.Monad.State.Class
import Control.Monad.IO.Class

type PlayerFilterT = FilterT PlayerId

-- | Automatically derive an instance for 'MonadRoom'
mkRoom s = [d|
    instance MonadRoom m => MonadRoom ($sx m) where
      getRoomState = lift getRoomState
      putRoomState = lift . putRoomState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadError e'
mkFail e s = [d|
    instance (MonadError $ex m) => MonadError $ex ($sx m) where
      throwError = lift . throwError
      catchError = error "catchError not implemented for this type."
  |]
  where sx = strToType s
        ex = strToType e

-- | Automatically derive an instance for 'MonadDungeon'
mkDungeon s = [d|
    instance MonadDungeon m => MonadDungeon ($sx m) where
      getDungeonState = lift getDungeonState
      putDungeonState = lift . putDungeonState
    instance (MonadDungeon m,ChChannelPrinter PlayerId m) => ChBroadcaster PlayerId ($sx m) where
      bprint c = lowerDungeon . bprint (lift . c)
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadObject'
mkObject s = [d|
    instance MonadObject m => MonadObject ($sx m) where
      getObjectState = lift getObjectState
      putObjectState = lift . putObjectState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadPlayer'
mkPlayer s = [d|
    instance MonadPlayer m => MonadPlayer ($sx m) where
      getPlayerState = lift getPlayerState
      putPlayerState = lift . putPlayerState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadIO'
mkIO s = [d|
    instance MonadIO m => MonadIO ($sx m) where
      liftIO = lift . liftIO
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadVocab'
mkVocab s = [d|
    instance MonadVocab m => MonadVocab ($sx m) where
      lookupVocab = lift . lookupVocab
      insertVocab k = lift . insertVocab k
      vocabKnown = lift . vocabKnown
  |]
  where sx = strToType s
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE TemplateHaskell, QuasiQuotes, FlexibleInstances, MultiParamTypeClasses, TypeSynonymInstances, FlexibleContexts, UndecidableInstances #-}

{-
  This module is part of Antisplice.
  Copyleft (c) 2014 Marvin Cohrs

  All wrongs reversed. Sharing is an act of love, not crime.
  Please share Antisplice with everyone you like.

  Antisplice is free software: you can redistribute it and/or modify
  it under the terms of the GNU Affero General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Antisplice is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Affero General Public License for more details.

  You should have received a copy of the GNU Affero General Public License
  along with Antisplice. If not, see <http://www.gnu.org/licenses/>.
-}

-- | Provides (chatty-compatible) templates for automatical instance derivation.
module Game.Antisplice.Templates where

import Language.Haskell.TH
import Text.Chatty.Templates
import Text.Chatty.Channel.Printer
import Text.Chatty.Channel.Broadcast
import Data.Chatty.Fail
import Data.Chatty.Counter
import Game.Antisplice.Monad.Dungeon
import Game.Antisplice.Monad.Vocab
import Data.Chatty.Atoms
import Control.Monad.Error.Class
import Control.Monad.Trans.Class
import Control.Monad.State.Class
import Control.Monad.IO.Class

type PlayerFilterT = FilterT PlayerId

-- | Automatically derive an instance for 'MonadRoom'
mkRoom s = [d|
    instance MonadRoom m => MonadRoom (sx m) where
      getRoomState = lift getRoomState
      putRoomState = lift . putRoomState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadError e'
mkFail e s = [d|
    instance (MonadError ex m) => MonadError ex (sx m) where
      throwError = lift . throwError
      catchError = error "catchError not implemented for this type."
  |]
  where sx = strToType s
        ex = strToType e

-- | Automatically derive an instance for 'MonadDungeon'
mkDungeon s = [d|
    instance MonadDungeon m => MonadDungeon (sx m) where
      getDungeonState = lift getDungeonState
      putDungeonState = lift . putDungeonState
    instance (MonadDungeon m,ChChannelPrinter PlayerId m) => ChBroadcaster PlayerId (sx m) where
      bprint c = lowerDungeon . bprint (lift . c)
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadObject'
mkObject s = [d|
    instance MonadObject m => MonadObject (sx m) where
      getObjectState = lift getObjectState
      putObjectState = lift . putObjectState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadPlayer'
mkPlayer s = [d|
    instance MonadPlayer m => MonadPlayer (sx m) where
      getPlayerState = lift getPlayerState
      putPlayerState = lift . putPlayerState
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadIO'
mkIO s = [d|
    instance MonadIO m => MonadIO (sx m) where
      liftIO = lift . liftIO
  |]
  where sx = strToType s

-- | Automatically derive an instance for 'MonadVocab'
mkVocab s = [d|
    instance MonadVocab m => MonadVocab (sx m) where
      lookupVocab = lift . lookupVocab
      insertVocab k = lift . insertVocab k
      vocabKnown = lift . vocabKnown
  |]
  where sx = strToType s

</pre>