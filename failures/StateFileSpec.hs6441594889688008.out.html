<a href="StateFile.hs195400260589673557.out.html">prev</a></br><a href="failures.html">home</a></br><a href="StateSpace.hs1622650073984943658.out.html">next</a></br></br><pre>26c26
< withNRtorrentFiles ∷ Int → StateMod → (FilePath → IO a) → IO a
---
> withNRtorrentFiles :: Int -> StateMod -> (FilePath -> IO a) -> IO a
28d27
<   t ← getTemporaryDirectory
29d27
<   withTempDirectory t "rtorrent-state-test-dir" $ \d → do
30c28
<     mapM_ (\x → makeStateFile $ d </> show x ++ ".rtorrent") [1 .. i]
---
>   t <- getTemporaryDirectory
30a29
>   withTempDirectory t "rtorrent-state-test-dir" $ \d -> do
30a30
>     mapM_ (\x -> makeStateFile $ d </> show x ++ ".rtorrent") [1 .. i]
33c33
<     genStateFileContent ∷ IO ByteString
---
>     genStateFileContent :: IO ByteString
36c36
<     makeStateFile ∷ FilePath → IO ()
---
>     makeStateFile :: FilePath -> IO ()
41c41
< withRtorrentFiles ∷ StateMod -- ^ Modifies the 'StateFile' before
---
> withRtorrentFiles :: StateMod -- ^ Modifies the 'StateFile' before
44c44
<                   → (FilePath → IO a) → IO a
---
>                   -> (FilePath -> IO a) -> IO a
46c46
<   generate arbitrary >>= \(Positive i) → withNRtorrentFiles i f g
---
>   generate arbitrary >>= \(Positive i) -> withNRtorrentFiles i f g
49c49
< shouldSatisfyIO ∷ IO a → (a → Bool) → Expectation
---
> shouldSatisfyIO :: IO a -> (a -> Bool) -> Expectation
52c52
< spec ∷ Spec
---
> spec :: Spec
55d54
<     \s@(StateFile {}) → let e = toStrict $ encode s
56c55
<                         in decode e `shouldBe` Right s
---
>     \s@(StateFile {}) -> let e = toStrict $ encode s
56a56
>                          in decode e `shouldBe` Right s
59c59
<     . withNRtorrentFiles 0 id $ \d →
---
>     . withNRtorrentFiles 0 id $ \d ->
62c62
<   prop "can stop all torrents" . withRtorrentFiles startTorrent $ \d →
---
>   prop "can stop all torrents" . withRtorrentFiles startTorrent $ \d ->
66c66
<     . withNRtorrentFiles 10000 startTorrent $ \d →
---
>     . withNRtorrentFiles 10000 startTorrent $ \d ->
69c69
<   prop "can start all torrents" . withRtorrentFiles stopTorrent $ \d →
---
>   prop "can start all torrents" . withRtorrentFiles stopTorrent $ \d ->
78d77
<     allSatisfy ∷ M.Map FilePath (Result StateFile) -- ^ parsed files
79d77
<                → (Result StateFile → Bool) -- ^ predicate
80c78
<                → Bool
---
>     allSatisfy :: M.Map FilePath (Result StateFile) -- ^ parsed files
80a79
>                -> (Result StateFile -> Bool) -- ^ predicate
80a80
>                -> Bool
84d83
<     allAre ∷ M.Map FilePath (Result StateFile)
85d83
<            → (StateFile → Bool)
86d83
<            → Bool
87d83
<     allAre m p = allSatisfy m (\case Right x → p x
88c84
<                                      Left _ → False )
---
>     allAre :: M.Map FilePath (Result StateFile)
88a85
>            -> (StateFile -> Bool)
88a86
>            -> Bool
88a87
>     allAre m p = allSatisfy m (      Right x -> p x
88a88
>                                      Left _ -> False )
90c90
<     allStopped, allStarted ∷ M.Map FilePath (Result StateFile) → Bool
---
>     allStopped, allStarted :: M.Map FilePath (Result StateFile) -> Bool
104c104
<     (cdl, cds, cdul, cdus) ← (,,,) <$> arbitrary <*> arbitrary <*> arbitrary
---
>     (cdl, cds, cdul, cdus) <- (,,,) <$> arbitrary <*> arbitrary <*> arbitrary
106d105
<     (cd, cw, com) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
107d105
<     (cl, cs) ← (,) <$> arbitrary <*> arbitrary
108d105
<     cust ← arbitrary
109c106
<     (c1, c2, c3, c4, c5, dir) ← (,,,,,) <$> arbitrary <*> arbitrary
---
>     (cd, cw, com) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
109a107
>     (cl, cs) <- (,) <$> arbitrary <*> arbitrary
109a108
>     cust <- arbitrary
109a109
>     (c1, c2, c3, c4, c5, dir) <- (,,,,,) <$> arbitrary <*> arbitrary
112d111
<     (hash, ign, k) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
113d111
<     lf ← arbitrary
114c112
<     (p, st, stch, stco) ← (,,,) <$> arbitrary <*> arbitrary
---
>     (hash, ign, k) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
114a113
>     lf <- arbitrary
114a114
>     (p, st, stch, stco) <- (,,,) <$> arbitrary <*> arbitrary
116d115
<     (tn, tf) ← (,) <$> arbitrary <*> arbitrary
117d115
<     (tsf, tss, totu) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
118c116
<     vs ← listOf arbitrary
---
>     (tn, tf) <- (,) <$> arbitrary <*> arbitrary
118a117
>     (tsf, tss, totu) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
118a118
>     vs <- listOf arbitrary
155c155
<   arbitrary = RTFC . toStrict . encode <$> (arbitrary ∷ Gen StateFile)
---
>   arbitrary = RTFC . toStrict . encode <$> (arbitrary :: Gen StateFile)
155a156
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
module Data.Rtorrent.StateFileSpec where

import           Control.Applicative ((<$>), (<*>), liftA2)
import           Data.BEncode
import           Data.ByteString (writeFile)
import           Data.ByteString.Lazy (toStrict)
import           Data.ByteString.UTF8 (ByteString, fromString)
import qualified Data.Map as M
import           Data.Rtorrent.StateFile
import           Data.Rtorrent.StateFile.Types
import           Data.Typeable
import           Prelude hiding (writeFile)
import           System.Directory
import           System.FilePath
import           System.IO.Temp
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck hiding (Result)

-- | Just like 'withRtorrentFiles' but allows us to specify the number
-- of files to use. When 0 or negative, no files are created.
withNRtorrentFiles ∷ Int → StateMod → (FilePath → IO a) → IO a
withNRtorrentFiles i f g = do
  t ← getTemporaryDirectory
  withTempDirectory t "rtorrent-state-test-dir" $ \d → do
    mapM_ (\x → makeStateFile $ d </> show x ++ ".rtorrent") [1 .. i]
    g d
  where
    genStateFileContent ∷ IO ByteString
    genStateFileContent = generate arbitrary >>= return . encodeState' . f

    makeStateFile ∷ FilePath → IO ()
    makeStateFile p = genStateFileContent >>= writeFile p

-- | Produces a temporary directory with some temporary, generated
-- .rtorrent files for the functions that need it.
withRtorrentFiles ∷ StateMod -- ^ Modifies the 'StateFile' before
                             -- writing in case we need specific
                             -- conditions
                  → (FilePath → IO a) → IO a
withRtorrentFiles f g =
  generate arbitrary >>= \(Positive i) → withNRtorrentFiles i f g

-- | IO version of 'shouldSatisfy'.
shouldSatisfyIO ∷ IO a → (a → Bool) → Expectation
t `shouldSatisfyIO` p = p <$> t `shouldReturn` True

spec ∷ Spec
spec = describe "StateFile" $ do
  modifyMaxSuccess (const 10) . prop "decode . encode = id" $
    \s@(StateFile {}) → let e = toStrict $ encode s
                        in decode e `shouldBe` Right s

  prop "overFiles and parse files work with 0 files"
    . withNRtorrentFiles 0 id $ \d →
    afterRunning d id `shouldSatisfyIO` const True

  prop "can stop all torrents" . withRtorrentFiles startTorrent $ \d →
    afterRunning d stopTorrent `shouldSatisfyIO` allStopped

  it "can stop 10000 torrents" . once
    . withNRtorrentFiles 10000 startTorrent $ \d →
    afterRunning d stopTorrent `shouldSatisfyIO` allStopped

  prop "can start all torrents" . withRtorrentFiles stopTorrent $ \d →
    afterRunning d startTorrent `shouldSatisfyIO` allStarted

  it "parseFile deals with inexistent path" $
    let f = "nofile-rtorrent-state" in
    parseFile f `shouldReturn`
    Left (f ++ ": openBinaryFile: does not exist (No such file or directory)")

  where
    allSatisfy ∷ M.Map FilePath (Result StateFile) -- ^ parsed files
               → (Result StateFile → Bool) -- ^ predicate
               → Bool
    allSatisfy m p = all (== True) . map p $ M.elems m

    -- similar to allSatisfy but fails if a parsing failure has occured
    allAre ∷ M.Map FilePath (Result StateFile)
           → (StateFile → Bool)
           → Bool
    allAre m p = allSatisfy m (\case Right x → p x
                                     Left _ → False )

    allStopped, allStarted ∷ M.Map FilePath (Result StateFile) → Bool
    allStopped m = allAre m ((== 0) . _state)
    allStarted m = allAre m ((== 1) . _state)

    afterRunning d f = overFilesIn d f >> parseFiles d

instance Arbitrary ByteStringUtf8 where
  arbitrary = BS8 . fromString <$> arbitrary

instance Arbitrary CustomSeeding where
  arbitrary = liftA2 CustomSeeding arbitrary arbitrary

instance Arbitrary StateFile where
  arbitrary = do
    (cdl, cds, cdul, cdus) ← (,,,) <$> arbitrary <*> arbitrary <*> arbitrary
                             <*> arbitrary
    (cd, cw, com) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    (cl, cs) ← (,) <$> arbitrary <*> arbitrary
    cust ← arbitrary
    (c1, c2, c3, c4, c5, dir) ← (,,,,,) <$> arbitrary <*> arbitrary
                                <*> arbitrary <*> arbitrary <*> arbitrary
                                <*> arbitrary
    (hash, ign, k) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    lf ← arbitrary
    (p, st, stch, stco) ← (,,,) <$> arbitrary <*> arbitrary
                          <*> arbitrary <*> arbitrary
    (tn, tf) ← (,) <$> arbitrary <*> arbitrary
    (tsf, tss, totu) ← (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    vs ← listOf arbitrary
    return StateFile { _chokeHeuristicsDownLeech = cdl
                     , _chokeHeuristicsDownSeed = cds
                     , _chokeHeuristicsUpLeech = cdul
                     , _chokeHeuristicsUpSeed = cdus
                     , _chunksDone = cd
                     , _chunksWanted = cw
                     , _complete = com
                     , _connectionLeech = cl
                     , _connectionSeed = cs
                     , _custom = cust
                     , _custom1 = c1
                     , _custom2 = c2
                     , _custom3 = c3
                     , _custom4 = c4
                     , _custom5 = c5
                     , _directory = dir
                     , _hashing = hash
                     , _ignoreCommands = ign
                     , _key = k
                     , _loadedFile = lf
                     , _priority = p
                     , _state = st
                     , _stateChanged = stch
                     , _stateCounter = stco
                     , _throttleName = tn
                     , _tiedToFile = tf
                     , _timestampFinished = tsf
                     , _timestampStarted = tss
                     , _totalUploaded = totu
                     , _views = vs
                     }

newtype RtorrentFileContent = RTFC ByteString
                            deriving (Show, Eq, Read, Typeable)

instance Arbitrary RtorrentFileContent where
  arbitrary = RTFC . toStrict . encode <$> (arbitrary ∷ Gen StateFile)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}
module Data.Rtorrent.StateFileSpec where

import           Control.Applicative ((<$>), (<*>), liftA2)
import           Data.BEncode
import           Data.ByteString (writeFile)
import           Data.ByteString.Lazy (toStrict)
import           Data.ByteString.UTF8 (ByteString, fromString)
import qualified Data.Map as M
import           Data.Rtorrent.StateFile
import           Data.Rtorrent.StateFile.Types
import           Data.Typeable
import           Prelude hiding (writeFile)
import           System.Directory
import           System.FilePath
import           System.IO.Temp
import           Test.Hspec
import           Test.Hspec.QuickCheck
import           Test.QuickCheck hiding (Result)

-- | Just like 'withRtorrentFiles' but allows us to specify the number
-- of files to use. When 0 or negative, no files are created.
withNRtorrentFiles :: Int -> StateMod -> (FilePath -> IO a) -> IO a
withNRtorrentFiles i f g = do
  t <- getTemporaryDirectory
  withTempDirectory t "rtorrent-state-test-dir" $ \d -> do
    mapM_ (\x -> makeStateFile $ d </> show x ++ ".rtorrent") [1 .. i]
    g d
  where
    genStateFileContent :: IO ByteString
    genStateFileContent = generate arbitrary >>= return . encodeState' . f

    makeStateFile :: FilePath -> IO ()
    makeStateFile p = genStateFileContent >>= writeFile p

-- | Produces a temporary directory with some temporary, generated
-- .rtorrent files for the functions that need it.
withRtorrentFiles :: StateMod -- ^ Modifies the 'StateFile' before
                             -- writing in case we need specific
                             -- conditions
                  -> (FilePath -> IO a) -> IO a
withRtorrentFiles f g =
  generate arbitrary >>= \(Positive i) -> withNRtorrentFiles i f g

-- | IO version of 'shouldSatisfy'.
shouldSatisfyIO :: IO a -> (a -> Bool) -> Expectation
t `shouldSatisfyIO` p = p <$> t `shouldReturn` True

spec :: Spec
spec = describe "StateFile" $ do
  modifyMaxSuccess (const 10) . prop "decode . encode = id" $
    \s@(StateFile {}) -> let e = toStrict $ encode s
                         in decode e `shouldBe` Right s

  prop "overFiles and parse files work with 0 files"
    . withNRtorrentFiles 0 id $ \d ->
    afterRunning d id `shouldSatisfyIO` const True

  prop "can stop all torrents" . withRtorrentFiles startTorrent $ \d ->
    afterRunning d stopTorrent `shouldSatisfyIO` allStopped

  it "can stop 10000 torrents" . once
    . withNRtorrentFiles 10000 startTorrent $ \d ->
    afterRunning d stopTorrent `shouldSatisfyIO` allStopped

  prop "can start all torrents" . withRtorrentFiles stopTorrent $ \d ->
    afterRunning d startTorrent `shouldSatisfyIO` allStarted

  it "parseFile deals with inexistent path" $
    let f = "nofile-rtorrent-state" in
    parseFile f `shouldReturn`
    Left (f ++ ": openBinaryFile: does not exist (No such file or directory)")

  where
    allSatisfy :: M.Map FilePath (Result StateFile) -- ^ parsed files
               -> (Result StateFile -> Bool) -- ^ predicate
               -> Bool
    allSatisfy m p = all (== True) . map p $ M.elems m

    -- similar to allSatisfy but fails if a parsing failure has occured
    allAre :: M.Map FilePath (Result StateFile)
           -> (StateFile -> Bool)
           -> Bool
    allAre m p = allSatisfy m (      Right x -> p x
                                     Left _ -> False )

    allStopped, allStarted :: M.Map FilePath (Result StateFile) -> Bool
    allStopped m = allAre m ((== 0) . _state)
    allStarted m = allAre m ((== 1) . _state)

    afterRunning d f = overFilesIn d f >> parseFiles d

instance Arbitrary ByteStringUtf8 where
  arbitrary = BS8 . fromString <$> arbitrary

instance Arbitrary CustomSeeding where
  arbitrary = liftA2 CustomSeeding arbitrary arbitrary

instance Arbitrary StateFile where
  arbitrary = do
    (cdl, cds, cdul, cdus) <- (,,,) <$> arbitrary <*> arbitrary <*> arbitrary
                             <*> arbitrary
    (cd, cw, com) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    (cl, cs) <- (,) <$> arbitrary <*> arbitrary
    cust <- arbitrary
    (c1, c2, c3, c4, c5, dir) <- (,,,,,) <$> arbitrary <*> arbitrary
                                <*> arbitrary <*> arbitrary <*> arbitrary
                                <*> arbitrary
    (hash, ign, k) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    lf <- arbitrary
    (p, st, stch, stco) <- (,,,) <$> arbitrary <*> arbitrary
                          <*> arbitrary <*> arbitrary
    (tn, tf) <- (,) <$> arbitrary <*> arbitrary
    (tsf, tss, totu) <- (,,) <$> arbitrary <*> arbitrary <*> arbitrary
    vs <- listOf arbitrary
    return StateFile { _chokeHeuristicsDownLeech = cdl
                     , _chokeHeuristicsDownSeed = cds
                     , _chokeHeuristicsUpLeech = cdul
                     , _chokeHeuristicsUpSeed = cdus
                     , _chunksDone = cd
                     , _chunksWanted = cw
                     , _complete = com
                     , _connectionLeech = cl
                     , _connectionSeed = cs
                     , _custom = cust
                     , _custom1 = c1
                     , _custom2 = c2
                     , _custom3 = c3
                     , _custom4 = c4
                     , _custom5 = c5
                     , _directory = dir
                     , _hashing = hash
                     , _ignoreCommands = ign
                     , _key = k
                     , _loadedFile = lf
                     , _priority = p
                     , _state = st
                     , _stateChanged = stch
                     , _stateCounter = stco
                     , _throttleName = tn
                     , _tiedToFile = tf
                     , _timestampFinished = tsf
                     , _timestampStarted = tss
                     , _totalUploaded = totu
                     , _views = vs
                     }

newtype RtorrentFileContent = RTFC ByteString
                            deriving (Show, Eq, Read, Typeable)

instance Arbitrary RtorrentFileContent where
  arbitrary = RTFC . toStrict . encode <$> (arbitrary :: Gen StateFile)

</pre>