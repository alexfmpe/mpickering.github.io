<a href="Class.hs17195338081517273377.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Class.hs18667296621536830211.out.html">next</a></br></br><pre>33d32
< class Monad μ ⇒ MonadFinish f μ | μ → f where
34c33
<   finish ∷ f → μ α
---
> class Monad μ => MonadFinish f μ | μ -> f where
34a34
>   finish :: f -> μ α
36c36
< instance Monad μ ⇒ MonadFinish f (FinishT f μ) where
---
> instance Monad μ => MonadFinish f (FinishT f μ) where
39d38
< instance MonadCont μ ⇒ MonadCont (FinishT f μ) where
40c39
<   callCC k = FinishT $ callCC $ \f → runFinishT $ k (lift . f . Right)
---
> instance MonadCont μ => MonadCont (FinishT f μ) where
40a40
>   callCC k = FinishT $ callCC $ \f -> runFinishT $ k (lift . f . Right)
42c42
< instance MonadError e μ ⇒ MonadError e (FinishT f μ) where
---
> instance MonadError e μ => MonadError e (FinishT f μ) where
46c46
< instance MonadAbort e μ ⇒ MonadAbort e (FinishT f μ) where
---
> instance MonadAbort e μ => MonadAbort e (FinishT f μ) where
49c49
< instance MonadRecover e μ ⇒ MonadRecover e (FinishT f μ) where
---
> instance MonadRecover e μ => MonadRecover e (FinishT f μ) where
52c52
< instance MonadReader r μ ⇒ MonadReader r (FinishT f μ) where
---
> instance MonadReader r μ => MonadReader r (FinishT f μ) where
56c56
< instance MonadState s μ ⇒ MonadState s (FinishT f μ) where
---
> instance MonadState s μ => MonadState s (FinishT f μ) where
60c60
< instance MonadWriter w μ ⇒ MonadWriter w (FinishT f μ) where
---
> instance MonadWriter w μ => MonadWriter w (FinishT f μ) where
63d62
<     (lr, w) ← listen $ runFinishT m
64c63
<     return $! fmap (, w) lr
---
>     (lr, w) <- listen $ runFinishT m
64a64
>     return $! fmap (  w) lr
66d65
<     lr ← runFinishT m
67c66
<     return $! either ((, id) . Left) (\(r, f) → (Right r, f)) lr
---
>     lr <- runFinishT m
67a67
>     return $! either ((  id) . Left) (\(r, f) -> (Right r, f)) lr
69c69
< instance MonadRWS r w s μ ⇒ MonadRWS r w s (FinishT f μ)
---
> instance MonadRWS r w s μ => MonadRWS r w s (FinishT f μ)
71c71
< instance MonadFinish f μ ⇒ MonadFinish f (IdentityT μ) where
---
> instance MonadFinish f μ => MonadFinish f (IdentityT μ) where
74c74
< instance MonadFinish f μ ⇒ MonadFinish f (ContT r μ) where
---
> instance MonadFinish f μ => MonadFinish f (ContT r μ) where
77c77
< instance MonadFinish f μ ⇒ MonadFinish f (MaybeT μ) where
---
> instance MonadFinish f μ => MonadFinish f (MaybeT μ) where
80c80
< instance (MonadFinish f μ, Error e) ⇒ MonadFinish f (ErrorT e μ) where
---
> instance (MonadFinish f μ, Error e) => MonadFinish f (ErrorT e μ) where
83c83
< instance MonadFinish f μ ⇒ MonadFinish f (AbortT e μ) where
---
> instance MonadFinish f μ => MonadFinish f (AbortT e μ) where
86c86
< instance MonadFinish f μ ⇒ MonadFinish f (ListT μ) where
---
> instance MonadFinish f μ => MonadFinish f (ListT μ) where
89c89
< instance MonadFinish f μ ⇒ MonadFinish f (ReaderT r μ) where
---
> instance MonadFinish f μ => MonadFinish f (ReaderT r μ) where
92c92
< instance MonadFinish f μ ⇒ MonadFinish f (L.StateT s μ) where
---
> instance MonadFinish f μ => MonadFinish f (L.StateT s μ) where
95c95
< instance MonadFinish f μ ⇒ MonadFinish f (S.StateT s μ) where
---
> instance MonadFinish f μ => MonadFinish f (S.StateT s μ) where
98c98
< instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (L.WriterT w μ) where
---
> instance (MonadFinish f μ, Monoid w) => MonadFinish f (L.WriterT w μ) where
101c101
< instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (S.WriterT w μ) where
---
> instance (MonadFinish f μ, Monoid w) => MonadFinish f (S.WriterT w μ) where
104c104
< instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (L.RWST r w s μ) where
---
> instance (MonadFinish f μ, Monoid w) => MonadFinish f (L.RWST r w s μ) where
107c107
< instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (S.RWST r w s μ) where
---
> instance (MonadFinish f μ, Monoid w) => MonadFinish f (S.RWST r w s μ) where
109a110
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Control.Monad.Finish.Class (
    MonadFinish(..)
  ) where

import Data.Monoid
import Control.Monad.Trans.Identity
import Control.Monad.Trans.Maybe
import Control.Monad.Cont
import Control.Monad.Error
import Control.Monad.List
import Control.Monad.Reader
import Control.Monad.State (MonadState(..))
import qualified Control.Monad.State.Lazy as L
import qualified Control.Monad.State.Strict as S
import Control.Monad.Writer (MonadWriter(..))
import qualified Control.Monad.Writer.Lazy as L
import qualified Control.Monad.Writer.Strict as S
import Control.Monad.RWS (MonadRWS)
import qualified Control.Monad.RWS.Lazy as L
import qualified Control.Monad.RWS.Strict as S
import Control.Monad.Abort
import Control.Monad.Trans.Finish (FinishT(..))
import qualified Control.Monad.Trans.Finish as F

class Monad μ ⇒ MonadFinish f μ | μ → f where
  finish ∷ f → μ α

instance Monad μ ⇒ MonadFinish f (FinishT f μ) where
  finish = F.finish

instance MonadCont μ ⇒ MonadCont (FinishT f μ) where
  callCC k = FinishT $ callCC $ \f → runFinishT $ k (lift . f . Right)

instance MonadError e μ ⇒ MonadError e (FinishT f μ) where
  throwError = lift . throwError
  catchError m h = FinishT $ catchError (runFinishT m) (runFinishT . h)

instance MonadAbort e μ ⇒ MonadAbort e (FinishT f μ) where
  abort = lift . abort

instance MonadRecover e μ ⇒ MonadRecover e (FinishT f μ) where
  recover m h = FinishT $ recover (runFinishT m) (runFinishT . h)

instance MonadReader r μ ⇒ MonadReader r (FinishT f μ) where
  ask = lift ask
  local f = FinishT . local f . runFinishT

instance MonadState s μ ⇒ MonadState s (FinishT f μ) where
  get = lift get
  put = lift . put

instance MonadWriter w μ ⇒ MonadWriter w (FinishT f μ) where
  tell = lift . tell
  listen m = FinishT $ do
    (lr, w) ← listen $ runFinishT m
    return $! fmap (, w) lr
  pass m = FinishT $ pass $ do
    lr ← runFinishT m
    return $! either ((, id) . Left) (\(r, f) → (Right r, f)) lr

instance MonadRWS r w s μ ⇒ MonadRWS r w s (FinishT f μ)

instance MonadFinish f μ ⇒ MonadFinish f (IdentityT μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (ContT r μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (MaybeT μ) where
  finish = lift . finish

instance (MonadFinish f μ, Error e) ⇒ MonadFinish f (ErrorT e μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (AbortT e μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (ListT μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (ReaderT r μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (L.StateT s μ) where
  finish = lift . finish

instance MonadFinish f μ ⇒ MonadFinish f (S.StateT s μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (L.WriterT w μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (S.WriterT w μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (L.RWST r w s μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) ⇒ MonadFinish f (S.RWST r w s μ) where
  finish = lift . finish

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Control.Monad.Finish.Class (
    MonadFinish(..)
  ) where

import Data.Monoid
import Control.Monad.Trans.Identity
import Control.Monad.Trans.Maybe
import Control.Monad.Cont
import Control.Monad.Error
import Control.Monad.List
import Control.Monad.Reader
import Control.Monad.State (MonadState(..))
import qualified Control.Monad.State.Lazy as L
import qualified Control.Monad.State.Strict as S
import Control.Monad.Writer (MonadWriter(..))
import qualified Control.Monad.Writer.Lazy as L
import qualified Control.Monad.Writer.Strict as S
import Control.Monad.RWS (MonadRWS)
import qualified Control.Monad.RWS.Lazy as L
import qualified Control.Monad.RWS.Strict as S
import Control.Monad.Abort
import Control.Monad.Trans.Finish (FinishT(..))
import qualified Control.Monad.Trans.Finish as F

class Monad μ => MonadFinish f μ | μ -> f where
  finish :: f -> μ α

instance Monad μ => MonadFinish f (FinishT f μ) where
  finish = F.finish

instance MonadCont μ => MonadCont (FinishT f μ) where
  callCC k = FinishT $ callCC $ \f -> runFinishT $ k (lift . f . Right)

instance MonadError e μ => MonadError e (FinishT f μ) where
  throwError = lift . throwError
  catchError m h = FinishT $ catchError (runFinishT m) (runFinishT . h)

instance MonadAbort e μ => MonadAbort e (FinishT f μ) where
  abort = lift . abort

instance MonadRecover e μ => MonadRecover e (FinishT f μ) where
  recover m h = FinishT $ recover (runFinishT m) (runFinishT . h)

instance MonadReader r μ => MonadReader r (FinishT f μ) where
  ask = lift ask
  local f = FinishT . local f . runFinishT

instance MonadState s μ => MonadState s (FinishT f μ) where
  get = lift get
  put = lift . put

instance MonadWriter w μ => MonadWriter w (FinishT f μ) where
  tell = lift . tell
  listen m = FinishT $ do
    (lr, w) <- listen $ runFinishT m
    return $! fmap (  w) lr
  pass m = FinishT $ pass $ do
    lr <- runFinishT m
    return $! either ((  id) . Left) (\(r, f) -> (Right r, f)) lr

instance MonadRWS r w s μ => MonadRWS r w s (FinishT f μ)

instance MonadFinish f μ => MonadFinish f (IdentityT μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (ContT r μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (MaybeT μ) where
  finish = lift . finish

instance (MonadFinish f μ, Error e) => MonadFinish f (ErrorT e μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (AbortT e μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (ListT μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (ReaderT r μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (L.StateT s μ) where
  finish = lift . finish

instance MonadFinish f μ => MonadFinish f (S.StateT s μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) => MonadFinish f (L.WriterT w μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) => MonadFinish f (S.WriterT w μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) => MonadFinish f (L.RWST r w s μ) where
  finish = lift . finish

instance (MonadFinish f μ, Monoid w) => MonadFinish f (S.RWST r w s μ) where
  finish = lift . finish


</pre>