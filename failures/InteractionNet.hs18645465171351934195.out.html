<a href="Interaction.hs1402331728356326671.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Interactive.hs8107833201051519025.out.html">next</a></br></br><pre>14c14
< class INet n where principalPort ∷ n → Port
---
> class INet n where principalPort :: n -> Port
21c21
< pair ∷ Pair a → (a,a)
---
> pair :: Pair a -> (a,a)
24c24
< activePair ∷ (View [Port] n, View v n, INet v) ⇒ Pattern n (Pair v)
---
> activePair :: (View [Port] n, View v n, INet v) => Pattern n (Pair v)
26c26
<     v1 ← node
---
>     v1 <- node
28c28
<     v2 ← nodeWith pp1
---
>     v2 <- nodeWith pp1
30a31
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts, MultiParamTypeClasses #-}
-- | Offers an 'activePair' pattern for convenient implementation of interaction nets.
module GraphRewriting.Pattern.InteractionNet where

import Prelude.Unicode
import Data.View
import Data.Functor
import GraphRewriting.Graph.Types
--import GraphRewriting.Graph.Read
import GraphRewriting.Pattern


-- | Index that identifies the principal port within the list of ports
class INet n where principalPort ∷ n → Port

-- | Instead of @(,)@ to save parentheses
data Pair a = a :-: a

instance Functor Pair where fmap f (x :-: y) = f x :-: f y

pair ∷ Pair a → (a,a)
pair (x :-: y) = (x,y)

activePair ∷ (View [Port] n, View v n, INet v) ⇒ Pattern n (Pair v)
activePair = linear $ do
    v1 ← node
    let pp1 = principalPort v1
    v2 ← nodeWith pp1
    require (pp1 ≡ principalPort v2)
    return (v1 :-: v2)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleContexts, MultiParamTypeClasses #-}
-- | Offers an 'activePair' pattern for convenient implementation of interaction nets.
module GraphRewriting.Pattern.InteractionNet where

import Prelude.Unicode
import Data.View
import Data.Functor
import GraphRewriting.Graph.Types
--import GraphRewriting.Graph.Read
import GraphRewriting.Pattern


-- | Index that identifies the principal port within the list of ports
class INet n where principalPort :: n -> Port

-- | Instead of @(,)@ to save parentheses
data Pair a = a :-: a

instance Functor Pair where fmap f (x :-: y) = f x :-: f y

pair :: Pair a -> (a,a)
pair (x :-: y) = (x,y)

activePair :: (View [Port] n, View v n, INet v) => Pattern n (Pair v)
activePair = linear $ do
    v1 <- node
    let pp1 = principalPort v1
    v2 <- nodeWith pp1
    require (pp1 ≡ principalPort v2)
    return (v1 :-: v2)

</pre>