<a href="Main.hs1073185695316824712.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs13564252281899894091.out.html">next</a></br></br><pre>326a327
> 
347d347
< 
349d348
< insertAtom after aid ch d = go xs
350d348
<     where
351d348
<       xs = drop 1 $ SM.toListFrom after d
352d348
<       go []     = d SM.|> (aid, mkTa ch)
353c349
<       go ((y,_):ys) | aid < y   = go xs
---
> insertAtom ::afteraid -> AtomIdd = go -> Char -> Document -> Document
353a350
> insertAtomwhere  after aid ch d = go xs
353a351
>     wherexs = drop 1 $ SM.toListFrom after d
353a352
>       xs =]drop 1 $ SM.toListFromSM.|> (aid, mkTach)d
353a353
>       go []y,_):=ysd SM.|>| aid (aidy , mkTa= go ch)
353a354
>       go ((y,_):ys) | aidotherwise y   = goSM.insertBefore           y (aid, mkTa ch) d
355d355
< 
356a357
> removeAtom ::a time= SM.adjust-> Timestamp(\(TextAtom-> Documentch _->) ->TextAtom ch (Just time)) a
358d358
< 
360c360
< getTimestamp :: MonadIO m => m Timestamp
---
> getTimestamp-- |'getTimestamp' returns the timestamp in milliseconds:: MonadIO m => m Timestamp
360a361
> getTimestamp ::= liftIO$ mliftM=> m(Timestamp . round . (*1000) . utcTimeToPOSIXSeconds) getCurrentTime
362d362
< 
369d368
< 
370a370
> t ::= id -> Text
372d371
< 
373a373
> mkClientId ::e =MonadIOliftIO mmodifyMVar=> Editor ->(unique ClientIde) $ \u -> let u' = succ u in return (u',u'))
375d374
< 
377c376
< pushToClients cs msg = do
---
> pushToClients :: MonadIOmsg = dom => Map ClientId Client -> J.Value -> m ()
377a377
> pushToClientsforM_ (M.elems msgcs) = do\c -> liftIO (writeChan (clientChan c) msg)
379d378
< 
381d379
< applyOps e ops = do
382d379
<   mapM_ (applyOp e) ops
383c380
<   (_, clients) <- liftIO $ readMVar (doc e)
---
> applyOps ::e ops= do m => Editor -> [Operation] -> m ()
383a381
> applyOpsmapM_ (eapplyOp = doe) ops
383a382
>   mapM_(_, clientsapplyOp) <-e)liftIO  $ readMVar (doc e)
383a383
>   (pushToClients_, clients) <-clients$$J.toJSON((OpBlockdoc e) ops)
385d384
< 
387d385
< applyOp e (InsertAfter a0 ai ch) = liftIO $ modifyMVar_ (doc e) $ \(d,clients) -> do
388d385
<                                        let d' = insertAtom a0 ai ch d
389d385
<                                        return (d',clients)
390d385
< applyOp e (Remove      a) = liftIO $ modifyMVar_ (doc e) $ \(d,clients) -> do
391d385
<                                        time <- getTimestamp
392d385
<                                        let d' = removeAtom a time d
393d385
<                                        return (d', clients)
394c386
< 
---
> applyOp ::e (MonadIOInsertAfter =>a0ai ch->) =OperationliftIO $ ->modifyMVar_ ()     (doc e) $ \(d,clients) -> do
394a387
> applyOp e (InsertAfter a0 ai ch) = liftIOlet$d'= insertAtomdoca0e)ai$ch(d,clients) -> do
394a388
>                               letreturn =d',clients) a0 ai ch d
394a389
> applyOp e (Remove      a) = liftIO $ modifyMVar_ (d',clientsdoc e) ) \(d,clients) -> do
394a390
> applyOp e (Remove      a) = liftIO $ modifyMVar_time <- getTimestampdoc e) $ \(d,clients) -> do
394a391
>                                                 timelet d'<-=getTimestampremoveAtom a time d
394a392
>                                                 letreturn =d', clients)a time d
394a393
>                                                 return (d', clients)
397c396
<   parseJSON (J.Object o) = OpBlock <$> o .: "actions"
---
> instanceparseJSON(J.Objecto) = OpBlockwhere  <$> o .: "actions"
397a397
>   parseJSON (J.Object o) = OpBlockmzero   <$> o .: "actions"
399d398
< 
400a400
> instancetoJSON J.ToJSON(OpBlock OpBlockops) = J.objectwhere   [ "actions" .= ops ]
402d401
< 
404d402
<     parseJSON (J.Object o) = do
405d402
<       a <- o .: "action"
406d402
<       case () of
407d402
<         () | a == t"insert" -> InsertAfter <$> o .: "after" <*> o .: "id" <*> o .: "ch"
408d402
<         () | a == t"remove" -> Remove <$> o .: "atom"
409c403
<         () | otherwise      -> mzero
---
> instanceparseJSON(J.Objecto) = dowhere
409a404
>     parseJSONa <- o .:J.Object"action"o) = do
409a405
>       acase<- o).:of"action"
409a406
>       case() ()aof== t"insert" -> InsertAfter <$> o .: "after" <*> o .: "id" <*> o .: "ch"
409a407
>         () | a == t"insert" -> InsertAfterRemove <$> o<$>.: o"atom" "after" <*> o .: "id" <*> o .: "ch"
409a408
>         () | aotherwise t"remove" -> Removemzero  <$> o .: "atom"
409a409
>     parseJSON) | otherwise_ = mzero     -> mzero
411d410
< 
413c412
<   toJSON (InsertAfter after aid ch) = J.object [ "action" .= t"insert", "after" .= after, "id" .= aid, "ch" .= ch ]
---
> instancetoJSON J.ToJSON(InsertAfterafter whereaid ch) = J.object [ "action" .= t"insert", "after" .= after, "id" .= aid, "ch" .= ch ]
413a413
>   toJSON (InsertAfterRemove aid) after aid ch) = J.object [ "action" .= t"insert", "after""id" .= .=aidafter]    , "id" .= aid, "ch" .= ch ]
415d414
< 
417c416
< 
---
> ---
420d418
< receiveJson = do
421d418
<   bs <- WS.receiveData
422d418
<   case J.decode' bs of
423c419
<     Nothing -> sendJson (jsonError "invalid message") >> receiveJson
---
> receiveJson ::= do a => WS.WebSockets WS.Hybi00 a
423a420
> receiveJsonbs <- WS.receiveData= do
423a421
>   bscase<-J.decode'bs of
423a422
>   caseNothing-> sendJson of  (jsonError "invalid message") >> receiveJson
423a423
>     NothingJust a  -> sendJsonreturn a (jsonError "invalid message") >> receiveJson
425d424
< 
427d425
< sendJson j = do
428c426
<     msg <- mkJsonMsg (J.toJSON j)
---
> sendJson ::j =J.ToJSONdo      a => a -> WS.WebSockets WS.Hybi00 ()
428a427
> sendJsonmsg <- =mkJsonMsg      (J.toJSON j)
428a428
>     msgWS.sendTextData<- mkJsonMsg((LTE.decodeUtf8J.toJSON j)   $ J.encode msg)
430d429
< 
432d430
< sendSinkJson sink j = do
433c431
<   msg <- mkJsonMsg (J.toJSON j)
---
> sendSinkJson ::sinkMonadIOj = do m, J.ToJSON a) => WS.Sink WS.Hybi00 -> a -> m ()
433a432
> sendSinkJsonmsg <- mkJsonMsg j(=J.toJSON     j)
433a433
>   msgliftIO<- mkJsonMsg$ WS.sendSinkJ.toJSONsink $j)WS.textData (LTE.decodeUtf8 $ J.encode msg)
435d434
< 
437d435
< mkJsonMsg :: MonadIO m => Value -> m J.Value
438d435
< mkJsonMsg (J.Object o) | not (HM.member "time" o) = do
439d435
<   t <- getTimestamp
440c436
<   return $ J.Object (HM.insert "time" (J.toJSON t) o)
---
> mkJsonMsg-- if we send an object, and it does not have a time field, inject it:: MonadIO m => Value -> m J.Value
440a437
> mkJsonMsg ::(J.Objectom =>| not(HM.member-> m J.Value"time" o) = do
440a438
> mkJsonMsgt <- getTimestampJ.Object o) | not (HM.member "time" o) = do
440a439
>   treturn<- getTimestamp$ J.Object (HM.insert "time" (J.toJSON t) o)
440a440
> mkJsonMsg $xJ.Object= return(HM.insertx         "time" (J.toJSON t) o)
442d441
< 
443a443
> jsonError ::msgString= J.object-> J.Value[ "error" .= msg ]
445d444
< 
447d445
< sockets y req
448d445
<   | WS.requestPath req == "/edit"  = accept editSocket
449d445
<   | otherwise                      = WS.rejectRequest req "Not found"
450c446
<   where
---
> sockets ::y req -> WS.Request -> WS.WebSockets WS.Hybi00 ()
450a447
> sockets| WS.requestPath req      req == "/edit"  = accept editSocket
450a448
>   | WS.requestPathotherwise      req == "/edit"  = acceptWS.rejectRequestreq "Not found"
450a449
>   |where                      = WS.rejectRequest req "Not found"
450a450
>   whereaccept a = WS.acceptRequest req >> a y
452d451
< 
454d452
< editSocket e = do
455d452
<   client <- mkClientId e
456d452
<   sendInit e client
457d452
<   sink <- WS.getSink
458d452
<   ch <- liftIO newChan
459d452
<   t <- liftIO getTimestamp
460d452
<   liftIO $ addClient e (Client t client ch)
461d452
<   tid <- liftIO . forkIO . forever $ do
462d452
<     acts <- readChan ch
463d452
<     sendSinkJson sink acts
464d452
<   forever $ do
465d452
<     (OpBlock acts) <- receiveJson
466d452
<     liftIO $ applyOps e acts
467d452
<     return ()
468c453
<   liftIO $ removeClient e client
---
> editSocket ::e =Editordo    -> WS.WebSockets WS.Hybi00 ()
468a454
> editSocketclient <-emkClientId= do      e
468a455
>   clientsendInit<-emkClientIdclient    e
468a456
>   sendInitsink <- WS.getSink client
468a457
>   sinkch <-<-liftIOnewChan
468a458
>   cht <-<-liftIOgetTimestamp
468a459
>   tliftIO<- liftIO$ addCliente (Client t client ch)
468a460
>   liftIOtid <- $liftIO. forkIO (Client. forever client$ do ch)
468a461
>   tidacts<- liftIO<- readChan forkIOch  . forever $ do
468a462
>     actssendSinkJson<- readChansinkchacts
468a463
>   forever$ do   sink acts
468a464
>   forever(OpBlock doacts) <- receiveJson
468a465
>     (liftIOOpBlock$ actsapplyOps) <- receiveJsone acts
468a466
>     liftIO $)applyOps e acts
468a467
>   liftIO$ (removeClient)           e client
468a468
>   liftIO $)removeClient e client
470d469
< 
471a471
> addClient ::e cEditor= modifyMVar_-> Client(doc-> IOe) ()\(d, m) -> return (d, M.insert (clientId c) c m)
473d472
< 
474a474
> removeClient ::e cid= modifyMVar_-> ClientId(doc-> IOe) ()\(d, m) -> return (d, M.delete cid m)
476d475
< 
478d476
< currentVersion :: Document -> Value
479d476
< currentVersion d =
480d476
<     let xs = SM.toList d
481d476
<         encodeAtom (a,v) = J.toJSON [ J.toJSON (aiTime a)
482d476
<                                     , J.toJSON (aiClient a)
483c477
<                                     , J.toJSON (taCh v)
---
> currentVersion-- encode the whole document:: Document -> Value
483a478
> currentVersion ::d =Document -> Value
483a479
> currentVersionlet xs = SM.toList =     d
483a480
>     let xsencodeAtom= SM.toList(a,vd = J.toJSON [ J.toJSON (aiTime a)
483a481
>         encodeAtom (a,v) = J.toJSON [ J.toJSON (aiTimeaiClient)a)
483a482
>                                     , J.toJSON (aiClienttaCh v)  a)
483a483
>                                     , J.toJSON (taChisJust)$ taRemoved v)
485c485
<                                     ]
---
>     in  J.toJSON $ map encodeAtom xs]
487d486
< 
489d487
< sendInit e c = do
490d487
<   d <- liftIO (readMVar $ doc e)
491c488
<   sendJson $ actions [ J.object [ "action" .= t"clientid", "clientId" .= c]
---
> sendInit ::e cEditor= do  -> ClientId -> WS.WebSockets WS.Hybi00 ()
491a489
> sendInitd <- liftIO c =(doreadMVar $ doc e)
491a490
>   dsendJson<- liftIO$ actionsreadMVar[ J.object doc e)[ "action" .= t"clientid", "clientId" .= c]
491a491
>   sendJson $ actions [ J.object [ "action" .= t"clientid""doc", "doc", "clientId".= currentVersion c]   (fst d) ]
494d493
< 
495a495
> actions :: [J.ValueJ.object] ->["actions"  .= as ]
496a497
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP                        #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverlappingInstances       #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeSynonymInstances       #-}

module Main where
import           Control.Monad.Trans
import qualified Data.ByteString                as BS
import           Data.FileEmbed
import           Data.Maybe                     (fromMaybe, isJust, isNothing)
import           Data.Monoid
import qualified Data.Text.Lazy                 as T
import           Language.Haskell.Interpreter   hiding (get)
import           Network.Wai.Handler.Warp       (Settings(..), defaultSettings, runSettings)
import           System.Directory               (createDirectoryIfMissing, getTemporaryDirectory)
import qualified Text.Blaze.Html5               as H
import           Text.Blaze.Html5.Attributes    (class_, href, rel, src, type_)
import           Yesod
import           Yesod.Static

import           Control.Applicative
import           Control.Concurrent
import           Control.Concurrent.MVar
import           Control.Monad                  (forM_, forever, liftM, mzero, void)
import           Control.Monad.Error.Class
import           Data.Aeson                     ((.:), (.=))
import           Data.Char                      (isUpper)
import qualified Data.Text                      as ST
import qualified Data.Text.Lazy.Encoding        as LTE
import           Data.Typeable
import           Network.Web.GHCLive.Display
import           Text.Blaze
import           Text.Blaze.Internal            (preEscapedText, text)
import           Text.Blaze.Renderer.Text       (renderMarkup)

import qualified Data.Aeson                     as J
import qualified Data.Aeson.Types               as J
import qualified Data.HashMap.Strict            as HM
import           Data.Map                       (Map)
import qualified Data.Map                       as M
import           Data.Text                      (Text)
import qualified Data.Text.IO                   as DTI
import           Data.Time.Clock                (UTCTime, getCurrentTime)
import           Data.Time.Clock.POSIX          (utcTimeToPOSIXSeconds)
import qualified Data.Vector                    as V
import           Network.Wai
import qualified Network.Wai.Handler.WebSockets as WS
import qualified Network.WebSockets             as WS


import           Prelude
import qualified SeqMap                         as SM
import           SignalHandlers

type Hint = Run (InterpreterT IO)
data Run m = Run { vRequest :: MVar (m ()) }

-- hint gives Either InterpreterError DisplayResult
jsonerror expr err = object ["expr" .= expr, "error" .= err]
jsonresult expr res = object ["expr" .= expr, "result" .= res]

data GHCLive = GHCLive
                { ref       :: MVar [J.Value] -- list of jsonerror or jsonresult Values
                , hint      :: Hint
                , editor    :: Editor
                , getStatic :: Static
                , tmpdir    :: FilePath
                }

data Editor = Editor
              { doc       :: MVar (Document, Map ClientId Client)
              , unique    :: MVar ClientId
              }

data Operation = InsertAfter AtomId AtomId Char
               | Remove AtomId
    deriving (Show, Eq, Ord)

data OpBlock = OpBlock [Operation] deriving (Show, Eq, Ord)

-- inefficiently, [(AtomId,TextAtom)]
type Document = SM.SeqMap AtomId TextAtom

-- Char, and whether this Char has been removed
data TextAtom = TextAtom
    { taCh      :: Char
    , taRemoved :: Maybe Timestamp
    } deriving Show

doc2string seqmap = map taCh $ filter (isNothing . taRemoved)  (map snd (SM.toList seqmap))

emptyDoc = SM.singleton (AtomId (Timestamp 0) (ClientId 0)) (TextAtom ' ' (Just (Timestamp 0)))

newtype Timestamp = Timestamp { unTimestamp :: Integer }
    deriving (Eq, Ord, Show, J.ToJSON, J.FromJSON)

newtype ClientId  = ClientId  { unClientId  :: Integer }
    deriving (Eq, Ord, Show, Enum, J.ToJSON, J.FromJSON)



data Client = Client
              { clientConnected :: Timestamp       -- timestamp when client connected
              , clientId        :: ClientId        -- unique id
              , clientChan      :: Chan J.Value    -- post outgoing messages to this chan
              }


mkTa :: Char -> TextAtom
mkTa ch = TextAtom ch Nothing

-- a Client never makes two IDs with the same timestamp
data AtomId    = AtomId
                  { aiTime :: Timestamp
                  , aiClient :: ClientId
                  } deriving (Show, Ord, Eq)

instance J.ToJSON AtomId where
   toJSON (AtomId (Timestamp t) (ClientId c)) = J.toJSON [t,c]

-- atoms encoded in json as [time,clientid]
instance J.FromJSON AtomId where
   parseJSON (J.Array v) | V.length v == 2 = AtomId <$> J.parseJSON (v V.! 0) <*> J.parseJSON (v V.! 1)
   parseJSON _ = mzero

staticDir = "static"

staticSiteFiles :: Static
staticSiteFiles = $(embed "static")

staticSite :: IO Static
staticSite = do
#ifdef DEVELOPMENT
  putStrLn ("using web files from: " ++ staticDir ++ "/")
  Static.staticDevel staticDir
#else
  putStrLn "using embedded web files"
  return $(embed "static")
#endif
-- switch to this when working on the javascript to prevent recompiling each time
-- staticSite :: IO Static
-- staticSite = staticDevel "static"

$(staticFiles "static")

mkYesod "GHCLive" [parseRoutes|
/        RootR   GET
/eval    EvalR   GET
/static  StaticR Static getStatic
/loader  LoaderR GET
/edit    EditR   GET
/results ResultsR GET
|]

instance Yesod GHCLive where
  makeSessionBackend _ = return Nothing

main :: IO ()
main = do
  -- filesystem setup
  tmp <- getTemporaryDirectory
  let cachedir = (tmp ++ "/ghclive/")
  createDirectoryIfMissing False cachedir
  BS.writeFile (cachedir ++ "Helper.hs") helperFile
  -- hint setup
  r  <- newMVar ([] :: [J.Value])
  h  <- newHint
  ss <- staticSite
  -- shared editor setup
  d  <- newMVar (emptyDoc, M.empty)
  u  <- newMVar (ClientId 0)
  let editor = Editor d u
  let master = GHCLive r h editor ss cachedir
      s      = defaultSettings
               { settingsPort = 3000
               , settingsIntercept = WS.intercept (sockets editor)
               }
  putStrLn $ "To use ghcLiVE, point your web browser to http://localhost:" ++ show (settingsPort s)
  runSettings s =<< (toWaiApp master :: IO Yesod.Application)

getLoaderR = do
  y <- getYesod
  cs <- liftIO $ readMVar (doc $ editor y)
  t <- liftIO . performHint (hint y) $ moduleHint (doc2string $ fst cs) (tmpdir y)
  case t of
    Left error -> jsonToRepJson $ cleanShow error
    Right displayres -> jsonToRepJson displayres

getRootR :: Handler RepHtml
getRootR = redirect EditR

getResultsR = do
  y <- getYesod
  h <- liftIO $ readMVar (ref y)
  jsonToRepJson h -- send ALL the state!

getEvalR :: Handler RepJson
getEvalR = do
  y <- getYesod
  expr <- fromMaybe "" <$> lookupGetParam "expr"
  liftIO $ putStr "expression is "
  liftIO $ DTI.putStrLn expr
  -- get Editor with getYesod and then document
  -- get the clients from the editor document (see applyOps for an example)
  (_, clients) <- liftIO $ readMVar (doc $ editor y)
  -- - call pushToClients with the clients and the JSON message you want to send, for example: object [ "refresh" .= True ]
  (t :: Either InterpreterError DisplayResult) <- liftIO . performHint (hint y) $ interpretHint ("displaying " ++ parens (ST.unpack expr))
  pushToClients clients $ object [ "refreshoutput" .= True ]
  case t of
    Left error -> do
             let jserr = jsonerror expr (cleanShow error)
             liftIO $ modifyMVar_ (ref y) $ \x -> return (x ++ [jserr])
             jsonToRepJson jserr
    Right displayres -> do
             let jsres = jsonresult expr displayres
             liftIO $ modifyMVar_ (ref y) $ \x -> return (x ++ [jsres])
             jsonToRepJson jsres

interpretHint :: (Typeable a, MonadInterpreter m) => String -> m a
interpretHint expr = set [ languageExtensions := (NoMonomorphismRestriction:ExtendedDefaultRules:glasgowExtensions) ] >> interpret expr as

moduleHint :: MonadInterpreter m => String -> FilePath -> m [ModuleName]
moduleHint ms cachedir = do
  -- save the file
  liftIO . putStrLn $ "calling cachedir with " ++ cachedir ++ " and " ++ (take 50 ms)
  liftIO $ cacheFile cachedir ms
  let allfiles = ["Helper.hs", "Main.hs"]
  reset
  liftIO $ putStrLn $ "will be loading " ++ (show $ map (cachedir ++) allfiles)
  loadModules $ map (cachedir ++) allfiles
  ms <- getLoadedModules
  setTopLevelModules ms
  setImports $ ["Prelude", "Network.Web.GHCLive.Display", "Text.Blaze"] ++ ms
  return ms

    -- eval :: String -> Interpret String
    -- eval "something" ~= interpret "(show something) (as :: String)"

{-----------------------------------------------------------------------------
    Interpreter abstraction
------------------------------------------------------------------------------}
newHint :: IO Hint
newHint = newRun $ \a -> void $ runInterpreter (liftIO restoreHandlers >> a)

performHint :: Hint -> InterpreterT IO a -> IO (Either InterpreterError a)
performHint hint act = perform hint $ (Right `liftM` act) `catchError` (return . Left)
{-
loadFile :: Hint -> FilePath -> IO ()
loadFile w filepath = perform w $ do

evaluate :: Hint -> String -> IO String
evaluate w expr = perform w $ do

-- stopInterpreter :: Hint -> IO ()
-}

-- | Thread responsible for "running" a monad that can do IO.
perform :: MonadIO m => Run m -> m a -> IO a
perform run act = do
    ref <- newEmptyMVar
    putMVar (vRequest run) $ do
        a <- act
        liftIO $ putMVar ref a
    takeMVar ref

newRun :: MonadIO m => (m () -> IO ()) -> IO (Run m)
newRun f = do
    vRequest <- newEmptyMVar
    forkIO . f . forever $ do
        act <- liftIO $ takeMVar vRequest
        act
    return Run { vRequest = vRequest }


cleanShow    :: InterpreterError -> String
cleanShow ie = case ie of
                 UnknownError e -> "UnknownError\n" ++ e
                 WontCompile es -> unlines $ map errMsg es
                 NotAllowed e -> "NotAllowed\n" ++ e
                 GhcException e -> "GhcException\n" ++ e

cacheFile cachedir f = do
  putStrLn $ "cachedir is " ++ cachedir
  putStrLn $ "text is " ++ (take 50 f)
  writeFile (cachedir ++ "Main.hs") f
  return "Main.hs"

liveLayout :: Widget -> Handler RepHtml
liveLayout w = do
  p <- widgetToPageContent w
  hamletToRepHtml [hamlet|$newline never
      $doctype 5
      <html>
        <head>
          <title>GHCLive
          ^{pageHead p}
        <body>
          ^{pageBody p}
    |]

helperFile :: BS.ByteString
helperFile = $(embedFile "cache/Helper.hs")

{-- shared editor --}
getEditR :: Handler RepHtml
getEditR = liveLayout $ do
             addScript     (StaticR jquery_js)
             addScript     (StaticR codemirror_lib_codemirror_js)
             addScript     (StaticR codemirror_mode_haskell_haskell_js)
             addScript     (StaticR document_js)
             addStylesheet (StaticR codemirror_lib_codemirror_css)
             addStylesheet (StaticR foo_css)
             addScript     (StaticR jquery_ui_1_8_23_custom_min_js)
             addStylesheet (StaticR jquery_ui_1_8_23_custom_css)
             addScript     (StaticR jquery_layout_latest_js)
             addScript     (StaticR jquery_scrollTo_js)
             addScript     (StaticR ghclive_js)
             toWidget [lucius|
                         #editor {
                           width: 800px;
                           height: 500px;
                         }
                      |]
             [whamlet|$newline never
               <div id="editor-pane" class="ui-layout-north">
                 <div class="ui-layout-content">
                   <textarea #editor>
                 <form action="#">
                   <input type=submit value="Load shared document" #load>
               <div class="ui-layout-center">
                 <div #editormessages>
                 <div #output class="ui-layout-content">
               <div class="ui-layout-south">
                 <form id="evalform" action="#">
                   <div id="eval-panel">
                     <input type=text placeholder="Enter a Haskell expression" #expr>
               <div class="ui-layout-west">
               <div class="ui-layout-east">
             |]

insertAtom :: AtomId -> AtomId -> Char -> Document -> Document
insertAtom after aid ch d = go xs
    where
      xs = drop 1 $ SM.toListFrom after d
      go []     = d SM.|> (aid, mkTa ch)
      go ((y,_):ys) | aid < y   = go xs
                    | otherwise = SM.insertBefore y (aid, mkTa ch) d

removeAtom :: AtomId -> Timestamp -> Document -> Document
removeAtom a time = SM.adjust (\(TextAtom ch _) -> TextAtom ch (Just time)) a

-- |'getTimestamp' returns the timestamp in milliseconds
getTimestamp :: MonadIO m => m Timestamp
getTimestamp = liftIO $ liftM (Timestamp . round . (*1000) . utcTimeToPOSIXSeconds) getCurrentTime

{-
collectGarbage :: Integer -> Document -> Document
collectGarbage time d = SM.removeAll ks d
    where
      ks = filter ((< time) . aiTime) (SM.keys d)
-}

t :: Text -> Text
t = id

mkClientId :: MonadIO m => Editor -> m ClientId
mkClientId e = liftIO (modifyMVar (unique e) $ \u -> let u' = succ u in return (u',u'))

pushToClients :: MonadIO m => Map ClientId Client -> J.Value -> m ()
pushToClients cs msg = do
  forM_ (M.elems cs) $ \c -> liftIO (writeChan (clientChan c) msg)

applyOps :: MonadIO m => Editor -> [Operation] -> m ()
applyOps e ops = do
  mapM_ (applyOp e) ops
  (_, clients) <- liftIO $ readMVar (doc e)
  pushToClients clients $ J.toJSON (OpBlock ops)

applyOp :: MonadIO m => Editor -> Operation -> m ()
applyOp e (InsertAfter a0 ai ch) = liftIO $ modifyMVar_ (doc e) $ \(d,clients) -> do
                                       let d' = insertAtom a0 ai ch d
                                       return (d',clients)
applyOp e (Remove      a) = liftIO $ modifyMVar_ (doc e) $ \(d,clients) -> do
                                       time <- getTimestamp
                                       let d' = removeAtom a time d
                                       return (d', clients)


instance J.FromJSON OpBlock where
  parseJSON (J.Object o) = OpBlock <$> o .: "actions"
  parseJSON _            = mzero

instance J.ToJSON OpBlock where
  toJSON (OpBlock ops) = J.object [ "actions" .= ops ]

instance J.FromJSON Operation where
    parseJSON (J.Object o) = do
      a <- o .: "action"
      case () of
        () | a == t"insert" -> InsertAfter <$> o .: "after" <*> o .: "id" <*> o .: "ch"
        () | a == t"remove" -> Remove <$> o .: "atom"
        () | otherwise      -> mzero
    parseJSON _ = mzero

instance J.ToJSON Operation where
  toJSON (InsertAfter after aid ch) = J.object [ "action" .= t"insert", "after" .= after, "id" .= aid, "ch" .= ch ]
  toJSON (Remove aid)               = J.object [ "action" .= t"remove", "id" .= aid]

---


receiveJson :: J.FromJSON a => WS.WebSockets WS.Hybi00 a
receiveJson = do
  bs <- WS.receiveData
  case J.decode' bs of
    Nothing -> sendJson (jsonError "invalid message") >> receiveJson
    Just a  -> return a

sendJson :: J.ToJSON a => a -> WS.WebSockets WS.Hybi00 ()
sendJson j = do
    msg <- mkJsonMsg (J.toJSON j)
    WS.sendTextData (LTE.decodeUtf8 $ J.encode msg)

sendSinkJson :: (MonadIO m, J.ToJSON a) => WS.Sink WS.Hybi00 -> a -> m ()
sendSinkJson sink j = do
  msg <- mkJsonMsg (J.toJSON j)
  liftIO $ WS.sendSink sink $ WS.textData (LTE.decodeUtf8 $ J.encode msg)

-- if we send an object, and it does not have a time field, inject it
mkJsonMsg :: MonadIO m => Value -> m J.Value
mkJsonMsg (J.Object o) | not (HM.member "time" o) = do
  t <- getTimestamp
  return $ J.Object (HM.insert "time" (J.toJSON t) o)
mkJsonMsg x = return x

jsonError :: String -> J.Value
jsonError msg = J.object [ "error" .= msg ]

sockets :: Editor -> WS.Request -> WS.WebSockets WS.Hybi00 ()
sockets y req
  | WS.requestPath req == "/edit"  = accept editSocket
  | otherwise                      = WS.rejectRequest req "Not found"
  where
    accept a = WS.acceptRequest req >> a y

editSocket :: Editor -> WS.WebSockets WS.Hybi00 ()
editSocket e = do
  client <- mkClientId e
  sendInit e client
  sink <- WS.getSink
  ch <- liftIO newChan
  t <- liftIO getTimestamp
  liftIO $ addClient e (Client t client ch)
  tid <- liftIO . forkIO . forever $ do
    acts <- readChan ch
    sendSinkJson sink acts
  forever $ do
    (OpBlock acts) <- receiveJson
    liftIO $ applyOps e acts
    return ()
  liftIO $ removeClient e client
  return ()

addClient :: Editor -> Client -> IO ()
addClient e c = modifyMVar_ (doc e) $ \(d, m) -> return (d, M.insert (clientId c) c m)

removeClient :: Editor -> ClientId -> IO ()
removeClient e cid = modifyMVar_ (doc e) $ \(d, m) -> return (d, M.delete cid m)

-- encode the whole document
currentVersion :: Document -> Value
currentVersion d =
    let xs = SM.toList d
        encodeAtom (a,v) = J.toJSON [ J.toJSON (aiTime a)
                                    , J.toJSON (aiClient a)
                                    , J.toJSON (taCh v)
                                    , J.toJSON (isJust $ taRemoved v)
                                    ]
    in  J.toJSON $ map encodeAtom xs

sendInit :: Editor -> ClientId -> WS.WebSockets WS.Hybi00 ()
sendInit e c = do
  d <- liftIO (readMVar $ doc e)
  sendJson $ actions [ J.object [ "action" .= t"clientid", "clientId" .= c]
                     , J.object [ "action" .= t"doc", "doc" .= currentVersion (fst d) ]
                     ]

actions :: [J.Value] -> J.Value
actions as = J.object ["actions" .= as ]
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP                        #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverlappingInstances       #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeSynonymInstances       #-}

module Main where
import           Control.Monad.Trans
import qualified Data.ByteString                as BS
import           Data.FileEmbed
import           Data.Maybe                     (fromMaybe, isJust, isNothing)
import           Data.Monoid
import qualified Data.Text.Lazy                 as T
import           Language.Haskell.Interpreter   hiding (get)
import           Network.Wai.Handler.Warp       (Settings(..), defaultSettings, runSettings)
import           System.Directory               (createDirectoryIfMissing, getTemporaryDirectory)
import qualified Text.Blaze.Html5               as H
import           Text.Blaze.Html5.Attributes    (class_, href, rel, src, type_)
import           Yesod
import           Yesod.Static

import           Control.Applicative
import           Control.Concurrent
import           Control.Concurrent.MVar
import           Control.Monad                  (forM_, forever, liftM, mzero, void)
import           Control.Monad.Error.Class
import           Data.Aeson                     ((.:), (.=))
import           Data.Char                      (isUpper)
import qualified Data.Text                      as ST
import qualified Data.Text.Lazy.Encoding        as LTE
import           Data.Typeable
import           Network.Web.GHCLive.Display
import           Text.Blaze
import           Text.Blaze.Internal            (preEscapedText, text)
import           Text.Blaze.Renderer.Text       (renderMarkup)

import qualified Data.Aeson                     as J
import qualified Data.Aeson.Types               as J
import qualified Data.HashMap.Strict            as HM
import           Data.Map                       (Map)
import qualified Data.Map                       as M
import           Data.Text                      (Text)
import qualified Data.Text.IO                   as DTI
import           Data.Time.Clock                (UTCTime, getCurrentTime)
import           Data.Time.Clock.POSIX          (utcTimeToPOSIXSeconds)
import qualified Data.Vector                    as V
import           Network.Wai
import qualified Network.Wai.Handler.WebSockets as WS
import qualified Network.WebSockets             as WS


import           Prelude
import qualified SeqMap                         as SM
import           SignalHandlers

type Hint = Run (InterpreterT IO)
data Run m = Run { vRequest :: MVar (m ()) }

-- hint gives Either InterpreterError DisplayResult
jsonerror expr err = object ["expr" .= expr, "error" .= err]
jsonresult expr res = object ["expr" .= expr, "result" .= res]

data GHCLive = GHCLive
                { ref       :: MVar [J.Value] -- list of jsonerror or jsonresult Values
                , hint      :: Hint
                , editor    :: Editor
                , getStatic :: Static
                , tmpdir    :: FilePath
                }

data Editor = Editor
              { doc       :: MVar (Document, Map ClientId Client)
              , unique    :: MVar ClientId
              }

data Operation = InsertAfter AtomId AtomId Char
               | Remove AtomId
    deriving (Show, Eq, Ord)

data OpBlock = OpBlock [Operation] deriving (Show, Eq, Ord)

-- inefficiently, [(AtomId,TextAtom)]
type Document = SM.SeqMap AtomId TextAtom

-- Char, and whether this Char has been removed
data TextAtom = TextAtom
    { taCh      :: Char
    , taRemoved :: Maybe Timestamp
    } deriving Show

doc2string seqmap = map taCh $ filter (isNothing . taRemoved)  (map snd (SM.toList seqmap))

emptyDoc = SM.singleton (AtomId (Timestamp 0) (ClientId 0)) (TextAtom ' ' (Just (Timestamp 0)))

newtype Timestamp = Timestamp { unTimestamp :: Integer }
    deriving (Eq, Ord, Show, J.ToJSON, J.FromJSON)

newtype ClientId  = ClientId  { unClientId  :: Integer }
    deriving (Eq, Ord, Show, Enum, J.ToJSON, J.FromJSON)



data Client = Client
              { clientConnected :: Timestamp       -- timestamp when client connected
              , clientId        :: ClientId        -- unique id
              , clientChan      :: Chan J.Value    -- post outgoing messages to this chan
              }


mkTa :: Char -> TextAtom
mkTa ch = TextAtom ch Nothing

-- a Client never makes two IDs with the same timestamp
data AtomId    = AtomId
                  { aiTime :: Timestamp
                  , aiClient :: ClientId
                  } deriving (Show, Ord, Eq)

instance J.ToJSON AtomId where
   toJSON (AtomId (Timestamp t) (ClientId c)) = J.toJSON [t,c]

-- atoms encoded in json as [time,clientid]
instance J.FromJSON AtomId where
   parseJSON (J.Array v) | V.length v == 2 = AtomId <$> J.parseJSON (v V.! 0) <*> J.parseJSON (v V.! 1)
   parseJSON _ = mzero

staticDir = "static"

staticSiteFiles :: Static
staticSiteFiles = $(embed "static")

staticSite :: IO Static
staticSite = do
#ifdef DEVELOPMENT
  putStrLn ("using web files from: " ++ staticDir ++ "/")
  Static.staticDevel staticDir
#else
  putStrLn "using embedded web files"
  return $(embed "static")
#endif
-- switch to this when working on the javascript to prevent recompiling each time
-- staticSite :: IO Static
-- staticSite = staticDevel "static"

$(staticFiles "static")

mkYesod "GHCLive" [parseRoutes|
/        RootR   GET
/eval    EvalR   GET
/static  StaticR Static getStatic
/loader  LoaderR GET
/edit    EditR   GET
/results ResultsR GET
|]

instance Yesod GHCLive where
  makeSessionBackend _ = return Nothing

main :: IO ()
main = do
  -- filesystem setup
  tmp <- getTemporaryDirectory
  let cachedir = (tmp ++ "/ghclive/")
  createDirectoryIfMissing False cachedir
  BS.writeFile (cachedir ++ "Helper.hs") helperFile
  -- hint setup
  r  <- newMVar ([] :: [J.Value])
  h  <- newHint
  ss <- staticSite
  -- shared editor setup
  d  <- newMVar (emptyDoc, M.empty)
  u  <- newMVar (ClientId 0)
  let editor = Editor d u
  let master = GHCLive r h editor ss cachedir
      s      = defaultSettings
               { settingsPort = 3000
               , settingsIntercept = WS.intercept (sockets editor)
               }
  putStrLn $ "To use ghcLiVE, point your web browser to http://localhost:" ++ show (settingsPort s)
  runSettings s =<< (toWaiApp master :: IO Yesod.Application)

getLoaderR = do
  y <- getYesod
  cs <- liftIO $ readMVar (doc $ editor y)
  t <- liftIO . performHint (hint y) $ moduleHint (doc2string $ fst cs) (tmpdir y)
  case t of
    Left error -> jsonToRepJson $ cleanShow error
    Right displayres -> jsonToRepJson displayres

getRootR :: Handler RepHtml
getRootR = redirect EditR

getResultsR = do
  y <- getYesod
  h <- liftIO $ readMVar (ref y)
  jsonToRepJson h -- send ALL the state!

getEvalR :: Handler RepJson
getEvalR = do
  y <- getYesod
  expr <- fromMaybe "" <$> lookupGetParam "expr"
  liftIO $ putStr "expression is "
  liftIO $ DTI.putStrLn expr
  -- get Editor with getYesod and then document
  -- get the clients from the editor document (see applyOps for an example)
  (_, clients) <- liftIO $ readMVar (doc $ editor y)
  -- - call pushToClients with the clients and the JSON message you want to send, for example: object [ "refresh" .= True ]
  (t :: Either InterpreterError DisplayResult) <- liftIO . performHint (hint y) $ interpretHint ("displaying " ++ parens (ST.unpack expr))
  pushToClients clients $ object [ "refreshoutput" .= True ]
  case t of
    Left error -> do
             let jserr = jsonerror expr (cleanShow error)
             liftIO $ modifyMVar_ (ref y) $ \x -> return (x ++ [jserr])
             jsonToRepJson jserr
    Right displayres -> do
             let jsres = jsonresult expr displayres
             liftIO $ modifyMVar_ (ref y) $ \x -> return (x ++ [jsres])
             jsonToRepJson jsres

interpretHint :: (Typeable a, MonadInterpreter m) => String -> m a
interpretHint expr = set [ languageExtensions := (NoMonomorphismRestriction:ExtendedDefaultRules:glasgowExtensions) ] >> interpret expr as

moduleHint :: MonadInterpreter m => String -> FilePath -> m [ModuleName]
moduleHint ms cachedir = do
  -- save the file
  liftIO . putStrLn $ "calling cachedir with " ++ cachedir ++ " and " ++ (take 50 ms)
  liftIO $ cacheFile cachedir ms
  let allfiles = ["Helper.hs", "Main.hs"]
  reset
  liftIO $ putStrLn $ "will be loading " ++ (show $ map (cachedir ++) allfiles)
  loadModules $ map (cachedir ++) allfiles
  ms <- getLoadedModules
  setTopLevelModules ms
  setImports $ ["Prelude", "Network.Web.GHCLive.Display", "Text.Blaze"] ++ ms
  return ms

    -- eval :: String -> Interpret String
    -- eval "something" ~= interpret "(show something) (as :: String)"

{-----------------------------------------------------------------------------
    Interpreter abstraction
------------------------------------------------------------------------------}
newHint :: IO Hint
newHint = newRun $ \a -> void $ runInterpreter (liftIO restoreHandlers >> a)

performHint :: Hint -> InterpreterT IO a -> IO (Either InterpreterError a)
performHint hint act = perform hint $ (Right `liftM` act) `catchError` (return . Left)
{-
loadFile :: Hint -> FilePath -> IO ()
loadFile w filepath = perform w $ do

evaluate :: Hint -> String -> IO String
evaluate w expr = perform w $ do

-- stopInterpreter :: Hint -> IO ()
-}

-- | Thread responsible for "running" a monad that can do IO.
perform :: MonadIO m => Run m -> m a -> IO a
perform run act = do
    ref <- newEmptyMVar
    putMVar (vRequest run) $ do
        a <- act
        liftIO $ putMVar ref a
    takeMVar ref

newRun :: MonadIO m => (m () -> IO ()) -> IO (Run m)
newRun f = do
    vRequest <- newEmptyMVar
    forkIO . f . forever $ do
        act <- liftIO $ takeMVar vRequest
        act
    return Run { vRequest = vRequest }


cleanShow    :: InterpreterError -> String
cleanShow ie = case ie of
                 UnknownError e -> "UnknownError\n" ++ e
                 WontCompile es -> unlines $ map errMsg es
                 NotAllowed e -> "NotAllowed\n" ++ e
                 GhcException e -> "GhcException\n" ++ e

cacheFile cachedir f = do
  putStrLn $ "cachedir is " ++ cachedir
  putStrLn $ "text is " ++ (take 50 f)
  writeFile (cachedir ++ "Main.hs") f
  return "Main.hs"

liveLayout :: Widget -> Handler RepHtml
liveLayout w = do
  p <- widgetToPageContent w
  hamletToRepHtml [hamlet|$newline never
      $doctype 5
      <html>
        <head>
          <title>GHCLive
          ^{pageHead p}
        <body>
          ^{pageBody p}
    |]

helperFile :: BS.ByteString
helperFile = $(embedFile "cache/Helper.hs")

{-- shared editor --}
getEditR :: Handler RepHtml
getEditR = liveLayout $ do
             addScript     (StaticR jquery_js)
             addScript     (StaticR codemirror_lib_codemirror_js)
             addScript     (StaticR codemirror_mode_haskell_haskell_js)
             addScript     (StaticR document_js)
             addStylesheet (StaticR codemirror_lib_codemirror_css)
             addStylesheet (StaticR foo_css)
             addScript     (StaticR jquery_ui_1_8_23_custom_min_js)
             addStylesheet (StaticR jquery_ui_1_8_23_custom_css)
             addScript     (StaticR jquery_layout_latest_js)
             addScript     (StaticR jquery_scrollTo_js)
             addScript     (StaticR ghclive_js)
             toWidget [lucius|
                         #editor {

                           width: 800px;
                           height: 500px;
                         }
                      |]
             [whamlet|$newline never
               <div id="editor-pane" class="ui-layout-north">
                 <div class="ui-layout-content">
                   <textarea #editor>
                 <form action="#">
                   <input type=submit value="Load shared document" #load>
               <div class="ui-layout-center">
                 <div #editormessages>
                 <div #output class="ui-layout-content">
               <div class="ui-layout-south">
                 <form id="evalform" action="#">
                   <div id="eval-panel">
                     <input type=text placeholder="Enter a Haskell expression" #expr>
               <div class="ui-layout-west">
               <div class="ui-layout-east">
             |]
insertAtom :: AtomId -> AtomId -> Char -> Document -> Document
insertAtom ::afteraid -> AtomIdd = go -> Char -> Document -> Document
insertAtomwhere  after aid ch d = go xs
    wherexs = drop 1 $ SM.toListFrom after d
      xs =]drop 1 $ SM.toListFromSM.|> (aid, mkTach)d
      go []y,_):=ysd SM.|>| aid (aidy , mkTa= go ch)
      go ((y,_):ys) | aidotherwise y   = goSM.insertBefore           y (aid, mkTa ch) d
                    | otherwise = SM.insertBefore y (aid, mkTa ch) d
removeAtom :: AtomId -> Timestamp -> Document -> Document
removeAtom ::a time= SM.adjust-> Timestamp(\(TextAtom-> Documentch _->) ->TextAtom ch (Just time)) a
removeAtom a time = SM.adjust (\(TextAtom ch _) -> TextAtom ch (Just time)) a
-- |'getTimestamp' returns the timestamp in milliseconds
getTimestamp-- |'getTimestamp' returns the timestamp in milliseconds:: MonadIO m => m Timestamp
getTimestamp ::= liftIO$ mliftM=> m(Timestamp . round . (*1000) . utcTimeToPOSIXSeconds) getCurrentTime
getTimestamp = liftIO $ liftM (Timestamp . round . (*1000) . utcTimeToPOSIXSeconds) getCurrentTime
{-
collectGarbage :: Integer -> Document -> Document
collectGarbage time d = SM.removeAll ks d
    where
      ks = filter ((< time) . aiTime) (SM.keys d)
-}
t :: Text -> Text
t ::= id -> Text
t = id
mkClientId :: MonadIO m => Editor -> m ClientId
mkClientId ::e =MonadIOliftIO mmodifyMVar=> Editor ->(unique ClientIde) $ \u -> let u' = succ u in return (u',u'))
mkClientId e = liftIO (modifyMVar (unique e) $ \u -> let u' = succ u in return (u',u'))
pushToClients :: MonadIO m => Map ClientId Client -> J.Value -> m ()
pushToClients :: MonadIOmsg = dom => Map ClientId Client -> J.Value -> m ()
pushToClientsforM_ (M.elems msgcs) = do\c -> liftIO (writeChan (clientChan c) msg)
  forM_ (M.elems cs) $ \c -> liftIO (writeChan (clientChan c) msg)
applyOps :: MonadIO m => Editor -> [Operation] -> m ()
applyOps ::e ops= do m => Editor -> [Operation] -> m ()
applyOpsmapM_ (eapplyOp = doe) ops
  mapM_(_, clientsapplyOp) <-e)liftIO  $ readMVar (doc e)
  (pushToClients_, clients) <-clients$$J.toJSON((OpBlockdoc e) ops)
  pushToClients clients $ J.toJSON (OpBlock ops)
applyOp :: MonadIO m => Editor -> Operation -> m ()
applyOp ::e (MonadIOInsertAfter =>a0ai ch->) =OperationliftIO $ ->modifyMVar_ ()     (doc e) $ \(d,clients) -> do
applyOp e (InsertAfter a0 ai ch) = liftIOlet$d'= insertAtomdoca0e)ai$ch(d,clients) -> do
                              letreturn =d',clients) a0 ai ch d
applyOp e (Remove      a) = liftIO $ modifyMVar_ (d',clientsdoc e) ) \(d,clients) -> do
applyOp e (Remove      a) = liftIO $ modifyMVar_time <- getTimestampdoc e) $ \(d,clients) -> do
                                                timelet d'<-=getTimestampremoveAtom a time d
                                                letreturn =d', clients)a time d
                                                return (d', clients)

instance J.FromJSON OpBlock where
instanceparseJSON(J.Objecto) = OpBlockwhere  <$> o .: "actions"
  parseJSON (J.Object o) = OpBlockmzero   <$> o .: "actions"
  parseJSON _            = mzero
instance J.ToJSON OpBlock where
instancetoJSON J.ToJSON(OpBlock OpBlockops) = J.objectwhere   [ "actions" .= ops ]
  toJSON (OpBlock ops) = J.object [ "actions" .= ops ]
instance J.FromJSON Operation where
instanceparseJSON(J.Objecto) = dowhere
    parseJSONa <- o .:J.Object"action"o) = do
      acase<- o).:of"action"
      case() ()aof== t"insert" -> InsertAfter <$> o .: "after" <*> o .: "id" <*> o .: "ch"
        () | a == t"insert" -> InsertAfterRemove <$> o<$>.: o"atom" "after" <*> o .: "id" <*> o .: "ch"
        () | aotherwise t"remove" -> Removemzero  <$> o .: "atom"
    parseJSON) | otherwise_ = mzero     -> mzero
    parseJSON _ = mzero
instance J.ToJSON Operation where
instancetoJSON J.ToJSON(InsertAfterafter whereaid ch) = J.object [ "action" .= t"insert", "after" .= after, "id" .= aid, "ch" .= ch ]
  toJSON (InsertAfterRemove aid) after aid ch) = J.object [ "action" .= t"insert", "after""id" .= .=aidafter]    , "id" .= aid, "ch" .= ch ]
  toJSON (Remove aid)               = J.object [ "action" .= t"remove", "id" .= aid]
---
---

receiveJson :: J.FromJSON a => WS.WebSockets WS.Hybi00 a
receiveJson ::= do a => WS.WebSockets WS.Hybi00 a
receiveJsonbs <- WS.receiveData= do
  bscase<-J.decode'bs of
  caseNothing-> sendJson of  (jsonError "invalid message") >> receiveJson
    NothingJust a  -> sendJsonreturn a (jsonError "invalid message") >> receiveJson
    Just a  -> return a
sendJson :: J.ToJSON a => a -> WS.WebSockets WS.Hybi00 ()
sendJson ::j =J.ToJSONdo      a => a -> WS.WebSockets WS.Hybi00 ()
sendJsonmsg <- =mkJsonMsg      (J.toJSON j)
    msgWS.sendTextData<- mkJsonMsg((LTE.decodeUtf8J.toJSON j)   $ J.encode msg)
    WS.sendTextData (LTE.decodeUtf8 $ J.encode msg)
sendSinkJson :: (MonadIO m, J.ToJSON a) => WS.Sink WS.Hybi00 -> a -> m ()
sendSinkJson ::sinkMonadIOj = do m, J.ToJSON a) => WS.Sink WS.Hybi00 -> a -> m ()
sendSinkJsonmsg <- mkJsonMsg j(=J.toJSON     j)
  msgliftIO<- mkJsonMsg$ WS.sendSinkJ.toJSONsink $j)WS.textData (LTE.decodeUtf8 $ J.encode msg)
  liftIO $ WS.sendSink sink $ WS.textData (LTE.decodeUtf8 $ J.encode msg)
-- if we send an object, and it does not have a time field, inject it
mkJsonMsg-- if we send an object, and it does not have a time field, inject it:: MonadIO m => Value -> m J.Value
mkJsonMsg ::(J.Objectom =>| not(HM.member-> m J.Value"time" o) = do
mkJsonMsgt <- getTimestampJ.Object o) | not (HM.member "time" o) = do
  treturn<- getTimestamp$ J.Object (HM.insert "time" (J.toJSON t) o)
mkJsonMsg $xJ.Object= return(HM.insertx         "time" (J.toJSON t) o)
mkJsonMsg x = return x
jsonError :: String -> J.Value
jsonError ::msgString= J.object-> J.Value[ "error" .= msg ]
jsonError msg = J.object [ "error" .= msg ]
sockets :: Editor -> WS.Request -> WS.WebSockets WS.Hybi00 ()
sockets ::y req -> WS.Request -> WS.WebSockets WS.Hybi00 ()
sockets| WS.requestPath req      req == "/edit"  = accept editSocket
  | WS.requestPathotherwise      req == "/edit"  = acceptWS.rejectRequestreq "Not found"
  |where                      = WS.rejectRequest req "Not found"
  whereaccept a = WS.acceptRequest req >> a y
    accept a = WS.acceptRequest req >> a y
editSocket :: Editor -> WS.WebSockets WS.Hybi00 ()
editSocket ::e =Editordo    -> WS.WebSockets WS.Hybi00 ()
editSocketclient <-emkClientId= do      e
  clientsendInit<-emkClientIdclient    e
  sendInitsink <- WS.getSink client
  sinkch <-<-liftIOnewChan
  cht <-<-liftIOgetTimestamp
  tliftIO<- liftIO$ addCliente (Client t client ch)
  liftIOtid <- $liftIO. forkIO (Client. forever client$ do ch)
  tidacts<- liftIO<- readChan forkIOch  . forever $ do
    actssendSinkJson<- readChansinkchacts
  forever$ do   sink acts
  forever(OpBlock doacts) <- receiveJson
    (liftIOOpBlock$ actsapplyOps) <- receiveJsone acts
    liftIO $)applyOps e acts
  liftIO$ (removeClient)           e client
  liftIO $)removeClient e client
  return ()
addClient :: Editor -> Client -> IO ()
addClient ::e cEditor= modifyMVar_-> Client(doc-> IOe) ()\(d, m) -> return (d, M.insert (clientId c) c m)
addClient e c = modifyMVar_ (doc e) $ \(d, m) -> return (d, M.insert (clientId c) c m)
removeClient :: Editor -> ClientId -> IO ()
removeClient ::e cid= modifyMVar_-> ClientId(doc-> IOe) ()\(d, m) -> return (d, M.delete cid m)
removeClient e cid = modifyMVar_ (doc e) $ \(d, m) -> return (d, M.delete cid m)
-- encode the whole document
currentVersion-- encode the whole document:: Document -> Value
currentVersion ::d =Document -> Value
currentVersionlet xs = SM.toList =     d
    let xsencodeAtom= SM.toList(a,vd = J.toJSON [ J.toJSON (aiTime a)
        encodeAtom (a,v) = J.toJSON [ J.toJSON (aiTimeaiClient)a)
                                    , J.toJSON (aiClienttaCh v)  a)
                                    , J.toJSON (taChisJust)$ taRemoved v)
                                    , J.toJSON (isJust $ taRemoved v)
    in  J.toJSON $ map encodeAtom xs]
    in  J.toJSON $ map encodeAtom xs
sendInit :: Editor -> ClientId -> WS.WebSockets WS.Hybi00 ()
sendInit ::e cEditor= do  -> ClientId -> WS.WebSockets WS.Hybi00 ()
sendInitd <- liftIO c =(doreadMVar $ doc e)
  dsendJson<- liftIO$ actionsreadMVar[ J.object doc e)[ "action" .= t"clientid", "clientId" .= c]
  sendJson $ actions [ J.object [ "action" .= t"clientid""doc", "doc", "clientId".= currentVersion c]   (fst d) ]
                     , J.object [ "action" .= t"doc", "doc" .= currentVersion (fst d) ]
                     ]
actions :: [J.Value] -> J.Value
actions :: [J.ValueJ.object] ->["actions"  .= as ]
actions as = J.object ["actions" .= as ]

</pre>