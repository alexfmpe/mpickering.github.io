<a href="Linear.hs555860589795054873.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Listen.hs11633137291122721015.out.html">next</a></br></br><pre>533d532
< -- changing its semantics (max might not be strict), but we can for
534d532
< -- the version specialised to 'Int'.
535d532
< strictMaximum           :: (Ord a) => [a] -> a
536c533
< strictMaximum []        =  errorEmptyList "maximum"
---
> -- We can't make the overloaded version of maximum strict without-- changing its semantics (max might not be strict), but we can for
536a534
> -- the version specialised to 'Int'.-- changing its semantics (max might not be strict), but we can for
536a535
> strictMaximum-- the version specialised to 'Int'.:: (Ord a) => [a] -> a
536a536
> strictMaximum []        ::=  (errorEmptyListOrd a) => [a] ->"maximum"
536a537
> strictMaximum [xs]        =  errorEmptyListfoldl1' max xs "maximum"
538d538
< 
540d539
< -- which must be non-empty, finite, and of an ordered type.
541d539
< -- It is a special case of 'Data.List.minimumBy', which allows the
542d539
< -- programmer to supply their own comparison function.
543d539
< minimum                 :: (Ord a) => [a] -> a
544d539
< {-# NOINLINE [1] minimum #-}
545c540
< minimum []              =  errorEmptyList "minimum"
---
> -- | 'minimum' returns the minimum value from a list,-- which must be non-empty, finite, and of an ordered type.
545a541
> -- which must be non-empty, finite, and of an ordered type.-- It is a special case of 'Data.List.minimumBy', which allows the
545a542
> -- programmer to supply their own comparison function.-- It is a special case of 'Data.List.minimumBy', which allows the
545a543
> minimum-- programmer to supply their own comparison function.:: (Ord a) => [a] -> a
545a544
> minimum{-# NOINLINE [1] minimum::#-}Ord a) => [a] -> a
545a545
> {-# NOINLINEminimum []   [1] minimum=#-}errorEmptyList "minimum"
545a546
> minimum [xs]              =  errorEmptyListfoldl1 min xs  "minimum"
547d547
< 
549d548
<   "minimumInt"     minimum = (strictMinimum :: [Int]     -> Int);
550c549
<   "minimumInteger" minimum = (strictMinimum :: [Integer] -> Integer)
---
> {-# RULES"minimumInt"     minimum = (strictMinimum :: [Int]     -> Int);
550a550
>   "minimumInt""minimumInteger" minimum = (strictMinimum :: [IntInteger]   ] -> IntInteger);  )
550a551
>  #-} minimum = (strictMinimum :: [Integer] -> Integer)
552d552
< 
555d554
< strictMinimum xs        =  foldl1' min xs
556d554
< 
557c555
< -- | The 'maximumBy' function takes a comparison function and a list
---
> strictMinimum xs        ::=  (foldl1'Ord a) =>min[axs] -> a
557a556
> strictMinimum []        =  errorEmptyList "minimum"
557a557
> strictMinimum-- | The 'maximumBy' function takes a comparison function and a list        =  foldl1' min xs
559d558
< -- The list must be finite and non-empty.
560d558
< maximumBy               :: (a -> a -> Ordering) -> [a] -> a
561d558
< maximumBy _ []          =  error "List.maximumBy: empty list"
562d558
< maximumBy cmp xs        =  foldl1 maxBy xs
563d558
<                         where
564c559
<                            maxBy x y = case cmp x y of
---
> -- The list must be finite and non-empty.-- | The 'maximumBy' function takes a comparison function and a list
564a560
> maximumBy-- and returns the greatest element of the list by the comparison function.:: (a -> a -> Ordering) -> [a] -> a
564a561
> maximumBy-- The list must be finite and non-empty._ []          =  error "List.maximumBy: empty list"
564a562
> maximumBy cmp xs        ::=  (foldl1a -> amaxBy-> Orderingxs    ) -> [a] -> a
564a563
> maximumBy _ []          =where "List.maximumBy: empty list"
564a564
> maximumBy cmp xs        =  foldl1maxBy xmaxByy = case  cmp x y of
564a565
>                         where          GT -> x
564a566
>                            maxBy x y = case_  ->cmpy  x y of
566d567
<                                        _  -> y
567d567
< 
568c568
< -- | The 'minimumBy' function takes a comparison function and a list
---
> -- | The 'minimumBy' function takes a comparison function and a list  -> y
570d569
< -- The list must be finite and non-empty.
571d569
< minimumBy               :: (a -> a -> Ordering) -> [a] -> a
572d569
< minimumBy _ []          =  error "List.minimumBy: empty list"
573d569
< minimumBy cmp xs        =  foldl1 minBy xs
574d569
<                         where
575c570
<                            minBy x y = case cmp x y of
---
> -- The list must be finite and non-empty.-- | The 'minimumBy' function takes a comparison function and a list
575a571
> minimumBy-- and returns the least element of the list by the comparison function.:: (a -> a -> Ordering) -> [a] -> a
575a572
> minimumBy-- The list must be finite and non-empty._ []          =  error "List.minimumBy: empty list"
575a573
> minimumBy cmp xs        ::=  (foldl1a -> aminBy-> Orderingxs    ) -> [a] -> a
575a574
> minimumBy _ []          =where "List.minimumBy: empty list"
575a575
> minimumBy cmp xs        =  foldl1minBy xminByy = case  cmp x y of
575a576
>                         where          GT -> y
575a577
>                            minBy x y = case_  ->cmpx  x y of
577d578
<                                        _  -> x
578d578
< 
579c579
< -- | The 'genericLength' function is an overloaded version of 'length'.  In
---
> -- | The 'genericLength' function is an overloaded version of 'length'.  In  -> x
581d580
< -- an instance of 'Num'.  It is, however, less efficient than 'length'.
582d580
< genericLength           :: (Num i) => [a] -> i
583c581
< {-# NOINLINE [1] genericLength #-}
---
> -- an instance of 'Num'.  It is, however, less efficient than 'length'.-- | The 'genericLength' function is an overloaded version of 'length'.  In
583a582
> genericLength-- particular, instead of returning an 'Int', it returns any type which is:: (Num i) => [a] -> i
583a583
> {-# NOINLINE-- an instance of 'Num'.  It is, however, less efficient than 'length'.[1] genericLength #-}
583a584
> genericLength []        ::=  (Num i) => [a] -> i
583a585
> {-# NOINLINEgenericLength[1]:genericLengthl)     =  1 + #-}genericLength l
585d586
< genericLength (_:l)     =  1 + genericLength l
586d586
< 
587c587
< {-# RULES
---
> genericLength{-# RULES     (_:l)     =  1 + genericLength l
588a589
> {-# RULES"genericLengthInteger" genericLength = (strictGenericLength :: [a] -> Integer);
588a590
>  #-}     genericLength = (strictGenericLength :: [a] -> Int);
590d591
<  #-}
591d591
< 
592c592
< strictGenericLength     :: (Num i) => [b] -> i
---
> strictGenericLength#-}                    :: (Num i) => [b] -> i
595d594
<                            gl [] a     = a
596d594
<                            gl (_:xs) a = let a' = a + 1 in a' `seq` gl xs a'
597d594
< 
598d594
< -- | The 'genericTake' function is an overloaded version of 'take', which
599c595
< -- accepts any 'Integral' value as the number of elements to take.
---
> strictGenericLength     :: (glNum[]i) => [b]a-> i
599a596
> strictGenericLength l   =  gl   l_0xs) a = let a' = a + 1 in a' `seq` gl xs a'
599a597
>                         where
599a598
> -- | The 'genericTake' function is an overloaded version of 'take', which [] a     = a
599a599
> -- accepts any 'Integral' value as the number of elements to take. (_:xs) a = let a' = a + 1 in a' `seq` gl xs a'
600a601
> genericTake-- | The 'genericTake' function is an overloaded version of 'take', whichn _ | n <= 0 = []
600a602
> genericTake-- accepts any 'Integral' value as the number of elements to take._ []        =  []
600a603
> genericTake n (x:xs)    ::=  (Integral: genericTake) => in->-1)[axs] -> [a]
602d604
< genericTake _ []        =  []
603d604
< genericTake n (x:xs)    =  x : genericTake (n-1) xs
604d604
< 
605d604
< -- | The 'genericDrop' function is an overloaded version of 'drop', which
606c605
< -- accepts any 'Integral' value as the number of elements to drop.
---
> genericTake-- | The 'genericDrop' function is an overloaded version of 'drop', which []        =  []
606a606
> genericTake-- accepts any 'Integral' value as the number of elements to drop. (x:xs)    =  x : genericTake (n-1) xs
607a608
> genericDrop-- | The 'genericDrop' function is an overloaded version of 'drop', whichn xs | n <= 0 = xs
607a609
> genericDrop-- accepts any 'Integral' value as the number of elements to drop._ []        =  []
607a610
> genericDrop n (_:xs)    ::=  (genericDropIntegral i)(=>n-1i -> [a] -> [a]
610d612
< genericDrop n (_:xs)    =  genericDrop (n-1) xs
611d612
< 
612d612
< 
613c613
< -- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which
---
> genericDrop-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which (_:xs)    =  genericDrop (n-1) xs
616c616
< genericSplitAt n xs | n <= 0 =  ([],xs)
---
> genericSplitAt-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', whichn xs | n <= 0 =  ([],xs)
616a617
> genericSplitAt-- accepts any 'Integral' value as the position at which to split._ []     =  ([],[])
616a618
> genericSplitAt n (x:xs) ::=  (Integralx:xs',xs'') =>where -> [a] -> ([a], [a])
616a619
> genericSplitAt(xs',xs'') n xsgenericSplitAt n <= 0 =  ([],xs) )xs
618d620
< genericSplitAt n (x:xs) =  (x:xs',xs'') where
619d620
<     (xs',xs'') = genericSplitAt (n-1) xs
620d620
< 
621d620
< -- | The 'genericIndex' function is an overloaded version of '!!', which
622c621
< -- accepts any 'Integral' value as the index.
---
> genericSplitAt-- | The 'genericIndex' function is an overloaded version of '!!', which (x:xs) =  (x:xs',xs'') where
622a622
> -- accepts any 'Integral' value as the index.xs',xs'') = genericSplitAt (n-1) xs
624d623
< genericIndex (x:_)  0 = x
625c624
< genericIndex (_:xs) n
---
> genericIndex-- | The 'genericIndex' function is an overloaded version of '!!', which(x:_)  0 = x
625a625
> genericIndex-- accepts any 'Integral' value as the index.(_:xs) n
625a626
> genericIndex| n > 0     ::= genericIndexIntegral i)xs=>([a])-> i -> a
625a627
> genericIndex| otherwise (x:error_)  0"List.genericIndex: negative argument."= x
625a628
> genericIndex (_:xs) n = error "List.genericIndex: index too large."
627d629
<  | otherwise = error "List.genericIndex: negative argument."
628d629
< genericIndex _ _      = error "List.genericIndex: index too large."
629d629
< 
630d629
< -- | The 'genericReplicate' function is an overloaded version of 'replicate',
631c630
< -- which accepts any 'Integral' value as the number of repetitions to make.
---
> -- | The 'genericReplicate' function is an overloaded version of 'replicate', otherwise = error "List.genericIndex: negative argument."
631a631
> genericIndex-- which accepts any 'Integral' value as the number of repetitions to make. _      = error "List.genericIndex: index too large."
633d632
< genericReplicate n x    =  genericTake n (repeat x)
634d632
< 
635d632
< -- | The 'zip4' function takes four lists and returns a list of
636c633
< -- quadruples, analogous to 'zip'.
---
> genericReplicate-- | The 'genericReplicate' function is an overloaded version of 'replicate',n x    =  genericTake n (repeat x)
636a634
> -- which accepts any 'Integral' value as the number of repetitions to make.
636a635
> genericReplicate-- | The 'zip4' function takes four lists and returns a list of:: (Integral i) => i -> a -> [a]
636a636
> genericReplicate-- quadruples, analogous to 'zip'. x    =  genericTake n (repeat x)
638d637
< zip4                    =  zipWith4 (,,,)
639d637
< 
640d637
< -- | The 'zip5' function takes five lists and returns a list of
641c638
< -- five-tuples, analogous to 'zip'.
---
> zip4-- | The 'zip4' function takes four lists and returns a list of=  zipWith4 (,,,)
641a639
> -- quadruples, analogous to 'zip'.
641a640
> zip4-- | The 'zip5' function takes five lists and returns a list of:: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
641a641
> zip4-- five-tuples, analogous to 'zip'.=  zipWith4 (,,,)
643d642
< zip5                    =  zipWith5 (,,,,)
644d642
< 
645d642
< -- | The 'zip6' function takes six lists and returns a list of six-tuples,
646c643
< -- analogous to 'zip'.
---
> zip5-- | The 'zip5' function takes five lists and returns a list of=  zipWith5 (,,,,)
646a644
> -- five-tuples, analogous to 'zip'.
646a645
> zip5-- | The 'zip6' function takes six lists and returns a list of six-tuples,:: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
646a646
> zip5-- analogous to 'zip'.  =  zipWith5 (,,,,)
648d647
<                               [(a,b,c,d,e,f)]
649d647
< zip6                    =  zipWith6 (,,,,,)
650d647
< 
651d647
< -- | The 'zip7' function takes seven lists and returns a list of
652c648
< -- seven-tuples, analogous to 'zip'.
---
> -- | The 'zip6' function takes six lists and returns a list of six-tuples,[(a,b,c,d,e,f)]
652a649
> zip6-- analogous to 'zip'.  =  zipWith6 (,,,,,)
652a650
> zip6                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
652a651
> -- | The 'zip7' function takes seven lists and returns a list of(a,b,c,d,e,f)]
652a652
> zip6-- seven-tuples, analogous to 'zip'.=  zipWith6 (,,,,,)
654d653
<                               [g] -> [(a,b,c,d,e,f,g)]
655d653
< zip7                    =  zipWith7 (,,,,,,)
656d653
< 
657d653
< -- | The 'zipWith4' function takes a function which combines four
658c654
< -- elements, as well as four lists and returns a list of their point-wise
---
> -- | The 'zip7' function takes seven lists and returns a list of[g] -> [(a,b,c,d,e,f,g)]
658a655
> zip7-- seven-tuples, analogous to 'zip'.=  zipWith7 (,,,,,,)
658a656
> zip7                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
658a657
> -- | The 'zipWith4' function takes a function which combines fourg] -> [(a,b,c,d,e,f,g)]
658a658
> zip7-- elements, as well as four lists and returns a list of their point-wise=  zipWith7 (,,,,,,)
660c660
< zipWith4                :: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
---
> zipWith4-- | The 'zipWith4' function takes a function which combines four:: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
660a661
> zipWith4-- elements, as well as four lists and returns a list of their point-wisez (a:as) (b:bs) (c:cs) (d:ds)
660a662
> -- combination, analogous to 'zipWith'.=  z a b c d : zipWith4 z as bs cs ds
660a663
> zipWith4 _ _ _ _ _      ::=  (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
662d664
<                         =  z a b c d : zipWith4 z as bs cs ds
663d664
< zipWith4 _ _ _ _ _      =  []
664d664
< 
665d664
< -- | The 'zipWith5' function takes a function which combines five
666c665
< -- elements, as well as five lists and returns a list of their point-wise
---
> -- | The 'zipWith5' function takes a function which combines five=  z a b c d : zipWith4 z as bs cs ds
666a666
> zipWith4-- elements, as well as five lists and returns a list of their point-wise _ _ _ _      =  []
668d667
< zipWith5                :: (a->b->c->d->e->f) ->
669c668
<                            [a]->[b]->[c]->[d]->[e]->[f]
---
> zipWith5-- | The 'zipWith5' function takes a function which combines five:: (a->b->c->d->e->f) ->
669a669
> -- elements, as well as five lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]
669a670
> zipWith5-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
669a671
> zipWith5                ::=  (a->a b->cc->d d->:e->zipWith5f) ->  z as bs cs ds es
669a672
> zipWith5 _ _ _ _ _ _    = [[a]->[b]->[c]->[d]->[e]->[f]
671d673
<                         =  z a b c d e : zipWith5 z as bs cs ds es
672d673
< zipWith5 _ _ _ _ _ _    = []
673d673
< 
674d673
< -- | The 'zipWith6' function takes a function which combines six
675c674
< -- elements, as well as six lists and returns a list of their point-wise
---
> -- | The 'zipWith6' function takes a function which combines six=  z a b c d e : zipWith5 z as bs cs ds es
675a675
> zipWith5-- elements, as well as six lists and returns a list of their point-wise _ _ _ _ _    = []
677d676
< zipWith6                :: (a->b->c->d->e->f->g) ->
678c677
<                            [a]->[b]->[c]->[d]->[e]->[f]->[g]
---
> zipWith6-- | The 'zipWith6' function takes a function which combines six:: (a->b->c->d->e->f->g) ->
678a678
> -- elements, as well as six lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]->[g]
678a679
> zipWith6-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
678a680
> zipWith6                ::=  (a->a b->cc->d d->fe->: fzipWith6->g) -> z as bs cs ds es fs
678a681
> zipWith6 _ _ _ _ _ _ _  = [[a]->[b]->[c]->[d]->[e]->[f]->[g]
680d682
<                         =  z a b c d e f : zipWith6 z as bs cs ds es fs
681d682
< zipWith6 _ _ _ _ _ _ _  = []
682d682
< 
683d682
< -- | The 'zipWith7' function takes a function which combines seven
684c683
< -- elements, as well as seven lists and returns a list of their point-wise
---
> -- | The 'zipWith7' function takes a function which combines seven=  z a b c d e f : zipWith6 z as bs cs ds es fs
684a684
> zipWith6-- elements, as well as seven lists and returns a list of their point-wise _ _ _ _ _ _  = []
686d685
< zipWith7                :: (a->b->c->d->e->f->g->h) ->
687c686
<                            [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
---
> zipWith7-- | The 'zipWith7' function takes a function which combines seven:: (a->b->c->d->e->f->g->h) ->
687a687
> -- elements, as well as seven lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
687a688
> zipWith7-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
687a689
> zipWith7           =  z ::a b(a->db->e c->gd->: ezipWith7->f->g->h)as->bs cs ds es fs gs
687a690
> zipWith7 _ _ _ _ _ _ _ _ = [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
689d691
<                    =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
690d691
< zipWith7 _ _ _ _ _ _ _ _ = []
691d691
< 
692d691
< -- | The 'unzip4' function takes a list of quadruples and returns four
693c692
< -- lists, analogous to 'unzip'.
---
> -- | The 'unzip4' function takes a list of quadruples and returns four=  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
693a693
> zipWith7-- lists, analogous to 'unzip'. _ _ _ _ _ _ _ = []
694a695
> unzip4-- | The 'unzip4' function takes a list of quadruples and returns four=  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
694a696
> -- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds))
694a697
> unzip4                  :: [(a,b,c,d)]]->,[]([a],[b],[c],[d])
696d698
<                                         (a:as,b:bs,c:cs,d:ds))
697d698
<                                  ([],[],[],[])
698d698
< 
699d698
< -- | The 'unzip5' function takes a list of five-tuples and returns five
700c699
< -- lists, analogous to 'unzip'.
---
> -- | The 'unzip5' function takes a list of five-tuples and returns fivea:as,b:bs,c:cs,d:ds))
700a700
> -- lists, analogous to 'unzip'.  ([],[],[],[])
701a702
> unzip5-- | The 'unzip5' function takes a list of five-tuples and returns five=  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
701a703
> -- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds,e:es))
701a704
> unzip5                  :: [(a,b,c,d,e)][->],[([a],[b],[c],[d],[e])
703d705
<                                         (a:as,b:bs,c:cs,d:ds,e:es))
704d705
<                                  ([],[],[],[],[])
705d705
< 
706d705
< -- | The 'unzip6' function takes a list of six-tuples and returns six
707c706
< -- lists, analogous to 'unzip'.
---
> -- | The 'unzip6' function takes a list of six-tuples and returns sixa:as,b:bs,c:cs,d:ds,e:es))
707a707
> -- lists, analogous to 'unzip'.  ([],[],[],[],[])
708a709
> unzip6-- | The 'unzip6' function takes a list of six-tuples and returns six=  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
708a710
> -- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds,e:es,f:fs))
708a711
> unzip6                  :: [(a,b,c,d,e,f)],->[],([a],[b],[c],[d],[e],[f])
710d712
<                                         (a:as,b:bs,c:cs,d:ds,e:es,f:fs))
711d712
<                                  ([],[],[],[],[],[])
712d712
< 
713d712
< -- | The 'unzip7' function takes a list of seven-tuples and returns
714c713
< -- seven lists, analogous to 'unzip'.
---
> -- | The 'unzip7' function takes a list of seven-tuples and returnsa:as,b:bs,c:cs,d:ds,e:es,f:fs))
714a714
> -- seven lists, analogous to 'unzip'.[],[],[],[],[],[])
715a716
> unzip7-- | The 'unzip7' function takes a list of seven-tuples and returns=  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
715a717
> -- seven lists, analogous to 'unzip'.(a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
715a718
> unzip7          :: [(a,b,c,d,e,f,g)]]->,[]([a],[b],[c],[d],[e],[f],[g])
718d720
<                          ([],[],[],[],[],[],[])
719d720
< 
720d720
< 
721c721
< -- | The 'deleteFirstsBy' function takes a predicate and two lists and
---
> -- | The 'deleteFirstsBy' function takes a predicate and two lists and[],[],[],[],[],[],[])
724d723
< deleteFirstsBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]
725d723
< deleteFirstsBy eq       =  foldl (flip (deleteBy eq))
726d723
< 
727d723
< -- | The 'group' function takes a list and returns a list of lists such
728c724
< -- that the concatenation of the result is equal to the argument.  Moreover,
---
> deleteFirstsBy-- | The 'deleteFirstsBy' function takes a predicate and two lists and:: (a -> a -> Bool) -> [a] -> [a] -> [a]
728a725
> deleteFirstsBy-- returns the first list with the first occurrence of each element ofeq       =  foldl (flip (deleteBy eq))
728a726
> -- the second list removed.
728a727
> deleteFirstsBy-- | The 'group' function takes a list and returns a list of lists such:: (a -> a -> Bool) -> [a] -> [a] -> [a]
728a728
> deleteFirstsBy-- that the concatenation of the result is equal to the argument.  Moreover,       =  foldl (flip (deleteBy eq))
730d729
< --
731d729
< -- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
732d729
< --
733c730
< -- It is a special case of 'groupBy', which allows the programmer to supply
---
> ---- | The 'group' function takes a list and returns a list of lists such
733a731
> -- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]-- that the concatenation of the result is equal to the argument.  Moreover,
733a732
> ---- each sublist in the result contains only equal elements.  For example,
733a733
> ---- It is a special case of 'groupBy', which allows the programmer to supply
733a734
> -- their own equality test.-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
733a735
> --group                   :: Eq a => [a] -> [[a]]
733a736
> group-- It is a special case of 'groupBy', which allows the programmer to supply=  groupBy (==)
735d737
< group                   :: Eq a => [a] -> [[a]]
736d737
< group                   =  groupBy (==)
737d737
< 
738d737
< -- | The 'groupBy' function is the non-overloaded version of 'group'.
739c738
< groupBy                 :: (a -> a -> Bool) -> [a] -> [[a]]
---
> group-- | The 'groupBy' function is the non-overloaded version of 'group'.:: Eq a => [a] -> [[a]]
739a739
> groupgroupBy                 =:: groupBy(a -> a (->==)Bool) -> [a] -> [[a]]
741d740
< groupBy eq (x:xs)       =  (x:ys) : groupBy eq zs
742d740
<                            where (ys,zs) = span (eq x) xs
743d740
< 
744d740
< -- | The 'inits' function returns all initial segments of the argument,
745d740
< -- shortest first.  For example,
746d740
< --
747c741
< -- > inits "abc" == ["","a","ab","abc"]
---
> groupBy-- | The 'groupBy' function is the non-overloaded version of 'group'.eq (x:xs)       =  (x:ys) : groupBy eq zs
747a742
> groupBy                 :: (wherea -> a ys->,zs) =)span-> [a]eq->x)[[xsa]]
747a743
> groupBy _  []           =  []
747a744
> groupBy-- | The 'inits' function returns all initial segments of the argument, (x:xs)       =  (x:ys) : groupBy eq zs
747a745
> -- shortest first.  For example,where (ys,zs) = span (eq x) xs
749d746
< -- Note that 'inits' has the following strictness property:
750c747
< -- @inits (xs ++ _|_) = inits xs ++ _|_@
---
> -- > inits "abc" == ["","a","ab","abc"]-- | The 'inits' function returns all initial segments of the argument,
750a748
> ---- shortest first.  For example,
750a749
> ---- Note that 'inits' has the following strictness property:
750a750
> -- > inits "abc" == ["","a","ab","abc"]-- @inits (xs ++ _|_) = inits xs ++ _|_@
752d751
< -- In particular,
753c752
< -- @inits _|_ = [] : _|_@
---
> -- In particular,-- Note that 'inits' has the following strictness property:
753a753
> -- @inits _|_ = [] : _|_@-- @inits (xs ++ _|_) = inits xs ++ _|_@
753a754
> --inits                   :: [a] -> [[a]]
753a755
> inits-- In particular,       = map toListSB . scanl' snocSB emptySB
753a756
> {-# NOINLINE-- @inits _|_ = [] : _|_@inits #-}
755d757
< inits                   = map toListSB . scanl' snocSB emptySB
756d757
< {-# NOINLINE inits #-}
757d757
< 
758d757
< -- We do not allow inits to inline, because it plays havoc with Call Arity
759c758
< -- if it fuses with a consumer, and it would generally lead to serious
---
> inits-- We do not allow inits to inline, because it plays havoc with Call Arity= map toListSB . scanl' snocSB emptySB
759a759
> {-# NOINLINE-- if it fuses with a consumer, and it would generally lead to serious #-}
761d760
< 
762d760
< -- | A strictly accumulating version of 'scanl'
763c761
< {-# NOINLINE [1] scanl' #-}
---
> -- We do not allow inits to inline, because it plays havoc with Call Arity
763a762
> -- | A strictly accumulating version of 'scanl'-- if it fuses with a consumer, and it would generally lead to serious
763a763
> {-# NOINLINE-- loss of sharing if allowed to fuse with a producer.[1] scanl' #-}
765d764
< -- This peculiar form is needed to prevent scanl' from being rewritten
766d764
< -- in its own right hand side.
767d764
< scanl' = scanlGo'
768d764
<   where
769c765
<     scanlGo' :: (b -> a -> b) -> b -> [a] -> [b]
---
> -- | A strictly accumulating version of 'scanl'-- This peculiar form is needed to prevent scanl' from being rewritten
769a766
> {-# NOINLINE-- in its own right hand side.[1] scanl' #-}
769a767
> scanl' = scanlGo':: (b -> a -> b) -> b -> [a] -> [b]
769a768
> -- This peculiar form is needed to prevent scanl' from being rewrittenwhere
769a769
> -- in its own right hand side.scanlGo' :: (b -> a -> b) -> b -> [a] -> [b]
769a770
> scanl'scanlGo'= scanlGo'f !q ls    = q : (case ls of
769a771
>   where                     []   -> []
769a772
>     scanlGo' :: (b -> a -> b) :-> b->->scanlGo'a] -> [b]f q x) xs)
771d773
<                             []   -> []
772d773
<                             x:xs -> scanlGo' f (f q x) xs)
773d773
< 
774d773
< -- | The 'tails' function returns all final segments of the argument,
775d773
< -- longest first.  For example,
776d773
< --
777c774
< -- > tails "abc" == ["abc", "bc", "c",""]
---
> -- | The 'tails' function returns all final segments of the argument,]   -> []
777a775
> -- longest first.  For example,:xs -> scanlGo' f (f q x) xs)
779d776
< -- Note that 'tails' has the following strictness property:
780d776
< -- @tails _|_ = _|_ : _|_@
781c777
< tails                   :: [a] -> [[a]]
---
> -- > tails "abc" == ["abc", "bc", "c",""]-- | The 'tails' function returns all final segments of the argument,
781a778
> ---- longest first.  For example,
781a779
> ---- Note that 'tails' has the following strictness property:
781a780
> -- @tails _|_ = _|_ : _|_@-- > tails "abc" == ["abc", "bc", "c",""]
781a781
> --tails                   :: [a] -> [[a]]
781a782
> tails-- Note that 'tails' has the following strictness property:xs                =  xs : case xs of
781a783
> -- @tails _|_ = _|_ : _|_@        []      -> []
781a784
> tails                   :: [a] -> [ [a]]xs' -> tails xs'
783d785
<                                   []      -> []
784d785
<                                   _ : xs' -> tails xs'
785d785
< 
786d785
< -- | The 'subsequences' function returns the list of all subsequences of the argument.
787c786
< --
---
> -- | The 'subsequences' function returns the list of all subsequences of the argument.]      -> []
787a787
> --                                _ : xs' -> tails xs'
789d788
< subsequences            :: [a] -> [[a]]
790d788
< subsequences xs         =  [] : nonEmptySubsequences xs
791d788
< 
792d788
< -- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,
793c789
< --   except for the empty list.
---
> subsequences-- | The 'subsequences' function returns the list of all subsequences of the argument.:: [a] -> [[a]]
793a790
> --subsequences xs         =  [] : nonEmptySubsequences xs
793a791
> -- > subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
793a792
> subsequences-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,:: [a] -> [[a]]
793a793
> subsequences--   except for the empty list.         =  [] : nonEmptySubsequences xs
795d794
< -- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"]
796c795
< nonEmptySubsequences         :: [a] -> [[a]]
---
> -- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"]-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,
796a796
> nonEmptySubsequences--   except for the empty list.:: [a] -> [[a]]
796a797
> --nonEmptySubsequences []      =  []
796a798
> nonEmptySubsequences-- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"](x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
796a799
> nonEmptySubsequenceswhere f ys r = ys : (x : ys::) :[a] -> [[a]]
799d801
<   where f ys r = ys : (x : ys) : r
800d801
< 
801d801
< 
802c802
< -- | The 'permutations' function returns the list of all permutations of the argument.
---
> -- | The 'permutations' function returns the list of all permutations of the argument.where f ys r = ys : (x : ys) : r
805d804
< permutations            :: [a] -> [[a]]
806d804
< permutations xs0        =  xs0 : perms xs0 []
807d804
<   where
808d804
<     perms []     _  = []
809d804
<     perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)
810c805
<       where interleave    xs     r = let (_,zs) = interleave' id xs r in zs
---
> permutations-- | The 'permutations' function returns the list of all permutations of the argument.:: [a] -> [[a]]
810a806
> --permutations xs0        =  xs0 : perms xs0 []
810a807
> -- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]where
810a808
> permutationsperms []     _  = []:: [a] -> [[a]]
810a809
> permutationsperms (t:xs0ts) is = foldr=  xs0interleave perms xs0(perms] ts (t:is)) (permutations is)
810a810
>   wherewhere interleave    xs     r = let (_,zs) = interleave' id xs r in zs
810a811
>     perms []interleave'  = []_ []     r = (ts, r)
810a812
>     perms (t:interleave'ts) is = foldrf (yinterleave:ys) r = letperms(us,zs) (t:interleave'is)) (permutations(f . (y:is)))ys r
810a813
>       where interleave    xs     r = letin  (_,zs) = interleave'(t:y:us) : zs) xs r in zs
813d815
<                                      in  (y:us, f (t:y:us) : zs)
814d815
< 
815d815
< 
816c816
< ------------------------------------------------------------------------------
---
> ------------------------------------------------------------------------------in  (y:us, f (t:y:us) : zs)
819d818
< -- | The 'sort' function implements a stable sorting algorithm.
820c819
< -- It is a special case of 'sortBy', which allows the programmer to supply
---
> -- | The 'sort' function implements a stable sorting algorithm.------------------------------------------------------------------------------
820a820
> -- Quick Sort algorithm taken from HBC's QSort library.-- It is a special case of 'sortBy', which allows the programmer to supply
822d821
< sort :: (Ord a) => [a] -> [a]
823d821
< 
824d821
< -- | The 'sortBy' function is the non-overloaded version of 'sort'.
825c822
< sortBy :: (a -> a -> Ordering) -> [a] -> [a]
---
> sort-- | The 'sort' function implements a stable sorting algorithm.:: (Ord a) => [a] -> [a]
825a823
> -- It is a special case of 'sortBy', which allows the programmer to supply
825a824
> -- their own comparison function.-- | The 'sortBy' function is the non-overloaded version of 'sort'.
825a825
> sortsortBy::::Ord(a a->) =>a ->a]Ordering-> [a]) -> [a] -> [a]
827d826
< #ifdef USE_REPORT_PRELUDE
828c827
< sort = sortBy compare
---
> #ifdef USE_REPORT_PRELUDE-- | The 'sortBy' function is the non-overloaded version of 'sort'.
828a828
> sortBysort = ::sortBya ->compare -> Ordering) -> [a] -> [a]
842d841
< -}
843d841
< 
844c842
< sort = sortBy compare
---
> -}sort = sortBy compare
847c845
<     sequences (a:b:xs)
---
> sortsequences= sortBy compare(a:b:xs)
847a846
> sortBy|cmpa `=cmp` b == GT sequences= descending b [a]  xs
847a847
>   where| otherwise       = ascending  b (a:) xs
847a848
>     sequences (xsa:b:xs[xs)]
849d849
<       | otherwise       = ascending  b (a:) xs
850d849
<     sequences xs = [xs]
851d849
< 
852d849
<     descending a as (b:bs)
853c850
<       | a `cmp` b == GT = descending b (a:as) bs
---
>     descending otherwisea as (b:bs=)ascending  b (a:) xs
853a851
>     sequences| a `cmpxs` b===xsGT] = descending b (a:as) bs
855d852
< 
856d852
<     ascending a as (b:bs)
857c853
<       | a `cmp` b /= GT = ascending b (\ys -> as (a:ys)) bs
---
>     descending a as (b:bs)
857a854
>     ascending a `cmp` bas==(bGT:bs= descending b (a:as) bs
857a855
>     descending| a `cmp`abas/=bsGT = (ascendinga:as): sequencesb (\ys ->as (a:ys)) bs
859d856
< 
860d856
<     mergeAll [x] = x
861c857
<     mergeAll xs  = mergeAll (mergePairs xs)
---
>     ascending a as (b:bs)
861a858
>     mergeAll a `cmp[`]b=/=x GT = ascending b (\ys -> as (a:ys)) bs
861a859
>     ascendingmergeAll xs as= bsmergeAll= as([mergePairsa]: sequencesxs) bs
863d860
<     mergePairs (a:b:xs) = merge a b: mergePairs xs
864c861
<     mergePairs xs       = xs
---
>     mergeAllmergePairsx]a=bxxs) = merge a b: mergePairs xs
864a862
>     mergeAllmergePairsxs= mergeAll= xs(mergePairs xs)
866d863
<     merge as@(a:as') bs@(b:bs')
867c864
<       | a `cmp` b == GT = b:merge as  bs'
---
>     mergePairsmerge as@(a(aas':b:xsbs)@=bmerge:bs') a b: mergePairs xs
867a865
>     mergePairs| a `cmp`xsb == GT = xsb:merge as  bs'
869c867
<     merge [] bs         = bs
---
>     merge as[]@(bsa:as') bs@(b:bsbs')
869a868
>     merge a `ascmp[` b == GT = bas:merge as  bs'
869a869
>       | otherwise       = a:merge as' bs
869a870
> {-
869a871
> sortBy cmp l = mergesort cmp l
869a872
> sort l = mergesort compare l
869a873
> 
869a874
> Quicksort replaced by mergesort, 14/5/2002.
869a875
> 
869a876
> From: Ian Lynagh <igloo@earth.li>
869a877
> 
869a878
> I am curious as to why the List.sort implementation in GHC is a
869a879
> quicksort algorithm rather than an algorithm that guarantees n log n
869a880
> time in the worst case? I have attached a mergesort implementation along
869a881
> with a few scripts to time it's performance, the results of which are
869a882
> shown below (* means it didn't finish successfully - in all cases this
869a883
> was due to a stack overflow).
869a884
> 
869a885
> If I heap profile the random_list case with only 10000 then I see
869a886
> random_list peaks at using about 2.5M of memory, whereas in the same
869a887
> program using List.sort it uses only 100k.
869a888
> 
869a889
> Input style     Input length     Sort data     Sort alg    User time
869a890
> stdin           10000            random_list   sort        2.82
869a891
> stdin           10000            random_list   mergesort   2.96
869a892
> stdin           10000            sorted        sort        31.37
869a893
> stdin           10000            sorted        mergesort   1.90
869a894
> stdin           10000            revsorted     sort        31.21
869a895
> stdin           10000            revsorted     mergesort   1.88
869a896
> stdin           100000           random_list   sort        *
869a897
> stdin           100000           random_list   mergesort   *
869a898
> stdin           100000           sorted        sort        *
869a899
> stdin           100000           sorted        mergesort   *
869a900
> stdin           100000           revsorted     sort        *
869a901
> stdin           100000           revsorted     mergesort   *
869a902
> func            10000            random_list   sort        0.31
869a903
> func            10000            random_list   mergesort   0.91
869a904
> func            10000            sorted        sort        19.09
869a905
> func            10000            sorted        mergesort   0.15
869a906
> func            10000            revsorted     sort        19.17
869a907
> func            10000            revsorted     mergesort   0.16
869a908
> func            100000           random_list   sort        3.85
869a909
> func            100000           random_list   mergesort   *
869a910
> func            100000           sorted        sort        5831.47
869a911
> func            100000           sorted        mergesort   2.23
869a912
> func            100000           revsorted     sort        5872.34
869a913
> func            100000           revsorted     mergesort   2.24
869a914
> 
869a915
> mergesort :: (a -> a -> Ordering) -> [a] -> [a]
869a916
> mergesort cmp = mergesort' cmp . map wrap
869a917
> 
869a918
> mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]
869a919
> mergesort' _   [] = []
869a920
> mergesort' _   [xs] = xs
869a921
> mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)
869a922
> 
869a923
> merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]
869a924
> merge_pairs _   [] = []
869a925
> merge_pairs _   [xs] = [xs]
869a926
> merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss
869a927
> 
869a928
> merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
869a929
> merge _   [] ys = ys
869a930
> merge _   xs [] = xs
869a931
> merge cmp (x:xs) (y:ys)
869a932
>  = case x `cmp` y of
869a933
>         GT -> y : merge cmp (x:xs)   ys
869a934
>         _  -> x : merge cmp    xs (y:ys)
869a935
> 
869a936
> wrap :: a -> [a]
869a937
> wrap x = [x]
869a938
> 
869a939
> 
869a940
> 
869a941
> OLDER: qsort version
869a942
> 
869a943
> -- qsort is stable and does not concatenate.
869a944
> qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
869a945
> qsort _   []     r = r
869a946
> qsort _   [x]    r = x:r
869a947
> qsort cmp (x:xs) r = qpart cmp x xs [] [] r
869a948
> 
869a949
> -- qpart partitions and sorts the sublists
869a950
> qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
869a951
> qpart cmp x [] rlt rge r =
869a952
>     -- rlt and rge are in reverse order and must be sorted with an
869a953
>     -- anti-stable sorting
869a954
>     rqsort cmp rlt (x:rqsort cmp rge r)
869a955
> qpart cmp x (y:ys) rlt rge r =
869a956
>     case cmp x y of
869a957
>         GT -> qpart cmp x ys (y:rlt) rge r
869a958
>         _  -> qpart cmp x ys rlt (y:rge) r
869a959
> 
869a960
> -- rqsort is as qsort but anti-stable, i.e. reverses equal elements
869a961
> rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
869a962
> rqsort _   []     r = r
869a963
> rqsort _   [x]    r = x:r
869a964
> rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r
869a965
> 
869a966
> rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
869a967
> rqpart cmp x [] rle rgt r =
869a968
>     qsort cmp rle (x:qsort cmp rgt r)
869a969
> rqpart cmp x (y:ys) rle rgt r =
869a970
>     case cmp y x of
869a971
>         GT -> rqpart cmp x ys rle (y:rgt) r
869a972
>         _  -> rqpart cmp x ys (y:rle) rgt r
869a973
> -}   [] bs         = bs
977d1080
< #endif /* USE_REPORT_PRELUDE */
978d1080
< 
982d1083
< -- if it is done producing the list or returns 'Just' @(a,b)@, in which
983d1083
< -- case, @a@ is a prepended to the list and @b@ is used as the next
984d1083
< -- element in a recursive call.  For example,
985d1083
< --
986d1083
< -- > iterate f == unfoldr (\x -> Just (x, f x))
987d1083
< --
988d1083
< -- In some cases, 'unfoldr' can undo a 'foldr' operation:
989d1083
< --
990d1083
< -- > unfoldr f' (foldr f z xs) == xs
991d1083
< --
992d1083
< -- if the following holds:
993d1083
< --
994d1083
< -- > f' (f x y) = Just (x,y)
995d1083
< -- > f' z       = Nothing
996d1083
< --
997c1084
< -- A simple use of unfoldr:
---
> -- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'-- if it is done producing the list or returns 'Just' @(a,b)@, in which
997a1085
> -- reduces a list to a summary value, 'unfoldr' builds a list from-- case, @a@ is a prepended to the list and @b@ is used as the next
997a1086
> -- element in a recursive call.  For example,-- a seed value.  The function takes the element and returns 'Nothing'
997a1087
> ---- if it is done producing the list or returns 'Just' @(a,b)@, in which
997a1088
> -- > iterate f == unfoldr (\x -> Just (x, f x))-- case, @a@ is a prepended to the list and @b@ is used as the next
997a1089
> ---- element in a recursive call.  For example,
997a1090
> ---- In some cases, 'unfoldr' can undo a 'foldr' operation:
997a1091
> ---- > iterate f == unfoldr (\x -> Just (x, f x))
997a1092
> ---- > unfoldr f' (foldr f z xs) == xs
997a1093
> ---- In some cases, 'unfoldr' can undo a 'foldr' operation:
997a1094
> ---- if the following holds:
997a1095
> ---- > unfoldr f' (foldr f z xs) == xs
997a1096
> ---- > f' (f x y) = Just (x,y)
997a1097
> -- > f' z       = Nothing-- if the following holds:
999d1098
< -- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
1000c1099
< -- >  [10,9,8,7,6,5,4,3,2,1]
---
> -- A simple use of unfoldr:-- > f' (f x y) = Just (x,y)
1000a1100
> ---- > f' z       = Nothing
1000a1101
> ---- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
1000a1102
> -- A simple use of unfoldr:-- >  [10,9,8,7,6,5,4,3,2,1]
1002d1103
< unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]
1003c1104
< unfoldr f b  =
---
> unfoldr-- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10:: (b -> Maybe (a, b)) -> b -> [a]
1003a1105
> unfoldr-- >  [10,9,8,7,6,5,4,3,2,1]f b  =
1003a1106
> --case f b of
1003a1107
> unfoldrJust (a,new_b:: (b->->aMaybe: unfoldra, b))new_b-> b -> [a]
1003a1108
> unfoldrNothing b  =    -> []
1005c1110
<    Just (a,new_b) -> a : unfoldr f new_b
---
> -- ----------------------------------------------------------------------------- (a,new_b) -> a : unfoldr f new_b
1007d1111
< 
1008d1111
< -- -----------------------------------------------------------------------------
1009d1111
< 
1011c1113
< foldl'           :: (b -> a -> b) -> b -> [a] -> b
---
> foldl'-- -----------------------------------------------------------------------------:: (b -> a -> b) -> b -> [a] -> b
1013d1114
<     where lgo z []     = z
1014d1114
<           lgo z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
1015d1114
< 
1016d1114
< -- | 'foldl1' is a variant of 'foldl' that has no starting value argument,
1017c1115
< -- and thus must be applied to non-empty lists.
---
> -- | A strict version of 'foldl'.where lgo z []     = z
1017a1116
> foldl'    lgo z (::x:xsb ->= let ->z'b) ->f zbx->in[az'] ->`seq` lgo z' xs
1017a1117
> foldl' f z0 xs0 = lgo z0 xs0
1017a1118
> -- | 'foldl1' is a variant of 'foldl' that has no starting value argument,where lgo z []     = z
1017a1119
>                                                                       -- and thus must be applied to non-empty lists. z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
1019d1120
< foldl1 f (x:xs)         =  foldl f x xs
1020d1120
< foldl1 _ []             =  errorEmptyList "foldl1"
1021d1120
< 
1022d1120
< -- | A strict version of 'foldl1'
1023c1121
< foldl1'                  :: (a -> a -> a) -> [a] -> a
---
> foldl1-- | 'foldl1' is a variant of 'foldl' that has no starting value argument,f (x:xs)         =  foldl f x xs
1023a1122
> foldl1-- and thus must be applied to non-empty lists._ []             =  errorEmptyList "foldl1"
1023a1123
> foldl1                  :: (a -> a -> a) -> [a] -> a
1023a1124
> foldl1-- | A strict version of 'foldl1' (x:xs)         =  foldl f x xs
1023a1125
> foldl1foldl1'_ []             =::errorEmptyList(a -> a -> a) "foldl1"-> [a] -> a
1025d1126
< foldl1' _ []             =  errorEmptyList "foldl1'"
1026d1126
< 
1027d1126
< -- -----------------------------------------------------------------------------
1028c1127
< -- List sum and product
---
> foldl1'-- | A strict version of 'foldl1'_ []             =  errorEmptyList "foldl1'"
1028a1128
> foldl1'                  :: (a -> a -> a) -> [a] -> a
1028a1129
> foldl1'-- ----------------------------------------------------------------------------- (x:xs)         =  foldl' f x xs
1028a1130
> foldl1'-- List sum and product []             =  errorEmptyList "foldl1'"
1030d1131
< {-# SPECIALISE sum     :: [Int] -> Int #-}
1031c1132
< {-# SPECIALISE sum     :: [Integer] -> Integer #-}
---
> {-# SPECIALISE-- -----------------------------------------------------------------------------sum     :: [Int] -> Int #-}
1031a1133
> {-# SPECIALISE-- List sum and productsum     :: [Integer] -> Integer #-}
1033d1134
< {-# SPECIALISE product :: [Int] -> Int #-}
1034c1135
< {-# SPECIALISE product :: [Integer] -> Integer #-}
---
> {-# SPECIALISE sumproduct :: [Int] -> Int #-}
1034a1136
> {-# SPECIALISE sumproduct :: [Integer] -> Integer #-}
1034a1137
> {-# INLINABLE sumproduct#-} #-}
1034a1138
> {-# SPECIALISE-- We make 'sum' and 'product' inlinable so that we get specialisations :: [Int] -> Int #-}
1034a1139
> {-# SPECIALISE-- at other types.  See, for example, Trac #7507. :: [Integer] -> Integer #-}
1036d1140
< -- We make 'sum' and 'product' inlinable so that we get specialisations
1037d1140
< -- at other types.  See, for example, Trac #7507.
1038d1140
< 
1039d1140
< -- | The 'sum' function computes the sum of a finite list of numbers.
1040c1141
< sum                     :: (Num a) => [a] -> a
---
> -- | The 'sum' function computes the sum of a finite list of numbers.-- We make 'sum' and 'product' inlinable so that we get specialisations
1040a1142
> sum-- at other types.  See, for example, Trac #7507.:: (Num a) => [a] -> a
1042d1143
< product                 :: (Num a) => [a] -> a
1043d1143
< #ifdef USE_REPORT_PRELUDE
1044d1143
< sum                     =  foldl (+) 0
1045c1144
< product                 =  foldl (*) 1
---
> product-- | The 'sum' function computes the sum of a finite list of numbers.:: (Num a) => [a] -> a
1045a1145
> sum#ifdef USE_REPORT_PRELUDE:: (Num a) => [a] -> a
1045a1146
> sum-- | The 'product' function computes the product of a finite list of numbers.=  foldl (+) 0
1045a1147
> product                 ::=  (foldlNum a)*=>) 1[a] -> a
1050d1151
<     sum' (x:xs) a = sum' xs (a+x)
1051d1151
< product l       = prod l 1
1052d1151
<   where
1053d1151
<     prod []     a = a
1054d1151
<     prod (x:xs) a = prod xs (a*x)
1055d1151
< #endif
1056d1151
< 
1057d1151
< -- -----------------------------------------------------------------------------
1058d1151
< -- Functions on strings
1059d1151
< 
1060d1151
< -- | 'lines' breaks a string up into a list of strings at newline
1061d1151
< -- characters.  The resulting strings do not contain newlines.
1062d1151
< lines                   :: String -> [String]
1063d1151
< lines ""                =  []
1064d1151
< -- Somehow GHC doesn't detect the selector thunks in the below code,
1065d1151
< -- so s' keeps a reference to the first line via the pair and we have
1066d1151
< -- a space leak (cf. #4334).
1067d1151
< -- So we need to make GHC see the selector thunks with a trick.
1068d1151
< lines s                 =  cons (case break (== '\n') s of
1069d1151
<                                     (l, s') -> (l, case s' of
1070d1151
<                                                     []      -> []
1071d1151
<                                                     _:s''   -> lines s''))
1072d1151
<   where
1073d1151
<     cons ~(h, t)        =  h : t
1074d1151
< 
1075d1151
< -- | 'unlines' is an inverse operation to 'lines'.
1076d1151
< -- It joins lines, after appending a terminating newline to each.
1077d1151
< unlines                 :: [String] -> String
1078d1151
< #ifdef USE_REPORT_PRELUDE
1079d1151
< unlines                 =  concatMap (++ "\n")
1080d1151
< #else
1081d1151
< -- HBC version (stolen)
1082d1151
< -- here's a more efficient version
1083d1151
< unlines [] = []
1084d1151
< unlines (l:ls) = l ++ '\n' : unlines ls
1085d1151
< #endif
1086d1151
< 
1087d1151
< -- | 'words' breaks a string up into a list of words, which were delimited
1088d1151
< -- by white space.
1089d1151
< words                   :: String -> [String]
1090d1151
< words s                 =  case dropWhile {-partain:Char.-}isSpace s of
1091d1151
<                                 "" -> []
1092d1151
<                                 s' -> w : words s''
1093d1151
<                                       where (w, s'') =
1094d1151
<                                              break {-partain:Char.-}isSpace s'
1095d1151
< 
1096d1151
< -- | 'unwords' is an inverse operation to 'words'.
1097d1151
< -- It joins words with separating spaces.
1098d1151
< unwords                 :: [String] -> String
1099d1151
< #ifdef USE_REPORT_PRELUDE
1100d1151
< unwords []              =  ""
1101d1151
< unwords ws              =  foldr1 (\w s -> w ++ ' ':s) ws
1102d1151
< #else
1103d1151
< -- HBC version (stolen)
1104d1151
< -- here's a more efficient version
1105d1151
< unwords []              =  ""
1106d1151
< unwords [w]             = w
1107d1151
< unwords (w:ws)          = w ++ ' ' : unwords ws
1108d1151
< #endif
1109d1151
< 
1110d1151
< {- A "SnocBuilder" is a version of Chris Okasaki's banker's queue that supports
1111d1151
< toListSB instead of uncons. In single-threaded use, its performance
1112d1151
< characteristics are similar to John Hughes's functional difference lists, but
1113d1151
< likely somewhat worse. In heavily persistent settings, however, it does much
1114d1151
< better, because it takes advantage of sharing. The banker's queue guarantees
1115d1151
< (amortized) O(1) snoc and O(1) uncons, meaning that we can think of toListSB as
1116d1151
< an O(1) conversion to a list-like structure a constant factor slower than
1117d1151
< normal lists--we pay the O(n) cost incrementally as we consume the list. Using
1118d1151
< functional difference lists, on the other hand, we would have to pay the whole
1119d1151
< cost up front for each output list. -}
1120d1151
< 
1121d1151
< {- We store a front list, a rear list, and the length of the queue.  Because we
1122d1151
< only snoc onto the queue and never uncons, we know it's time to rotate when the
1123d1151
< length of the queue plus 1 is a power of 2. Note that we rely on the value of
1124d1151
< the length field only for performance.  In the unlikely event of overflow, the
1125d1151
< performance will suffer but the semantics will remain correct.  -}
1126d1151
< 
1127d1151
< data SnocBuilder a = SnocBuilder {-# UNPACK #-} !Word [a] [a]
1128d1151
< 
1129d1151
< {- Smart constructor that rotates the builder when lp is one minus a power of
1130d1151
< 2. Does not rotate very small builders because doing so is not worth the
1131d1151
< trouble. The lp < 255 test goes first because the power-of-2 test gives awful
1132d1151
< branch prediction for very small n (there are 5 powers of 2 between 1 and
1133d1151
< 16). Putting the well-predicted lp < 255 test first avoids branching on the
1134d1151
< power-of-2 test until powers of 2 have become sufficiently rare to be predicted
1135d1151
< well. -}
1136d1151
< 
1137d1151
< {-# INLINE sb #-}
1138d1151
< sb :: Word -> [a] -> [a] -> SnocBuilder a
1139d1151
< sb lp f r
1140d1151
<   | lp < 255 || (lp .&. (lp + 1)) /= 0 = SnocBuilder lp f r
1141d1151
<   | otherwise                          = SnocBuilder lp (f ++ reverse r) []
1142d1151
< 
1143d1151
< -- The empty builder
1144d1151
< 
1145d1151
< emptySB :: SnocBuilder a
1146d1151
< emptySB = SnocBuilder 0 [] []
1147d1151
< 
1148d1151
< -- Add an element to the end of a queue.
1149d1151
< 
1150d1151
< snocSB :: SnocBuilder a -> a -> SnocBuilder a
1151d1151
< snocSB (SnocBuilder lp f r) x = sb (lp + 1) f (x:r)
1152d1151
< 
1153c1152
< -- Convert a builder to a list
---
> sum sum'l(x:xs) = sum'= sum' 0xs (a+x)
1153a1153
> productwhere l       = prod l 1
1153a1154
>   where []     a = a
1153a1155
>     sum' (x:xs) a = sum'a    xs (a+x)
1153a1156
> productprodl(x:xs) = prod= prod 1xs (a*x)
1155d1157
< toListSB :: SnocBuilder a -> [a]
1156d1157
< toListSB (SnocBuilder _ f r) = f ++ reverse r
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE CPP, NoImplicitPrelude, MagicHash, BangPatterns #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.List
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Operations on lists.
--
-----------------------------------------------------------------------------

module Data.List
   (
   -- * Basic functions

     (++)
   , head
   , last
   , tail
   , init
   , null
   , length

   -- * List transformations
   , map
   , reverse

   , intersperse
   , intercalate
   , transpose

   , subsequences
   , permutations

   -- * Reducing lists (folds)

   , foldl
   , foldl'
   , foldl1
   , foldl1'
   , foldr
   , foldr1

   -- ** Special folds

   , concat
   , concatMap
   , and
   , or
   , any
   , all
   , sum
   , product
   , maximum
   , minimum

   -- * Building lists

   -- ** Scans
   , scanl
   , scanl1
   , scanr
   , scanr1

   -- ** Accumulating maps
   , mapAccumL
   , mapAccumR

   -- ** Infinite lists
   , iterate
   , repeat
   , replicate
   , cycle

   -- ** Unfolding
   , unfoldr

   -- * Sublists

   -- ** Extracting sublists
   , take
   , drop
   , splitAt

   , takeWhile
   , dropWhile
   , dropWhileEnd
   , span
   , break

   , stripPrefix

   , group

   , inits
   , tails

   -- ** Predicates
   , isPrefixOf
   , isSuffixOf
   , isInfixOf

   -- * Searching lists

   -- ** Searching by equality
   , elem
   , notElem
   , lookup

   -- ** Searching with a predicate
   , find
   , filter
   , partition

   -- * Indexing lists
   -- | These functions treat a list @xs@ as a indexed collection,
   -- with indices ranging from 0 to @'length' xs - 1@.

   , (!!)

   , elemIndex
   , elemIndices

   , findIndex
   , findIndices

   -- * Zipping and unzipping lists

   , zip
   , zip3
   , zip4, zip5, zip6, zip7

   , zipWith
   , zipWith3
   , zipWith4, zipWith5, zipWith6, zipWith7

   , unzip
   , unzip3
   , unzip4, unzip5, unzip6, unzip7

   -- * Special lists

   -- ** Functions on strings
   , lines
   , words
   , unlines
   , unwords

   -- ** \"Set\" operations

   , nub

   , delete
   , (\\)

   , union
   , intersect

   -- ** Ordered lists
   , sort
   , insert

   -- * Generalized functions

   -- ** The \"@By@\" operations
   -- | By convention, overloaded functions have a non-overloaded
   -- counterpart whose name is suffixed with \`@By@\'.
   --
   -- It is often convenient to use these functions together with
   -- 'Data.Function.on', for instance @'sortBy' ('compare'
   -- \`on\` 'fst')@.

   -- *** User-supplied equality (replacing an @Eq@ context)
   -- | The predicate is assumed to define an equivalence.
   , nubBy
   , deleteBy
   , deleteFirstsBy
   , unionBy
   , intersectBy
   , groupBy

   -- *** User-supplied comparison (replacing an @Ord@ context)
   -- | The function is assumed to define a total ordering.
   , sortBy
   , insertBy
   , maximumBy
   , minimumBy

   -- ** The \"@generic@\" operations
   -- | The prefix \`@generic@\' indicates an overloaded function that
   -- is a generalized version of a "Prelude" function.

   , genericLength
   , genericTake
   , genericDrop
   , genericSplitAt
   , genericIndex
   , genericReplicate

   ) where

import Data.Maybe
import Data.Bits        ( (.&.) )
import Data.Char        ( isSpace )

import GHC.Num
import GHC.Real
import GHC.List
import GHC.Base

infix 5 \\ -- comment to fool cpp

-- -----------------------------------------------------------------------------
-- List functions

-- | The 'dropWhileEnd' function drops the largest suffix of a list
-- in which the given predicate holds for all elements.  For example:
--
-- > dropWhileEnd isSpace "foo\n" == "foo"
-- > dropWhileEnd isSpace "foo bar" == "foo bar"
-- > dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--
-- /Since: 4.5.0.0/
dropWhileEnd :: (a -> Bool) -> [a] -> [a]
dropWhileEnd p = foldr (\x xs -> if p x && null xs then [] else x : xs) []

-- | The 'stripPrefix' function drops the given prefix from a list.
-- It returns 'Nothing' if the list did not start with the prefix
-- given, or 'Just' the list after the prefix, if it does.
--
-- > stripPrefix "foo" "foobar" == Just "bar"
-- > stripPrefix "foo" "foo" == Just ""
-- > stripPrefix "foo" "barfoo" == Nothing
-- > stripPrefix "foo" "barfoobaz" == Nothing
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
stripPrefix [] ys = Just ys
stripPrefix (x:xs) (y:ys)
 | x == y = stripPrefix xs ys
stripPrefix _ _ = Nothing

-- | The 'elemIndex' function returns the index of the first element
-- in the given list which is equal (by '==') to the query element,
-- or 'Nothing' if there is no such element.
elemIndex       :: Eq a => a -> [a] -> Maybe Int
elemIndex x     = findIndex (x==)

-- | The 'elemIndices' function extends 'elemIndex', by returning the
-- indices of all elements equal to the query element, in ascending order.
elemIndices     :: Eq a => a -> [a] -> [Int]
elemIndices x   = findIndices (x==)

-- | The 'find' function takes a predicate and a list and returns the
-- first element in the list matching the predicate, or 'Nothing' if
-- there is no such element.
find            :: (a -> Bool) -> [a] -> Maybe a
find p          = listToMaybe . filter p

-- | The 'findIndex' function takes a predicate and a list and returns
-- the index of the first element in the list satisfying the predicate,
-- or 'Nothing' if there is no such element.
findIndex       :: (a -> Bool) -> [a] -> Maybe Int
findIndex p     = listToMaybe . findIndices p

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices      :: (a -> Bool) -> [a] -> [Int]
#ifdef USE_REPORT_PRELUDE
findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
#else
-- Efficient definition
findIndices p ls = loop 0# ls
                 where
                   loop _ [] = []
                   loop n (x:xs) | p x       = I# n : loop (n +# 1#) xs
                                 | otherwise = loop (n +# 1#) xs
#endif  /* USE_REPORT_PRELUDE */

-- | The 'isPrefixOf' function takes two lists and returns 'True'
-- iff the first list is a prefix of the second.
isPrefixOf              :: (Eq a) => [a] -> [a] -> Bool
isPrefixOf [] _         =  True
isPrefixOf _  []        =  False
isPrefixOf (x:xs) (y:ys)=  x == y && isPrefixOf xs ys

-- | The 'isSuffixOf' function takes two lists and returns 'True'
-- iff the first list is a suffix of the second.
-- Both lists must be finite.
isSuffixOf              :: (Eq a) => [a] -> [a] -> Bool
isSuffixOf x y          =  reverse x `isPrefixOf` reverse y

-- | The 'isInfixOf' function takes two lists and returns 'True'
-- iff the first list is contained, wholly and intact,
-- anywhere within the second.
--
-- Example:
--
-- >isInfixOf "Haskell" "I really like Haskell." == True
-- >isInfixOf "Ial" "I really like Haskell." == False
isInfixOf               :: (Eq a) => [a] -> [a] -> Bool
isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)

-- | /O(n^2)/. The 'nub' function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name 'nub' means \`essence\'.)
-- It is a special case of 'nubBy', which allows the programmer to supply
-- their own equality test.
nub                     :: (Eq a) => [a] -> [a]
#ifdef USE_REPORT_PRELUDE
nub                     =  nubBy (==)
#else
-- stolen from HBC
nub l                   = nub' l []             -- '
  where
    nub' [] _           = []                    -- '
    nub' (x:xs) ls                              -- '
        | x `elem` ls   = nub' xs ls            -- '
        | otherwise     = x : nub' xs (x:ls)    -- '
#endif

-- | The 'nubBy' function behaves just like 'nub', except it uses a
-- user-supplied equality predicate instead of the overloaded '=='
-- function.
nubBy                   :: (a -> a -> Bool) -> [a] -> [a]
#ifdef USE_REPORT_PRELUDE
nubBy eq []             =  []
nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
#else
nubBy eq l              = nubBy' l []
  where
    nubBy' [] _         = []
    nubBy' (y:ys) xs
       | elem_by eq y xs = nubBy' ys xs
       | otherwise       = y : nubBy' ys (y:xs)

-- Not exported:
-- Note that we keep the call to `eq` with arguments in the
-- same order as in the reference implementation
-- 'xs' is the list of things we've seen so far,
-- 'y' is the potential new element
elem_by :: (a -> a -> Bool) -> a -> [a] -> Bool
elem_by _  _ []         =  False
elem_by eq y (x:xs)     =  y `eq` x || elem_by eq y xs
#endif


-- | 'delete' @x@ removes the first occurrence of @x@ from its list argument.
-- For example,
--
-- > delete 'a' "banana" == "bnana"
--
-- It is a special case of 'deleteBy', which allows the programmer to
-- supply their own equality test.

delete                  :: (Eq a) => a -> [a] -> [a]
delete                  =  deleteBy (==)

-- | The 'deleteBy' function behaves like 'delete', but takes a
-- user-supplied equality predicate.
deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteBy _  _ []        = []
deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys

-- | The '\\' function is list difference (non-associative).
-- In the result of @xs@ '\\' @ys@, the first occurrence of each element of
-- @ys@ in turn (if any) has been removed from @xs@.  Thus
--
-- > (xs ++ ys) \\ xs == ys.
--
-- It is a special case of 'deleteFirstsBy', which allows the programmer
-- to supply their own equality test.

(\\)                    :: (Eq a) => [a] -> [a] -> [a]
(\\)                    =  foldl (flip delete)

-- | The 'union' function returns the list union of the two lists.
-- For example,
--
-- > "dog" `union` "cow" == "dogcw"
--
-- Duplicates, and elements of the first list, are removed from the
-- the second list, but if the first list contains duplicates, so will
-- the result.
-- It is a special case of 'unionBy', which allows the programmer to supply
-- their own equality test.

union                   :: (Eq a) => [a] -> [a] -> [a]
union                   = unionBy (==)

-- | The 'unionBy' function is the non-overloaded version of 'union'.
unionBy                 :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs

-- | The 'intersect' function takes the list intersection of two lists.
-- For example,
--
-- > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--
-- If the first list contains duplicates, so will the result.
--
-- > [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--
-- It is a special case of 'intersectBy', which allows the programmer to
-- supply their own equality test. If the element is found in both the first
-- and the second list, the element from the first list will be used.

intersect               :: (Eq a) => [a] -> [a] -> [a]
intersect               =  intersectBy (==)

-- | The 'intersectBy' function is the non-overloaded version of 'intersect'.
intersectBy             :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy _  [] _     =  []
intersectBy _  _  []    =  []
intersectBy eq xs ys    =  [x | x <- xs, any (eq x) ys]

-- | The 'intersperse' function takes an element and a list and
-- \`intersperses\' that element between the elements of the list.
-- For example,
--
-- > intersperse ',' "abcde" == "a,b,c,d,e"

intersperse             :: a -> [a] -> [a]
intersperse _   []      = []
intersperse sep (x:xs)  = x : prependToAll sep xs


-- Not exported:
-- We want to make every element in the 'intersperse'd list available
-- as soon as possible to avoid space leaks. Experiments suggested that
-- a separate top-level helper is more efficient than a local worker.
prependToAll            :: a -> [a] -> [a]
prependToAll _   []     = []
prependToAll sep (x:xs) = sep : x : prependToAll sep xs

-- | 'intercalate' @xs xss@ is equivalent to @('concat' ('intersperse' xs xss))@.
-- It inserts the list @xs@ in between the lists in @xss@ and concatenates the
-- result.
intercalate :: [a] -> [[a]] -> [a]
intercalate xs xss = concat (intersperse xs xss)

-- | The 'transpose' function transposes the rows and columns of its argument.
-- For example,
--
-- > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]

transpose               :: [[a]] -> [[a]]
transpose []             = []
transpose ([]   : xss)   = transpose xss
transpose ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])


-- | The 'partition' function takes a predicate a list and returns
-- the pair of lists of elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p xs == (filter p xs, filter (not . p) xs)

partition               :: (a -> Bool) -> [a] -> ([a],[a])
{-# INLINE partition #-}
partition p xs = foldr (select p) ([],[]) xs

select :: (a -> Bool) -> a -> ([a], [a]) -> ([a], [a])
select p x ~(ts,fs) | p x       = (x:ts,fs)
                    | otherwise = (ts, x:fs)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a list, passing
-- an accumulating parameter from left to right, and returning a final
-- value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -- Function of elt of input list
                                    -- and accumulator, returning new
                                    -- accumulator and elt of result list
          -> acc            -- Initial accumulator
          -> [x]            -- Input list
          -> (acc, [y])     -- Final accumulator and result list
mapAccumL _ s []        =  (s, [])
mapAccumL f s (x:xs)    =  (s'',y:ys)
                           where (s', y ) = f s x
                                 (s'',ys) = mapAccumL f s' xs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a list, passing
-- an accumulating parameter from right to left, and returning a final
-- value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y))     -- Function of elt of input list
                                        -- and accumulator, returning new
                                        -- accumulator and elt of result list
            -> acc              -- Initial accumulator
            -> [x]              -- Input list
            -> (acc, [y])               -- Final accumulator and result list
mapAccumR _ s []        =  (s, [])
mapAccumR f s (x:xs)    =  (s'', y:ys)
                           where (s'',y ) = f s' x
                                 (s', ys) = mapAccumR f s xs

-- | The 'insert' function takes an element and a list and inserts the
-- element into the list at the first position where it is less
-- than or equal to the next element.  In particular, if the list
-- is sorted before the call, the result will also be sorted.
-- It is a special case of 'insertBy', which allows the programmer to
-- supply their own comparison function.
insert :: Ord a => a -> [a] -> [a]
insert e ls = insertBy (compare) e ls

-- | The non-overloaded version of 'insert'.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
insertBy _   x [] = [x]
insertBy cmp x ys@(y:ys')
 = case cmp x y of
     GT -> y : insertBy cmp x ys'
     _  -> x : ys

-- | 'maximum' returns the maximum value from a list,
-- which must be non-empty, finite, and of an ordered type.
-- It is a special case of 'Data.List.maximumBy', which allows the
-- programmer to supply their own comparison function.
maximum                 :: (Ord a) => [a] -> a
{-# NOINLINE [1] maximum #-}
maximum []              =  errorEmptyList "maximum"
maximum xs              =  foldl1 max xs

{-# RULES
  "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int);
  "maximumInteger" maximum = (strictMaximum :: [Integer] -> Integer)
 #-}

-- We can't make the overloaded version of maximum strict without
-- changing its semantics (max might not be strict), but we can for
-- the version specialised to 'Int'.
strictMaximum           :: (Ord a) => [a] -> a
strictMaximum []        =  errorEmptyList "maximum"
strictMaximum xs        =  foldl1' max xs

-- | 'minimum' returns the minimum value from a list,
-- which must be non-empty, finite, and of an ordered type.
-- It is a special case of 'Data.List.minimumBy', which allows the
-- programmer to supply their own comparison function.
minimum                 :: (Ord a) => [a] -> a
{-# NOINLINE [1] minimum #-}
minimum []              =  errorEmptyList "minimum"
minimum xs              =  foldl1 min xs

{-# RULES
  "minimumInt"     minimum = (strictMinimum :: [Int]     -> Int);
  "minimumInteger" minimum = (strictMinimum :: [Integer] -> Integer)
 #-}

strictMinimum           :: (Ord a) => [a] -> a
strictMinimum []        =  errorEmptyList "minimum"
strictMinimum xs        =  foldl1' min xs

-- | The 'maximumBy' function takes a comparison function and a list
-- and returns the greatest element of the list by the comparison function.
-- The list must be finite and non-empty.
maximumBy               :: (a -> a -> Ordering) -> [a] -> a
maximumBy _ []          =  error "List.maximumBy: empty list"
maximumBy cmp xs        =  foldl1 maxBy xs
                        where
                           maxBy x y = case cmp x y of
                                       GT -> x
                                       _  -> y

-- | The 'minimumBy' function takes a comparison function and a list
-- and returns the least element of the list by the comparison function.
-- The list must be finite and non-empty.
minimumBy               :: (a -> a -> Ordering) -> [a] -> a
minimumBy _ []          =  error "List.minimumBy: empty list"
minimumBy cmp xs        =  foldl1 minBy xs
                        where
                           minBy x y = case cmp x y of
                                       GT -> y
                                       _  -> x

-- | The 'genericLength' function is an overloaded version of 'length'.  In
-- particular, instead of returning an 'Int', it returns any type which is
-- an instance of 'Num'.  It is, however, less efficient than 'length'.
genericLength           :: (Num i) => [a] -> i
{-# NOINLINE [1] genericLength #-}
genericLength []        =  0
genericLength (_:l)     =  1 + genericLength l

{-# RULES
  "genericLengthInt"     genericLength = (strictGenericLength :: [a] -> Int);
  "genericLengthInteger" genericLength = (strictGenericLength :: [a] -> Integer);
 #-}

strictGenericLength     :: (Num i) => [b] -> i
strictGenericLength l   =  gl l 0
                        where
                           gl [] a     = a
                           gl (_:xs) a = let a' = a + 1 in a' `seq` gl xs a'

-- | The 'genericTake' function is an overloaded version of 'take', which
-- accepts any 'Integral' value as the number of elements to take.
genericTake             :: (Integral i) => i -> [a] -> [a]
genericTake n _ | n <= 0 = []
genericTake _ []        =  []
genericTake n (x:xs)    =  x : genericTake (n-1) xs

-- | The 'genericDrop' function is an overloaded version of 'drop', which
-- accepts any 'Integral' value as the number of elements to drop.
genericDrop             :: (Integral i) => i -> [a] -> [a]
genericDrop n xs | n <= 0 = xs
genericDrop _ []        =  []
genericDrop n (_:xs)    =  genericDrop (n-1) xs


-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which
-- accepts any 'Integral' value as the position at which to split.
genericSplitAt          :: (Integral i) => i -> [a] -> ([a], [a])
genericSplitAt n xs | n <= 0 =  ([],xs)
genericSplitAt _ []     =  ([],[])
genericSplitAt n (x:xs) =  (x:xs',xs'') where
    (xs',xs'') = genericSplitAt (n-1) xs

-- | The 'genericIndex' function is an overloaded version of '!!', which
-- accepts any 'Integral' value as the index.
genericIndex :: (Integral i) => [a] -> i -> a
genericIndex (x:_)  0 = x
genericIndex (_:xs) n
 | n > 0     = genericIndex xs (n-1)
 | otherwise = error "List.genericIndex: negative argument."
genericIndex _ _      = error "List.genericIndex: index too large."

-- | The 'genericReplicate' function is an overloaded version of 'replicate',
-- which accepts any 'Integral' value as the number of repetitions to make.
genericReplicate        :: (Integral i) => i -> a -> [a]
genericReplicate n x    =  genericTake n (repeat x)

-- | The 'zip4' function takes four lists and returns a list of
-- quadruples, analogous to 'zip'.
zip4                    :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
zip4                    =  zipWith4 (,,,)

-- | The 'zip5' function takes five lists and returns a list of
-- five-tuples, analogous to 'zip'.
zip5                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
zip5                    =  zipWith5 (,,,,)

-- | The 'zip6' function takes six lists and returns a list of six-tuples,
-- analogous to 'zip'.
zip6                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
                              [(a,b,c,d,e,f)]
zip6                    =  zipWith6 (,,,,,)

-- | The 'zip7' function takes seven lists and returns a list of
-- seven-tuples, analogous to 'zip'.
zip7                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
                              [g] -> [(a,b,c,d,e,f,g)]
zip7                    =  zipWith7 (,,,,,,)

-- | The 'zipWith4' function takes a function which combines four
-- elements, as well as four lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith4                :: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)
                        =  z a b c d : zipWith4 z as bs cs ds
zipWith4 _ _ _ _ _      =  []

-- | The 'zipWith5' function takes a function which combines five
-- elements, as well as five lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith5                :: (a->b->c->d->e->f) ->
                           [a]->[b]->[c]->[d]->[e]->[f]
zipWith5 z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
                        =  z a b c d e : zipWith5 z as bs cs ds es
zipWith5 _ _ _ _ _ _    = []

-- | The 'zipWith6' function takes a function which combines six
-- elements, as well as six lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith6                :: (a->b->c->d->e->f->g) ->
                           [a]->[b]->[c]->[d]->[e]->[f]->[g]
zipWith6 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
                        =  z a b c d e f : zipWith6 z as bs cs ds es fs
zipWith6 _ _ _ _ _ _ _  = []

-- | The 'zipWith7' function takes a function which combines seven
-- elements, as well as seven lists and returns a list of their point-wise
-- combination, analogous to 'zipWith'.
zipWith7                :: (a->b->c->d->e->f->g->h) ->
                           [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
zipWith7 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
                   =  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
zipWith7 _ _ _ _ _ _ _ _ = []

-- | The 'unzip4' function takes a list of quadruples and returns four
-- lists, analogous to 'unzip'.
unzip4                  :: [(a,b,c,d)] -> ([a],[b],[c],[d])
unzip4                  =  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
                                        (a:as,b:bs,c:cs,d:ds))
                                 ([],[],[],[])

-- | The 'unzip5' function takes a list of five-tuples and returns five
-- lists, analogous to 'unzip'.
unzip5                  :: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
unzip5                  =  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
                                        (a:as,b:bs,c:cs,d:ds,e:es))
                                 ([],[],[],[],[])

-- | The 'unzip6' function takes a list of six-tuples and returns six
-- lists, analogous to 'unzip'.
unzip6                  :: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
unzip6                  =  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
                                        (a:as,b:bs,c:cs,d:ds,e:es,f:fs))
                                 ([],[],[],[],[],[])

-- | The 'unzip7' function takes a list of seven-tuples and returns
-- seven lists, analogous to 'unzip'.
unzip7          :: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])
unzip7          =  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
                                (a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
                         ([],[],[],[],[],[],[])


-- | The 'deleteFirstsBy' function takes a predicate and two lists and
-- returns the first list with the first occurrence of each element of
-- the second list removed.
deleteFirstsBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]
deleteFirstsBy eq       =  foldl (flip (deleteBy eq))

-- | The 'group' function takes a list and returns a list of lists such
-- that the concatenation of the result is equal to the argument.  Moreover,
-- each sublist in the result contains only equal elements.  For example,
--
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--
-- It is a special case of 'groupBy', which allows the programmer to supply
-- their own equality test.
group                   :: Eq a => [a] -> [[a]]
group                   =  groupBy (==)

-- | The 'groupBy' function is the non-overloaded version of 'group'.
groupBy                 :: (a -> a -> Bool) -> [a] -> [[a]]
groupBy _  []           =  []
groupBy eq (x:xs)       =  (x:ys) : groupBy eq zs
                           where (ys,zs) = span (eq x) xs

-- | The 'inits' function returns all initial segments of the argument,
-- shortest first.  For example,
--
-- > inits "abc" == ["","a","ab","abc"]
--
-- Note that 'inits' has the following strictness property:
-- @inits (xs ++ _|_) = inits xs ++ _|_@
--
-- In particular,
-- @inits _|_ = [] : _|_@
inits                   :: [a] -> [[a]]
inits                   = map toListSB . scanl' snocSB emptySB
{-# NOINLINE inits #-}

-- We do not allow inits to inline, because it plays havoc with Call Arity
-- if it fuses with a consumer, and it would generally lead to serious
-- loss of sharing if allowed to fuse with a producer.

-- | A strictly accumulating version of 'scanl'
{-# NOINLINE [1] scanl' #-}
scanl'           :: (b -> a -> b) -> b -> [a] -> [b]
-- This peculiar form is needed to prevent scanl' from being rewritten
-- in its own right hand side.
scanl' = scanlGo'
  where
    scanlGo' :: (b -> a -> b) -> b -> [a] -> [b]
    scanlGo' f !q ls    = q : (case ls of
                            []   -> []
                            x:xs -> scanlGo' f (f q x) xs)

-- | The 'tails' function returns all final segments of the argument,
-- longest first.  For example,
--
-- > tails "abc" == ["abc", "bc", "c",""]
--
-- Note that 'tails' has the following strictness property:
-- @tails _|_ = _|_ : _|_@
tails                   :: [a] -> [[a]]
tails xs                =  xs : case xs of
                                  []      -> []
                                  _ : xs' -> tails xs'

-- | The 'subsequences' function returns the list of all subsequences of the argument.
--
-- > subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
subsequences            :: [a] -> [[a]]
subsequences xs         =  [] : nonEmptySubsequences xs

-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,
--   except for the empty list.
--
-- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"]
nonEmptySubsequences         :: [a] -> [[a]]
nonEmptySubsequences []      =  []
nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
  where f ys r = ys : (x : ys) : r


-- | The 'permutations' function returns the list of all permutations of the argument.
--
-- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
permutations            :: [a] -> [[a]]
permutations xs0        =  xs0 : perms xs0 []
  where
    perms []     _  = []
    perms (t:ts) is = foldr interleave (perms ts (t:is)) (permutations is)
      where interleave    xs     r = let (_,zs) = interleave' id xs r in zs
            interleave' _ []     r = (ts, r)
            interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r
                                     in  (y:us, f (t:y:us) : zs)


------------------------------------------------------------------------------
-- Quick Sort algorithm taken from HBC's QSort library.

-- | The 'sort' function implements a stable sorting algorithm.
-- It is a special case of 'sortBy', which allows the programmer to supply
-- their own comparison function.
sort :: (Ord a) => [a] -> [a]

-- | The 'sortBy' function is the non-overloaded version of 'sort'.
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

#ifdef USE_REPORT_PRELUDE
sort = sortBy compare
sortBy cmp = foldr (insertBy cmp) []
#else

{-
GHC's mergesort replaced by a better implementation, 24/12/2009.
This code originally contributed to the nhc12 compiler by Thomas Nordin
in 2002.  Rumoured to have been based on code by Lennart Augustsson, e.g.
    http://www.mail-archive.com/haskell@haskell.org/msg01822.html
and possibly to bear similarities to a 1982 paper by Richard O'Keefe:
"A smooth applicative merge sort".

Benchmarks show it to be often 2x the speed of the previous implementation.
Fixes ticket http://hackage.haskell.org/trac/ghc/ticket/2143
-}

sort = sortBy compare
sortBy cmp = mergeAll . sequences
  where
    sequences (a:b:xs)
      | a `cmp` b == GT = descending b [a]  xs
      | otherwise       = ascending  b (a:) xs
    sequences xs = [xs]

    descending a as (b:bs)
      | a `cmp` b == GT = descending b (a:as) bs
    descending a as bs  = (a:as): sequences bs

    ascending a as (b:bs)
      | a `cmp` b /= GT = ascending b (\ys -> as (a:ys)) bs
    ascending a as bs   = as [a]: sequences bs

    mergeAll [x] = x
    mergeAll xs  = mergeAll (mergePairs xs)

    mergePairs (a:b:xs) = merge a b: mergePairs xs
    mergePairs xs       = xs

    merge as@(a:as') bs@(b:bs')
      | a `cmp` b == GT = b:merge as  bs'
      | otherwise       = a:merge as' bs
    merge [] bs         = bs
    merge as []         = as

{-
sortBy cmp l = mergesort cmp l
sort l = mergesort compare l

Quicksort replaced by mergesort, 14/5/2002.

From: Ian Lynagh <igloo@earth.li>

I am curious as to why the List.sort implementation in GHC is a
quicksort algorithm rather than an algorithm that guarantees n log n
time in the worst case? I have attached a mergesort implementation along
with a few scripts to time it's performance, the results of which are
shown below (* means it didn't finish successfully - in all cases this
was due to a stack overflow).

If I heap profile the random_list case with only 10000 then I see
random_list peaks at using about 2.5M of memory, whereas in the same
program using List.sort it uses only 100k.

Input style     Input length     Sort data     Sort alg    User time
stdin           10000            random_list   sort        2.82
stdin           10000            random_list   mergesort   2.96
stdin           10000            sorted        sort        31.37
stdin           10000            sorted        mergesort   1.90
stdin           10000            revsorted     sort        31.21
stdin           10000            revsorted     mergesort   1.88
stdin           100000           random_list   sort        *
stdin           100000           random_list   mergesort   *
stdin           100000           sorted        sort        *
stdin           100000           sorted        mergesort   *
stdin           100000           revsorted     sort        *
stdin           100000           revsorted     mergesort   *
func            10000            random_list   sort        0.31
func            10000            random_list   mergesort   0.91
func            10000            sorted        sort        19.09
func            10000            sorted        mergesort   0.15
func            10000            revsorted     sort        19.17
func            10000            revsorted     mergesort   0.16
func            100000           random_list   sort        3.85
func            100000           random_list   mergesort   *
func            100000           sorted        sort        5831.47
func            100000           sorted        mergesort   2.23
func            100000           revsorted     sort        5872.34
func            100000           revsorted     mergesort   2.24

mergesort :: (a -> a -> Ordering) -> [a] -> [a]
mergesort cmp = mergesort' cmp . map wrap

mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]
mergesort' _   [] = []
mergesort' _   [xs] = xs
mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)

merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]
merge_pairs _   [] = []
merge_pairs _   [xs] = [xs]
merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss

merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
merge _   [] ys = ys
merge _   xs [] = xs
merge cmp (x:xs) (y:ys)
 = case x `cmp` y of
        GT -> y : merge cmp (x:xs)   ys
        _  -> x : merge cmp    xs (y:ys)

wrap :: a -> [a]
wrap x = [x]



OLDER: qsort version

-- qsort is stable and does not concatenate.
qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
qsort _   []     r = r
qsort _   [x]    r = x:r
qsort cmp (x:xs) r = qpart cmp x xs [] [] r

-- qpart partitions and sorts the sublists
qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
qpart cmp x [] rlt rge r =
    -- rlt and rge are in reverse order and must be sorted with an
    -- anti-stable sorting
    rqsort cmp rlt (x:rqsort cmp rge r)
qpart cmp x (y:ys) rlt rge r =
    case cmp x y of
        GT -> qpart cmp x ys (y:rlt) rge r
        _  -> qpart cmp x ys rlt (y:rge) r

-- rqsort is as qsort but anti-stable, i.e. reverses equal elements
rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
rqsort _   []     r = r
rqsort _   [x]    r = x:r
rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r

rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
rqpart cmp x [] rle rgt r =
    qsort cmp rle (x:qsort cmp rgt r)
rqpart cmp x (y:ys) rle rgt r =
    case cmp y x of
        GT -> rqpart cmp x ys rle (y:rgt) r
        _  -> rqpart cmp x ys (y:rle) rgt r
-}

#endif /* USE_REPORT_PRELUDE */

-- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'
-- reduces a list to a summary value, 'unfoldr' builds a list from
-- a seed value.  The function takes the element and returns 'Nothing'
-- if it is done producing the list or returns 'Just' @(a,b)@, in which
-- case, @a@ is a prepended to the list and @b@ is used as the next
-- element in a recursive call.  For example,
--
-- > iterate f == unfoldr (\x -> Just (x, f x))
--
-- In some cases, 'unfoldr' can undo a 'foldr' operation:
--
-- > unfoldr f' (foldr f z xs) == xs
--
-- if the following holds:
--
-- > f' (f x y) = Just (x,y)
-- > f' z       = Nothing
--
-- A simple use of unfoldr:
--
-- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
-- >  [10,9,8,7,6,5,4,3,2,1]
--
unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]
unfoldr f b  =
  case f b of
   Just (a,new_b) -> a : unfoldr f new_b
   Nothing        -> []

-- -----------------------------------------------------------------------------

-- | A strict version of 'foldl'.
foldl'           :: (b -> a -> b) -> b -> [a] -> b
foldl' f z0 xs0 = lgo z0 xs0
    where lgo z []     = z
          lgo z (x:xs) = let z' = f z x in z' `seq` lgo z' xs

-- | 'foldl1' is a variant of 'foldl' that has no starting value argument,
-- and thus must be applied to non-empty lists.
foldl1                  :: (a -> a -> a) -> [a] -> a
foldl1 f (x:xs)         =  foldl f x xs
foldl1 _ []             =  errorEmptyList "foldl1"

-- | A strict version of 'foldl1'
foldl1'                  :: (a -> a -> a) -> [a] -> a
foldl1' f (x:xs)         =  foldl' f x xs
foldl1' _ []             =  errorEmptyList "foldl1'"

-- -----------------------------------------------------------------------------
-- List sum and product

{-# SPECIALISE sum     :: [Int] -> Int #-}
{-# SPECIALISE sum     :: [Integer] -> Integer #-}
{-# INLINABLE sum #-}
{-# SPECIALISE product :: [Int] -> Int #-}
{-# SPECIALISE product :: [Integer] -> Integer #-}
{-# INLINABLE product #-}
-- We make 'sum' and 'product' inlinable so that we get specialisations
-- at other types.  See, for example, Trac #7507.

-- | The 'sum' function computes the sum of a finite list of numbers.
sum                     :: (Num a) => [a] -> a
-- | The 'product' function computes the product of a finite list of numbers.
product                 :: (Num a) => [a] -> a
#ifdef USE_REPORT_PRELUDE
sum                     =  foldl (+) 0
product                 =  foldl (*) 1
#else
sum     l       = sum' l 0
  where
    sum' []     a = a
    sum' (x:xs) a = sum' xs (a+x)
product l       = prod l 1
  where
    prod []     a = a
    prod (x:xs) a = prod xs (a*x)
#endif

-- -----------------------------------------------------------------------------
-- Functions on strings

-- | 'lines' breaks a string up into a list of strings at newline
-- characters.  The resulting strings do not contain newlines.
lines                   :: String -> [String]
lines ""                =  []
-- Somehow GHC doesn't detect the selector thunks in the below code,
-- so s' keeps a reference to the first line via the pair and we have
-- a space leak (cf. #4334).
-- So we need to make GHC see the selector thunks with a trick.
lines s                 =  cons (case break (== '\n') s of
                                    (l, s') -> (l, case s' of
                                                    []      -> []
                                                    _:s''   -> lines s''))
  where
    cons ~(h, t)        =  h : t

-- | 'unlines' is an inverse operation to 'lines'.
-- It joins lines, after appending a terminating newline to each.
unlines                 :: [String] -> String
#ifdef USE_REPORT_PRELUDE
unlines                 =  concatMap (++ "\n")
#else
-- HBC version (stolen)
-- here's a more efficient version
unlines [] = []
unlines (l:ls) = l ++ '\n' : unlines ls
#endif

-- | 'words' breaks a string up into a list of words, which were delimited
-- by white space.
words                   :: String -> [String]
words s                 =  case dropWhile {-partain:Char.-}isSpace s of
                                "" -> []
                                s' -> w : words s''
                                      where (w, s'') =
                                             break {-partain:Char.-}isSpace s'

-- | 'unwords' is an inverse operation to 'words'.
-- It joins words with separating spaces.
unwords                 :: [String] -> String
#ifdef USE_REPORT_PRELUDE
unwords []              =  ""
unwords ws              =  foldr1 (\w s -> w ++ ' ':s) ws
#else
-- HBC version (stolen)
-- here's a more efficient version
unwords []              =  ""
unwords [w]             = w
unwords (w:ws)          = w ++ ' ' : unwords ws
#endif

{- A "SnocBuilder" is a version of Chris Okasaki's banker's queue that supports
toListSB instead of uncons. In single-threaded use, its performance
characteristics are similar to John Hughes's functional difference lists, but
likely somewhat worse. In heavily persistent settings, however, it does much
better, because it takes advantage of sharing. The banker's queue guarantees
(amortized) O(1) snoc and O(1) uncons, meaning that we can think of toListSB as
an O(1) conversion to a list-like structure a constant factor slower than
normal lists--we pay the O(n) cost incrementally as we consume the list. Using
functional difference lists, on the other hand, we would have to pay the whole
cost up front for each output list. -}

{- We store a front list, a rear list, and the length of the queue.  Because we
only snoc onto the queue and never uncons, we know it's time to rotate when the
length of the queue plus 1 is a power of 2. Note that we rely on the value of
the length field only for performance.  In the unlikely event of overflow, the
performance will suffer but the semantics will remain correct.  -}

data SnocBuilder a = SnocBuilder {-# UNPACK #-} !Word [a] [a]

{- Smart constructor that rotates the builder when lp is one minus a power of
2. Does not rotate very small builders because doing so is not worth the
trouble. The lp < 255 test goes first because the power-of-2 test gives awful
branch prediction for very small n (there are 5 powers of 2 between 1 and
16). Putting the well-predicted lp < 255 test first avoids branching on the
power-of-2 test until powers of 2 have become sufficiently rare to be predicted
well. -}

{-# INLINE sb #-}
sb :: Word -> [a] -> [a] -> SnocBuilder a
sb lp f r
  | lp < 255 || (lp .&. (lp + 1)) /= 0 = SnocBuilder lp f r
  | otherwise                          = SnocBuilder lp (f ++ reverse r) []

-- The empty builder

emptySB :: SnocBuilder a
emptySB = SnocBuilder 0 [] []

-- Add an element to the end of a queue.

snocSB :: SnocBuilder a -> a -> SnocBuilder a
snocSB (SnocBuilder lp f r) x = sb (lp + 1) f (x:r)

-- Convert a builder to a list

toListSB :: SnocBuilder a -> [a]
toListSB (SnocBuilder _ f r) = f ++ reverse r
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE CPP, NoImplicitPrelude, MagicHash, BangPatterns #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.List
-- Copyright   :  (c) The University of Glasgow 2001
-- License     :  BSD-style (see the file libraries/base/LICENSE)
--
-- Maintainer  :  libraries@haskell.org
-- Stability   :  stable
-- Portability :  portable
--
-- Operations on lists.
--
-----------------------------------------------------------------------------

module Data.List
   (
   -- * Basic functions

     (++)
   , head
   , last
   , tail
   , init
   , null
   , length

   -- * List transformations
   , map
   , reverse

   , intersperse
   , intercalate
   , transpose

   , subsequences
   , permutations

   -- * Reducing lists (folds)

   , foldl
   , foldl'
   , foldl1
   , foldl1'
   , foldr
   , foldr1

   -- ** Special folds

   , concat
   , concatMap
   , and
   , or
   , any
   , all
   , sum
   , product
   , maximum
   , minimum

   -- * Building lists

   -- ** Scans
   , scanl
   , scanl1
   , scanr
   , scanr1

   -- ** Accumulating maps
   , mapAccumL
   , mapAccumR

   -- ** Infinite lists
   , iterate
   , repeat
   , replicate
   , cycle

   -- ** Unfolding
   , unfoldr

   -- * Sublists

   -- ** Extracting sublists
   , take
   , drop
   , splitAt

   , takeWhile
   , dropWhile
   , dropWhileEnd
   , span
   , break

   , stripPrefix

   , group

   , inits
   , tails

   -- ** Predicates
   , isPrefixOf
   , isSuffixOf
   , isInfixOf

   -- * Searching lists

   -- ** Searching by equality
   , elem
   , notElem
   , lookup

   -- ** Searching with a predicate
   , find
   , filter
   , partition

   -- * Indexing lists
   -- | These functions treat a list @xs@ as a indexed collection,
   -- with indices ranging from 0 to @'length' xs - 1@.

   , (!!)

   , elemIndex
   , elemIndices

   , findIndex
   , findIndices

   -- * Zipping and unzipping lists

   , zip
   , zip3
   , zip4, zip5, zip6, zip7

   , zipWith
   , zipWith3
   , zipWith4, zipWith5, zipWith6, zipWith7

   , unzip
   , unzip3
   , unzip4, unzip5, unzip6, unzip7

   -- * Special lists

   -- ** Functions on strings
   , lines
   , words
   , unlines
   , unwords

   -- ** \"Set\" operations

   , nub

   , delete
   , (\\)

   , union
   , intersect

   -- ** Ordered lists
   , sort
   , insert

   -- * Generalized functions

   -- ** The \"@By@\" operations
   -- | By convention, overloaded functions have a non-overloaded
   -- counterpart whose name is suffixed with \`@By@\'.
   --
   -- It is often convenient to use these functions together with
   -- 'Data.Function.on', for instance @'sortBy' ('compare'
   -- \`on\` 'fst')@.

   -- *** User-supplied equality (replacing an @Eq@ context)
   -- | The predicate is assumed to define an equivalence.
   , nubBy
   , deleteBy
   , deleteFirstsBy
   , unionBy
   , intersectBy
   , groupBy

   -- *** User-supplied comparison (replacing an @Ord@ context)
   -- | The function is assumed to define a total ordering.
   , sortBy
   , insertBy
   , maximumBy
   , minimumBy

   -- ** The \"@generic@\" operations
   -- | The prefix \`@generic@\' indicates an overloaded function that
   -- is a generalized version of a "Prelude" function.

   , genericLength
   , genericTake
   , genericDrop
   , genericSplitAt
   , genericIndex
   , genericReplicate

   ) where

import Data.Maybe
import Data.Bits        ( (.&.) )
import Data.Char        ( isSpace )

import GHC.Num
import GHC.Real
import GHC.List
import GHC.Base

infix 5 \\ -- comment to fool cpp

-- -----------------------------------------------------------------------------
-- List functions

-- | The 'dropWhileEnd' function drops the largest suffix of a list
-- in which the given predicate holds for all elements.  For example:
--
-- > dropWhileEnd isSpace "foo\n" == "foo"
-- > dropWhileEnd isSpace "foo bar" == "foo bar"
-- > dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--
-- /Since: 4.5.0.0/
dropWhileEnd :: (a -> Bool) -> [a] -> [a]
dropWhileEnd p = foldr (\x xs -> if p x && null xs then [] else x : xs) []

-- | The 'stripPrefix' function drops the given prefix from a list.
-- It returns 'Nothing' if the list did not start with the prefix
-- given, or 'Just' the list after the prefix, if it does.
--
-- > stripPrefix "foo" "foobar" == Just "bar"
-- > stripPrefix "foo" "foo" == Just ""
-- > stripPrefix "foo" "barfoo" == Nothing
-- > stripPrefix "foo" "barfoobaz" == Nothing
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
stripPrefix [] ys = Just ys
stripPrefix (x:xs) (y:ys)
 | x == y = stripPrefix xs ys
stripPrefix _ _ = Nothing

-- | The 'elemIndex' function returns the index of the first element
-- in the given list which is equal (by '==') to the query element,
-- or 'Nothing' if there is no such element.
elemIndex       :: Eq a => a -> [a] -> Maybe Int
elemIndex x     = findIndex (x==)

-- | The 'elemIndices' function extends 'elemIndex', by returning the
-- indices of all elements equal to the query element, in ascending order.
elemIndices     :: Eq a => a -> [a] -> [Int]
elemIndices x   = findIndices (x==)

-- | The 'find' function takes a predicate and a list and returns the
-- first element in the list matching the predicate, or 'Nothing' if
-- there is no such element.
find            :: (a -> Bool) -> [a] -> Maybe a
find p          = listToMaybe . filter p

-- | The 'findIndex' function takes a predicate and a list and returns
-- the index of the first element in the list satisfying the predicate,
-- or 'Nothing' if there is no such element.
findIndex       :: (a -> Bool) -> [a] -> Maybe Int
findIndex p     = listToMaybe . findIndices p

-- | The 'findIndices' function extends 'findIndex', by returning the
-- indices of all elements satisfying the predicate, in ascending order.
findIndices      :: (a -> Bool) -> [a] -> [Int]
#ifdef USE_REPORT_PRELUDE
findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
#else
-- Efficient definition
findIndices p ls = loop 0# ls
                 where
                   loop _ [] = []
                   loop n (x:xs) | p x       = I# n : loop (n +# 1#) xs
                                 | otherwise = loop (n +# 1#) xs
#endif  /* USE_REPORT_PRELUDE */

-- | The 'isPrefixOf' function takes two lists and returns 'True'
-- iff the first list is a prefix of the second.
isPrefixOf              :: (Eq a) => [a] -> [a] -> Bool
isPrefixOf [] _         =  True
isPrefixOf _  []        =  False
isPrefixOf (x:xs) (y:ys)=  x == y && isPrefixOf xs ys

-- | The 'isSuffixOf' function takes two lists and returns 'True'
-- iff the first list is a suffix of the second.
-- Both lists must be finite.
isSuffixOf              :: (Eq a) => [a] -> [a] -> Bool
isSuffixOf x y          =  reverse x `isPrefixOf` reverse y

-- | The 'isInfixOf' function takes two lists and returns 'True'
-- iff the first list is contained, wholly and intact,
-- anywhere within the second.
--
-- Example:
--
-- >isInfixOf "Haskell" "I really like Haskell." == True
-- >isInfixOf "Ial" "I really like Haskell." == False
isInfixOf               :: (Eq a) => [a] -> [a] -> Bool
isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)

-- | /O(n^2)/. The 'nub' function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name 'nub' means \`essence\'.)
-- It is a special case of 'nubBy', which allows the programmer to supply
-- their own equality test.
nub                     :: (Eq a) => [a] -> [a]
#ifdef USE_REPORT_PRELUDE
nub                     =  nubBy (==)
#else
-- stolen from HBC
nub l                   = nub' l []             -- '
  where
    nub' [] _           = []                    -- '
    nub' (x:xs) ls                              -- '
        | x `elem` ls   = nub' xs ls            -- '
        | otherwise     = x : nub' xs (x:ls)    -- '
#endif

-- | The 'nubBy' function behaves just like 'nub', except it uses a
-- user-supplied equality predicate instead of the overloaded '=='
-- function.
nubBy                   :: (a -> a -> Bool) -> [a] -> [a]
#ifdef USE_REPORT_PRELUDE
nubBy eq []             =  []
nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
#else
nubBy eq l              = nubBy' l []
  where
    nubBy' [] _         = []
    nubBy' (y:ys) xs
       | elem_by eq y xs = nubBy' ys xs
       | otherwise       = y : nubBy' ys (y:xs)

-- Not exported:
-- Note that we keep the call to `eq` with arguments in the
-- same order as in the reference implementation
-- 'xs' is the list of things we've seen so far,
-- 'y' is the potential new element
elem_by :: (a -> a -> Bool) -> a -> [a] -> Bool
elem_by _  _ []         =  False
elem_by eq y (x:xs)     =  y `eq` x || elem_by eq y xs
#endif


-- | 'delete' @x@ removes the first occurrence of @x@ from its list argument.
-- For example,
--
-- > delete 'a' "banana" == "bnana"
--
-- It is a special case of 'deleteBy', which allows the programmer to
-- supply their own equality test.

delete                  :: (Eq a) => a -> [a] -> [a]
delete                  =  deleteBy (==)

-- | The 'deleteBy' function behaves like 'delete', but takes a
-- user-supplied equality predicate.
deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
deleteBy _  _ []        = []
deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys

-- | The '\\' function is list difference (non-associative).
-- In the result of @xs@ '\\' @ys@, the first occurrence of each element of
-- @ys@ in turn (if any) has been removed from @xs@.  Thus
--
-- > (xs ++ ys) \\ xs == ys.
--
-- It is a special case of 'deleteFirstsBy', which allows the programmer
-- to supply their own equality test.

(\\)                    :: (Eq a) => [a] -> [a] -> [a]
(\\)                    =  foldl (flip delete)

-- | The 'union' function returns the list union of the two lists.
-- For example,
--
-- > "dog" `union` "cow" == "dogcw"
--
-- Duplicates, and elements of the first list, are removed from the
-- the second list, but if the first list contains duplicates, so will
-- the result.
-- It is a special case of 'unionBy', which allows the programmer to supply
-- their own equality test.

union                   :: (Eq a) => [a] -> [a] -> [a]
union                   = unionBy (==)

-- | The 'unionBy' function is the non-overloaded version of 'union'.
unionBy                 :: (a -> a -> Bool) -> [a] -> [a] -> [a]
unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs

-- | The 'intersect' function takes the list intersection of two lists.
-- For example,
--
-- > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
--
-- If the first list contains duplicates, so will the result.
--
-- > [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
--
-- It is a special case of 'intersectBy', which allows the programmer to
-- supply their own equality test. If the element is found in both the first
-- and the second list, the element from the first list will be used.

intersect               :: (Eq a) => [a] -> [a] -> [a]
intersect               =  intersectBy (==)

-- | The 'intersectBy' function is the non-overloaded version of 'intersect'.
intersectBy             :: (a -> a -> Bool) -> [a] -> [a] -> [a]
intersectBy _  [] _     =  []
intersectBy _  _  []    =  []
intersectBy eq xs ys    =  [x | x <- xs, any (eq x) ys]

-- | The 'intersperse' function takes an element and a list and
-- \`intersperses\' that element between the elements of the list.
-- For example,
--
-- > intersperse ',' "abcde" == "a,b,c,d,e"

intersperse             :: a -> [a] -> [a]
intersperse _   []      = []
intersperse sep (x:xs)  = x : prependToAll sep xs


-- Not exported:
-- We want to make every element in the 'intersperse'd list available
-- as soon as possible to avoid space leaks. Experiments suggested that
-- a separate top-level helper is more efficient than a local worker.
prependToAll            :: a -> [a] -> [a]
prependToAll _   []     = []
prependToAll sep (x:xs) = sep : x : prependToAll sep xs

-- | 'intercalate' @xs xss@ is equivalent to @('concat' ('intersperse' xs xss))@.
-- It inserts the list @xs@ in between the lists in @xss@ and concatenates the
-- result.
intercalate :: [a] -> [[a]] -> [a]
intercalate xs xss = concat (intersperse xs xss)

-- | The 'transpose' function transposes the rows and columns of its argument.
-- For example,
--
-- > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]

transpose               :: [[a]] -> [[a]]
transpose []             = []
transpose ([]   : xss)   = transpose xss
transpose ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])


-- | The 'partition' function takes a predicate a list and returns
-- the pair of lists of elements which do and do not satisfy the
-- predicate, respectively; i.e.,
--
-- > partition p xs == (filter p xs, filter (not . p) xs)

partition               :: (a -> Bool) -> [a] -> ([a],[a])
{-# INLINE partition #-}
partition p xs = foldr (select p) ([],[]) xs

select :: (a -> Bool) -> a -> ([a], [a]) -> ([a], [a])
select p x ~(ts,fs) | p x       = (x:ts,fs)
                    | otherwise = (ts, x:fs)

-- | The 'mapAccumL' function behaves like a combination of 'map' and
-- 'foldl'; it applies a function to each element of a list, passing
-- an accumulating parameter from left to right, and returning a final
-- value of this accumulator together with the new list.
mapAccumL :: (acc -> x -> (acc, y)) -- Function of elt of input list
                                    -- and accumulator, returning new
                                    -- accumulator and elt of result list
          -> acc            -- Initial accumulator
          -> [x]            -- Input list
          -> (acc, [y])     -- Final accumulator and result list
mapAccumL _ s []        =  (s, [])
mapAccumL f s (x:xs)    =  (s'',y:ys)
                           where (s', y ) = f s x
                                 (s'',ys) = mapAccumL f s' xs

-- | The 'mapAccumR' function behaves like a combination of 'map' and
-- 'foldr'; it applies a function to each element of a list, passing
-- an accumulating parameter from right to left, and returning a final
-- value of this accumulator together with the new list.
mapAccumR :: (acc -> x -> (acc, y))     -- Function of elt of input list
                                        -- and accumulator, returning new
                                        -- accumulator and elt of result list
            -> acc              -- Initial accumulator
            -> [x]              -- Input list
            -> (acc, [y])               -- Final accumulator and result list
mapAccumR _ s []        =  (s, [])
mapAccumR f s (x:xs)    =  (s'', y:ys)
                           where (s'',y ) = f s' x
                                 (s', ys) = mapAccumR f s xs

-- | The 'insert' function takes an element and a list and inserts the
-- element into the list at the first position where it is less
-- than or equal to the next element.  In particular, if the list
-- is sorted before the call, the result will also be sorted.
-- It is a special case of 'insertBy', which allows the programmer to
-- supply their own comparison function.
insert :: Ord a => a -> [a] -> [a]
insert e ls = insertBy (compare) e ls

-- | The non-overloaded version of 'insert'.
insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
insertBy _   x [] = [x]
insertBy cmp x ys@(y:ys')
 = case cmp x y of
     GT -> y : insertBy cmp x ys'
     _  -> x : ys

-- | 'maximum' returns the maximum value from a list,
-- which must be non-empty, finite, and of an ordered type.
-- It is a special case of 'Data.List.maximumBy', which allows the
-- programmer to supply their own comparison function.
maximum                 :: (Ord a) => [a] -> a
{-# NOINLINE [1] maximum #-}
maximum []              =  errorEmptyList "maximum"
maximum xs              =  foldl1 max xs

{-# RULES
  "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int);
  "maximumInteger" maximum = (strictMaximum :: [Integer] -> Integer)
 #-}

-- We can't make the overloaded version of maximum strict without
-- We can't make the overloaded version of maximum strict without-- changing its semantics (max might not be strict), but we can for
-- the version specialised to 'Int'.-- changing its semantics (max might not be strict), but we can for
strictMaximum-- the version specialised to 'Int'.:: (Ord a) => [a] -> a
strictMaximum []        ::=  (errorEmptyListOrd a) => [a] ->"maximum"
strictMaximum [xs]        =  errorEmptyListfoldl1' max xs "maximum"
strictMaximum xs        =  foldl1' max xs
-- | 'minimum' returns the minimum value from a list,
-- | 'minimum' returns the minimum value from a list,-- which must be non-empty, finite, and of an ordered type.
-- which must be non-empty, finite, and of an ordered type.-- It is a special case of 'Data.List.minimumBy', which allows the
-- programmer to supply their own comparison function.-- It is a special case of 'Data.List.minimumBy', which allows the
minimum-- programmer to supply their own comparison function.:: (Ord a) => [a] -> a
minimum{-# NOINLINE [1] minimum::#-}Ord a) => [a] -> a
{-# NOINLINEminimum []   [1] minimum=#-}errorEmptyList "minimum"
minimum [xs]              =  errorEmptyListfoldl1 min xs  "minimum"
minimum xs              =  foldl1 min xs
{-# RULES
{-# RULES"minimumInt"     minimum = (strictMinimum :: [Int]     -> Int);
  "minimumInt""minimumInteger" minimum = (strictMinimum :: [IntInteger]   ] -> IntInteger);  )
 #-} minimum = (strictMinimum :: [Integer] -> Integer)
 #-}
strictMinimum           :: (Ord a) => [a] -> a
strictMinimum []        =  errorEmptyList "minimum"
strictMinimum xs        ::=  (foldl1'Ord a) =>min[axs] -> a
strictMinimum []        =  errorEmptyList "minimum"
strictMinimum-- | The 'maximumBy' function takes a comparison function and a list        =  foldl1' min xs
-- and returns the greatest element of the list by the comparison function.
-- The list must be finite and non-empty.-- | The 'maximumBy' function takes a comparison function and a list
maximumBy-- and returns the greatest element of the list by the comparison function.:: (a -> a -> Ordering) -> [a] -> a
maximumBy-- The list must be finite and non-empty._ []          =  error "List.maximumBy: empty list"
maximumBy cmp xs        ::=  (foldl1a -> amaxBy-> Orderingxs    ) -> [a] -> a
maximumBy _ []          =where "List.maximumBy: empty list"
maximumBy cmp xs        =  foldl1maxBy xmaxByy = case  cmp x y of
                        where          GT -> x
                           maxBy x y = case_  ->cmpy  x y of
                                       GT -> x
-- | The 'minimumBy' function takes a comparison function and a list  -> y
-- and returns the least element of the list by the comparison function.
-- The list must be finite and non-empty.-- | The 'minimumBy' function takes a comparison function and a list
minimumBy-- and returns the least element of the list by the comparison function.:: (a -> a -> Ordering) -> [a] -> a
minimumBy-- The list must be finite and non-empty._ []          =  error "List.minimumBy: empty list"
minimumBy cmp xs        ::=  (foldl1a -> aminBy-> Orderingxs    ) -> [a] -> a
minimumBy _ []          =where "List.minimumBy: empty list"
minimumBy cmp xs        =  foldl1minBy xminByy = case  cmp x y of
                        where          GT -> y
                           minBy x y = case_  ->cmpx  x y of
                                       GT -> y
-- | The 'genericLength' function is an overloaded version of 'length'.  In  -> x
-- particular, instead of returning an 'Int', it returns any type which is
-- an instance of 'Num'.  It is, however, less efficient than 'length'.-- | The 'genericLength' function is an overloaded version of 'length'.  In
genericLength-- particular, instead of returning an 'Int', it returns any type which is:: (Num i) => [a] -> i
{-# NOINLINE-- an instance of 'Num'.  It is, however, less efficient than 'length'.[1] genericLength #-}
genericLength []        ::=  (Num i) => [a] -> i
{-# NOINLINEgenericLength[1]:genericLengthl)     =  1 + #-}genericLength l
genericLength []        =  0
genericLength{-# RULES     (_:l)     =  1 + genericLength l
  "genericLengthInt"     genericLength = (strictGenericLength :: [a] -> Int);
{-# RULES"genericLengthInteger" genericLength = (strictGenericLength :: [a] -> Integer);
 #-}     genericLength = (strictGenericLength :: [a] -> Int);
  "genericLengthInteger" genericLength = (strictGenericLength :: [a] -> Integer);
strictGenericLength#-}                    :: (Num i) => [b] -> i
strictGenericLength l   =  gl l 0
                        where
strictGenericLength     :: (glNum[]i) => [b]a-> i
strictGenericLength l   =  gl   l_0xs) a = let a' = a + 1 in a' `seq` gl xs a'
                        where
-- | The 'genericTake' function is an overloaded version of 'take', which [] a     = a
-- accepts any 'Integral' value as the number of elements to take. (_:xs) a = let a' = a + 1 in a' `seq` gl xs a'
genericTake             :: (Integral i) => i -> [a] -> [a]
genericTake-- | The 'genericTake' function is an overloaded version of 'take', whichn _ | n <= 0 = []
genericTake-- accepts any 'Integral' value as the number of elements to take._ []        =  []
genericTake n (x:xs)    ::=  (Integral: genericTake) => in->-1)[axs] -> [a]
genericTake n _ | n <= 0 = []
genericTake-- | The 'genericDrop' function is an overloaded version of 'drop', which []        =  []
genericTake-- accepts any 'Integral' value as the number of elements to drop. (x:xs)    =  x : genericTake (n-1) xs
genericDrop             :: (Integral i) => i -> [a] -> [a]
genericDrop-- | The 'genericDrop' function is an overloaded version of 'drop', whichn xs | n <= 0 = xs
genericDrop-- accepts any 'Integral' value as the number of elements to drop._ []        =  []
genericDrop n (_:xs)    ::=  (genericDropIntegral i)(=>n-1i -> [a] -> [a]
genericDrop n xs | n <= 0 = xs
genericDrop _ []        =  []
genericDrop-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', which (_:xs)    =  genericDrop (n-1) xs
-- accepts any 'Integral' value as the position at which to split.
genericSplitAt          :: (Integral i) => i -> [a] -> ([a], [a])
genericSplitAt-- | The 'genericSplitAt' function is an overloaded version of 'splitAt', whichn xs | n <= 0 =  ([],xs)
genericSplitAt-- accepts any 'Integral' value as the position at which to split._ []     =  ([],[])
genericSplitAt n (x:xs) ::=  (Integralx:xs',xs'') =>where -> [a] -> ([a], [a])
genericSplitAt(xs',xs'') n xsgenericSplitAt n <= 0 =  ([],xs) )xs
genericSplitAt _ []     =  ([],[])
genericSplitAt-- | The 'genericIndex' function is an overloaded version of '!!', which (x:xs) =  (x:xs',xs'') where
-- accepts any 'Integral' value as the index.xs',xs'') = genericSplitAt (n-1) xs
genericIndex :: (Integral i) => [a] -> i -> a
genericIndex-- | The 'genericIndex' function is an overloaded version of '!!', which(x:_)  0 = x
genericIndex-- accepts any 'Integral' value as the index.(_:xs) n
genericIndex| n > 0     ::= genericIndexIntegral i)xs=>([a])-> i -> a
genericIndex| otherwise (x:error_)  0"List.genericIndex: negative argument."= x
genericIndex (_:xs) n = error "List.genericIndex: index too large."
 | n > 0     = genericIndex xs (n-1)
-- | The 'genericReplicate' function is an overloaded version of 'replicate', otherwise = error "List.genericIndex: negative argument."
genericIndex-- which accepts any 'Integral' value as the number of repetitions to make. _      = error "List.genericIndex: index too large."
genericReplicate        :: (Integral i) => i -> a -> [a]
genericReplicate-- | The 'genericReplicate' function is an overloaded version of 'replicate',n x    =  genericTake n (repeat x)
-- which accepts any 'Integral' value as the number of repetitions to make.
genericReplicate-- | The 'zip4' function takes four lists and returns a list of:: (Integral i) => i -> a -> [a]
genericReplicate-- quadruples, analogous to 'zip'. x    =  genericTake n (repeat x)
zip4                    :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
zip4-- | The 'zip4' function takes four lists and returns a list of=  zipWith4 (,,,)
-- quadruples, analogous to 'zip'.
zip4-- | The 'zip5' function takes five lists and returns a list of:: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
zip4-- five-tuples, analogous to 'zip'.=  zipWith4 (,,,)
zip5                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
zip5-- | The 'zip5' function takes five lists and returns a list of=  zipWith5 (,,,,)
-- five-tuples, analogous to 'zip'.
zip5-- | The 'zip6' function takes six lists and returns a list of six-tuples,:: [a] -> [b] -> [c] -> [d] -> [e] -> [(a,b,c,d,e)]
zip5-- analogous to 'zip'.  =  zipWith5 (,,,,)
zip6                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
-- | The 'zip6' function takes six lists and returns a list of six-tuples,[(a,b,c,d,e,f)]
zip6-- analogous to 'zip'.  =  zipWith6 (,,,,,)
zip6                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
-- | The 'zip7' function takes seven lists and returns a list of(a,b,c,d,e,f)]
zip6-- seven-tuples, analogous to 'zip'.=  zipWith6 (,,,,,)
zip7                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
-- | The 'zip7' function takes seven lists and returns a list of[g] -> [(a,b,c,d,e,f,g)]
zip7-- seven-tuples, analogous to 'zip'.=  zipWith7 (,,,,,,)
zip7                    :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] ->
-- | The 'zipWith4' function takes a function which combines fourg] -> [(a,b,c,d,e,f,g)]
zip7-- elements, as well as four lists and returns a list of their point-wise=  zipWith7 (,,,,,,)
-- combination, analogous to 'zipWith'.
zipWith4-- | The 'zipWith4' function takes a function which combines four:: (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
zipWith4-- elements, as well as four lists and returns a list of their point-wisez (a:as) (b:bs) (c:cs) (d:ds)
-- combination, analogous to 'zipWith'.=  z a b c d : zipWith4 z as bs cs ds
zipWith4 _ _ _ _ _      ::=  (a->b->c->d->e) -> [a]->[b]->[c]->[d]->[e]
zipWith4 z (a:as) (b:bs) (c:cs) (d:ds)
-- | The 'zipWith5' function takes a function which combines five=  z a b c d : zipWith4 z as bs cs ds
zipWith4-- elements, as well as five lists and returns a list of their point-wise _ _ _ _      =  []
-- combination, analogous to 'zipWith'.
zipWith5-- | The 'zipWith5' function takes a function which combines five:: (a->b->c->d->e->f) ->
-- elements, as well as five lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]
zipWith5-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
zipWith5                ::=  (a->a b->cc->d d->:e->zipWith5f) ->  z as bs cs ds es
zipWith5 _ _ _ _ _ _    = [[a]->[b]->[c]->[d]->[e]->[f]
zipWith5 z (a:as) (b:bs) (c:cs) (d:ds) (e:es)
-- | The 'zipWith6' function takes a function which combines six=  z a b c d e : zipWith5 z as bs cs ds es
zipWith5-- elements, as well as six lists and returns a list of their point-wise _ _ _ _ _    = []
-- combination, analogous to 'zipWith'.
zipWith6-- | The 'zipWith6' function takes a function which combines six:: (a->b->c->d->e->f->g) ->
-- elements, as well as six lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]->[g]
zipWith6-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
zipWith6                ::=  (a->a b->cc->d d->fe->: fzipWith6->g) -> z as bs cs ds es fs
zipWith6 _ _ _ _ _ _ _  = [[a]->[b]->[c]->[d]->[e]->[f]->[g]
zipWith6 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs)
-- | The 'zipWith7' function takes a function which combines seven=  z a b c d e f : zipWith6 z as bs cs ds es fs
zipWith6-- elements, as well as seven lists and returns a list of their point-wise _ _ _ _ _ _  = []
-- combination, analogous to 'zipWith'.
zipWith7-- | The 'zipWith7' function takes a function which combines seven:: (a->b->c->d->e->f->g->h) ->
-- elements, as well as seven lists and returns a list of their point-wise[a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
zipWith7-- combination, analogous to 'zipWith'.z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
zipWith7           =  z ::a b(a->db->e c->gd->: ezipWith7->f->g->h)as->bs cs ds es fs gs
zipWith7 _ _ _ _ _ _ _ _ = [a]->[b]->[c]->[d]->[e]->[f]->[g]->[h]
zipWith7 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs)
-- | The 'unzip4' function takes a list of quadruples and returns four=  z a b c d e f g : zipWith7 z as bs cs ds es fs gs
zipWith7-- lists, analogous to 'unzip'. _ _ _ _ _ _ _ = []
unzip4                  :: [(a,b,c,d)] -> ([a],[b],[c],[d])
unzip4-- | The 'unzip4' function takes a list of quadruples and returns four=  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
-- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds))
unzip4                  :: [(a,b,c,d)]]->,[]([a],[b],[c],[d])
unzip4                  =  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
-- | The 'unzip5' function takes a list of five-tuples and returns fivea:as,b:bs,c:cs,d:ds))
-- lists, analogous to 'unzip'.  ([],[],[],[])
unzip5                  :: [(a,b,c,d,e)] -> ([a],[b],[c],[d],[e])
unzip5-- | The 'unzip5' function takes a list of five-tuples and returns five=  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
-- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds,e:es))
unzip5                  :: [(a,b,c,d,e)][->],[([a],[b],[c],[d],[e])
unzip5                  =  foldr (\(a,b,c,d,e) ~(as,bs,cs,ds,es) ->
-- | The 'unzip6' function takes a list of six-tuples and returns sixa:as,b:bs,c:cs,d:ds,e:es))
-- lists, analogous to 'unzip'.  ([],[],[],[],[])
unzip6                  :: [(a,b,c,d,e,f)] -> ([a],[b],[c],[d],[e],[f])
unzip6-- | The 'unzip6' function takes a list of six-tuples and returns six=  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
-- lists, analogous to 'unzip'.         (a:as,b:bs,c:cs,d:ds,e:es,f:fs))
unzip6                  :: [(a,b,c,d,e,f)],->[],([a],[b],[c],[d],[e],[f])
unzip6                  =  foldr (\(a,b,c,d,e,f) ~(as,bs,cs,ds,es,fs) ->
-- | The 'unzip7' function takes a list of seven-tuples and returnsa:as,b:bs,c:cs,d:ds,e:es,f:fs))
-- seven lists, analogous to 'unzip'.[],[],[],[],[],[])
unzip7          :: [(a,b,c,d,e,f,g)] -> ([a],[b],[c],[d],[e],[f],[g])
unzip7-- | The 'unzip7' function takes a list of seven-tuples and returns=  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
-- seven lists, analogous to 'unzip'.(a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
unzip7          :: [(a,b,c,d,e,f,g)]]->,[]([a],[b],[c],[d],[e],[f],[g])
unzip7          =  foldr (\(a,b,c,d,e,f,g) ~(as,bs,cs,ds,es,fs,gs) ->
                                (a:as,b:bs,c:cs,d:ds,e:es,f:fs,g:gs))
-- | The 'deleteFirstsBy' function takes a predicate and two lists and[],[],[],[],[],[],[])
-- returns the first list with the first occurrence of each element of
-- the second list removed.
deleteFirstsBy-- | The 'deleteFirstsBy' function takes a predicate and two lists and:: (a -> a -> Bool) -> [a] -> [a] -> [a]
deleteFirstsBy-- returns the first list with the first occurrence of each element ofeq       =  foldl (flip (deleteBy eq))
-- the second list removed.
deleteFirstsBy-- | The 'group' function takes a list and returns a list of lists such:: (a -> a -> Bool) -> [a] -> [a] -> [a]
deleteFirstsBy-- that the concatenation of the result is equal to the argument.  Moreover,       =  foldl (flip (deleteBy eq))
-- each sublist in the result contains only equal elements.  For example,
---- | The 'group' function takes a list and returns a list of lists such
-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]-- that the concatenation of the result is equal to the argument.  Moreover,
---- each sublist in the result contains only equal elements.  For example,
---- It is a special case of 'groupBy', which allows the programmer to supply
-- their own equality test.-- > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--group                   :: Eq a => [a] -> [[a]]
group-- It is a special case of 'groupBy', which allows the programmer to supply=  groupBy (==)
-- their own equality test.
group-- | The 'groupBy' function is the non-overloaded version of 'group'.:: Eq a => [a] -> [[a]]
groupgroupBy                 =:: groupBy(a -> a (->==)Bool) -> [a] -> [[a]]
groupBy _  []           =  []
groupBy-- | The 'groupBy' function is the non-overloaded version of 'group'.eq (x:xs)       =  (x:ys) : groupBy eq zs
groupBy                 :: (wherea -> a ys->,zs) =)span-> [a]eq->x)[[xsa]]
groupBy _  []           =  []
groupBy-- | The 'inits' function returns all initial segments of the argument, (x:xs)       =  (x:ys) : groupBy eq zs
-- shortest first.  For example,where (ys,zs) = span (eq x) xs
--
-- > inits "abc" == ["","a","ab","abc"]-- | The 'inits' function returns all initial segments of the argument,
---- shortest first.  For example,
---- Note that 'inits' has the following strictness property:
-- > inits "abc" == ["","a","ab","abc"]-- @inits (xs ++ _|_) = inits xs ++ _|_@
--
-- In particular,-- Note that 'inits' has the following strictness property:
-- @inits _|_ = [] : _|_@-- @inits (xs ++ _|_) = inits xs ++ _|_@
--inits                   :: [a] -> [[a]]
inits-- In particular,       = map toListSB . scanl' snocSB emptySB
{-# NOINLINE-- @inits _|_ = [] : _|_@inits #-}
inits                   :: [a] -> [[a]]
inits-- We do not allow inits to inline, because it plays havoc with Call Arity= map toListSB . scanl' snocSB emptySB
{-# NOINLINE-- if it fuses with a consumer, and it would generally lead to serious #-}
-- loss of sharing if allowed to fuse with a producer.
-- We do not allow inits to inline, because it plays havoc with Call Arity
-- | A strictly accumulating version of 'scanl'-- if it fuses with a consumer, and it would generally lead to serious
{-# NOINLINE-- loss of sharing if allowed to fuse with a producer.[1] scanl' #-}
scanl'           :: (b -> a -> b) -> b -> [a] -> [b]
-- | A strictly accumulating version of 'scanl'-- This peculiar form is needed to prevent scanl' from being rewritten
{-# NOINLINE-- in its own right hand side.[1] scanl' #-}
scanl' = scanlGo':: (b -> a -> b) -> b -> [a] -> [b]
-- This peculiar form is needed to prevent scanl' from being rewrittenwhere
-- in its own right hand side.scanlGo' :: (b -> a -> b) -> b -> [a] -> [b]
scanl'scanlGo'= scanlGo'f !q ls    = q : (case ls of
  where                     []   -> []
    scanlGo' :: (b -> a -> b) :-> b->->scanlGo'a] -> [b]f q x) xs)
    scanlGo' f !q ls    = q : (case ls of
-- | The 'tails' function returns all final segments of the argument,]   -> []
-- longest first.  For example,:xs -> scanlGo' f (f q x) xs)
--
-- > tails "abc" == ["abc", "bc", "c",""]-- | The 'tails' function returns all final segments of the argument,
---- longest first.  For example,
---- Note that 'tails' has the following strictness property:
-- @tails _|_ = _|_ : _|_@-- > tails "abc" == ["abc", "bc", "c",""]
--tails                   :: [a] -> [[a]]
tails-- Note that 'tails' has the following strictness property:xs                =  xs : case xs of
-- @tails _|_ = _|_ : _|_@        []      -> []
tails                   :: [a] -> [ [a]]xs' -> tails xs'
tails xs                =  xs : case xs of
-- | The 'subsequences' function returns the list of all subsequences of the argument.]      -> []
--                                _ : xs' -> tails xs'
-- > subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
subsequences-- | The 'subsequences' function returns the list of all subsequences of the argument.:: [a] -> [[a]]
--subsequences xs         =  [] : nonEmptySubsequences xs
-- > subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
subsequences-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,:: [a] -> [[a]]
subsequences--   except for the empty list.         =  [] : nonEmptySubsequences xs
--
-- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"]-- | The 'nonEmptySubsequences' function returns the list of all subsequences of the argument,
nonEmptySubsequences--   except for the empty list.:: [a] -> [[a]]
--nonEmptySubsequences []      =  []
nonEmptySubsequences-- > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"](x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
nonEmptySubsequenceswhere f ys r = ys : (x : ys::) :[a] -> [[a]]
nonEmptySubsequences []      =  []
nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
-- | The 'permutations' function returns the list of all permutations of the argument.where f ys r = ys : (x : ys) : r
--
-- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
permutations-- | The 'permutations' function returns the list of all permutations of the argument.:: [a] -> [[a]]
--permutations xs0        =  xs0 : perms xs0 []
-- > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]where
permutationsperms []     _  = []:: [a] -> [[a]]
permutationsperms (t:xs0ts) is = foldr=  xs0interleave perms xs0(perms] ts (t:is)) (permutations is)
  wherewhere interleave    xs     r = let (_,zs) = interleave' id xs r in zs
    perms []interleave'  = []_ []     r = (ts, r)
    perms (t:interleave'ts) is = foldrf (yinterleave:ys) r = letperms(us,zs) (t:interleave'is)) (permutations(f . (y:is)))ys r
      where interleave    xs     r = letin  (_,zs) = interleave'(t:y:us) : zs) xs r in zs
            interleave' _ []     r = (ts, r)
            interleave' f (y:ys) r = let (us,zs) = interleave' (f . (y:)) ys r
------------------------------------------------------------------------------in  (y:us, f (t:y:us) : zs)
-- Quick Sort algorithm taken from HBC's QSort library.

-- | The 'sort' function implements a stable sorting algorithm.------------------------------------------------------------------------------
-- Quick Sort algorithm taken from HBC's QSort library.-- It is a special case of 'sortBy', which allows the programmer to supply
-- their own comparison function.
sort-- | The 'sort' function implements a stable sorting algorithm.:: (Ord a) => [a] -> [a]
-- It is a special case of 'sortBy', which allows the programmer to supply
-- their own comparison function.-- | The 'sortBy' function is the non-overloaded version of 'sort'.
sortsortBy::::Ord(a a->) =>a ->a]Ordering-> [a]) -> [a] -> [a]

#ifdef USE_REPORT_PRELUDE-- | The 'sortBy' function is the non-overloaded version of 'sort'.
sortBysort = ::sortBya ->compare -> Ordering) -> [a] -> [a]
sortBy cmp = foldr (insertBy cmp) []
#else

{-
GHC's mergesort replaced by a better implementation, 24/12/2009.
This code originally contributed to the nhc12 compiler by Thomas Nordin
in 2002.  Rumoured to have been based on code by Lennart Augustsson, e.g.
    http://www.mail-archive.com/haskell@haskell.org/msg01822.html
and possibly to bear similarities to a 1982 paper by Richard O'Keefe:
"A smooth applicative merge sort".

Benchmarks show it to be often 2x the speed of the previous implementation.
Fixes ticket http://hackage.haskell.org/trac/ghc/ticket/2143
-}sort = sortBy compare
sortBy cmp = mergeAll . sequences
  where
sortsequences= sortBy compare(a:b:xs)
sortBy|cmpa `=cmp` b == GT sequences= descending b [a]  xs
  where| otherwise       = ascending  b (a:) xs
    sequences (xsa:b:xs[xs)]
      | a `cmp` b == GT = descending b [a]  xs
    descending otherwisea as (b:bs=)ascending  b (a:) xs
    sequences| a `cmpxs` b===xsGT] = descending b (a:as) bs
    descending a as bs  = (a:as): sequences bs
    descending a as (b:bs)
    ascending a `cmp` bas==(bGT:bs= descending b (a:as) bs
    descending| a `cmp`abas/=bsGT = (ascendinga:as): sequencesb (\ys ->as (a:ys)) bs
    ascending a as bs   = as [a]: sequences bs
    ascending a as (b:bs)
    mergeAll a `cmp[`]b=/=x GT = ascending b (\ys -> as (a:ys)) bs
    ascendingmergeAll xs as= bsmergeAll= as([mergePairsa]: sequencesxs) bs

    mergeAllmergePairsx]a=bxxs) = merge a b: mergePairs xs
    mergeAllmergePairsxs= mergeAll= xs(mergePairs xs)

    mergePairsmerge as@(a(aas':b:xsbs)@=bmerge:bs') a b: mergePairs xs
    mergePairs| a `cmp`xsb == GT = xsb:merge as  bs'
      | otherwise       = a:merge as' bs
    merge as[]@(bsa:as') bs@(b:bsbs')
    merge a `ascmp[` b == GT = bas:merge as  bs'
      | otherwise       = a:merge as' bs
{-
sortBy cmp l = mergesort cmp l
sort l = mergesort compare l

Quicksort replaced by mergesort, 14/5/2002.

From: Ian Lynagh <igloo@earth.li>

I am curious as to why the List.sort implementation in GHC is a
quicksort algorithm rather than an algorithm that guarantees n log n
time in the worst case? I have attached a mergesort implementation along
with a few scripts to time it's performance, the results of which are
shown below (* means it didn't finish successfully - in all cases this
was due to a stack overflow).

If I heap profile the random_list case with only 10000 then I see
random_list peaks at using about 2.5M of memory, whereas in the same
program using List.sort it uses only 100k.

Input style     Input length     Sort data     Sort alg    User time
stdin           10000            random_list   sort        2.82
stdin           10000            random_list   mergesort   2.96
stdin           10000            sorted        sort        31.37
stdin           10000            sorted        mergesort   1.90
stdin           10000            revsorted     sort        31.21
stdin           10000            revsorted     mergesort   1.88
stdin           100000           random_list   sort        *
stdin           100000           random_list   mergesort   *
stdin           100000           sorted        sort        *
stdin           100000           sorted        mergesort   *
stdin           100000           revsorted     sort        *
stdin           100000           revsorted     mergesort   *
func            10000            random_list   sort        0.31
func            10000            random_list   mergesort   0.91
func            10000            sorted        sort        19.09
func            10000            sorted        mergesort   0.15
func            10000            revsorted     sort        19.17
func            10000            revsorted     mergesort   0.16
func            100000           random_list   sort        3.85
func            100000           random_list   mergesort   *
func            100000           sorted        sort        5831.47
func            100000           sorted        mergesort   2.23
func            100000           revsorted     sort        5872.34
func            100000           revsorted     mergesort   2.24

mergesort :: (a -> a -> Ordering) -> [a] -> [a]
mergesort cmp = mergesort' cmp . map wrap

mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]
mergesort' _   [] = []
mergesort' _   [xs] = xs
mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)

merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]
merge_pairs _   [] = []
merge_pairs _   [xs] = [xs]
merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss

merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
merge _   [] ys = ys
merge _   xs [] = xs
merge cmp (x:xs) (y:ys)
 = case x `cmp` y of
        GT -> y : merge cmp (x:xs)   ys
        _  -> x : merge cmp    xs (y:ys)

wrap :: a -> [a]
wrap x = [x]



OLDER: qsort version

-- qsort is stable and does not concatenate.
qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
qsort _   []     r = r
qsort _   [x]    r = x:r
qsort cmp (x:xs) r = qpart cmp x xs [] [] r

-- qpart partitions and sorts the sublists
qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
qpart cmp x [] rlt rge r =
    -- rlt and rge are in reverse order and must be sorted with an
    -- anti-stable sorting
    rqsort cmp rlt (x:rqsort cmp rge r)
qpart cmp x (y:ys) rlt rge r =
    case cmp x y of
        GT -> qpart cmp x ys (y:rlt) rge r
        _  -> qpart cmp x ys rlt (y:rge) r

-- rqsort is as qsort but anti-stable, i.e. reverses equal elements
rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
rqsort _   []     r = r
rqsort _   [x]    r = x:r
rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r

rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
rqpart cmp x [] rle rgt r =
    qsort cmp rle (x:qsort cmp rgt r)
rqpart cmp x (y:ys) rle rgt r =
    case cmp y x of
        GT -> rqpart cmp x ys rle (y:rgt) r
        _  -> rqpart cmp x ys (y:rle) rgt r
-}   [] bs         = bs
    merge as []         = as

{-
sortBy cmp l = mergesort cmp l
sort l = mergesort compare l

Quicksort replaced by mergesort, 14/5/2002.

From: Ian Lynagh <igloo@earth.li>

I am curious as to why the List.sort implementation in GHC is a
quicksort algorithm rather than an algorithm that guarantees n log n
time in the worst case? I have attached a mergesort implementation along
with a few scripts to time it's performance, the results of which are
shown below (* means it didn't finish successfully - in all cases this
was due to a stack overflow).

If I heap profile the random_list case with only 10000 then I see
random_list peaks at using about 2.5M of memory, whereas in the same
program using List.sort it uses only 100k.

Input style     Input length     Sort data     Sort alg    User time
stdin           10000            random_list   sort        2.82
stdin           10000            random_list   mergesort   2.96
stdin           10000            sorted        sort        31.37
stdin           10000            sorted        mergesort   1.90
stdin           10000            revsorted     sort        31.21
stdin           10000            revsorted     mergesort   1.88
stdin           100000           random_list   sort        *
stdin           100000           random_list   mergesort   *
stdin           100000           sorted        sort        *
stdin           100000           sorted        mergesort   *
stdin           100000           revsorted     sort        *
stdin           100000           revsorted     mergesort   *
func            10000            random_list   sort        0.31
func            10000            random_list   mergesort   0.91
func            10000            sorted        sort        19.09
func            10000            sorted        mergesort   0.15
func            10000            revsorted     sort        19.17
func            10000            revsorted     mergesort   0.16
func            100000           random_list   sort        3.85
func            100000           random_list   mergesort   *
func            100000           sorted        sort        5831.47
func            100000           sorted        mergesort   2.23
func            100000           revsorted     sort        5872.34
func            100000           revsorted     mergesort   2.24

mergesort :: (a -> a -> Ordering) -> [a] -> [a]
mergesort cmp = mergesort' cmp . map wrap

mergesort' :: (a -> a -> Ordering) -> [[a]] -> [a]
mergesort' _   [] = []
mergesort' _   [xs] = xs
mergesort' cmp xss = mergesort' cmp (merge_pairs cmp xss)

merge_pairs :: (a -> a -> Ordering) -> [[a]] -> [[a]]
merge_pairs _   [] = []
merge_pairs _   [xs] = [xs]
merge_pairs cmp (xs:ys:xss) = merge cmp xs ys : merge_pairs cmp xss

merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
merge _   [] ys = ys
merge _   xs [] = xs
merge cmp (x:xs) (y:ys)
 = case x `cmp` y of
        GT -> y : merge cmp (x:xs)   ys
        _  -> x : merge cmp    xs (y:ys)

wrap :: a -> [a]
wrap x = [x]



OLDER: qsort version

-- qsort is stable and does not concatenate.
qsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
qsort _   []     r = r
qsort _   [x]    r = x:r
qsort cmp (x:xs) r = qpart cmp x xs [] [] r

-- qpart partitions and sorts the sublists
qpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
qpart cmp x [] rlt rge r =
    -- rlt and rge are in reverse order and must be sorted with an
    -- anti-stable sorting
    rqsort cmp rlt (x:rqsort cmp rge r)
qpart cmp x (y:ys) rlt rge r =
    case cmp x y of
        GT -> qpart cmp x ys (y:rlt) rge r
        _  -> qpart cmp x ys rlt (y:rge) r

-- rqsort is as qsort but anti-stable, i.e. reverses equal elements
rqsort :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
rqsort _   []     r = r
rqsort _   [x]    r = x:r
rqsort cmp (x:xs) r = rqpart cmp x xs [] [] r

rqpart :: (a -> a -> Ordering) -> a -> [a] -> [a] -> [a] -> [a] -> [a]
rqpart cmp x [] rle rgt r =
    qsort cmp rle (x:qsort cmp rgt r)
rqpart cmp x (y:ys) rle rgt r =
    case cmp y x of
        GT -> rqpart cmp x ys rle (y:rgt) r
        _  -> rqpart cmp x ys (y:rle) rgt r
-}

-- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'
-- reduces a list to a summary value, 'unfoldr' builds a list from
-- a seed value.  The function takes the element and returns 'Nothing'
-- | The 'unfoldr' function is a \`dual\' to 'foldr': while 'foldr'-- if it is done producing the list or returns 'Just' @(a,b)@, in which
-- reduces a list to a summary value, 'unfoldr' builds a list from-- case, @a@ is a prepended to the list and @b@ is used as the next
-- element in a recursive call.  For example,-- a seed value.  The function takes the element and returns 'Nothing'
---- if it is done producing the list or returns 'Just' @(a,b)@, in which
-- > iterate f == unfoldr (\x -> Just (x, f x))-- case, @a@ is a prepended to the list and @b@ is used as the next
---- element in a recursive call.  For example,
---- In some cases, 'unfoldr' can undo a 'foldr' operation:
---- > iterate f == unfoldr (\x -> Just (x, f x))
---- > unfoldr f' (foldr f z xs) == xs
---- In some cases, 'unfoldr' can undo a 'foldr' operation:
---- if the following holds:
---- > unfoldr f' (foldr f z xs) == xs
---- > f' (f x y) = Just (x,y)
-- > f' z       = Nothing-- if the following holds:
--
-- A simple use of unfoldr:-- > f' (f x y) = Just (x,y)
---- > f' z       = Nothing
---- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
-- A simple use of unfoldr:-- >  [10,9,8,7,6,5,4,3,2,1]
--
unfoldr-- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10:: (b -> Maybe (a, b)) -> b -> [a]
unfoldr-- >  [10,9,8,7,6,5,4,3,2,1]f b  =
--case f b of
unfoldrJust (a,new_b:: (b->->aMaybe: unfoldra, b))new_b-> b -> [a]
unfoldrNothing b  =    -> []
  case f b of
-- ----------------------------------------------------------------------------- (a,new_b) -> a : unfoldr f new_b
   Nothing        -> []
-- | A strict version of 'foldl'.
foldl'-- -----------------------------------------------------------------------------:: (b -> a -> b) -> b -> [a] -> b
foldl' f z0 xs0 = lgo z0 xs0
-- | A strict version of 'foldl'.where lgo z []     = z
foldl'    lgo z (::x:xsb ->= let ->z'b) ->f zbx->in[az'] ->`seq` lgo z' xs
foldl' f z0 xs0 = lgo z0 xs0
-- | 'foldl1' is a variant of 'foldl' that has no starting value argument,where lgo z []     = z
                                                                      -- and thus must be applied to non-empty lists. z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
foldl1                  :: (a -> a -> a) -> [a] -> a
foldl1-- | 'foldl1' is a variant of 'foldl' that has no starting value argument,f (x:xs)         =  foldl f x xs
foldl1-- and thus must be applied to non-empty lists._ []             =  errorEmptyList "foldl1"
foldl1                  :: (a -> a -> a) -> [a] -> a
foldl1-- | A strict version of 'foldl1' (x:xs)         =  foldl f x xs
foldl1foldl1'_ []             =::errorEmptyList(a -> a -> a) "foldl1"-> [a] -> a
foldl1' f (x:xs)         =  foldl' f x xs
foldl1'-- | A strict version of 'foldl1'_ []             =  errorEmptyList "foldl1'"
foldl1'                  :: (a -> a -> a) -> [a] -> a
foldl1'-- ----------------------------------------------------------------------------- (x:xs)         =  foldl' f x xs
foldl1'-- List sum and product []             =  errorEmptyList "foldl1'"

{-# SPECIALISE-- -----------------------------------------------------------------------------sum     :: [Int] -> Int #-}
{-# SPECIALISE-- List sum and productsum     :: [Integer] -> Integer #-}
{-# INLINABLE sum #-}
{-# SPECIALISE sumproduct :: [Int] -> Int #-}
{-# SPECIALISE sumproduct :: [Integer] -> Integer #-}
{-# INLINABLE sumproduct#-} #-}
{-# SPECIALISE-- We make 'sum' and 'product' inlinable so that we get specialisations :: [Int] -> Int #-}
{-# SPECIALISE-- at other types.  See, for example, Trac #7507. :: [Integer] -> Integer #-}
{-# INLINABLE product #-}
-- | The 'sum' function computes the sum of a finite list of numbers.-- We make 'sum' and 'product' inlinable so that we get specialisations
sum-- at other types.  See, for example, Trac #7507.:: (Num a) => [a] -> a
-- | The 'product' function computes the product of a finite list of numbers.
product-- | The 'sum' function computes the sum of a finite list of numbers.:: (Num a) => [a] -> a
sum#ifdef USE_REPORT_PRELUDE:: (Num a) => [a] -> a
sum-- | The 'product' function computes the product of a finite list of numbers.=  foldl (+) 0
product                 ::=  (foldlNum a)*=>) 1[a] -> a
#else
sum     l       = sum' l 0
  where
    sum' []     a = a
sum sum'l(x:xs) = sum'= sum' 0xs (a+x)
productwhere l       = prod l 1
  where []     a = a
    sum' (x:xs) a = sum'a    xs (a+x)
productprodl(x:xs) = prod= prod 1xs (a*x)

</pre>