<a href="Graph.hs1194314738318153057.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Graph.hs13418536351808266298.out.html">next</a></br></br><pre>12d11
<     =  S           {inp ∷ Port}
13d11
<     |  K           {inp ∷ Port}
14d11
<     |  I           {inp ∷ Port}
15d11
<     |  Applicator  {inp, out1, out2 ∷ Port}
16d11
<     |  Duplicator  {inp1, inp2, out ∷ Port}
17d11
<     |  Eraser      {inp ∷ Port}
18d11
<     |  Variable    {inp ∷ Port, name ∷ String}
19c12
<     |  Root        {out ∷ Port}
---
>     =  S           {inp :: Port}
19a13
>     |  K           {inp :: Port}
19a14
>     |  I           {inp :: Port}
19a15
>     |  Applicator  {inp, out1, out2 :: Port}
19a16
>     |  Duplicator  {inp1, inp2, out :: Port}
19a17
>     |  Eraser      {inp :: Port}
19a18
>     |  Variable    {inp :: Port, name :: String}
19a19
>     |  Root        {out :: Port}
25d24
<         S           {inp = i}                        → [i]
26d24
<         K           {inp = i}                        → [i]
27d24
<         I           {inp = i}                        → [i]
28d24
<         Applicator  {inp = i, out1 = o1, out2 = o2}  → [i,o1,o2]
29d24
<         Duplicator  {inp1 = i1, inp2 = i2, out = o}  → [i1,i2,o]
30d24
<         Eraser      {inp = i}                        → [i]
31d24
<         Variable    {inp = i}                        → [i]
32c25
<         Root        {out = o}                        → [o]
---
>         S           {inp = i}                        -> [i]
32a26
>         K           {inp = i}                        -> [i]
32a27
>         I           {inp = i}                        -> [i]
32a28
>         Applicator  {inp = i, out1 = o1, out2 = o2}  -> [i,o1,o2]
32a29
>         Duplicator  {inp1 = i1, inp2 = i2, out = o}  -> [i1,i2,o]
32a30
>         Eraser      {inp = i}                        -> [i]
32a31
>         Variable    {inp = i}                        -> [i]
32a32
>         Root        {out = o}                        -> [o]
34d33
<         S           {} → ski {inp = i}                        where [i]        = ports
35d33
<         K           {} → ski {inp = i}                        where [i]        = ports
36d33
<         I           {} → ski {inp = i}                        where [i]        = ports
37d33
<         Applicator  {} → ski {inp = i, out1 = o1, out2 = o2}  where [i,o1,o2]  = ports
38d33
<         Duplicator  {} → ski {inp1 = i1, inp2 = i2, out = o}  where [i1,i2,o]  = ports
39d33
<         Eraser      {} → ski {inp = i}                        where [i]        = ports
40d33
<         Variable    {} → ski {inp = i}                        where [i]        = ports
41c34
<         Root        {} → ski {out = o}                        where [o]        = ports
---
>         S           {} -> ski {inp = i}                        where [i]        = ports
41a35
>         K           {} -> ski {inp = i}                        where [i]        = ports
41a36
>         I           {} -> ski {inp = i}                        where [i]        = ports
41a37
>         Applicator  {} -> ski {inp = i, out1 = o1, out2 = o2}  where [i,o1,o2]  = ports
41a38
>         Duplicator  {} -> ski {inp1 = i1, inp2 = i2, out = o}  where [i1,i2,o]  = ports
41a39
>         Eraser      {} -> ski {inp = i}                        where [i]        = ports
41a40
>         Variable    {} -> ski {inp = i}                        where [i]        = ports
41a41
>         Root        {} -> ski {out = o}                        where [o]        = ports
44c44
< fromTerm ∷ Term.Expr → Graph SKI
---
> fromTerm :: Term.Expr -> Graph SKI
46c46
<     e ← compile term
---
>     e <- compile term
49c49
< compile ∷ Term.Expr → Rewrite SKI Edge
---
> compile :: Term.Expr -> Rewrite SKI Edge
51d50
<     e ← newEdge
52d50
<     _ ← case term of
53d50
<         Term.A f x → do
54d50
<             ef ← compile f
55c51
<             ex ← compile x
---
>     e <- newEdge
55a52
>     _ <- case term of
55a53
>         Term.A f x -> do
55a54
>             ef <- compile f
55a55
>             ex <- compile x
57d56
<         Term.S → newNode S {inp = e}
58d56
<         Term.K → newNode K {inp = e}
59d56
<         Term.I → newNode I {inp = e}
60c57
<         Term.V v → newNode Variable {inp = e, name = v}
---
>         Term.S -> newNode S {inp = e}
60a58
>         Term.K -> newNode K {inp = e}
60a59
>         Term.I -> newNode I {inp = e}
60a60
>         Term.V v -> newNode Variable {inp = e, name = v}
61a62
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, MultiParamTypeClasses, FlexibleInstances #-}
module Direct.Graph where

import Data.View
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import qualified Common.Term as Term


-- <chunk: node_type>
data SKI
    =  S           {inp ∷ Port}
    |  K           {inp ∷ Port}
    |  I           {inp ∷ Port}
    |  Applicator  {inp, out1, out2 ∷ Port}
    |  Duplicator  {inp1, inp2, out ∷ Port}
    |  Eraser      {inp ∷ Port}
    |  Variable    {inp ∷ Port, name ∷ String}
    |  Root        {out ∷ Port}
-- </chunk: node_type>

-- <chunk: view_ports>
instance View [Port] SKI where
    inspect ski = case ski of
        S           {inp = i}                        → [i]
        K           {inp = i}                        → [i]
        I           {inp = i}                        → [i]
        Applicator  {inp = i, out1 = o1, out2 = o2}  → [i,o1,o2]
        Duplicator  {inp1 = i1, inp2 = i2, out = o}  → [i1,i2,o]
        Eraser      {inp = i}                        → [i]
        Variable    {inp = i}                        → [i]
        Root        {out = o}                        → [o]
    update ports ski = case ski of
        S           {} → ski {inp = i}                        where [i]        = ports
        K           {} → ski {inp = i}                        where [i]        = ports
        I           {} → ski {inp = i}                        where [i]        = ports
        Applicator  {} → ski {inp = i, out1 = o1, out2 = o2}  where [i,o1,o2]  = ports
        Duplicator  {} → ski {inp1 = i1, inp2 = i2, out = o}  where [i1,i2,o]  = ports
        Eraser      {} → ski {inp = i}                        where [i]        = ports
        Variable    {} → ski {inp = i}                        where [i]        = ports
        Root        {} → ski {out = o}                        where [o]        = ports
-- </chunk: view_ports>

fromTerm ∷ Term.Expr → Graph SKI
fromTerm term = flip execGraph emptyGraph $ do
    e ← compile term
    newNode Root {out = e}

compile ∷ Term.Expr → Rewrite SKI Edge
compile term = do
    e ← newEdge
    _ ← case term of
        Term.A f x → do
            ef ← compile f
            ex ← compile x
            newNode Applicator {inp = e, out1 = ef, out2 = ex}
        Term.S → newNode S {inp = e}
        Term.K → newNode K {inp = e}
        Term.I → newNode I {inp = e}
        Term.V v → newNode Variable {inp = e, name = v}
    return e
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, MultiParamTypeClasses, FlexibleInstances #-}
module Direct.Graph where

import Data.View
import GraphRewriting.Graph
import GraphRewriting.Graph.Write
import qualified Common.Term as Term


-- <chunk: node_type>
data SKI
    =  S           {inp :: Port}
    |  K           {inp :: Port}
    |  I           {inp :: Port}
    |  Applicator  {inp, out1, out2 :: Port}
    |  Duplicator  {inp1, inp2, out :: Port}
    |  Eraser      {inp :: Port}
    |  Variable    {inp :: Port, name :: String}
    |  Root        {out :: Port}
-- </chunk: node_type>

-- <chunk: view_ports>
instance View [Port] SKI where
    inspect ski = case ski of
        S           {inp = i}                        -> [i]
        K           {inp = i}                        -> [i]
        I           {inp = i}                        -> [i]
        Applicator  {inp = i, out1 = o1, out2 = o2}  -> [i,o1,o2]
        Duplicator  {inp1 = i1, inp2 = i2, out = o}  -> [i1,i2,o]
        Eraser      {inp = i}                        -> [i]
        Variable    {inp = i}                        -> [i]
        Root        {out = o}                        -> [o]
    update ports ski = case ski of
        S           {} -> ski {inp = i}                        where [i]        = ports
        K           {} -> ski {inp = i}                        where [i]        = ports
        I           {} -> ski {inp = i}                        where [i]        = ports
        Applicator  {} -> ski {inp = i, out1 = o1, out2 = o2}  where [i,o1,o2]  = ports
        Duplicator  {} -> ski {inp1 = i1, inp2 = i2, out = o}  where [i1,i2,o]  = ports
        Eraser      {} -> ski {inp = i}                        where [i]        = ports
        Variable    {} -> ski {inp = i}                        where [i]        = ports
        Root        {} -> ski {out = o}                        where [o]        = ports
-- </chunk: view_ports>

fromTerm :: Term.Expr -> Graph SKI
fromTerm term = flip execGraph emptyGraph $ do
    e <- compile term
    newNode Root {out = e}

compile :: Term.Expr -> Rewrite SKI Edge
compile term = do
    e <- newEdge
    _ <- case term of
        Term.A f x -> do
            ef <- compile f
            ex <- compile x
            newNode Applicator {inp = e, out1 = ef, out2 = ex}
        Term.S -> newNode S {inp = e}
        Term.K -> newNode K {inp = e}
        Term.I -> newNode I {inp = e}
        Term.V v -> newNode Variable {inp = e, name = v}
    return e

</pre>