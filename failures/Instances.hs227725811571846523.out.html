<a href="Instances.hs10351917361702482605.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Instantiate.hs553029607459380633.out.html">next</a></br></br><pre>35c35
<     $expect $ equal
---
>     expect $ equal
42c42
<     $expect $ equal
---
>     expect $ equal
49c49
<     $expect $ equal
---
>     expect $ equal
55c55
<     $expect $ equal
---
>     expect $ equal
61c61
<     $expect $ equal
---
>     expect $ equal
64c64
<     $expect $ equal
---
>     expect $ equal
66a67
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.Instances
    ( test_Instances
    ) where

import           Control.Applicative (pure, (<*>))
import           Data.Functor.Identity (runIdentity)
import           Data.Typeable (typeOf)
import           Test.Chell

import           Data.Enumerator

test_Instances :: Suite
test_Instances = suite "instances"
    [ test_Typeable
    , test_Functor
    , test_Applicative
    ]

test_Typeable :: Suite
test_Typeable = suite "typeable"
    [ test_TypeableStream
    , test_TypeableIteratee
    , test_TypeableStep
    ]

test_TypeableStream :: Suite
test_TypeableStream = assertions "stream" $ do
    let x = undefined :: Stream Char
    $expect $ equal
        "Data.Enumerator.Stream Char"
        (show (typeOf x))

test_TypeableIteratee :: Suite
test_TypeableIteratee = assertions "iteratee" $ do
    let x = undefined :: Iteratee Char Maybe Int
    $expect $ equal
        "Data.Enumerator.Iteratee Char Maybe Int"
        (show (typeOf x))

test_TypeableStep :: Suite
test_TypeableStep = assertions "step" $ do
    let x = undefined :: Step Char Maybe Int
    $expect $ equal
        "Data.Enumerator.Step Char Maybe Int"
        (show (typeOf x))

test_Functor :: Suite
test_Functor = assertions "functor" $ do
    $expect $ equal
        'B'
        (runIdentity (run_ (fmap succ (return 'A'))))

test_Applicative :: Suite
test_Applicative = assertions "applicative" $ do
    $expect $ equal
        'A'
        (runIdentity (run_ (pure 'A')))
    $expect $ equal
        'B'
        (runIdentity (run_ (pure succ <*> pure 'A')))
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.Instances
    ( test_Instances
    ) where

import           Control.Applicative (pure, (<*>))
import           Data.Functor.Identity (runIdentity)
import           Data.Typeable (typeOf)
import           Test.Chell

import           Data.Enumerator

test_Instances :: Suite
test_Instances = suite "instances"
    [ test_Typeable
    , test_Functor
    , test_Applicative
    ]

test_Typeable :: Suite
test_Typeable = suite "typeable"
    [ test_TypeableStream
    , test_TypeableIteratee
    , test_TypeableStep
    ]

test_TypeableStream :: Suite
test_TypeableStream = assertions "stream" $ do
    let x = undefined :: Stream Char
    expect $ equal
        "Data.Enumerator.Stream Char"
        (show (typeOf x))

test_TypeableIteratee :: Suite
test_TypeableIteratee = assertions "iteratee" $ do
    let x = undefined :: Iteratee Char Maybe Int
    expect $ equal
        "Data.Enumerator.Iteratee Char Maybe Int"
        (show (typeOf x))

test_TypeableStep :: Suite
test_TypeableStep = assertions "step" $ do
    let x = undefined :: Step Char Maybe Int
    expect $ equal
        "Data.Enumerator.Step Char Maybe Int"
        (show (typeOf x))

test_Functor :: Suite
test_Functor = assertions "functor" $ do
    expect $ equal
        'B'
        (runIdentity (run_ (fmap succ (return 'A'))))

test_Applicative :: Suite
test_Applicative = assertions "applicative" $ do
    expect $ equal
        'A'
        (runIdentity (run_ (pure 'A')))
    expect $ equal
        'B'
        (runIdentity (run_ (pure succ <*> pure 'A')))

</pre>