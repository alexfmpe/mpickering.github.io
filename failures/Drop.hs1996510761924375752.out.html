<a href="Drop.hs19740445571292006996.out.html">prev</a></br><a href="failures.html">home</a></br><a href="DSL.hs15544269551115266930.out.html">next</a></br></br><pre>22c22
<     $expect $ equal
---
>     expect $ equal
27c27
<     $expect $ equal
---
>     expect $ equal
32c32
<     $expect $ equal
---
>     expect $ equal
40c40
<     $expect $ equal
---
>     expect $ equal
45c45
<     $expect $ equal
---
>     expect $ equal
53c53
<     $expect $ equal
---
>     expect $ equal
60c60
<     $expect $ equal
---
>     expect $ equal
63a64
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.List.Drop
    ( test_Drop
    , test_DropWhile
    , test_Filter
    , test_FilterM
    ) where

import           Test.Chell

import           Data.Enumerator ((=$))
import qualified Data.Enumerator as E
import qualified Data.Enumerator.List as EL

test_Drop :: Suite
test_Drop = assertions "drop" $ do
    $expect $ equal
        ['A', 'B', 'C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.drop 0
            EL.consume)
    $expect $ equal
        ['C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.drop 2
            EL.consume)
    $expect $ equal
        []
        (E.runLists_ [['A']] $ do
            EL.drop 2
            EL.consume)

test_DropWhile :: Suite
test_DropWhile = assertions "dropWhile" $ do
    $expect $ equal
        ['C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.dropWhile (< 'C')
            EL.consume)
    $expect $ equal
        []
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.dropWhile (\_ -> True)
            EL.consume)

test_Filter :: Suite
test_Filter = assertions "filter" $ do
    $expect $ equal
        ['A', 'B', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.filter (/= 'C') =$ EL.consume)

test_FilterM :: Suite
test_FilterM = assertions "filterM" $ do
    $expect $ equal
        ['A', 'B', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.filterM (\x -> return (x /= 'C')) =$ EL.consume)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- Copyright (C) 2010 John Millikin <jmillikin@gmail.com>
--
-- See license.txt for details
module EnumeratorTests.List.Drop
    ( test_Drop
    , test_DropWhile
    , test_Filter
    , test_FilterM
    ) where

import           Test.Chell

import           Data.Enumerator ((=$))
import qualified Data.Enumerator as E
import qualified Data.Enumerator.List as EL

test_Drop :: Suite
test_Drop = assertions "drop" $ do
    expect $ equal
        ['A', 'B', 'C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.drop 0
            EL.consume)
    expect $ equal
        ['C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.drop 2
            EL.consume)
    expect $ equal
        []
        (E.runLists_ [['A']] $ do
            EL.drop 2
            EL.consume)

test_DropWhile :: Suite
test_DropWhile = assertions "dropWhile" $ do
    expect $ equal
        ['C', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.dropWhile (< 'C')
            EL.consume)
    expect $ equal
        []
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.dropWhile (\_ -> True)
            EL.consume)

test_Filter :: Suite
test_Filter = assertions "filter" $ do
    expect $ equal
        ['A', 'B', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.filter (/= 'C') =$ EL.consume)

test_FilterM :: Suite
test_FilterM = assertions "filterM" $ do
    expect $ equal
        ['A', 'B', 'D', 'E']
        (E.runLists_ [['A'], ['B'], ['C'], ['D'], ['E']] $ do
            EL.filterM (\x -> return (x /= 'C')) =$ EL.consume)

</pre>