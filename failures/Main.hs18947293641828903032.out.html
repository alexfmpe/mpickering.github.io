<a href="Main.hs18326198551631437711.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Main.hs1928517639625274502.out.html">next</a></br></br><pre>46c46
< {-# LINE 96 "src/ehc/EHC/Main.chs" #-}
---
> 
46a47
> 
46a48
> 
46a49
> 
46a50
> 
46a51
> 
46a52
> 
46a53
> 
46a54
> 
46a55
> 
46a56
> 
46a57
> 
46a58
> 
46a59
> 
46a60
> 
46a61
> 
46a62
> 
46a63
> 
46a64
> 
46a65
> 
46a66
> 
46a67
> 
46a68
> 
46a69
> 
46a70
> 
46a71
> 
46a72
> 
46a73
> 
46a74
> 
46a75
> 
46a76
> 
46a77
> 
46a78
> 
46a79
> 
46a80
> 
46a81
> 
46a82
> 
46a83
> 
46a84
> 
46a85
> 
46a86
> 
46a87
> 
46a88
> 
46a89
> 
46a90
> 
46a91
> 
46a92
> 
46a93
> 
46a94
> 
46a95
> 
96c145
< {-# LINE 191 "src/ehc/EHC/Main.chs" #-}
---
> 
96a146
> 
96a147
> 
96a148
> 
96a149
> 
96a150
> 
96a151
> 
96a152
> 
96a153
> 
96a154
> 
96a155
> 
96a156
> 
96a157
> 
96a158
> 
96a159
> 
96a160
> 
96a161
> 
96a162
> 
96a163
> 
96a164
> 
96a165
> 
96a166
> 
96a167
> 
96a168
> 
96a169
> 
96a170
> 
96a171
> 
96a172
> 
96a173
> 
96a174
> 
96a175
> 
96a176
> 
96a177
> 
96a178
> 
96a179
> 
96a180
> 
96a181
> 
96a182
> 
96a183
> 
96a184
> 
96a185
> 
96a186
> 
96a187
> 
96a188
> 
96a189
> 
96a190
> 
101c195
< {-# LINE 269 "src/ehc/EHC/Main.chs" #-}
---
> 
101a196
> 
101a197
> 
101a198
> 
101a199
> 
101a200
> 
101a201
> 
101a202
> 
101a203
> 
101a204
> 
101a205
> 
101a206
> 
101a207
> 
101a208
> 
101a209
> 
101a210
> 
101a211
> 
101a212
> 
101a213
> 
101a214
> 
101a215
> 
101a216
> 
101a217
> 
101a218
> 
101a219
> 
101a220
> 
101a221
> 
101a222
> 
101a223
> 
101a224
> 
101a225
> 
101a226
> 
101a227
> 
101a228
> 
101a229
> 
101a230
> 
101a231
> 
101a232
> 
101a233
> 
101a234
> 
101a235
> 
101a236
> 
101a237
> 
101a238
> 
101a239
> 
101a240
> 
101a241
> 
101a242
> 
101a243
> 
101a244
> 
101a245
> 
101a246
> 
101a247
> 
101a248
> 
101a249
> 
101a250
> 
101a251
> 
101a252
> 
101a253
> 
101a254
> 
101a255
> 
101a256
> 
101a257
> 
101a258
> 
101a259
> 
101a260
> 
101a261
> 
101a262
> 
101a263
> 
101a264
> 
101a265
> 
101a266
> 
101a267
> 
101a268
> 
331a499
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.EHC.Main
( mainEHC )
where
import System.Console.GetOpt
import System.IO
import System.Exit
import System.Process
import System.Environment
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.Main.Utils
import qualified Control.Exception as CE
import UHC.Light.Compiler.EHC.Environment
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.InitialSetup
import UHC.Light.Compiler.EHC.CompilePhase.TopLevelPhases
import qualified Debug.Trace
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad.State
import Control.Monad.Error
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize (allOptimizeMp)
import qualified UHC.Light.Compiler.SourceCodeSig as Sig
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.Module.ImportExport (modBuiltin)
import UHC.Light.Compiler.Module.ImportExport
import System.Directory
import UHC.Light.Compiler.Base.PackageDatabase
import UHC.Light.Compiler.Base.Parser2
import qualified UHC.Light.Compiler.ConfigCabal as Cfg (getDataDir)













{-# LINE 96 "src/ehc/EHC/Main.chs" #-}
mainEHC :: EHCOpts -> IO ()
mainEHC opts0
  =  do  {  args      <- getArgs
         ;  progName  <- getProgName
         ;  curDir    <- getCurrentDirectory
         -- a non-empty data dir means we are running as cabal installed exec
         ;  mbDataDir <- Cfg.getDataDir >>= \d -> return $ if null d then Nothing else Just d
         ;  let  opts1          = opts0
                                    { ehcOptEnvironment     = defaultEHCEnvironment
                                    , ehcProgName           = p
                                    , ehcCurDir             = curDir
                                    }
                                where p = mkFPath "uhcl"     -- hardbaked name
                 oo@(o,n,errs)  = ehcCmdLineOptsApply (maybe [] (\d -> [\o -> o {ehcOptCfgInstallRoot = Just d}]) mbDataDir) args opts1
                 opts2          = maybe opts1 id o
         ;  case opts2 of
              o | isNotOk (ehcOptMbTarget       o) -> err $ "non existent target `"        ++ fromNotOk (ehcOptMbTarget       o) ++ "'"
                | isNotOk (ehcOptMbTargetFlavor o) -> err $ "non existent target flavor `" ++ fromNotOk (ehcOptMbTargetFlavor o) ++ "'"
                where err x
                        = do { hPutStrLn stderr ("option error: " ++ x)
                             ; exitFailure
                             }
              _ -> return ()
         ;  userDir <- ehcenvDir (envkey opts2)
         ;  let opts3 = opts2 { ehcOptUserDir = userDir
                              , ehcOptOutputDir =
                                  let outputDir = maybe "." id (ehcOptOutputDir opts2)
                                  in  case ehcOptPkgOpt opts2 of
                                        Just (PkgOption {pkgoptName=s})
                                          -> case parsePkgKey s of
                                               Just k  -> Just $
                                                          outputDir ++ "/" ++
                                                          mkInternalPkgFileBase k (Cfg.installVariant opts2)
                                                                                (ehcOptTarget opts2) (ehcOptTargetFlavor opts2)
                                               _       -> ehcOptOutputDir opts2
                                        _ -> ehcOptOutputDir opts2
                              }
         ;  case ehcOptImmQuit opts3 of
              Just immq     -> let
                                   inputSuffixes = catMaybes [ s | (s,_,vis) <- mkFileSuffMpHs opts3, vis ]
                               in  handleImmQuitOption ehcCmdLineOpts inputSuffixes immq opts3
              _ | null errs ->
                               unless (null n) (doCompileRun n opts3)
                | otherwise -> do { putStr (head errs)
                                  ; exitFailure
                                  }
         }
  where envkey opts = mkEhcenvKey (Cfg.verFull Cfg.version) (fpathToStr $ ehcProgName opts) Cfg.ehcDefaultVariant

{-# LINE 191 "src/ehc/EHC/Main.chs" #-}
defaultEHCEnvironment :: EHCEnvironment
defaultEHCEnvironment
  = EHCEnvironment Cfg.ehcDefaultVariant Cfg.ehcDefaultInplaceInstallDir

{-# LINE 269 "src/ehc/EHC/Main.chs" #-}
doCompilePrepare :: [String] -> EHCOpts -> IO (Maybe (EHCOpts,[FPath],[HsName],EHCompileRun))
doCompilePrepare fnL@(fn:_) opts
  = do { let fpL@(fp:_)             = map (mkTopLevelFPath "hs") fnL
             topModNmL@(topModNm:_) = map (mkHNm . fpathBase) fpL
             -- installVariant         = Cfg.installVariant opts
       -- ; installRoot <- Cfg.installRootM opts
       -- ; userDir <- ehcenvDir (Cfg.verFull Cfg.version)
       -- ; let opts2 = opts -- {ehcOptUserDir = userDir}
       ; pkgDb1 <- pkgDbFromDirs opts
                    ({-
                        [ filePathCoalesceSeparator $ filePathUnPrefix
                          $ Cfg.mkDirbasedInstallPrefix (filelocDir d) Cfg.INST_LIB_PKG "" (show (ehcOptTarget opts)) ""
                        | d <- ehcOptPkgdirLocPath opts
                        ]
                     ++ [ filePathUnPrefix
                          $ Cfg.mkDirbasedTargetVariantPkgPrefix installRoot installVariant (show (ehcOptTarget opts)) ""
                        ]
                     -}
                     {-
                     -}
                        [ filePathUnPrefix d
                        | d <- nub $ ehcOptPkgdirLocPath opts ++ [Cfg.mkInstallPkgdirUser opts, Cfg.mkInstallPkgdirSystem opts]
                        ]
                    )
       ; let (pkgDb2,pkgErrs) = pkgDbSelectBySearchFilter (pkgSearchFilter Just PackageSearchFilter_ExposePkg (map tup123to1 $ pkgExposedPackages pkgDb1)
                                                           ++ sort (ehcOptPackageSearchFilter opts)
                                                          ) pkgDb1
             pkgDb3 = pkgDbFreeze pkgDb2
       -- ; putStrLn $ "db1 " ++ show pkgDb1
       -- ; putStrLn $ "db2 " ++ show pkgDb2
       -- ; putStrLn $ "db3 " ++ show pkgDb3
       -- ; putStrLn (show $ ehcOptPackageSearchFilter opts)
       ; ehcioinfo <- newEHCIOInfo
       ; let searchPath     = [emptyFileLoc]
                              ++ ehcOptImportFileLocPath opts
                              {-
                              ++ [ mkPkgFileLoc (p, Nothing) $ filePathUnPrefix
                                   $ Cfg.mkDirbasedLibVariantTargetPkgPrefix (filelocDir d) "" (show (ehcOptTarget opts)) p
                                 | d <- ehcOptLibFileLocPath opts
                                 , p <- ehcOptLibPackages opts
                                 ]
                              ++ [ mkPkgFileLoc p $ filePathUnPrefix
                                   $ Cfg.mkDirbasedTargetVariantPkgPrefix installRoot installVariant (show (ehcOptTarget opts)) p
                                 | p <- (   ehcOptLibPackages opts
                                         ++ (if ehcOptHideAllPackages opts then [] else Cfg.ehcAssumedPackages)
                                        )
                                 ]
                              -}
                              ++ [fileLocPkgDb]
             opts3          = opts { ehcOptImportFileLocPath = searchPath
                                    , ehcOptPkgDb = pkgDb3
                                    }
{- this does not work in ghc 6.8.2
             crsi           = emptyEHCompileRunStateInfo
                                { crsiOpts       =   opts3
                                , crsiHSInh      =   initialHSSem opts3
                                , crsiEHInh      =   initialEHSem opts3 fp
                                , crsiCoreInh    =   initialCore2GrSem opts3
                                -- , crsiHIInh      =   initialHISem opts3
                                , crsiHSModInh   =   initialHSSemMod opts3
                                }
-}
             crsi           =   (EHCompileRunStateInfo opts3
                                                       uidStart uidStart
                                                       (initialHSSem opts3)
                                                       (initialEHSem opts3 fp)
                                                       (initialCore2GrSem opts3)
                                                       initialCore2CoreRunSem
                                                       Nothing
                                                       -- (initialHISem opts3)
                                                       (initialHSSemMod opts3)
                                                       Map.empty Map.empty defaultOptim
                                                       Map.empty
                                                       ehcioinfo []
                                )
             initialState   = mkEmptyCompileRun topModNm crsi
       ; return $ Just (opts3,fpL,topModNmL,initialState)
       }

doCompileRun :: [String] -> EHCOpts -> IO ()
doCompileRun fnL@(fn:_) opts
  = do { mbPrep <- doCompilePrepare fnL opts
       ; if isJust mbPrep
         then do { let ( opts
                        , fpL@(fp:_)
                        , topModNmL@(topModNm:_)
                        , initialState
                        ) = fromJust mbPrep
                       searchPath = ehcOptImportFileLocPath opts
                       fileSuffMpHs = mkFileSuffMpHs opts
                 ; when (ehcOptVerbosity opts >= VerboseDebug)
                        (putStrLn $ "search path: " ++ show searchPath)
                 ; _ <- if False -- ehcOptPriv opts
                        then run initialState $ compile2 opts fileSuffMpHs searchPath fpL topModNmL
                        else run initialState $ compile  opts fileSuffMpHs searchPath fpL topModNmL
                 ; return ()
                 }
         else exitFailure
       }
  where -- run s c = {- runErrorT $ -} runStateT (runCompilePhaseT c) s
        run s c = runStateT (runCompilePhaseT c) s
        -- compile2 :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhaseT m ()
        compile2 :: EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhase ()
        compile2 opts fileSuffMpHs searchPath fpL topModNmL
          = do {
               -- start with directly importing top modules, providing the filepath directly
                 topModNmL' <- toplayer fpL topModNmL
               ; cpPP "topModNmL'"
               ; oneModNmL <- onelayer
               ; cpPP "oneModNmL"
               ; return ()
               }
          where toplayer fpL topModNmL
                  = zipWithM (\fp topModNm -> imp1 opts fileSuffMpHs searchPath (ECUS_Haskell HSOnlyImports) (Just fp) Nothing topModNm) fpL topModNmL
                onelayer
                  = do { cr <- get
                       ; let modNmS = Map.keysSet $ crCUCache cr
                             ms = Set.unions
                                    [ case cuState e of
                                        -- ECUS_Haskell HIOnlyImports -> ecuTransClosedOrphanModS ecu
                                        _                         -> ecuImpNmS e
                                    | m <- Set.toList modNmS, let e = crCU m cr
                                    ]
                                  `Set.difference` modNmS
                       ; sequence -- or: cpSeq + return ()
                           [ do { i@(m',_) <- imp1 opts fileSuffMpHs searchPath (ECUS_Haskell HSOnlyImports) Nothing Nothing m
                                -- ; cpEhcFullProgModuleDetermineNeedsCompile m'
                                ; return i
                                }
                           | m <- Set.toList ms
                           ]
                       }

                -- dbg
                {-
                showCompileOrder
                  = do { cr <- get
                       ; liftIO $ putStrLn $ "compile order: " ++ show (crCompileOrder cr)
                       }
                -}

        -- compile :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhaseT m ()
        compile :: EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhase ()
        compile opts fileSuffMpHs searchPath fpL topModNmL@(modNm:_)
          = do { cpMsg modNm VerboseDebug $ "doCompileRun.compile topModNmL: " ++ show topModNmL

               -- check module import relationship for builtin module
               ; cpCheckModsModWith (const emptyModMpInfo) [modBuiltin]

               -- start with directly importing top modules, providing the filepath directly
               ; topModNmL' <- zipWithM (\fp topModNm -> imp (ECUS_Haskell HSOnlyImports) (Just fp) Nothing topModNm) fpL topModNmL

               -- follow the import relation to chase modules which have to be analysed
               ; cpImportGatherFromModsWithImp
                   (if ehcOptPriv opts
                    then \ecu -> case ecuState ecu of
                                   -- ECUS_Haskell HIStart -> Set.toList $ ecuTransClosedOrphanModS ecu
                                   ECUS_Haskell HIOnlyImports -> [] -- Set.toList $ ecuTransClosedOrphanModS ecu
                                   _ -> ecuImpNmL ecu
                    else ecuImpNmL
                   )
                   (imp (ECUS_Haskell HSOnlyImports) Nothing) (map fst topModNmL')

               -- import orphans
               ; when (ehcOptPriv opts)
                      (do {
                          -- import orphans
                            importAlso (ECUS_Haskell HSOnlyImports) ecuTransClosedOrphanModS

                          -- import used remaining modules, but just minimally
                          ; importAlso (ECUS_Haskell HMOnlyMinimal) (Set.unions . Map.elems . ecuTransClosedUsedModMp)
                          })

               -- inhibit mutual recursiveness
               ; cpEhcCheckAbsenceOfMutRecModules

               -- and compile it all
               ; cpEhcFullProgCompileAllModules
               -- cleanup
               ; unless (ehcOptKeepIntermediateFiles opts) cpRmFilesToRm
               }
          where -- abbrev for imp1
                imp = imp1 opts fileSuffMpHs searchPath

                -- import others, but then in a (slightly) different way
                -- importAlso :: EHCCompileRunner m => EHCompileUnitState -> (EHCompileUnit -> Set.Set HsName) -> EHCompilePhaseT m ()
                importAlso :: EHCompileUnitState -> (EHCompileUnit -> Set.Set HsName) -> EHCompilePhase ()
                importAlso how getNms
                  = do { cr <- get
                       ; let allAnalysedModS = Map.keysSet $ crCUCache cr
                             allNewS         = Set.unions [ getNms $ crCU m cr | m <- Set.toList allAnalysedModS ] `Set.difference` allAnalysedModS
                       ; cpImportGatherFromModsWithImp
                           (const [])
                           (imp how Nothing) (Set.toList allNewS)
                       }

        -- imp1 :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> EHCompileUnitState -> Maybe FPath -> Maybe (HsName,(FPath,FileLoc)) -> HsName -> EHCompilePhaseT m (HsName,Maybe (HsName,(FPath,FileLoc)))
        imp1 :: EHCOpts -> FileSuffMp -> FileLocPath -> EHCompileUnitState -> Maybe FPath -> Maybe (HsName,(FPath,FileLoc)) -> HsName -> EHCompilePhase (HsName,Maybe (HsName,(FPath,FileLoc)))
        imp1 opts fileSuffMpHs searchPath desiredState mbFp mbPrev nm
          = do { let isTopModule = isJust mbFp
                     fileSuffMpHs' = map tup123to12 $ (if isTopModule then fileSuffMpHsNoSuff else []) ++ fileSuffMpHs
               ; let searchPath' = adaptedSearchPath mbPrev
               ; fpsFound <- cpFindFilesForFPathInLocations (fileLocSearch opts) (\(x,_,_) -> x) False fileSuffMpHs' searchPath' (Just nm) mbFp
               ; when (ehcOptVerbosity opts >= VerboseDebug)
                      (do { liftIO $ putStrLn $ show nm ++ ": " ++ show (fmap fpathToStr mbFp) ++ ": " ++ show (map fpathToStr fpsFound)
                          ; liftIO $ putStrLn $ "searchPath: " ++ show searchPath'
                          })
               ; when isTopModule
                      (cpUpdCU nm (ecuSetIsTopMod True))
               ; cpUpdCU nm (ecuSetTarget (ehcOptTarget opts))
               ; case fpsFound of
                   (fp:_)
                     -> do { nm' <- cpEhcModuleCompile1 (Just desiredState) nm
                           ; cr <- get
                           ; let (ecu,_,_,_) = crBaseInfo nm' cr
                           ; return (nm',Just (nm',(fp, ecuFileLocation ecu)))
                           }
                   _ -> return (nm,Nothing)
               }
          where -- strip tail part corresponding to module name, and use it to search as well
                adaptedSearchPath (Just (prevNm,(prevFp,prevLoc)))
                  = case (fpathMbDir (mkFPath prevNm), fpathMbDir prevFp, prevLoc) of
                      (_, _, p) | filelocIsPkg p
                        -> p : searchPath
                      (Just n, Just p, _)
                        -> mkDirFileLoc (filePathUnPrefix prefix) : searchPath
                        where (prefix,_) = splitAt (length p - length n) p
                      _ -> searchPath
                adaptedSearchPath _ = searchPath

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.EHC.Main
( mainEHC )
where
import System.Console.GetOpt
import System.IO
import System.Exit
import System.Process
import System.Environment
import qualified UHC.Light.Compiler.Config as Cfg
import UHC.Light.Compiler.EHC.Common
import UHC.Light.Compiler.EHC.Main.Utils
import qualified Control.Exception as CE
import UHC.Light.Compiler.EHC.Environment
import UHC.Light.Compiler.EHC.CompileUnit
import UHC.Light.Compiler.EHC.CompileRun
import UHC.Light.Compiler.EHC.InitialSetup
import UHC.Light.Compiler.EHC.CompilePhase.TopLevelPhases
import qualified Debug.Trace
import qualified Data.Map as Map
import qualified Data.Set as Set
import Control.Monad.State
import Control.Monad.Error
import UHC.Light.Compiler.Base.Target
import UHC.Light.Compiler.Base.Optimize (allOptimizeMp)
import qualified UHC.Light.Compiler.SourceCodeSig as Sig
import UHC.Light.Compiler.EHC.CompilePhase.Module
import UHC.Light.Compiler.Module.ImportExport (modBuiltin)
import UHC.Light.Compiler.Module.ImportExport
import System.Directory
import UHC.Light.Compiler.Base.PackageDatabase
import UHC.Light.Compiler.Base.Parser2
import qualified UHC.Light.Compiler.ConfigCabal as Cfg (getDataDir)































































mainEHC :: EHCOpts -> IO ()
mainEHC opts0
  =  do  {  args      <- getArgs
         ;  progName  <- getProgName
         ;  curDir    <- getCurrentDirectory
         -- a non-empty data dir means we are running as cabal installed exec
         ;  mbDataDir <- Cfg.getDataDir >>= \d -> return $ if null d then Nothing else Just d
         ;  let  opts1          = opts0
                                    { ehcOptEnvironment     = defaultEHCEnvironment
                                    , ehcProgName           = p
                                    , ehcCurDir             = curDir
                                    }
                                where p = mkFPath "uhcl"     -- hardbaked name
                 oo@(o,n,errs)  = ehcCmdLineOptsApply (maybe [] (\d -> [\o -> o {ehcOptCfgInstallRoot = Just d}]) mbDataDir) args opts1
                 opts2          = maybe opts1 id o
         ;  case opts2 of
              o | isNotOk (ehcOptMbTarget       o) -> err $ "non existent target `"        ++ fromNotOk (ehcOptMbTarget       o) ++ "'"
                | isNotOk (ehcOptMbTargetFlavor o) -> err $ "non existent target flavor `" ++ fromNotOk (ehcOptMbTargetFlavor o) ++ "'"
                where err x
                        = do { hPutStrLn stderr ("option error: " ++ x)
                             ; exitFailure
                             }
              _ -> return ()
         ;  userDir <- ehcenvDir (envkey opts2)
         ;  let opts3 = opts2 { ehcOptUserDir = userDir
                              , ehcOptOutputDir =
                                  let outputDir = maybe "." id (ehcOptOutputDir opts2)
                                  in  case ehcOptPkgOpt opts2 of
                                        Just (PkgOption {pkgoptName=s})
                                          -> case parsePkgKey s of
                                               Just k  -> Just $
                                                          outputDir ++ "/" ++
                                                          mkInternalPkgFileBase k (Cfg.installVariant opts2)
                                                                                (ehcOptTarget opts2) (ehcOptTargetFlavor opts2)
                                               _       -> ehcOptOutputDir opts2
                                        _ -> ehcOptOutputDir opts2
                              }
         ;  case ehcOptImmQuit opts3 of
              Just immq     -> let
                                   inputSuffixes = catMaybes [ s | (s,_,vis) <- mkFileSuffMpHs opts3, vis ]
                               in  handleImmQuitOption ehcCmdLineOpts inputSuffixes immq opts3
              _ | null errs ->
                               unless (null n) (doCompileRun n opts3)
                | otherwise -> do { putStr (head errs)
                                  ; exitFailure
                                  }
         }
  where envkey opts = mkEhcenvKey (Cfg.verFull Cfg.version) (fpathToStr $ ehcProgName opts) Cfg.ehcDefaultVariant















































defaultEHCEnvironment :: EHCEnvironment
defaultEHCEnvironment
  = EHCEnvironment Cfg.ehcDefaultVariant Cfg.ehcDefaultInplaceInstallDir











































































doCompilePrepare :: [String] -> EHCOpts -> IO (Maybe (EHCOpts,[FPath],[HsName],EHCompileRun))
doCompilePrepare fnL@(fn:_) opts
  = do { let fpL@(fp:_)             = map (mkTopLevelFPath "hs") fnL
             topModNmL@(topModNm:_) = map (mkHNm . fpathBase) fpL
             -- installVariant         = Cfg.installVariant opts
       -- ; installRoot <- Cfg.installRootM opts
       -- ; userDir <- ehcenvDir (Cfg.verFull Cfg.version)
       -- ; let opts2 = opts -- {ehcOptUserDir = userDir}
       ; pkgDb1 <- pkgDbFromDirs opts
                    ({-
                        [ filePathCoalesceSeparator $ filePathUnPrefix
                          $ Cfg.mkDirbasedInstallPrefix (filelocDir d) Cfg.INST_LIB_PKG "" (show (ehcOptTarget opts)) ""
                        | d <- ehcOptPkgdirLocPath opts
                        ]
                     ++ [ filePathUnPrefix
                          $ Cfg.mkDirbasedTargetVariantPkgPrefix installRoot installVariant (show (ehcOptTarget opts)) ""
                        ]
                     -}
                     {-
                     -}
                        [ filePathUnPrefix d
                        | d <- nub $ ehcOptPkgdirLocPath opts ++ [Cfg.mkInstallPkgdirUser opts, Cfg.mkInstallPkgdirSystem opts]
                        ]
                    )
       ; let (pkgDb2,pkgErrs) = pkgDbSelectBySearchFilter (pkgSearchFilter Just PackageSearchFilter_ExposePkg (map tup123to1 $ pkgExposedPackages pkgDb1)
                                                           ++ sort (ehcOptPackageSearchFilter opts)
                                                          ) pkgDb1
             pkgDb3 = pkgDbFreeze pkgDb2
       -- ; putStrLn $ "db1 " ++ show pkgDb1
       -- ; putStrLn $ "db2 " ++ show pkgDb2
       -- ; putStrLn $ "db3 " ++ show pkgDb3
       -- ; putStrLn (show $ ehcOptPackageSearchFilter opts)
       ; ehcioinfo <- newEHCIOInfo
       ; let searchPath     = [emptyFileLoc]
                              ++ ehcOptImportFileLocPath opts
                              {-
                              ++ [ mkPkgFileLoc (p, Nothing) $ filePathUnPrefix
                                   $ Cfg.mkDirbasedLibVariantTargetPkgPrefix (filelocDir d) "" (show (ehcOptTarget opts)) p
                                 | d <- ehcOptLibFileLocPath opts
                                 , p <- ehcOptLibPackages opts
                                 ]
                              ++ [ mkPkgFileLoc p $ filePathUnPrefix
                                   $ Cfg.mkDirbasedTargetVariantPkgPrefix installRoot installVariant (show (ehcOptTarget opts)) p
                                 | p <- (   ehcOptLibPackages opts
                                         ++ (if ehcOptHideAllPackages opts then [] else Cfg.ehcAssumedPackages)
                                        )
                                 ]
                              -}
                              ++ [fileLocPkgDb]
             opts3          = opts { ehcOptImportFileLocPath = searchPath
                                    , ehcOptPkgDb = pkgDb3
                                    }
{- this does not work in ghc 6.8.2
             crsi           = emptyEHCompileRunStateInfo
                                { crsiOpts       =   opts3
                                , crsiHSInh      =   initialHSSem opts3
                                , crsiEHInh      =   initialEHSem opts3 fp
                                , crsiCoreInh    =   initialCore2GrSem opts3
                                -- , crsiHIInh      =   initialHISem opts3
                                , crsiHSModInh   =   initialHSSemMod opts3
                                }
-}
             crsi           =   (EHCompileRunStateInfo opts3
                                                       uidStart uidStart
                                                       (initialHSSem opts3)
                                                       (initialEHSem opts3 fp)
                                                       (initialCore2GrSem opts3)
                                                       initialCore2CoreRunSem
                                                       Nothing
                                                       -- (initialHISem opts3)
                                                       (initialHSSemMod opts3)
                                                       Map.empty Map.empty defaultOptim
                                                       Map.empty
                                                       ehcioinfo []
                                )
             initialState   = mkEmptyCompileRun topModNm crsi
       ; return $ Just (opts3,fpL,topModNmL,initialState)
       }

doCompileRun :: [String] -> EHCOpts -> IO ()
doCompileRun fnL@(fn:_) opts
  = do { mbPrep <- doCompilePrepare fnL opts
       ; if isJust mbPrep
         then do { let ( opts
                        , fpL@(fp:_)
                        , topModNmL@(topModNm:_)
                        , initialState
                        ) = fromJust mbPrep
                       searchPath = ehcOptImportFileLocPath opts
                       fileSuffMpHs = mkFileSuffMpHs opts
                 ; when (ehcOptVerbosity opts >= VerboseDebug)
                        (putStrLn $ "search path: " ++ show searchPath)
                 ; _ <- if False -- ehcOptPriv opts
                        then run initialState $ compile2 opts fileSuffMpHs searchPath fpL topModNmL
                        else run initialState $ compile  opts fileSuffMpHs searchPath fpL topModNmL
                 ; return ()
                 }
         else exitFailure
       }
  where -- run s c = {- runErrorT $ -} runStateT (runCompilePhaseT c) s
        run s c = runStateT (runCompilePhaseT c) s
        -- compile2 :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhaseT m ()
        compile2 :: EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhase ()
        compile2 opts fileSuffMpHs searchPath fpL topModNmL
          = do {
               -- start with directly importing top modules, providing the filepath directly
                 topModNmL' <- toplayer fpL topModNmL
               ; cpPP "topModNmL'"
               ; oneModNmL <- onelayer
               ; cpPP "oneModNmL"
               ; return ()
               }
          where toplayer fpL topModNmL
                  = zipWithM (\fp topModNm -> imp1 opts fileSuffMpHs searchPath (ECUS_Haskell HSOnlyImports) (Just fp) Nothing topModNm) fpL topModNmL
                onelayer
                  = do { cr <- get
                       ; let modNmS = Map.keysSet $ crCUCache cr
                             ms = Set.unions
                                    [ case cuState e of
                                        -- ECUS_Haskell HIOnlyImports -> ecuTransClosedOrphanModS ecu
                                        _                         -> ecuImpNmS e
                                    | m <- Set.toList modNmS, let e = crCU m cr
                                    ]
                                  `Set.difference` modNmS
                       ; sequence -- or: cpSeq + return ()
                           [ do { i@(m',_) <- imp1 opts fileSuffMpHs searchPath (ECUS_Haskell HSOnlyImports) Nothing Nothing m
                                -- ; cpEhcFullProgModuleDetermineNeedsCompile m'
                                ; return i
                                }
                           | m <- Set.toList ms
                           ]
                       }

                -- dbg
                {-
                showCompileOrder
                  = do { cr <- get
                       ; liftIO $ putStrLn $ "compile order: " ++ show (crCompileOrder cr)
                       }
                -}

        -- compile :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhaseT m ()
        compile :: EHCOpts -> FileSuffMp -> FileLocPath -> [FPath] -> [HsName] -> EHCompilePhase ()
        compile opts fileSuffMpHs searchPath fpL topModNmL@(modNm:_)
          = do { cpMsg modNm VerboseDebug $ "doCompileRun.compile topModNmL: " ++ show topModNmL

               -- check module import relationship for builtin module
               ; cpCheckModsModWith (const emptyModMpInfo) [modBuiltin]

               -- start with directly importing top modules, providing the filepath directly
               ; topModNmL' <- zipWithM (\fp topModNm -> imp (ECUS_Haskell HSOnlyImports) (Just fp) Nothing topModNm) fpL topModNmL

               -- follow the import relation to chase modules which have to be analysed
               ; cpImportGatherFromModsWithImp
                   (if ehcOptPriv opts
                    then \ecu -> case ecuState ecu of
                                   -- ECUS_Haskell HIStart -> Set.toList $ ecuTransClosedOrphanModS ecu
                                   ECUS_Haskell HIOnlyImports -> [] -- Set.toList $ ecuTransClosedOrphanModS ecu
                                   _ -> ecuImpNmL ecu
                    else ecuImpNmL
                   )
                   (imp (ECUS_Haskell HSOnlyImports) Nothing) (map fst topModNmL')

               -- import orphans
               ; when (ehcOptPriv opts)
                      (do {
                          -- import orphans
                            importAlso (ECUS_Haskell HSOnlyImports) ecuTransClosedOrphanModS

                          -- import used remaining modules, but just minimally
                          ; importAlso (ECUS_Haskell HMOnlyMinimal) (Set.unions . Map.elems . ecuTransClosedUsedModMp)
                          })

               -- inhibit mutual recursiveness
               ; cpEhcCheckAbsenceOfMutRecModules

               -- and compile it all
               ; cpEhcFullProgCompileAllModules
               -- cleanup
               ; unless (ehcOptKeepIntermediateFiles opts) cpRmFilesToRm
               }
          where -- abbrev for imp1
                imp = imp1 opts fileSuffMpHs searchPath

                -- import others, but then in a (slightly) different way
                -- importAlso :: EHCCompileRunner m => EHCompileUnitState -> (EHCompileUnit -> Set.Set HsName) -> EHCompilePhaseT m ()
                importAlso :: EHCompileUnitState -> (EHCompileUnit -> Set.Set HsName) -> EHCompilePhase ()
                importAlso how getNms
                  = do { cr <- get
                       ; let allAnalysedModS = Map.keysSet $ crCUCache cr
                             allNewS         = Set.unions [ getNms $ crCU m cr | m <- Set.toList allAnalysedModS ] `Set.difference` allAnalysedModS
                       ; cpImportGatherFromModsWithImp
                           (const [])
                           (imp how Nothing) (Set.toList allNewS)
                       }

        -- imp1 :: EHCCompileRunner m => EHCOpts -> FileSuffMp -> FileLocPath -> EHCompileUnitState -> Maybe FPath -> Maybe (HsName,(FPath,FileLoc)) -> HsName -> EHCompilePhaseT m (HsName,Maybe (HsName,(FPath,FileLoc)))
        imp1 :: EHCOpts -> FileSuffMp -> FileLocPath -> EHCompileUnitState -> Maybe FPath -> Maybe (HsName,(FPath,FileLoc)) -> HsName -> EHCompilePhase (HsName,Maybe (HsName,(FPath,FileLoc)))
        imp1 opts fileSuffMpHs searchPath desiredState mbFp mbPrev nm
          = do { let isTopModule = isJust mbFp
                     fileSuffMpHs' = map tup123to12 $ (if isTopModule then fileSuffMpHsNoSuff else []) ++ fileSuffMpHs
               ; let searchPath' = adaptedSearchPath mbPrev
               ; fpsFound <- cpFindFilesForFPathInLocations (fileLocSearch opts) (\(x,_,_) -> x) False fileSuffMpHs' searchPath' (Just nm) mbFp
               ; when (ehcOptVerbosity opts >= VerboseDebug)
                      (do { liftIO $ putStrLn $ show nm ++ ": " ++ show (fmap fpathToStr mbFp) ++ ": " ++ show (map fpathToStr fpsFound)
                          ; liftIO $ putStrLn $ "searchPath: " ++ show searchPath'
                          })
               ; when isTopModule
                      (cpUpdCU nm (ecuSetIsTopMod True))
               ; cpUpdCU nm (ecuSetTarget (ehcOptTarget opts))
               ; case fpsFound of
                   (fp:_)
                     -> do { nm' <- cpEhcModuleCompile1 (Just desiredState) nm
                           ; cr <- get
                           ; let (ecu,_,_,_) = crBaseInfo nm' cr
                           ; return (nm',Just (nm',(fp, ecuFileLocation ecu)))
                           }
                   _ -> return (nm,Nothing)
               }
          where -- strip tail part corresponding to module name, and use it to search as well
                adaptedSearchPath (Just (prevNm,(prevFp,prevLoc)))
                  = case (fpathMbDir (mkFPath prevNm), fpathMbDir prevFp, prevLoc) of
                      (_, _, p) | filelocIsPkg p
                        -> p : searchPath
                      (Just n, Just p, _)
                        -> mkDirFileLoc (filePathUnPrefix prefix) : searchPath
                        where (prefix,_) = splitAt (length p - length n) p
                      _ -> searchPath
                adaptedSearchPath _ = searchPath


</pre>