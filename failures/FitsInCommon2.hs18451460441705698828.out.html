<a href="FitsInCommon.hs1951398138778248382.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Fix.hs10708009801039109000.out.html">next</a></br></br><pre>28c28
< {-# LINE 36 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
28a29
> 
28a30
> 
28a31
> 
28a32
> 
28a33
> 
28a34
> 
28a35
> 
35c42
< {-# LINE 56 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
35a43
> 
35a44
> 
35a45
> 
35a46
> 
35a47
> 
35a48
> 
35a49
> 
35a50
> 
35a51
> 
35a52
> 
35a53
> 
35a54
> 
35a55
> 
53c73
< {-# LINE 77 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
53a74
> 
53a75
> 
53a76
> 
73c96
< {-# LINE 100 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
73a97
> 
73a98
> 
73a99
> 
85c111
< {-# LINE 117 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
85a112
> 
85a113
> 
85a114
> 
85a115
> 
85a116
> 
90c121
< {-# LINE 131 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
90a122
> 
90a123
> 
90a124
> 
90a125
> 
90a126
> 
90a127
> 
90a128
> 
90a129
> 
90a130
> 
99c139
< {-# LINE 145 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
99a140
> 
99a141
> 
99a142
> 
99a143
> 
99a144
> 
106c151
< {-# LINE 159 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
106a152
> 
106a153
> 
106a154
> 
106a155
> 
106a156
> 
106a157
> 
106a158
> 
116c168
< {-# LINE 174 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
116a169
> 
116a170
> 
116a171
> 
116a172
> 
116a173
> 
126c183
< {-# LINE 185 "src/ehc/Ty/FitsInCommon2.chs" #-}
---
> 
126a184
> 
129a188
> 
</pre></br><h2>original</h2></br><pre>module UHC.Light.Compiler.Ty.FitsInCommon2
( module UHC.Light.Compiler.Ty.FIEnv
, ppTyWithFI, ppTyWithFIFO
, FIIn' (..), FIIn
, emptyFI', emptyFI
, fiLookupVar', fiLookupTyVarCyc
, fiLookupReplaceTyCyc
, fiAllowTyVarBind
, fiInitInstRank, fiRankEqInstRank, fiUpdRankByPolarity
, fiPlusVarMp, fiSetVarMp, fiBindTyVar
, TyBetaRedEnv (..), emptyTyBetaRedEnv, emptyTyBetaRedEnv'
, fiBindImplsVar )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Utils1
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty.FIEnv
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Light.Compiler.AbstractCore



{-# LINE 36 "src/ehc/Ty/FitsInCommon2.chs" #-}
ppTyWithFI :: (VarLookupCmb VarMp gm, VarUpdatable Ty gm) => FIIn' gm -> Ty -> PP_Doc
ppTyWithFI fi t =  ppTyS (fiVarMpLoc fi |+> fiVarMp fi) t

ppTyWithFIFO :: (VarLookupCmb VarMp gm, VarUpdatable Ty gm) => FIIn' gm -> FIOut -> Ty -> PP_Doc
ppTyWithFIFO fi fo t    =  ppTyS (foVarMp fo |+> fiVarMp fi) t

{-# LINE 56 "src/ehc/Ty/FitsInCommon2.chs" #-}
data FIIn' globvm
  = FIIn
      { fiFIOpts          ::  !FIOpts               -- options to fitsIn
      , fiUniq            ::  !UID                  -- unique thread
      , fiVarMp           ::  !globvm               -- global (type) var bindings
      , fiVarMpLoc        ::  !VarMp                    -- locally introduced (type) var bindings
      , fiExpLTvS         ::  !(Set.Set TyVarId)        -- lhs ty vars for which expansion (via VarMp) is inhibited (already done once)
      , fiExpRTvS         ::  !(Set.Set TyVarId)        -- and rhs
      , fiRank            ::  !Int                  -- rank
      , fiMbInstRank      ::  !(Maybe Int)          -- rank where possible deep instantation did start
      , fiTrace           ::  [PP_Doc]              -- ???? 20080110, must be strict otherwise ghc 6.8.1 generates crashing program ????
      , fiCoeCtx          ::  CoeCtx                -- the coercion context
      , fiEnv             ::  !FIEnv                -- environment (Gam's,...)
      }

type FIIn = FIIn' VarMp

{-# LINE 77 "src/ehc/Ty/FitsInCommon2.chs" #-}
emptyFI' :: gm -> FIIn' gm
emptyFI' m
  = FIIn
      { fiFIOpts          =   strongFIOpts
      , fiUniq            =   uidStart
      , fiVarMp           =   m
      , fiVarMpLoc        =   emptyVarMp
      , fiExpLTvS         =   Set.empty
      , fiExpRTvS         =   Set.empty
      , fiRank            =   1
      , fiMbInstRank      =   Nothing
      , fiTrace           =   []
      , fiCoeCtx          =   CoeCtx_Allow
      , fiEnv             =   emptyFE
      }

-- emptyFI :: forall gm . FIIn' gm
emptyFI = emptyFI' emptyVarMp

{-# LINE 100 "src/ehc/Ty/FitsInCommon2.chs" #-}
-- lookup a tvar subsequently in 2 VarMps
fiLookupVar' :: (v -> m1 -> Maybe x) -> (v -> m2 -> Maybe x) -> v -> m1 -> m2 -> Maybe x
fiLookupVar' lkup1 lkup2 v m1 m2
  = case lkup1 v m1 of
      Nothing -> lkup2 v m2
      j       -> j

-- lookup a tvar in the VarMps of a FIIn
fiLookupTyVarCyc :: VarLookup gm TyVarId VarMpInfo => FIIn' gm -> TyVarId -> Maybe Ty
fiLookupTyVarCyc  fi v  =  fiLookupVar' varmpTyLookupCyc varmpTyLookupCyc v (fiVarMpLoc fi) (fiVarMp fi)

{-# LINE 117 "src/ehc/Ty/FitsInCommon2.chs" #-}
-- lookup a possible tvar in the VarMps of a FIIn, the result being the replacement if any
fiLookupReplaceTyCyc :: VarLookup gm TyVarId VarMpInfo => FIIn' gm -> Ty -> Ty
fiLookupReplaceTyCyc  fi t  =  maybe t (maybe t id . fiLookupTyVarCyc fi) $ tyMbVar t

{-# LINE 131 "src/ehc/Ty/FitsInCommon2.chs" #-}
data TyBetaRedEnv gm
  = TyBetaRedEnv
      { tbredFI     :: FIIn' gm
      }

emptyTyBetaRedEnv' fe = TyBetaRedEnv ((emptyFI {fiEnv = fe}) :: FIIn)
emptyTyBetaRedEnv = TyBetaRedEnv emptyFI

{-# LINE 145 "src/ehc/Ty/FitsInCommon2.chs" #-}
-- Pre: is a tyvar
fiAllowTyVarBind :: FIIn' gm -> Ty -> Bool
fiAllowTyVarBind fi (Ty_Var v f)   =  f `elem` fioBindCategs (fiFIOpts fi) -- f == TyVarCateg_Plain
                                      && not (v `Set.member` fioDontBind (fiFIOpts fi))
fiAllowTyVarBind fi _              =  False

{-# LINE 159 "src/ehc/Ty/FitsInCommon2.chs" #-}
fiInitInstRank :: FIIn' gm -> FIIn' gm
fiInitInstRank fi = maybe (fi {fiMbInstRank = Just (fiRank fi)}) (const fi) (fiMbInstRank fi)

fiRankEqInstRank :: FIIn' gm -> Bool
fiRankEqInstRank fi = maybe True (== fiRank fi) (fiMbInstRank fi)

fiUpdRankByPolarity :: Polarity -> FIIn' gm -> FIIn' gm
fiUpdRankByPolarity pol fi = if polIsContravariant pol then fi {fiRank = fiRank fi + 1} else fi

{-# LINE 174 "src/ehc/Ty/FitsInCommon2.chs" #-}
fiPlusVarMp :: VarMp -> FIIn' gm -> FIIn' gm
fiPlusVarMp c fi = fi {fiVarMpLoc = c |+> fiVarMpLoc fi}

fiSetVarMp :: VarMp -> FIIn' gm -> FIIn' gm
fiSetVarMp  c fi = fi {fiVarMpLoc = c}

fiBindTyVar :: TyVarId -> Ty -> FIIn' gm -> FIIn' gm
fiBindTyVar v t = fiPlusVarMp (v `varmpTyUnit` t)

{-# LINE 185 "src/ehc/Ty/FitsInCommon2.chs" #-}
fiBindImplsVar :: ImplsVarId -> Impls -> FIIn' gm -> FIIn' gm
fiBindImplsVar v i = fiPlusVarMp (v `varmpImplsUnit` i)

</pre></br><h2>printed</h2></br><pre>module UHC.Light.Compiler.Ty.FitsInCommon2
( module UHC.Light.Compiler.Ty.FIEnv
, ppTyWithFI, ppTyWithFIFO
, FIIn' (..), FIIn
, emptyFI', emptyFI
, fiLookupVar', fiLookupTyVarCyc
, fiLookupReplaceTyCyc
, fiAllowTyVarBind
, fiInitInstRank, fiRankEqInstRank, fiUpdRankByPolarity
, fiPlusVarMp, fiSetVarMp, fiBindTyVar
, TyBetaRedEnv (..), emptyTyBetaRedEnv, emptyTyBetaRedEnv'
, fiBindImplsVar )
where
import UHC.Light.Compiler.Base.Common
import UHC.Light.Compiler.Ty.FitsInCommon
import UHC.Light.Compiler.Ty
import UHC.Light.Compiler.Ty.Utils1
import UHC.Light.Compiler.Substitutable
import UHC.Light.Compiler.Opts
import UHC.Light.Compiler.VarMp
import UHC.Light.Compiler.Ty.FIEnv
import qualified Data.Set as Set
import UHC.Util.Pretty
import UHC.Light.Compiler.AbstractCore











ppTyWithFI :: (VarLookupCmb VarMp gm, VarUpdatable Ty gm) => FIIn' gm -> Ty -> PP_Doc
ppTyWithFI fi t =  ppTyS (fiVarMpLoc fi |+> fiVarMp fi) t

ppTyWithFIFO :: (VarLookupCmb VarMp gm, VarUpdatable Ty gm) => FIIn' gm -> FIOut -> Ty -> PP_Doc
ppTyWithFIFO fi fo t    =  ppTyS (foVarMp fo |+> fiVarMp fi) t















data FIIn' globvm
  = FIIn
      { fiFIOpts          ::  !FIOpts               -- options to fitsIn
      , fiUniq            ::  !UID                  -- unique thread
      , fiVarMp           ::  !globvm               -- global (type) var bindings
      , fiVarMpLoc        ::  !VarMp                    -- locally introduced (type) var bindings
      , fiExpLTvS         ::  !(Set.Set TyVarId)        -- lhs ty vars for which expansion (via VarMp) is inhibited (already done once)
      , fiExpRTvS         ::  !(Set.Set TyVarId)        -- and rhs
      , fiRank            ::  !Int                  -- rank
      , fiMbInstRank      ::  !(Maybe Int)          -- rank where possible deep instantation did start
      , fiTrace           ::  [PP_Doc]              -- ???? 20080110, must be strict otherwise ghc 6.8.1 generates crashing program ????
      , fiCoeCtx          ::  CoeCtx                -- the coercion context
      , fiEnv             ::  !FIEnv                -- environment (Gam's,...)
      }

type FIIn = FIIn' VarMp





emptyFI' :: gm -> FIIn' gm
emptyFI' m
  = FIIn
      { fiFIOpts          =   strongFIOpts
      , fiUniq            =   uidStart
      , fiVarMp           =   m
      , fiVarMpLoc        =   emptyVarMp
      , fiExpLTvS         =   Set.empty
      , fiExpRTvS         =   Set.empty
      , fiRank            =   1
      , fiMbInstRank      =   Nothing
      , fiTrace           =   []
      , fiCoeCtx          =   CoeCtx_Allow
      , fiEnv             =   emptyFE
      }

-- emptyFI :: forall gm . FIIn' gm
emptyFI = emptyFI' emptyVarMp





-- lookup a tvar subsequently in 2 VarMps
fiLookupVar' :: (v -> m1 -> Maybe x) -> (v -> m2 -> Maybe x) -> v -> m1 -> m2 -> Maybe x
fiLookupVar' lkup1 lkup2 v m1 m2
  = case lkup1 v m1 of
      Nothing -> lkup2 v m2
      j       -> j

-- lookup a tvar in the VarMps of a FIIn
fiLookupTyVarCyc :: VarLookup gm TyVarId VarMpInfo => FIIn' gm -> TyVarId -> Maybe Ty
fiLookupTyVarCyc  fi v  =  fiLookupVar' varmpTyLookupCyc varmpTyLookupCyc v (fiVarMpLoc fi) (fiVarMp fi)







-- lookup a possible tvar in the VarMps of a FIIn, the result being the replacement if any
fiLookupReplaceTyCyc :: VarLookup gm TyVarId VarMpInfo => FIIn' gm -> Ty -> Ty
fiLookupReplaceTyCyc  fi t  =  maybe t (maybe t id . fiLookupTyVarCyc fi) $ tyMbVar t











data TyBetaRedEnv gm
  = TyBetaRedEnv
      { tbredFI     :: FIIn' gm
      }

emptyTyBetaRedEnv' fe = TyBetaRedEnv ((emptyFI {fiEnv = fe}) :: FIIn)
emptyTyBetaRedEnv = TyBetaRedEnv emptyFI







-- Pre: is a tyvar
fiAllowTyVarBind :: FIIn' gm -> Ty -> Bool
fiAllowTyVarBind fi (Ty_Var v f)   =  f `elem` fioBindCategs (fiFIOpts fi) -- f == TyVarCateg_Plain
                                      && not (v `Set.member` fioDontBind (fiFIOpts fi))
fiAllowTyVarBind fi _              =  False









fiInitInstRank :: FIIn' gm -> FIIn' gm
fiInitInstRank fi = maybe (fi {fiMbInstRank = Just (fiRank fi)}) (const fi) (fiMbInstRank fi)

fiRankEqInstRank :: FIIn' gm -> Bool
fiRankEqInstRank fi = maybe True (== fiRank fi) (fiMbInstRank fi)

fiUpdRankByPolarity :: Polarity -> FIIn' gm -> FIIn' gm
fiUpdRankByPolarity pol fi = if polIsContravariant pol then fi {fiRank = fiRank fi + 1} else fi







fiPlusVarMp :: VarMp -> FIIn' gm -> FIIn' gm
fiPlusVarMp c fi = fi {fiVarMpLoc = c |+> fiVarMpLoc fi}

fiSetVarMp :: VarMp -> FIIn' gm -> FIIn' gm
fiSetVarMp  c fi = fi {fiVarMpLoc = c}

fiBindTyVar :: TyVarId -> Ty -> FIIn' gm -> FIIn' gm
fiBindTyVar v t = fiPlusVarMp (v `varmpTyUnit` t)



fiBindImplsVar :: ImplsVarId -> Impls -> FIIn' gm -> FIIn' gm
fiBindImplsVar v i = fiPlusVarMp (v `varmpImplsUnit` i)


</pre>