<a href="Blowfish.hs270649095428975319.out.html">prev</a></br><a href="failures.html">home</a></br><a href="BUArr.hs16807282475249.out.html">next</a></br></br><pre>8d7
< -- |
9d7
< -- Module      :  Data.TypeLevel.Bool
10d7
< -- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
11d7
< --               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch
12d7
< --                    and KTH's SAM group
13d7
< -- License     :  BSD-style (see the file LICENSE)
14d7
< --
15d7
< -- Maintainer  :  alfonso.acosta@gmail.com
16d7
< -- Stability   :  experimental (MPTC, non-standarad instances)
17d7
< -- Portability :  non-portable
18d7
< --
19d7
< -- Type-level Booleans.
20d7
< --
21d7
< ----------------------------------------------------------------------------
22d7
< module Data.TypeLevel.Bool (
23d7
<     -- * Type-level boolean values
24d7
<     -- Bool, toBool,
25d7
<     False, false,
26d7
<     True, true,
27d7
<     -- reifyBool,
28c8
<     -- * Type-level boolean operations
---
> -- |-----------------------------------------------------------------------------
28a9
> -- |-- Module      :  Data.TypeLevel.Bool
28a10
> -- Module      :  Data.TypeLevel.Bool-- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
28a11
> --               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch-- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
28a12
> --                    and KTH's SAM group--               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch
28a13
> --                    and KTH's SAM group-- License     :  BSD-style (see the file LICENSE)
28a14
> ---- License     :  BSD-style (see the file LICENSE)
28a15
> ---- Maintainer  :  alfonso.acosta@gmail.com
28a16
> -- Maintainer  :  alfonso.acosta@gmail.com-- Stability   :  experimental (MPTC, non-standarad instances)
28a17
> -- Portability :  non-portable-- Stability   :  experimental (MPTC, non-standarad instances)
28a18
> ---- Portability :  non-portable
28a19
> ---- Type-level Booleans.
28a20
> ---- Type-level Booleans.
28a21
> ------------------------------------------------------------------------------
28a22
> module----------------------------------------------------------------------------Data.TypeLevel.Bool (
28a23
> module-- * Type-level boolean valuesData.TypeLevel.Bool (
28a24
>     -- Bool, toBool,-- * Type-level boolean values
28a25
>     False-- Bool, toBool,, false,
28a26
>     FalseTrue,,true, ,
28a27
>     True-- reifyBool,, true,
28a28
>     -- reifyBool,-- * Type-level boolean operations
28a29
>     Not-- * Type-level boolean operations,
30d30
<     And,
31d30
<     Or
32d30
<     -- Not, not,
33c31
<     -- And, (&&),
---
>     AndOr ,
33a32
>     Or-- Not, not,
33a33
>     -- Not, not,-- And, (&&),
33a34
>     -- Or, (||),-- And, (&&),
35d35
<     -- Xor, xor,
36c36
<     -- Impl, imp,
---
>     -- Xor, xor,-- Impl, imp,
36a37
> ) where-- Impl, imp,
38d38
< 
40c40
< import Prelude hiding (Bool, not, (&&), (||), Eq)
---
> import Data.GenericsPrelude hiding(Typeable(Bool, not) , (&&), (||), Eq)
40a41
> import PreludequalifiedPrelude(Boolas,Pnot, (&&), (||), Eq)
42d42
< 
44d43
< -- Definition of type-level Booleans
46c45
< -- | True type-level value
---
> -- Definition of type-level Booleans
46a46
> -- | True type-level value------------------------------------
46a47
> data-- | True type-level valueTrue deriving Typeable
48d48
< 
49a50
> instanceshow _ =Show"True" where
51d51
< 
53c53
< true :: True
---
> true-- | True value-level reflecting function:: True
53a54
> true ::= undefined
55d55
< 
56a57
> data-- | False type-level valueFalse deriving Typeable
58d58
< 
59a60
> instanceshow _ =Show"False" where
62d62
< 
64c64
< false :: False
---
> false-- | False value-level reflecting function:: False
64a65
> false ::= undefined
66d66
< 
68d67
< type instance And True True   = True
69d67
< type instance And True False  = False
70c68
< type instance And False True  = False
---
> type familyinstanceAndTrueTrue   = True
70a69
> type instance And True TrueFalse  = TrueFalse
70a70
> type instance And TrueFalseFalseTrue  = False
70a71
> type instance And False TrueFalse = False
72d72
< 
74d73
< type instance Or True True   = True
75d73
< type instance Or True False  = True
76c74
< type instance Or False True  = True
---
> type familyinstanceOrTrueTrue   = True
76a75
> type instance Or True TrueFalse  = True
76a76
> type instance Or TrueFalseFalseTrue  = True
76a77
> type instance Or False TrueFalse = TrueFalse
78d78
< 
80c80
< type instance Not True  = False
---
> type familyinstanceNot True  = False
80a81
> type instance Not TrueFalse = FalseTrue
82d82
< 
191a192
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE EmptyDataDecls, MultiParamTypeClasses, FunctionalDependencies,
             Rank2Types, DeriveDataTypeable, FlexibleInstances,
             UndecidableInstances, FlexibleContexts,ScopedTypeVariables,
             TypeFamilies
  #-}
-----------------------------------------------------------------------------
-- |
-- Module      :  Data.TypeLevel.Bool
-- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
--               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch
--                    and KTH's SAM group
-- License     :  BSD-style (see the file LICENSE)
--
-- Maintainer  :  alfonso.acosta@gmail.com
-- Stability   :  experimental (MPTC, non-standarad instances)
-- Portability :  non-portable
--
-- Type-level Booleans.
--
----------------------------------------------------------------------------
module Data.TypeLevel.Bool (
    -- * Type-level boolean values
    -- Bool, toBool,
    False, false,
    True, true,
    -- reifyBool,
    -- * Type-level boolean operations
    Not,
    And,
    Or
    -- Not, not,
    -- And, (&&),
    -- Or, (||),
    -- Xor, xor,
    -- Impl, imp,
) where

import Data.Generics (Typeable)
import Prelude hiding (Bool, not, (&&), (||), Eq)
import qualified Prelude as P

------------------------------------
-- Definition of type-level Booleans
------------------------------------
-- | True type-level value
data True deriving Typeable

instance Show True where
 show _ = "True"

-- | True value-level reflecting function
true :: True
true = undefined

-- | False type-level value
data False deriving Typeable

instance Show False where
 show _ = "False"


-- | False value-level reflecting function
false :: False
false = undefined

type family And b_0 b_1
type instance And True True   = True
type instance And True False  = False
type instance And False True  = False
type instance And False False = False

type family Or b_0 b_1
type instance Or True True   = True
type instance Or True False  = True
type instance Or False True  = True
type instance Or False False = False

type family Not b
type instance Not True  = False
type instance Not False = True

#if 0
type family Id b
type family Const a b
type instance Id a = a
type instance Const b a = b
-- | Booleans, internal version
class BoolI b  where
  toBool :: b -> P.Bool
  type Not  b
  type And  b :: * -> *
  type Or   b :: * -> *
  type Xor  b :: * -> *
  type Impl b :: * -> *
  type BoolEq b :: * -> *

-- To prevent the user from adding new instances to BoolI we do NOT export
-- BoolI itself. Rather, we export the following proxy (Bool).
-- The proxy entails BoolI and so can be used to add BoolI
-- constraints in the signatures. However, all the constraints below
-- are expressed in terms of BoolI rather than the proxy. Thus, even if the
-- user adds new instances to the proxy, it would not matter.
-- Besides, because the following proxy instances are most general,
-- one may not add further instances without the overlapping instances
-- extension.

-- | Type-level Booleans
class BoolI b => Bool b

instance BoolI b => Bool b

instance BoolI True where
 toBool _ = True
 type Not True = False
 type And True = Id
 type Or  True = Const True
 type Xor True = Not
 type Impl True = Id
 type BoolEq True = Id

instance BoolI False where
 toBool _ = False
 type Not False = True
 type And False = Const False
 type Or  False = Id
 type Xor False = Id
 type Impl False = Const True
 type BoolEq False = Not
-- | Reification function. In CPS style (best possible solution)
reifyBool :: P.Bool -> (forall b . Bool b => b -> r) -> r
reifyBool True  f = f true
reifyBool False f = f false

-------------
-- Operations
-------------


-- | value-level reflection function for the 'Not' type-level relation
not :: b1 -> Not b1
not = undefined

-- | 'And' type-level relation. @And b1 b2 b3@ establishes that
--   @b1 && b2 = b3@


-- | value-level reflection function for the 'And' type-level relation
(&&) :: b1 -> b2 -> And b1 b2
(&&) = undefined
infixr 3 &&

-- | Or type-level relation. @Or b1 b2 b3@ establishes that
--   @b1 || b2 = b3@


-- | value-level reflection function for the 'Or' type-level relation
(||) :: b1 -> b2 -> Or b1 b2
(||) = undefined
infixr 2 ||

-- | Exclusive or type-level relation. @Xor b1 b2 b3@ establishes that
--   @xor b1 b2 = b3@

-- | value-level reflection function for the 'Xor' type-level relation
xor :: b1 -> b2 -> Xor b1 b2
xor = undefined


-- | Implication type-level relation. @Imp b1 b2 b3@ establishes that
-- @b1 =>b2 = b3@

-- | value-level reflection function for the Imp type-level relation
imp :: b1 -> b2 -> Impl b1 b2
imp = undefined


-- Although equality can be defined as the composition of Xor and Not
-- we define it specifically

-- | Boolean equality type-level relation

-- FIXME: eq should be named (==) but it clashes with the (==) defined
--        in Data.TypeLevel.Num . The chosen (and ugly) workaround was
--        to rename it to eq.

-- | value-level reflection function for the 'Eq' type-level relation
boolEq :: b1 -> b2 -> BoolEq b1 b2
boolEq = undefined
#endif

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE CPP #-}
{-# LANGUAGE EmptyDataDecls, MultiParamTypeClasses, FunctionalDependencies,
             Rank2Types, DeriveDataTypeable, FlexibleInstances,
             UndecidableInstances, FlexibleContexts,ScopedTypeVariables,
             TypeFamilies
  #-}
-----------------------------------------------------------------------------
-- |-----------------------------------------------------------------------------
-- |-- Module      :  Data.TypeLevel.Bool
-- Module      :  Data.TypeLevel.Bool-- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
--               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch-- Copyright   : (c) 2008 Benedikt Huber (port to Associative types (ghc 6.9+))
--                    and KTH's SAM group--               (c) 2008 Alfonso Acosta, Oleg Kiselyov, Wolfgang Jeltsch
--                    and KTH's SAM group-- License     :  BSD-style (see the file LICENSE)
---- License     :  BSD-style (see the file LICENSE)
---- Maintainer  :  alfonso.acosta@gmail.com
-- Maintainer  :  alfonso.acosta@gmail.com-- Stability   :  experimental (MPTC, non-standarad instances)
-- Portability :  non-portable-- Stability   :  experimental (MPTC, non-standarad instances)
---- Portability :  non-portable
---- Type-level Booleans.
---- Type-level Booleans.
------------------------------------------------------------------------------
module----------------------------------------------------------------------------Data.TypeLevel.Bool (
module-- * Type-level boolean valuesData.TypeLevel.Bool (
    -- Bool, toBool,-- * Type-level boolean values
    False-- Bool, toBool,, false,
    FalseTrue,,true, ,
    True-- reifyBool,, true,
    -- reifyBool,-- * Type-level boolean operations
    Not-- * Type-level boolean operations,
    Not,
    AndOr ,
    Or-- Not, not,
    -- Not, not,-- And, (&&),
    -- Or, (||),-- And, (&&),
    -- Or, (||),
    -- Xor, xor,-- Impl, imp,
) where-- Impl, imp,
) where
import Data.Generics (Typeable)
import Data.GenericsPrelude hiding(Typeable(Bool, not) , (&&), (||), Eq)
import PreludequalifiedPrelude(Boolas,Pnot, (&&), (||), Eq)
import qualified Prelude as P
------------------------------------
------------------------------------
-- Definition of type-level Booleans
-- | True type-level value------------------------------------
data-- | True type-level valueTrue deriving Typeable
data True deriving Typeable
instance Show True where
instanceshow _ =Show"True" where
 show _ = "True"
-- | True value-level reflecting function
true-- | True value-level reflecting function:: True
true ::= undefined
true = undefined
-- | False type-level value
data-- | False type-level valueFalse deriving Typeable
data False deriving Typeable
instance Show False where
instanceshow _ =Show"False" where
 show _ = "False"

-- | False value-level reflecting function
false-- | False value-level reflecting function:: False
false ::= undefined
false = undefined
type family And b_0 b_1
type familyinstanceAndTrueTrue   = True
type instance And True TrueFalse  = TrueFalse
type instance And TrueFalseFalseTrue  = False
type instance And False TrueFalse = False
type instance And False False = False
type family Or b_0 b_1
type familyinstanceOrTrueTrue   = True
type instance Or True TrueFalse  = True
type instance Or TrueFalseFalseTrue  = True
type instance Or False TrueFalse = TrueFalse
type instance Or False False = False
type family Not b
type familyinstanceNot True  = False
type instance Not TrueFalse = FalseTrue
type instance Not False = True
#if 0
type family Id b
type family Const a b
type instance Id a = a
type instance Const b a = b
-- | Booleans, internal version
class BoolI b  where
  toBool :: b -> P.Bool
  type Not  b
  type And  b :: * -> *
  type Or   b :: * -> *
  type Xor  b :: * -> *
  type Impl b :: * -> *
  type BoolEq b :: * -> *

-- To prevent the user from adding new instances to BoolI we do NOT export
-- BoolI itself. Rather, we export the following proxy (Bool).
-- The proxy entails BoolI and so can be used to add BoolI
-- constraints in the signatures. However, all the constraints below
-- are expressed in terms of BoolI rather than the proxy. Thus, even if the
-- user adds new instances to the proxy, it would not matter.
-- Besides, because the following proxy instances are most general,
-- one may not add further instances without the overlapping instances
-- extension.

-- | Type-level Booleans
class BoolI b => Bool b

instance BoolI b => Bool b

instance BoolI True where
 toBool _ = True
 type Not True = False
 type And True = Id
 type Or  True = Const True
 type Xor True = Not
 type Impl True = Id
 type BoolEq True = Id

instance BoolI False where
 toBool _ = False
 type Not False = True
 type And False = Const False
 type Or  False = Id
 type Xor False = Id
 type Impl False = Const True
 type BoolEq False = Not
-- | Reification function. In CPS style (best possible solution)
reifyBool :: P.Bool -> (forall b . Bool b => b -> r) -> r
reifyBool True  f = f true
reifyBool False f = f false

-------------
-- Operations
-------------


-- | value-level reflection function for the 'Not' type-level relation
not :: b1 -> Not b1
not = undefined

-- | 'And' type-level relation. @And b1 b2 b3@ establishes that
--   @b1 && b2 = b3@


-- | value-level reflection function for the 'And' type-level relation
(&&) :: b1 -> b2 -> And b1 b2
(&&) = undefined
infixr 3 &&

-- | Or type-level relation. @Or b1 b2 b3@ establishes that
--   @b1 || b2 = b3@


-- | value-level reflection function for the 'Or' type-level relation
(||) :: b1 -> b2 -> Or b1 b2
(||) = undefined
infixr 2 ||

-- | Exclusive or type-level relation. @Xor b1 b2 b3@ establishes that
--   @xor b1 b2 = b3@

-- | value-level reflection function for the 'Xor' type-level relation
xor :: b1 -> b2 -> Xor b1 b2
xor = undefined


-- | Implication type-level relation. @Imp b1 b2 b3@ establishes that
-- @b1 =>b2 = b3@

-- | value-level reflection function for the Imp type-level relation
imp :: b1 -> b2 -> Impl b1 b2
imp = undefined


-- Although equality can be defined as the composition of Xor and Not
-- we define it specifically

-- | Boolean equality type-level relation

-- FIXME: eq should be named (==) but it clashes with the (==) defined
--        in Data.TypeLevel.Num . The chosen (and ugly) workaround was
--        to rename it to eq.

-- | value-level reflection function for the 'Eq' type-level relation
boolEq :: b1 -> b2 -> BoolEq b1 b2
boolEq = undefined
#endif


</pre>