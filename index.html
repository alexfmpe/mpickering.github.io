<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="./">Home</a> <br>
              <a href="./about.html">About</a> <br>
              <a href="./archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <p> </p>

<li class="post_item">
    <span class="title"> Specifying how a plugin affects recompilation </span>
    <span class="info"> August 10, 2018 </span>
     
        <p>Plugins have existed for a long time in GHC. The first plugins were implemented in <a href="http://blog.omega-prime.co.uk/2008/06/15/compiler-plugins-for-ghc-the-first-week/">2008</a> by Max Bolingbroke. They enabled users to modify the optimisation pipeline. They ran after desugaring and hence were called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#core-plugins-in-more-detail">“core” plugins</a>. Later, Adam Gundry implemented what I shall refer to as <a href="http://adam.gundry.co.uk/pub/typechecker-plugins/">“constraint solver” plugins</a> which allow users to provide custom solver logic to solve additional constraints. Recently, Boldizsár Németh has extended the number of extension points again with a set of plugins which can inspect and modify the syntax AST. Plugins can run after parsing, renaming or type checking and hence are called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">“source” plugins</a>.</p>
<p>The idea behind plugins was great - a user can extend the compiler in their own specific way without having to modify the source tree and rebuild the compiler from scratch. It is far more convenient to write a plugin than to use a custom compiler. However, if a user wants to use a plugin, they will find that every module where the plugin is enabled is always recompiled, even if the source code didn’t change at all. Why is this? Well, a plugin can do anything, it could read the value from a temperature sensor and insert the room temperature into the program. Thus, we would always need to recompile a module if the temperature reading changed as it would affect what our program did.</p>
<p>However, there are also “pure” plugins, whose output is only affected by the program which is passed as in input. For these plugins, if the source code doesn’t change then we don’t need to do any recompilation.</p>
<p>This post is about a new metadata field which I added to the <code>Plugin</code> data type which specifies how a plugin should affect recompilation. This feature will be present in GHC 8.6.</p>

        <a href="./posts/2018-08-10-plugins-recompilation.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Reimplementing graphmod as a source plugin: graphmod-plugin </span>
    <span class="info"> August  9, 2018 </span>
     
        <p>You may have heard about <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">source plugins</a> by now. They allow you to modify and inspect the compiler’s intermediate representation. This is useful for extending GHC and performing static analysis of Haskell programs.</p>
<p>In order to test them out, I reimplemented the <a href="https://github.com/yav/graphmod"><code>graphmod</code></a> tool as a source plugin. <code>graphmod</code> generates a graph of the module structure of your package. Reimplementing it as a source plugin makes the implementation more robust. I implemented it as as a type checker plugin which runs after type checking has finished. The result: <a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a></p>
<figure>
<img src="https://raw.githubusercontent.com/yav/graphmod/master/screenshots/aeson1.dot.png" alt="An example of the structure of the aeson package" /><figcaption>An example of the structure of the <code>aeson</code> package</figcaption>
</figure>

        <a href="./posts/2018-08-09-source-plugin-graphmod.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Nix scaffolding for running Haskell plugins </span>
    <span class="info"> June 24, 2018 </span>
     
        <p>I’ve been all about writing <a href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html">source plugins</a> recently but have been dissatisfied with how rough it is to use them practically. In particular, I am writing plugins which don’t change the semantics of my programs but are useful for debugging. I only sometimes want to run them and don’t want them to appear as dependencies at all on Hackage. It needs to be easy to apply them to my own and other people’s packages.</p>
<p>Of course, the solution was to leverage my knowledge of nix to wrap up everything into a nice interface. The key to the interface is a new function <code>haskell.lib.addPlugin</code> which augments an existing package with a plugin.</p>
<pre><code>addPlugin dump-core-plugin either</code></pre>
<p>This invocation will now also output an HTML representation of the core program of the <code>either</code> package by using the <code>dump-core</code> plugin.</p>
<p>This post will explain this interface in more detail but will not get into the gritty implementation details. The implementation can be found in the <a href="https://github.com/mpickering/haskell-nix-plugin"><code>haskell-nix-plugin</code></a> repo.</p>

        <a href="./posts/2018-06-24-haskell-nix-plugins.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Fixing the missing `ar` error with a development build of GHC (on NixOS) </span>
    <span class="info"> June 21, 2018 </span>
     
        <p>On NixOS, if you build GHC from source using Make or hadrian and try to use it with cabal then you will be greeted with the following error:</p>
<pre><code>cabal: The program 'ar' is required but it could not be found.</code></pre>
<p>The way to fix this problem is to run cabal in an environment with the <code>binutils-unwrapped</code> package available. You can then use cabal as normal.</p>
<pre><code>nix-shell -p binutils-unwrapped</code></pre>
      </p>
</li>

<li class="post_item">
    <span class="title"> Source Plugins: Four ways to build a typechecked Haskell expression </span>
    <span class="info"> June 11, 2018 </span>
     
        <p>A source plugin allows users to modify and analyse code after typechecking. They have access to all the features of the compiler to create and modify bindings.</p>
<p>Sounds great right? GHC is all about creating and modifying bindings so this should be a doddle. However, it isn’t immediately obvious how to make a typechecked binding using the provided API.</p>
<p>In this post, I’ll demonstrate and explain four different ways of arriving at a typechecked expression which can then be inserted into a program. All these examples are packaged up into a complete plugin on my <a href="https://github.com/mpickering/plugin-constraint">GitHub page</a>.</p>

        <a href="./posts/2018-06-11-source-plugins.html">Read more</a>
      </p>
</li>

  

        <div id="footer">
          <a href="./atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
