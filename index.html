<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="./">Home</a> <br>
              <a href="./about.html">About</a> <br>
              <a href="./archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <p> </p>

<li class="post_item">
    <span class="title"> Inlining and Specialisation </span>
    <span class="info"> March 20, 2017 </span>
     
        <p>The inliner and specialiser are the two parts of the optimiser which are crucial to writing performant functional programs. They ensure that we can write programs at a high-level of abstraction which are simplified when eventually used with concrete arguments.</p>
<p>The inliner’s job is to replace a function with its definition. This removes one layer of indirection and most importantly allows other optimisations to fire. The specialiser is important for optimising code which uses type classes. Type classes are desugared into dictionary passing style but the specialiser removes a layer of indirection by creating new functions with the relevant dictionaries already supplied.</p>
<p>This document will explain the basics of these two parts of the optimiser and some user-facing options which can be used to control them.</p>

        <a href="./posts/2017-03-20-inlining-and-specialisation.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Motivating the Foldable Type Class </span>
    <span class="info"> September 16, 2016 </span>
     
        <p>Something I have never seen articulated is why the <code>Foldable</code> type class exists. It is lawless apart from the free theorems which leads to ad-hoc definitions of its methods. What use is the abstraction if not to enable us to reason more easily about our programs? This post aims to articulate some justification stemming from the universality of folds.</p>
<p>In brief, here is the argument.</p>
<ol style="list-style-type: decimal">
<li>For inductive data types, the fold is unique defined as a consequence of initiality.</li>
<li>The <code>Foldable</code> type class is a way to exploit this universality without having to define all of our data types as the fixed points of base functors.</li>
<li>The uneasiness comes from this impedence mismatch between points 1 and 2.</li>
</ol>

        <a href="./posts/2016-09-16-motivating-foldable.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Why do pattern synonyms not cause type refinement? </span>
    <span class="info"> June 18, 2016 </span>
     
        <p>Pattern synonyms can’t (safely) cause any additional type refinement than their definition dictates. This means that they can’t be used to provide a GADT-like interface when the underlying representation is not a GADT. The purpose of this note is to explain this restriction.</p>

        <a href="./posts/2016-06-18-why-no-refinement.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Pattern Synonyms in GHC 8.0 </span>
    <span class="info"> December 12, 2015 </span>
     
        <p>There have been four small but significant improvements to pattern synonyms which are going to appear in GHC 8.0.</p>
<p>This work closes up some holes which were left in the implementation of pattern synonyms and should provide library authors with a new and flexible method of abstraction.</p>
<p>More information about pattern synonyms can be found in the <a href="http://mpickering.github.io/users_guide/glasgow_exts.html#pattern-synonyms">GHC 8.0 user guide</a>.</p>

        <a href="./posts/2015-12-12-pattern-synonyms-8.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Automatically Apply HLint Suggestions </span>
    <span class="info"> November 22, 2015 </span>
     
        <p>Users upgrading to <a href="https://hackage.haskell.org/package/hlint-1.9.23">hlint 1.9.23</a> will now be able to take advantage of the new <code>--refactor</code> flag which by invoking the <code>refactor</code> executable supplied by <a href="https://hackage.haskell.org/package/apply-refact-0.1.0.0"><code>apply-refact</code></a> can automatically apply suggestions.</p>
<p><img src="http://i.imgur.com/5hiEZJo.gif" alt="example" /><br />

        <a href="./posts/2015-11-22-hlint-refactor.html">Read more</a>
      </p>
</li>

  

        <div id="footer">
          <a href="./atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
