<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="./">Home</a> <br>
              <a href="./about.html">About</a> <br>
              <a href="./archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <p> </p>

<li class="post_item">
    <span class="title"> INLIN(E)ing: A case study </span>
    <span class="info"> May 17, 2017 </span>
     
        <p>Ollie Charles recently popped into #ghc to ask about a small program which was taking a long time to compile. In fact, the compiler was taking so long in the simplifier he had to increase the tick factor (a measure of how much work the simplifier is allowed to do) to get compilation to finish. Oleg and I quickly set to work working out what was going on in his program.</p>
<p>It turned out that a misplaced <code>INLINE</code> pragma was causing a lot of simplification work to be duplicated. Removing the pragma allowed the compiler to operate faster whilst producing the same code.</p>

        <a href="./posts/2017-05-17-inlining-case-study.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Indexed Optics </span>
    <span class="info"> April 10, 2017 </span>
     
        <p>What is an indexed optic? It is an optic which gives you access to an index whilst performing updates.</p>
<p>It is a simple clear generalisation of a lens but the implementation looks quite complicated. This is due to the desire to reuse the same combinators for both non-indexed and indexed variants. We we will start by explaining a simplified implementation of indexed optics before the technique used in order to reuse the same combinators as ordinary optics.</p>

        <a href="./posts/2017-04-10-indexed-optics.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Inlining and Specialisation </span>
    <span class="info"> March 20, 2017 </span>
     
        <p>The inliner and specialiser are the two parts of the optimiser which are crucial to writing performant functional programs. They ensure that we can write programs at a high-level of abstraction which are simplified when eventually used with concrete arguments.</p>
<p>The inliner’s job is to replace a function with its definition. This removes one layer of indirection and most importantly allows other optimisations to fire. The specialiser is important for optimising code which uses type classes. Type classes are desugared into dictionary passing style but the specialiser removes a layer of indirection by creating new functions with the relevant dictionaries already supplied.</p>
<p>This document will explain the basics of these two parts of the optimiser and some user-facing options which can be used to control them.</p>

        <a href="./posts/2017-03-20-inlining-and-specialisation.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Motivating the Foldable Type Class </span>
    <span class="info"> September 16, 2016 </span>
     
        <p>Something I have never seen articulated is why the <code>Foldable</code> type class exists. It is lawless apart from the free theorems which leads to ad-hoc definitions of its methods. What use is the abstraction if not to enable us to reason more easily about our programs? This post aims to articulate some justification stemming from the universality of folds.</p>
<p>In brief, here is the argument.</p>
<ol style="list-style-type: decimal">
<li>For inductive data types, the fold is unique defined as a consequence of initiality.</li>
<li>The <code>Foldable</code> type class is a way to exploit this universality without having to define all of our data types as the fixed points of base functors.</li>
<li>The uneasiness comes from this impedence mismatch between points 1 and 2.</li>
</ol>

        <a href="./posts/2016-09-16-motivating-foldable.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Why do pattern synonyms not cause type refinement? </span>
    <span class="info"> June 18, 2016 </span>
     
        <p>Pattern synonyms can’t (safely) cause any additional type refinement than their definition dictates. This means that they can’t be used to provide a GADT-like interface when the underlying representation is not a GADT. The purpose of this note is to explain this restriction.</p>

        <a href="./posts/2016-06-18-why-no-refinement.html">Read more</a>
      </p>
</li>

  

        <div id="footer">
          <a href="./atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
