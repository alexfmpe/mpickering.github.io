<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="./">Home</a> <br>
              <a href="./about.html">About</a> <br>
              <a href="./archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <p> </p>

<li class="post_item">
    <span class="title"> Reimplementing graphmod as a source plugin: graphmod-plugin </span>
    <span class="info"> August  9, 2018 </span>
     
        <p>You may have heard about <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">source plugins</a> by now. They allow you to modify and inspect the compiler’s intermediate representation. This is useful for extending GHC and performing static analysis of Haskell programs.</p>
<p>In order to test them out, I reimplemented the <a href="https://github.com/yav/graphmod"><code>graphmod</code></a> tool as a source plugin. <code>graphmod</code> generates a graph of the module structure of your package. Reimplementing it as a source plugin makes the implementation more robust. I implementated it as as a type checker plugin which runs after type checking has finished. The result: <a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a></p>
<figure>
<img src="https://raw.githubusercontent.com/yav/graphmod/master/screenshots/aeson1.dot.png" alt="An example of the structure of the aeson package" /><figcaption>An example of the structure of the <code>aeson</code> package</figcaption>
</figure>

        <a href="./posts/2018-08-09-source-plugin-graphmod.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Nix scaffolding for running Haskell plugins </span>
    <span class="info"> June 24, 2018 </span>
     
        <p>I’ve been all about writing <a href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html">source plugins</a> recently but have been dissatisfied with how rough it is to use them practically. In particular, I am writing plugins which don’t change the semantics of my programs but are useful for debugging. I only sometimes want to run them and don’t want them to appear as dependencies at all on Hackage. It needs to be easy to apply them to my own and other people’s packages.</p>
<p>Of course, the solution was to leverage my knowledge of nix to wrap up everything into a nice interface. The key to the interface is a new function <code>haskell.lib.addPlugin</code> which augments an existing package with a plugin.</p>
<pre><code>addPlugin dump-core-plugin either</code></pre>
<p>This invocation will now also output an HTML representation of the core program of the <code>either</code> package by using the <code>dump-core</code> plugin.</p>
<p>This post will explain this interface in more detail but will not get into the gritty implementation details. The implementation can be found in the <a href="https://github.com/mpickering/haskell-nix-plugin"><code>haskell-nix-plugin</code></a> repo.</p>

        <a href="./posts/2018-06-24-haskell-nix-plugins.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Fixing the missing `ar` error with a development build of GHC (on NixOS) </span>
    <span class="info"> June 21, 2018 </span>
     
        <p>On NixOS, if you build GHC from source using Make or hadrian and try to use it with cabal then you will be greeted with the following error:</p>
<pre><code>cabal: The program 'ar' is required but it could not be found.</code></pre>
<p>The way to fix this problem is to run cabal in an environment with the <code>binutils-unwrapped</code> package available. You can then use cabal as normal.</p>
<pre><code>nix-shell -p binutils-unwrapped</code></pre>
      </p>
</li>

<li class="post_item">
    <span class="title"> Source Plugins: Four ways to build a typechecked Haskell expression </span>
    <span class="info"> June 11, 2018 </span>
     
        <p>A source plugin allows users to modify and analyse code after typechecking. They have access to all the features of the compiler to create and modify bindings.</p>
<p>Sounds great right? GHC is all about creating and modifying bindings so this should be a doddle. However, it isn’t immediately obvious how to make a typechecked binding using the provided API.</p>
<p>In this post, I’ll demonstrate and explain four different ways of arriving at a typechecked expression which can then be inserted into a program. All these examples are packaged up into a complete plugin on my <a href="https://github.com/mpickering/plugin-constraint">GitHub page</a>.</p>

        <a href="./posts/2018-06-11-source-plugins.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Replacing type classes with records affects optimisation </span>
    <span class="info"> March 20, 2018 </span>
     
        <p>It is somewhat common to suggest using records instead of type classes for particular domains for which type classes are not deemed idiomatic. However, this suggestion should be taken with caution as the change will have consequences on how your program is optimised. Using records instead of type classes can lead to much slower programs.</p>

        <a href="./posts/2018-03-20-recordsvstypeclasses.html">Read more</a>
      </p>
</li>

  

        <div id="footer">
          <a href="./atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
