<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div class="container">
          <div class="row">
            <div class="col-sm-auto">
              <ul class="nav flex-column">
              <li class="nav-item">
                <a href="./">Home</a>
              </li>
              <li class="nav-item">
                <a href="./about.html">About</a> <br>
              </li>
              <li class="nav-item">
                <a href="./archive.html">Archive</a> <br>
              </li>
              <li>
                <a href="./atom.xml">Feed</a>
              </li>
              <li>
                <a href="./plugins.html">Plugins</a>
              </li>
              <li>
                <a href="./maps.html">Maps</a>
              </li>
              </ul>
            </div>
          <div class="col-md">

            <div id="content">
              
<h2> Packaging a Haskell library for artefact evaluation using nix <small class="text-muted"> September 19, 2018 </small> </span> </h2>
     
        <p>This year I packaged two artefacts for the ICFP artefact evaluation process. This post explains the system I used to make it easy to produce the docker images using nix. I hope this documentation will be useful for anyone else submitting a Haskell library for evaluation.</p>
<p>The end result will be an <code>artefact.nix</code> file which is used to build a docker image to submit. It will be an entirely reproducible process as we will fix the versions of all the dependencies we use.</p>

        <a href="./posts/2018-09-19-nix-artefacts.html">Read more</a>
      
<hr>

<h2> Using funflow to cache a nix based workflow <small class="text-muted"> September 12, 2018 </small> </span> </h2>
     
        <p>My latest project has been to plot a <a href="http://mpickering.github.io/maps.html">map of orienteering maps</a> in the UK. This post explains the technical aspects behind the project and primarily the use of <a href="https://hackage.haskell.org/package/funflow"><code>funflow</code></a> to turn my assortment of scripts into into a resumable workflow.</p>
<p>There was nothing wrong with my ad-hoc python and bash scripts but they downloaded and regenerated the whole output every time. The whole generation takes about 2 hours so it’s desirable to only recompute the necessary portions. This is where <code>funflow</code> comes in, by stringing together these scripts in their DSL, you get caching for free. The workflow is also highly parallelisable so in the future I could distribute the work across multiple machines if necessary.</p>
<p>The code for the project can be found <a href="https://github.com/mpickering/rg-map">here</a>.</p>
<p><img src="https://i.imgur.com/NVLui01.png" style="width: 50%; margin: auto; display: block" /></p>

        <a href="./posts/2018-09-12-funflow-nix.html">Read more</a>
      
<hr>

<h2> Specifying how a plugin affects recompilation <small class="text-muted"> August 10, 2018 </small> </span> </h2>
     
        <p>Plugins have existed for a long time in GHC. The first plugins were implemented in <a href="http://blog.omega-prime.co.uk/2008/06/15/compiler-plugins-for-ghc-the-first-week/">2008</a> by Max Bolingbroke. They enabled users to modify the optimisation pipeline. They ran after desugaring and hence were called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#core-plugins-in-more-detail">“core” plugins</a>. Later, Adam Gundry implemented what I shall refer to as <a href="http://adam.gundry.co.uk/pub/typechecker-plugins/">“constraint solver” plugins</a> which allow users to provide custom solver logic to solve additional constraints. Recently, Boldizsár Németh has extended the number of extension points again with a set of plugins which can inspect and modify the syntax AST. Plugins can run after parsing, renaming or type checking and hence are called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">“source” plugins</a>.</p>
<p>The idea behind plugins was great - a user can extend the compiler in their own specific way without having to modify the source tree and rebuild the compiler from scratch. It is far more convenient to write a plugin than to use a custom compiler. However, if a user wants to use a plugin, they will find that every module where the plugin is enabled is always recompiled, even if the source code didn’t change at all. Why is this? Well, a plugin can do anything, it could read the value from a temperature sensor and insert the room temperature into the program. Thus, we would always need to recompile a module if the temperature reading changed as it would affect what our program did.</p>
<p>However, there are also “pure” plugins, whose output is only affected by the program which is passed as in input. For these plugins, if the source code doesn’t change then we don’t need to do any recompilation.</p>
<p>This post is about a new metadata field which I added to the <code>Plugin</code> data type which specifies how a plugin should affect recompilation. This feature will be present in GHC 8.6.</p>

        <a href="./posts/2018-08-10-plugins-recompilation.html">Read more</a>
      
<hr>

<h2> Reimplementing graphmod as a source plugin: graphmod-plugin <small class="text-muted"> August  9, 2018 </small> </span> </h2>
     
        <p>You may have heard about <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">source plugins</a> by now. They allow you to modify and inspect the compiler’s intermediate representation. This is useful for extending GHC and performing static analysis of Haskell programs.</p>
<p>In order to test them out, I reimplemented the <a href="https://github.com/yav/graphmod"><code>graphmod</code></a> tool as a source plugin. <code>graphmod</code> generates a graph of the module structure of your package. Reimplementing it as a source plugin makes the implementation more robust. I implemented it as as a type checker plugin which runs after type checking has finished. The result: <a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a></p>
<figure>
<img src="https://raw.githubusercontent.com/yav/graphmod/master/screenshots/aeson1.dot.png" alt="An example of the structure of the aeson package" /><figcaption>An example of the structure of the <code>aeson</code> package</figcaption>
</figure>

        <a href="./posts/2018-08-09-source-plugin-graphmod.html">Read more</a>
      
<hr>

<h2> Nix scaffolding for running Haskell plugins <small class="text-muted"> June 24, 2018 </small> </span> </h2>
     
        <p>I’ve been all about writing <a href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html">source plugins</a> recently but have been dissatisfied with how rough it is to use them practically. In particular, I am writing plugins which don’t change the semantics of my programs but are useful for debugging. I only sometimes want to run them and don’t want them to appear as dependencies at all on Hackage. It needs to be easy to apply them to my own and other people’s packages.</p>
<p>Of course, the solution was to leverage my knowledge of nix to wrap up everything into a nice interface. The key to the interface is a new function <code>haskell.lib.addPlugin</code> which augments an existing package with a plugin.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ex">addPlugin</span> dump-core-plugin either</a></code></pre></div>
<p>This invocation will now also output an HTML representation of the core program of the <code>either</code> package by using the <code>dump-core</code> plugin.</p>
<p>This post will explain this interface in more detail but will not get into the gritty implementation details. The implementation can be found in the <a href="https://github.com/mpickering/haskell-nix-plugin"><code>haskell-nix-plugin</code></a> repo.</p>

        <a href="./posts/2018-06-24-haskell-nix-plugins.html">Read more</a>
      
<hr>



            </div>
          </div>
        </div>
      </div>
    </body>
</html>
