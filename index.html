<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>mpickering - index</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link href="http://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="sidebar">
            <div id="navigation">
              <a href="./">Home</a> <br>
              <a href="./about.html">About</a> <br>
              <a href="./archive.html">Archive</a> <br>
            </div>
        </div>

        <div id="content">
            <p> </p>

<li class="post_item">
    <span class="title"> Fixing the missing `ar` error with a development build of GHC (on NixOS) </span>
    <span class="info"> June 21, 2018 </span>
     
        <p>On NixOS, if you build GHC from source using Make or hadrian and try to use it with cabal then you will be greeted with the following error:</p>
<pre><code>cabal: The program 'ar' is required but it could not be found.</code></pre>
<p>The way to fix this problem is to run cabal in an environment with the <code>binutils-unwrapped</code> package available. You can then use cabal as normal.</p>
<pre><code>nix-shell -p binutils-unwrapped</code></pre>
      </p>
</li>

<li class="post_item">
    <span class="title"> Source Plugins: Four ways to build a typechecked Haskell expression </span>
    <span class="info"> June 11, 2018 </span>
     
        <p>A source plugin allows users to modify and analyse code after typechecking. They have access to all the features of the compiler to create and modify bindings.</p>
<p>Sounds great right? GHC is all about creating and modifying bindings so this should be a doddle. However, it isn’t immediately obvious how to make a typechecked binding using the provided API.</p>
<p>In this post, I’ll demonstrate and explain four different ways of arriving at a typechecked expression which can then be inserted into a program. All these examples are packaged up into a complete plugin on my <a href="https://github.com/mpickering/plugin-constraint">GitHub page</a>.</p>

        <a href="./posts/2018-06-11-source-plugins.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Replacing type classes with records affects optimisation </span>
    <span class="info"> March 20, 2018 </span>
     
        <p>It is somewhat common to suggest using records instead of type classes for particular domains for which type classes are not deemed idiomatic. However, this suggestion should be taken with caution as the change will have consequences on how your program is optimised. Using records instead of type classes can lead to much slower programs.</p>

        <a href="./posts/2018-03-20-recordsvstypeclasses.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> Using a development version of GHC with nix </span>
    <span class="info"> January  5, 2018 </span>
     
        <p>Most documentation for using nix with Haskell concentrates on quite simple use cases such as how to modify or add new dependencies. What about when you want to do something more complicated? In this post we look at combining modifications from different sources. The goal is to create a package set which can be used to compile packages with HEAD.</p>

        <a href="./posts/2018-01-05-ghchead-nix.html">Read more</a>
      </p>
</li>

<li class="post_item">
    <span class="title"> INLIN(E)ing: A case study </span>
    <span class="info"> May 17, 2017 </span>
     
        <p>Ollie Charles recently popped into #ghc to ask about a small program which was taking a long time to compile. In fact, the compiler was taking so long in the simplifier he had to increase the tick factor (a measure of how much work the simplifier is allowed to do) to get compilation to finish. Oleg and I quickly set to work working out what was going on in his program.</p>
<p>It turned out that a misplaced <code>INLINE</code> pragma was causing a lot of simplification work to be duplicated. Removing the pragma allowed the compiler to operate faster whilst producing the same code.</p>

        <a href="./posts/2017-05-17-inlining-case-study.html">Read more</a>
      </p>
</li>

  

        <div id="footer">
          <a href="./atom.xml">Feed</a>
        </div>
        </div>
    </body>
</html>
