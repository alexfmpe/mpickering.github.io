<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>mpickering.github.io</title>
    <link href="http://mpickering.github.io/atom.xml" rel="self" />
    <link href="http://mpickering.github.io" />
    <id>http://mpickering.github.io/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2018-06-21T00:00:00Z</updated>
    <entry>
    <title>Fixing the missing `ar` error with a development build of GHC (on NixOS)</title>
    <link href="http://mpickering.github.io/posts/2018-06-21-binutils-unwrapped.html" />
    <id>http://mpickering.github.io/posts/2018-06-21-binutils-unwrapped.html</id>
    <published>2018-06-21T00:00:00Z</published>
    <updated>2018-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Fixing the missing `ar` error with a development build of GHC (on NixOS) </h2>
<div class="info">
    Posted on June 21, 2018
    
</div>

<p>On NixOS, if you build GHC from source using Make or hadrian and try to use it with cabal then you will be greeted with the following error:</p>
<pre><code>cabal: The program &#39;ar&#39; is required but it could not be found.</code></pre>
<p>The way to fix this problem is to run cabal in an environment with the <code>binutils-unwrapped</code> package available. You can then use cabal as normal.</p>
<pre><code>nix-shell -p binutils-unwrapped</code></pre>
]]></summary>
</entry>
<entry>
    <title>Source Plugins: Four ways to build a typechecked Haskell expression</title>
    <link href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html" />
    <id>http://mpickering.github.io/posts/2018-06-11-source-plugins.html</id>
    <published>2018-06-11T00:00:00Z</published>
    <updated>2018-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Source Plugins: Four ways to build a typechecked Haskell expression </h2>
<div class="info">
    Posted on June 11, 2018
    
</div>

<p>A source plugin allows users to modify and analyse code after typechecking. They have access to all the features of the compiler to create and modify bindings.</p>
<p>Sounds great right? GHC is all about creating and modifying bindings so this should be a doddle. However, it isn’t immediately obvious how to make a typechecked binding using the provided API.</p>
<p>In this post, I’ll demonstrate and explain four different ways of arriving at a typechecked expression which can then be inserted into a program. All these examples are packaged up into a complete plugin on my <a href="https://github.com/mpickering/plugin-constraint">GitHub page</a>.</p>
<!--more-->
<h2 id="constructing-expressions">Constructing Expressions</h2>
<p>The four examples which we order from the most direct to the most indirect. Each has their advantages but in general, directly constructing an already typechecked binding is the most risky but flexible whilst starting from a Template Haskell quote is the safest but most rigid option. In the end we will always end up with a <code>LHsExpr GhcTc</code> but we will start from four different places.</p>
<ul>
<li><code>LHsExpr GhcTc</code> - An already typechecked expression</li>
<li><code>LHsExpr GhcRn</code> - An already renamed expression</li>
<li><code>LHsExpr GhcPs</code> - A parsed expression</li>
<li><code>TH.Exp</code> - A quoted expression</li>
</ul>
<p>Each example will construct the simple expression <code>print ()</code>. This example is chosen because it demonstrates that we must be concerned with polymorphism and type classes during the process.</p>
<h2 id="typechecked-expression">Typechecked Expression</h2>
<p>Constructing a <code>LHsExpr GhcTc</code> by hand is quite annoying as you must be knowledgeable about how the typechecker prepares a program. You must also be quite explicit about types and the compiler won’t tell you that you’re wrong unless you compiler with core lint enabled.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- Creates the already typechecked expression `print ()`</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">-- There is quite a lot of boilerplate and the compiler won&#39;t tell</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- you where you went wrong unless -dcore-lint is enabled.</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">mkNewExprTc ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">mkNewExprTc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="co">-- Get the `Id`s that we need, these ones helpfully are already defined</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="co">-- in `PrelNames` and `TysWiredIn`.</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  print_id    <span class="ot">&lt;-</span> tcLookupId printName</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="co">-- Generate the evidence for `Show ()` which we will pass to `print`</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  (dict_var, showUnitEv) <span class="ot">&lt;-</span> generateDictionary</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    rhs <span class="fu">=</span> mHsApp (mLHsWrap wrapper printExpr) unitExpr)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    printExpr <span class="fu">=</span> nlHsVar print_id</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    unitExpr <span class="fu">=</span> nlHsDataCon unitDataCon</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="co">-- How we are going to apply the necessary type arguments</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    wrapper <span class="fu">=</span> mkWpLet showUnitEv <span class="fu">&lt;.&gt;</span> mkWpEvVarApps [dict_var] <span class="fu">&lt;.&gt;</span> mkWpTyApps [unitTy]</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  return rhs</a></code></pre></div>
<p>Notice that in particular, we have to be careful to construct and apply a wrapper which will desugar to type and dictionary applications. We also have to explicitly come up with the correct dictionary for the <code>print</code> function and manually apply it ourselves. This approach gives us a lot of control but leaves many fiddly places to go wrong.</p>
<h2 id="renamed-binding">Renamed Binding</h2>
<p>The second approach creates a <code>LHsExpr GhcRn</code> which we will then typecheck using the normal typechecker. This has the advantage that we can be direct about which names we mean but also have the safety that the compiler will emit an error when the plugin is used if we made a mistake.</p>
<p>We still have to construct the return type of the expression to pass into the typechecker. We use <code>lookupOccRn</code> to find the definition of <code>print</code> which is in scope but can use <code>unitDataCon</code> directly without looking it up as it is already wired into the compiled and defined in <code>PrelNames</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- Creates a `LHsExpr GhcRn` which we then typecheck to turn into</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- a `LHsExpr GhcTc`. The compiler will raise an error to the user if you</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">-- made a mistake in constructing the term.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">mkNewExprRn ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">mkNewExprRn <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="co">-- The names we want to use happen to already be in PrelNames so we use</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="co">-- them directly.</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">let</span> print_occ <span class="fu">=</span> mkRdrUnqual (mkVarOcc <span class="st">&quot;print&quot;</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  print_name <span class="ot">&lt;-</span> lookupOccRn print_occ</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="kw">let</span> raw_expr <span class="fu">=</span> nlHsApp (nlHsVar print_name) (nlHsVar (dataConName unitDataCon))</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  typecheckExpr exp_type raw_expr</a></code></pre></div>
<h2 id="parsed-binding">Parsed Binding</h2>
<p>We sometimes don’t want to specify exactly which names we mean or know which renaming functions to use to find them. It’s easier to let the renamer do that for us. In this example, we construct a <code>LHsExpr GhcPs</code> which we then pass into the renamer and typechecker. Therefore, the compiler will warn us about out of scope variables or type errors in the expression we have created like normal.</p>
<p>Instead of constructing <code>Name</code>s like before, we are constructing <code>RdrName</code>s. These are conceptually easier to create as we must only consider the namespace the name lives in rather than any other details. The renamer will fill in the rest of the information.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- An example of how to construct a value from a `LHsExpr GhcPs`.</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- Making sure things are in the right namespace is sometimes a bit</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">-- awkward.</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">mkNewExprPs ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">mkNewExprPs  <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    print_occ <span class="fu">=</span> mkRdrUnqual (mkVarOcc <span class="st">&quot;print&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    unit_occ <span class="fu">=</span> nameRdrName (dataConName unitDataCon)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    ps_expr <span class="fu">=</span> nlHsApp (nlHsVar print_occ)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                      (nlHsVar unit_occ)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  renameExpr ps_expr <span class="fu">&gt;&gt;=</span> typecheckExpr exp_type</a></code></pre></div>
<p>Note, I initially tried to use a different definition of <code>unit_occ</code> which didn’t start from the wired in name but it proved tricky to get correct. This is why we start from the more specific <code>Name</code> and turn it into a <code>RdrName</code>. We are also relying more on the context of the module, if the user hasn’t imported <code>print</code> then the plugin will fail.</p>
<h2 id="constructing-a-binding-from-template-haskell">Constructing a binding from Template Haskell</h2>
<p>Still, explicitly typing out the syntax tree is quite onerous. We would much prefer type out a Haskell program as normal and then splice it into our program. We can achieve this by using a Template Haskell quasiquoter.</p>
<p>We first quote the expression we want to insert which creates a <code>TH.Exp</code> which we can convert to a normal <code>HsExpr GhcPs</code> by using the same function that GHC itself uses to deal with Template Haskell. Once we have the parsed expression we can rename it and typecheck it as in the previous examples. This is all quite convenient!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">liftQ ::</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">TcM</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">liftQ <span class="fu">=</span> liftIO <span class="fu">.</span> runQ</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">-- Creates a `TH.Exp` using a quasiquoter before renaming</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">-- and typechecking to create an `LHsExpr`. This is convenient as you</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">-- don&#39;t have to write out the syntax.</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">-- p</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ot">mkNewExprTh ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">mkNewExprTh <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  th_expr <span class="ot">&lt;-</span> liftQ [<span class="fu">|</span> print () <span class="fu">|</span>]</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  ps_expr <span class="ot">&lt;-</span> <span class="kw">case</span> convertToHsExpr noSrcSpan th_expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="dt">Left</span> _err <span class="ot">-&gt;</span> error <span class="st">&quot;Bad expression&quot;</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="dt">Right</span> res <span class="ot">-&gt;</span> return res</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  renameExpr ps_expr <span class="fu">&gt;&gt;=</span> typecheckExpr exp_type</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>In our experience, the most practical way of constructing expressions is to use Template Haskell. A more in-depth example which creates a complicated expression can be see in the <a href="https://github.com/ocharles/assert-explainer">assert-explainer</a> which I worked on with Ollie Charles at Zurihac 2018.</p>
<h1 id="addendum-how-can-i-interact-with-the-constraint-solver">Addendum: How can I interact with the constraint solver?</h1>
<p>The <code>generateDictionary</code> is an example of how to generate some evidence. It might need to be refined further but worked for simple tests.</p>
<h1 id="addendum-how-can-i-get-the-type-of-an-hsexpr-ghctc">Addendum: How can I get the type of an <code>HsExpr GhcTc</code>?</h1>
<p>To get the type of an expression, first desugar the expression and then use <code>exprType</code> to find the type of the desugared variant. There is an example in <a href="https://github.com/ocharles/assert-explainer/blob/master/plugin/AssertExplainer.hs#L289">assert-explainer</a>.</p>
<h1 id="addendum-how-can-i-combine-together-old-and-new-program-fragments">Addendum: How can I combine together old and new program fragments</h1>
<p>If you want to combine together pieces of new syntax and old syntax then don’t try to do it directly. Construct a lambda with arguments for each of the pieces you want to insert. Finally, apply the lambda to the existing expressions you want to insert.</p>
]]></summary>
</entry>
<entry>
    <title>Replacing type classes with records affects optimisation</title>
    <link href="http://mpickering.github.io/posts/2018-03-20-recordsvstypeclasses.html" />
    <id>http://mpickering.github.io/posts/2018-03-20-recordsvstypeclasses.html</id>
    <published>2018-03-20T00:00:00Z</published>
    <updated>2018-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Replacing type classes with records affects optimisation </h2>
<div class="info">
    Posted on March 20, 2018
    
</div>

<p>It is somewhat common to suggest using records instead of type classes for particular domains for which type classes are not deemed idiomatic. However, this suggestion should be taken with caution as the change will have consequences on how your program is optimised. Using records instead of type classes can lead to much slower programs.</p>
<!--more-->
<p>In order to provide an interface for propositional logic, we might provide a type class which allows the constructors to be overloaded. We can then provide a direct interpretation of <code>Prop</code> which evaluates an expression to a truth value.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Prop</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  or ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  and ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">  true ::</span> r</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  false ::</span> r</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Prop</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  or <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  and <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  true <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  false <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>However, one might be tempted to avoid using a type class and instead perform the manual type class desugaring in order to be able to more easily modify and extend an interpretation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">PropDict</span> r <span class="fu">=</span> <span class="dt">PropDict</span> {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  dor ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> dand ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  ,<span class="ot"> dtrue ::</span> r</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  ,<span class="ot"> dfalse ::</span> r</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">boolDict <span class="fu">=</span> <span class="dt">PropDict</span> {</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  dor <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  , dand <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  , dtrue <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , dfalse <span class="fu">=</span> <span class="dt">False</span> }</a></code></pre></div>
<p>We can then use both versions in order to implement a helper function which turns a list into a chain of disjunctions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">ors ::</span> <span class="dt">Prop</span> r <span class="ot">=&gt;</span> [r] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">ors [o] <span class="fu">=</span> o</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">ors (o<span class="fu">:</span>os) <span class="fu">=</span> o <span class="ot">`or`</span> ors os</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">dors ::</span> <span class="dt">PropDict</span> r <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">dors _ [o] <span class="fu">=</span> o</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">dors pd (o<span class="fu">:</span>os) <span class="fu">=</span> dor pd o (dors pd os)</a></code></pre></div>
<p>We can then instantiate each function by either supplying a type argument or the dictionary directly in the latter case.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">test1 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">test1 <span class="fu">=</span> ors <span class="fu">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">test2 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">test2 <span class="fu">=</span> dors boolDict</a></code></pre></div>
<p>What’s the difference between these two versions? The process of optimisation is different. In the first case, the overloading of <code>ors</code> will be eliminated by <strong>specialisation</strong>. In the later case, the static argument will be eliminated by <strong>SpecConstr</strong>. When we define these definitions in the same module as our earlier definitions of <code>ors</code> and <code>dors</code> then both definitions result in essentially the same code as each other. The overhead is eliminated.</p>
<p>However, when we use <code>ors</code> or <code>dors</code> in another module, they behave quite differently. If we mark <code>ors</code> as <code>INLINABLE</code> then it will also be specialised in other modules. However, <strong>SpecConstr does not work across module boundaries</strong>. As a result, <code>dors</code> will not be specialised on the static argument and the dictionary overhead will remain.</p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://github.com/mpickering/rtcwrao-benchmarks">Benchmarks</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/85svhm/replacing_type_classes_with_records_affects/">Reddit Discussion</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Using a development version of GHC with nix</title>
    <link href="http://mpickering.github.io/posts/2018-01-05-ghchead-nix.html" />
    <id>http://mpickering.github.io/posts/2018-01-05-ghchead-nix.html</id>
    <published>2018-01-05T00:00:00Z</published>
    <updated>2018-01-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Using a development version of GHC with nix </h2>
<div class="info">
    Posted on January  5, 2018
    
</div>

<p>Most documentation for using nix with Haskell concentrates on quite simple use cases such as how to modify or add new dependencies. What about when you want to do something more complicated? In this post we look at combining modifications from different sources. The goal is to create a package set which can be used to compile packages with HEAD.</p>
<!--more-->
<p>The main problem which we are going to solve is that many packages need modifying in order to compile with HEAD. There is already a nix package which builds a development version of the compiler and a corresponding package set but the utility is limited as many packages will fail to compile.</p>
<p>For example, at the time of writing this post, if we try and build the <code>primitive</code> package, the build fails due to a missing <code>Semigroup</code> instance.</p>
<p>If you are impatient, here is the <a href="https://gist.github.com/mpickering/209354a6affe2883ca07ffc4f4084af6">complete example</a> we are going to come up with. We create a new top-level attribute <code>new-ghcHEAD</code> which we can use to build packages with <code>ghcHEAD</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ex">nixpkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="ex">patchRepo</span> =</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="ex">nixpkgs.fetchFromGitHub</span> {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      <span class="ex">owner</span> = <span class="st">&quot;mpickering&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="ex">repo</span> = <span class="st">&quot;head.hackage&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="fu">rev</span> = <span class="st">&quot;767dcf11b367ccff4a9fcd55df9c2432cd485fbe&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="ex">sha256</span> = <span class="st">&quot;1cdrcw7grpc2dyxnb7a5bg9mi1h7qnblcibi91s348034zf7a0vj&quot;</span><span class="kw">;</span>};</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="ex">patchDir</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/patches&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="ex">patchScript</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/scripts/overrides.nix&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">in</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="ex">self</span>: super:</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">{</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="ex">haskellPatches</span> = self.callPackage patchScript</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">              <span class="kw">{</span> <span class="ex">patches</span> = patchDir<span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">          <span class="ex">sel</span>: sup: { haskell-src-exts</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">                        = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">                      <span class="ex">mkDerivation</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">                        = <span class="ex">drv</span>: sup.mkDerivation (drv //</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">                             <span class="kw">{</span> <span class="ex">jailbreak</span> = true<span class="kw">;</span> <span class="ex">doHaddock</span> = false<span class="kw">;}</span>);</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">                     <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">         <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">}</a></code></pre></div>
<h1 id="a-simple-overlay">A simple overlay</h1>
<p>We are going to use an overlay in order to define the new package set. An overlay is the idiomatic way to extend and change the top-level nixpkgs set. It is a function which takes two arguments, the result of performing the modification and the old unmodified package set. It returns a set of attributes which augment the top-level attribute set.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="ex">my-cool-new-attribute</span> = ...<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">}</a></code></pre></div>
<p>As such <code>my-cool-new-attribute</code> will be in <code>self</code> but not in <code>super</code>. If we want to use <code>my-cool-new-attribute</code> in another attribute we can refer to it as <code>self.my-cool-new-attribute</code>.</p>
<p>When this overlay is installed (see below), we can use <code>my-cool-new-attribute</code> like any top-level attribute defined in <code>nixpkgs</code>. The overlay mechanism surpasses the old <code>packageOverrides</code> mechanism which used to be how to modify <code>nixpkgs</code>.</p>
<p>For example, we could enter an environment with <code>my-cool-new-attribute</code> available with <code>nix-shell -p my-cool-new-attribute</code> as if it were defined in the main <code>nixpkgs</code> repo.</p>
<p>There are two ways to easily install an overlay.</p>
<ol type="1">
<li><p>Pass it as an argument when importing nixpkgs.<br />
</p>
<pre><code>let pkgs = import &lt;nixpkgs&gt; {overlays = [overlay1 overlay2 ..]};
in ...</code></pre></li>
<li><p>Place the overlay in <code>~/.config/nixpkgs/overlays/</code></p></li>
</ol>
<p>More details about using overlays can be found in the <a href="https://nixos.org/nixpkgs/manual/#sec-overlays-install">user manual</a>.</p>
<h1 id="extending-a-package-set">Extending a package set</h1>
<p>We’ll start from a simple template which demonstrates the concept of extending a Haskell package set like you might find in other documentation. We start from the <code>ghcHEAD</code> package set (<code>haskell.packages.ghcHEAD</code>) and then call the <code>extend</code> attribute with the extension function.</p>
<p>The extension function takes two arguments, the extended haskell package set and the original haskell package set much like an overlay. <code>ghcPackageOverrides</code> is the identity extension function in this example which performs no modifications.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="bu">let</span> ghcPackageOverrides = sel: sup: <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides <span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>If we then want to fix a specific version of a package we can modify <code>ghcPackageOverrides</code> like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="bu">let</span> ghcPackageOverrides =</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">          <span class="ex">sel</span>: sup: {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">            <span class="ex">haskell-src-exts</span> =</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">              <span class="ex">sup.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">          };</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">}</a></code></pre></div>
<p>When using the <code>new-ghcHEAD</code> package set, we will now install <code>haskell-src-exts-1.20.1</code> rather than <code>haskell-src-exts-1.19.1</code> if it is needed as a dependency.</p>
<h2 id="more-extensions">More extensions</h2>
<p>Manually redefining each package to get it to build is tedious. Instead, we’re going to use the patches from <a href="https://github.com/hvr/head.hackage"><code>head.hackage</code></a> in order to generate a lot of modifications automatically. What we need are the patches in <code>head.hackage/patches</code> which enable packages to build with the bleeding edge version of the compiler.</p>
<p>In <code>head.hackage/scripts</code> there are the necessary files in order to use the patches with nix. <code>overrides.nix</code> is a wrapper which runs a haskell executable in order to generate a nix expression explaining the package modifications. The result of the derivation is a file which we can then import into our overlay directly.</p>
<h3 id="using-a-local-copy-of-head.hackage">Using a local copy of <code>head.hackage</code></h3>
<p>You will probably want to clone <code>head.hackage</code> locally so that you can add and modify patches as necessary to get your project to compile.</p>
<p>In that case, instead of specifying a url, we just specify the correct paths for the packaging script and patch directory.</p>
<p>For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">}</a></code></pre></div>
<h3 id="using-a-remote-copy-of-head.hackage">Using a remote copy of <code>head.hackage</code></h3>
<p>If you don’t want to maintain a local clone of the repo then you can also fetch it from wherever you like. For example, here I fetch a specific branch from my clone of the repo which contains some nix specific patches.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ex">nixpkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ex">patchRepo</span> = nixpkgs.fetchFromGitHub {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="ex">owner</span> = <span class="st">&quot;mpickering&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="ex">repo</span> = <span class="st">&quot;head.hackage&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="fu">rev</span> = <span class="st">&quot;767dcf11b367ccff4a9fcd55df9c2432cd485fbe&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="ex">sha256</span> = <span class="st">&quot;1cdrcw7grpc2dyxnb7a5bg9mi1h7qnblcibi91s348034zf7a0vj&quot;</span><span class="kw">;</span>};</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  <span class="ex">patchDir</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/patches&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="ex">patchScript</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/scripts/overrides.nix&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">in</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="ex">self</span>: super:</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">{</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="ex">haskellPatches</span> = self.callPackage patchScript</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">              <span class="kw">{</span> <span class="ex">patches</span> = patchDir<span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20"><span class="kw">}</span></a></code></pre></div>
<h2 id="combining-head.hackage-modifications-with-local-modifications">Combining <code>head.hackage</code> modifications with local modifications</h2>
<p>Unfortunately, this is not quite enough as it is sometimes necessary to further modify packages in order to get them to compile. The most obvious way is that a lot of packages have restrictive version bounds but compile fine with newer versions of libraries. So, in order to get around this we preemptively need to jailbreak all packages.</p>
<p>Jailbreaking is a process which removes all version bounds from a package. This is safe to do as each package set only contains one version of each dependency anyway.</p>
<p>We introduce a new extension function <code>localOverrides</code> which will contain our specific modifications which we don’t want to include in <code>head.hackage</code>. We will first only contain one specific modification which chooses a new version of <code>haskell-src-exts</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="ex">sel</span>: sup:</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            <span class="kw">{</span> <span class="ex">haskell-src-exts</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">                = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">            <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">}</a></code></pre></div>
<p>We need to use <code>composeExtensions</code> so that the attributes we locally modify are then also modified by <code>head.hackage</code> incrementally.</p>
<h3 id="modifying-mkderivation">Modifying <code>mkDerivation</code></h3>
<p>Finally, we will modify <code>mkDerivation</code> in order to jailbreak packages and not run <code>haddock</code> in order to speed up the builds. <code>mkDerivation</code> is the function which takes a Haskell package description and turns it into a nix derivation. It’s the function which when given the what to build, says precisely <em>how</em> to build it.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">          <span class="ex">sel</span>: sup: {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">            <span class="ex">haskell-src-exts</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">              = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">            <span class="ex">mkDerivation</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">              = <span class="ex">drv</span>: sup.mkDerivation (drv //</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                  <span class="kw">{</span> <span class="ex">jailbreak</span> = true<span class="kw">;</span> <span class="ex">doHaddock</span> = false<span class="kw">;}</span>);</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">          };</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">}</a></code></pre></div>
<h2 id="testing">Testing</h2>
<p>We can now test our new attribute using <code>nix-shell</code>. For example, let’s try to provision a version of the compiler with <code>primitive</code> available.</p>
<pre><code>&gt; nix-shell -p &quot;new-ghcHEAD.ghcWithPackages (ps: [ps.primitive])&quot;
...</code></pre>
<p>Success!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Thanks to Csongor Kiss, Alessio Zakaria, Sarah Brofeldt and Vaibhav Sagar for comments on a draft.</p>
<h2 id="related-links">Related Links</h2>
<hr />
<h1 id="appendix">Appendix</h1>
<h2 id="addendum-what-do-i-do-if-a-patch-from-head.hackage-doesnt-apply">Addendum: What do I do if a patch from <code>head.hackage</code> doesn’t apply?</h2>
<p>There are some situations where patches from <code>head.hackage</code> fail to apply properly. The usual cause is that patches in the <code>head.hackage</code> repo apply to unmodified tarballs but the nix build process tries to apply patches after patching the cabal file to take into account package revisions.</p>
<p>The workaround for this is to just create a new nix-specific patch in your local directory. :)</p>
<h2 id="addendum-how-do-i-make-a-patch-to-contribute-to-head.hackage">Addendum: How do I make a patch to contribute to <code>head.hackage</code>?</h2>
<pre><code>cabal get haskell-src-exts-1.20.1 &lt;--pristine&gt;
cd haskell-src-exts-1.20.1
git init
git add .
&lt;Make the simple change&gt;
git diff &gt; &lt;patchDir&gt;/haskell-src-exts-1.20.1.patch</code></pre>
<p>Use the <code>--pristine</code> flag if you intend to contribute the patch upstream! This will fetch the package without applying cabal file revisions.</p>
<h2 id="addendum-how-does-overrides.nix-work">Addendum: How does <code>overrides.nix</code> work?</h2>
<p><code>overrides.nix</code> is a simple derivation which packages a single haskell script. The haskell script scans a directory and generates the correct overrides for the given patches. The wrapper script then stores the overrides and copies the patch files into the nix store.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">{</span> <span class="ex">stdenv</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  , <span class="ex">haskell</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  , <span class="ex">patches</span>  # A directory containing patch files used to build packages</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">             <span class="co"># it can either be a local directory or fetched from the web</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">}</span>:</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="bu">let</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  <span class="ex">ghc</span> = haskell.packages.ghc822.ghcWithPackages (ps: with ps<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">          [ ]);</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="kw">in</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="ex">stdenv.mkDerivation</span> {</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  <span class="ex">name</span> = <span class="st">&quot;hs-generate-overrides-0.1&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">  <span class="ex">src</span> = ./generate-nix-overrides.hs<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">  <span class="ex">preUnpack</span> = <span class="st">&#39;&#39;</span>mkdir hs-generate-overrides<span class="st">&#39;&#39;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  <span class="ex">buildInputs</span> = [ ghc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20">  <span class="ex">unpackCmd</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">    <span class="fu">cp</span> <span class="va">$curSrc</span> ./hs-generate-overrides</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">    <span class="fu">cp</span> -r <span class="va">${patches}</span> ./hs-generate-overrides/patches</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    <span class="va">sourceRoot=</span>hs-generate-overrides;</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-25" data-line-number="25"></a>
<a class="sourceLine" id="cb12-26" data-line-number="26">  <span class="ex">buildPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">    <span class="ex">ghc</span> <span class="va">$src</span> -o generate</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">    <span class="ex">./generate</span> <span class="va">$script</span>/patches patches <span class="op">&gt;</span> patches.nix</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">  <span class="ex">outputs</span> = [<span class="st">&quot;out&quot;</span> <span class="st">&quot;script&quot;</span>]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32"></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">  <span class="ex">installPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34">    <span class="fu">cp</span> patches.nix <span class="va">$out</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35">    <span class="ex">ensureDir</span> <span class="va">$script</span>/patches</a>
<a class="sourceLine" id="cb12-36" data-line-number="36">    <span class="fu">cp</span> -r patches <span class="va">$script</span>/patches</a>
<a class="sourceLine" id="cb12-37" data-line-number="37">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-38" data-line-number="38"></a>
<a class="sourceLine" id="cb12-39" data-line-number="39">}</a></code></pre></div>
<h2 id="addendum-how-is-jailbreaking-different-to-cabals---allow-newer">Addendum: How is jailbreaking different to cabal’s <code>--allow-newer</code>?</h2>
<p>The goal of jailbreaking and <code>--allow-newer</code> are the same, to remove restrictive bounds on packages.</p>
<p>Jailbreaking achieves this by parsing and rewriting the cabal file to remove nearly all bounds. This fits better into the nix ecosystem where there is exactly one version of each package anyway so additional version bounds are irrelevant.</p>
<p><code>--allow-newer</code> influences the solver in order to pick a package set as if the package didn’t have any upper bounds.</p>
<h2 id="addendum-why-are-you-using-extend-rather-than-override.">Addendum: Why are you using <code>extend</code> rather than <code>override</code>.</h2>
<p><code>override</code> is a general nix mechanism to override arguments to a function. In the haskell package set case, one of the arguments to the package set is called <code>overrides</code>, which is a function explaining how we want to modify the package set further.</p>
<p>However, there is one big downside to using this mechanism, it is not possible to repeatedly override the package set with more and more extensions as each time you call <code>override</code> you <em>replace</em> the argument.</p>
<p>For more explanation of the difference see <a href="https://github.com/NixOS/nixpkgs/issues/25887">this issue</a> on the nixpkgs issue tracker.</p>
<h2 id="addendum-what-to-do-if-callhackage-doesnt-find-the-latest-version-of-a-package">Addendum: What to do if <code>callHackage</code> doesn’t find the latest version of a package</h2>
<p>If <code>callHackage</code> doesn’t find a package which you know is on hackage then it is because the <code>all-cabal-hashes</code> attribute is too old. In order to override it, you can simply add a new line to your overlay with an updated copy.</p>
<p>For example, this version is from <code>2018-01-05</code>:</p>
<pre><code>all-cabal-hashes = super.fetchurl {
  url    = &quot;https://github.com/commercialhaskell/all-cabal-hashes/archive/e1089e56e666c2a0fe82f840d3cc7f49b9c9fe9b.tar.gz&quot;;
  sha256 = &quot;0qbzdngm4q8cmwydnrg7jvipw39nb1mjxw95vw6f789874002kn1&quot;;
};</code></pre>
<h2 id="addendum-how-to-update-the-ghchead-derivation">Addendum: How to update the ghcHEAD derivation</h2>
<p>If you want to use a more recent version of HEAD then you have to update the ghcHEAD derivation. It can be found at <code>development/compilers/ghc/head.nix</code>.</p>
<p>You then need to modify three things.</p>
<ol type="1">
<li>Correct the version of the compiler by modifying the <code>version</code> argument.</li>
<li>Set <code>rev</code> to the git commit identifier of the revision you want to build.</li>
<li><p>Correct the <code>sha256</code> attribute by running <code>nix-prefetch-git</code> and copying the resulting hash.</p>
<pre><code>nix-shell -p nix-prefetch-git
 --run &quot;nix-prefetch-git --fetch-submodules git://git.haskell.org/ghc.git &lt;rev&gt;&quot;</code></pre></li>
</ol>
]]></summary>
</entry>
<entry>
    <title>INLIN(E)ing: A case study</title>
    <link href="http://mpickering.github.io/posts/2017-05-17-inlining-case-study.html" />
    <id>http://mpickering.github.io/posts/2017-05-17-inlining-case-study.html</id>
    <published>2017-05-17T00:00:00Z</published>
    <updated>2017-05-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> INLIN(E)ing: A case study </h2>
<div class="info">
    Posted on May 17, 2017
    
</div>

<p>Ollie Charles recently popped into #ghc to ask about a small program which was taking a long time to compile. In fact, the compiler was taking so long in the simplifier he had to increase the tick factor (a measure of how much work the simplifier is allowed to do) to get compilation to finish. Oleg and I quickly set to work working out what was going on in his program.</p>
<p>It turned out that a misplaced <code>INLINE</code> pragma was causing a lot of simplification work to be duplicated. Removing the pragma allowed the compiler to operate faster whilst producing the same code.</p>
<!--more-->
<h1 id="the-problem">The Problem</h1>
<p>When a lot of time is spent in the simplifier it is usually because the core programs have grown quite large. Core programs can grow large for a number of reasons but one of primary reasons is due to excessive inlining caused by <code>INLINE</code> pragmas.</p>
<p>The first tool we have at our disposal is <code>-ddump-simpl-stats</code> which outputs a summary of each step the simplifier takes. Looking at this summary is a good way to work out roughly where the problem lies.</p>
<p>In this case, the statistics file was quite <a href="https://gist.github.com/ocharles/8d69c518b5d3169e8254b24205e03f65">large</a>. The first bit I always check is the “UnfoldingDone” section which details how many times each definition has been inlined. Here is the relevant snippet from the top of that section.</p>
<pre><code>  14620 UnfoldingDone
    596 $
    574 contramapF
    546 $fNumInt_$c+
    485 $fStorableWord8_$cpoke
    485 castPtr
    485 $fStorableWord8_$calignment
    485 word8
    485 $s&gt;$&lt;
    485 castPtr1
    484 thenIO
    484 thenIO1
    484 ord
    484 $fBitsInt_$c.&amp;.
    484 plusPtr
    484 $fStorableWord19
    463 char7
    331 $s&gt;*&lt;1
    331 pairF
    220 returnIO
    220 returnIO1
    220 $s&gt;$&lt;
    220 contramapB</code></pre>
<p>The first thing to notice about these numbers is that there are groups of definitions which have all been inlined the same number of times. This is indicative of a misplaced <code>INLINE</code> pragma as a large unoptimised definition will then be inlined many times and then simplified individually at each call site rather than once at the definition site. Of particular suspicion is the large block of definitions which are each inlined exactly 484 times.</p>
<p>By looking at the definitions of each of the identifiers in this list, we can then work out what is going on. To cut to the chase, inspecting the definition of <code>char7</code> from the <code>Data.ByteString.Builder.Prim.ASCII</code> module we can see where a lot of the work is coming from.</p>
<pre><code>-- | Encode the least 7-bits of a &#39;Char&#39; using the ASCII encoding.
{-# INLINE char7 #-}
char7 :: FixedPrim Char
char7 = (\c -&gt; fromIntegral $ ord c .&amp;. 0x7f) &gt;$&lt; word8</code></pre>
<p>The definition of <code>char7</code> is concise but composed of combinators which will be keen to get inlined later on. The definitions of <code>ord</code>, <code>.&amp;.</code> and <code>&gt;$&lt;</code> are all small.</p>
<p>By using an <code>INLINE</code> pragma, the unoptimised unfolding is included in the interface file so this complex definition will be inline verbatim into each call site. We can inspect the unfolding by using the <code>--show-iface</code> flag on the <code>.hi</code> file for the module.</p>
<pre><code>8334ad079da5b638008c6f8feefdfa4a
   char7 :: FixedPrim Char
   {- HasNoCafRefs, Strictness: m, Inline: INLINE (sat-args=0),
      Unfolding: InlineRule (0, False, False)
                 ($s&gt;$&lt;
                    @ Char
                    @ Word8
                    (\ (c :: Char) -&gt;
                     $ @ &#39;PtrRepLifted
                       @ Int
                       @ Word8
                       (\ (x :: Int) -&gt;
                        case x of wild { I# x# -&gt; W8# (narrow8Word# (int2Word# x#)) })
                       ($fBitsInt_$c.&amp;. (ord c) (I# 127#)))
                   word8) -}</code></pre>
<p>Which very closely resembles the source definition.</p>
<p>Removing the <code>INLINE</code> pragma we get a nice, small optimised definition which crucially is still small enough that GHC inlines it at call sites.</p>
<pre><code>5e7820a4ab4b18cf2032517105d2cc56
  char7 :: FixedPrim Char
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (FP
                   @ Char
                   1#
                   char1
                     `cast`
                   (&lt;Char&gt;_R -&gt;_R &lt;Ptr Word8&gt;_R -&gt;_R Sym (N:IO[0] &lt;()&gt;_R)))      -}</code></pre>
<p>Look! No calls to <code>&gt;$&lt;</code>, <code>.&amp;.</code>, <code>ord</code> or any other complicated functions. We have optimised the definition <em>once</em> at the definition site so that we don’t have to repeatedly do so at each call site. We didn’t even need to look at the program to spot the problem.</p>
<h1 id="discussion">Discussion</h1>
<p>This is currently a problem because <code>INLINE</code> is used for two different reasons.</p>
<ol type="1">
<li>By library authors who use <code>RULES</code> where it is important to inline the literal rhs of a definition so that the rules reliably fire.</li>
<li>By library authors who want to inline definitions so that GHC’s simplifier can work better across modules.</li>
</ol>
<p>For the first case, the unoptimised unfoldings are important but for the second this leads to a lot of duplicated work. In this case, I could see that there were no rules defined which were relevant to the definition of <code>char7</code> so I ruled out the first scenario. I then verified that GHC considered the optimised version of <code>char7</code> small enough to include in interface files and inline by using <code>--show-iface</code>. Ruling out both of these possibilities, it then seemed sensible to remove the pragma.</p>
<p>It would be good to add a new pragma which instructs GHC to inline an <em>optimised</em> unfolding across modules rather than the unoptimised version so that the second scenario can be reliably achieved.</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/6bojlj/inlineing_a_case_study/">Reddit Comments</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Indexed Optics</title>
    <link href="http://mpickering.github.io/posts/2017-04-10-indexed-optics.html" />
    <id>http://mpickering.github.io/posts/2017-04-10-indexed-optics.html</id>
    <published>2017-04-10T00:00:00Z</published>
    <updated>2017-04-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Indexed Optics </h2>
<div class="info">
    Posted on April 10, 2017
    
</div>

<p>What is an indexed optic? It is an optic which gives you access to an index whilst performing updates.</p>
<p>It is a simple clear generalisation of a lens but the implementation looks quite complicated. This is due to the desire to reuse the same combinators for both non-indexed and indexed variants. We we will start by explaining a simplified implementation of indexed optics before the technique used in order to reuse the same combinators as ordinary optics.</p>
<!--more-->
<h1 id="simple-implementation">Simple Implementation</h1>
<p>As a first approximation, we will augment the updating function with an additional index which we will then subsequently refine.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">PrimitiveIndexedTraversal</span> i s t a b</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="fu">=</span> forall f <span class="fu">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f t)</a></code></pre></div>
<p>Implementing optics by hand gives a good intuition for the types involved.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">pair ::</span> <span class="dt">PrimitiveIndexedTraversal</span> <span class="dt">Int</span> (a, a) (b, b) a b</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">pair iafb (a0, a1) <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> iafb <span class="dv">0</span> a0 <span class="fu">&lt;*&gt;</span> iafb <span class="dv">1</span> a1</a></code></pre></div>
<p>The implementation is exactly the same as a normal traversals apart from we also pass an index to each call of the worker function. Note that we have a lot of choice about which indices we choose. We could have indexed each field with a boolean or in the opposite order. For lists, we need to use a helper function which passes an index to each recursive call.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">list ::</span> <span class="dt">PrimitiveIndexedTraversal</span> <span class="dt">Int</span> [a] [b] a b</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">list iafb xs <span class="fu">=</span> go xs <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    go [] _ <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    go (x<span class="fu">:</span>xs) n <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> iafb n x <span class="fu">&lt;*&gt;</span> go xs (n<span class="fu">+</span><span class="dv">1</span>)</a></code></pre></div>
<p>There are all the usual combinators to work with indexed traversals as normal traversals but one of the most useful ones to see what is going on is <code>itoListOf</code> which converts an indexed traversal into a list of index-value pairs.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">itoListOf ::</span> ((i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Const</span> [(i, a)] b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (<span class="dt">Const</span> [(i, a)] t))</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">          <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [(i, a)]</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">itoListOf t s <span class="fu">=</span> getConst <span class="fu">$</span> t (\i a <span class="ot">-&gt;</span> <span class="dt">Const</span> [(i, a)]) s</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;</span> itoListOf pair (<span class="dt">True</span>, <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[(<span class="dv">0</span>, <span class="dt">True</span>), (<span class="dv">1</span>, <span class="dt">False</span>)]</a></code></pre></div>
<p>We monomorphise the argument so that we we don’t have to use a variant of <code>cloneTraversal</code> in order to work around impredicative types.</p>
<p>We can also turn an ordinary traversal into an indexed traversal by labelling each element with the order in which we traverse it. In order to do so we need to define an applicative functor which when traversed with will perform the labelling ultimately returning an indexed traversal.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Indexing</span> f s <span class="fu">=</span> <span class="dt">Indexing</span> {<span class="ot"> runIndexing ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, f s))}</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Indexing</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  fmap f (<span class="dt">Indexing</span> fn) <span class="fu">=</span> <span class="dt">Indexing</span> (over (_2 <span class="fu">.</span> mapped) f <span class="fu">.</span> fn)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Indexing</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  pure x <span class="fu">=</span> <span class="dt">Indexing</span> (\i <span class="ot">-&gt;</span> (i, pure x))</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  (<span class="dt">Indexing</span> fab) <span class="fu">&lt;*&gt;</span> (<span class="dt">Indexing</span> fa)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Indexing</span> (\i <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">        <span class="kw">let</span> (i&#39;, ab) <span class="fu">=</span> fab i</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">            (i&#39;&#39;, a) <span class="fu">=</span> fa i&#39;</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="kw">in</span> (i&#39;&#39;, ab <span class="fu">&lt;*&gt;</span> a))</a></code></pre></div>
<p>Then traversing with this applicative functor supplies the index to each function call which we can pass to our indexed updating function.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">indexing ::</span> <span class="dt">Traversal</span> s t a b <span class="ot">-&gt;</span> <span class="dt">PrimitiveIndexedTraversal</span> <span class="dt">Int</span> s t a b</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">indexing t p s <span class="fu">=</span> snd <span class="fu">$</span> runIndexing</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  (t (\a <span class="ot">-&gt;</span> <span class="dt">Indexing</span> (\i <span class="ot">-&gt;</span> (i <span class="fu">+</span> <span class="dv">1</span>, p i a) )) s) <span class="dv">0</span></a></code></pre></div>
<p>A common pattern is to use <code>indexing</code> and <code>traverse</code> together to create indexed traversals for <code>Traversable</code> functors. It is so common that it is given a special name <code>traversed</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">traversed ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">PrimitiveIndexedTraversal</span> (t a) (t b) a b</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">traversed <span class="fu">=</span> indexing traverse</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="fu">&gt;</span> itoListOf traversed (<span class="dt">Just</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">[(<span class="dv">0</span>, <span class="dv">5</span>)]</a></code></pre></div>
<p>However, there are two problems with this representation.</p>
<ol type="1">
<li>Indexed optics do not compose with ordinary optics.</li>
<li>We need a different composition operator other than (<code>.</code>) in order to compose indexed optics together.</li>
</ol>
<h1 id="composing-indexed-and-ordinary-optics">Composing indexed and ordinary optics</h1>
<p>Considering the first problem, in order to compose an indexed optic with an ordinary optic using function composition we would need to be able to unify <code>i -&gt; a -&gt; b</code> with <code>s -&gt; t</code>.</p>
<p>Given an ordinary optic <code>op</code> and an indexed optic <code>iop</code> with the following types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">op <span class="fu">:</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f t)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">iop <span class="fu">:</span> (i <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> f d) <span class="ot">-&gt;</span> (u <span class="ot">-&gt;</span> f v)</a></code></pre></div>
<p><code>op . iop</code> is the only composition which type checks. It yields an indexed traversal which keeps track of the index of the inner component.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">&gt;</span> itoListOf (traverse <span class="fu">.</span> list) (<span class="dt">True</span>, [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">[(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>)]</a></code></pre></div>
<p>However, composition the other way around doesn’t work and further with this representation indexed optics do not compose together with <code>.</code>. In order to compose indexed optics together with <code>.</code> we need to be able to unify the argument and result type of the lens together. In order to do this, we abstract away from the the indexed argument of the updating function for any <code>Indexable</code> profunctor.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Indexable</span> i p <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">  index ::</span> p a b <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>Using this class, the type for indexed traversals becomes:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> <span class="dt">IndexedTraversal</span> i s t a b <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  forall f p <span class="fu">.</span> (<span class="dt">Applicative</span> f, <span class="dt">Indexable</span> i p) <span class="ot">=&gt;</span> p a (f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</a></code></pre></div>
<p>There are instances for the newtype wrapped indexed functions which we were using before</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Indexed</span> i a b <span class="fu">=</span> <span class="dt">Indexed</span> {<span class="ot"> runIndexed ::</span> i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="kw">instance</span> (<span class="dt">Indexable</span> i (<span class="dt">Indexed</span> i)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  index (<span class="dt">Indexed</span> p) <span class="fu">=</span> p</a></code></pre></div>
<p>but also for <code>(-&gt;)</code> which ignores the index. This means that we can seamlessly use optics with or without the index by instantiating <code>p</code> with either <code>Indexed</code> or <code>-&gt;</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Indexable</span> i (<span class="ot">-&gt;</span>)) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  index f _ <span class="fu">=</span> f</a></code></pre></div>
<p>Now <code>op . iop</code> yields an indexed traversal, <code>iop . op</code> forces us to instantiate <code>p = (-&gt;)</code> and so yields a traversal which has forgotten the index. Perhaps most surprisingly, the composition <code>iop . iop</code> type-checks as well, but again we loose information as we are forced to instantiate <code>p = (-&gt;)</code> and thus forget about the indexing of the outer traversal.</p>
<p>This is a double edged sword. Composing using <code>.</code> leads to more code reuse as the same combinators can be used for both indexed and non-indexed optics. On the other hand, composing indexed optics using <code>.</code> is nearly always the wrong thing if you care about the indices.</p>
<h1 id="a-different-composition-operator">A different composition operator</h1>
<p>Composing together indexed optics with the normal lens composition operator <code>.</code> leads to unexpected results as the indices are not combined appropriately. The index of the inner-most optic of the composition is preserved whilst the outer indexing is thrown away. It would be more desirable to combine the indices together in order to retain as much information as possible.</p>
<p>To that end we define <code>&lt;.&gt;</code> which can compose indexed optics together whilst suitably combining their indices.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">(&lt;.&gt;) ::</span> <span class="dt">Indexable</span> (i, j) p</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">      <span class="ot">=&gt;</span> (<span class="dt">Indexed</span> i s t <span class="ot">-&gt;</span> r)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">      <span class="ot">-&gt;</span> (<span class="dt">Indexed</span> j a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">      <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">(istr <span class="fu">&lt;.&gt;</span> jabst) p</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  <span class="fu">=</span> istr (<span class="dt">Indexed</span> (\i s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">      jabst (<span class="dt">Indexed</span> (\j a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">        indexed p (i, j) a)) s))</a></code></pre></div>
<p>The definition monomorphises the argument again in order to avoid inpredicativity problems.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">&gt;</span> itoListOf (list <span class="fu">&lt;.&gt;</span> pair) [(<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>)]</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">[((<span class="dv">0</span>,<span class="dv">0</span>),<span class="dv">1</span>),((<span class="dv">0</span>,<span class="dv">1</span>),<span class="dv">2</span>),((<span class="dv">1</span>,<span class="dv">0</span>),<span class="dv">2</span>),((<span class="dv">1</span>,<span class="dv">1</span>),<span class="dv">3</span>)]</a></code></pre></div>
<p>Generalisations are possible which combine indices in other ways but this simple combination function highlights the essence of the approach.</p>
<h1 id="what-are-indexed-optics-useful-for">What are indexed optics useful for?</h1>
<p>Now that is a question which I will have to defer to reddit comments. I couldn’t find many libraries which were using the indexing in interesting ways.</p>
]]></summary>
</entry>
<entry>
    <title>Inlining and Specialisation</title>
    <link href="http://mpickering.github.io/posts/2017-03-20-inlining-and-specialisation.html" />
    <id>http://mpickering.github.io/posts/2017-03-20-inlining-and-specialisation.html</id>
    <published>2017-03-20T00:00:00Z</published>
    <updated>2017-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Inlining and Specialisation </h2>
<div class="info">
    Posted on March 20, 2017
    
</div>

<p>The inliner and specialiser are the two parts of the optimiser which are crucial to writing performant functional programs. They ensure that we can write programs at a high-level of abstraction which are simplified when eventually used with concrete arguments.</p>
<p>The inliner’s job is to replace a function with its definition. This removes one layer of indirection and most importantly allows other optimisations to fire. The specialiser is important for optimising code which uses type classes. Type classes are desugared into dictionary passing style but the specialiser removes a layer of indirection by creating new functions with the relevant dictionaries already supplied.</p>
<p>This document will explain the basics of these two parts of the optimiser and some user-facing options which can be used to control them.</p>
<!--more-->
<h1 id="what-does-the-inlinable-pragma-do">What does the <code>INLINABLE</code> pragma do?</h1>
<p>Top-level definitions can be marked <code>INLINABLE</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">myComplicatedFunction ::</span> (<span class="dt">Show</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">myComplicatedFunction <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# INLINABLE myComplicatedFunction #-}</span></a></code></pre></div>
<p>This causes exactly two things to happens.</p>
<ol type="1">
<li>The function’s (exact) definition is included in the interface file for the module.</li>
<li>The function will be specialised at use sites – even across modules.</li>
</ol>
<p>Note that GHC is no more keen to inline an <code>INLINABLE</code> function than any other.</p>
<h1 id="what-does-the-inline-pragma-do">What does the <code>INLINE</code> pragma do?</h1>
<p>The <code>INLINE</code> pragma can be applied to top-level definitions. It behaves like the <code>INLINABLE</code> pragma but makes GHC very keen to inline the function.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">mySimpleFunction ::</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">mySimpleFunction <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">{-# INLINE mySimpleFunction #-}</span></a></code></pre></div>
<p>It is a sledgehammer and without care you can make the compiler take a long time and produce a lot of code. Most “ticks exhausted” panics are due to library authors misusing <code>INLINE</code> pragmas.</p>
<p>Liberally sprinkling all your definitions with <code>INLINE</code> is likely make the compiler take a very long time to compile your program. It is not beneficial to inline every function, inlining a function which is not optimised further only increases overall code size without improving performance.</p>
<p>One situation where it is useful to use an <code>INLINE</code> pragma is when the definition of the function contains functions which are mentioned in <code>RULES</code>. In this case, it is essential that the optimiser is quite aggressive so that the <code>RULES</code> can fire.</p>
<h1 id="optimised-vs-unoptimised-unfoldings">Optimised vs unoptimised unfoldings</h1>
<p>GHC will decide to include some small unfoldings in interface files. When it does this, it first optimises the definitions so that they are not repeatedly optimised at each use site after being inlined. Unfoldings included by <code>INLINE</code> or <code>INLINABLE</code> are unoptimised so that they interact better with <code>RULES</code>.</p>
<h1 id="what-is-an-interface-file">What is an interface file?</h1>
<p>An interface file stores all information about a module which is needed by other modules.</p>
<p>The key to cross-module inlining and specialisation is making sure that we have the definitions of functions we want to inline at hand. Information is only passed between modules by interface files, therefore we must include the unfoldings of definitions in interface files if we want to inline them across modules.</p>
<p>The extension for interface files is <code>.hi</code>, you can see what’s in an interface file by using the <code>--show-iface</code> flag.</p>
<h1 id="what-is-an-unfolding">What is an unfolding?</h1>
<p>The <em>unfolding</em> of a function <code>f</code> is what <code>f</code> is replaced by when it is inlined. This is usually the definition of <code>f</code>.</p>
<h1 id="when-are-unfoldings-included-in-interface-files">When are unfoldings included in interface files?</h1>
<p>Not all definitions are included in interface files by default, doing so might create quite large files. There’s no point including an unfolding of very large definitions which we will never inline in other modules.</p>
<p>Unfoldings end up in interface files in three ways:</p>
<ol type="1">
<li>GHC decides to include unfoldings of small functions by default which it knows it will inline later.</li>
<li>Functions marked as <code>INLINE</code> or <code>INLINABLE</code> are included in interface files.</li>
<li>Compiler flags such as <code>-fexpose-all-unfoldings</code> include all unfoldings of all definitions in a module unless they are marked as <code>NOINLINE</code>.</li>
</ol>
<h1 id="what-is-specialisation">What is specialisation?</h1>
<p>Specialisation is the process of removing typeclass dictionary arguments by creating a new type-specialised definition for an overloaded function. Once specialised, dictionary methods can be easily inlined which usually creates more efficient code.</p>
<p>For example, if we define the overloaded function <code>foo</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">foo ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">foo x y <span class="fu">=</span> show x <span class="fu">==</span> show y</a></code></pre></div>
<p>the following core definition will be produced:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foo <span class="fu">=</span> \ <span class="fu">@</span>a <span class="fu">$</span>dShow x y <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    eqString (show <span class="fu">$</span>dShow x) (show <span class="fu">$</span>dShow y)</a></code></pre></div>
<p>There are now 4 parameters to <code>foo</code>, the first argument is a type (denoted by <code>@</code>), the second argument is the dictionary for <code>Show</code> (denoted by the <code>$d</code> prefix) and the last two are the arguments <code>x</code> and <code>y</code> of the original definition.</p>
<p>The class constraint is translated into a dictionary. Each time a class method is used, we must dynamically lookup which definition to use in the supplied class dictionary.</p>
<p>If we know which type <code>a</code> is instantiated with, we can specialise the definition of <code>foo</code> and produce much better code.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">qux ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">qux <span class="fu">=</span> foo <span class="fu">@</span><span class="dt">Bool</span></a></code></pre></div>
<p>Using <code>foo</code> at a specific type produces a new definition <code>foo_$sfoo</code> which is defined as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">foo_<span class="fu">$</span><span class="ot">sfoo ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">foo_<span class="fu">$</span>sfoo <span class="fu">=</span> foo <span class="fu">@</span><span class="dt">Bool</span> <span class="fu">$</span>fShowBool</a></code></pre></div>
<p>Further optimisations then inline <code>foo</code> and then the dictionary selector <code>show</code> which produces the following more direct program.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">foo_<span class="fu">$</span>sfoo <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  \ x y <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">case</span> x <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">      <span class="dt">False</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="kw">case</span> y <span class="kw">of</span> {</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">          <span class="dt">False</span> <span class="ot">-&gt;</span> foo4;</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">          <span class="dt">True</span> <span class="ot">-&gt;</span> foo3</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        };</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">      <span class="dt">True</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">        <span class="kw">case</span> y <span class="kw">of</span> _ {</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">          <span class="dt">False</span> <span class="ot">-&gt;</span> foo2;</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">          <span class="dt">True</span> <span class="ot">-&gt;</span> foo1</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">        }</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    }</a></code></pre></div>
<h2 id="when-does-specialisation-occur">When does specialisation occur?</h2>
<p>Specialisation occurs when an overloaded function is called at a specific type. The specialised definition is placed in the module where the call happens but also exported so that it can be reused if there is another upstream call-site where specialisation would take place.</p>
<p>By default, functions are not specialised across modules.</p>
<p>There are two ways to make functions specialise across modules:</p>
<ol type="1">
<li>Marking a function as <code>INLINABLE</code> or <code>INLINE</code>.</li>
<li>Using the flag <code>-fspecialise-aggressively</code> when compiling the client module. An unfolding must still be available to perform specialisation.</li>
</ol>
<p>Further to this, observe that for specialisation to occur across modules, the unfolding must be made available in interface files.</p>
<p>Notice this subtle point, the <code>INLINABLE</code> pragma guarantees the precise conditions for a function to be specialised across modules.</p>
<h1 id="how-do-i-use-the-specialise-pragma">How do I use the <code>SPECIALISE</code> pragma?</h1>
<p>The <code>SPECIALISE</code> pragma is used to create a specialised copy of an overloaded function even if it is not used with that type in the module.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">class</span> <span class="dt">C</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">foo ::</span> <span class="dt">C</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">{-# SPECIALISE foo :: Text -&gt; Text #-}</span></a></code></pre></div>
<p>This example will create a new function, <code>foo_$sfoo :: Text -&gt; Text</code> which will be used whenever <code>foo</code> is applied to a <code>Text</code> value even in modules which import <code>A</code>.</p>
<p>This is useful to prevent GHC creating many copies of the same specialised function if you have a very flat module structure.</p>
<h1 id="what-is-a-loop-breaker">What is a loop-breaker?</h1>
<p>In general, if we were to inline recursive definitions without care we could easily cause the simplifier to diverge. However, we still want to inline as many functions which appear in mutually recursive blocks as possible. GHC statically analyses each recursive groups of bindings and chooses one of them as the <em>loop-breaker</em>. Any function which is marked as a loop-breaker will never be inlined. Other functions in the recursive group are free to be inlined as eventually a loop-breaker will be reached and the inliner will stop.</p>
<p>Note: Do not apply <code>INLINE</code> pragmas to loop-breakers, GHC will never inline a loop breaker regardless of which pragma you attach. In fact, with a debugging compiler, core lint will warn about using an <code>INLINE</code> pragma on a loopbreaker.</p>
<p>Loop-breakers are discussed in detail in section 4 of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf">Secrets of the Glasgow Haskell Compiler inliner</a>.</p>
<h1 id="how-does-ghc-choose-a-loop-breaker">How does GHC choose a loop-breaker?</h1>
<p>GHC uses a heuristic to decide which definitions it would be least beneficial to inline and to choose those as loop breakers. For example, it is very beneficial to inline simple expressions and dictionary selector functions so they are given high scores. Discounts are also available if an unfolding is available thus marking a definition as <code>INLINABLE</code> or <code>INLINE</code> will usually cause GHC to not choose it.</p>
<h1 id="which-flags-can-i-use-to-control-the-simplifier-and-inliner">Which flags can I use to control the simplifier and inliner?</h1>
<p><code>-fspecialise-aggressively</code> removes the restrictions about which functions are specialisable. Any overloaded function will be specialised with this flag. This can potentially create lots of additional code.</p>
<p><code>-fexpose-all-unfoldings</code> will include the (optimised) unfoldings of all functions in interface files so that they can be inlined and specialised across modules.</p>
<p>Using these two flags in conjunction will have nearly the same effect as marking every definition as <code>INLINABLE</code> apart from the fact that the unfoldings for <code>INLINABLE</code> definitions are <em>not</em> optimised.</p>
<h1 id="will-ghc-ever-inline-recursive-definitions-with-static-arguments">Will GHC ever inline recursive definitions with static arguments?</h1>
<p>Sometimes people ask if GHC is smart enough to unroll a recursive definition when given a static argument. For example, if we could define <code>sum</code> using direct recursion:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">sum<span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sum [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs</a></code></pre></div>
<p>A user might expect <code>sum [1,2,3]</code> to be optimised to 6. However, GHC will not inline <code>sum</code> because it is a self-recursive definition and hence a loop-breaker. The compiler is not smart enough to realise that repeatedly inlining <code>sum</code> will terminate.</p>
<p>However, there is a trick that can be used in order to tell GHC that an argument is truly static. We replace the value argument with a type argument. Then by defining suitable type class instances, we can recurse on the structure of the type as we would on a normal value. This time however, GHC will happily inline each “recursive” call as each call to <code>sum</code> is at a different type.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeApplications #-}</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="ot">{-# LANGUAGE PolyKinds #-}</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="kw">module</span> <span class="dt">Sum</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Integer</span>, (+))</a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Proxy</span> x <span class="fu">=</span> <span class="dt">Proxy</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="kw">class</span> <span class="dt">Sum</span> (<span class="ot">xs ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="ot">  sum ::</span> proxy xs <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">Sum</span> <span class="ch">&#39;[] where</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  sum _ <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="kw">instance</span> (<span class="dt">KnownNat</span> x, <span class="dt">Sum</span> xs) <span class="ot">=&gt;</span> <span class="dt">Sum</span> (x <span class="ch">&#39;: xs) where</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">  <span class="co">--sum :: Proxy (x &#39;: xs) -&gt; Int</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24">  sum _ <span class="fu">=</span> natVal (<span class="dt">Proxy</span> <span class="fu">@</span>x) <span class="fu">+</span> sum (<span class="dt">Proxy</span> <span class="fu">@</span>xs)</a>
<a class="sourceLine" id="cb10-25" data-line-number="25"></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">main <span class="fu">=</span> sum (<span class="dt">Proxy</span> <span class="fu">@</span><span class="ch">&#39;[1,2,3])</span></a></code></pre></div>
<p>Inspecting the core we find that the definition of <code>main</code> is simplified to the constant value <code>6</code>.</p>
<p>Note that this is slightly different to the <a href="http://blog.johantibell.com/2010/09/static-argument-transformation.html">static argument transformation</a> which applies to a multi-parameter recursive functions where one of the arguments is the same for each recursive call. In this case, there are no arguments which remain constant across recursive calls.</p>
<p>This technique is due to Andres Löh.</p>
<h1 id="more-links">More Links</h1>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf">Secrets of the Glasgow Haskell Compiler inliner</a></li>
<li><a href="https://dl.acm.org/authorize?297115">Optimizing Generics Is Easy!</a></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">GHC Users Guide</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/60h7a8/inlining_and_specialisation/?ref=share&amp;ref_source=link">Reddit Thread</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Inlining">GHC Wiki Inlining page</a></li>
</ul>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>Thanks to Reid Barton, Ashok Menon and Csongor Kiss for useful comments on a draft.</p>
]]></summary>
</entry>
<entry>
    <title>Motivating the Foldable Type Class</title>
    <link href="http://mpickering.github.io/posts/2016-09-16-motivating-foldable.html" />
    <id>http://mpickering.github.io/posts/2016-09-16-motivating-foldable.html</id>
    <published>2016-09-16T00:00:00Z</published>
    <updated>2016-09-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Motivating the Foldable Type Class </h2>
<div class="info">
    Posted on September 16, 2016
    
</div>

<p>Something I have never seen articulated is why the <code>Foldable</code> type class exists. It is lawless apart from the free theorems which leads to ad-hoc definitions of its methods. What use is the abstraction if not to enable us to reason more easily about our programs? This post aims to articulate some justification stemming from the universality of folds.</p>
<p>In brief, here is the argument.</p>
<ol type="1">
<li>For inductive data types, the fold is unique defined as a consequence of initiality.</li>
<li>The <code>Foldable</code> type class is a way to exploit this universality without having to define all of our data types as the fixed points of base functors.</li>
<li>The uneasiness comes from this impedence mismatch between points 1 and 2.</li>
</ol>
<!--more-->
<p>To recall, the type class is meant to capture the intuitive notion of a fold. Folds are a way of consuming a data type by summarising values in a uniform manner before combining them together.</p>
<p>We now recall the basics of initial algebra semantics for polynomial data types.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> We can represent all data types as the fixed point of a polynomial functor. In Haskell we can represent the fixed point by the data type <code>Mu</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> {<span class="ot"> out ::</span> (f (<span class="dt">Mu</span> f)) }</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">-- Inital algebra</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">in</span><span class="ot"> ::</span> f (<span class="dt">Mu</span> f) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">in</span> <span class="fu">=</span> <span class="dt">Mu</span></a></code></pre></div>
<p>We then specify data types by first defining a control functor <span class="math inline">\(F\)</span> and then considering the initial <span class="math inline">\(F\)</span>-algebra for the functor. The initial <span class="math inline">\(F\)</span>-algebra is given by <span class="math inline">\((\mu F, in)\)</span>. The injection function <span class="math inline">\(in\)</span> wraps up one level of the recursion. The projection function <code>out</code> strips off one layer of the recursion.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>We can define the type of lists by first specifying a control functor <span class="math inline">\(ListF = 1 + (A \times \_)\)</span> and then defining lists in terms of this base functor and <code>Mu</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">type</span> <span class="dt">ListM</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">ListF</span> a)</a></code></pre></div>
<p>We call types which are definable in this manner <em>inductive</em> types.</p>
<p>We do not usually define data types in this style as programming directly with them is quite cumbersome as one must wrap and unwrap to access the recursive structure.</p>
<p>However, defining data in this manner has some useful properties. The one that we care about is that it is possible to define a generic fold operator for inductive types.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">cata ::</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">cata f <span class="fu">=</span> f <span class="fu">.</span> fmap (cata f) <span class="fu">.</span> out</a></code></pre></div>
<p>What’s more, due to initiality, <code>cata f</code> is the unique function of this type. We have no choice about how we define a fold operator after we have described how to interpret the control functor.</p>
<p>Fleshed out in some more detail, Given a functor <span class="math inline">\(F\)</span>, for any other algebra <span class="math inline">\((B, g : F B \to B)\)</span> there exists a unique map <span class="math inline">\(h\)</span> to this algebra from <span class="math inline">\((\mu F, in)\)</span>. Our definition of <code>cata</code> is precisely the way to construct this unique map.</p>
<h1 id="real-world-haskell">Real-World Haskell</h1>
<p>Languages such as Haskell allow users to define data types in a more ad-hoc fashion by specifying the recursive structure themselves rather than in terms of a base functor.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a></code></pre></div>
<p>It can be easily seen that <code>Mu (ListF a) ~= List a</code> and thus we can exploit the the uniqueness of the fold function and define a canonical fold function specialised to our newly defined data type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p><code>foldr</code> is a specialisation of <code>cata</code> to lists. It is perhaps clearer to see the correspondence if we rewrite the function to explicitly take a list algebra as it’s first argument.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ListAlg</span> a b <span class="fu">=</span> <span class="dt">ListAlg</span> {<span class="ot"> z ::</span> () <span class="ot">-&gt;</span> b ,<span class="ot"> cons ::</span> (a, b) <span class="ot">-&gt;</span> b }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">foldr<span class="ot"> ::</span> <span class="dt">ListAlg</span> a b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>Specifying a function <code>ListF a b -&gt; b</code> is precisely the same as specifying <code>ListAlg a b</code> as it amounts to specifying functions <span class="math inline">\(1 \to b\)</span> and <span class="math inline">\(a \times b \to b\)</span>.</p>
<p>So, for each data type we define we can specialise the <code>cata</code> operator in order to define a canonical fold operator. However, the issue now is that each one of our fold operators has a different type. It would be useful to still be able to provide a consistent interface so that we can still fold any inductive type. The answer to this problem is <code>Foldable</code>.</p>
<p>This highlights the essential tension with the <code>Foldable</code> type class. It exists in order to be able to continue to define a generic fold operation but without the cost of defining our data types in terms of fixed points and base functors.</p>
<h1 id="foldable"><code>Foldable</code></h1>
<p>The method <code>foldr</code> is the only method needed to define an instance of <code>Foldable</code>.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>It turns out that <code>(a -&gt; b -&gt; b)</code> and a single constant <code>b</code> are sufficient for specifying algebras for inductive types. Inductive types are built from polynomial base functors so we can describe an algebra by first matching on the summand and then iteratively applying the combining function to combine each recursive position. If there are no recursive positions, we instead use the zero value <code>z</code>.</p>
<p>Defining the instance for lists is straightforward:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  foldr _ z [] <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f _ (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f xs)</a></code></pre></div>
<p>As another example, we consider writing an instance for binary trees which only contain values in the leaves. It is less obvious then how to implement <code>foldr</code> as the usual fold (<code>foldTree</code> below) has a different type signature.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Branch</span> (<span class="dt">Leaf</span> a) (<span class="dt">Leaf</span> a) <span class="fu">|</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">foldTree ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>We can do so by cleverly instantiating the result type <code>b</code> when performing the recursive calls.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  foldr f z t <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="kw">case</span> t <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">      <span class="dt">Leaf</span> a <span class="ot">-&gt;</span> f a z</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">      <span class="dt">Branch</span> l r <span class="ot">-&gt;</span> foldr (\a c <span class="ot">-&gt;</span> f a <span class="fu">.</span> c) id l</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">                   		(foldr f z r)</a></code></pre></div>
<p>The first recursive call of <code>foldr</code> returns a function of type <code>b -&gt; b</code> which tells us how to combine the next recursive occurence. In this case there are only two recursive positions but this process can be iterated to combine all the recursive holes.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<p>The definition for <code>foldMap</code> usually provides a more intuitive interface for defining instances but it is harder to motivate which is why we prefer <code>foldr</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">foldMapTree ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">foldMapTree f (<span class="dt">Leaf</span> a) <span class="fu">=</span> f a</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">foldMapTree f (<span class="dt">Branch</span> l r) <span class="fu">=</span> foldMapTree f l <span class="fu">&lt;&gt;</span> foldMapTree f r</a></code></pre></div>
<p>However, instances for inductive types defined in this uniform manner are less powerful than folds induced by an <span class="math inline">\(F\)</span>-algebra. The problem comes from the fact that all the recursive holes much be combined in a uniform fashion.</p>
<p>The question I have, is it possible to define <code>middle</code> using the <code>Foldable</code> interface?</p>
<pre><code>data Tree3F a r = Leaf a | Branch r r r

type Tree3 a = Mu (Tree3F a)

middleFold :: Tree3F a a -&gt; a
middleFold (Leaf a) = a
middleFold (Branch _ m _) = m

middle :: Tree3 a -&gt; a
middle = cata middleFold</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>The definition of <code>Foldable</code> is motivated by the well-understood theory of inductive data types. The pragmatics of Haskell lead us to the seemingly quite ad-hoc class definition which has generated much discussion in recent years. The goal of this post was to argue that the class is better founded than people think and to explain some of the reasons that it leads to some uncomfort.</p>
<p>My argument is not about deciding whether an ad-hoc definition is lawful, it is explaining the motivation for the class in a way which also explains the lawlessness. The class definition is a compromise because of the practicalities of Haskell. The only way in which we can know a definition is sensible or not is by inspecting whether the ad-hoc definition agrees with the canonical definition given by <code>cata</code>.</p>
<h1 id="appendix-free-theorems-of-foldr">Appendix: Free Theorems of <code>foldr</code></h1>
<p>There are some free theorems for <code>foldr</code> which is natural in <code>a</code> and <code>b</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>Naturality in <code>b</code> amounts to, for all functions <code>g : b -&gt; c</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">g (foldr f z t) <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f x (g y)) (g z)</a></code></pre></div>
<p>and naturality in <code>a</code> amounts to, for all functions <code>f : c -&gt; a</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">foldr f z <span class="fu">.</span> fmap h <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f (h x) y) z</a></code></pre></div>
<p>These are included for completeness.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>From now on when we say data type, we mean polynomial data type.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Lambek’s lemma tells us that the two functions are each other’s inverse.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p> Notice that we are only able to fold type constructors of kind <code>* -&gt; *</code>, this is an arbritary choice, motivated by the fact that most containers which we wish to fold are polymorphic in one way. (For example, lists and trees).<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p>Note that I didn’t think of this definiton myself but arrived at it purely calculationally from the definition of <code>foldMap</code> and <code>foldr</code>.<a href="#fnref4" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></summary>
</entry>
<entry>
    <title>Why do pattern synonyms not cause type refinement?</title>
    <link href="http://mpickering.github.io/posts/2016-06-18-why-no-refinement.html" />
    <id>http://mpickering.github.io/posts/2016-06-18-why-no-refinement.html</id>
    <published>2016-06-18T00:00:00Z</published>
    <updated>2016-06-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Why do pattern synonyms not cause type refinement? </h2>
<div class="info">
    Posted on June 18, 2016
    
</div>

<p>Pattern synonyms can’t (safely) cause any additional type refinement than their definition dictates. This means that they can’t be used to provide a GADT-like interface when the underlying representation is not a GADT. The purpose of this note is to explain this restriction.</p>
<!--more-->
<p>The defining feature of GADTs is that the constructors can bind dictionaries for constraints.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">CaptureShow</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">CaptureShow</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a</a></code></pre></div>
<p>When the constructor is matched upon, the constraints are <em>provided</em> to the local environment.</p>
<p>When the constraints are equality constraints, this causes type refinement. We learn more about the result type from performing the match.</p>
<p>We can use pattern synonyms to abstract GADTs. The second set of constraints is the set of provided constraints.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">pattern <span class="dt">MyCaptureShow</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">pattern <span class="dt">MyCaptureShow</span> <span class="fu">=</span> <span class="dt">CaptureShow</span></a></code></pre></div>
<p>But, the set of provided constraints must be exactly those constraints which the underlying constructor provides. This is different to <em>required</em> constraints which can be more specific than needed.</p>
<p>Why is this the case? One might expect that if additional constraints were specified then the pattern synonym could bind the needed dictionaries when building and release them when matching. However, <strong>not all values which can be destructed with a pattern synonym must be constructed with a pattern synonym</strong>.</p>
<p>For example, we would be able to specify an unsatisfiable constraint in the provided context.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">pattern <span class="dt">Unsat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (<span class="ch">&#39;True ~ &#39;</span><span class="dt">False</span>) <span class="ot">=&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">pattern <span class="dt">Unsat</span> <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>If we did the same in a GADT it would be impossible to construct such a value, similary here we can’t use <code>Unsat</code> to construct an <code>Int</code> as we will never be able to satisfy the equality constraint. However, if it were possible to define such a pattern synonym we would be able to use it to match on <code>0</code>. Doing so would provide the bogus constraint.</p>
<p>There is a more immediate reason why this will never work. For type class constraints, the dictionaries must be bound when the constructor is used to construct values. If the pattern synonym is not used to construct the value then we can’t conjure it up out of thin air when we need it.</p>
<p>This wasn’t obvious to me, which is why it is now written down. Pattern synonym signatures are surprisingly tricky.</p>
<h1 id="addendum">Addendum</h1>
<p>David Feuer and Edward Yang conspired to show that using <code>unsafeCoerce</code> it was possible to provide additional type equalities. The key to the approach is to use a dummy GADT which is used to actually do the refining. Our more efficient representation is upcasted to this GADT, then by matching on the constructor, we cause refinement. Here is Edward’s code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">module</span> <span class="dt">GhostBuster</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">newtype</span> <span class="dt">Vec</span> a (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="fu">=</span> <span class="dt">Vec</span> {<span class="ot"> unVec ::</span> [a] }</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="co">-- &quot;Almost&quot; Vec GADT, but the inside is a Vec</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="co">-- (so only the top-level is unfolded.)</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17"><span class="kw">data</span> <span class="dt">Vec&#39;</span> a (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    <span class="dt">VNil&#39;</span><span class="ot">  ::</span> <span class="dt">Vec&#39;</span> a <span class="dv">0</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    <span class="dt">VCons&#39;</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec&#39;</span> a (n <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="ot">upVec ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec&#39;</span> a n</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">upVec (<span class="dt">Vec</span> [])     <span class="fu">=</span> unsafeCoerce <span class="dt">VNil&#39;</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">upVec (<span class="dt">Vec</span> (x<span class="fu">:</span>xs)) <span class="fu">=</span> unsafeCoerce (<span class="dt">VCons&#39;</span> x (<span class="dt">Vec</span> xs))</a>
<a class="sourceLine" id="cb4-24" data-line-number="24"></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">pattern <span class="dt">VNil</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dv">0</span>) <span class="ot">=&gt;</span> <span class="dt">Vec</span> a n</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">pattern <span class="dt">VNil</span> <span class="ot">&lt;-</span> (upVec <span class="ot">-&gt;</span> <span class="dt">VNil&#39;</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    <span class="dt">VNil</span> <span class="fu">=</span> <span class="dt">Vec</span> []</a>
<a class="sourceLine" id="cb4-28" data-line-number="28"></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">pattern <span class="dt">VCons</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> ((n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">~</span> n&#39;) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n&#39;</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">pattern <span class="dt">VCons</span> x xs <span class="ot">&lt;-</span> (upVec <span class="ot">-&gt;</span> <span class="dt">VCons&#39;</span> x xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">    <span class="dt">VCons</span> x (<span class="dt">Vec</span> xs) <span class="fu">=</span> <span class="dt">Vec</span> (x <span class="fu">:</span> xs)</a>
<a class="sourceLine" id="cb4-32" data-line-number="32"></a>
<a class="sourceLine" id="cb4-33" data-line-number="33"><span class="ot">headVec ::</span> <span class="dt">Vec</span> a (n <span class="fu">+</span> <span class="dv">1</span>) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb4-34" data-line-number="34">headVec (<span class="dt">VCons</span> x _) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb4-35" data-line-number="35"></a>
<a class="sourceLine" id="cb4-36" data-line-number="36"><span class="ot">mapVec ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> b n</a>
<a class="sourceLine" id="cb4-37" data-line-number="37">mapVec f <span class="dt">VNil</span> <span class="fu">=</span> <span class="dt">VNil</span></a>
<a class="sourceLine" id="cb4-38" data-line-number="38">mapVec f (<span class="dt">VCons</span> x xs) <span class="fu">=</span> <span class="dt">VCons</span> (f x) (mapVec f xs)</a></code></pre></div>
<p>If we were to change the definition of the nil case of <code>mapVec</code> to use <code>VCons</code> instead then it wouldn’t type check.</p>
]]></summary>
</entry>
<entry>
    <title>Pattern Synonyms in GHC 8.0</title>
    <link href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html" />
    <id>http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html</id>
    <published>2015-12-12T00:00:00Z</published>
    <updated>2015-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Pattern Synonyms in GHC 8.0 </h2>
<div class="info">
    Posted on December 12, 2015
    
</div>

<p>There have been four small but significant improvements to pattern synonyms which are going to appear in GHC 8.0.</p>
<p>This work closes up some holes which were left in the implementation of pattern synonyms and should provide library authors with a new and flexible method of abstraction.</p>
<p>More information about pattern synonyms can be found in the <a href="http://mpickering.github.io/users_guide/glasgow_exts.html#pattern-synonyms">GHC 8.0 user guide</a>.</p>
<!--more-->
<h3 id="record-pattern-synonyms">Record Pattern Synonyms</h3>
<p>The biggest update extends pattern synonyms to allow the construction of pattern synonyms which behave like record data constructors.</p>
<p>Since GHC 7.8 you have been able to define prefix and infix pattern synonyms which behave like normal data constructors. With the addition of record pattern synonyms most data constructors can be replicated by pattern synonyms.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>To make this clear, consider the data constructor <code>Just</code>. We can use this constructor in two contexts, in a pattern match or in an expression context to construct a value.</p>
<p>If we defined the pattern synonym <code>MyJust</code>, we can use it in precisely the same contexts as <code>Just</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">pattern <span class="dt">MyJust</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">pattern <span class="dt">MyJust</span> a <span class="fu">=</span> <span class="dt">Just</span> a</a></code></pre></div>
<p>Similarly, record data constructors can be used in seven contexts.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Usage</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>As a constructor</td>
<td><code>zero = Point 0 0</code></td>
</tr>
<tr class="even">
<td>As a constructor with record syntax</td>
<td><code>zero = Point { x = 0, y = 0}</code></td>
</tr>
<tr class="odd">
<td>In a pattern context</td>
<td><code>isZero (Point 0 0) = True</code></td>
</tr>
<tr class="even">
<td>In a pattern context with record syntax</td>
<td><code>isZero (Point { x = 0, y = 0 }</code></td>
</tr>
<tr class="odd">
<td>In a pattern context with field puns</td>
<td><code>getX (Point {x}) = x</code></td>
</tr>
<tr class="even">
<td>In a record update</td>
<td><code>(0, 0) { x = 1 } == (1,0)</code></td>
</tr>
<tr class="odd">
<td>Using record selectors</td>
<td><code>x (0,0) == 0</code></td>
</tr>
</tbody>
</table>
<p>Record pattern synonyms are defined as follows and can also be used in these seven contexts.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">pattern <span class="dt">MyPoint</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">pattern <span class="dt">MyPoint</span>{x, y} <span class="fu">=</span> (x,y)</a></code></pre></div>
<p>Projection functions, <code>x</code> and <code>y</code> are defined like record selectors for ordinary constructors.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">x ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">y ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>Because we defined this pattern synonym, tuples can now be updated with record update syntax.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;</span> (<span class="dv">0</span>,<span class="dv">0</span>) { x <span class="fu">=</span> <span class="dv">5</span> }</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">(<span class="dv">5</span>, <span class="dv">0</span>)</a></code></pre></div>
<h3 id="bundling-pattern-synonyms">Bundling Pattern Synonyms</h3>
<p>Since pattern synonyms are a lot like data constructors, they should be able to be imported just like data constructors. To put it another way a user should be unaware whether they are using a pattern synonym or a data constructor.</p>
<p>However, before GHC 8.0, there has been quite an awkward distinction between the two. Data constructors couldn’t be imported or exported separated from the type which they construct. On the other hand, pattern synonyms could only be imported and exported individually by using the <code>pattern</code> keyword. This meant that consumers had to be aware that whether they were importing a pattern synonym or not! No good!</p>
<p>Now there are two ways which we can export the pattern synonym <code>P :: A</code>.</p>
<ol type="1">
<li>Separately, as before, by using the <code>pattern</code> keyword. <code>haskell  module Foo (pattern P) where</code></li>
<li>Bundled with the relevant type constructor <code>haskell  module Foo ( A(P) ) where</code> or to export all of <code>A</code>’s constructors along with the pattern synonym <code>P</code>. <code>haskell  module Foo ( A(.., P) ) where</code></li>
</ol>
<p>In this second case, if another module imports <code>Foo</code> then <code>P</code> can be imported alongwith <code>A</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- Will import P</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Foo</span> (<span class="dt">A</span> (..))</a></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- Will import P</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Foo</span> (<span class="dt">A</span> (<span class="dt">P</span>))</a></code></pre></div>
<h4 id="an-example-errorcall">An Example: <code>ErrorCall</code></h4>
<p>This problem reared its head in one of the first serious uses of pattern synonyms. In GHC 8 a pattern synonym <code>ErrorCall</code> is introduced into the base library to smooth over changes in the internal representation caused by Eric Seidel’s work on call stacks.</p>
<p>The datatype <code>ErrorCall</code> previously just had one synonymous constructor.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCall</span> <span class="dt">String</span></a></code></pre></div>
<p>After the <a href="https://phabricator.haskell.org/D861">refactoring</a>, the single constructor was renamed to <code>ErrorCallWithLocation</code> but Eric wanted to smooth over the transition by providing a pattern synonym which would behave much like before.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">pattern <span class="dt">ErrorCall</span> s <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> s _ <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">ErrorCall</span> s <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> s <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>However clients importing <code>ErrorCall(..)</code> found that despite the careful efforts of the library author this change broke their code. The problem being that by default, it is necessary to explicitly import pattern synonyms.</p>
<p>With this feature, we can now bundle the new <code>ErrorCall</code> pattern synonym in the export list of the module so that users importing <code>ErrorCall(..)</code> will also import the pattern synonym.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">module</span> <span class="dt">GHC.Exception</span> ( <span class="dt">ErrorCall</span>(<span class="fu">..</span>, <span class="dt">ErrorCall</span>) ) <span class="kw">where</span></a></code></pre></div>
<h3 id="pattern-synonym-signatures">Pattern Synonym Signatures</h3>
<p>Pattern synonyms can also have type signatures. The syntax is very similar to normal type signatures but there are two sets of constraints rather than the usual one which correspond to “required” and “provided” constraints.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> provided <span class="ot">=&gt;</span> <span class="kw">type</span></a></code></pre></div>
<p>In the common case that there are no provided constraints, it is possible to omit the first set of constraints.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> <span class="kw">type</span></a></code></pre></div>
<p>and in the even more common case when there are no constraints, both can be omitted.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">pattern <span class="dt">P</span><span class="ot"> ::</span> <span class="kw">type</span></a></code></pre></div>
<p><em>Required</em> constraints are constraints which are required in order to make a match. For example, we could provide the quite silly pattern synonym which uses <code>show</code> to check whether a pattern should match. As <code>show</code> is from the <code>Show</code> typeclass, we have to add it to the required constraints.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">pattern <span class="dt">IsTrue</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">pattern <span class="dt">IsTrue</span> <span class="ot">&lt;-</span> ((<span class="fu">==</span> <span class="st">&quot;True&quot;</span>) <span class="fu">.</span> show <span class="ot">-&gt;</span> <span class="dt">True</span>)</a></code></pre></div>
<p><em>Provided</em> constraints are constraints which are made available on a successful match. This usually occurs when matching on a GADT with an existential type.</p>
<p>In fact, it only makes sense for provided constraints to mention existentially quantified type variables which explains why they are less often used.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">T</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="dt">MkT</span><span class="ot"> ::</span> (<span class="dt">Show</span> b) <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">pattern <span class="dt">ExNumPat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> b <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">pattern <span class="dt">ExNumPat</span> x <span class="fu">=</span> <span class="dt">MkT</span> x</a></code></pre></div>
<p>Pattern synonym signatures aren’t new for GHC 8.0 but the order of required and provided constraints has been switched.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<h3 id="warnings-for-missing-pattern-synonym-signatures">Warnings for missing pattern synonym signatures</h3>
<p>The final small change is that GHC can also warn about any pattern synonym which doesn’t have a type signature. The warning is turned on by the flag <code>-fwarn-missing-pat-syn-sigs</code> and is also enabled by <code>-Wall</code>.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is one exception which is a datatype which has record constructors which share field names. <code>data A = B { a :: Int } | C { a :: Int, b :: Int }</code><a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>In previous versions, provided constraints appeared before required constraints and if only one set was given then it was assumed to be the provided rather than required constraints.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
]]></summary>
</entry>

</feed>
