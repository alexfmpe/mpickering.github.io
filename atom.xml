<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>mpickering.github.io</title>
    <link href="http://mpickering.github.io/atom.xml" rel="self" />
    <link href="http://mpickering.github.io" />
    <id>http://mpickering.github.io/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2016-09-16T00:00:00Z</updated>
    <entry>
    <title>Motivating the Foldable Type Class</title>
    <link href="http://mpickering.github.io/posts/2016-09-16-motivating-foldable.html" />
    <id>http://mpickering.github.io/posts/2016-09-16-motivating-foldable.html</id>
    <published>2016-09-16T00:00:00Z</published>
    <updated>2016-09-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Motivating the Foldable Type Class </h2>
<div class="info">
    Posted on September 16, 2016
    
</div>

<p>Something I have never seen articulated is why the <code>Foldable</code> type class exists. It is lawless apart from the free theorems which leads to ad-hoc definitions of its methods. What use is the abstraction if not to enable us to reason more easily about our programs? This post aims to articulate some justification stemming from the universality of folds.</p>
<p>In brief, here is the argument.</p>
<ol style="list-style-type: decimal">
<li>For inductive data types, the fold is unique defined as a consequence of initiality.</li>
<li>The <code>Foldable</code> type class is a way to exploit this universality without having to define all of our data types as the fixed points of base functors.</li>
<li>The uneasiness comes from this impedence mismatch between points 1 and 2.</li>
</ol>
<!--more-->
<p>To recall, the type class is meant to capture the intuitive notion of a fold. Folds are a way of consuming a data type by summarising values in a uniform manner before combining them together.</p>
<p>We now recall the basics of initial algebra semantics for polynomial data types.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> We can represent all data types as the fixed point of a polynomial functor. In Haskell we can represent the fixed point by the data type <code>Mu</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> {<span class="ot"> out ::</span> (f (<span class="dt">Mu</span> f)) }

<span class="co">-- Inital algebra</span>
<span class="kw">in</span><span class="ot"> ::</span> f (<span class="dt">Mu</span> f) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f
<span class="kw">in</span> <span class="fu">=</span> <span class="dt">Mu</span></code></pre></div>
<p>We then specify data types by first defining a control functor <span class="math inline">\(F\)</span> and then considering the initial <span class="math inline">\(F\)</span>-algebra for the functor. The initial <span class="math inline">\(F\)</span>-algebra is given by <span class="math inline">\((\mu F, in)\)</span>. The injection function <span class="math inline">\(in\)</span> wraps up one level of the recursion. The projection function <code>out</code> strips off one layer of the recursion.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>We can define the type of lists by first specifying a control functor <span class="math inline">\(ListF = 1 + (A \times \_)\)</span> and then defining lists in terms of this base functor and <code>Mu</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r

<span class="kw">type</span> <span class="dt">ListM</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">ListF</span> a)</code></pre></div>
<p>We call types which are definable in this manner <em>inductive</em> types.</p>
<p>We do not usually define data types in this style as programming directly with them is quite cumbersome as one must wrap and unwrap to access the recursive structure.</p>
<p>However, defining data in this manner has some useful properties. The one that we care about is that it is possible to define a generic fold operator for inductive types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cata ::</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a
cata f <span class="fu">=</span> f <span class="fu">.</span> fmap (cata f) <span class="fu">.</span> out</code></pre></div>
<p>What’s more, due to initiality, <code>cata f</code> is the unique function of this type. We have no choice about how we define a fold operator after we have described how to interpret the control functor.</p>
<p>Fleshed out in some more detail, Given a functor <span class="math inline">\(F\)</span>, for any other algebra <span class="math inline">\((B, g : F B \to B)\)</span> there exists a unique map <span class="math inline">\(h\)</span> to this algebra from <span class="math inline">\((\mu F, in)\)</span>. Our definition of <code>cata</code> is precisely the way to construct this unique map.</p>
<h1 id="real-world-haskell">Real-World Haskell</h1>
<p>Languages such as Haskell allow users to define data types in a more ad-hoc fashion by specifying the recursive structure themselves rather than in terms of a base functor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<p>It can be easily seen that <code>Mu (ListF a) ~= List a</code> and thus we can exploit the the uniqueness of the fold function and define a canonical fold function specialised to our newly defined data type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p><code>foldr</code> is a specialisation of <code>cata</code> to lists. It is perhaps clearer to see the correspondence if we rewrite the function to explicitly take a list algebra as it’s first argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListAlg</span> a b <span class="fu">=</span> <span class="dt">ListAlg</span> {<span class="ot"> z ::</span> () <span class="ot">-&gt;</span> b ,<span class="ot"> cons ::</span> (a, b) <span class="ot">-&gt;</span> b }

foldr<span class="ot"> ::</span> <span class="dt">ListAlg</span> a b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Specifying a function <code>ListF a b -&gt; b</code> is precisely the same as specifying <code>ListAlg a b</code> as it amounts to specifying functions <span class="math inline">\(1 \to b\)</span> and <span class="math inline">\(a \times b \to b\)</span>.</p>
<p>So, for each data type we define we can specialise the <code>cata</code> operator in order to define a canonical fold operator. However, the issue now is that each one of our fold operators has a different type. It would be useful to still be able to provide a consistent interface so that we can still fold any inductive type. The answer to this problem is <code>Foldable</code>.</p>
<p>This highlights the essential tension with the <code>Foldable</code> type class. It exists in order to be able to continue to define a generic fold operation but without the cost of defining our data types in terms of fixed points and base functors.</p>
<h1 id="foldable"><code>Foldable</code></h1>
<p>The method <code>foldr</code> is the only method needed to define an instance of <code>Foldable</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span>
<span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</code></pre></div>
<p>It turns out that <code>(a -&gt; b -&gt; b)</code> and a single constant <code>b</code> are sufficient for specifying algebras for inductive types. Inductive types are built from polynomial base functors so we can describe an algebra by first matching on the summand and then iteratively applying the combining function to combine each recursive position. If there are no recursive positions, we instead use the zero value <code>z</code>.</p>
<p>Defining the instance for lists is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> [] <span class="kw">where</span>
  foldr _ z [] <span class="fu">=</span> z
  foldr f _ (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f xs)</code></pre></div>
<p>As another example, we consider writing an instance for binary trees which only contain values in the leaves. It is less obvious then how to implement <code>foldr</code> as the usual fold (<code>foldTree</code> below) has a different type signature.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Branch</span> (<span class="dt">Leaf</span> a) (<span class="dt">Leaf</span> a) <span class="fu">|</span> <span class="dt">Leaf</span> a

<span class="ot">foldTree ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>We can do so by cleverly instantiating the result type <code>b</code> when performing the recursive calls.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span>
<span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> b
  foldr f z t <span class="fu">=</span>
    <span class="kw">case</span> t <span class="kw">of</span>
      <span class="dt">Leaf</span> a <span class="ot">-&gt;</span> f a z
      <span class="dt">Branch</span> l r <span class="ot">-&gt;</span> foldr (\a c <span class="ot">-&gt;</span> f a <span class="fu">.</span> c) id l
                   		(foldr f z r)</code></pre></div>
<p>The first recursive call of <code>foldr</code> returns a function of type <code>b -&gt; b</code> which tells us how to combine the next recursive occurence. In this case there are only two recursive positions but this process can be iterated to combine all the recursive holes.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>The definition for <code>foldMap</code> usually provides a more intuitive interface for defining instances but it is harder to motivate which is why we prefer <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldMapTree ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> m
foldMapTree f (<span class="dt">Leaf</span> a) <span class="fu">=</span> f a
foldMapTree f (<span class="dt">Branch</span> l r) <span class="fu">=</span> foldMapTree f l <span class="fu">&lt;&gt;</span> foldMapTree f r</code></pre></div>
<p>However, instances for inductive types defined in this uniform manner are less powerful than folds induced by an <span class="math inline">\(F\)</span>-algebra. The problem comes from the fact that all the recursive holes much be combined in a uniform fashion.</p>
<p>The question I have, is it possible to define <code>middle</code> using the <code>Foldable</code> interface?</p>
<pre><code>data Tree3F a r = Leaf a | Branch r r r

type Tree3 a = Mu (Tree3F a)

middleFold :: Tree3F a a -&gt; a
middleFold (Leaf a) = a
middleFold (Branch _ m _) = m

middle :: Tree3 a -&gt; a
middle = cata middleFold</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>The definition of <code>Foldable</code> is motivated by the well-understood theory of inductive data types. The pragmatics of Haskell lead us to the seemingly quite ad-hoc class definition which has generated much discussion in recent years. The goal of this post was to argue that the class is better founded than people think and to explain some of the reasons that it leads to some uncomfort.</p>
<p>My argument is not about deciding whether an ad-hoc definition is lawful, it is explaining the motivation for the class in a way which also explains the lawlessness. The class definition is a compromise because of the practicalities of Haskell. The only way in which we can know a definition is sensible or not is by inspecting whether the ad-hoc definition agrees with the canonical definition given by <code>cata</code>.</p>
<h1 id="appendix-free-theorems-of-foldr">Appendix: Free Theorems of <code>foldr</code></h1>
<p>There are some free theorems for <code>foldr</code> which is natural in <code>a</code> and <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Naturality in <code>b</code> amounts to, for all functions <code>g : b -&gt; c</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">g (foldr f z t) <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f x (g y)) (g z)</code></pre></div>
<p>and naturality in <code>a</code> amounts to, for all functions <code>f : c -&gt; a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f z <span class="fu">.</span> fmap h <span class="fu">=</span> foldr (\x y <span class="ot">-&gt;</span> f (h x) y) z</code></pre></div>
<p>These are included for completeness.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>From now on when we say data type, we mean polynomial data type.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Lambek’s lemma tells us that the two functions are each other’s inverse.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Notice that we are only able to fold type constructors of kind <code>* -&gt; *</code>, this is an arbritary choice, motivated by the fact that most containers which we wish to fold are polymorphic in one way. (For example, lists and trees).<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Note that I didn’t think of this definiton myself but arrived at it purely calculationally from the definition of <code>foldMap</code> and <code>foldr</code>.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Why do pattern synonyms not cause type refinement?</title>
    <link href="http://mpickering.github.io/posts/2016-06-18-why-no-refinement.html" />
    <id>http://mpickering.github.io/posts/2016-06-18-why-no-refinement.html</id>
    <published>2016-06-18T00:00:00Z</published>
    <updated>2016-06-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Why do pattern synonyms not cause type refinement? </h2>
<div class="info">
    Posted on June 18, 2016
    
</div>

<p>Pattern synonyms can’t (safely) cause any additional type refinement than their definition dictates. This means that they can’t be used to provide a GADT-like interface when the underlying representation is not a GADT. The purpose of this note is to explain this restriction.</p>
<!--more-->
<p>The defining feature of GADTs is that the constructors can bind dictionaries for constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CaptureShow</span> a <span class="kw">where</span>
  <span class="dt">CaptureShow</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a</code></pre></div>
<p>When the constructor is matched upon, the constraints are <em>provided</em> to the local environment.</p>
<p>When the constraints are equality constraints, this causes type refinement. We learn more about the result type from performing the match.</p>
<p>We can use pattern synonyms to abstract GADTs. The second set of constraints is the set of provided constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyCaptureShow</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">CaptureShow</span> a
pattern <span class="dt">MyCaptureShow</span> <span class="fu">=</span> <span class="dt">CaptureShow</span></code></pre></div>
<p>But, the set of provided constraints must be exactly those constraints which the underlying constructor provides. This is different to <em>required</em> constraints which can be more specific than needed.</p>
<p>Why is this the case? One might expect that if additional constraints were specified then the pattern synonym could bind the needed dictionaries when building and release them when matching. However, <strong>not all values which can be destructed with a pattern synonym must be constructed with a pattern synonym</strong>.</p>
<p>For example, we would be able to specify an unsatisfiable constraint in the provided context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">Unsat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (<span class="ch">&#39;True ~ &#39;</span><span class="dt">False</span>) <span class="ot">=&gt;</span> <span class="dt">Int</span>
pattern <span class="dt">Unsat</span> <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>If we did the same in a GADT it would be impossible to construct such a value, similary here we can’t use <code>Unsat</code> to construct an <code>Int</code> as we will never be able to satisfy the equality constraint. However, if it were possible to define such a pattern synonym we would be able to use it to match on <code>0</code>. Doing so would provide the bogus constraint.</p>
<p>There is a more immediate reason why this will never work. For type class constraints, the dictionaries must be bound when the constructor is used to construct values. If the pattern synonym is not used to construct the value then we can’t conjure it up out of thin air when we need it.</p>
<p>This wasn’t obvious to me, which is why it is now written down. Pattern synonym signatures are surprisingly tricky.</p>
<h1 id="addendum">Addendum</h1>
<p>David Feuer and Edward Yang conspired to show that using <code>unsafeCoerce</code> it was possible to provide additional type equalities. The key to the approach is to use a dummy GADT which is used to actually do the refining. Our more efficient representation is upcasted to this GADT, then by matching on the constructor, we cause refinement. Here is Edward’s code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PatternSynonyms #-}</span>
<span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="ot">{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span>
<span class="kw">module</span> <span class="dt">GhostBuster</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Unsafe.Coerce</span>

<span class="kw">newtype</span> <span class="dt">Vec</span> a (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="fu">=</span> <span class="dt">Vec</span> {<span class="ot"> unVec ::</span> [a] }

<span class="co">-- &quot;Almost&quot; Vec GADT, but the inside is a Vec</span>
<span class="co">-- (so only the top-level is unfolded.)</span>
<span class="kw">data</span> <span class="dt">Vec&#39;</span> a (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
    <span class="dt">VNil&#39;</span><span class="ot">  ::</span> <span class="dt">Vec&#39;</span> a <span class="dv">0</span>
    <span class="dt">VCons&#39;</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec&#39;</span> a (n <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">upVec ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec&#39;</span> a n
upVec (<span class="dt">Vec</span> [])     <span class="fu">=</span> unsafeCoerce <span class="dt">VNil&#39;</span>
upVec (<span class="dt">Vec</span> (x<span class="fu">:</span>xs)) <span class="fu">=</span> unsafeCoerce (<span class="dt">VCons&#39;</span> x (<span class="dt">Vec</span> xs))

pattern <span class="dt">VNil</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> (n <span class="fu">~</span> <span class="dv">0</span>) <span class="ot">=&gt;</span> <span class="dt">Vec</span> a n
pattern <span class="dt">VNil</span> <span class="ot">&lt;-</span> (upVec <span class="ot">-&gt;</span> <span class="dt">VNil&#39;</span>) <span class="kw">where</span>
    <span class="dt">VNil</span> <span class="fu">=</span> <span class="dt">Vec</span> []

pattern <span class="dt">VCons</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> ((n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">~</span> n&#39;) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n&#39;
pattern <span class="dt">VCons</span> x xs <span class="ot">&lt;-</span> (upVec <span class="ot">-&gt;</span> <span class="dt">VCons&#39;</span> x xs) <span class="kw">where</span>
    <span class="dt">VCons</span> x (<span class="dt">Vec</span> xs) <span class="fu">=</span> <span class="dt">Vec</span> (x <span class="fu">:</span> xs)

<span class="ot">headVec ::</span> <span class="dt">Vec</span> a (n <span class="fu">+</span> <span class="dv">1</span>) <span class="ot">-&gt;</span> a
headVec (<span class="dt">VCons</span> x _) <span class="fu">=</span> x

<span class="ot">mapVec ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> b n
mapVec f <span class="dt">VNil</span> <span class="fu">=</span> <span class="dt">VNil</span>
mapVec f (<span class="dt">VCons</span> x xs) <span class="fu">=</span> <span class="dt">VCons</span> (f x) (mapVec f xs)</code></pre></div>
<p>If we were to change the definition of the nil case of <code>mapVec</code> to use <code>VCons</code> instead then it wouldn’t type check.</p>
]]></summary>
</entry>
<entry>
    <title>Pattern Synonyms in GHC 8.0</title>
    <link href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html" />
    <id>http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html</id>
    <published>2015-12-12T00:00:00Z</published>
    <updated>2015-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Pattern Synonyms in GHC 8.0 </h2>
<div class="info">
    Posted on December 12, 2015
    
</div>

<p>There have been four small but significant improvements to pattern synonyms which are going to appear in GHC 8.0.</p>
<p>This work closes up some holes which were left in the implementation of pattern synonyms and should provide library authors with a new and flexible method of abstraction.</p>
<p>More information about pattern synonyms can be found in the <a href="http://mpickering.github.io/users_guide/glasgow_exts.html#pattern-synonyms">GHC 8.0 user guide</a>.</p>
<!--more-->
<h3 id="record-pattern-synonyms">Record Pattern Synonyms</h3>
<p>The biggest update extends pattern synonyms to allow the construction of pattern synonyms which behave like record data constructors.</p>
<p>Since GHC 7.8 you have been able to define prefix and infix pattern synonyms which behave like normal data constructors. With the addition of record pattern synonyms most data constructors can be replicated by pattern synonyms.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<p>To make this clear, consider the data constructor <code>Just</code>. We can use this constructor in two contexts, in a pattern match or in an expression context to construct a value.</p>
<p>If we defined the pattern synonym <code>MyJust</code>, we can use it in precisely the same contexts as <code>Just</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyJust</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
pattern <span class="dt">MyJust</span> a <span class="fu">=</span> <span class="dt">Just</span> a</code></pre></div>
<p>Similarly, record data constructors can be used in seven contexts.</p>
<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th>Usage</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>As a constructor</p></td>
<td><p><code>zero = Point 0 0</code></p></td>
</tr>
<tr class="even">
<td><p>As a constructor with record syntax</p></td>
<td><p><code>zero = Point { x = 0, y = 0}</code></p></td>
</tr>
<tr class="odd">
<td><p>In a pattern context</p></td>
<td><p><code>isZero (Point 0 0) = True</code></p></td>
</tr>
<tr class="even">
<td><p>In a pattern context with record syntax</p></td>
<td><p><code>isZero (Point { x = 0, y = 0 }</code></p></td>
</tr>
<tr class="odd">
<td><p>In a pattern context with field puns</p></td>
<td><p><code>getX (Point {x}) = x</code></p></td>
</tr>
<tr class="even">
<td><p>In a record update</p></td>
<td><p><code>(0, 0) { x = 1 } == (1,0)</code></p></td>
</tr>
<tr class="odd">
<td><p>Using record selectors</p></td>
<td><p><code>x (0,0) == 0</code></p></td>
</tr>
</tbody>
</table>
<p>Record pattern synonyms are defined as follows and can also be used in these seven contexts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">MyPoint</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
pattern <span class="dt">MyPoint</span>{x, y} <span class="fu">=</span> (x,y)</code></pre></div>
<p>Projection functions, <code>x</code> and <code>y</code> are defined like record selectors for ordinary constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">x ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">y ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Because we defined this pattern synonym, tuples can now be updated with record update syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> (<span class="dv">0</span>,<span class="dv">0</span>) { x <span class="fu">=</span> <span class="dv">5</span> }
(<span class="dv">5</span>, <span class="dv">0</span>)</code></pre></div>
<h3 id="bundling-pattern-synonyms">Bundling Pattern Synonyms</h3>
<p>Since pattern synonyms are a lot like data constructors, they should be able to be imported just like data constructors. To put it another way a user should be unaware whether they are using a pattern synonym or a data constructor.</p>
<p>However, before GHC 8.0, there has been quite an awkward distinction between the two. Data constructors couldn’t be imported or exported separated from the type which they construct. On the other hand, pattern synonyms could only be imported and exported individually by using the <code>pattern</code> keyword. This meant that consumers had to be aware that whether they were importing a pattern synonym or not! No good!</p>
<p>Now there are two ways which we can export the pattern synonym <code>P :: A</code>.</p>
<ol style="list-style-type: decimal">
<li><p>Separately, as before, by using the <code>pattern</code> keyword.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> (pattern <span class="dt">P</span>) <span class="kw">where</span></code></pre></div></li>
<li><p>Bundled with the relevant type constructor</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> ( <span class="dt">A</span>(<span class="dt">P</span>) ) <span class="kw">where</span></code></pre></div>
<p>or to export all of <code>A</code>’s constructors along with the pattern synonym <code>P</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> ( <span class="dt">A</span>(<span class="fu">..</span>, <span class="dt">P</span>) ) <span class="kw">where</span></code></pre></div></li>
</ol>
<p>In this second case, if another module imports <code>Foo</code> then <code>P</code> can be imported alongwith <code>A</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Will import P</span>
<span class="kw">import </span><span class="dt">Foo</span> (<span class="dt">A</span> (..))</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Will import P</span>
<span class="kw">import </span><span class="dt">Foo</span> (<span class="dt">A</span> (<span class="dt">P</span>))</code></pre></div>
<h4 id="an-example-errorcall">An Example: <code>ErrorCall</code></h4>
<p>This problem reared its head in one of the first serious uses of pattern synonyms. In GHC 8 a pattern synonym <code>ErrorCall</code> is introduced into the base library to smooth over changes in the internal representation caused by Eric Seidel’s work on call stacks.</p>
<p>The datatype <code>ErrorCall</code> previously just had one synonymous constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCall</span> <span class="dt">String</span></code></pre></div>
<p>After the <a href="https://phabricator.haskell.org/D861">refactoring</a>, the single constructor was renamed to <code>ErrorCallWithLocation</code> but Eric wanted to smooth over the transition by providing a pattern synonym which would behave much like before.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span>

pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span>
pattern <span class="dt">ErrorCall</span> s <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> s _ <span class="kw">where</span>
  <span class="dt">ErrorCall</span> s <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> s <span class="st">&quot;&quot;</span></code></pre></div>
<p>However clients importing <code>ErrorCall(..)</code> found that despite the careful efforts of the library author this change broke their code. The problem being that by default, it is necessary to explicitly import pattern synonyms.</p>
<p>With this feature, we can now bundle the new <code>ErrorCall</code> pattern synonym in the export list of the module so that users importing <code>ErrorCall(..)</code> will also import the pattern synonym.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GHC.Exception</span> ( <span class="dt">ErrorCall</span>(<span class="fu">..</span>, <span class="dt">ErrorCall</span>) ) <span class="kw">where</span></code></pre></div>
<h3 id="pattern-synonym-signatures">Pattern Synonym Signatures</h3>
<p>Pattern synonyms can also have type signatures. The syntax is very similar to normal type signatures but there are two sets of constraints rather than the usual one which correspond to “required” and “provided” constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> provided <span class="ot">=&gt;</span> <span class="kw">type</span></code></pre></div>
<p>In the common case that there are no provided constraints, it is possible to omit the first set of constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> required <span class="ot">=&gt;</span> <span class="kw">type</span></code></pre></div>
<p>and in the even more common case when there are no constraints, both can be omitted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">P</span><span class="ot"> ::</span> <span class="kw">type</span></code></pre></div>
<p><em>Required</em> constraints are constraints which are required in order to make a match. For example, we could provide the quite silly pattern synonym which uses <code>show</code> to check whether a pattern should match. As <code>show</code> is from the <code>Show</code> typeclass, we have to add it to the required constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">IsTrue</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a
pattern <span class="dt">IsTrue</span> <span class="ot">&lt;-</span> ((<span class="fu">==</span> <span class="st">&quot;True&quot;</span>) <span class="fu">.</span> show <span class="ot">-&gt;</span> <span class="dt">True</span>)</code></pre></div>
<p><em>Provided</em> constraints are constraints which are made available on a successful match. This usually occurs when matching on a GADT with an existential type.</p>
<p>In fact, it only makes sense for provided constraints to mention existentially quantified type variables which explains why they are less often used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">T</span> <span class="kw">where</span>
  <span class="dt">MkT</span><span class="ot"> ::</span> (<span class="dt">Show</span> b) <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span>

pattern <span class="dt">ExNumPat</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Show</span> b <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">T</span>
pattern <span class="dt">ExNumPat</span> x <span class="fu">=</span> <span class="dt">MkT</span> x</code></pre></div>
<p>Pattern synonym signatures aren’t new for GHC 8.0 but the order of required and provided constraints has been switched.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<h3 id="warnings-for-missing-pattern-synonym-signatures">Warnings for missing pattern synonym signatures</h3>
<p>The final small change is that GHC can also warn about any pattern synonym which doesn’t have a type signature. The warning is turned on by the flag <code>-fwarn-missing-pat-syn-sigs</code> and is also enabled by <code>-Wall</code>.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>There is one exception which is a datatype which has record constructors which share field names. <code>data A = B { a :: Int } | C { a :: Int, b :: Int }</code><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In previous versions, provided constraints appeared before required constraints and if only one set was given then it was assumed to be the provided rather than required constraints.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Automatically Apply HLint Suggestions</title>
    <link href="http://mpickering.github.io/posts/2015-11-22-hlint-refactor.html" />
    <id>http://mpickering.github.io/posts/2015-11-22-hlint-refactor.html</id>
    <published>2015-11-22T00:00:00Z</published>
    <updated>2015-11-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Automatically Apply HLint Suggestions </h2>
<div class="info">
    Posted on November 22, 2015
    
</div>

<p>Users upgrading to <a href="https://hackage.haskell.org/package/hlint-1.9.23">hlint 1.9.23</a> will now be able to take advantage of the new <code>--refactor</code> flag which by invoking the <code>refactor</code> executable supplied by <a href="https://hackage.haskell.org/package/apply-refact-0.1.0.0"><code>apply-refact</code></a> can automatically apply suggestions.</p>
<p><img src="http://i.imgur.com/5hiEZJo.gif" alt="example" /><br />
<!--more--></p>
<h1 id="getting-started">Getting Started</h1>
<pre><code>cabal install hlint
cabal install apply-refact
hlint --refactor myfile.hs</code></pre>
<p>To take advantage of this flag users also need to install the <code>refactor</code> executable which is provided by <code>apply-refact</code>. Users can directly invoke <code>refactor</code> if they wish but it is easier to invoke it via hlint, passing any extra options with the <code>--refactor-options</code> flag.</p>
<p>HLint will by default apply all suggestions without any prompts to the user and output the result on stdout.</p>
<p><img src="http://i.imgur.com/cmxQJiI.gif" alt="example2" /><br />
If you’re feeling cautious, the <code>-s</code> flag will prompt you before applying each refactoring.</p>
<p><img src="http://i.imgur.com/pxygqXI.gif" alt="sexample" /><br />
If you’re feeling brave, the <code>-i</code> flag will perform the refactoring in place.</p>
<p><img src="http://i.imgur.com/QJOGoHL.gif?1" alt="iexample" /><br />
The final option which is useful for tool writers is the <code>--pos</code> flag which specifies the region to which hints should be applied to.</p>
<p><img src="http://i.imgur.com/vOmNwq0.gif?1" alt="posexample" /><br />
</p>
<h1 id="editor-integration">Editor Integration</h1>
<p>There are plugins availible for vim, emacs and atom. Moritz Kiefer has already helped me with the emacs plugin, pull requests to clean up the other two plugins would be greatly appreciated.</p>
<ul>
<li><a href="https://github.com/mpickering/hlint-refactor-vim"><code>hlint-refactor-vim</code></a></li>
<li><a href="https://github.com/mpickering/hlint-refactor-atom"><code>hlint-refactor-atom</code></a></li>
<li><a href="https://github.com/mpickering/hlint-refactor-mode"><code>hlint-refactor-mode</code></a></li>
</ul>
<h1 id="reporting-bugs">Reporting Bugs</h1>
<p>If you find that the program gives you an unexpected result then please report a bug to the <a href="https://github.com/mpickering/apply-refact">issue tracker</a>. Please also include the output of <code>hlint --serialise</code> and the input file.</p>
<p>There are a few known problems with CPP and a few corner cases which are not handled by the underlying library but for most users, a pain-free experience is expected.</p>
<h2 id="known-issues">Known Issues</h2>
<ul>
<li><p>Tabs and trailing whitespace will be removed (this is by design and not going to change). Line endings are changed to unix line endings.</p></li>
<li><p>Not all hlint suggestions are supported. A notable exception being the eta reduction refactoring as it proved quite difficult to implement correctly.</p></li>
<li><p>Sometimes hlint suggests a refactoring which uses a name which isn’t in scope. The tool is quite dumb! It just takes whatever hlint suggests and applies it blindly. It might be good to add an option to hlint to avoid spitting out hints which do this.</p></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Announcing ghc-exactprint: A New Foundation For Refactoring Tools</title>
    <link href="http://mpickering.github.io/posts/2015-07-23-ghc-exactprint.html" />
    <id>http://mpickering.github.io/posts/2015-07-23-ghc-exactprint.html</id>
    <published>2015-07-23T00:00:00Z</published>
    <updated>2015-07-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Announcing ghc-exactprint: A New Foundation For Refactoring Tools </h2>
<div class="info">
    Posted on July 23, 2015
    
</div>

<p>Over the last few months Alan Zimmerman and myself have been working on what will hopefully become a new foundation for refactoring Haskell programs. We have called this foundation <code>ghc-exactprint</code> and it is now available on <a href="https://hackage.haskell.org/package/ghc-exactprint">hackage</a> to coincide with the release of GHC 7.10.2.</p>
<p>Thompson and Reinke originally described 22 refactorings in their <a href="http://www.cs.kent.ac.uk/projects/refactor-fp/publications/refactoring-draft-catalogue.pdf">catalogue</a> of functional refactorings which motivated the development of HaRe. Missing from their list is the identity transformation, in the context of refactoring this is perhaps the most important. When applying any kind of change to small segment of your project it is undesirable for the tooling to modify another part of your file unexpectedly. The identity refactoring seems to be the easiest of all but it is important that any refactoring tool behaves in this way.</p>
<p>The biggest challenge of the last few months was being able to perform the identity refactoring whilst retaining a suitable representation to be able to easily transform programs. Now that we believe that <code>ghc-exactprint</code> is robust, the challenge is to build the promised refactoring tools upon it.</p>
<!--more-->
<h1 id="representation">Representation</h1>
<p>If your only concern is to perform the identity transformation then perhaps the representation you choose is not very important. One can easily choose to operate directly on the source files for instance. The representation becomes much more important when considering other refactoring operations.</p>
<p>When deciding on a representation, you have to take into account more complicated transformations such as renamings, insertions and deletions which are made much easier by manipulating an AST. Most current source manipulations are based on <code>haskell-src-exts</code> which provides a separate parser and as a result lacks support for many modern language extensions. We instead chose to base <code>ghc-exactprint</code> directly on the GHC parser so that we don’t have to worry (much) about adding support for future language extensions and secondly, working with the GHC AST directly is essential if you want to perform <em>type-aware</em> refactorings.</p>
<p>We work in two stages.</p>
<p>After receiving the output of the GHC parser, the first stage converts all the absolute source positions into relative positions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">not <span class="dt">True</span> <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>For example, in the preceding declaration, using absolute source positions we might describe the the declaration starts at <code>(0,0)</code>, the first argument starts at <code>(0,4)</code> and the RHS of the definition starts at <code>(0,12)</code>. Using relative positioning like in the library, we instead describe the position of each element relative to the position of the previous element. For example, <code>True</code> is 0 lines and 1 column further than <code>not</code> and <code>False</code> is 0 lines and 1 column further than <code>=</code>.</p>
<p>To keep track of this information we introduce a separate data structure which we call <em>annotations</em>. This data structure keeps track of the relative positions of all AST elements and keywords as well as any necessary information which is not included in the AST in order to exactly reproduce the original source file.</p>
<p>We hope this approach will make it easy to perform transformations without worrying too much about where exactly everything will end up. With this style, replacing expressions is easy as we don’t have to worry about updating anything at all, just by replacing the expression in the AST produces the correct output.</p>
<p>Secondly, we perform the reverse of this transformation and produce a source file given an AST and the previously worked out relative positions. Thus a refactoring becomes two things:</p>
<ol style="list-style-type: decimal">
<li>A direct modification of the AST.</li>
<li>A modification of the associated annotations.</li>
</ol>
<h1 id="results">Results</h1>
<p>Much of the last 10 months was spent modifying GHC and <code>ghc-exactprint</code> in order to be able roundtrip any source file successfully. The library has been through many iterations with varying levels of success but finally has reached an understandable and usable core. After testing the program on around 50,000 source files from Hackage, we can say with confidence that at least the foundations are in place for further tooling to be built.</p>
<p>A glance at the <a href="https://github.com/alanz/ghc-exactprint/tree/master/tests/examples">test suite</a> will show some particularly tricky examples. The IOHCC also provided a good source of test material..</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>
e<span class="fu">=</span><span class="dv">181021504832735228091659724090293195791121747536890433</span>

u(f,m)x<span class="fu">=</span>i(m(x),       [],<span class="kw">let</span>(a,b)<span class="fu">=</span>f(x)       <span class="kw">in</span>(a<span class="fu">:</span>u(f,m)b))
(v,h)<span class="fu">=</span>(foldr(\x(y    )<span class="ot">-&gt;</span><span class="dv">00</span><span class="fu">+</span><span class="dv">128</span><span class="fu">*</span>y<span class="fu">+</span>x)<span class="dv">0</span>,u(     sp(<span class="dv">25</span>),((<span class="fu">==</span>)<span class="st">&quot;&quot;</span>)))
<span class="ot">p::</span>(<span class="dt">Integer</span>,<span class="dt">Integer</span> )<span class="ot">-&gt;</span><span class="dt">Integer</span>      <span class="ot">-&gt;</span>     <span class="dt">Integer</span>    <span class="co">--NotInt</span>
p(n,m)x     <span class="fu">=</span>i(n<span class="fu">==</span><span class="dv">0</span> ,<span class="dv">1</span>,i(z n             ,q(n,m)x,    r(n,m)x))
i(n,e,d     )<span class="fu">=</span><span class="kw">if</span>(n) <span class="kw">then</span>(e)              <span class="kw">else</span>  (d)    <span class="co">--23+3d4f</span>
(g,main     ,s,un)<span class="fu">=</span> (\x<span class="ot">-&gt;</span>x,             y(j),\x<span class="ot">-&gt;</span>x<span class="fu">*</span>x,unlines)<span class="co">--)</span>
j(o)<span class="fu">=</span>i(take(<span class="dv">2</span>)o<span class="fu">==</span>   <span class="st">&quot;e=&quot;</span>,<span class="st">&quot;e=&quot;</span><span class="fu">++</span>t        (drop(<span class="dv">4</span><span class="fu">-</span><span class="dv">2</span>)o),i(d<span class="fu">&gt;</span>e,k,l)o)
l<span class="fu">=</span>un<span class="fu">.</span>map (show<span class="fu">.</span>p      (e,n)<span class="fu">.</span>v<span class="fu">.</span>map(      fromIntegral<span class="co">{-g-}</span><span class="fu">.</span>ord))<span class="fu">.</span>h
k<span class="fu">=</span>co<span class="fu">.</span>map(map(chr       <span class="fu">.</span>fromIntegral    )<span class="fu">.</span>w<span class="fu">.</span>p(d,n)<span class="fu">.</span>   read)<span class="fu">.</span>lines
(t,y)<span class="fu">=</span>(\ (o<span class="fu">:</span>q)<span class="ot">-&gt;</span>              i(o<span class="fu">==</span><span class="ch">&#39;-&#39;</span>  ,<span class="ch">&#39;1&#39;</span>,<span class="ch">&#39;-&#39;</span> )<span class="fu">:</span>   q,interact)
q(n,m)x<span class="fu">=</span>   mod(s(    p(        div(n)<span class="dv">2</span>, m<span class="co">{-jl-}</span>)x)    )m<span class="co">--hd&amp;&amp;gdb</span>
(r,z,co)    <span class="fu">=</span>(\(n,   m)x<span class="ot">-&gt;</span>mod(x<span class="fu">*</span>p(n<span class="fu">-</span><span class="dv">1</span>,  m)x)m,even    ,concat)<span class="co">--6</span>
(w,sp)<span class="fu">=</span>(    u(\x<span class="ot">-&gt;</span>(   mod(x)<span class="dv">128</span>,div(x   )<span class="dv">128</span>),(<span class="fu">==</span><span class="dv">0</span>    )),splitAt)

d<span class="fu">=</span><span class="dv">563347325936</span><span class="fu">+</span><span class="dv">1197371806136556985877790097</span><span class="fu">-</span><span class="dv">563347325936</span>
n<span class="fu">=</span><span class="dv">351189532146914946493104395525009571831256157560461451</span></code></pre></div>
<p>Replacements, deletions and rearrangements are very easy using this framework. Most of the time they can be specified by generic traversals (with any generics library) The last piece of the puzzle is to make it just as easy to add new items into the AST. A challenge that I and Alan Zimmerman will now begin to work on.</p>
<h2 id="future-work">Future Work</h2>
<ul>
<li>I have used this tooling to write a <a href="https://github.com/mpickering/apply-refact">tool</a> which automatically applies hlint suggestions.</li>
<li>HaRe is currently being rewritten to use this new machinery.</li>
<li>We are looking at using pattern synonyms in order to smooth over the rough corners of the GHC API.</li>
</ul>
<p>If you are interested in using the tooling then we are both active in <code>#haskell-refactorer</code>.</p>
<h2 id="caveats">Caveats</h2>
<p>There are a few things which remain difficult to process.</p>
<ul>
<li>CPP - I think that every Haskell tool has difficultly dealing with CPP and we are no exception.</li>
<li>Minimal Pragmas - The GHC AST performs normalisation on complicated Minimal Pragmas which means that some positional information is lost. This will be fixed for GHC 7.12.</li>
<li>Unicode Syntax - The lexer doesn’t differentiate between unicode characters and their ascii equivalents. For the most part we can work around this by comparing the length of symbols. The exception is ★, which has the same length as it’s ascii equivalent * which means that ★’s are unfortunately lost on conversion.</li>
</ul>
<h2 id="a-simple-insertion">A simple insertion</h2>
<p>This simple example inserts a type signature making sure to move comments to the right place. We hope to build a higher level interface on top of this low level manipulation.</p>
<p>Along with the changes that Alan made to GHC to keep track of all the locations of keywords during parsing there have been two other improvements to enable this work.</p>
<ol style="list-style-type: decimal">
<li>Andrew Gibiansky added some more parser entry points which have proved invaluable.</li>
<li>All the datatypes in the GHC AST now derive Data and Typeable instances which enables generic traversals.</li>
</ol>
<p>The following example takes advantage of the former of these two additions.</p>
<h3 id="input">Input</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- test.hs</span>
<span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span>

baz <span class="st">&quot;one&quot;</span> <span class="fu">=</span> <span class="dv">1</span>
baz <span class="st">&quot;two&quot;</span> <span class="fu">=</span> <span class="dv">2</span></code></pre></div>
<h3 id="program">Program</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span>
<span class="kw">module</span> <span class="dt">InsertSignature</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Language.Haskell.GHC.ExactPrint</span>
<span class="kw">import </span><span class="dt">Language.Haskell.GHC.ExactPrint.Parsers</span>
<span class="kw">import </span><span class="dt">Language.Haskell.GHC.ExactPrint.Types</span>
<span class="kw">import </span><span class="dt">Language.Haskell.GHC.ExactPrint.Utils</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span>

<span class="kw">import qualified</span> <span class="dt">HsSyn</span> <span class="kw">as</span> <span class="dt">GHC</span>
<span class="kw">import qualified</span> <span class="dt">RdrName</span> <span class="kw">as</span> <span class="dt">GHC</span>
<span class="kw">import qualified</span> <span class="dt">SrcLoc</span> <span class="kw">as</span> <span class="dt">GHC</span>

<span class="kw">type</span> <span class="dt">Module</span> <span class="fu">=</span> <span class="dt">GHC.Located</span> (<span class="dt">GHC.HsModule</span> <span class="dt">GHC.RdrName</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">Right</span> (as, m) <span class="ot">&lt;-</span> parseModule <span class="st">&quot;test.hs&quot;</span>
  (finalAs, finalM) <span class="ot">&lt;-</span> addSignature <span class="st">&quot;baz&quot;</span> <span class="st">&quot;baz :: String -&gt; Int&quot;</span> as m
  putStrLn <span class="fu">$</span> exactPrintWithAnns finalM finalAs


<span class="ot">addSignature ::</span> <span class="dt">String</span> <span class="co">-- ^ Function to add a signature for</span>
             <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="co">-- ^ Type signature</span>
             <span class="ot">-&gt;</span> <span class="dt">Anns</span>
             <span class="ot">-&gt;</span> <span class="dt">Module</span>
             <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Anns</span>, <span class="dt">Module</span>)
addSignature funid tsig as (<span class="dt">GHC.L</span> l m) <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Parse new AST element</span>
  <span class="dt">Right</span> (sigAnns, sig) <span class="ot">&lt;-</span> withDynFlags (\d <span class="ot">-&gt;</span> parseDecl d <span class="st">&quot;template&quot;</span> tsig)
  <span class="kw">let</span> (before, (bind<span class="fu">:</span> after)) <span class="fu">=</span> break findFunBind (GHC.hsmodDecls m)
      <span class="co">-- Add new annotations to the map</span>
      newAs <span class="fu">=</span> Map.union as sigAnns
      <span class="co">-- Modify the annotations to</span>
      <span class="co">-- 1. Retain the original spacing</span>
      <span class="co">-- 2. Make sure that comments are placed correctly.</span>
      <span class="dt">Just</span> <span class="dt">Ann</span>{annEntryDelta, annPriorComments} <span class="fu">=</span> Map.lookup (mkAnnKey bind) newAs
      finalAnns <span class="fu">=</span> Map.adjust (\sigAnn <span class="ot">-&gt;</span> sigAnn { annEntryDelta <span class="fu">=</span> annEntryDelta
                                                , annPriorComments <span class="fu">=</span> annPriorComments })
                             (mkAnnKey sig)
                  <span class="fu">.</span> Map.adjust (\bindAnn <span class="ot">-&gt;</span> bindAnn { annEntryDelta <span class="fu">=</span> <span class="dt">DP</span> (<span class="dv">1</span>, <span class="dv">0</span>)
                                                    , annPriorComments <span class="fu">=</span> [] })
                               (mkAnnKey bind) <span class="fu">$</span> newAs

      finalMod <span class="fu">=</span> m { GHC.hsmodDecls <span class="fu">=</span> before <span class="fu">++</span> [sig, bind] <span class="fu">++</span> after }

  return (finalAnns, <span class="dt">GHC.L</span> l finalMod)


  <span class="kw">where</span>
<span class="ot">    findFunBind ::</span> <span class="dt">GHC.LHsDecl</span> <span class="dt">GHC.RdrName</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
    findFunBind (<span class="dt">GHC.L</span> _ (<span class="dt">GHC.ValD</span> b<span class="fu">@</span>(<span class="dt">GHC.FunBind</span> {})))
      <span class="fu">|</span> showGhc (GHC.unLoc (GHC.fun_id  b)) <span class="fu">==</span> funid <span class="fu">=</span> <span class="dt">True</span>
    findFunBind _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<h3 id="result">Result</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span>

<span class="ot">baz ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
baz <span class="st">&quot;one&quot;</span> <span class="fu">=</span> <span class="dv">1</span>
baz <span class="st">&quot;two&quot;</span> <span class="fu">=</span> <span class="dv">2</span></code></pre></div>
]]></summary>
</entry>
<entry>
    <title>Data Types à la Carte with Closed Type Families</title>
    <link href="http://mpickering.github.io/posts/2014-12-20-closed-type-family-data-types.html" />
    <id>http://mpickering.github.io/posts/2014-12-20-closed-type-family-data-types.html</id>
    <published>2014-12-20T00:00:00Z</published>
    <updated>2014-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Data Types à la Carte with Closed Type Families </h2>
<div class="info">
    Posted on December 20, 2014
    
</div>

<p>By hitting that critical sweet spot of solving an interesting problem and having a catchy name, most know, if not understand Wouter Swierstra’s data types à la carte.</p>
<p>As the name suggests, the à la carte approach involves composing together data types to form bigger, <em>custom</em> types along with functions where we can precisely specify the necessary pieces. The approach relies heavily on a clever trick with type classes which is reviewed below. With more modern GHC extensions, the implementation can be made much more explicit, this is what this post will explore.</p>
<p>For a general overview of the approach there is no better introduction than the original <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131">functional pearl</a>.</p>
<!--more-->
<p>To recap, in order to ease writing composed data types, we define a type class <code>a :&lt;: b</code> to express that <code>a</code> is a subtype of <code>b</code>. To do this we require three instances.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Coproduct</span>
<span class="kw">data</span> (f <span class="fu">:+:</span> g) e <span class="fu">=</span> <span class="dt">Inl</span> (f e) <span class="fu">|</span> <span class="dt">Inr</span> (g e)

<span class="kw">class</span> f <span class="fu">:&lt;:</span> g <span class="kw">where</span>
<span class="ot">  inj ::</span> f a <span class="ot">-&gt;</span> g a

<span class="kw">instance</span> f <span class="fu">:&lt;:</span> f <span class="kw">where</span>
  inj <span class="fu">=</span> id

<span class="kw">instance</span> f <span class="fu">:&lt;:</span> (f <span class="fu">:+:</span> g) <span class="kw">where</span>
  inj <span class="fu">=</span> <span class="dt">Inl</span>

<span class="kw">instance</span> (f <span class="fu">:&lt;:</span> h) <span class="ot">=&gt;</span>  f <span class="fu">:&lt;:</span> (g <span class="fu">:+:</span> h) <span class="kw">where</span>
  inj <span class="fu">=</span> inj <span class="fu">.</span> <span class="dt">Inr</span></code></pre></div>
<p>Together these three instances model a linear search through our nested coproduct whilst picking out the correct injection.</p>
<p>Closed type families as introduced by Richard Eisenberg <span class="citation">(2013)</span> are on a simple level are restricted functions which act on types. With this observation, it seems that they can be used to reimplement most type class tricks in a more explicit manner and indeed this is the case. Patrick Bahr <span class="citation">(2014)</span> was the first to explore this idea in connection with compositional data types, this post closely follows his exposition.</p>
<p>Patrick incrementally builds a solution to provide a more robust subtyping constraint. He proceeds in three stages.</p>
<ol style="list-style-type: decimal">
<li>A (near) faithful recreation of the semantics presented by Swierstra.</li>
<li>Strengthening to prevent ambiguous injections.</li>
<li>Strengthening to support complex injections.</li>
</ol>
<p>Today I will talk about the first two stages, leaving the slightly more intricate third for another time.</p>
<h1 id="recreation">Recreation</h1>
<p>Implementing the subtyping relation using type families brings out quite a subtle point which is implicit in the original pearl. The type class <code>:&lt;:</code> has two purposes, the first is to check whether we are able to construct an injection from <code>f</code> to <code>g</code> by computing at the type level. The second is to work out the correction injection from <code>a</code> to <code>b</code> at the term level. Type families make this dependency explicit.</p>
<p>Thus, our first step will be to check whether such an injection exists from <code>f</code> to <code>g</code>.</p>
<p>As type class resolution operators without backtracking - we can’t express any kind of branching computation in type class instances. This led to the convention where we were forced to make sure that <code>:+:</code> associated to the right.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> Hence, it was easy to think about our composed data types as lists of types (with <code>:+:</code> being a type level cons and <code>:&lt;:</code> searching through the list). As type families allow us to backtrack, this restriction is needless. Instead it is much easier to think about our constructed data types as trees.</p>
<p>Our goal becomes to find a type family which searches these trees. To do this, we consider how we would do so at the term level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Tip</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a

elem<span class="ot"> ::</span> <span class="dt">Eq</span> v <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
elem v (<span class="dt">Tip</span> x) <span class="fu">=</span> <span class="kw">if</span> v <span class="fu">==</span> x <span class="kw">then</span> <span class="dt">True</span> <span class="kw">else</span> <span class="dt">False</span>
elem v (<span class="dt">Branch</span> l r) <span class="fu">=</span> (elem v l) <span class="fu">||</span> (elem v r)</code></pre></div>
<p>We can define a very similar type family which searches a composite coproduct at the type level. Note that we will make extensive implicit use of the <code>DataKinds</code> extension. For example in the following example, <code>True</code> and <code>False</code> are the promoted constructors.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Elem</span> e<span class="ot"> f ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">Elem</span> e e <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">Elem</span> e (l <span class="fu">:+:</span> r) <span class="fu">=</span> <span class="dt">Or</span> (<span class="dt">Elem</span> e l) (<span class="dt">Elem</span> e r)
  <span class="dt">Elem</span> e f <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> family <span class="dt">Or</span> a<span class="ot"> b ::</span> <span class="dt">Bool</span>
  <span class="dt">Or</span> <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
  <span class="dt">Or</span> a b         <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>This is no use to us as we must also calculate the injection, to do this, we need to know the path we took to find the value in the tree. By introducing a new data type <code>Res</code> and <code>Crumbs</code> we can construct the trail necessary. The modified definition of <code>Elem</code> and <code>Or</code> follow naturally.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Crumbs</span> <span class="fu">=</span> <span class="dt">Here</span> <span class="fu">|</span> <span class="dt">L</span> <span class="dt">Crumbs</span> <span class="fu">|</span> <span class="dt">R</span> <span class="dt">Crumbs</span>

<span class="kw">data</span> <span class="dt">Res</span> <span class="fu">=</span> <span class="dt">Found</span> <span class="dt">Crumbs</span> <span class="fu">|</span> <span class="dt">NotFound</span>

<span class="kw">type</span> family <span class="dt">Elem</span> e<span class="ot"> f ::</span> <span class="dt">Res</span> <span class="kw">where</span>
  <span class="dt">Elem</span> e e         <span class="fu">=</span> <span class="dt">Found</span> <span class="dt">Here</span>
  <span class="dt">Elem</span> e (l <span class="fu">:+:</span> r) <span class="fu">=</span> <span class="dt">Choose</span> (<span class="dt">Elem</span> e l) (<span class="dt">Elem</span> e r)
  <span class="dt">Elem</span> e f         <span class="fu">=</span> <span class="dt">NotFound</span>

<span class="kw">type</span> family <span class="dt">Choose</span> e<span class="ot"> f ::</span> <span class="dt">Res</span> <span class="kw">where</span>
  <span class="dt">Choose</span> (<span class="dt">Found</span> a) b <span class="fu">=</span> <span class="dt">Found</span> (<span class="dt">L</span> a)
  <span class="dt">Choose</span> a (<span class="dt">Found</span> b) <span class="fu">=</span> <span class="dt">Found</span> (<span class="dt">R</span> b)
  <span class="dt">Choose</span> a b         <span class="fu">=</span> <span class="dt">NotFound</span></code></pre></div>
<p>Again, this is very similar to the term-level definition but is more verbose thanks to the lack of type-level type classes.</p>
<p>Now we have the path to the type, we must also construct the injection. In fact, another type class is what we need but this time thanks to our additional work we don’t need to rely on convention nor <code>OverlappingInstances</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MakeInj</span> (<span class="ot">res ::</span> <span class="dt">Res</span>) f g <span class="kw">where</span>
<span class="ot">  mkInj ::</span> <span class="dt">Proxy</span> res <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g a</code></pre></div>
<p>Notice one difference here is that as we are going to explicitly use the computed type level path, we need someway to make this information accessible to our type class. One way to do this is to use a <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Proxy.html">proxy variable</a>. At first glace it may seem useless to define a data type in this fashion but it allows us to pass around type information in exactly the way we want to here.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MakeInj</span> (<span class="dt">Found</span> <span class="dt">Here</span>) f f <span class="kw">where</span>
  mkInj _ <span class="fu">=</span> id

<span class="kw">instance</span> <span class="dt">MakeInj</span> (<span class="dt">MakeInj</span> (<span class="dt">Found</span> p) f l) <span class="ot">=&gt;</span> <span class="dt">MakeInj</span> (<span class="dt">Found</span> (<span class="dt">L</span> p)) f (l <span class="fu">:+:</span> r) <span class="kw">where</span>
  mkInj _ <span class="fu">=</span> <span class="dt">Inl</span> <span class="fu">.</span> mkInj (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Found</span> p))

<span class="kw">instance</span> <span class="dt">MakeInj</span> (<span class="dt">MakeInj</span> (<span class="dt">Found</span> p) f r) <span class="ot">=&gt;</span> <span class="dt">MakeInj</span> (<span class="dt">Found</span> (<span class="dt">R</span> p)) f (l <span class="fu">:+:</span> r) <span class="kw">where</span>
  mkInj _ <span class="fu">=</span> <span class="dt">Inr</span> <span class="fu">.</span> mkInj (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Found</span> p))</code></pre></div>
<p>Notice how the proxy is used to direct the construction.</p>
<p>Finally we can define <code>:&lt;:</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> f <span class="fu">:&lt;:</span> g <span class="fu">=</span> <span class="dt">MakeInj</span> (<span class="dt">Elem</span> f g) f g</code></pre></div>
<p>That is to say, <code>f</code> is a subtype of <code>g</code> if there is an injection from <code>f</code> to <code>g</code>. Notice that there is an injection if <code>Elem f g</code> is not <code>NotFound</code>.</p>
<p>Using closed type families might seem like more work but the approach is inherently more powerful. There is also something to be said about making our search strategy explicit. Without knowledge of the type class resolution mechanism it can be confusing why a certain subtyping would fail. With this implementation, even if unfamiliar with the nuances of type families, it is much clearer.</p>
<h1 id="ambiguity">Ambiguity</h1>
<p>Another wart was the possibility of ambiguous injections if the same constructor was specified twice in a type signature. One example where it would be impossible to guarantee a consistent injection would be <code>Lit :+: Lit</code>. We want to disallow such signatures at compile time as they are always a programming error.</p>
<p>To do this we can extend the <code>Res</code> data type to include a new constructor <code>Ambiguous</code> and altering the definition of <code>Choose</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Res</span> <span class="fu">=</span> <span class="dt">Found</span> <span class="dt">Crumbs</span> <span class="fu">|</span> <span class="dt">NotFound</span> <span class="fu">|</span> <span class="dt">Ambiguous</span>

<span class="kw">type</span> family <span class="dt">Choose</span> e<span class="ot"> f ::</span> <span class="dt">Res</span> <span class="kw">where</span>
    <span class="dt">Choose</span> (<span class="dt">Found</span> x) (<span class="dt">Found</span> y) <span class="fu">=</span> <span class="dt">Ambiguous</span>
    <span class="dt">Choose</span> <span class="dt">Ambiguous</span> x <span class="fu">=</span> <span class="dt">Ambiguous</span>
    <span class="dt">Choose</span> x <span class="dt">Ambiguous</span> <span class="fu">=</span> <span class="dt">Ambiguous</span>
    <span class="dt">Choose</span> (<span class="dt">Found</span> a) b <span class="fu">=</span> <span class="dt">Found</span> (<span class="dt">L</span> a)
    <span class="dt">Choose</span> a (<span class="dt">Found</span> b) <span class="fu">=</span> <span class="dt">Found</span> (<span class="dt">R</span> b)
    <span class="dt">Choose</span> a b <span class="fu">=</span> <span class="dt">NotFound</span></code></pre></div>
<p>The choice here to use a new constructor <code>Ambiguous</code> is stylistic, we could have easily reused the <code>NotFound</code> constructor. The reason for doing so is that the error messages produced by a fine grained result type are better. For example now attempting to compile the following expression results in an error which specifically mentions ambiguity.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lit2 ::</span> <span class="dt">Expr</span> (<span class="dt">Lit</span> <span class="fu">:+:</span> <span class="dt">Lit</span>)
lit2 <span class="fu">=</span> lit <span class="dv">2</span>

<span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">MakeInj</span> <span class="ch">&#39;Ambiguous Lit (Lit :+: Lit))</span>
   arising from a use <span class="kw">of</span> ‘lit’
   <span class="dt">In</span> the expression<span class="fu">:</span> lit <span class="dv">2</span>
   <span class="dt">In</span> an equation for ‘lit2’<span class="fu">:</span> lit2 <span class="fu">=</span> lit <span class="dv">2</span>
<span class="dt">Failed</span>, modules loaded<span class="fu">:</span> none<span class="fu">.</span></code></pre></div>
<h1 id="further-work">Further Work</h1>
<p>We’ll wrap things up there for today but Patrick goes on to explore the possibility of further extending the subtyping relation to deal with more complicated injections. Even with the machinery he developed, intuitively correct subtyping relationships (such as <code>Add :+: Mult :&lt;: Add :+: Mult :+: Lit</code>) fail to hold. To avoid any suspense, he shows how to further extend <code>:&lt;:</code> to allow such relationships.</p>
<p>These ideas and more are implemented in the <a href="https://hackage.haskell.org/package/compdata">compdata</a> package.</p>
<h1 id="references">References</h1>
<ul>
<li><a href="http://ezyang.tumblr.com/post/74438034022/richard-a-eisenberg-closed-type-families-with">Q&amp;A with Richard Eisenberg</a></li>
</ul>
<div id="refs" class="references">
<div id="ref-Bahr2014">
<p>Bahr, Patrick. 2014. “Composing and decomposing data types: a closed type families implementation of data types à la carte.” <em>Proceedings of the 10th ACM SIGPLAN Workshop on …</em>, 71–82. <a href="http://dl.acm.org/citation.cfm?id=2633635" class="uri">http://dl.acm.org/citation.cfm?id=2633635</a>.</p>
</div>
<div id="ref-Eisenberg2013">
<p>Eisenberg, RA, D Vytiniotis, SP Jones, and Stephanie Weirich. 2013. “Closed type families with overlapping equations (extended version),” 1–21. <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf" class="uri">http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For instance <code>a :&lt;: (a :+: b) :+: c</code> would not typecheck.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>In fact, it is possible to promote simple functions using the <a href="http://hackage.haskell.org/package/singletons">singletons</a> package by Richard Eisenberg.<a href="#fnref2">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Pain Free Unfix with Pattern Synonyms</title>
    <link href="http://mpickering.github.io/posts/2014-11-27-pain-free.html" />
    <id>http://mpickering.github.io/posts/2014-11-27-pain-free.html</id>
    <published>2014-11-27T00:00:00Z</published>
    <updated>2014-11-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Pain Free Unfix with Pattern Synonyms </h2>
<div class="info">
    Posted on November 27, 2014
    
</div>

<p>Pattern synonyms are a great feature.</p>
<p>It is common to define closed data types. Later if one wants to annotate their syntax tree or pass along any other additional information this can cause significant problems. A clean solution is to redefine the data type using open recursion and then taking the fixed point.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> This approach allows great flexibility and access to uniform <a href="http://hackage.haskell.org/package/recursion-schemes">recursion schemes</a> but used to come at a cost. If the library writer had exposed the constructors, all existing user code would break with these changes. Since GHC 7.10, patterns allow us to completely swap out the underlying data type whilst maintaining the original interface.</p>
<!--more-->
<p>Here’s how. Consider Hutton’s Razor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hutton</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Hutton</span> <span class="dt">Hutton</span></code></pre></div>
<p>Typically there will be many different operations defined as traversals of the syntax tree. One might typically be an evaluator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Hutton</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">Int</span> n) <span class="fu">=</span> n
eval (<span class="dt">Add</span> n m) <span class="fu">=</span> eval n <span class="fu">+</span> eval m</code></pre></div>
<p>Later, we might want to define the unfixed version of <code>Hutton</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HuttonF</span> a <span class="fu">=</span> <span class="dt">IntF</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">AddF</span> a a <span class="kw">deriving</span> <span class="dt">Functor</span>

<span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="fu">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))

<span class="kw">type</span> <span class="dt">Hutton</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">HuttonF</span></code></pre></div>
<p>Unfortunately, we can no longer use any of our existing functions. Fortunately, using pattern synonyms we can regain this functionality.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern (<span class="dt">Int</span> n) <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">IntF</span> n)
pattern (<span class="dt">Add</span> x y) <span class="fu">=</span> <span class="dt">Fix</span> (<span class="dt">AddF</span> x y)</code></pre></div>
<p>This is as far as GHC 7.8 will take us. To move further we need to take advantage of <a href="https://ghc.haskell.org/trac/ghc/ticket/8581">explicitly-bidirectional pattern synonyms</a> which are set to be introduced in GHC 7.10. These allow us to explicitly specify the constructor as well as the pattern. Useless in this case but what if we also wanted to annotate out AST?</p>
<p>To do so it is usual to define a product type, <code>Annotate</code>,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Annotate</span> f <span class="fu">=</span> <span class="dt">Annotate</span> <span class="dt">Label</span> (f (<span class="dt">Annotate</span> f))</code></pre></div>
<p>which we can then take the fixed point to get an annotated AST.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Annotated</span> <span class="fu">=</span> <span class="dt">Annotate</span> <span class="dt">Hutton</span></code></pre></div>
<p>Now we want to be able to keep using our existing functions for both annotated and unannotated values. The catch is that we can only have one pattern which corresponds to each constructor. To get around this we can use view patterns and a type class in order to use the same pattern for both our annotated and unannotated AST.</p>
<p><code>View</code> provides an injection and projection function. Then defining suitable instances for <code>Annotated</code> and <code>Hutton</code>, we can reuse all of our previous definitions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">View</span> a <span class="kw">where</span>
<span class="ot">  proj ::</span> a <span class="ot">-&gt;</span> <span class="dt">HuttonF</span> a
<span class="ot">  inj ::</span> <span class="dt">HuttonF</span> a <span class="ot">-&gt;</span> a

pattern <span class="dt">I</span> n <span class="ot">&lt;-</span> (proj <span class="ot">-&gt;</span> <span class="dt">IF</span> n) <span class="kw">where</span>
  <span class="dt">I</span> n <span class="fu">=</span> inj (<span class="dt">IF</span> n)

pattern <span class="dt">Add</span> a b <span class="ot">&lt;-</span> (proj <span class="ot">-&gt;</span> <span class="dt">AddF</span> a b) <span class="kw">where</span>
  <span class="dt">Add</span> a b <span class="fu">=</span> inj (<span class="dt">AddF</span> a b)


<span class="kw">instance</span> <span class="dt">View</span> <span class="dt">Hutton</span> <span class="kw">where</span>
  proj <span class="fu">=</span> unFix
  inj <span class="fu">=</span> <span class="dt">Fix</span>

<span class="kw">instance</span> <span class="dt">View</span> <span class="dt">Annotated</span> <span class="kw">where</span>
  proj (<span class="dt">Annotated</span> _ e) <span class="fu">=</span> e
  inj v <span class="fu">=</span> <span class="dt">Annotated</span> (mkLabel v) v

<span class="ot">mkLabel ::</span> <span class="dt">HuttonF</span> <span class="dt">Annotated</span> <span class="ot">-&gt;</span> <span class="dt">Label</span></code></pre></div>
<p>So far so good. Let’s test out our sample program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">View</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">I</span> n) <span class="fu">=</span> n
eval (<span class="dt">Add</span> a b) <span class="fu">=</span> eval a <span class="fu">+</span> eval b

p1 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">I</span> <span class="dv">5</span>) (<span class="dt">I</span> <span class="dv">6</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> p2 <span class="fu">=</span><span class="ot"> p1 ::</span> <span class="dt">Hutton</span>
  <span class="kw">let</span> p3 <span class="fu">=</span><span class="ot"> p1 ::</span> <span class="dt">Annotated</span>
  print (eval p2)
  print (eval p3)

<span class="fu">&gt;</span> <span class="fu">./</span>patterns
<span class="dv">11</span>
<span class="dv">11</span></code></pre></div>
<p>To take stock for a moment - using technology available in GHC 7.8 we were able to swap out our standard data type and replace it with an unfixed variant. Then with machinery available to us in GHC 7.10, we were able to vary this underlying type as long as we could provide suitable mapping functions.</p>
<p>Looking back at our definition of <code>inj</code> for <code>Annotated</code>, depending on what we want the label to be, it could make little sense to fill in the annotation whilst we are building the AST. It seems sensible to separate our <code>View</code> typeclass into two separate classes, one for projection and one for injection as they might not both make sense for all data types. Indeed if we introduce one more example, it is clear that they don’t.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Holey</span> f <span class="fu">=</span> <span class="dt">Hole</span> <span class="fu">|</span> <span class="dt">Expr</span> (f (<span class="dt">Holey</span> f))

<span class="kw">type</span> <span class="dt">HuttonHole</span> <span class="fu">=</span> <span class="dt">Holey</span> <span class="dt">HuttonF</span></code></pre></div>
<p>This union type represents syntax trees which might have holes in. Clearly there is no total definition of <code>proj</code> so we redefine our type classes as follows.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Project</span> a <span class="kw">where</span>
<span class="ot">  proj ::</span> a <span class="ot">-&gt;</span> <span class="dt">HuttonF</span> a

<span class="kw">class</span> <span class="dt">Inject</span> a <span class="kw">where</span>
<span class="ot">  inj ::</span> <span class="dt">HuttonF</span> a <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Inject</span> <span class="dt">HuttonHole</span> <span class="kw">where</span>
  inj <span class="fu">=</span> <span class="dt">Expr</span></code></pre></div>
<p>Now we <em>should</em> be able to use this data type very naturally to construct trees which might contain holes and later fill in the holes with whatever we please.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hole ::</span> <span class="dt">HuttonHole</span>
hole <span class="fu">=</span> <span class="dt">Hole</span>

<span class="ot">p4 ::</span> <span class="dt">HuttonHole</span>
p4 <span class="fu">=</span> <span class="dt">Add</span> (<span class="dt">I</span> <span class="dv">5</span>) hole

<span class="ot">fillHole ::</span> (<span class="dt">Hole</span> <span class="ot">-&gt;</span> <span class="dt">Hutton</span>) <span class="ot">-&gt;</span> <span class="dt">HuttonHole</span> <span class="ot">-&gt;</span> <span class="dt">Hutton</span>
fillHole f <span class="dt">Hole</span> <span class="fu">=</span> f <span class="dt">Hole</span>
fillHole _ (<span class="dt">Expr</span> v) <span class="fu">=</span> v</code></pre></div>
<p>Unfortunately we have pushed pattern synonyms a little bit too far. Instead of sweet sweet compilation, we are greeted with the following error message for each of the patterns.</p>
<pre><code>Could not deduce (Inject a) arising from a use of ‘inj’
    from the context (Project a)
      bound by the type signature for Main.I :: Project a =&gt; Int -&gt; a
      at patterns.hs:1:1
    Possible fix:
      add (Inject a) to the context of
        the type signature for Main.I :: Project a =&gt; Int -&gt; a
    In the expression: inj&#39; (IF n)
    In an equation for ‘I’: I n = inj (IF n)</code></pre>
<p>GHC baulks at the fact that we have different class constraints for the pattern and constructor. I don’t think there is any reason that they <em>need</em> to have the same constraints but it might be desirable so that constructors, even synonyms, continue to match up with patterns.</p>
<p>There are many powerful abstractions in Haskell which allow a library maintainer to provide a consistent interface across interactions. Unfortunately, if they ever chose to expose their internal syntax tree to the end-user, it was previously very difficult to maintain backwards compatibility. Pattern synonyms provide the perfect tool to do just this but they don’t appear to stretch quite far enough to tackle all interesting use cases.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’ve been meaning to put this post up for a while but <a href="http://stackoverflow.com/questions/27157717/boilerplate-free-annotation-of-asts-in-haskell">this</a> stack overflow answer prompted me to finish up the post. As a result, the examples I use here are heavily inspired by it.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
]]></summary>
</entry>
<entry>
    <title>Diff word documents with pandoc</title>
    <link href="http://mpickering.github.io/posts/2014-09-27-diff-word.html" />
    <id>http://mpickering.github.io/posts/2014-09-27-diff-word.html</id>
    <published>2014-09-27T00:00:00Z</published>
    <updated>2014-09-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 class="post"> Diff word documents with pandoc </h2>
<div class="info">
    Posted on September 27, 2014
    
</div>

<p>Thanks to the work of Jesse Rosenthal, pandoc has recently become capable of reading docx documents. This additional functional now makes it extremely easy to diff two docx files without any additional tools.</p>
<!--more-->
<p>Given two documents <code>old.docx</code> and <code>new.docx</code> the following command can calculate the diff. (The choice to convert to markdown is arbritary but works best in my experience)</p>
<pre><code>diff &lt;(pandoc -t markdown old.docx) &lt;(pandoc -t markdown new.docx)</code></pre>
<p>The output from two example documents, the second identical to the first with an additional line:</p>
<pre><code>&gt; diff &lt;(pandoc -t markdown old.docx) &lt;(pandoc -t markdown new.docx )
2a3,4
&gt; This is the new line in the new file
&gt;</code></pre>
<p>Easy as that!</p>
]]></summary>
</entry>

</feed>
