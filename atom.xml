<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>mpickering.github.io</title>
    <link href="http://mpickering.github.io/atom.xml" rel="self" />
    <link href="http://mpickering.github.io" />
    <id>http://mpickering.github.io/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2018-09-19T00:00:00Z</updated>
    <entry>
    <title>Packaging a Haskell library for artefact evaluation using nix</title>
    <link href="http://mpickering.github.io/posts/2018-09-19-nix-artefacts.html" />
    <id>http://mpickering.github.io/posts/2018-09-19-nix-artefacts.html</id>
    <published>2018-09-19T00:00:00Z</published>
    <updated>2018-09-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Packaging a Haskell library for artefact evaluation using nix </h2>
<p class="text-muted">
    Posted on September 19, 2018
    
</p>

<p>This year I packaged two artefacts for the ICFP artefact evaluation process. This post explains the system I used to make it easy to produce the docker images using nix. I hope this documentation will be useful for anyone else submitting a Haskell library for evaluation.</p>
<p>The end result will be an <code>artefact.nix</code> file which is used to build a docker image to submit. It will be an entirely reproducible process as we will fix the versions of all the dependencies we use.</p>
<!--more-->
<h2 id="the-structure-of-the-artefact">The structure of the artefact</h2>
<p>In this example, I am going to package the artefact from the paper <a href="https://dl.acm.org/citation.cfm?id=3236780">“Generic Deriving of Generic Traversals”</a>. The artefact was a Haskell library and an executable which ran some benchmarks. The resulting artefact will be a docker image which contains:</p>
<ol type="1">
<li>The source code of the library</li>
<li>The source code for the benchmarks</li>
<li>The executable of the benchmarks</li>
<li>An environment where it is possible to compile the library and benchmarks</li>
</ol>
<p>To start with, I will assume that we have placed the source code and benchmarks code in our current directory. We will add the rest of the files</p>
<pre><code>&gt;&gt;&gt; ls
generic-lens-1.0.0.1/
benchmarks/</code></pre>
<h2 id="step-1-pinning-nixpkgs">Step 1: Pinning nixpkgs</h2>
<p>The most important step of the whole process is to “pin” our version of nixpkgs to a specific version so that anyone else trying to build the image will use the same versions of all the libraries and system dependencies.</p>
<p>Once we have established a commit of nixpkgs that out package builds with. We can use <code>nix-prefetch-git</code> in order to create <code>nixpkgs.json</code> which will provide the information about the pin.</p>
<pre><code>nix-prefetch-git --rev 651239d5ee66d6fe8e5e8c7b7a0eb54d2f4d8621 --url https://github.com/NixOS/nixpkgs.git &gt; nixpkgs.json</code></pre>
<p>Now we have a file, <code>nixpkgs.json</code> which specifies which version of nixpkgs we should use.</p>
<p>We then need to load this file. Some boilerplate, <code>nixpkgs.nix</code>, will do that for us.</p>
<pre><code>opts:
let
   hostPkgs = import &lt;nixpkgs&gt; {};
   pinnedVersion = hostPkgs.lib.importJSON ./nixpkgs.json;
   pinnedPkgs = hostPkgs.fetchFromGitHub {
     owner = &quot;NixOS&quot;;
     repo = &quot;nixpkgs&quot;;
     inherit (pinnedVersion) rev sha256;
   };
in import pinnedPkgs opts</code></pre>
<p><code>nixpkgs.nix</code> will be imported in <code>artefact.nix</code> and will determine precisely the version of all dependencies we will use.</p>
<h2 id="step-2-using-dockertools">Step 2: Using <code>dockerTools</code></h2>
<p>Now we have specified the set of dependencies we want to use we can go about starting to build our docker image. Nixpkgs provides a convenient set of functions called <code>dockerTools</code> in order to create docker images in a declarative manner. This is the start of our <code>artefact.nix</code> file.</p>
<pre><code>let
  pkgs = import ./nixpkgs.nix { };
in
with pkgs;
let
    debian = dockerTools.pullImage
      { imageName = &quot;debian&quot;
      ; imageTag = &quot;9.5&quot;
      ; sha256 = &quot;1jxci0ph7l5fh0mm66g4apq1dpcm5r7gqfpnm9hqyj7rgnh44crb&quot;; };
in
dockerTools.buildImage {
  name = &quot;generic-lens-artefact&quot;;

  fromImage = debian;

  contents = [  bashInteractive
                glibcLocales
             ];

  config = {
    Env = [&quot;LANG=en_US.UTF-8&quot;
           &quot;LOCALE_ARCHIVE=${glibcLocales}/lib/locale/locale-archive&quot;];
    WorkingDir = &quot;/programs&quot;;
  };
}</code></pre>
<p>This is the barebones example we’ll start from. We firstly import <code>nixpkgs.nix</code> which defines the package set we want to use. Our docker file will be based on <code>debian</code>, and so we use the <code>dockerTools.pullImage</code> function to get this base image. The <code>imageName</code> comes from docker hub and the <code>imageTag</code> indicates the specific tag.</p>
<p>This image is our base image when calling <code>dockerTools.buildImage</code>. For now, we add the basic packages <code>bashInteractive</code> and <code>glibcLocales</code>, in the next step we will add the specific contents that we need for our artefact.</p>
<p>Setting the <code>LANG</code> and <code>LOCALE_ARCHIVE</code> env vars is important for Haskell programs as otherwise you can run into strange encoding errors.</p>
<p>This is a complete image which can already be build with <code>nix-build artefact.nix</code>. The result will be a <code>.tar.gz</code> which can be loaded into docker and run as normal.</p>
<h2 id="step-3-including-the-artefact">Step 3: Including the artefact</h2>
<p>First we’ll deal with making the executable itself available on the image. Remember that the source code the the benchmarks, which is a normal Haskell package, is located in <code>benchmarks/</code>.</p>
<p>We need to tell nix how to build the benchmarks. The standard way to do this is to use <code>cabal2nix</code> to generate a package specification which we will pass to <code>haskellPackages.callPackage</code>.</p>
<pre><code>cabal2nix benchmarks/ &gt; benchmarks.nix</code></pre>
<p>This will produce a file which looks a bit like</p>
<pre><code>{ mkDerivation, base, criterion, deepseq, dlist, dump-core
, generic-lens, geniplate-mirror, haskell-src, lens, mtl, one-liner
, parallel, plugin, random, stdenv, syb, transformers, uniplate
, weigh
}:
mkDerivation {
  pname = &quot;benchmarks&quot;;
  version = &quot;0.1.0.0&quot;;
  src = ./benchmarks;
  isLibrary = false;
  isExecutable = true;
  executableHaskellDepends = [
    base criterion deepseq dlist dump-core generic-lens
    geniplate-mirror haskell-src lens mtl one-liner parallel plugin
    random syb transformers uniplate weigh
  ];
  license = stdenv.lib.licenses.bsd3;
}</code></pre>
<p>Now we will add the executable to the docker image. A new definition is created in the let bindings and then we add the executable to the <code>contents</code> of the image.</p>
<pre><code>run-benchmarks = haskellPackages.callPackage ./benchmarks.nix {};</code></pre>
<p>So now our <code>contents</code> section will look like:</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                ];</code></pre>
<p>When we build this image, the executable will be available on the path by default. In our case, the user will type <code>bench</code> and it will run the benchmarks.</p>
<h2 id="step-4-including-the-source-files">Step 4: Including the source files</h2>
<p>The next step is to add the source files to the image. To do this we use a the <code>runCommand</code> script to make a simple derivation which copies some files into the right place.</p>
<pre><code>benchmarks-raw = ./benchmarks;
benchmarks =
  runCommand &quot;benchmarks&quot; {} &#39;&#39;
  mkdir -p $out/programs
  mkdir -p $out/programs/benchmarks
  cp -r ${benchmarks-raw}/* $out/programs/benchmarks
&#39;&#39;;</code></pre>
<p>All the derivation does is copy the directory into the nix store at a specific path. We then just add this to the <code>contents</code> list again and also do the same for the library itself and the README.</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library];</code></pre>
<p>Now once we build the docker image, we’ll have the executable <code>bench</code> available and also a file called <code>README</code> and two folders containing the library code and benchmarks code.</p>
<h2 id="step-5-an-environment-to-build-the-source-code">Step 5: An environment to build the source code</h2>
<p>Finally, we need to do two more things to make it possible to build the source programs in the container.</p>
<p>Including <code>cabal-install</code> in the contents is the first so that we can use <code>cabal</code> in the container.</p>
<pre><code>  contents = [  bashInteractive
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library
                cabal-install ];</code></pre>
<p>The second is much less obvious, we need to make sure that the necessary dependencies are already installed in the environment so that someone can just use <code>cabal build</code> in order to build the package. The way to achieve this is to modify the <code>benchmarks.nix</code> file and change <code>isLibrary</code> to <code>true</code>.</p>
<pre><code>-  isLibrary = false;
+  isLibrary = true;</code></pre>
<p>This means that all the build inputs for the benchmarks are propagated to the container so all the dependencies for the benchmarks will be available to rebuild them again.</p>
<h2 id="complete-artefact.nix">Complete <code>artefact.nix</code></h2>
<p>Here’s the complete <code>artefact.nix</code> that we ended up with. We also generated <code>nixpkgs.json</code>, <code>nixpkgs.nix</code> and <code>benchmarks.nix</code> along the way.</p>
<pre><code>let
  pkgs = import ./nixpkgs.nix {};
in
with pkgs;
let
    debian = dockerTools.pullImage
      { imageName = &quot;debian&quot;
      ; imageTag = &quot;9.5&quot;
      ; sha256 = &quot;1y4k42ljf6nqxfq7glq3ibfaqsq8va6w9nrhghgfj50w36bq1fg5&quot;; };

    benchmarks-raw = ./benchmarks;
    benchmarks =
      runCommand &quot;benchmarks&quot; {} &#39;&#39;
        mkdir -p $out/programs
        mkdir -p $out/programs/benchmarks
        cp -r ${benchmarks-raw}/* $out/programs/benchmarks
      &#39;&#39;;

    library-raw = ./generic-lens-1.0.0.1;
    library =
      runCommand &quot;benchmarks&quot; {} &#39;&#39;
        mkdir -p $out/programs
        mkdir -p $out/programs/library
        cp -r ${library-raw}/* $out/programs/library
      &#39;&#39;;

    readme-raw = ./README;
    readme =
      runCommand &quot;readme&quot; {} &#39;&#39;
        mkdir -p $out/programs
        cp ${readme-raw} $out/programs/README
      &#39;&#39;;

    run-benchmarks = haskellPackages.callPackage ./benchmarks.nix {};

in
dockerTools.buildImage {
  name = &quot;generic-lens-artefact&quot;;


  fromImage = debian;

  contents = [  bashInteractive
                cabal-install
                glibcLocales
                run-benchmarks
                benchmarks
                readme
                library];

  config = {
    Env = [&quot;LANG=en_US.UTF-8&quot;
           &quot;LOCALE_ARCHIVE=${glibcLocales}/lib/locale/locale-archive&quot;];
    WorkingDir = &quot;/programs&quot;;
  };
}</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully this tutorial will be useful for anyone having to package a Haskell library in future. Each artefact is different so you’ll probably have to modify some of the steps in order to make it work perfectly for you. It’s also possible that the <code>dockerTools</code> interface will change but it should be possible to modify the examples here to adapt to any minor changes. If you’re already using nix, you probably know what you’re doing anyway.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/">Quick and Easy Nixpkgs Pinning - Vaibhav Sagar</a></li>
<li><a href="https://nixos.org/nixpkgs/manual/#sec-pkgs-dockerTools"><code>dockerTools</code> documentation</a></li>
<li><a href="https://www.software.ac.uk/blog/2017-10-05-reproducible-environments-nix">Reproducible Environments With Nix - Blair Archibald</a></li>
<li>Reddit comments</li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Using funflow to cache a nix based workflow</title>
    <link href="http://mpickering.github.io/posts/2018-09-12-funflow-nix.html" />
    <id>http://mpickering.github.io/posts/2018-09-12-funflow-nix.html</id>
    <published>2018-09-12T00:00:00Z</published>
    <updated>2018-09-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Using funflow to cache a nix based workflow </h2>
<p class="text-muted">
    Posted on September 12, 2018
    
</p>

<p>My latest project has been to plot a <a href="http://mpickering.github.io/maps.html">map of orienteering maps</a> in the UK. This post explains the technical aspects behind the project and primarily the use of <a href="https://hackage.haskell.org/package/funflow"><code>funflow</code></a> to turn my assortment of scripts into into a resumable workflow.</p>
<p>There was nothing wrong with my ad-hoc python and bash scripts but they downloaded and regenerated the whole output every time. The whole generation takes about 2 hours so it’s desirable to only recompute the necessary portions. This is where <code>funflow</code> comes in, by stringing together these scripts in their DSL, you get caching for free. The workflow is also highly parallelisable so in the future I could distribute the work across multiple machines if necessary.</p>
<p>The code for the project can be found <a href="https://github.com/mpickering/rg-map">here</a>.</p>
<p><img src="https://i.imgur.com/NVLui01.png" style="width: 50%; margin: auto; display: block" /></p>
<!--more-->
<h2 id="funflow"><code>funflow</code></h2>
<p>There are already two blog posts introducing the concepts of <code>funflow</code>.</p>
<ol type="1">
<li><a href="https://www.tweag.io/posts/2018-04-25-funflow.html">Funflow: Typed Resumable Workflows</a></li>
<li><a href="https://www.tweag.io/posts/2018-07-10-funflow-make.html">Funflow Example: Emulating Make</a></li>
</ol>
<p>The main idea is that you specify your workflow (usually a sequence of external scripts) using a DSL and then <code>funflow</code> will automatically cache and schedule the steps.</p>
<p>My primary motivation for using <code>funflow</code> was the automatic caching. The store is content addressed which means that the location for each file in the store depends on its contents. <code>funflow</code> performs two different types of caching.</p>
<ol type="1">
<li>Input-based caching: A flow will only be executed once for each set of inputs.</li>
<li>Output-based caching: If multiple different steps produce the same output then it will only be stored once in the store. Further steps will not be recomputed.</li>
</ol>
<p>The lack of output-based caching is one of the big missing features of nix which makes it unsuitable for this task. A content-addressed store where the address depends on the contents of the file is sometimes known as an <strong>intensional</strong> store. Nix’s store model is <strong>extensional</strong> as the store hash only depends on the inputs to the build.</p>
<p>An intensional store relies on the program producing deterministic output hashes. It can be quite difficult to track down why a step is not being cached when you are relying on the output’s being identified in the store.</p>
<h2 id="high-level-architecture">High-level architecture</h2>
<p>There are two outputs to the project.</p>
<ol type="1">
<li>A folder of map tiles rendered at different resolutions.</li>
<li>A HTML page which contains the javascript to display the map and markers.</li>
</ol>
<p>This folder is then uploaded to online storage and served as a static site.</p>
<p>The processing pipeline is as follows:</p>
<ol type="1">
<li>Find all the maps with location information from <a href="http://www.routegadget.co.uk/">routegadget.co.uk</a>.</li>
<li>Download the metainformation and map image for each map.</li>
<li>Convert the maps to a common image format.</li>
<li>Reproject the maps to remove any rotation.</li>
<li>Merge overlapping maps into groups.</li>
<li>Generate tiles at all the different resolutions.</li>
<li>Combine all the tiles groups together.</li>
<li>Generate the website with the map and location markers.</li>
</ol>
<p>As can be seen, the workflow is firstly highly parallelisable as much of the processing pipeline happens independently of other steps. However, the main goal is to avoid computing the tiles as much as possible as this is the step which takes by far the longest. At the time of writing there are about 500 maps to process. In general, there are about 5-10 maps added each week. Only recomputing the changed portions of the map saves a lot of time.</p>
<h2 id="implementation-using-funflow">Implementation using <code>funflow</code></h2>
<p>In theory, this is a perfect application for <code>funflow</code> but in order to achieve the perfect caching behaviour I had to rearchitecture several parts of the application.</p>
<h3 id="using-nix-scripts">Using nix scripts</h3>
<p>The recommended way to use <code>funflow</code> is to run each step of the flow in a docker container. I didn’t want to do this was my scripts already declared the correct environment to run in by using the <a href="http://iam.travishartwell.net/2015/06/17/nix-shell-shebang/"><code>nix-shell</code> shebang</a>.</p>
<pre><code>#! /usr/bin/env nix-shell
#! nix-shell -i bash -p gdal</code></pre>
<p>By placing these two lines at the top of the file, the script will be run using the <code>bash</code> interpreter with the <code>gdal</code> package available. This is more lightweight and flexible than using a docker image as I don’t have to regenerate a new docker image any time I make a change.</p>
<p>However, there is no native support for running these kinds of scripts built into <code>funflow</code>. It was easy enough to define my own function in order to run these kinds of scripts using the <code>external'</code> primitive.</p>
<p><code>nixScript</code> takes a boolean parameter indicating whether the script is pure and should be cached. The name of the script to run, the names of any files the script depends on and finally a function which supplies any additional arguments to the script.</p>
<pre><code>nixScriptX :: ArrowFlow eff ex arr =&gt; Bool
                                   -&gt; Path Rel File
                                   -&gt; [Path Rel File]
                                   -&gt; (a -&gt; [Param])
                                   -&gt; arr (Content Dir, a) CS.Item
nixScriptX impure script scripts params = proc (scriptDir, a) -&gt; do
  env &lt;- mergeFiles -&lt; absScripts scriptDir
  external&#39; props (\(s, args) -&gt; ExternalTask
        { _etCommand = &quot;perl&quot;
        , _etParams = contentParam (s ^&lt;/&gt; script) : params args
        , _etWriteToStdOut = NoOutputCapture
        , _etEnv = [(&quot;NIX_PATH&quot;, envParam &quot;NIX_PATH&quot;)] }) -&lt; (env, a)
  where
    props = def { ep_impure = impure }
    absScripts sd = map (sd ^&lt;/&gt;) (script : scripts)</code></pre>
<p>The use of <code>perl</code> as the command relies on <a href="http://perldoc.perl.org/perlrun.html">the behaviour</a> of <code>perl</code> that it will execute the <code>#!</code> line if it does not contain the word “perl”. Yes, this <a href="https://askubuntu.com/questions/850384/is-there-a-command-for-running-a-script-according-to-its-shebang-line/850387">is dirty</a>.</p>
<p>It would be desirable to set <code>NIX_PATH</code> to a fixed <code>nixpkgs</code> checkout by passing a tarball directly but this worked for now.</p>
<p>All the steps are then defined in terms of <code>nixScriptX</code> indirectly as two helper functions are defined for the two cases of a pure or impure scripts.</p>
<pre><code>nixScript = nixScriptX False
impureNixScript = nixScriptX True</code></pre>
<h2 id="step-1---finding-the-map-information">Step 1 - Finding the map information</h2>
<p>Now to the nitty gritty details.</p>
<p>Firstly, I had to decouple the processing of finding the map metainformation from downloading the image. Otherwise, I would end up doing a lot of redundant work downloading images multiple times.</p>
<p>The python script <code>scraper.py</code> executes a selenium driver to extract the map information. For each map, the metainformation is serialised to its own file in the output directory.</p>
<pre><code>scrape = impureNixScript [relfile|scraper.py|] [[relfile|shell.nix|]]
          (\() -&gt; [ outParam ])</code></pre>
<p>This step is marked as impure as we have to run it every time the flow runs to work out if we need to perform any more work.</p>
<p>It is important that the filename of the serialised information is the same if the content of the file is the same. Otherwise, <code>funflow</code> will calculate a different hash for the file. As such, we compute our own hash of the metainformation for the name the serialised file.</p>
<p>In the end the output directory looks like:</p>
<pre><code>9442c7eaa81f82f7e9889f6ee8382e8d047df76db2d5f6a6983d1c82399a2698.pickle
5e7e6994db565126a942d66a9435454d8b55cd7d3023dd37f64eca7bbb46df1f.pickle
...</code></pre>
<h3 id="gotcha-1-using-listdircontents-defeats-caching">Gotcha 1: Using <code>listDirContents</code> defeats caching</h3>
<p>Now that we have a directory containing all the metainformation, we want to split it up and then execute the fetching, converting and warping in parallel for all the images. My first attempt was</p>
<pre><code>meta_dir &lt;- step All &lt;&lt;&lt; scrape -&lt; (script_dir, ())
keys &lt;- listDirContents -&lt; meta_dir</code></pre>
<p>but this did not work and even if the keys remained the same, the images would be refetched. The problem was <a href="https://hackage.haskell.org/package/funflow-1.3.2/docs/Control-Funflow-Steps.html#v:listDirContents"><code>listDirContents</code></a> does not have the correct caching behaviour.</p>
<p><code>listDirContents</code> takes a <code>Content Dir</code> and returns a <code>[Content File]</code> as required but the <code>[Content File]</code> are pointers into places into the <code>Content Dir</code>. This means that if the location of <code>Content Dir</code> changes (if there are any changes or new additions to any files in the directory) then the location of <em>all</em> the <code>[Content File]</code> will also be changed. This means the next stage of recompilation will be triggered despite being unnecessary.</p>
<p>Instead, we have to put each file in the directory into its own store location so that the its location depends only on itself rather than the other contents of the directory. I defined the <code>splitDir</code> combinator in order to do this.</p>
<pre><code>splitDir :: ArrowFlow eff ex arr =&gt; arr (Content Dir) ([Content File])
splitDir = proc dir -&gt; do
  (_, fs) &lt;- listDirContents -&lt; dir
  mapA reifyFile -&lt; fs


-- Put a file, which might be a pointer into a dir, into its own store
-- location.
reifyFile :: ArrowFlow eff ex arr =&gt; arr (Content File) (Content File)
reifyFile = proc f -&gt; do
  file &lt;- getFromStore return -&lt; f
  putInStoreAt (\d fn -&gt; copyFile fn d) -&lt; (file, CS.contentFilename f)</code></pre>
<p>It could be improved by using a hardlink rather than <code>copyFile</code>.</p>
<h2 id="step-2-download-convert-and-warp">Step 2: Download, convert and warp</h2>
<p>Now we have split the metainformation up into individual components we have to download, convert and warp the map files.</p>
<p>We define three flows to do this which correspond to three different scripts.</p>
<pre><code>fetch = nixScript [relfile|fetch.py|] [[relfile|shell.nix|]]
          (\metadata -&gt; [ outParam, contentParam metadata ])

convertToGif = nixScript [relfile|convert_gif|] []
                (\dir -&gt; [ pathParam (IPItem dir), outParam ])

warp = nixScript [relfile|do_warp|] []
        (\dir -&gt; [ pathParam (IPItem dir), outParam ])</code></pre>
<p>Each script takes an individual input file and produces output in a directory specified by <code>funflow</code>.</p>
<p><code>fetch.py</code> is a python script whilst <code>convert_gif</code> and <code>do_warp</code> are bash scripts. We can treat them uniformly because of the <code>nix-shell</code> shebang.</p>
<p>These steps are all cached by default because they are external processes.</p>
<h2 id="step-3-merge-the-images-together">Step 3: Merge the images together</h2>
<p>In order to get a good looking result, we need to group together the processed images into groups of overlapping images. This time we will use a python script again invoked in a similar manner. The output is a directory of files which specify the groups, remember:</p>
<ol type="1">
<li>We have to be careful naming the files so that the names remain stable across compilation. In my original program the names were supplied by a counter but now they are the hash of the files which were used to create the group.</li>
<li>We have to use <code>splitDir</code> after creating the output to put each group file into it’s own store location so the next recompilation step will work.</li>
</ol>
<pre><code>mergeRasters = nixScript [relfile|merge-rasters.py|] [[relfile|merge-rasters.nix|]]
                (\rs -&gt; outParam : map contentParam rs )</code></pre>
<p>This command also relies on <code>merge-rasters.nix</code> which sets up the correct python environment to run the script.</p>
<h3 id="gotcha-2-mergedirs-can-also-defeat-caching">Gotcha 2: <code>mergeDirs</code> can also defeat caching</h3>
<p>The original implementation of this used <code>mergeDirs :: arr [Content File] (Content Dir)</code> in order to group together the files and pass a single directory to <code>merge-rasters.py</code>.</p>
<p>However, this suffers a similar problem to <code>listDirContents</code> as <code>mergeDirs</code> will create a new content store entry which contains all the files in the merge directories. The hash of this store location will then depend on the whole contents of the directory. In this case these file paths ended up in the output so it would cause the next steps to recompile even if nothing had changed.</p>
<p>In this case, we would prefer a “logical” group which groups the files together with a stable filename which wouldn’t affect caching.</p>
<p>The workaround for now was to use <code>splitDir</code> again to put each processed image into its own storage path and then pass each filename individually to <code>merge-rasters.py</code> rather than a directory as before.</p>
<h2 id="step-4-making-the-tiles">Step 4: Making the tiles</h2>
<p>Making the tiles is another straightforward step which takes each of the groups and makes the necessary tiles for that group.</p>
<pre><code>makeTiles = nixScript [relfile|make_tiles|] [] (\dir -&gt; [ contentParam dir, outParam, textParam &quot;16&quot; ])</code></pre>
<h3 id="gotcha-3-mergedirs-doesnt-merge-duplicate-files">Gotcha 3: <code>mergeDirs</code> doesn’t merge duplicate files</h3>
<p>Once we have made all the tiles we need to merge them all together. This is safe as we already ensured that they didn’t overlap each other. The problem is that <code>mergeDirs</code> will not merge duplicate files. The <code>make_tiles</code> step creates some unnecessary files which we don’t need but would cause <code>mergeDirs</code> to fail as they are contained in the output of each directory.</p>
<p>The solution was to write my own version of <code>mergeDirs</code> which checks to see whether a file already exists before trying to merge it. It would be more hygienic to ensure that the directories I was trying to merge were properly distinct but this worked well for this use case.</p>
<h2 id="step-5-creating-the-static-site">Step 5: Creating the static site</h2>
<p>Our final script is a python script which creates the static site displaying all the markers and the map tiles. It takes the output of processing all the images and the metainformation to produce a single html file.</p>
<pre><code>leaflet &lt;- step All &lt;&lt;&lt; makeLeaflet -&lt; ( script_dir, (merge_dir, meta_dir))</code></pre>
<p>The final step then merges together the static page and all the tiles. This is a nice bundle we can directly upload and serve our static site.</p>
<pre><code>mergeDirs -&lt; [leaflet, tiles]</code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The complete flow is shown below:</p>
<pre><code>mainFlow :: SimpleFlow () (Content Dir)
mainFlow = proc () -&gt; do
  cwd &lt;- stepIO (const getCurrentDir) -&lt; ()
  script_dir &lt;- copyDirToStore -&lt; (DirectoryContent (cwd &lt;/&gt; [reldir|scripts/|]), Nothing)

	# Step 1
  meta_dir &lt;- step All &lt;&lt;&lt; scrape -&lt; (script_dir, ())
  keys &lt;- splitDir -&lt; meta_dir
	# Step 2
  maps &lt;- mapA (fetch) -&lt; [( script_dir, event) | event &lt;- keys]
  mapJpgs &lt;- mapA convertToGif -&lt; [(script_dir, m) | m &lt;- maps]
  merge_dir &lt;- mergeDirs&#39; &lt;&lt;&lt; mapA (step All) &lt;&lt;&lt; mapA warp -&lt; [(script_dir, jpg) | jpg &lt;- mapJpgs ]
  toMerge &lt;- splitDir -&lt; merge_dir
	# Step 3
  vrt_dir &lt;- step All &lt;&lt;&lt; mergeRasters -&lt; (script_dir, toMerge)
  merged_vrts &lt;- splitDir -&lt; vrt_dir
	# Step 4
  tiles &lt;- mergeDirs&#39; &lt;&lt;&lt; mapA (step All) &lt;&lt;&lt; mapA makeTiles -&lt; [(script_dir, vrt) | vrt &lt;- merged_vrts]

	# Step 5
  leaflet &lt;- step All &lt;&lt;&lt; makeLeaflet -&lt; ( script_dir, (merge_dir, meta_dir))

  mergeDirs -&lt; [leaflet, tiles]</code></pre>
<p>Once all the kinks are ironed out – it’s quite short but a very powerful specification which avoids a lot of redundant work being carried out.</p>
<h3 id="gotcha-4-copydirtostore-can-defeat-caching">Gotcha 4: <code>copyDirToStore</code> can defeat caching</h3>
<p>Using <code>copyDirToStore</code> seems much more convenient than copying each script into the store manually but it can again have confusing caching behaviour. The hash of the store location for <code>script_dir</code> depends on the whole <code>script_dir</code> directory. If you change any file in the directory then the hash of it will change. This means that all steps will recompile if you modify any script!</p>
<p>This is the reason for the <code>mergeFiles</code> call in <code>nixScriptX</code>. <code>mergeFiles</code> will take the necessary files from <code>script_dir</code> and put them into their own store directory. The hash of this directory will only depend on the files necessary for that step.</p>
<h2 id="running-the-flow">Running the flow</h2>
<p>The flow is run with the simple local runner. We pass in a location for the local store to the runner which is just a local directory in this case. The library has support for more complicated runners but I haven’t explored using those yet.</p>
<pre><code>main :: IO ()
main = do
    cwd &lt;- getCurrentDir
    r &lt;- withSimpleLocalRunner (cwd &lt;/&gt; [reldir|funflow-example/store|]) $ \run -&gt;
      run (mainFlow &gt;&gt;&gt; storePath) ()
    case r of
      Left err -&gt;
        putStrLn $ &quot;FAILED: &quot; ++ displayException err
      Right out -&gt; do
        putStrLn $ &quot;SUCCESS&quot;
        putStrLn $ toFilePath out</code></pre>
<h3 id="displaying-the-outpath">Displaying the outpath</h3>
<p>A nice feature of <code>nix-build</code> is that it displays the path of the final output in the nix store once the build has finished. This is possible to replicate using <code>funflow</code> after defining your own combinator. It would be good to put this in the standard library.</p>
<pre><code>storePath :: ArrowFlow eff ex arr =&gt; arr (Content Dir) (Path Abs Dir)
storePath = getFromStore return</code></pre>
<p>It means that we can run our flow and deploy the site in a single command given we have a script which performs the deployment given an output path.</p>
<p>Mine looks a bit like:</p>
<pre><code>#! /usr/bin/env nix-shell
#! nix-shell -i bash -p awscli
if [[ $# -eq 0 ]] ; then
     echo &#39;Must pass output directory&#39;
     exit 1
fi
aws s3 sync $1 s3://&lt;bucket-name&gt;</code></pre>
<p>Putting them together:</p>
<pre><code>cabal new-run | ./upload-s3</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>Once everything is set up properly, <code>funflow</code> is a joy to use. It abstracts beautifully away from the annoying problems of scheduling and caching leaving the core logic visible. An unfortunate consequence of the intensional store model is that debugging why a build step is not being cached can be very time consuming and fiddly. When I explain the problems I faced, they are obvious but each one required careful thought and reading the source code to understand the intricacies of each of the different operations.</p>
<p>It was also very pleasant to combine using <code>nix</code> and <code>funflow</code> rather than the suggested <code>docker</code> support.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="http://mpickering.github.io/maps.html">Map of orienteering maps</a></li>
<li><a href="https://github.com/mpickering/rg-map">Source code</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/9f7kq9/using_funflow_to_cache_a_nix_based_workflow/">Reddit comments</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Specifying how a plugin affects recompilation</title>
    <link href="http://mpickering.github.io/posts/2018-08-10-plugins-recompilation.html" />
    <id>http://mpickering.github.io/posts/2018-08-10-plugins-recompilation.html</id>
    <published>2018-08-10T00:00:00Z</published>
    <updated>2018-08-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Specifying how a plugin affects recompilation </h2>
<p class="text-muted">
    Posted on August 10, 2018
    
</p>

<p>Plugins have existed for a long time in GHC. The first plugins were implemented in <a href="http://blog.omega-prime.co.uk/2008/06/15/compiler-plugins-for-ghc-the-first-week/">2008</a> by Max Bolingbroke. They enabled users to modify the optimisation pipeline. They ran after desugaring and hence were called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#core-plugins-in-more-detail">“core” plugins</a>. Later, Adam Gundry implemented what I shall refer to as <a href="http://adam.gundry.co.uk/pub/typechecker-plugins/">“constraint solver” plugins</a> which allow users to provide custom solver logic to solve additional constraints. Recently, Boldizsár Németh has extended the number of extension points again with a set of plugins which can inspect and modify the syntax AST. Plugins can run after parsing, renaming or type checking and hence are called <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">“source” plugins</a>.</p>
<p>The idea behind plugins was great - a user can extend the compiler in their own specific way without having to modify the source tree and rebuild the compiler from scratch. It is far more convenient to write a plugin than to use a custom compiler. However, if a user wants to use a plugin, they will find that every module where the plugin is enabled is always recompiled, even if the source code didn’t change at all. Why is this? Well, a plugin can do anything, it could read the value from a temperature sensor and insert the room temperature into the program. Thus, we would always need to recompile a module if the temperature reading changed as it would affect what our program did.</p>
<p>However, there are also “pure” plugins, whose output is only affected by the program which is passed as in input. For these plugins, if the source code doesn’t change then we don’t need to do any recompilation.</p>
<p>This post is about a new metadata field which I added to the <code>Plugin</code> data type which specifies how a plugin should affect recompilation. This feature will be present in GHC 8.6.</p>
<!--more-->
<h1 id="controlling-recompilation">Controlling Recompilation</h1>
<p>The <code>Plugin</code> data type is a record which contains a field for each of the different types of plugin. There is now also a new field <code>pluginRecompile</code> which specifies how the plugin should affect recompilation.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Plugin</span> {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  installCoreToDos ::</span> <span class="dt">CorePlugin</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> tcPlugin ::</span> <span class="dt">TcPlugin</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  , parsedResultAction</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">    ::</span> [<span class="dt">CommandLineOption</span>] <span class="ot">-&gt;</span> <span class="dt">ModSummary</span> <span class="ot">-&gt;</span> <span class="dt">HsParsedModule</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">                                         <span class="ot">-&gt;</span> <span class="dt">Hsc</span> <span class="dt">HsParsedModule</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="fu">...</span> omitted fields</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  ,<span class="ot"> pluginRecompile ::</span> [<span class="dt">CommandLineOpts</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">PluginRecompile</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">}</a></code></pre></div>
<p>This function will be run during the recompilation check which happens at the start of every module compilation. It returns a value of the <code>PluginRecompile</code> data type.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">PluginRecompile</span> <span class="fu">=</span> <span class="dt">PurePlugin</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                     <span class="fu">|</span> <span class="dt">ImpurePlugin</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                     <span class="fu">|</span> <span class="dt">MaybeRecompile</span> <span class="dt">Fingerprint</span></a></code></pre></div>
<p>There are three different ways to specify how a plugin affects recompilation.</p>
<ol type="1">
<li><code>PurePlugin</code> which means that it doesn’t contribute anything to the recompilation check. We will only recompile a module if we would normally recompile it.</li>
<li><code>ImpurePlugin</code> which means that should always recompile a module. This is the default as it is backwards compatible.</li>
<li><code>MaybeRecompile</code>, we compute a <code>Fingerprint</code> which we add to the recompilation check to decide whether we should recompile.</li>
</ol>
<h2 id="library-functions">Library Functions</h2>
<p>The <code>Plugins</code> interface provides some library functions for common configurations.</p>
<p>We might want to use <code>impurePlugin</code> when our plugin injects some additional impure information into the program such as the result of reading a webpage.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">impurePlugin ::</span> [<span class="dt">CommandLineOpts</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">PluginRecompile</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">impurePlugin _ <span class="fu">=</span> return <span class="dt">ImpurePlugin</span></a></code></pre></div>
<p>The <code>purePlugin</code> function is useful for static analysis tools which don’t modify the source program at all and just output information. Other plugins which modify the source program in a predictable manner such as the <code>ghc-typelits-natnormalise</code> plugin should also be marked as pure.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">purePlugin ::</span> [<span class="dt">CommandLineOpts</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">PluginRecompile</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">purePlugin _args <span class="fu">=</span> return <span class="dt">NoForceRecompile</span></a></code></pre></div>
<p>If you have some options which affect the output of the plugin then you might want to use the <code>flagRecompile</code> option which causes recompilation if any of the plugin flags change.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">flagRecompile ::</span> [<span class="dt">CommandLineOption</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">PluginRecompile</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">flagRecompile <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  return <span class="fu">.</span> <span class="dt">MaybeRecompile</span> <span class="fu">.</span> fingerprintFingerprints</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="fu">.</span> map fingerprintString <span class="fu">.</span> sort</a></code></pre></div>
<p>The nature of this interface is that it is sometimes necessary to be overly conservative when specifying recompilation behaviour. For example, you can’t decide on a per-module basis whether to recompile or not. Perhaps the interface could be extended with this information if user’s found it necessary.</p>
<h1 id="conclusion">Conclusion</h1>
<p>There is now a simple mechanism for controlling how plugins should affect recompilation. This solves one of the major problems that large scale usage of plugins has faced. Using a plugin on a 1000 module code base was impractical but now shouldn’t impose any additional inconvenience.</p>
<h1 id="related-links">Related Links</h1>
<ul>
<li><a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#controlling-recompilation">GHC User’s Guide</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/967o6k/specifying_how_a_plugin_affects_recompilation/">Reddit comments</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Reimplementing graphmod as a source plugin: graphmod-plugin</title>
    <link href="http://mpickering.github.io/posts/2018-08-09-source-plugin-graphmod.html" />
    <id>http://mpickering.github.io/posts/2018-08-09-source-plugin-graphmod.html</id>
    <published>2018-08-09T00:00:00Z</published>
    <updated>2018-08-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Reimplementing graphmod as a source plugin: graphmod-plugin </h2>
<p class="text-muted">
    Posted on August  9, 2018
    
</p>

<p>You may have heard about <a href="http://mpickering.github.io/ghc-docs/build-html/users_guide/extending_ghc.html#source-plugins">source plugins</a> by now. They allow you to modify and inspect the compiler’s intermediate representation. This is useful for extending GHC and performing static analysis of Haskell programs.</p>
<p>In order to test them out, I reimplemented the <a href="https://github.com/yav/graphmod"><code>graphmod</code></a> tool as a source plugin. <code>graphmod</code> generates a graph of the module structure of your package. Reimplementing it as a source plugin makes the implementation more robust. I implemented it as as a type checker plugin which runs after type checking has finished. The result: <a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a></p>
<figure>
<img src="https://raw.githubusercontent.com/yav/graphmod/master/screenshots/aeson1.dot.png" alt="An example of the structure of the aeson package" /><figcaption>An example of the structure of the <code>aeson</code> package</figcaption>
</figure>
<!--more-->
<h1 id="architecture">Architecture</h1>
<p>The plugin runs once at the end of type checking for each module. Therefore, if we want to collate information about multiple modules, we must first serialise the information we want and then once all the modules have finished compiling collect all serialised files and process the information.</p>
<p>We will therefore first define a plugin which extracts all the import information from one module before defining the suitable executable which collects all the import information and produces the final output graph.</p>
<p><code>graphmod-plugin</code> consists of a library which exports the plugin and an executable which is then invoked to render the information. Here is how to directly use the two in tandem:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># Run the plugin on the source file</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">ghc</span> -fplugin=GraphMod -fplugin-opt:GraphMod:/output/dir</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co"># Collect the information which was produced</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ex">graphmod-plugin</span> --indir /output/dir <span class="op">&gt;</span> modules.dot</a></code></pre></div>
<p>Once the dot file has been generated, you can use the normal graphviz utilities to render the file.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">cat</span> modules.dot <span class="kw">|</span> <span class="ex">tred</span> <span class="kw">|</span> <span class="ex">dot</span> -Tpdf <span class="op">&gt;</span> modules.pdf</a></code></pre></div>
<p><code>tred</code> removes transitive edges from the graph before we render the graph as a pdf.</p>
<h1 id="the-plugin">The plugin</h1>
<p>A type checker plugin is a function of the following type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">sourcePlugin ::</span> [<span class="dt">CommandLineOpts</span>] <span class="ot">-&gt;</span> <span class="dt">ModSummary</span> <span class="ot">-&gt;</span> <span class="dt">TcGblEnv</span> <span class="ot">-&gt;</span> <span class="dt">TcM</span> <span class="dt">TcGblEnv</span></a></code></pre></div>
<p>The <code>TcGblEnv</code> is the output of the type checker, it contains all the type checked bindings in addition to lots of other useful information. We are interested in just the imports, these are located in the <code>tcg_rn_imports</code> field.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">tcg_rn_imports ::</span> [<span class="dt">LImportDecl</span> <span class="dt">GhcRn</span>]</a></code></pre></div>
<p>An <code>LImportDecl GhcRn</code> is a data type which contains information about each import.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- GHC data types</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">type</span> <span class="dt">LImportDecl</span> pass <span class="fu">=</span> <span class="dt">Located</span> (<span class="dt">ImportDecl</span> pass)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">ImportDecl</span> pass</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">ImportDecl</span> {</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">      ideclExt       ::</span> <span class="dt">XCImportDecl</span> pass,</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">      ideclSourceSrc ::</span> <span class="dt">SourceText</span>,</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">      ideclName      ::</span> <span class="dt">Located</span> <span class="dt">ModuleName</span>, <span class="co">-- ^ Module name.</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">      ideclPkgQual   ::</span> <span class="dt">Maybe</span> <span class="dt">StringLiteral</span>,  <span class="co">-- ^ Package qualifier.</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="ot">      ideclSource    ::</span> <span class="dt">Bool</span>,          <span class="co">-- ^ True &lt;=&gt; {-\# SOURCE \#-} import</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">      ideclSafe      ::</span> <span class="dt">Bool</span>,          <span class="co">-- ^ True =&gt; safe import</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="ot">      ideclQualified ::</span> <span class="dt">Bool</span>,          <span class="co">-- ^ True =&gt; qualified</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="ot">      ideclImplicit  ::</span> <span class="dt">Bool</span>,          <span class="co">-- ^ True =&gt; implicit import (of Prel</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">ude)</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">      ideclAs        ::</span> <span class="dt">Maybe</span> (<span class="dt">Located</span> <span class="dt">ModuleName</span>),  <span class="co">-- ^ as Module</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="ot">      ideclHiding    ::</span> <span class="dt">Maybe</span> (<span class="dt">Bool</span>, <span class="dt">Located</span> [<span class="dt">LIE</span> pass])</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">                                       <span class="co">-- ^ (True =&gt; hiding, names)</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    }</a></code></pre></div>
<p>Along with the module name, there is lots of meta information about other aspects of the import such as whether it was qualified and so on. Our plugin will take this information and convert it into the format expected by the existing <code>graphmod</code> library.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot"># Graphmod data types</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Import</span> <span class="fu">=</span> <span class="dt">Import</span> {<span class="ot"> impMod ::</span> <span class="dt">ModName</span>,<span class="ot"> impType ::</span> <span class="dt">ImpType</span> }</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">data</span> <span class="dt">ImpType</span> <span class="fu">=</span> <span class="dt">NormalImp</span> <span class="fu">|</span> <span class="dt">SourceImp</span></a></code></pre></div>
<p>The <code>graphmod</code> <code>Import</code> data type is a simplified version of <code>ImportDecl</code>. It’s straightforward to extract the information we need. Notice how much simpler this approach is than the approach taken in the original library which uses a lexer to try to identify textually the position of the imports.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">convertImport ::</span> <span class="dt">ImportDecl</span> <span class="dt">GhcRn</span> <span class="ot">-&gt;</span> <span class="dt">GraphMod.Import</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">convertImport (<span class="dt">ImportDecl</span>{<span class="fu">..</span>}) <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="dt">GraphMod.Import</span> { impMod <span class="fu">=</span> convertModName (ideclName)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                  , impType <span class="fu">=</span> <span class="kw">if</span> ideclSource</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">                                <span class="kw">then</span> <span class="dt">GraphMod.SourceImp</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">                                <span class="kw">else</span> <span class="dt">GraphMod.NormalImp</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">                  }</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="ot">convertModName ::</span> <span class="dt">Located</span> <span class="dt">ModuleName</span> <span class="ot">-&gt;</span> <span class="dt">GraphMod.ModName</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">convertModName (<span class="dt">L</span> _ mn) <span class="fu">=</span> GraphMod.splitModName (moduleNameString mn)</a></code></pre></div>
<p>Notice that it is also possible to extend the <code>GraphMod.Import</code> data type to contain new information easily. In the previous implementation this would be much more effort as the lexing approach is fragile.</p>
<h1 id="serialisation">Serialisation</h1>
<p>Once we have gathered this information we need to serialise it and write it to disk so that once we have compiled all the modules we can deserialise it and render the final graph.</p>
<p>As we are using GHC, we can use the same serialisation machinery as GHC uses to write interface files. Of course, you are free to use whatever serialisation library you like but there are already instances defined for GHC specific types. We won’t need any of them in this example but they can be useful. The <code>writeBinary</code> function takes a value serialisable by the <code>GHC.Binary</code> class and writes it to the file.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Binary</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">initBinMemSize ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">initBinMemSize <span class="fu">=</span> <span class="dv">1024</span> <span class="fu">*</span> <span class="dv">1024</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="ot">writeBinary ::</span> <span class="dt">Binary</span> a <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">writeBinary path payload <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  bh <span class="ot">&lt;-</span> openBinMem initBinMemSize</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  put_ bh payload</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  writeBinMem bh path</a></code></pre></div>
<p>We also needed to write some simple <code>Binary</code> instances by hand in order to do the serialisation.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">GraphMod.Import</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  put_ bh (<span class="dt">GraphMod.Import</span> mn ip) <span class="fu">=</span> put_ bh mn <span class="fu">&gt;&gt;</span> put_ bh ip</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  get bh <span class="fu">=</span> <span class="dt">GraphMod.Import</span> <span class="fu">&lt;$&gt;</span> get bh <span class="fu">&lt;*&gt;</span> get bh</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">GraphMod.ImpType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  put_ bh c <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      <span class="dt">GraphMod.NormalImp</span> <span class="ot">-&gt;</span> putByte bh <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="dt">GraphMod.SourceImp</span> <span class="ot">-&gt;</span> putByte bh <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  get bh <span class="fu">=</span> getByte bh  <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">                      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">GraphMod.NormalImp</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">                      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">GraphMod.SourceImp</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">                      _ <span class="ot">-&gt;</span> error <span class="st">&quot;Binary:GraphMod&quot;</span></a></code></pre></div>
<h1 id="plugin-description">Plugin Description</h1>
<p>Once we have these parts, we can assemble them into the final plugin. We first get the imports out of <code>tcg_rn_imports</code> and then convert them using <code>convertImport</code>. We then write this information to a uniquely named file in the output directory which is passed as an argument to the plugin.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- The main plugin function, it collects and serialises the import</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- information for a module.</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">install ::</span> [<span class="dt">CommandLineOption</span>] <span class="ot">-&gt;</span> <span class="dt">ModSummary</span> <span class="ot">-&gt;</span> <span class="dt">TcGblEnv</span> <span class="ot">-&gt;</span> <span class="dt">TcM</span> <span class="dt">TcGblEnv</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">install opts ms tc_gbl <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="kw">let</span> imps <span class="fu">=</span> tcg_rn_imports tc_gbl</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">        gm_imps <span class="fu">=</span> map (convertImport <span class="fu">.</span> unLoc) imps</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">        outdir <span class="fu">=</span> mkOutdir opts</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">        path <span class="fu">=</span> mkPath outdir (ms_mod ms)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">        gm_modname <span class="fu">=</span> getModName ms</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    liftIO <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">      createDirectoryIfMissing <span class="dt">False</span> outdir</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">      writeBinary path (gm_modname, gm_imps)</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">    return tc_gbl</a></code></pre></div>
<p><code>mkPath</code> tries to come up with a unique name for a module by using the <code>moduleUnitId</code>. The file name doesn’t matter particularly as long as it’s unique. We could instead write this information to a database or to a file handle. Writing to disk is just a convenient method of serialisation.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">mkPath ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Module</span> <span class="ot">-&gt;</span> FilePath</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">mkPath fp m</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="fu">=</span> fp <span class="fu">&lt;/&gt;</span> (moduleNameString (moduleName m) <span class="fu">++</span> (show (moduleUnitId m)))</a></code></pre></div>
<p>Then, we define the plugin by making a definition called <code>plugin</code> and overriding the <code>typeCheckResultAction</code> field and the <code>pluginRecompile</code> field. <code>purePlugin</code> means that the result of our plugin only depends on the contents of the source file rather than any external information. This means that we don’t need to recompile the module every time just because we are using a plugin.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- Installing the plugin</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">plugin ::</span> <span class="dt">Plugin</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">plugin <span class="fu">=</span> defaultPlugin  {</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  typeCheckResultAction <span class="fu">=</span> install</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  , pluginRecompile <span class="fu">=</span> purePlugin</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">}</a></code></pre></div>
<p>Now that our module exports an identifier of type <code>Plugin</code> called <code>plugin</code> we are finished defining the plugin part of the project.</p>
<h1 id="the-finaliser">The finaliser</h1>
<p>Once all the modules have finished compiling. They will have written their information to a file in a certain directory that we can now inspect to create the dot graph.</p>
<p>We define an executable to do this. The executable takes the directory of the files as an argument, reads all the files and then processes them to produce the graph.</p>
<p>In the <code>collectImports</code> function, we first read the directory from a command line argument. Then we find all the files in this directory and read their contents into memory. We use the helper function <code>readImports</code> which uses functions from the <code>Binary</code> module to read the serialised files. Finally, we build the graph using all the import information and then pass the graph we have built to the existing <code>graphmod</code> backend.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">collectImports ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">collectImports <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  raw_opts <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">let</span> (fs, _ms, _errs) <span class="fu">=</span> getOpt <span class="dt">Permute</span> options raw_opts</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">      opts <span class="fu">=</span> foldr (<span class="fu">$</span>) default_opts fs</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">      outdir <span class="fu">=</span> inputDir opts</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  files <span class="ot">&lt;-</span> listDirectory outdir</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">  usages <span class="ot">&lt;-</span> mapM (readImports outdir) files</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">let</span> graph <span class="fu">=</span> buildGraph opts usages</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  putStr (GraphMod.make_dot opts graph)</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="ot">readImports ::</span> FilePath <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Payload</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">readImports outdir fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">  readBinMem (outdir <span class="fu">&lt;/&gt;</span> fp) <span class="fu">&gt;&gt;=</span> get</a></code></pre></div>
<p>The <code>buildGraph</code> function builds an in memory representation of the module graph. There is a node for each module and an edge between modules if one imports the other. We finally mimic the original <code>graphmod</code> tool and output the representation of the graph on <code>stdout</code>. This can then be piped to <code>dot</code> in order to render the graph.</p>
<h1 id="running-the-plugin-with-nix">Running the plugin with nix</h1>
<p>By far the most convenient way to run the plugin is with nix. This gets around the problem of having to run the finaliser after compiling the plugin. We use the <a href="http://mpickering.github.io/posts/2018-06-24-haskell-nix-plugins.html"><code>haskell-nix-plugin</code></a> infrastructure in order to do this.</p>
<p>The information required to run the plugin consists of information about the plugin package but also an additional, optional, final phase which runs after the module has finished compiling.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ex">graphmod</span> =</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="kw">{</span> <span class="ex">pluginPackage</span> = hp.graphmod-plugin<span class="kw">;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="ex">pluginName</span> = <span class="st">&quot;GraphMod&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="ex">pluginOpts</span> = (out-path: [<span class="st">&quot;</span><span class="va">${out-</span>path<span class="va">}</span><span class="st">/output&quot;</span>]);</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="ex">pluginDepends</span> = [ nixpkgs.graphviz ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="ex">finalPhase</span> = out-path: <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">      <span class="ex">graphmod-plugin</span> --indir <span class="va">${out-</span>path<span class="va">}</span>/output <span class="op">&gt;</span> <span class="va">${out-</span>path<span class="va">}</span>/out.dot</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      <span class="fu">cat</span> <span class="va">${out-</span>path<span class="va">}</span>/out.dot <span class="kw">|</span> <span class="ex">tred</span> <span class="kw">|</span> <span class="ex">dot</span> -Gdpi=600 -Tpng <span class="op">&gt;</span> <span class="va">${out-</span>path<span class="va">}</span>/modules.png</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">      <span class="st">&#39;&#39;</span>; <span class="kw">}</span> ;</a></code></pre></div>
<p>I will add this definition to the <code>plugins.nix</code> file in <code>haskell-nix-plugin</code> once ghc-8.6.1 is released.</p>
<p>We then would use the <code>addPlugin</code> function in order to run the plugin on a package. In order to get the module graph we inspect the <code>GraphMod</code> output.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">(</span><span class="ex">addPlugin</span> graphmod hp.aeson<span class="kw">)</span><span class="ex">.GraphMod</span></a></code></pre></div>
<p>Running this script on <code>aeson</code> produces <a href="https://i.imgur.com/baiyyuc.jpg">this</a> quite large image which shows the whole module graph.</p>
<p>A complete example <code>default.nix</code> can be found in the <a href="https://github.com/mpickering/graphmod-plugin/blob/master/default.nix">repo</a>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We have described one way in which one can structure a plugin. There are probably other ways but this seems ergnomic and convenient. Hopefully others will find this quite detailed summary and reference code useful to build upon.</p>
<p>Writing plugins is quite similar to modifying GHC itself so if you need help, the best place to ask is either on the <a href="https://mail.haskell.org/mailman/listinfo/ghc-devs"><code>ghc-devs</code> mailing list</a> or on #ghc on freenode.</p>
<h1 id="related-links">Related Links</h1>
<ul>
<li><a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/95r8uj/reimplementing_graphmod_as_a_source_plugin/">Reddit comments</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Nix scaffolding for running Haskell plugins</title>
    <link href="http://mpickering.github.io/posts/2018-06-24-haskell-nix-plugins.html" />
    <id>http://mpickering.github.io/posts/2018-06-24-haskell-nix-plugins.html</id>
    <published>2018-06-24T00:00:00Z</published>
    <updated>2018-06-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Nix scaffolding for running Haskell plugins </h2>
<p class="text-muted">
    Posted on June 24, 2018
    
</p>

<p>I’ve been all about writing <a href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html">source plugins</a> recently but have been dissatisfied with how rough it is to use them practically. In particular, I am writing plugins which don’t change the semantics of my programs but are useful for debugging. I only sometimes want to run them and don’t want them to appear as dependencies at all on Hackage. It needs to be easy to apply them to my own and other people’s packages.</p>
<p>Of course, the solution was to leverage my knowledge of nix to wrap up everything into a nice interface. The key to the interface is a new function <code>haskell.lib.addPlugin</code> which augments an existing package with a plugin.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ex">addPlugin</span> dump-core-plugin either</a></code></pre></div>
<p>This invocation will now also output an HTML representation of the core program of the <code>either</code> package by using the <code>dump-core</code> plugin.</p>
<p>This post will explain this interface in more detail but will not get into the gritty implementation details. The implementation can be found in the <a href="https://github.com/mpickering/haskell-nix-plugin"><code>haskell-nix-plugin</code></a> repo.</p>
<!--more-->
<h1 id="two-uses-of-plugins">Two uses of plugins</h1>
<p>There are two kinds of plugins:</p>
<ol type="1">
<li>A plugin which modify your program so should always run. For example, the <a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise"><code>ghc-typelits-natnormalise</code></a> plugin which solves constraints containing type level numbers.</li>
<li>A plugin which collects information or debugging information which is optional. For example, the <a href="https://hackage.haskell.org/package/dump-core"><code>dump-core</code></a> plugin which outputs an HTML rendering of the core of your program.</li>
</ol>
<p>Even though you only sometimes want to run plugins in the second category, the convenient way to involves several steps:</p>
<ol type="1">
<li>Add the plugin package to your <code>build-depends</code>.</li>
<li>Pass a specific option <code>-fplugin=DumpCore</code> by modifying <code>ghc-options</code>.</li>
</ol>
<p>If you want to package your library correctly, you then need to hide this information behind a cabal flag. However, this is still undesirable as a package like <code>dump-core</code> is only going to be used by developers but the flag now appears in the public interface. Further to this, I can’t run my plugin on someone else’s package without modifying the cabal file.</p>
<p>What we really want is a way to take an existing package and to augment it to run the plugin. In order to do this, we define a function <code>addPlugin</code> which takes a plugin and a package as an argument and then compiles the package whilst running the plugin. For example, if we want to inspect the core of the <code>either</code> package, we could specify this like so.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">addPlugin</span> dump-core-plugin either</a></code></pre></div>
<p>If we then build this modified package, there will be a new output which has the same name as the plugin which contains the output of the plugin. So in this case, we will find the relevant HTML by inspecting the <code>DumpCore</code> attribute. It will also be symlinked to <code>result-DumpCore</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">either-core</span> = (addPlugin dump-core-plugin either)<span class="ex">.DumpCore</span></a></code></pre></div>
<p>There are three new elements to the nixpkgs API.</p>
<ol type="1">
<li>A new function <code>haskell.lib.addPlugin</code> which adds a plugin to a package.</li>
<li>A new attribute <code>haskell.plugins</code> which is parameterised by a Haskell package set and contains a set of plugins.</li>
<li>A new <code>with*</code> function, <code>haskellPackages.withPlugin</code> which takes a function expecting two arguments, the first being a set of plugins for that package set and the second being a list of packages for that package set. The result of the function should be a Haskell package.</li>
</ol>
<h2 id="the-plugin-set">The plugin set</h2>
<p>The <code>haskell.plugins</code> attribute is a set of plugins parameterised by a normal Haskell package set. It is designed in this manner so the same plugin definitions can be used with different compilers.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">hp</span>:</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">{</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">dump-core</span> = { ... <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">graphmod-plugin</span> = { ... };</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>Each attribute is a different plugin which we might want to use with our program.</p>
<h2 id="a-plugin">A plugin</h2>
<p>A plugin is a Haskell package which provides the plugin with four additional attributes which describe how to run it. For example, here is the definition for the <code>dump-core</code> plugin.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ex">dump-core</span> = { pluginPackage = hp.dump-core <span class="kw">;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">              <span class="ex">pluginName</span> = <span class="st">&quot;DumpCore&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">              <span class="ex">pluginOpts</span> = (out-path: [out-path]);</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">              <span class="ex">pluginDepends</span> = []<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">              <span class="ex">finalPhase</span> = _: <span class="st">&quot;&quot;</span><span class="kw">;</span> } ;</a></code></pre></div>
<dl>
<dt><code>pluginPackage</code></dt>
<dd>The Haskell package which provides the plugin.
</dd>
<dt><code>pluginName</code></dt>
<dd>The module name where the plugin is defined.
</dd>
<dt><code>pluginOpts</code></dt>
<dd>Additional options to pass to the plugin. The path where it places its output is passed as an argument.
</dd>
<dt><code>pluginDepends</code></dt>
<dd>Any additional system dependencies the plugin needs for the finalPhase.
</dd>
<dt><code>finalPhase</code></dt>
<dd>An action to run in the <code>postBuild</code> phase, after the plugin has run. The output directory is passed as an argument.
</dd>
</dl>
<p>In most cases, <code>pluginDepends</code> and <code>finalPhase</code> can be omitted (they then take these default values) but they are useful for when a plugin emits information as it compiles each module which is then summarised at the end.</p>
<p>An example of this architecture is the <a href="https://github.com/mpickering/graphmod-plugin"><code>graphmod-plugin</code></a>. As each module is compiled, the import information is serialised. Then, at the end we read all the serialised files and create a dot graph of the module import structure. Here is how we specify the final phase of the plugin:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">graphmod</span> = { pluginPackage = hp.graphmod-plugin<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">             <span class="ex">pluginName</span> = <span class="st">&quot;GraphMod&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">             <span class="ex">pluginOpts</span> = (out-path: [<span class="st">&quot;</span><span class="va">${out-</span>path<span class="va">}</span><span class="st">/output&quot;</span>]);</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">             <span class="ex">pluginDepends</span> = [ nixpkgs.graphviz ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">             <span class="ex">finalPhase</span> = out-path: <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">                <span class="ex">graphmod-plugin</span> --indir <span class="va">${out-</span>path<span class="va">}</span>/output <span class="op">&gt;</span> <span class="va">${out-</span>path<span class="va">}</span>/out.dot</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">                <span class="fu">cat</span> <span class="va">${out-</span>path<span class="va">}</span>/out.dot <span class="kw">|</span> <span class="ex">tred</span> <span class="kw">|</span> <span class="ex">dot</span> -Tpdf <span class="op">&gt;</span> <span class="va">${out-</span>path<span class="va">}</span>/modules.pdf</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">              <span class="st">&#39;&#39;</span>; } ;</a></code></pre></div>
<p>The first three fields are standard, however we now populate the final two arguments as well. We firstly add a dependency on <code>graphviz</code> which we will use to render the module graph and then specify the invocations needed to firstly summarise and then render the information.</p>
<p>In this architecture, the plugin package provides a library interface which exposes the plugin and an executable which is invoked to collect the information output by the plugin. This is what the call to <code>graphmod-plugin</code> achieves.</p>
<h2 id="withplugin"><code>withPlugin</code></h2>
<p>We also provide the <code>withPlugin</code> attribute which supplies both the plugins and packages already applied to a specific package set. The reason for this is that <strong>a plugin and a package must be both compiled by the same compiler</strong>. Thus, unrestricted usage of <code>addPlugin</code> can lead to confusing errors if the plugin and package are compiled with different compilers. The <code>withPlugin</code> attribute ensures that the versions align correctly.</p>
<pre><code>core-either =
  haskellPackages.withPlugin
    (plugins: packages: addPlugin plugins.dump-core packages.either)</code></pre>
<h2 id="how-can-i-use-it">How can I use it?</h2>
<p>This infrastructure is provided as an overlay. Install the overlay as you would normally, one suggested method can be see in the <a href="https://github.com/mpickering/haskell-nix-plugin/blob/master/example.nix"><code>example.nix</code></a> file.</p>
<pre><code>let
  plugin-overlay-git = builtins.fetchGit
    { url = https://github.com/mpickering/haskell-nix-plugin.git;}  ;
  plugin-overlay = import &quot;${plugin-overlay-git}/overlay.nix&quot;;
  nixpkgs = import &lt;nixpkgs&gt; { overlays = [plugin-overlay]; };
in ...</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>So far, I have not package many plugins in this manner but as source plugins are released in GHC 8.6 I expect to want to use plugins more and more regularly.</p>
<h3 id="related-links">Related Links</h3>
]]></summary>
</entry>
<entry>
    <title>Fixing the missing `ar` error with a development build of GHC (on NixOS)</title>
    <link href="http://mpickering.github.io/posts/2018-06-21-binutils-unwrapped.html" />
    <id>http://mpickering.github.io/posts/2018-06-21-binutils-unwrapped.html</id>
    <published>2018-06-21T00:00:00Z</published>
    <updated>2018-06-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Fixing the missing `ar` error with a development build of GHC (on NixOS) </h2>
<p class="text-muted">
    Posted on June 21, 2018
    
</p>

<p>On NixOS, if you build GHC from source using Make or hadrian and try to use it with cabal then you will be greeted with the following error:</p>
<pre><code>cabal: The program &#39;ar&#39; is required but it could not be found.</code></pre>
<p>The way to fix this problem is to run cabal in an environment with the <code>binutils-unwrapped</code> package available. You can then use cabal as normal.</p>
<pre><code>nix-shell -p binutils-unwrapped</code></pre>
]]></summary>
</entry>
<entry>
    <title>Source Plugins: Four ways to build a typechecked Haskell expression</title>
    <link href="http://mpickering.github.io/posts/2018-06-11-source-plugins.html" />
    <id>http://mpickering.github.io/posts/2018-06-11-source-plugins.html</id>
    <published>2018-06-11T00:00:00Z</published>
    <updated>2018-06-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Source Plugins: Four ways to build a typechecked Haskell expression </h2>
<p class="text-muted">
    Posted on June 11, 2018
    
</p>

<p>A source plugin allows users to modify and analyse code after typechecking. They have access to all the features of the compiler to create and modify bindings.</p>
<p>Sounds great right? GHC is all about creating and modifying bindings so this should be a doddle. However, it isn’t immediately obvious how to make a typechecked binding using the provided API.</p>
<p>In this post, I’ll demonstrate and explain four different ways of arriving at a typechecked expression which can then be inserted into a program. All these examples are packaged up into a complete plugin on my <a href="https://github.com/mpickering/plugin-constraint">GitHub page</a>.</p>
<!--more-->
<h2 id="constructing-expressions">Constructing Expressions</h2>
<p>The four examples which we order from the most direct to the most indirect. Each has their advantages but in general, directly constructing an already typechecked binding is the most risky but flexible whilst starting from a Template Haskell quote is the safest but most rigid option. In the end we will always end up with a <code>LHsExpr GhcTc</code> but we will start from four different places.</p>
<ul>
<li><code>LHsExpr GhcTc</code> - An already typechecked expression</li>
<li><code>LHsExpr GhcRn</code> - An already renamed expression</li>
<li><code>LHsExpr GhcPs</code> - A parsed expression</li>
<li><code>TH.Exp</code> - A quoted expression</li>
</ul>
<p>Each example will construct the simple expression <code>print ()</code>. This example is chosen because it demonstrates that we must be concerned with polymorphism and type classes during the process.</p>
<h2 id="typechecked-expression">Typechecked Expression</h2>
<p>Constructing a <code>LHsExpr GhcTc</code> by hand is quite annoying as you must be knowledgeable about how the typechecker prepares a program. You must also be quite explicit about types and the compiler won’t tell you that you’re wrong unless you compiler with core lint enabled.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- Creates the already typechecked expression `print ()`</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">-- There is quite a lot of boilerplate and the compiler won&#39;t tell</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">-- you where you went wrong unless -dcore-lint is enabled.</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">mkNewExprTc ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">mkNewExprTc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="co">-- Get the `Id`s that we need, these ones helpfully are already defined</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="co">-- in `PrelNames` and `TysWiredIn`.</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  print_id    <span class="ot">&lt;-</span> tcLookupId printName</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="co">-- Generate the evidence for `Show ()` which we will pass to `print`</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  (dict_var, showUnitEv) <span class="ot">&lt;-</span> generateDictionary</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    rhs <span class="fu">=</span> mHsApp (mLHsWrap wrapper printExpr) unitExpr)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    printExpr <span class="fu">=</span> nlHsVar print_id</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    unitExpr <span class="fu">=</span> nlHsDataCon unitDataCon</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="co">-- How we are going to apply the necessary type arguments</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    wrapper <span class="fu">=</span> mkWpLet showUnitEv <span class="fu">&lt;.&gt;</span> mkWpEvVarApps [dict_var] <span class="fu">&lt;.&gt;</span> mkWpTyApps [unitTy]</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  return rhs</a></code></pre></div>
<p>Notice that in particular, we have to be careful to construct and apply a wrapper which will desugar to type and dictionary applications. We also have to explicitly come up with the correct dictionary for the <code>print</code> function and manually apply it ourselves. This approach gives us a lot of control but leaves many fiddly places to go wrong.</p>
<h2 id="renamed-binding">Renamed Binding</h2>
<p>The second approach creates a <code>LHsExpr GhcRn</code> which we will then typecheck using the normal typechecker. This has the advantage that we can be direct about which names we mean but also have the safety that the compiler will emit an error when the plugin is used if we made a mistake.</p>
<p>We still have to construct the return type of the expression to pass into the typechecker. We use <code>lookupOccRn</code> to find the definition of <code>print</code> which is in scope but can use <code>unitDataCon</code> directly without looking it up as it is already wired into the compiled and defined in <code>PrelNames</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- Creates a `LHsExpr GhcRn` which we then typecheck to turn into</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- a `LHsExpr GhcTc`. The compiler will raise an error to the user if you</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">-- made a mistake in constructing the term.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">mkNewExprRn ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">mkNewExprRn <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="co">-- The names we want to use happen to already be in PrelNames so we use</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="co">-- them directly.</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">let</span> print_occ <span class="fu">=</span> mkRdrUnqual (mkVarOcc <span class="st">&quot;print&quot;</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  print_name <span class="ot">&lt;-</span> lookupOccRn print_occ</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="kw">let</span> raw_expr <span class="fu">=</span> nlHsApp (nlHsVar print_name) (nlHsVar (dataConName unitDataCon))</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  typecheckExpr exp_type raw_expr</a></code></pre></div>
<h2 id="parsed-binding">Parsed Binding</h2>
<p>We sometimes don’t want to specify exactly which names we mean or know which renaming functions to use to find them. It’s easier to let the renamer do that for us. In this example, we construct a <code>LHsExpr GhcPs</code> which we then pass into the renamer and typechecker. Therefore, the compiler will warn us about out of scope variables or type errors in the expression we have created like normal.</p>
<p>Instead of constructing <code>Name</code>s like before, we are constructing <code>RdrName</code>s. These are conceptually easier to create as we must only consider the namespace the name lives in rather than any other details. The renamer will fill in the rest of the information.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- An example of how to construct a value from a `LHsExpr GhcPs`.</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- Making sure things are in the right namespace is sometimes a bit</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">-- awkward.</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">mkNewExprPs ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">mkNewExprPs  <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    print_occ <span class="fu">=</span> mkRdrUnqual (mkVarOcc <span class="st">&quot;print&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    unit_occ <span class="fu">=</span> nameRdrName (dataConName unitDataCon)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    ps_expr <span class="fu">=</span> nlHsApp (nlHsVar print_occ)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                      (nlHsVar unit_occ)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  renameExpr ps_expr <span class="fu">&gt;&gt;=</span> typecheckExpr exp_type</a></code></pre></div>
<p>Note, I initially tried to use a different definition of <code>unit_occ</code> which didn’t start from the wired in name but it proved tricky to get correct. This is why we start from the more specific <code>Name</code> and turn it into a <code>RdrName</code>. We are also relying more on the context of the module, if the user hasn’t imported <code>print</code> then the plugin will fail.</p>
<h2 id="constructing-a-binding-from-template-haskell">Constructing a binding from Template Haskell</h2>
<p>Still, explicitly typing out the syntax tree is quite onerous. We would much prefer type out a Haskell program as normal and then splice it into our program. We can achieve this by using a Template Haskell quasiquoter.</p>
<p>We first quote the expression we want to insert which creates a <code>TH.Exp</code> which we can convert to a normal <code>HsExpr GhcPs</code> by using the same function that GHC itself uses to deal with Template Haskell. Once we have the parsed expression we can rename it and typecheck it as in the previous examples. This is all quite convenient!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">liftQ ::</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">TcM</span> a</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">liftQ <span class="fu">=</span> liftIO <span class="fu">.</span> runQ</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">-- Creates a `TH.Exp` using a quasiquoter before renaming</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">-- and typechecking to create an `LHsExpr`. This is convenient as you</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">-- don&#39;t have to write out the syntax.</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">-- p</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="ot">mkNewExprTh ::</span> <span class="dt">TcM</span> (<span class="dt">LHsExpr</span> <span class="dt">GhcTc</span>)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">mkNewExprTh <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  th_expr <span class="ot">&lt;-</span> liftQ [<span class="fu">|</span> print () <span class="fu">|</span>]</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  ps_expr <span class="ot">&lt;-</span> <span class="kw">case</span> convertToHsExpr noSrcSpan th_expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="dt">Left</span> _err <span class="ot">-&gt;</span> error <span class="st">&quot;Bad expression&quot;</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="dt">Right</span> res <span class="ot">-&gt;</span> return res</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  io_tycon <span class="ot">&lt;-</span> tcLookupTyCon ioTyConName</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  <span class="kw">let</span> exp_type <span class="fu">=</span> mkTyConApp io_tycon [unitTy]</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  renameExpr ps_expr <span class="fu">&gt;&gt;=</span> typecheckExpr exp_type</a></code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>In our experience, the most practical way of constructing expressions is to use Template Haskell. A more in-depth example which creates a complicated expression can be see in the <a href="https://github.com/ocharles/assert-explainer">assert-explainer</a> which I worked on with Ollie Charles at Zurihac 2018.</p>
<h1 id="addendum-how-can-i-interact-with-the-constraint-solver">Addendum: How can I interact with the constraint solver?</h1>
<p>The <code>generateDictionary</code> is an example of how to generate some evidence. It might need to be refined further but worked for simple tests.</p>
<h1 id="addendum-how-can-i-get-the-type-of-an-hsexpr-ghctc">Addendum: How can I get the type of an <code>HsExpr GhcTc</code>?</h1>
<p>To get the type of an expression, first desugar the expression and then use <code>exprType</code> to find the type of the desugared variant. There is an example in <a href="https://github.com/ocharles/assert-explainer/blob/master/plugin/AssertExplainer.hs#L289">assert-explainer</a>.</p>
<h1 id="addendum-how-can-i-combine-together-old-and-new-program-fragments">Addendum: How can I combine together old and new program fragments</h1>
<p>If you want to combine together pieces of new syntax and old syntax then don’t try to do it directly. Construct a lambda with arguments for each of the pieces you want to insert. Finally, apply the lambda to the existing expressions you want to insert.</p>
]]></summary>
</entry>
<entry>
    <title>Replacing type classes with records affects optimisation</title>
    <link href="http://mpickering.github.io/posts/2018-03-20-recordsvstypeclasses.html" />
    <id>http://mpickering.github.io/posts/2018-03-20-recordsvstypeclasses.html</id>
    <published>2018-03-20T00:00:00Z</published>
    <updated>2018-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Replacing type classes with records affects optimisation </h2>
<p class="text-muted">
    Posted on March 20, 2018
    
</p>

<p>It is somewhat common to suggest using records instead of type classes for particular domains for which type classes are not deemed idiomatic. However, this suggestion should be taken with caution as the change will have consequences on how your program is optimised. Using records instead of type classes can lead to much slower programs.</p>
<!--more-->
<p>In order to provide an interface for propositional logic, we might provide a type class which allows the constructors to be overloaded. We can then provide a direct interpretation of <code>Prop</code> which evaluates an expression to a truth value.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Prop</span> r <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">  or ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  and ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">  true ::</span> r</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  false ::</span> r</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Prop</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  or <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  and <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  true <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  false <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>However, one might be tempted to avoid using a type class and instead perform the manual type class desugaring in order to be able to more easily modify and extend an interpretation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">PropDict</span> r <span class="fu">=</span> <span class="dt">PropDict</span> {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  dor ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> dand ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  ,<span class="ot"> dtrue ::</span> r</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  ,<span class="ot"> dfalse ::</span> r</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">boolDict <span class="fu">=</span> <span class="dt">PropDict</span> {</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  dor <span class="fu">=</span> (<span class="fu">||</span>)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  , dand <span class="fu">=</span> (<span class="fu">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  , dtrue <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , dfalse <span class="fu">=</span> <span class="dt">False</span> }</a></code></pre></div>
<p>We can then use both versions in order to implement a helper function which turns a list into a chain of disjunctions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">ors ::</span> <span class="dt">Prop</span> r <span class="ot">=&gt;</span> [r] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">ors [o] <span class="fu">=</span> o</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">ors (o<span class="fu">:</span>os) <span class="fu">=</span> o <span class="ot">`or`</span> ors os</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">dors ::</span> <span class="dt">PropDict</span> r <span class="ot">-&gt;</span> [r] <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">dors _ [o] <span class="fu">=</span> o</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">dors pd (o<span class="fu">:</span>os) <span class="fu">=</span> dor pd o (dors pd os)</a></code></pre></div>
<p>We can then instantiate each function by either supplying a type argument or the dictionary directly in the latter case.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">test1 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">test1 <span class="fu">=</span> ors <span class="fu">@</span><span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">test2 ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">test2 <span class="fu">=</span> dors boolDict</a></code></pre></div>
<p>What’s the difference between these two versions? The process of optimisation is different. In the first case, the overloading of <code>ors</code> will be eliminated by <strong>specialisation</strong>. In the later case, the static argument will be eliminated by <strong>SpecConstr</strong>. When we define these definitions in the same module as our earlier definitions of <code>ors</code> and <code>dors</code> then both definitions result in essentially the same code as each other. The overhead is eliminated.</p>
<p>However, when we use <code>ors</code> or <code>dors</code> in another module, they behave quite differently. If we mark <code>ors</code> as <code>INLINABLE</code> then it will also be specialised in other modules. However, <strong>SpecConstr does not work across module boundaries</strong>. As a result, <code>dors</code> will not be specialised on the static argument and the dictionary overhead will remain.</p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://github.com/mpickering/rtcwrao-benchmarks">Benchmarks</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/85svhm/replacing_type_classes_with_records_affects/">Reddit Discussion</a></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Using a development version of GHC with nix</title>
    <link href="http://mpickering.github.io/posts/2018-01-05-ghchead-nix.html" />
    <id>http://mpickering.github.io/posts/2018-01-05-ghchead-nix.html</id>
    <published>2018-01-05T00:00:00Z</published>
    <updated>2018-01-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Using a development version of GHC with nix </h2>
<p class="text-muted">
    Posted on January  5, 2018
    
</p>

<p>Most documentation for using nix with Haskell concentrates on quite simple use cases such as how to modify or add new dependencies. What about when you want to do something more complicated? In this post we look at combining modifications from different sources. The goal is to create a package set which can be used to compile packages with HEAD.</p>
<!--more-->
<p>The main problem which we are going to solve is that many packages need modifying in order to compile with HEAD. There is already a nix package which builds a development version of the compiler and a corresponding package set but the utility is limited as many packages will fail to compile.</p>
<p>For example, at the time of writing this post, if we try and build the <code>primitive</code> package, the build fails due to a missing <code>Semigroup</code> instance.</p>
<p>If you are impatient, here is the <a href="https://gist.github.com/mpickering/209354a6affe2883ca07ffc4f4084af6">complete example</a> we are going to come up with. We create a new top-level attribute <code>new-ghcHEAD</code> which we can use to build packages with <code>ghcHEAD</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ex">nixpkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="ex">patchRepo</span> =</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="ex">nixpkgs.fetchFromGitHub</span> {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      <span class="ex">owner</span> = <span class="st">&quot;mpickering&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="ex">repo</span> = <span class="st">&quot;head.hackage&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="fu">rev</span> = <span class="st">&quot;767dcf11b367ccff4a9fcd55df9c2432cd485fbe&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="ex">sha256</span> = <span class="st">&quot;1cdrcw7grpc2dyxnb7a5bg9mi1h7qnblcibi91s348034zf7a0vj&quot;</span><span class="kw">;</span>};</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="ex">patchDir</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/patches&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="ex">patchScript</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/scripts/overrides.nix&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">in</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="ex">self</span>: super:</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">{</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="ex">haskellPatches</span> = self.callPackage patchScript</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">              <span class="kw">{</span> <span class="ex">patches</span> = patchDir<span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">          <span class="ex">sel</span>: sup: { haskell-src-exts</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">                        = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">                      <span class="ex">mkDerivation</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24">                        = <span class="ex">drv</span>: sup.mkDerivation (drv //</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">                             <span class="kw">{</span> <span class="ex">jailbreak</span> = true<span class="kw">;</span> <span class="ex">doHaddock</span> = false<span class="kw">;}</span>);</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">                     <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">         <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">}</a></code></pre></div>
<h1 id="a-simple-overlay">A simple overlay</h1>
<p>We are going to use an overlay in order to define the new package set. An overlay is the idiomatic way to extend and change the top-level nixpkgs set. It is a function which takes two arguments, the result of performing the modification and the old unmodified package set. It returns a set of attributes which augment the top-level attribute set.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="ex">my-cool-new-attribute</span> = ...<span class="kw">;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">}</a></code></pre></div>
<p>As such <code>my-cool-new-attribute</code> will be in <code>self</code> but not in <code>super</code>. If we want to use <code>my-cool-new-attribute</code> in another attribute we can refer to it as <code>self.my-cool-new-attribute</code>.</p>
<p>When this overlay is installed (see below), we can use <code>my-cool-new-attribute</code> like any top-level attribute defined in <code>nixpkgs</code>. The overlay mechanism surpasses the old <code>packageOverrides</code> mechanism which used to be how to modify <code>nixpkgs</code>.</p>
<p>For example, we could enter an environment with <code>my-cool-new-attribute</code> available with <code>nix-shell -p my-cool-new-attribute</code> as if it were defined in the main <code>nixpkgs</code> repo.</p>
<p>There are two ways to easily install an overlay.</p>
<ol type="1">
<li><p>Pass it as an argument when importing nixpkgs.<br />
</p>
<pre><code>let pkgs = import &lt;nixpkgs&gt; {overlays = [overlay1 overlay2 ..]};
in ...</code></pre></li>
<li><p>Place the overlay in <code>~/.config/nixpkgs/overlays/</code></p></li>
</ol>
<p>More details about using overlays can be found in the <a href="https://nixos.org/nixpkgs/manual/#sec-overlays-install">user manual</a>.</p>
<h1 id="extending-a-package-set">Extending a package set</h1>
<p>We’ll start from a simple template which demonstrates the concept of extending a Haskell package set like you might find in other documentation. We start from the <code>ghcHEAD</code> package set (<code>haskell.packages.ghcHEAD</code>) and then call the <code>extend</code> attribute with the extension function.</p>
<p>The extension function takes two arguments, the extended haskell package set and the original haskell package set much like an overlay. <code>ghcPackageOverrides</code> is the identity extension function in this example which performs no modifications.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="bu">let</span> ghcPackageOverrides = sel: sup: <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides <span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">}</a></code></pre></div>
<p>If we then want to fix a specific version of a package we can modify <code>ghcPackageOverrides</code> like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="bu">let</span> ghcPackageOverrides =</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">          <span class="ex">sel</span>: sup: {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">            <span class="ex">haskell-src-exts</span> =</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">              <span class="ex">sup.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">          };</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">}</a></code></pre></div>
<p>When using the <code>new-ghcHEAD</code> package set, we will now install <code>haskell-src-exts-1.20.1</code> rather than <code>haskell-src-exts-1.19.1</code> if it is needed as a dependency.</p>
<h2 id="more-extensions">More extensions</h2>
<p>Manually redefining each package to get it to build is tedious. Instead, we’re going to use the patches from <a href="https://github.com/hvr/head.hackage"><code>head.hackage</code></a> in order to generate a lot of modifications automatically. What we need are the patches in <code>head.hackage/patches</code> which enable packages to build with the bleeding edge version of the compiler.</p>
<p>In <code>head.hackage/scripts</code> there are the necessary files in order to use the patches with nix. <code>overrides.nix</code> is a wrapper which runs a haskell executable in order to generate a nix expression explaining the package modifications. The result of the derivation is a file which we can then import into our overlay directly.</p>
<h3 id="using-a-local-copy-of-head.hackage">Using a local copy of <code>head.hackage</code></h3>
<p>You will probably want to clone <code>head.hackage</code> locally so that you can add and modify patches as necessary to get your project to compile.</p>
<p>In that case, instead of specifying a url, we just specify the correct paths for the packaging script and patch directory.</p>
<p>For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">}</a></code></pre></div>
<h3 id="using-a-remote-copy-of-head.hackage">Using a remote copy of <code>head.hackage</code></h3>
<p>If you don’t want to maintain a local clone of the repo then you can also fetch it from wherever you like. For example, here I fetch a specific branch from my clone of the repo which contains some nix specific patches.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="ex">nixpkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ex">patchRepo</span> = nixpkgs.fetchFromGitHub {</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="ex">owner</span> = <span class="st">&quot;mpickering&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="ex">repo</span> = <span class="st">&quot;head.hackage&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="fu">rev</span> = <span class="st">&quot;767dcf11b367ccff4a9fcd55df9c2432cd485fbe&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="ex">sha256</span> = <span class="st">&quot;1cdrcw7grpc2dyxnb7a5bg9mi1h7qnblcibi91s348034zf7a0vj&quot;</span><span class="kw">;</span>};</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  <span class="ex">patchDir</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/patches&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="ex">patchScript</span> = <span class="st">&quot;</span><span class="va">${patchRepo}</span><span class="st">/scripts/overrides.nix&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">in</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="ex">self</span>: super:</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">{</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  <span class="ex">haskellPatches</span> = self.callPackage patchScript</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">              <span class="kw">{</span> <span class="ex">patches</span> = patchDir<span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span> ghcPackageOverrides<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20"><span class="kw">}</span></a></code></pre></div>
<h2 id="combining-head.hackage-modifications-with-local-modifications">Combining <code>head.hackage</code> modifications with local modifications</h2>
<p>Unfortunately, this is not quite enough as it is sometimes necessary to further modify packages in order to get them to compile. The most obvious way is that a lot of packages have restrictive version bounds but compile fine with newer versions of libraries. So, in order to get around this we preemptively need to jailbreak all packages.</p>
<p>Jailbreaking is a process which removes all version bounds from a package. This is safe to do as each package set only contains one version of each dependency anyway.</p>
<p>We introduce a new extension function <code>localOverrides</code> which will contain our specific modifications which we don’t want to include in <code>head.hackage</code>. We will first only contain one specific modification which chooses a new version of <code>haskell-src-exts</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">          <span class="ex">sel</span>: sup:</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">            <span class="kw">{</span> <span class="ex">haskell-src-exts</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">                = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">            <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">        <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">}</a></code></pre></div>
<p>We need to use <code>composeExtensions</code> so that the attributes we locally modify are then also modified by <code>head.hackage</code> incrementally.</p>
<h3 id="modifying-mkderivation">Modifying <code>mkDerivation</code></h3>
<p>Finally, we will modify <code>mkDerivation</code> in order to jailbreak packages and not run <code>haddock</code> in order to speed up the builds. <code>mkDerivation</code> is the function which takes a Haskell package description and turns it into a nix derivation. It’s the function which when given the what to build, says precisely <em>how</em> to build it.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ex">self</span>: super: {</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="ex">haskellPatches</span> = self.callPackage <span class="op">&lt;</span>path-to-overrides.nix<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">              <span class="kw">{</span> <span class="ex">patches</span> = <span class="op">&lt;</span>path-to-patch-dir<span class="op">&gt;</span><span class="kw">;</span> <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="ex">new-ghcHEAD</span> =</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="bu">let</span> ghcPackageOverrides = self.callPackage self.haskellPatches <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">        <span class="ex">localOverrides</span>      =</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">          <span class="ex">sel</span>: sup: {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">            <span class="ex">haskell-src-exts</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">              = <span class="ex">sel.callHackage</span> <span class="st">&quot;haskell-src-exts&quot;</span> <span class="st">&quot;1.20.1&quot;</span> <span class="dt">{}</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">            <span class="ex">mkDerivation</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">              = <span class="ex">drv</span>: sup.mkDerivation (drv //</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">                  <span class="kw">{</span> <span class="ex">jailbreak</span> = true<span class="kw">;</span> <span class="ex">doHaddock</span> = false<span class="kw">;}</span>);</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">          };</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    <span class="kw">in</span> <span class="ex">self.haskell.packages.ghcHEAD.extend</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        <span class="kw">(</span><span class="ex">self.lib.composeExtensions</span> localOverrides ghcPackageOverrides<span class="kw">)</span>;</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">}</a></code></pre></div>
<h2 id="testing">Testing</h2>
<p>We can now test our new attribute using <code>nix-shell</code>. For example, let’s try to provision a version of the compiler with <code>primitive</code> available.</p>
<pre><code>&gt; nix-shell -p &quot;new-ghcHEAD.ghcWithPackages (ps: [ps.primitive])&quot;
...</code></pre>
<p>Success!</p>
<h1 id="conclusion">Conclusion</h1>
<p>Thanks to Csongor Kiss, Alessio Zakaria, Sarah Brofeldt and Vaibhav Sagar for comments on a draft.</p>
<h2 id="related-links">Related Links</h2>
<hr />
<h1 id="appendix">Appendix</h1>
<h2 id="addendum-what-do-i-do-if-a-patch-from-head.hackage-doesnt-apply">Addendum: What do I do if a patch from <code>head.hackage</code> doesn’t apply?</h2>
<p>There are some situations where patches from <code>head.hackage</code> fail to apply properly. The usual cause is that patches in the <code>head.hackage</code> repo apply to unmodified tarballs but the nix build process tries to apply patches after patching the cabal file to take into account package revisions.</p>
<p>The workaround for this is to just create a new nix-specific patch in your local directory. :)</p>
<h2 id="addendum-how-do-i-make-a-patch-to-contribute-to-head.hackage">Addendum: How do I make a patch to contribute to <code>head.hackage</code>?</h2>
<pre><code>cabal get haskell-src-exts-1.20.1 &lt;--pristine&gt;
cd haskell-src-exts-1.20.1
git init
git add .
&lt;Make the simple change&gt;
git diff &gt; &lt;patchDir&gt;/haskell-src-exts-1.20.1.patch</code></pre>
<p>Use the <code>--pristine</code> flag if you intend to contribute the patch upstream! This will fetch the package without applying cabal file revisions.</p>
<h2 id="addendum-how-does-overrides.nix-work">Addendum: How does <code>overrides.nix</code> work?</h2>
<p><code>overrides.nix</code> is a simple derivation which packages a single haskell script. The haskell script scans a directory and generates the correct overrides for the given patches. The wrapper script then stores the overrides and copies the patch files into the nix store.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">{</span> <span class="ex">stdenv</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  , <span class="ex">haskell</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  , <span class="ex">patches</span>  # A directory containing patch files used to build packages</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">             <span class="co"># it can either be a local directory or fetched from the web</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="kw">}</span>:</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="bu">let</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  <span class="ex">ghc</span> = haskell.packages.ghc822.ghcWithPackages (ps: with ps<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8">          [ ]);</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="kw">in</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="ex">stdenv.mkDerivation</span> {</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  <span class="ex">name</span> = <span class="st">&quot;hs-generate-overrides-0.1&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">  <span class="ex">src</span> = ./generate-nix-overrides.hs<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">  <span class="ex">preUnpack</span> = <span class="st">&#39;&#39;</span>mkdir hs-generate-overrides<span class="st">&#39;&#39;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">  <span class="ex">buildInputs</span> = [ ghc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20">  <span class="ex">unpackCmd</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">    <span class="fu">cp</span> <span class="va">$curSrc</span> ./hs-generate-overrides</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">    <span class="fu">cp</span> -r <span class="va">${patches}</span> ./hs-generate-overrides/patches</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    <span class="va">sourceRoot=</span>hs-generate-overrides;</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-25" data-line-number="25"></a>
<a class="sourceLine" id="cb12-26" data-line-number="26">  <span class="ex">buildPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">    <span class="ex">ghc</span> <span class="va">$src</span> -o generate</a>
<a class="sourceLine" id="cb12-28" data-line-number="28">    <span class="ex">./generate</span> <span class="va">$script</span>/patches patches <span class="op">&gt;</span> patches.nix</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">  <span class="ex">outputs</span> = [<span class="st">&quot;out&quot;</span> <span class="st">&quot;script&quot;</span>]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32"></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">  <span class="ex">installPhase</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34">    <span class="fu">cp</span> patches.nix <span class="va">$out</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35">    <span class="ex">ensureDir</span> <span class="va">$script</span>/patches</a>
<a class="sourceLine" id="cb12-36" data-line-number="36">    <span class="fu">cp</span> -r patches <span class="va">$script</span>/patches</a>
<a class="sourceLine" id="cb12-37" data-line-number="37">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb12-38" data-line-number="38"></a>
<a class="sourceLine" id="cb12-39" data-line-number="39">}</a></code></pre></div>
<h2 id="addendum-how-is-jailbreaking-different-to-cabals---allow-newer">Addendum: How is jailbreaking different to cabal’s <code>--allow-newer</code>?</h2>
<p>The goal of jailbreaking and <code>--allow-newer</code> are the same, to remove restrictive bounds on packages.</p>
<p>Jailbreaking achieves this by parsing and rewriting the cabal file to remove nearly all bounds. This fits better into the nix ecosystem where there is exactly one version of each package anyway so additional version bounds are irrelevant.</p>
<p><code>--allow-newer</code> influences the solver in order to pick a package set as if the package didn’t have any upper bounds.</p>
<h2 id="addendum-why-are-you-using-extend-rather-than-override.">Addendum: Why are you using <code>extend</code> rather than <code>override</code>.</h2>
<p><code>override</code> is a general nix mechanism to override arguments to a function. In the haskell package set case, one of the arguments to the package set is called <code>overrides</code>, which is a function explaining how we want to modify the package set further.</p>
<p>However, there is one big downside to using this mechanism, it is not possible to repeatedly override the package set with more and more extensions as each time you call <code>override</code> you <em>replace</em> the argument.</p>
<p>For more explanation of the difference see <a href="https://github.com/NixOS/nixpkgs/issues/25887">this issue</a> on the nixpkgs issue tracker.</p>
<h2 id="addendum-what-to-do-if-callhackage-doesnt-find-the-latest-version-of-a-package">Addendum: What to do if <code>callHackage</code> doesn’t find the latest version of a package</h2>
<p>If <code>callHackage</code> doesn’t find a package which you know is on hackage then it is because the <code>all-cabal-hashes</code> attribute is too old. In order to override it, you can simply add a new line to your overlay with an updated copy.</p>
<p>For example, this version is from <code>2018-01-05</code>:</p>
<pre><code>all-cabal-hashes = super.fetchurl {
  url    = &quot;https://github.com/commercialhaskell/all-cabal-hashes/archive/e1089e56e666c2a0fe82f840d3cc7f49b9c9fe9b.tar.gz&quot;;
  sha256 = &quot;0qbzdngm4q8cmwydnrg7jvipw39nb1mjxw95vw6f789874002kn1&quot;;
};</code></pre>
<h2 id="addendum-how-to-update-the-ghchead-derivation">Addendum: How to update the ghcHEAD derivation</h2>
<p>If you want to use a more recent version of HEAD then you have to update the ghcHEAD derivation. It can be found at <code>development/compilers/ghc/head.nix</code>.</p>
<p>You then need to modify three things.</p>
<ol type="1">
<li>Correct the version of the compiler by modifying the <code>version</code> argument.</li>
<li>Set <code>rev</code> to the git commit identifier of the revision you want to build.</li>
<li><p>Correct the <code>sha256</code> attribute by running <code>nix-prefetch-git</code> and copying the resulting hash.</p>
<pre><code>nix-shell -p nix-prefetch-git
 --run &quot;nix-prefetch-git --fetch-submodules git://git.haskell.org/ghc.git &lt;rev&gt;&quot;</code></pre></li>
</ol>
]]></summary>
</entry>
<entry>
    <title>INLIN(E)ing: A case study</title>
    <link href="http://mpickering.github.io/posts/2017-05-17-inlining-case-study.html" />
    <id>http://mpickering.github.io/posts/2017-05-17-inlining-case-study.html</id>
    <published>2017-05-17T00:00:00Z</published>
    <updated>2017-05-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> INLIN(E)ing: A case study </h2>
<p class="text-muted">
    Posted on May 17, 2017
    
</p>

<p>Ollie Charles recently popped into #ghc to ask about a small program which was taking a long time to compile. In fact, the compiler was taking so long in the simplifier he had to increase the tick factor (a measure of how much work the simplifier is allowed to do) to get compilation to finish. Oleg and I quickly set to work working out what was going on in his program.</p>
<p>It turned out that a misplaced <code>INLINE</code> pragma was causing a lot of simplification work to be duplicated. Removing the pragma allowed the compiler to operate faster whilst producing the same code.</p>
<!--more-->
<h1 id="the-problem">The Problem</h1>
<p>When a lot of time is spent in the simplifier it is usually because the core programs have grown quite large. Core programs can grow large for a number of reasons but one of primary reasons is due to excessive inlining caused by <code>INLINE</code> pragmas.</p>
<p>The first tool we have at our disposal is <code>-ddump-simpl-stats</code> which outputs a summary of each step the simplifier takes. Looking at this summary is a good way to work out roughly where the problem lies.</p>
<p>In this case, the statistics file was quite <a href="https://gist.github.com/ocharles/8d69c518b5d3169e8254b24205e03f65">large</a>. The first bit I always check is the “UnfoldingDone” section which details how many times each definition has been inlined. Here is the relevant snippet from the top of that section.</p>
<pre><code>  14620 UnfoldingDone
    596 $
    574 contramapF
    546 $fNumInt_$c+
    485 $fStorableWord8_$cpoke
    485 castPtr
    485 $fStorableWord8_$calignment
    485 word8
    485 $s&gt;$&lt;
    485 castPtr1
    484 thenIO
    484 thenIO1
    484 ord
    484 $fBitsInt_$c.&amp;.
    484 plusPtr
    484 $fStorableWord19
    463 char7
    331 $s&gt;*&lt;1
    331 pairF
    220 returnIO
    220 returnIO1
    220 $s&gt;$&lt;
    220 contramapB</code></pre>
<p>The first thing to notice about these numbers is that there are groups of definitions which have all been inlined the same number of times. This is indicative of a misplaced <code>INLINE</code> pragma as a large unoptimised definition will then be inlined many times and then simplified individually at each call site rather than once at the definition site. Of particular suspicion is the large block of definitions which are each inlined exactly 484 times.</p>
<p>By looking at the definitions of each of the identifiers in this list, we can then work out what is going on. To cut to the chase, inspecting the definition of <code>char7</code> from the <code>Data.ByteString.Builder.Prim.ASCII</code> module we can see where a lot of the work is coming from.</p>
<pre><code>-- | Encode the least 7-bits of a &#39;Char&#39; using the ASCII encoding.
{-# INLINE char7 #-}
char7 :: FixedPrim Char
char7 = (\c -&gt; fromIntegral $ ord c .&amp;. 0x7f) &gt;$&lt; word8</code></pre>
<p>The definition of <code>char7</code> is concise but composed of combinators which will be keen to get inlined later on. The definitions of <code>ord</code>, <code>.&amp;.</code> and <code>&gt;$&lt;</code> are all small.</p>
<p>By using an <code>INLINE</code> pragma, the unoptimised unfolding is included in the interface file so this complex definition will be inline verbatim into each call site. We can inspect the unfolding by using the <code>--show-iface</code> flag on the <code>.hi</code> file for the module.</p>
<pre><code>8334ad079da5b638008c6f8feefdfa4a
   char7 :: FixedPrim Char
   {- HasNoCafRefs, Strictness: m, Inline: INLINE (sat-args=0),
      Unfolding: InlineRule (0, False, False)
                 ($s&gt;$&lt;
                    @ Char
                    @ Word8
                    (\ (c :: Char) -&gt;
                     $ @ &#39;PtrRepLifted
                       @ Int
                       @ Word8
                       (\ (x :: Int) -&gt;
                        case x of wild { I# x# -&gt; W8# (narrow8Word# (int2Word# x#)) })
                       ($fBitsInt_$c.&amp;. (ord c) (I# 127#)))
                   word8) -}</code></pre>
<p>Which very closely resembles the source definition.</p>
<p>Removing the <code>INLINE</code> pragma we get a nice, small optimised definition which crucially is still small enough that GHC inlines it at call sites.</p>
<pre><code>5e7820a4ab4b18cf2032517105d2cc56
  char7 :: FixedPrim Char
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (FP
                   @ Char
                   1#
                   char1
                     `cast`
                   (&lt;Char&gt;_R -&gt;_R &lt;Ptr Word8&gt;_R -&gt;_R Sym (N:IO[0] &lt;()&gt;_R)))      -}</code></pre>
<p>Look! No calls to <code>&gt;$&lt;</code>, <code>.&amp;.</code>, <code>ord</code> or any other complicated functions. We have optimised the definition <em>once</em> at the definition site so that we don’t have to repeatedly do so at each call site. We didn’t even need to look at the program to spot the problem.</p>
<h1 id="discussion">Discussion</h1>
<p>This is currently a problem because <code>INLINE</code> is used for two different reasons.</p>
<ol type="1">
<li>By library authors who use <code>RULES</code> where it is important to inline the literal rhs of a definition so that the rules reliably fire.</li>
<li>By library authors who want to inline definitions so that GHC’s simplifier can work better across modules.</li>
</ol>
<p>For the first case, the unoptimised unfoldings are important but for the second this leads to a lot of duplicated work. In this case, I could see that there were no rules defined which were relevant to the definition of <code>char7</code> so I ruled out the first scenario. I then verified that GHC considered the optimised version of <code>char7</code> small enough to include in interface files and inline by using <code>--show-iface</code>. Ruling out both of these possibilities, it then seemed sensible to remove the pragma.</p>
<p>It would be good to add a new pragma which instructs GHC to inline an <em>optimised</em> unfolding across modules rather than the unoptimised version so that the second scenario can be reliably achieved.</p>
<h1 id="links">Links</h1>
<ul>
<li><a href="https://www.reddit.com/r/haskell/comments/6bojlj/inlineing_a_case_study/">Reddit Comments</a></li>
</ul>
]]></summary>
</entry>

</feed>
